//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class ClientRuntime.Indirect
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// Access to a resource was denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GlueClientTypes {

    /// Specifies configuration properties of a notification.
    public struct NotificationProperty: Swift.Sendable {
        /// After a job run starts, the number of minutes to wait before sending a job run delay notification.
        public var notifyDelayAfter: Swift.Int?

        public init(
            notifyDelayAfter: Swift.Int? = nil
        )
        {
            self.notifyDelayAfter = notifyDelayAfter
        }
    }
}

extension GlueClientTypes {

    /// Defines an action to be initiated by a trigger.
    public struct Action: Swift.Sendable {
        /// The job arguments used when this trigger fires. For this job run, they replace the default arguments set in the job definition itself. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. For information about how to specify and consume your own Job arguments, see the [Calling Glue APIs in Python](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html) topic in the developer guide. For information about the key-value pairs that Glue consumes to set up your job, see the [Special Parameters Used by Glue](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html) topic in the developer guide.
        public var arguments: [Swift.String: Swift.String]?
        /// The name of the crawler to be used with this action.
        public var crawlerName: Swift.String?
        /// The name of a job to be run.
        public var jobName: Swift.String?
        /// Specifies configuration properties of a job run notification.
        public var notificationProperty: GlueClientTypes.NotificationProperty?
        /// The name of the SecurityConfiguration structure to be used with this action.
        public var securityConfiguration: Swift.String?
        /// The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.
        public var timeout: Swift.Int?

        public init(
            arguments: [Swift.String: Swift.String]? = nil,
            crawlerName: Swift.String? = nil,
            jobName: Swift.String? = nil,
            notificationProperty: GlueClientTypes.NotificationProperty? = nil,
            securityConfiguration: Swift.String? = nil,
            timeout: Swift.Int? = nil
        )
        {
            self.arguments = arguments
            self.crawlerName = crawlerName
            self.jobName = jobName
            self.notificationProperty = notificationProperty
            self.securityConfiguration = securityConfiguration
            self.timeout = timeout
        }
    }
}

extension GlueClientTypes {

    public enum AdditionalOptionKeys: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cacheoption
        case observationsoption
        case sdkUnknown(Swift.String)

        public static var allCases: [AdditionalOptionKeys] {
            return [
                .cacheoption,
                .observationsoption
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cacheoption: return "performanceTuning.caching"
            case .observationsoption: return "observations.scope"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum AggFunction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case avg
        case count
        case countdistinct
        case first
        case kurtosis
        case last
        case max
        case min
        case skewness
        case stddevPop
        case stddevSamp
        case sum
        case sumdistinct
        case varPop
        case varSamp
        case sdkUnknown(Swift.String)

        public static var allCases: [AggFunction] {
            return [
                .avg,
                .count,
                .countdistinct,
                .first,
                .kurtosis,
                .last,
                .max,
                .min,
                .skewness,
                .stddevPop,
                .stddevSamp,
                .sum,
                .sumdistinct,
                .varPop,
                .varSamp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .avg: return "avg"
            case .count: return "count"
            case .countdistinct: return "countDistinct"
            case .first: return "first"
            case .kurtosis: return "kurtosis"
            case .last: return "last"
            case .max: return "max"
            case .min: return "min"
            case .skewness: return "skewness"
            case .stddevPop: return "stddev_pop"
            case .stddevSamp: return "stddev_samp"
            case .sum: return "sum"
            case .sumdistinct: return "sumDistinct"
            case .varPop: return "var_pop"
            case .varSamp: return "var_samp"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies the set of parameters needed to perform aggregation in the aggregate transform.
    public struct AggregateOperation: Swift.Sendable {
        /// Specifies the aggregation function to apply. Possible aggregation functions include: avg countDistinct, count, first, last, kurtosis, max, min, skewness, stddev_samp, stddev_pop, sum, sumDistinct, var_samp, var_pop
        /// This member is required.
        public var aggFunc: GlueClientTypes.AggFunction?
        /// Specifies the column on the data set on which the aggregation function will be applied.
        /// This member is required.
        public var column: [Swift.String]?

        public init(
            aggFunc: GlueClientTypes.AggFunction? = nil,
            column: [Swift.String]? = nil
        )
        {
            self.aggFunc = aggFunc
            self.column = column
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that groups rows by chosen fields and computes the aggregated value by specified function.
    public struct Aggregate: Swift.Sendable {
        /// Specifies the aggregate functions to be performed on specified fields.
        /// This member is required.
        public var aggs: [GlueClientTypes.AggregateOperation]?
        /// Specifies the fields to group by.
        /// This member is required.
        public var groups: [[Swift.String]]?
        /// Specifies the fields and rows to use as inputs for the aggregate transform.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?

        public init(
            aggs: [GlueClientTypes.AggregateOperation]? = nil,
            groups: [[Swift.String]]? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.aggs = aggs
            self.groups = groups
            self.inputs = inputs
            self.name = name
        }
    }
}

/// A resource to be created or added already exists.
public struct AlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GlueClientTypes {

    /// Specifies an optional value when connecting to the Redshift cluster.
    public struct AmazonRedshiftAdvancedOption: Swift.Sendable {
        /// The key for the additional connection option.
        public var key: Swift.String?
        /// The value for the additional connection option.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension GlueClientTypes {

    /// Specifies an option value.
    public struct Option: Swift.Sendable {
        /// Specifies the description of the option.
        public var description: Swift.String?
        /// Specifies the label of the option.
        public var label: Swift.String?
        /// Specifies the value of the option.
        public var value: Swift.String?

        public init(
            description: Swift.String? = nil,
            label: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.description = description
            self.label = label
            self.value = value
        }
    }
}

extension GlueClientTypes {

    /// Specifies an Amazon Redshift node.
    public struct AmazonRedshiftNodeData: Swift.Sendable {
        /// The access type for the Redshift connection. Can be a direct connection or catalog connections.
        public var accessType: Swift.String?
        /// Specifies how writing to a Redshift cluser will occur.
        public var action: Swift.String?
        /// Optional values when connecting to the Redshift cluster.
        public var advancedOptions: [GlueClientTypes.AmazonRedshiftAdvancedOption]?
        /// The name of the Glue Data Catalog database when working with a data catalog.
        public var catalogDatabase: GlueClientTypes.Option?
        /// The Redshift schema name when working with a data catalog.
        public var catalogRedshiftSchema: Swift.String?
        /// The database table to read from.
        public var catalogRedshiftTable: Swift.String?
        /// The Glue Data Catalog table name when working with a data catalog.
        public var catalogTable: GlueClientTypes.Option?
        /// The Glue connection to the Redshift cluster.
        public var connection: GlueClientTypes.Option?
        /// Specifies the name of the connection that is associated with the catalog table used.
        public var crawlerConnection: Swift.String?
        /// Optional. The role name use when connection to S3. The IAM role ill default to the role on the job when left blank.
        public var iamRole: GlueClientTypes.Option?
        /// The action used when to detemine how a MERGE in a Redshift sink will be handled.
        public var mergeAction: Swift.String?
        /// The SQL used in a custom merge to deal with matching records.
        public var mergeClause: Swift.String?
        /// The action used when to detemine how a MERGE in a Redshift sink will be handled when an existing record matches a new record.
        public var mergeWhenMatched: Swift.String?
        /// The action used when to detemine how a MERGE in a Redshift sink will be handled when an existing record doesn't match a new record.
        public var mergeWhenNotMatched: Swift.String?
        /// The SQL used before a MERGE or APPEND with upsert is run.
        public var postAction: Swift.String?
        /// The SQL used before a MERGE or APPEND with upsert is run.
        public var preAction: Swift.String?
        /// The SQL used to fetch the data from a Redshift sources when the SourceType is 'query'.
        public var sampleQuery: Swift.String?
        /// The Redshift schema name when working with a direct connection.
        public var schema: GlueClientTypes.Option?
        /// The list of column names used to determine a matching record when doing a MERGE or APPEND with upsert.
        public var selectedColumns: [GlueClientTypes.Option]?
        /// The source type to specify whether a specific table is the source or a custom query.
        public var sourceType: Swift.String?
        /// The name of the temporary staging table that is used when doing a MERGE or APPEND with upsert.
        public var stagingTable: Swift.String?
        /// The Redshift table name when working with a direct connection.
        public var table: GlueClientTypes.Option?
        /// Specifies the prefix to a table.
        public var tablePrefix: Swift.String?
        /// The array of schema output for a given node.
        public var tableSchema: [GlueClientTypes.Option]?
        /// The Amazon S3 path where temporary data can be staged when copying out of the database.
        public var tempDir: Swift.String?
        /// The action used on Redshift sinks when doing an APPEND.
        public var upsert: Swift.Bool

        public init(
            accessType: Swift.String? = nil,
            action: Swift.String? = nil,
            advancedOptions: [GlueClientTypes.AmazonRedshiftAdvancedOption]? = nil,
            catalogDatabase: GlueClientTypes.Option? = nil,
            catalogRedshiftSchema: Swift.String? = nil,
            catalogRedshiftTable: Swift.String? = nil,
            catalogTable: GlueClientTypes.Option? = nil,
            connection: GlueClientTypes.Option? = nil,
            crawlerConnection: Swift.String? = nil,
            iamRole: GlueClientTypes.Option? = nil,
            mergeAction: Swift.String? = nil,
            mergeClause: Swift.String? = nil,
            mergeWhenMatched: Swift.String? = nil,
            mergeWhenNotMatched: Swift.String? = nil,
            postAction: Swift.String? = nil,
            preAction: Swift.String? = nil,
            sampleQuery: Swift.String? = nil,
            schema: GlueClientTypes.Option? = nil,
            selectedColumns: [GlueClientTypes.Option]? = nil,
            sourceType: Swift.String? = nil,
            stagingTable: Swift.String? = nil,
            table: GlueClientTypes.Option? = nil,
            tablePrefix: Swift.String? = nil,
            tableSchema: [GlueClientTypes.Option]? = nil,
            tempDir: Swift.String? = nil,
            upsert: Swift.Bool = false
        )
        {
            self.accessType = accessType
            self.action = action
            self.advancedOptions = advancedOptions
            self.catalogDatabase = catalogDatabase
            self.catalogRedshiftSchema = catalogRedshiftSchema
            self.catalogRedshiftTable = catalogRedshiftTable
            self.catalogTable = catalogTable
            self.connection = connection
            self.crawlerConnection = crawlerConnection
            self.iamRole = iamRole
            self.mergeAction = mergeAction
            self.mergeClause = mergeClause
            self.mergeWhenMatched = mergeWhenMatched
            self.mergeWhenNotMatched = mergeWhenNotMatched
            self.postAction = postAction
            self.preAction = preAction
            self.sampleQuery = sampleQuery
            self.schema = schema
            self.selectedColumns = selectedColumns
            self.sourceType = sourceType
            self.stagingTable = stagingTable
            self.table = table
            self.tablePrefix = tablePrefix
            self.tableSchema = tableSchema
            self.tempDir = tempDir
            self.upsert = upsert
        }
    }
}

extension GlueClientTypes {

    /// Specifies an Amazon Redshift source.
    public struct AmazonRedshiftSource: Swift.Sendable {
        /// Specifies the data of the Amazon Reshift source node.
        public var data: GlueClientTypes.AmazonRedshiftNodeData?
        /// The name of the Amazon Redshift source.
        public var name: Swift.String?

        public init(
            data: GlueClientTypes.AmazonRedshiftNodeData? = nil,
            name: Swift.String? = nil
        )
        {
            self.data = data
            self.name = name
        }
    }
}

extension GlueClientTypes {

    /// Specifies an Amazon Redshift target.
    public struct AmazonRedshiftTarget: Swift.Sendable {
        /// Specifies the data of the Amazon Redshift target node.
        public var data: GlueClientTypes.AmazonRedshiftNodeData?
        /// The nodes that are inputs to the data target.
        public var inputs: [Swift.String]?
        /// The name of the Amazon Redshift target.
        public var name: Swift.String?

        public init(
            data: GlueClientTypes.AmazonRedshiftNodeData? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.data = data
            self.inputs = inputs
            self.name = name
        }
    }
}

extension GlueClientTypes {

    /// A failed annotation.
    public struct AnnotationError: Swift.Sendable {
        /// The reason why the annotation failed.
        public var failureReason: Swift.String?
        /// The Profile ID for the failed annotation.
        public var profileId: Swift.String?
        /// The Statistic ID for the failed annotation.
        public var statisticId: Swift.String?

        public init(
            failureReason: Swift.String? = nil,
            profileId: Swift.String? = nil,
            statisticId: Swift.String? = nil
        )
        {
            self.failureReason = failureReason
            self.profileId = profileId
            self.statisticId = statisticId
        }
    }
}

extension GlueClientTypes {

    public enum InclusionAnnotationValue: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case exclude
        case include
        case sdkUnknown(Swift.String)

        public static var allCases: [InclusionAnnotationValue] {
            return [
                .exclude,
                .include
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .exclude: return "EXCLUDE"
            case .include: return "INCLUDE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A timestamped inclusion annotation.
    public struct TimestampedInclusionAnnotation: Swift.Sendable {
        /// The timestamp when the inclusion annotation was last modified.
        public var lastModifiedOn: Foundation.Date?
        /// The inclusion annotation value.
        public var value: GlueClientTypes.InclusionAnnotationValue?

        public init(
            lastModifiedOn: Foundation.Date? = nil,
            value: GlueClientTypes.InclusionAnnotationValue? = nil
        )
        {
            self.lastModifiedOn = lastModifiedOn
            self.value = value
        }
    }
}

extension GlueClientTypes {

    /// A Statistic Annotation.
    public struct StatisticAnnotation: Swift.Sendable {
        /// The inclusion annotation applied to the statistic.
        public var inclusionAnnotation: GlueClientTypes.TimestampedInclusionAnnotation?
        /// The Profile ID.
        public var profileId: Swift.String?
        /// The Statistic ID.
        public var statisticId: Swift.String?
        /// The timestamp when the annotated statistic was recorded.
        public var statisticRecordedOn: Foundation.Date?

        public init(
            inclusionAnnotation: GlueClientTypes.TimestampedInclusionAnnotation? = nil,
            profileId: Swift.String? = nil,
            statisticId: Swift.String? = nil,
            statisticRecordedOn: Foundation.Date? = nil
        )
        {
            self.inclusionAnnotation = inclusionAnnotation
            self.profileId = profileId
            self.statisticId = statisticId
            self.statisticRecordedOn = statisticRecordedOn
        }
    }
}

extension GlueClientTypes {

    /// Specifies a single column in a Glue schema definition.
    public struct GlueStudioSchemaColumn: Swift.Sendable {
        /// The name of the column in the Glue Studio schema.
        /// This member is required.
        public var name: Swift.String?
        /// The hive type for this column in the Glue Studio schema.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }
}

extension GlueClientTypes {

    /// Specifies a user-defined schema when a schema cannot be determined by Glue.
    public struct GlueSchema: Swift.Sendable {
        /// Specifies the column definitions that make up a Glue schema.
        public var columns: [GlueClientTypes.GlueStudioSchemaColumn]?

        public init(
            columns: [GlueClientTypes.GlueStudioSchemaColumn]? = nil
        )
        {
            self.columns = columns
        }
    }
}

extension GlueClientTypes {

    /// Specifies a connector to an Amazon Athena data source.
    public struct AthenaConnectorSource: Swift.Sendable {
        /// The name of the connection that is associated with the connector.
        /// This member is required.
        public var connectionName: Swift.String?
        /// The name of the table in the data source.
        public var connectionTable: Swift.String?
        /// The type of connection, such as marketplace.athena or custom.athena, designating a connection to an Amazon Athena data store.
        /// This member is required.
        public var connectionType: Swift.String?
        /// The name of a connector that assists with accessing the data store in Glue Studio.
        /// This member is required.
        public var connectorName: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the custom Athena source.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?
        /// The name of the Cloudwatch log group to read from. For example, /aws-glue/jobs/output.
        /// This member is required.
        public var schemaName: Swift.String?

        public init(
            connectionName: Swift.String? = nil,
            connectionTable: Swift.String? = nil,
            connectionType: Swift.String? = nil,
            connectorName: Swift.String? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.connectionName = connectionName
            self.connectionTable = connectionTable
            self.connectionType = connectionType
            self.connectorName = connectorName
            self.name = name
            self.outputSchemas = outputSchemas
            self.schemaName = schemaName
        }
    }
}

extension GlueClientTypes {

    /// A structure containing the Lake Formation audit context.
    public struct AuditContext: Swift.Sendable {
        /// A string containing the additional audit context information.
        public var additionalAuditContext: Swift.String?
        /// All columns request for audit.
        public var allColumnsRequested: Swift.Bool?
        /// The requested columns for audit.
        public var requestedColumns: [Swift.String]?

        public init(
            additionalAuditContext: Swift.String? = nil,
            allColumnsRequested: Swift.Bool? = nil,
            requestedColumns: [Swift.String]? = nil
        )
        {
            self.additionalAuditContext = additionalAuditContext
            self.allColumnsRequested = allColumnsRequested
            self.requestedColumns = requestedColumns
        }
    }
}

extension GlueClientTypes {

    public enum AuthenticationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case basic
        case custom
        case oauth2
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .basic,
                .custom,
                .oauth2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .custom: return "CUSTOM"
            case .oauth2: return "OAUTH2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The OAuth2 client app used for the connection.
    public struct OAuth2ClientApplication: Swift.Sendable {
        /// The reference to the SaaS-side client app that is Amazon Web Services managed.
        public var awsManagedClientApplicationReference: Swift.String?
        /// The client application clientID if the ClientAppType is USER_MANAGED.
        public var userManagedClientApplicationClientId: Swift.String?

        public init(
            awsManagedClientApplicationReference: Swift.String? = nil,
            userManagedClientApplicationClientId: Swift.String? = nil
        )
        {
            self.awsManagedClientApplicationReference = awsManagedClientApplicationReference
            self.userManagedClientApplicationClientId = userManagedClientApplicationClientId
        }
    }
}

extension GlueClientTypes {

    public enum OAuth2GrantType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case authorizationCode
        case clientCredentials
        case jwtBearer
        case sdkUnknown(Swift.String)

        public static var allCases: [OAuth2GrantType] {
            return [
                .authorizationCode,
                .clientCredentials,
                .jwtBearer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authorizationCode: return "AUTHORIZATION_CODE"
            case .clientCredentials: return "CLIENT_CREDENTIALS"
            case .jwtBearer: return "JWT_BEARER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A structure containing properties for OAuth2 authentication.
    public struct OAuth2Properties: Swift.Sendable {
        /// The client application type. For example, AWS_MANAGED or USER_MANAGED.
        public var oAuth2ClientApplication: GlueClientTypes.OAuth2ClientApplication?
        /// The OAuth2 grant type. For example, AUTHORIZATION_CODE, JWT_BEARER, or CLIENT_CREDENTIALS.
        public var oAuth2GrantType: GlueClientTypes.OAuth2GrantType?
        /// The URL of the provider's authentication server, to exchange an authorization code for an access token.
        public var tokenUrl: Swift.String?
        /// A map of parameters that are added to the token GET request.
        public var tokenUrlParametersMap: [Swift.String: Swift.String]?

        public init(
            oAuth2ClientApplication: GlueClientTypes.OAuth2ClientApplication? = nil,
            oAuth2GrantType: GlueClientTypes.OAuth2GrantType? = nil,
            tokenUrl: Swift.String? = nil,
            tokenUrlParametersMap: [Swift.String: Swift.String]? = nil
        )
        {
            self.oAuth2ClientApplication = oAuth2ClientApplication
            self.oAuth2GrantType = oAuth2GrantType
            self.tokenUrl = tokenUrl
            self.tokenUrlParametersMap = tokenUrlParametersMap
        }
    }
}

extension GlueClientTypes {

    /// A structure containing the authentication configuration.
    public struct AuthenticationConfiguration: Swift.Sendable {
        /// A structure containing the authentication configuration.
        public var authenticationType: GlueClientTypes.AuthenticationType?
        /// The properties for OAuth2 authentication.
        public var oAuth2Properties: GlueClientTypes.OAuth2Properties?
        /// The secret manager ARN to store credentials.
        public var secretArn: Swift.String?

        public init(
            authenticationType: GlueClientTypes.AuthenticationType? = nil,
            oAuth2Properties: GlueClientTypes.OAuth2Properties? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.oAuth2Properties = oAuth2Properties
            self.secretArn = secretArn
        }
    }
}

extension GlueClientTypes {

    /// The set of properties required for the the OAuth2 AUTHORIZATION_CODE grant type workflow.
    public struct AuthorizationCodeProperties: Swift.Sendable {
        /// An authorization code to be used in the third leg of the AUTHORIZATION_CODE grant workflow. This is a single-use code which becomes invalid once exchanged for an access token, thus it is acceptable to have this value as a request parameter.
        public var authorizationCode: Swift.String?
        /// The redirect URI where the user gets redirected to by authorization server when issuing an authorization code. The URI is subsequently used when the authorization code is exchanged for an access token.
        public var redirectUri: Swift.String?

        public init(
            authorizationCode: Swift.String? = nil,
            redirectUri: Swift.String? = nil
        )
        {
            self.authorizationCode = authorizationCode
            self.redirectUri = redirectUri
        }
    }
}

extension GlueClientTypes.AuthorizationCodeProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizationCodeProperties(redirectUri: \(Swift.String(describing: redirectUri)), authorizationCode: \"CONTENT_REDACTED\")"}
}

extension GlueClientTypes {

    /// A structure containing properties for OAuth2 in the CreateConnection request.
    public struct OAuth2PropertiesInput: Swift.Sendable {
        /// The set of properties required for the the OAuth2 AUTHORIZATION_CODE grant type.
        public var authorizationCodeProperties: GlueClientTypes.AuthorizationCodeProperties?
        /// The client application type in the CreateConnection request. For example, AWS_MANAGED or USER_MANAGED.
        public var oAuth2ClientApplication: GlueClientTypes.OAuth2ClientApplication?
        /// The OAuth2 grant type in the CreateConnection request. For example, AUTHORIZATION_CODE, JWT_BEARER, or CLIENT_CREDENTIALS.
        public var oAuth2GrantType: GlueClientTypes.OAuth2GrantType?
        /// The URL of the provider's authentication server, to exchange an authorization code for an access token.
        public var tokenUrl: Swift.String?
        /// A map of parameters that are added to the token GET request.
        public var tokenUrlParametersMap: [Swift.String: Swift.String]?

        public init(
            authorizationCodeProperties: GlueClientTypes.AuthorizationCodeProperties? = nil,
            oAuth2ClientApplication: GlueClientTypes.OAuth2ClientApplication? = nil,
            oAuth2GrantType: GlueClientTypes.OAuth2GrantType? = nil,
            tokenUrl: Swift.String? = nil,
            tokenUrlParametersMap: [Swift.String: Swift.String]? = nil
        )
        {
            self.authorizationCodeProperties = authorizationCodeProperties
            self.oAuth2ClientApplication = oAuth2ClientApplication
            self.oAuth2GrantType = oAuth2GrantType
            self.tokenUrl = tokenUrl
            self.tokenUrlParametersMap = tokenUrlParametersMap
        }
    }
}

extension GlueClientTypes {

    /// A structure containing the authentication configuration in the CreateConnection request.
    public struct AuthenticationConfigurationInput: Swift.Sendable {
        /// A structure containing the authentication configuration in the CreateConnection request.
        public var authenticationType: GlueClientTypes.AuthenticationType?
        /// The properties for OAuth2 authentication in the CreateConnection request.
        public var oAuth2Properties: GlueClientTypes.OAuth2PropertiesInput?
        /// The secret manager ARN to store credentials in the CreateConnection request.
        public var secretArn: Swift.String?

        public init(
            authenticationType: GlueClientTypes.AuthenticationType? = nil,
            oAuth2Properties: GlueClientTypes.OAuth2PropertiesInput? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.oAuth2Properties = oAuth2Properties
            self.secretArn = secretArn
        }
    }
}

/// A specified entity does not exist
public struct EntityNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Indicates whether or not the exception relates to a federated source.
        public internal(set) var fromFederationSource: Swift.Bool? = nil
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fromFederationSource: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.fromFederationSource = fromFederationSource
        self.properties.message = message
    }
}

/// An encryption operation failed.
public struct GlueEncryptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GlueEncryptionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An internal service error occurred.
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input provided was not valid.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Indicates whether or not the exception relates to a federated source.
        public internal(set) var fromFederationSource: Swift.Bool? = nil
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fromFederationSource: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.fromFederationSource = fromFederationSource
        self.properties.message = message
    }
}

/// The operation timed out.
public struct OperationTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A resource numerical limit was exceeded.
public struct ResourceNumberLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNumberLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GlueClientTypes {

    /// A column in a Table.
    public struct Column: Swift.Sendable {
        /// A free-form text comment.
        public var comment: Swift.String?
        /// The name of the Column.
        /// This member is required.
        public var name: Swift.String?
        /// These key-value pairs define properties associated with the column.
        public var parameters: [Swift.String: Swift.String]?
        /// The data type of the Column.
        public var type: Swift.String?

        public init(
            comment: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.comment = comment
            self.name = name
            self.parameters = parameters
            self.type = type
        }
    }
}

extension GlueClientTypes {

    /// The unique ID of the schema in the Glue schema registry.
    public struct SchemaId: Swift.Sendable {
        /// The name of the schema registry that contains the schema.
        public var registryName: Swift.String?
        /// The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.
        public var schemaArn: Swift.String?
        /// The name of the schema. One of SchemaArn or SchemaName has to be provided.
        public var schemaName: Swift.String?

        public init(
            registryName: Swift.String? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
        }
    }
}

extension GlueClientTypes {

    /// An object that references a schema stored in the Glue Schema Registry.
    public struct SchemaReference: Swift.Sendable {
        /// A structure that contains schema identity fields. Either this or the SchemaVersionId has to be provided.
        public var schemaId: GlueClientTypes.SchemaId?
        /// The unique ID assigned to a version of the schema. Either this or the SchemaId has to be provided.
        public var schemaVersionId: Swift.String?
        /// The version number of the schema.
        public var schemaVersionNumber: Swift.Int?

        public init(
            schemaId: GlueClientTypes.SchemaId? = nil,
            schemaVersionId: Swift.String? = nil,
            schemaVersionNumber: Swift.Int? = nil
        )
        {
            self.schemaId = schemaId
            self.schemaVersionId = schemaVersionId
            self.schemaVersionNumber = schemaVersionNumber
        }
    }
}

extension GlueClientTypes {

    /// Information about a serialization/deserialization program (SerDe) that serves as an extractor and loader.
    public struct SerDeInfo: Swift.Sendable {
        /// Name of the SerDe.
        public var name: Swift.String?
        /// These key-value pairs define initialization parameters for the SerDe.
        public var parameters: [Swift.String: Swift.String]?
        /// Usually the class that implements the SerDe. An example is org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe.
        public var serializationLibrary: Swift.String?

        public init(
            name: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            serializationLibrary: Swift.String? = nil
        )
        {
            self.name = name
            self.parameters = parameters
            self.serializationLibrary = serializationLibrary
        }
    }
}

extension GlueClientTypes {

    /// Specifies skewed values in a table. Skewed values are those that occur with very high frequency.
    public struct SkewedInfo: Swift.Sendable {
        /// A list of names of columns that contain skewed values.
        public var skewedColumnNames: [Swift.String]?
        /// A mapping of skewed values to the columns that contain them.
        public var skewedColumnValueLocationMaps: [Swift.String: Swift.String]?
        /// A list of values that appear so frequently as to be considered skewed.
        public var skewedColumnValues: [Swift.String]?

        public init(
            skewedColumnNames: [Swift.String]? = nil,
            skewedColumnValueLocationMaps: [Swift.String: Swift.String]? = nil,
            skewedColumnValues: [Swift.String]? = nil
        )
        {
            self.skewedColumnNames = skewedColumnNames
            self.skewedColumnValueLocationMaps = skewedColumnValueLocationMaps
            self.skewedColumnValues = skewedColumnValues
        }
    }
}

extension GlueClientTypes {

    /// Specifies the sort order of a sorted column.
    public struct Order: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var column: Swift.String?
        /// Indicates that the column is sorted in ascending order (== 1), or in descending order (==0).
        /// This member is required.
        public var sortOrder: Swift.Int

        public init(
            column: Swift.String? = nil,
            sortOrder: Swift.Int = 0
        )
        {
            self.column = column
            self.sortOrder = sortOrder
        }
    }
}

extension GlueClientTypes {

    /// Describes the physical storage of table data.
    public struct StorageDescriptor: Swift.Sendable {
        /// A list of locations that point to the path where a Delta table is located.
        public var additionalLocations: [Swift.String]?
        /// A list of reducer grouping columns, clustering columns, and bucketing columns in the table.
        public var bucketColumns: [Swift.String]?
        /// A list of the Columns in the table.
        public var columns: [GlueClientTypes.Column]?
        /// True if the data in the table is compressed, or False if not.
        public var compressed: Swift.Bool
        /// The input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
        public var inputFormat: Swift.String?
        /// The physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
        public var location: Swift.String?
        /// Must be specified if the table contains any dimension columns.
        public var numberOfBuckets: Swift.Int
        /// The output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
        public var outputFormat: Swift.String?
        /// The user-supplied properties in key-value form.
        public var parameters: [Swift.String: Swift.String]?
        /// An object that references a schema stored in the Glue Schema Registry. When creating a table, you can pass an empty list of columns for the schema, and instead use a schema reference.
        public var schemaReference: GlueClientTypes.SchemaReference?
        /// The serialization/deserialization (SerDe) information.
        public var serdeInfo: GlueClientTypes.SerDeInfo?
        /// The information about values that appear frequently in a column (skewed values).
        public var skewedInfo: GlueClientTypes.SkewedInfo?
        /// A list specifying the sort order of each bucket in the table.
        public var sortColumns: [GlueClientTypes.Order]?
        /// True if the table data is stored in subdirectories, or False if not.
        public var storedAsSubDirectories: Swift.Bool

        public init(
            additionalLocations: [Swift.String]? = nil,
            bucketColumns: [Swift.String]? = nil,
            columns: [GlueClientTypes.Column]? = nil,
            compressed: Swift.Bool = false,
            inputFormat: Swift.String? = nil,
            location: Swift.String? = nil,
            numberOfBuckets: Swift.Int = 0,
            outputFormat: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            schemaReference: GlueClientTypes.SchemaReference? = nil,
            serdeInfo: GlueClientTypes.SerDeInfo? = nil,
            skewedInfo: GlueClientTypes.SkewedInfo? = nil,
            sortColumns: [GlueClientTypes.Order]? = nil,
            storedAsSubDirectories: Swift.Bool = false
        )
        {
            self.additionalLocations = additionalLocations
            self.bucketColumns = bucketColumns
            self.columns = columns
            self.compressed = compressed
            self.inputFormat = inputFormat
            self.location = location
            self.numberOfBuckets = numberOfBuckets
            self.outputFormat = outputFormat
            self.parameters = parameters
            self.schemaReference = schemaReference
            self.serdeInfo = serdeInfo
            self.skewedInfo = skewedInfo
            self.sortColumns = sortColumns
            self.storedAsSubDirectories = storedAsSubDirectories
        }
    }
}

extension GlueClientTypes {

    /// The structure used to create and update a partition.
    public struct PartitionInput: Swift.Sendable {
        /// The last time at which the partition was accessed.
        public var lastAccessTime: Foundation.Date?
        /// The last time at which column statistics were computed for this partition.
        public var lastAnalyzedTime: Foundation.Date?
        /// These key-value pairs define partition parameters.
        public var parameters: [Swift.String: Swift.String]?
        /// Provides information about the physical location where the partition is stored.
        public var storageDescriptor: GlueClientTypes.StorageDescriptor?
        /// The values of the partition. Although this parameter is not required by the SDK, you must specify this parameter for a valid input. The values for the keys for the new partition must be passed as an array of String objects that must be ordered in the same order as the partition keys appearing in the Amazon S3 prefix. Otherwise Glue will add the values to the wrong keys.
        public var values: [Swift.String]?

        public init(
            lastAccessTime: Foundation.Date? = nil,
            lastAnalyzedTime: Foundation.Date? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            storageDescriptor: GlueClientTypes.StorageDescriptor? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.parameters = parameters
            self.storageDescriptor = storageDescriptor
            self.values = values
        }
    }
}

public struct BatchCreatePartitionInput: Swift.Sendable {
    /// The ID of the catalog in which the partition is to be created. Currently, this should be the Amazon Web Services account ID.
    public var catalogId: Swift.String?
    /// The name of the metadata database in which the partition is to be created.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A list of PartitionInput structures that define the partitions to be created.
    /// This member is required.
    public var partitionInputList: [GlueClientTypes.PartitionInput]?
    /// The name of the metadata table in which the partition is to be created.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        partitionInputList: [GlueClientTypes.PartitionInput]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionInputList = partitionInputList
        self.tableName = tableName
    }
}

extension GlueClientTypes {

    /// Contains details about an error.
    public struct ErrorDetail: Swift.Sendable {
        /// The code associated with this error.
        public var errorCode: Swift.String?
        /// A message describing the error.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

extension GlueClientTypes {

    /// Contains information about a partition error.
    public struct PartitionError: Swift.Sendable {
        /// The details about the partition error.
        public var errorDetail: GlueClientTypes.ErrorDetail?
        /// The values that define the partition.
        public var partitionValues: [Swift.String]?

        public init(
            errorDetail: GlueClientTypes.ErrorDetail? = nil,
            partitionValues: [Swift.String]? = nil
        )
        {
            self.errorDetail = errorDetail
            self.partitionValues = partitionValues
        }
    }
}

public struct BatchCreatePartitionOutput: Swift.Sendable {
    /// The errors encountered when trying to create the requested partitions.
    public var errors: [GlueClientTypes.PartitionError]?

    public init(
        errors: [GlueClientTypes.PartitionError]? = nil
    )
    {
        self.errors = errors
    }
}

public struct BatchDeleteConnectionInput: Swift.Sendable {
    /// The ID of the Data Catalog in which the connections reside. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// A list of names of the connections to delete.
    /// This member is required.
    public var connectionNameList: [Swift.String]?

    public init(
        catalogId: Swift.String? = nil,
        connectionNameList: [Swift.String]? = nil
    )
    {
        self.catalogId = catalogId
        self.connectionNameList = connectionNameList
    }
}

public struct BatchDeleteConnectionOutput: Swift.Sendable {
    /// A map of the names of connections that were not successfully deleted to error details.
    public var errors: [Swift.String: GlueClientTypes.ErrorDetail]?
    /// A list of names of the connection definitions that were successfully deleted.
    public var succeeded: [Swift.String]?

    public init(
        errors: [Swift.String: GlueClientTypes.ErrorDetail]? = nil,
        succeeded: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.succeeded = succeeded
    }
}

extension GlueClientTypes {

    /// Contains a list of values defining partitions.
    public struct PartitionValueList: Swift.Sendable {
        /// The list of values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }
}

public struct BatchDeletePartitionInput: Swift.Sendable {
    /// The ID of the Data Catalog where the partition to be deleted resides. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the catalog database in which the table in question resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A list of PartitionInput structures that define the partitions to be deleted.
    /// This member is required.
    public var partitionsToDelete: [GlueClientTypes.PartitionValueList]?
    /// The name of the table that contains the partitions to be deleted.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        partitionsToDelete: [GlueClientTypes.PartitionValueList]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionsToDelete = partitionsToDelete
        self.tableName = tableName
    }
}

public struct BatchDeletePartitionOutput: Swift.Sendable {
    /// The errors encountered when trying to delete the requested partitions.
    public var errors: [GlueClientTypes.PartitionError]?

    public init(
        errors: [GlueClientTypes.PartitionError]? = nil
    )
    {
        self.errors = errors
    }
}

/// A resource was not ready for a transaction.
public struct ResourceNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotReadyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchDeleteTableInput: Swift.Sendable {
    /// The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the catalog database in which the tables to delete reside. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A list of the table to delete.
    /// This member is required.
    public var tablesToDelete: [Swift.String]?
    /// The transaction ID at which to delete the table contents.
    public var transactionId: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tablesToDelete: [Swift.String]? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tablesToDelete = tablesToDelete
        self.transactionId = transactionId
    }
}

extension GlueClientTypes {

    /// An error record for table operations.
    public struct TableError: Swift.Sendable {
        /// The details about the error.
        public var errorDetail: GlueClientTypes.ErrorDetail?
        /// The name of the table. For Hive compatibility, this must be entirely lowercase.
        public var tableName: Swift.String?

        public init(
            errorDetail: GlueClientTypes.ErrorDetail? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.errorDetail = errorDetail
            self.tableName = tableName
        }
    }
}

public struct BatchDeleteTableOutput: Swift.Sendable {
    /// A list of errors encountered in attempting to delete the specified tables.
    public var errors: [GlueClientTypes.TableError]?

    public init(
        errors: [GlueClientTypes.TableError]? = nil
    )
    {
        self.errors = errors
    }
}

public struct BatchDeleteTableVersionInput: Swift.Sendable {
    /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var tableName: Swift.String?
    /// A list of the IDs of versions to be deleted. A VersionId is a string representation of an integer. Each version is incremented by 1.
    /// This member is required.
    public var versionIds: [Swift.String]?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil,
        versionIds: [Swift.String]? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tableName = tableName
        self.versionIds = versionIds
    }
}

extension GlueClientTypes {

    /// An error record for table-version operations.
    public struct TableVersionError: Swift.Sendable {
        /// The details about the error.
        public var errorDetail: GlueClientTypes.ErrorDetail?
        /// The name of the table in question.
        public var tableName: Swift.String?
        /// The ID value of the version in question. A VersionID is a string representation of an integer. Each version is incremented by 1.
        public var versionId: Swift.String?

        public init(
            errorDetail: GlueClientTypes.ErrorDetail? = nil,
            tableName: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.errorDetail = errorDetail
            self.tableName = tableName
            self.versionId = versionId
        }
    }
}

public struct BatchDeleteTableVersionOutput: Swift.Sendable {
    /// A list of errors encountered while trying to delete the specified table versions.
    public var errors: [GlueClientTypes.TableVersionError]?

    public init(
        errors: [GlueClientTypes.TableVersionError]? = nil
    )
    {
        self.errors = errors
    }
}

public struct BatchGetBlueprintsInput: Swift.Sendable {
    /// Specifies whether or not to include the blueprint in the response.
    public var includeBlueprint: Swift.Bool?
    /// Specifies whether or not to include the parameters, as a JSON string, for the blueprint in the response.
    public var includeParameterSpec: Swift.Bool?
    /// A list of blueprint names.
    /// This member is required.
    public var names: [Swift.String]?

    public init(
        includeBlueprint: Swift.Bool? = nil,
        includeParameterSpec: Swift.Bool? = nil,
        names: [Swift.String]? = nil
    )
    {
        self.includeBlueprint = includeBlueprint
        self.includeParameterSpec = includeParameterSpec
        self.names = names
    }
}

extension GlueClientTypes {

    /// When there are multiple versions of a blueprint and the latest version has some errors, this attribute indicates the last successful blueprint definition that is available with the service.
    public struct LastActiveDefinition: Swift.Sendable {
        /// Specifies a path in Amazon S3 where the blueprint is published by the Glue developer.
        public var blueprintLocation: Swift.String?
        /// Specifies a path in Amazon S3 where the blueprint is copied when you create or update the blueprint.
        public var blueprintServiceLocation: Swift.String?
        /// The description of the blueprint.
        public var description: Swift.String?
        /// The date and time the blueprint was last modified.
        public var lastModifiedOn: Foundation.Date?
        /// A JSON string specifying the parameters for the blueprint.
        public var parameterSpec: Swift.String?

        public init(
            blueprintLocation: Swift.String? = nil,
            blueprintServiceLocation: Swift.String? = nil,
            description: Swift.String? = nil,
            lastModifiedOn: Foundation.Date? = nil,
            parameterSpec: Swift.String? = nil
        )
        {
            self.blueprintLocation = blueprintLocation
            self.blueprintServiceLocation = blueprintServiceLocation
            self.description = description
            self.lastModifiedOn = lastModifiedOn
            self.parameterSpec = parameterSpec
        }
    }
}

extension GlueClientTypes {

    public enum BlueprintStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [BlueprintStatus] {
            return [
                .active,
                .creating,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The details of a blueprint.
    public struct Blueprint: Swift.Sendable {
        /// Specifies the path in Amazon S3 where the blueprint is published.
        public var blueprintLocation: Swift.String?
        /// Specifies a path in Amazon S3 where the blueprint is copied when you call CreateBlueprint/UpdateBlueprint to register the blueprint in Glue.
        public var blueprintServiceLocation: Swift.String?
        /// The date and time the blueprint was registered.
        public var createdOn: Foundation.Date?
        /// The description of the blueprint.
        public var description: Swift.String?
        /// An error message.
        public var errorMessage: Swift.String?
        /// When there are multiple versions of a blueprint and the latest version has some errors, this attribute indicates the last successful blueprint definition that is available with the service.
        public var lastActiveDefinition: GlueClientTypes.LastActiveDefinition?
        /// The date and time the blueprint was last modified.
        public var lastModifiedOn: Foundation.Date?
        /// The name of the blueprint.
        public var name: Swift.String?
        /// A JSON string that indicates the list of parameter specifications for the blueprint.
        public var parameterSpec: Swift.String?
        /// The status of the blueprint registration.
        ///
        /// * Creating — The blueprint registration is in progress.
        ///
        /// * Active — The blueprint has been successfully registered.
        ///
        /// * Updating — An update to the blueprint registration is in progress.
        ///
        /// * Failed — The blueprint registration failed.
        public var status: GlueClientTypes.BlueprintStatus?

        public init(
            blueprintLocation: Swift.String? = nil,
            blueprintServiceLocation: Swift.String? = nil,
            createdOn: Foundation.Date? = nil,
            description: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            lastActiveDefinition: GlueClientTypes.LastActiveDefinition? = nil,
            lastModifiedOn: Foundation.Date? = nil,
            name: Swift.String? = nil,
            parameterSpec: Swift.String? = nil,
            status: GlueClientTypes.BlueprintStatus? = nil
        )
        {
            self.blueprintLocation = blueprintLocation
            self.blueprintServiceLocation = blueprintServiceLocation
            self.createdOn = createdOn
            self.description = description
            self.errorMessage = errorMessage
            self.lastActiveDefinition = lastActiveDefinition
            self.lastModifiedOn = lastModifiedOn
            self.name = name
            self.parameterSpec = parameterSpec
            self.status = status
        }
    }
}

public struct BatchGetBlueprintsOutput: Swift.Sendable {
    /// Returns a list of blueprint as a Blueprints object.
    public var blueprints: [GlueClientTypes.Blueprint]?
    /// Returns a list of BlueprintNames that were not found.
    public var missingBlueprints: [Swift.String]?

    public init(
        blueprints: [GlueClientTypes.Blueprint]? = nil,
        missingBlueprints: [Swift.String]? = nil
    )
    {
        self.blueprints = blueprints
        self.missingBlueprints = missingBlueprints
    }
}

public struct BatchGetCrawlersInput: Swift.Sendable {
    /// A list of crawler names, which might be the names returned from the ListCrawlers operation.
    /// This member is required.
    public var crawlerNames: [Swift.String]?

    public init(
        crawlerNames: [Swift.String]? = nil
    )
    {
        self.crawlerNames = crawlerNames
    }
}

extension GlueClientTypes {

    /// Specifies Lake Formation configuration settings for the crawler.
    public struct LakeFormationConfiguration: Swift.Sendable {
        /// Required for cross account crawls. For same account crawls as the target data, this can be left as null.
        public var accountId: Swift.String?
        /// Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.
        public var useLakeFormationCredentials: Swift.Bool?

        public init(
            accountId: Swift.String? = nil,
            useLakeFormationCredentials: Swift.Bool? = nil
        )
        {
            self.accountId = accountId
            self.useLakeFormationCredentials = useLakeFormationCredentials
        }
    }
}

extension GlueClientTypes {

    public enum LastCrawlStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [LastCrawlStatus] {
            return [
                .cancelled,
                .failed,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Status and error information about the most recent crawl.
    public struct LastCrawlInfo: Swift.Sendable {
        /// If an error occurred, the error information about the last crawl.
        public var errorMessage: Swift.String?
        /// The log group for the last crawl.
        public var logGroup: Swift.String?
        /// The log stream for the last crawl.
        public var logStream: Swift.String?
        /// The prefix for a message about this crawl.
        public var messagePrefix: Swift.String?
        /// The time at which the crawl started.
        public var startTime: Foundation.Date?
        /// Status of the last crawl.
        public var status: GlueClientTypes.LastCrawlStatus?

        public init(
            errorMessage: Swift.String? = nil,
            logGroup: Swift.String? = nil,
            logStream: Swift.String? = nil,
            messagePrefix: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            status: GlueClientTypes.LastCrawlStatus? = nil
        )
        {
            self.errorMessage = errorMessage
            self.logGroup = logGroup
            self.logStream = logStream
            self.messagePrefix = messagePrefix
            self.startTime = startTime
            self.status = status
        }
    }
}

extension GlueClientTypes {

    public enum CrawlerLineageSettings: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disable
        case enable
        case sdkUnknown(Swift.String)

        public static var allCases: [CrawlerLineageSettings] {
            return [
                .disable,
                .enable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies data lineage configuration settings for the crawler.
    public struct LineageConfiguration: Swift.Sendable {
        /// Specifies whether data lineage is enabled for the crawler. Valid values are:
        ///
        /// * ENABLE: enables data lineage for the crawler
        ///
        /// * DISABLE: disables data lineage for the crawler
        public var crawlerLineageSettings: GlueClientTypes.CrawlerLineageSettings?

        public init(
            crawlerLineageSettings: GlueClientTypes.CrawlerLineageSettings? = nil
        )
        {
            self.crawlerLineageSettings = crawlerLineageSettings
        }
    }
}

extension GlueClientTypes {

    public enum RecrawlBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case crawlEventMode
        case crawlEverything
        case crawlNewFoldersOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [RecrawlBehavior] {
            return [
                .crawlEventMode,
                .crawlEverything,
                .crawlNewFoldersOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .crawlEventMode: return "CRAWL_EVENT_MODE"
            case .crawlEverything: return "CRAWL_EVERYTHING"
            case .crawlNewFoldersOnly: return "CRAWL_NEW_FOLDERS_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// When crawling an Amazon S3 data source after the first crawl is complete, specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run. For more information, see [Incremental Crawls in Glue](https://docs.aws.amazon.com/glue/latest/dg/incremental-crawls.html) in the developer guide.
    public struct RecrawlPolicy: Swift.Sendable {
        /// Specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run. A value of CRAWL_EVERYTHING specifies crawling the entire dataset again. A value of CRAWL_NEW_FOLDERS_ONLY specifies crawling only folders that were added since the last crawler run. A value of CRAWL_EVENT_MODE specifies crawling only the changes identified by Amazon S3 events.
        public var recrawlBehavior: GlueClientTypes.RecrawlBehavior?

        public init(
            recrawlBehavior: GlueClientTypes.RecrawlBehavior? = nil
        )
        {
            self.recrawlBehavior = recrawlBehavior
        }
    }
}

extension GlueClientTypes {

    public enum ScheduleState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notScheduled
        case scheduled
        case transitioning
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduleState] {
            return [
                .notScheduled,
                .scheduled,
                .transitioning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notScheduled: return "NOT_SCHEDULED"
            case .scheduled: return "SCHEDULED"
            case .transitioning: return "TRANSITIONING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A scheduling object using a cron statement to schedule an event.
    public struct Schedule: Swift.Sendable {
        /// A cron expression used to specify the schedule (see [Time-Based Schedules for Jobs and Crawlers](https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html). For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public var scheduleExpression: Swift.String?
        /// The state of the schedule.
        public var state: GlueClientTypes.ScheduleState?

        public init(
            scheduleExpression: Swift.String? = nil,
            state: GlueClientTypes.ScheduleState? = nil
        )
        {
            self.scheduleExpression = scheduleExpression
            self.state = state
        }
    }
}

extension GlueClientTypes {

    public enum DeleteBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleteFromDatabase
        case deprecateInDatabase
        case log
        case sdkUnknown(Swift.String)

        public static var allCases: [DeleteBehavior] {
            return [
                .deleteFromDatabase,
                .deprecateInDatabase,
                .log
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleteFromDatabase: return "DELETE_FROM_DATABASE"
            case .deprecateInDatabase: return "DEPRECATE_IN_DATABASE"
            case .log: return "LOG"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum UpdateBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case log
        case updateInDatabase
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateBehavior] {
            return [
                .log,
                .updateInDatabase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .log: return "LOG"
            case .updateInDatabase: return "UPDATE_IN_DATABASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A policy that specifies update and deletion behaviors for the crawler.
    public struct SchemaChangePolicy: Swift.Sendable {
        /// The deletion behavior when the crawler finds a deleted object.
        public var deleteBehavior: GlueClientTypes.DeleteBehavior?
        /// The update behavior when the crawler finds a changed schema.
        public var updateBehavior: GlueClientTypes.UpdateBehavior?

        public init(
            deleteBehavior: GlueClientTypes.DeleteBehavior? = nil,
            updateBehavior: GlueClientTypes.UpdateBehavior? = nil
        )
        {
            self.deleteBehavior = deleteBehavior
            self.updateBehavior = updateBehavior
        }
    }
}

extension GlueClientTypes {

    public enum CrawlerState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ready
        case running
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [CrawlerState] {
            return [
                .ready,
                .running,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ready: return "READY"
            case .running: return "RUNNING"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies an Glue Data Catalog target.
    public struct CatalogTarget: Swift.Sendable {
        /// The name of the connection for an Amazon S3-backed Data Catalog table to be a target of the crawl when using a Catalog connection type paired with a NETWORK Connection type.
        public var connectionName: Swift.String?
        /// The name of the database to be synchronized.
        /// This member is required.
        public var databaseName: Swift.String?
        /// A valid Amazon dead-letter SQS ARN. For example, arn:aws:sqs:region:account:deadLetterQueue.
        public var dlqEventQueueArn: Swift.String?
        /// A valid Amazon SQS ARN. For example, arn:aws:sqs:region:account:sqs.
        public var eventQueueArn: Swift.String?
        /// A list of the tables to be synchronized.
        /// This member is required.
        public var tables: [Swift.String]?

        public init(
            connectionName: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dlqEventQueueArn: Swift.String? = nil,
            eventQueueArn: Swift.String? = nil,
            tables: [Swift.String]? = nil
        )
        {
            self.connectionName = connectionName
            self.databaseName = databaseName
            self.dlqEventQueueArn = dlqEventQueueArn
            self.eventQueueArn = eventQueueArn
            self.tables = tables
        }
    }
}

extension GlueClientTypes {

    /// Specifies a Delta data store to crawl one or more Delta tables.
    public struct DeltaTarget: Swift.Sendable {
        /// The name of the connection to use to connect to the Delta table target.
        public var connectionName: Swift.String?
        /// Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.
        public var createNativeDeltaTable: Swift.Bool?
        /// A list of the Amazon S3 paths to the Delta tables.
        public var deltaTables: [Swift.String]?
        /// Specifies whether to write the manifest files to the Delta table path.
        public var writeManifest: Swift.Bool?

        public init(
            connectionName: Swift.String? = nil,
            createNativeDeltaTable: Swift.Bool? = nil,
            deltaTables: [Swift.String]? = nil,
            writeManifest: Swift.Bool? = nil
        )
        {
            self.connectionName = connectionName
            self.createNativeDeltaTable = createNativeDeltaTable
            self.deltaTables = deltaTables
            self.writeManifest = writeManifest
        }
    }
}

extension GlueClientTypes {

    /// Specifies an Amazon DynamoDB table to crawl.
    public struct DynamoDBTarget: Swift.Sendable {
        /// The name of the DynamoDB table to crawl.
        public var path: Swift.String?
        /// Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table. A value of true means to scan all records, while a value of false means to sample the records. If no value is specified, the value defaults to true.
        public var scanAll: Swift.Bool?
        /// The percentage of the configured read capacity units to use by the Glue crawler. Read capacity units is a term defined by DynamoDB, and is a numeric value that acts as rate limiter for the number of reads that can be performed on that table per second. The valid values are null or a value between 0.1 to 1.5. A null value is used when user does not provide a value, and defaults to 0.5 of the configured Read Capacity Unit (for provisioned tables), or 0.25 of the max configured Read Capacity Unit (for tables using on-demand mode).
        public var scanRate: Swift.Double?

        public init(
            path: Swift.String? = nil,
            scanAll: Swift.Bool? = nil,
            scanRate: Swift.Double? = nil
        )
        {
            self.path = path
            self.scanAll = scanAll
            self.scanRate = scanRate
        }
    }
}

extension GlueClientTypes {

    /// Specifies an Apache Hudi data source.
    public struct HudiTarget: Swift.Sendable {
        /// The name of the connection to use to connect to the Hudi target. If your Hudi files are stored in buckets that require VPC authorization, you can set their connection properties here.
        public var connectionName: Swift.String?
        /// A list of glob patterns used to exclude from the crawl. For more information, see [Catalog Tables with a Crawler](https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html).
        public var exclusions: [Swift.String]?
        /// The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Hudi metadata folder in your Amazon S3 path. Used to limit the crawler run time.
        public var maximumTraversalDepth: Swift.Int?
        /// An array of Amazon S3 location strings for Hudi, each indicating the root folder with which the metadata files for a Hudi table resides. The Hudi folder may be located in a child folder of the root folder. The crawler will scan all folders underneath a path for a Hudi folder.
        public var paths: [Swift.String]?

        public init(
            connectionName: Swift.String? = nil,
            exclusions: [Swift.String]? = nil,
            maximumTraversalDepth: Swift.Int? = nil,
            paths: [Swift.String]? = nil
        )
        {
            self.connectionName = connectionName
            self.exclusions = exclusions
            self.maximumTraversalDepth = maximumTraversalDepth
            self.paths = paths
        }
    }
}

extension GlueClientTypes {

    /// Specifies an Apache Iceberg data source where Iceberg tables are stored in Amazon S3.
    public struct IcebergTarget: Swift.Sendable {
        /// The name of the connection to use to connect to the Iceberg target.
        public var connectionName: Swift.String?
        /// A list of glob patterns used to exclude from the crawl. For more information, see [Catalog Tables with a Crawler](https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html).
        public var exclusions: [Swift.String]?
        /// The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Iceberg metadata folder in your Amazon S3 path. Used to limit the crawler run time.
        public var maximumTraversalDepth: Swift.Int?
        /// One or more Amazon S3 paths that contains Iceberg metadata folders as s3://bucket/prefix.
        public var paths: [Swift.String]?

        public init(
            connectionName: Swift.String? = nil,
            exclusions: [Swift.String]? = nil,
            maximumTraversalDepth: Swift.Int? = nil,
            paths: [Swift.String]? = nil
        )
        {
            self.connectionName = connectionName
            self.exclusions = exclusions
            self.maximumTraversalDepth = maximumTraversalDepth
            self.paths = paths
        }
    }
}

extension GlueClientTypes {

    public enum JdbcMetadataEntry: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case comments
        case rawtypes
        case sdkUnknown(Swift.String)

        public static var allCases: [JdbcMetadataEntry] {
            return [
                .comments,
                .rawtypes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .comments: return "COMMENTS"
            case .rawtypes: return "RAWTYPES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies a JDBC data store to crawl.
    public struct JdbcTarget: Swift.Sendable {
        /// The name of the connection to use to connect to the JDBC target.
        public var connectionName: Swift.String?
        /// Specify a value of RAWTYPES or COMMENTS to enable additional metadata in table responses. RAWTYPES provides the native-level datatype. COMMENTS provides comments associated with a column or table in the database. If you do not need additional metadata, keep the field empty.
        public var enableAdditionalMetadata: [GlueClientTypes.JdbcMetadataEntry]?
        /// A list of glob patterns used to exclude from the crawl. For more information, see [Catalog Tables with a Crawler](https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html).
        public var exclusions: [Swift.String]?
        /// The path of the JDBC target.
        public var path: Swift.String?

        public init(
            connectionName: Swift.String? = nil,
            enableAdditionalMetadata: [GlueClientTypes.JdbcMetadataEntry]? = nil,
            exclusions: [Swift.String]? = nil,
            path: Swift.String? = nil
        )
        {
            self.connectionName = connectionName
            self.enableAdditionalMetadata = enableAdditionalMetadata
            self.exclusions = exclusions
            self.path = path
        }
    }
}

extension GlueClientTypes {

    /// Specifies an Amazon DocumentDB or MongoDB data store to crawl.
    public struct MongoDBTarget: Swift.Sendable {
        /// The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.
        public var connectionName: Swift.String?
        /// The path of the Amazon DocumentDB or MongoDB target (database/collection).
        public var path: Swift.String?
        /// Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table. A value of true means to scan all records, while a value of false means to sample the records. If no value is specified, the value defaults to true.
        public var scanAll: Swift.Bool?

        public init(
            connectionName: Swift.String? = nil,
            path: Swift.String? = nil,
            scanAll: Swift.Bool? = nil
        )
        {
            self.connectionName = connectionName
            self.path = path
            self.scanAll = scanAll
        }
    }
}

extension GlueClientTypes {

    /// Specifies a data store in Amazon Simple Storage Service (Amazon S3).
    public struct S3Target: Swift.Sendable {
        /// The name of a connection which allows a job or crawler to access data in Amazon S3 within an Amazon Virtual Private Cloud environment (Amazon VPC).
        public var connectionName: Swift.String?
        /// A valid Amazon dead-letter SQS ARN. For example, arn:aws:sqs:region:account:deadLetterQueue.
        public var dlqEventQueueArn: Swift.String?
        /// A valid Amazon SQS ARN. For example, arn:aws:sqs:region:account:sqs.
        public var eventQueueArn: Swift.String?
        /// A list of glob patterns used to exclude from the crawl. For more information, see [Catalog Tables with a Crawler](https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html).
        public var exclusions: [Swift.String]?
        /// The path to the Amazon S3 target.
        public var path: Swift.String?
        /// Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
        public var sampleSize: Swift.Int?

        public init(
            connectionName: Swift.String? = nil,
            dlqEventQueueArn: Swift.String? = nil,
            eventQueueArn: Swift.String? = nil,
            exclusions: [Swift.String]? = nil,
            path: Swift.String? = nil,
            sampleSize: Swift.Int? = nil
        )
        {
            self.connectionName = connectionName
            self.dlqEventQueueArn = dlqEventQueueArn
            self.eventQueueArn = eventQueueArn
            self.exclusions = exclusions
            self.path = path
            self.sampleSize = sampleSize
        }
    }
}

extension GlueClientTypes {

    /// Specifies data stores to crawl.
    public struct CrawlerTargets: Swift.Sendable {
        /// Specifies Glue Data Catalog targets.
        public var catalogTargets: [GlueClientTypes.CatalogTarget]?
        /// Specifies Delta data store targets.
        public var deltaTargets: [GlueClientTypes.DeltaTarget]?
        /// Specifies Amazon DynamoDB targets.
        public var dynamoDBTargets: [GlueClientTypes.DynamoDBTarget]?
        /// Specifies Apache Hudi data store targets.
        public var hudiTargets: [GlueClientTypes.HudiTarget]?
        /// Specifies Apache Iceberg data store targets.
        public var icebergTargets: [GlueClientTypes.IcebergTarget]?
        /// Specifies JDBC targets.
        public var jdbcTargets: [GlueClientTypes.JdbcTarget]?
        /// Specifies Amazon DocumentDB or MongoDB targets.
        public var mongoDBTargets: [GlueClientTypes.MongoDBTarget]?
        /// Specifies Amazon Simple Storage Service (Amazon S3) targets.
        public var s3Targets: [GlueClientTypes.S3Target]?

        public init(
            catalogTargets: [GlueClientTypes.CatalogTarget]? = nil,
            deltaTargets: [GlueClientTypes.DeltaTarget]? = nil,
            dynamoDBTargets: [GlueClientTypes.DynamoDBTarget]? = nil,
            hudiTargets: [GlueClientTypes.HudiTarget]? = nil,
            icebergTargets: [GlueClientTypes.IcebergTarget]? = nil,
            jdbcTargets: [GlueClientTypes.JdbcTarget]? = nil,
            mongoDBTargets: [GlueClientTypes.MongoDBTarget]? = nil,
            s3Targets: [GlueClientTypes.S3Target]? = nil
        )
        {
            self.catalogTargets = catalogTargets
            self.deltaTargets = deltaTargets
            self.dynamoDBTargets = dynamoDBTargets
            self.hudiTargets = hudiTargets
            self.icebergTargets = icebergTargets
            self.jdbcTargets = jdbcTargets
            self.mongoDBTargets = mongoDBTargets
            self.s3Targets = s3Targets
        }
    }
}

extension GlueClientTypes {

    /// Specifies a crawler program that examines a data source and uses classifiers to try to determine its schema. If successful, the crawler records metadata concerning the data source in the Glue Data Catalog.
    public struct Crawler: Swift.Sendable {
        /// A list of UTF-8 strings that specify the custom classifiers that are associated with the crawler.
        public var classifiers: [Swift.String]?
        /// Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see [Setting crawler configuration options](https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html).
        public var configuration: Swift.String?
        /// If the crawler is running, contains the total time elapsed since the last crawl began.
        public var crawlElapsedTime: Swift.Int
        /// The name of the SecurityConfiguration structure to be used by this crawler.
        public var crawlerSecurityConfiguration: Swift.String?
        /// The time that the crawler was created.
        public var creationTime: Foundation.Date?
        /// The name of the database in which the crawler's output is stored.
        public var databaseName: Swift.String?
        /// A description of the crawler.
        public var description: Swift.String?
        /// Specifies whether the crawler should use Lake Formation credentials for the crawler instead of the IAM role credentials.
        public var lakeFormationConfiguration: GlueClientTypes.LakeFormationConfiguration?
        /// The status of the last crawl, and potentially error information if an error occurred.
        public var lastCrawl: GlueClientTypes.LastCrawlInfo?
        /// The time that the crawler was last updated.
        public var lastUpdated: Foundation.Date?
        /// A configuration that specifies whether data lineage is enabled for the crawler.
        public var lineageConfiguration: GlueClientTypes.LineageConfiguration?
        /// The name of the crawler.
        public var name: Swift.String?
        /// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.
        public var recrawlPolicy: GlueClientTypes.RecrawlPolicy?
        /// The Amazon Resource Name (ARN) of an IAM role that's used to access customer resources, such as Amazon Simple Storage Service (Amazon S3) data.
        public var role: Swift.String?
        /// For scheduled crawlers, the schedule when the crawler runs.
        public var schedule: GlueClientTypes.Schedule?
        /// The policy that specifies update and delete behaviors for the crawler.
        public var schemaChangePolicy: GlueClientTypes.SchemaChangePolicy?
        /// Indicates whether the crawler is running, or whether a run is pending.
        public var state: GlueClientTypes.CrawlerState?
        /// The prefix added to the names of tables that are created.
        public var tablePrefix: Swift.String?
        /// A collection of targets to crawl.
        public var targets: GlueClientTypes.CrawlerTargets?
        /// The version of the crawler.
        public var version: Swift.Int

        public init(
            classifiers: [Swift.String]? = nil,
            configuration: Swift.String? = nil,
            crawlElapsedTime: Swift.Int = 0,
            crawlerSecurityConfiguration: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            databaseName: Swift.String? = nil,
            description: Swift.String? = nil,
            lakeFormationConfiguration: GlueClientTypes.LakeFormationConfiguration? = nil,
            lastCrawl: GlueClientTypes.LastCrawlInfo? = nil,
            lastUpdated: Foundation.Date? = nil,
            lineageConfiguration: GlueClientTypes.LineageConfiguration? = nil,
            name: Swift.String? = nil,
            recrawlPolicy: GlueClientTypes.RecrawlPolicy? = nil,
            role: Swift.String? = nil,
            schedule: GlueClientTypes.Schedule? = nil,
            schemaChangePolicy: GlueClientTypes.SchemaChangePolicy? = nil,
            state: GlueClientTypes.CrawlerState? = nil,
            tablePrefix: Swift.String? = nil,
            targets: GlueClientTypes.CrawlerTargets? = nil,
            version: Swift.Int = 0
        )
        {
            self.classifiers = classifiers
            self.configuration = configuration
            self.crawlElapsedTime = crawlElapsedTime
            self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.description = description
            self.lakeFormationConfiguration = lakeFormationConfiguration
            self.lastCrawl = lastCrawl
            self.lastUpdated = lastUpdated
            self.lineageConfiguration = lineageConfiguration
            self.name = name
            self.recrawlPolicy = recrawlPolicy
            self.role = role
            self.schedule = schedule
            self.schemaChangePolicy = schemaChangePolicy
            self.state = state
            self.tablePrefix = tablePrefix
            self.targets = targets
            self.version = version
        }
    }
}

public struct BatchGetCrawlersOutput: Swift.Sendable {
    /// A list of crawler definitions.
    public var crawlers: [GlueClientTypes.Crawler]?
    /// A list of names of crawlers that were not found.
    public var crawlersNotFound: [Swift.String]?

    public init(
        crawlers: [GlueClientTypes.Crawler]? = nil,
        crawlersNotFound: [Swift.String]? = nil
    )
    {
        self.crawlers = crawlers
        self.crawlersNotFound = crawlersNotFound
    }
}

public struct BatchGetCustomEntityTypesInput: Swift.Sendable {
    /// A list of names of the custom patterns that you want to retrieve.
    /// This member is required.
    public var names: [Swift.String]?

    public init(
        names: [Swift.String]? = nil
    )
    {
        self.names = names
    }
}

extension GlueClientTypes {

    /// An object representing a custom pattern for detecting sensitive data across the columns and rows of your structured data.
    public struct CustomEntityType: Swift.Sendable {
        /// A list of context words. If none of these context words are found within the vicinity of the regular expression the data will not be detected as sensitive data. If no context words are passed only a regular expression is checked.
        public var contextWords: [Swift.String]?
        /// A name for the custom pattern that allows it to be retrieved or deleted later. This name must be unique per Amazon Web Services account.
        /// This member is required.
        public var name: Swift.String?
        /// A regular expression string that is used for detecting sensitive data in a custom pattern.
        /// This member is required.
        public var regexString: Swift.String?

        public init(
            contextWords: [Swift.String]? = nil,
            name: Swift.String? = nil,
            regexString: Swift.String? = nil
        )
        {
            self.contextWords = contextWords
            self.name = name
            self.regexString = regexString
        }
    }
}

public struct BatchGetCustomEntityTypesOutput: Swift.Sendable {
    /// A list of CustomEntityType objects representing the custom patterns that have been created.
    public var customEntityTypes: [GlueClientTypes.CustomEntityType]?
    /// A list of the names of custom patterns that were not found.
    public var customEntityTypesNotFound: [Swift.String]?

    public init(
        customEntityTypes: [GlueClientTypes.CustomEntityType]? = nil,
        customEntityTypesNotFound: [Swift.String]? = nil
    )
    {
        self.customEntityTypes = customEntityTypes
        self.customEntityTypesNotFound = customEntityTypesNotFound
    }
}

public struct BatchGetDataQualityResultInput: Swift.Sendable {
    /// A list of unique result IDs for the data quality results.
    /// This member is required.
    public var resultIds: [Swift.String]?

    public init(
        resultIds: [Swift.String]? = nil
    )
    {
        self.resultIds = resultIds
    }
}

extension GlueClientTypes {

    /// Describes the result of the evaluation of a data quality analyzer.
    public struct DataQualityAnalyzerResult: Swift.Sendable {
        /// A description of the data quality analyzer.
        public var description: Swift.String?
        /// A map of metrics associated with the evaluation of the analyzer.
        public var evaluatedMetrics: [Swift.String: Swift.Double]?
        /// An evaluation message.
        public var evaluationMessage: Swift.String?
        /// The name of the data quality analyzer.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            evaluatedMetrics: [Swift.String: Swift.Double]? = nil,
            evaluationMessage: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.evaluatedMetrics = evaluatedMetrics
            self.evaluationMessage = evaluationMessage
            self.name = name
        }
    }
}

extension GlueClientTypes.DataQualityAnalyzerResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataQualityAnalyzerResult(name: \(Swift.String(describing: name)), description: \"CONTENT_REDACTED\", evaluatedMetrics: \"CONTENT_REDACTED\", evaluationMessage: \"CONTENT_REDACTED\")"}
}

extension GlueClientTypes {

    /// The database and table in the Glue Data Catalog that is used for input or output data.
    public struct GlueTable: Swift.Sendable {
        /// Additional options for the table. Currently there are two keys supported:
        ///
        /// * pushDownPredicate: to filter on partitions without having to list and read all the files in your dataset.
        ///
        /// * catalogPartitionPredicate: to use server-side partition pruning using partition indexes in the Glue Data Catalog.
        public var additionalOptions: [Swift.String: Swift.String]?
        /// A unique identifier for the Glue Data Catalog.
        public var catalogId: Swift.String?
        /// The name of the connection to the Glue Data Catalog.
        public var connectionName: Swift.String?
        /// A database name in the Glue Data Catalog.
        /// This member is required.
        public var databaseName: Swift.String?
        /// A table name in the Glue Data Catalog.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            additionalOptions: [Swift.String: Swift.String]? = nil,
            catalogId: Swift.String? = nil,
            connectionName: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.additionalOptions = additionalOptions
            self.catalogId = catalogId
            self.connectionName = connectionName
            self.databaseName = databaseName
            self.tableName = tableName
        }
    }
}

extension GlueClientTypes {

    /// A data source (an Glue table) for which you want data quality results.
    public struct DataSource: Swift.Sendable {
        /// An Glue table.
        /// This member is required.
        public var glueTable: GlueClientTypes.GlueTable?

        public init(
            glueTable: GlueClientTypes.GlueTable? = nil
        )
        {
            self.glueTable = glueTable
        }
    }
}

extension GlueClientTypes {

    /// Describes the data quality metric value according to the analysis of historical data.
    public struct DataQualityMetricValues: Swift.Sendable {
        /// The actual value of the data quality metric.
        public var actualValue: Swift.Double?
        /// The expected value of the data quality metric according to the analysis of historical data.
        public var expectedValue: Swift.Double?
        /// The lower limit of the data quality metric value according to the analysis of historical data.
        public var lowerLimit: Swift.Double?
        /// The upper limit of the data quality metric value according to the analysis of historical data.
        public var upperLimit: Swift.Double?

        public init(
            actualValue: Swift.Double? = nil,
            expectedValue: Swift.Double? = nil,
            lowerLimit: Swift.Double? = nil,
            upperLimit: Swift.Double? = nil
        )
        {
            self.actualValue = actualValue
            self.expectedValue = expectedValue
            self.lowerLimit = lowerLimit
            self.upperLimit = upperLimit
        }
    }
}

extension GlueClientTypes {

    /// Describes the metric based observation generated based on evaluated data quality metrics.
    public struct MetricBasedObservation: Swift.Sendable {
        /// The name of the data quality metric used for generating the observation.
        public var metricName: Swift.String?
        /// An object of type DataQualityMetricValues representing the analysis of the data quality metric value.
        public var metricValues: GlueClientTypes.DataQualityMetricValues?
        /// A list of new data quality rules generated as part of the observation based on the data quality metric value.
        public var newRules: [Swift.String]?
        /// The Statistic ID.
        public var statisticId: Swift.String?

        public init(
            metricName: Swift.String? = nil,
            metricValues: GlueClientTypes.DataQualityMetricValues? = nil,
            newRules: [Swift.String]? = nil,
            statisticId: Swift.String? = nil
        )
        {
            self.metricName = metricName
            self.metricValues = metricValues
            self.newRules = newRules
            self.statisticId = statisticId
        }
    }
}

extension GlueClientTypes {

    /// Describes the observation generated after evaluating the rules and analyzers.
    public struct DataQualityObservation: Swift.Sendable {
        /// A description of the data quality observation.
        public var description: Swift.String?
        /// An object of type MetricBasedObservation representing the observation that is based on evaluated data quality metrics.
        public var metricBasedObservation: GlueClientTypes.MetricBasedObservation?

        public init(
            description: Swift.String? = nil,
            metricBasedObservation: GlueClientTypes.MetricBasedObservation? = nil
        )
        {
            self.description = description
            self.metricBasedObservation = metricBasedObservation
        }
    }
}

extension GlueClientTypes.DataQualityObservation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataQualityObservation(metricBasedObservation: \(Swift.String(describing: metricBasedObservation)), description: \"CONTENT_REDACTED\")"}
}

extension GlueClientTypes {

    public enum DataQualityRuleResultStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case fail
        case pass
        case sdkUnknown(Swift.String)

        public static var allCases: [DataQualityRuleResultStatus] {
            return [
                .error,
                .fail,
                .pass
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Describes the result of the evaluation of a data quality rule.
    public struct DataQualityRuleResult: Swift.Sendable {
        /// A description of the data quality rule.
        public var description: Swift.String?
        /// A map of metrics associated with the evaluation of the rule.
        public var evaluatedMetrics: [Swift.String: Swift.Double]?
        /// The evaluated rule.
        public var evaluatedRule: Swift.String?
        /// An evaluation message.
        public var evaluationMessage: Swift.String?
        /// The name of the data quality rule.
        public var name: Swift.String?
        /// A pass or fail status for the rule.
        public var result: GlueClientTypes.DataQualityRuleResultStatus?

        public init(
            description: Swift.String? = nil,
            evaluatedMetrics: [Swift.String: Swift.Double]? = nil,
            evaluatedRule: Swift.String? = nil,
            evaluationMessage: Swift.String? = nil,
            name: Swift.String? = nil,
            result: GlueClientTypes.DataQualityRuleResultStatus? = nil
        )
        {
            self.description = description
            self.evaluatedMetrics = evaluatedMetrics
            self.evaluatedRule = evaluatedRule
            self.evaluationMessage = evaluationMessage
            self.name = name
            self.result = result
        }
    }
}

extension GlueClientTypes.DataQualityRuleResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataQualityRuleResult(name: \(Swift.String(describing: name)), result: \(Swift.String(describing: result)), description: \"CONTENT_REDACTED\", evaluatedMetrics: \"CONTENT_REDACTED\", evaluatedRule: \"CONTENT_REDACTED\", evaluationMessage: \"CONTENT_REDACTED\")"}
}

extension GlueClientTypes {

    /// Describes a data quality result.
    public struct DataQualityResult: Swift.Sendable {
        /// A list of DataQualityAnalyzerResult objects representing the results for each analyzer.
        public var analyzerResults: [GlueClientTypes.DataQualityAnalyzerResult]?
        /// The date and time when this data quality run completed.
        public var completedOn: Foundation.Date?
        /// The table associated with the data quality result, if any.
        public var dataSource: GlueClientTypes.DataSource?
        /// In the context of a job in Glue Studio, each node in the canvas is typically assigned some sort of name and data quality nodes will have names. In the case of multiple nodes, the evaluationContext can differentiate the nodes.
        public var evaluationContext: Swift.String?
        /// The job name associated with the data quality result, if any.
        public var jobName: Swift.String?
        /// The job run ID associated with the data quality result, if any.
        public var jobRunId: Swift.String?
        /// A list of DataQualityObservation objects representing the observations generated after evaluating the rules and analyzers.
        public var observations: [GlueClientTypes.DataQualityObservation]?
        /// The Profile ID for the data quality result.
        public var profileId: Swift.String?
        /// A unique result ID for the data quality result.
        public var resultId: Swift.String?
        /// A list of DataQualityRuleResult objects representing the results for each rule.
        public var ruleResults: [GlueClientTypes.DataQualityRuleResult]?
        /// The unique run ID for the ruleset evaluation for this data quality result.
        public var rulesetEvaluationRunId: Swift.String?
        /// The name of the ruleset associated with the data quality result.
        public var rulesetName: Swift.String?
        /// An aggregate data quality score. Represents the ratio of rules that passed to the total number of rules.
        public var score: Swift.Double?
        /// The date and time when this data quality run started.
        public var startedOn: Foundation.Date?

        public init(
            analyzerResults: [GlueClientTypes.DataQualityAnalyzerResult]? = nil,
            completedOn: Foundation.Date? = nil,
            dataSource: GlueClientTypes.DataSource? = nil,
            evaluationContext: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobRunId: Swift.String? = nil,
            observations: [GlueClientTypes.DataQualityObservation]? = nil,
            profileId: Swift.String? = nil,
            resultId: Swift.String? = nil,
            ruleResults: [GlueClientTypes.DataQualityRuleResult]? = nil,
            rulesetEvaluationRunId: Swift.String? = nil,
            rulesetName: Swift.String? = nil,
            score: Swift.Double? = nil,
            startedOn: Foundation.Date? = nil
        )
        {
            self.analyzerResults = analyzerResults
            self.completedOn = completedOn
            self.dataSource = dataSource
            self.evaluationContext = evaluationContext
            self.jobName = jobName
            self.jobRunId = jobRunId
            self.observations = observations
            self.profileId = profileId
            self.resultId = resultId
            self.ruleResults = ruleResults
            self.rulesetEvaluationRunId = rulesetEvaluationRunId
            self.rulesetName = rulesetName
            self.score = score
            self.startedOn = startedOn
        }
    }
}

public struct BatchGetDataQualityResultOutput: Swift.Sendable {
    /// A list of DataQualityResult objects representing the data quality results.
    /// This member is required.
    public var results: [GlueClientTypes.DataQualityResult]?
    /// A list of result IDs for which results were not found.
    public var resultsNotFound: [Swift.String]?

    public init(
        results: [GlueClientTypes.DataQualityResult]? = nil,
        resultsNotFound: [Swift.String]? = nil
    )
    {
        self.results = results
        self.resultsNotFound = resultsNotFound
    }
}

public struct BatchGetDevEndpointsInput: Swift.Sendable {
    /// The list of DevEndpoint names, which might be the names returned from the ListDevEndpoint operation.
    /// This member is required.
    public var devEndpointNames: [Swift.String]?

    public init(
        devEndpointNames: [Swift.String]? = nil
    )
    {
        self.devEndpointNames = devEndpointNames
    }
}

extension GlueClientTypes {

    public enum WorkerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case g025x
        case g1x
        case g2x
        case g4x
        case g8x
        case standard
        case z2x
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkerType] {
            return [
                .g025x,
                .g1x,
                .g2x,
                .g4x,
                .g8x,
                .standard,
                .z2x
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .g025x: return "G.025X"
            case .g1x: return "G.1X"
            case .g2x: return "G.2X"
            case .g4x: return "G.4X"
            case .g8x: return "G.8X"
            case .standard: return "Standard"
            case .z2x: return "Z.2X"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A development endpoint where a developer can remotely debug extract, transform, and load (ETL) scripts.
    public struct DevEndpoint: Swift.Sendable {
        /// A map of arguments used to configure the DevEndpoint. Valid arguments are:
        ///
        /// * "--enable-glue-datacatalog": ""
        ///
        ///
        /// You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
        public var arguments: [Swift.String: Swift.String]?
        /// The Amazon Web Services Availability Zone where this DevEndpoint is located.
        public var availabilityZone: Swift.String?
        /// The point in time at which this DevEndpoint was created.
        public var createdTimestamp: Foundation.Date?
        /// The name of the DevEndpoint.
        public var endpointName: Swift.String?
        /// The path to one or more Java .jar files in an S3 bucket that should be loaded in your DevEndpoint. You can only use pure Java/Scala libraries with a DevEndpoint.
        public var extraJarsS3Path: Swift.String?
        /// The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma. You can only use pure Python libraries with a DevEndpoint. Libraries that rely on C extensions, such as the [pandas](http://pandas.pydata.org/) Python data analysis library, are not currently supported.
        public var extraPythonLibsS3Path: Swift.String?
        /// The reason for a current failure in this DevEndpoint.
        public var failureReason: Swift.String?
        /// Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints. For more information about the available Glue versions and corresponding Spark and Python versions, see [Glue version](https://docs.aws.amazon.com/glue/latest/dg/add-job.html) in the developer guide. Development endpoints that are created without specifying a Glue version default to Glue 0.9. You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
        public var glueVersion: Swift.String?
        /// The point in time at which this DevEndpoint was last modified.
        public var lastModifiedTimestamp: Foundation.Date?
        /// The status of the last update.
        public var lastUpdateStatus: Swift.String?
        /// The number of Glue Data Processing Units (DPUs) allocated to this DevEndpoint.
        public var numberOfNodes: Swift.Int
        /// The number of workers of a defined workerType that are allocated to the development endpoint. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X.
        public var numberOfWorkers: Swift.Int?
        /// A private IP address to access the DevEndpoint within a VPC if the DevEndpoint is created within one. The PrivateAddress field is present only when you create the DevEndpoint within your VPC.
        public var privateAddress: Swift.String?
        /// The public IP address used by this DevEndpoint. The PublicAddress field is present only when you create a non-virtual private cloud (VPC) DevEndpoint.
        public var publicAddress: Swift.String?
        /// The public key to be used by this DevEndpoint for authentication. This attribute is provided for backward compatibility because the recommended attribute to use is public keys.
        public var publicKey: Swift.String?
        /// A list of public keys to be used by the DevEndpoints for authentication. Using this attribute is preferred over a single public key because the public keys allow you to have a different private key per client. If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys. Call the UpdateDevEndpoint API operation with the public key content in the deletePublicKeys attribute, and the list of new keys in the addPublicKeys attribute.
        public var publicKeys: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the IAM role used in this DevEndpoint.
        public var roleArn: Swift.String?
        /// The name of the SecurityConfiguration structure to be used with this DevEndpoint.
        public var securityConfiguration: Swift.String?
        /// A list of security group identifiers used in this DevEndpoint.
        public var securityGroupIds: [Swift.String]?
        /// The current status of this DevEndpoint.
        public var status: Swift.String?
        /// The subnet ID for this DevEndpoint.
        public var subnetId: Swift.String?
        /// The ID of the virtual private cloud (VPC) used by this DevEndpoint.
        public var vpcId: Swift.String?
        /// The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.
        ///
        /// * For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.
        ///
        /// * For the G.1X worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.
        ///
        /// * For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.
        ///
        ///
        /// Known issue: when a development endpoint is created with the G.2XWorkerType configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk.
        public var workerType: GlueClientTypes.WorkerType?
        /// The YARN endpoint address used by this DevEndpoint.
        public var yarnEndpointAddress: Swift.String?
        /// The Apache Zeppelin port for the remote Apache Spark interpreter.
        public var zeppelinRemoteSparkInterpreterPort: Swift.Int

        public init(
            arguments: [Swift.String: Swift.String]? = nil,
            availabilityZone: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            endpointName: Swift.String? = nil,
            extraJarsS3Path: Swift.String? = nil,
            extraPythonLibsS3Path: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            glueVersion: Swift.String? = nil,
            lastModifiedTimestamp: Foundation.Date? = nil,
            lastUpdateStatus: Swift.String? = nil,
            numberOfNodes: Swift.Int = 0,
            numberOfWorkers: Swift.Int? = nil,
            privateAddress: Swift.String? = nil,
            publicAddress: Swift.String? = nil,
            publicKey: Swift.String? = nil,
            publicKeys: [Swift.String]? = nil,
            roleArn: Swift.String? = nil,
            securityConfiguration: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            vpcId: Swift.String? = nil,
            workerType: GlueClientTypes.WorkerType? = nil,
            yarnEndpointAddress: Swift.String? = nil,
            zeppelinRemoteSparkInterpreterPort: Swift.Int = 0
        )
        {
            self.arguments = arguments
            self.availabilityZone = availabilityZone
            self.createdTimestamp = createdTimestamp
            self.endpointName = endpointName
            self.extraJarsS3Path = extraJarsS3Path
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
            self.failureReason = failureReason
            self.glueVersion = glueVersion
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.lastUpdateStatus = lastUpdateStatus
            self.numberOfNodes = numberOfNodes
            self.numberOfWorkers = numberOfWorkers
            self.privateAddress = privateAddress
            self.publicAddress = publicAddress
            self.publicKey = publicKey
            self.publicKeys = publicKeys
            self.roleArn = roleArn
            self.securityConfiguration = securityConfiguration
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetId = subnetId
            self.vpcId = vpcId
            self.workerType = workerType
            self.yarnEndpointAddress = yarnEndpointAddress
            self.zeppelinRemoteSparkInterpreterPort = zeppelinRemoteSparkInterpreterPort
        }
    }
}

public struct BatchGetDevEndpointsOutput: Swift.Sendable {
    /// A list of DevEndpoint definitions.
    public var devEndpoints: [GlueClientTypes.DevEndpoint]?
    /// A list of DevEndpoints not found.
    public var devEndpointsNotFound: [Swift.String]?

    public init(
        devEndpoints: [GlueClientTypes.DevEndpoint]? = nil,
        devEndpointsNotFound: [Swift.String]? = nil
    )
    {
        self.devEndpoints = devEndpoints
        self.devEndpointsNotFound = devEndpointsNotFound
    }
}

public struct BatchGetJobsInput: Swift.Sendable {
    /// A list of job names, which might be the names returned from the ListJobs operation.
    /// This member is required.
    public var jobNames: [Swift.String]?

    public init(
        jobNames: [Swift.String]? = nil
    )
    {
        self.jobNames = jobNames
    }
}

extension GlueClientTypes {

    /// Specifies a Delta Lake data source that is registered in the Glue Data Catalog.
    public struct CatalogDeltaSource: Swift.Sendable {
        /// Specifies additional connection options.
        public var additionalDeltaOptions: [Swift.String: Swift.String]?
        /// The name of the database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the Delta Lake data source.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the Delta Lake source.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?
        /// The name of the table in the database to read from.
        /// This member is required.
        public var table: Swift.String?

        public init(
            additionalDeltaOptions: [Swift.String: Swift.String]? = nil,
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil,
            table: Swift.String? = nil
        )
        {
            self.additionalDeltaOptions = additionalDeltaOptions
            self.database = database
            self.name = name
            self.outputSchemas = outputSchemas
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies a Hudi data source that is registered in the Glue Data Catalog.
    public struct CatalogHudiSource: Swift.Sendable {
        /// Specifies additional connection options.
        public var additionalHudiOptions: [Swift.String: Swift.String]?
        /// The name of the database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the Hudi data source.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the Hudi source.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?
        /// The name of the table in the database to read from.
        /// This member is required.
        public var table: Swift.String?

        public init(
            additionalHudiOptions: [Swift.String: Swift.String]? = nil,
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil,
            table: Swift.String? = nil
        )
        {
            self.additionalHudiOptions = additionalHudiOptions
            self.database = database
            self.name = name
            self.outputSchemas = outputSchemas
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies options related to data preview for viewing a sample of your data.
    public struct StreamingDataPreviewOptions: Swift.Sendable {
        /// The polling time in milliseconds.
        public var pollingTime: Swift.Int?
        /// The limit to the number of records polled.
        public var recordPollingLimit: Swift.Int?

        public init(
            pollingTime: Swift.Int? = nil,
            recordPollingLimit: Swift.Int? = nil
        )
        {
            self.pollingTime = pollingTime
            self.recordPollingLimit = recordPollingLimit
        }
    }
}

extension GlueClientTypes {

    /// Additional options for streaming.
    public struct KafkaStreamingSourceOptions: Swift.Sendable {
        /// When this option is set to 'true', the data output will contain an additional column named "__src_timestamp" that indicates the time when the corresponding record received by the topic. The default value is 'false'. This option is supported in Glue version 4.0 or later.
        public var addRecordTimestamp: Swift.String?
        /// The specific TopicPartitions to consume. You must specify at least one of "topicName", "assign" or "subscribePattern".
        public var assign: Swift.String?
        /// A list of bootstrap server URLs, for example, as b-1.vpc-test-2.o4q88o.c6.kafka.us-east-1.amazonaws.com:9094. This option must be specified in the API call or defined in the table metadata in the Data Catalog.
        public var bootstrapServers: Swift.String?
        /// An optional classification.
        public var classification: Swift.String?
        /// The name of the connection.
        public var connectionName: Swift.String?
        /// Specifies the delimiter character.
        public var delimiter: Swift.String?
        /// When this option is set to 'true', for each batch, it will emit the metrics for the duration between the oldest record received by the topic and the time it arrives in Glue to CloudWatch. The metric's name is "glue.driver.streaming.maxConsumerLagInMs". The default value is 'false'. This option is supported in Glue version 4.0 or later.
        public var emitConsumerLagMetrics: Swift.String?
        /// The end point when a batch query is ended. Possible values are either "latest" or a JSON string that specifies an ending offset for each TopicPartition.
        public var endingOffsets: Swift.String?
        /// Whether to include the Kafka headers. When the option is set to "true", the data output will contain an additional column named "glue_streaming_kafka_headers" with type Array[Struct(key: String, value: String)]. The default value is "false". This option is available in Glue version 3.0 or later only.
        public var includeHeaders: Swift.Bool?
        /// The rate limit on the maximum number of offsets that are processed per trigger interval. The specified total number of offsets is proportionally split across topicPartitions of different volumes. The default value is null, which means that the consumer reads all offsets until the known latest offset.
        public var maxOffsetsPerTrigger: Swift.Int?
        /// The desired minimum number of partitions to read from Kafka. The default value is null, which means that the number of spark partitions is equal to the number of Kafka partitions.
        public var minPartitions: Swift.Int?
        /// The number of times to retry before failing to fetch Kafka offsets. The default value is 3.
        public var numRetries: Swift.Int?
        /// The timeout in milliseconds to poll data from Kafka in Spark job executors. The default value is 512.
        public var pollTimeoutMs: Swift.Int?
        /// The time in milliseconds to wait before retrying to fetch Kafka offsets. The default value is 10.
        public var retryIntervalMs: Swift.Int?
        /// The protocol used to communicate with brokers. The possible values are "SSL" or "PLAINTEXT".
        public var securityProtocol: Swift.String?
        /// The starting position in the Kafka topic to read data from. The possible values are "earliest" or "latest". The default value is "latest".
        public var startingOffsets: Swift.String?
        /// The timestamp of the record in the Kafka topic to start reading data from. The possible values are a timestamp string in UTC format of the pattern yyyy-mm-ddTHH:MM:SSZ (where Z represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00+08:00"). Only one of StartingTimestamp or StartingOffsets must be set.
        public var startingTimestamp: Foundation.Date?
        /// A Java regex string that identifies the topic list to subscribe to. You must specify at least one of "topicName", "assign" or "subscribePattern".
        public var subscribePattern: Swift.String?
        /// The topic name as specified in Apache Kafka. You must specify at least one of "topicName", "assign" or "subscribePattern".
        public var topicName: Swift.String?

        public init(
            addRecordTimestamp: Swift.String? = nil,
            assign: Swift.String? = nil,
            bootstrapServers: Swift.String? = nil,
            classification: Swift.String? = nil,
            connectionName: Swift.String? = nil,
            delimiter: Swift.String? = nil,
            emitConsumerLagMetrics: Swift.String? = nil,
            endingOffsets: Swift.String? = nil,
            includeHeaders: Swift.Bool? = nil,
            maxOffsetsPerTrigger: Swift.Int? = nil,
            minPartitions: Swift.Int? = nil,
            numRetries: Swift.Int? = nil,
            pollTimeoutMs: Swift.Int? = nil,
            retryIntervalMs: Swift.Int? = nil,
            securityProtocol: Swift.String? = nil,
            startingOffsets: Swift.String? = nil,
            startingTimestamp: Foundation.Date? = nil,
            subscribePattern: Swift.String? = nil,
            topicName: Swift.String? = nil
        )
        {
            self.addRecordTimestamp = addRecordTimestamp
            self.assign = assign
            self.bootstrapServers = bootstrapServers
            self.classification = classification
            self.connectionName = connectionName
            self.delimiter = delimiter
            self.emitConsumerLagMetrics = emitConsumerLagMetrics
            self.endingOffsets = endingOffsets
            self.includeHeaders = includeHeaders
            self.maxOffsetsPerTrigger = maxOffsetsPerTrigger
            self.minPartitions = minPartitions
            self.numRetries = numRetries
            self.pollTimeoutMs = pollTimeoutMs
            self.retryIntervalMs = retryIntervalMs
            self.securityProtocol = securityProtocol
            self.startingOffsets = startingOffsets
            self.startingTimestamp = startingTimestamp
            self.subscribePattern = subscribePattern
            self.topicName = topicName
        }
    }
}

extension GlueClientTypes {

    /// Specifies an Apache Kafka data store in the Data Catalog.
    public struct CatalogKafkaSource: Swift.Sendable {
        /// Specifies options related to data preview for viewing a sample of your data.
        public var dataPreviewOptions: GlueClientTypes.StreamingDataPreviewOptions?
        /// The name of the database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// Whether to automatically determine the schema from the incoming data.
        public var detectSchema: Swift.Bool?
        /// The name of the data store.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the streaming options.
        public var streamingOptions: GlueClientTypes.KafkaStreamingSourceOptions?
        /// The name of the table in the database to read from.
        /// This member is required.
        public var table: Swift.String?
        /// The amount of time to spend processing each micro batch.
        public var windowSize: Swift.Int?

        public init(
            dataPreviewOptions: GlueClientTypes.StreamingDataPreviewOptions? = nil,
            database: Swift.String? = nil,
            detectSchema: Swift.Bool? = nil,
            name: Swift.String? = nil,
            streamingOptions: GlueClientTypes.KafkaStreamingSourceOptions? = nil,
            table: Swift.String? = nil,
            windowSize: Swift.Int? = nil
        )
        {
            self.dataPreviewOptions = dataPreviewOptions
            self.database = database
            self.detectSchema = detectSchema
            self.name = name
            self.streamingOptions = streamingOptions
            self.table = table
            self.windowSize = windowSize
        }
    }
}

extension GlueClientTypes {

    public enum StartingPosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case earliest
        case latest
        case timestamp
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [StartingPosition] {
            return [
                .earliest,
                .latest,
                .timestamp,
                .trimHorizon
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .earliest: return "earliest"
            case .latest: return "latest"
            case .timestamp: return "timestamp"
            case .trimHorizon: return "trim_horizon"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Additional options for the Amazon Kinesis streaming data source.
    public struct KinesisStreamingSourceOptions: Swift.Sendable {
        /// Adds a time delay between two consecutive getRecords operations. The default value is "False". This option is only configurable for Glue version 2.0 and above.
        public var addIdleTimeBetweenReads: Swift.Bool?
        /// When this option is set to 'true', the data output will contain an additional column named "__src_timestamp" that indicates the time when the corresponding record received by the stream. The default value is 'false'. This option is supported in Glue version 4.0 or later.
        public var addRecordTimestamp: Swift.String?
        /// Avoids creating an empty microbatch job by checking for unread data in the Kinesis data stream before the batch is started. The default value is "False".
        public var avoidEmptyBatches: Swift.Bool?
        /// An optional classification.
        public var classification: Swift.String?
        /// Specifies the delimiter character.
        public var delimiter: Swift.String?
        /// The minimum time interval between two ListShards API calls for your script to consider resharding. The default value is 1s.
        public var describeShardInterval: Swift.Int?
        /// When this option is set to 'true', for each batch, it will emit the metrics for the duration between the oldest record received by the stream and the time it arrives in Glue to CloudWatch. The metric's name is "glue.driver.streaming.maxConsumerLagInMs". The default value is 'false'. This option is supported in Glue version 4.0 or later.
        public var emitConsumerLagMetrics: Swift.String?
        /// The URL of the Kinesis endpoint.
        public var endpointUrl: Swift.String?
        /// The minimum time delay between two consecutive getRecords operations, specified in ms. The default value is 1000. This option is only configurable for Glue version 2.0 and above.
        public var idleTimeBetweenReadsInMs: Swift.Int?
        /// The maximum number of records to fetch per shard in the Kinesis data stream per microbatch. Note: The client can exceed this limit if the streaming job has already read extra records from Kinesis (in the same get-records call). If MaxFetchRecordsPerShard needs to be strict then it needs to be a multiple of MaxRecordPerRead. The default value is 100000.
        public var maxFetchRecordsPerShard: Swift.Int?
        /// The maximum time spent for the job executor to read records for the current batch from the Kinesis data stream, specified in milliseconds (ms). Multiple GetRecords API calls may be made within this time. The default value is 1000.
        public var maxFetchTimeInMs: Swift.Int?
        /// The maximum number of records to fetch from the Kinesis data stream in each getRecords operation. The default value is 10000.
        public var maxRecordPerRead: Swift.Int?
        /// The maximum cool-off time period (specified in ms) between two retries of a Kinesis Data Streams API call. The default value is 10000.
        public var maxRetryIntervalMs: Swift.Int?
        /// The maximum number of retries for Kinesis Data Streams API requests. The default value is 3.
        public var numRetries: Swift.Int?
        /// The cool-off time period (specified in ms) before retrying the Kinesis Data Streams API call. The default value is 1000.
        public var retryIntervalMs: Swift.Int?
        /// The Amazon Resource Name (ARN) of the role to assume using AWS Security Token Service (AWS STS). This role must have permissions for describe or read record operations for the Kinesis data stream. You must use this parameter when accessing a data stream in a different account. Used in conjunction with "awsSTSSessionName".
        public var roleArn: Swift.String?
        /// An identifier for the session assuming the role using AWS STS. You must use this parameter when accessing a data stream in a different account. Used in conjunction with "awsSTSRoleARN".
        public var roleSessionName: Swift.String?
        /// The starting position in the Kinesis data stream to read data from. The possible values are "latest", "trim_horizon", "earliest", or a timestamp string in UTC format in the pattern yyyy-mm-ddTHH:MM:SSZ (where Z represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00-04:00"). The default value is "latest". Note: Using a value that is a timestamp string in UTC format for "startingPosition" is supported only for Glue version 4.0 or later.
        public var startingPosition: GlueClientTypes.StartingPosition?
        /// The timestamp of the record in the Kinesis data stream to start reading data from. The possible values are a timestamp string in UTC format of the pattern yyyy-mm-ddTHH:MM:SSZ (where Z represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00+08:00").
        public var startingTimestamp: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the Kinesis data stream.
        public var streamArn: Swift.String?
        /// The name of the Kinesis data stream.
        public var streamName: Swift.String?

        public init(
            addIdleTimeBetweenReads: Swift.Bool? = nil,
            addRecordTimestamp: Swift.String? = nil,
            avoidEmptyBatches: Swift.Bool? = nil,
            classification: Swift.String? = nil,
            delimiter: Swift.String? = nil,
            describeShardInterval: Swift.Int? = nil,
            emitConsumerLagMetrics: Swift.String? = nil,
            endpointUrl: Swift.String? = nil,
            idleTimeBetweenReadsInMs: Swift.Int? = nil,
            maxFetchRecordsPerShard: Swift.Int? = nil,
            maxFetchTimeInMs: Swift.Int? = nil,
            maxRecordPerRead: Swift.Int? = nil,
            maxRetryIntervalMs: Swift.Int? = nil,
            numRetries: Swift.Int? = nil,
            retryIntervalMs: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            roleSessionName: Swift.String? = nil,
            startingPosition: GlueClientTypes.StartingPosition? = nil,
            startingTimestamp: Foundation.Date? = nil,
            streamArn: Swift.String? = nil,
            streamName: Swift.String? = nil
        )
        {
            self.addIdleTimeBetweenReads = addIdleTimeBetweenReads
            self.addRecordTimestamp = addRecordTimestamp
            self.avoidEmptyBatches = avoidEmptyBatches
            self.classification = classification
            self.delimiter = delimiter
            self.describeShardInterval = describeShardInterval
            self.emitConsumerLagMetrics = emitConsumerLagMetrics
            self.endpointUrl = endpointUrl
            self.idleTimeBetweenReadsInMs = idleTimeBetweenReadsInMs
            self.maxFetchRecordsPerShard = maxFetchRecordsPerShard
            self.maxFetchTimeInMs = maxFetchTimeInMs
            self.maxRecordPerRead = maxRecordPerRead
            self.maxRetryIntervalMs = maxRetryIntervalMs
            self.numRetries = numRetries
            self.retryIntervalMs = retryIntervalMs
            self.roleArn = roleArn
            self.roleSessionName = roleSessionName
            self.startingPosition = startingPosition
            self.startingTimestamp = startingTimestamp
            self.streamArn = streamArn
            self.streamName = streamName
        }
    }
}

extension GlueClientTypes {

    /// Specifies a Kinesis data source in the Glue Data Catalog.
    public struct CatalogKinesisSource: Swift.Sendable {
        /// Additional options for data preview.
        public var dataPreviewOptions: GlueClientTypes.StreamingDataPreviewOptions?
        /// The name of the database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// Whether to automatically determine the schema from the incoming data.
        public var detectSchema: Swift.Bool?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// Additional options for the Kinesis streaming data source.
        public var streamingOptions: GlueClientTypes.KinesisStreamingSourceOptions?
        /// The name of the table in the database to read from.
        /// This member is required.
        public var table: Swift.String?
        /// The amount of time to spend processing each micro batch.
        public var windowSize: Swift.Int?

        public init(
            dataPreviewOptions: GlueClientTypes.StreamingDataPreviewOptions? = nil,
            database: Swift.String? = nil,
            detectSchema: Swift.Bool? = nil,
            name: Swift.String? = nil,
            streamingOptions: GlueClientTypes.KinesisStreamingSourceOptions? = nil,
            table: Swift.String? = nil,
            windowSize: Swift.Int? = nil
        )
        {
            self.dataPreviewOptions = dataPreviewOptions
            self.database = database
            self.detectSchema = detectSchema
            self.name = name
            self.streamingOptions = streamingOptions
            self.table = table
            self.windowSize = windowSize
        }
    }
}

extension GlueClientTypes {

    /// Specifies a data store in the Glue Data Catalog.
    public struct CatalogSource: Swift.Sendable {
        /// The name of the database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the data store.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the table in the database to read from.
        /// This member is required.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.name = name
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies a target that uses a Glue Data Catalog table.
    public struct BasicCatalogTarget: Swift.Sendable {
        /// The database that contains the table you want to use as the target. This database must already exist in the Data Catalog.
        /// This member is required.
        public var database: Swift.String?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of your data target.
        /// This member is required.
        public var name: Swift.String?
        /// The partition keys used to distribute data across multiple partitions or shards based on a specific key or set of key.
        public var partitionKeys: [[Swift.String]]?
        /// The table that defines the schema of your output data. This table must already exist in the Data Catalog.
        /// This member is required.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            partitionKeys: [[Swift.String]]? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies a source generated with standard connection options.
    public struct ConnectorDataSource: Swift.Sendable {
        /// The connectionType, as provided to the underlying Glue library. This node type supports the following connection types:
        ///
        /// * opensearch
        ///
        /// * azuresql
        ///
        /// * azurecosmos
        ///
        /// * bigquery
        ///
        /// * saphana
        ///
        /// * teradata
        ///
        /// * vertica
        /// This member is required.
        public var connectionType: Swift.String?
        /// A map specifying connection options for the node. You can find standard connection options for the corresponding connection type in the [ Connection parameters](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-connect.html) section of the Glue documentation.
        /// This member is required.
        public var data: [Swift.String: Swift.String]?
        /// The name of this source node.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for this source.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?

        public init(
            connectionType: Swift.String? = nil,
            data: [Swift.String: Swift.String]? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil
        )
        {
            self.connectionType = connectionType
            self.data = data
            self.name = name
            self.outputSchemas = outputSchemas
        }
    }
}

extension GlueClientTypes {

    /// Specifies a target generated with standard connection options.
    public struct ConnectorDataTarget: Swift.Sendable {
        /// The connectionType, as provided to the underlying Glue library. This node type supports the following connection types:
        ///
        /// * opensearch
        ///
        /// * azuresql
        ///
        /// * azurecosmos
        ///
        /// * bigquery
        ///
        /// * saphana
        ///
        /// * teradata
        ///
        /// * vertica
        /// This member is required.
        public var connectionType: Swift.String?
        /// A map specifying connection options for the node. You can find standard connection options for the corresponding connection type in the [ Connection parameters](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-connect.html) section of the Glue documentation.
        /// This member is required.
        public var data: [Swift.String: Swift.String]?
        /// The nodes that are inputs to the data target.
        public var inputs: [Swift.String]?
        /// The name of this target node.
        /// This member is required.
        public var name: Swift.String?

        public init(
            connectionType: Swift.String? = nil,
            data: [Swift.String: Swift.String]? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.connectionType = connectionType
            self.data = data
            self.inputs = inputs
            self.name = name
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that uses custom code you provide to perform the data transformation. The output is a collection of DynamicFrames.
    public struct CustomCode: Swift.Sendable {
        /// The name defined for the custom code node class.
        /// This member is required.
        public var className: Swift.String?
        /// The custom code that is used to perform the data transformation.
        /// This member is required.
        public var code: Swift.String?
        /// The data inputs identified by their node names.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the custom code transform.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?

        public init(
            className: Swift.String? = nil,
            code: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil
        )
        {
            self.className = className
            self.code = code
            self.inputs = inputs
            self.name = name
            self.outputSchemas = outputSchemas
        }
    }
}

extension GlueClientTypes {

    public enum JDBCConnectionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mysql
        case oracle
        case postgresql
        case redshift
        case sqlserver
        case sdkUnknown(Swift.String)

        public static var allCases: [JDBCConnectionType] {
            return [
                .mysql,
                .oracle,
                .postgresql,
                .redshift,
                .sqlserver
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mysql: return "mysql"
            case .oracle: return "oracle"
            case .postgresql: return "postgresql"
            case .redshift: return "redshift"
            case .sqlserver: return "sqlserver"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies the direct JDBC source connection.
    public struct DirectJDBCSource: Swift.Sendable {
        /// The connection name of the JDBC source.
        /// This member is required.
        public var connectionName: Swift.String?
        /// The connection type of the JDBC source.
        /// This member is required.
        public var connectionType: GlueClientTypes.JDBCConnectionType?
        /// The database of the JDBC source connection.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the JDBC source connection.
        /// This member is required.
        public var name: Swift.String?
        /// The temp directory of the JDBC Redshift source.
        public var redshiftTmpDir: Swift.String?
        /// The table of the JDBC source connection.
        /// This member is required.
        public var table: Swift.String?

        public init(
            connectionName: Swift.String? = nil,
            connectionType: GlueClientTypes.JDBCConnectionType? = nil,
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            redshiftTmpDir: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.connectionName = connectionName
            self.connectionType = connectionType
            self.database = database
            self.name = name
            self.redshiftTmpDir = redshiftTmpDir
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies an Apache Kafka data store.
    public struct DirectKafkaSource: Swift.Sendable {
        /// Specifies options related to data preview for viewing a sample of your data.
        public var dataPreviewOptions: GlueClientTypes.StreamingDataPreviewOptions?
        /// Whether to automatically determine the schema from the incoming data.
        public var detectSchema: Swift.Bool?
        /// The name of the data store.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the streaming options.
        public var streamingOptions: GlueClientTypes.KafkaStreamingSourceOptions?
        /// The amount of time to spend processing each micro batch.
        public var windowSize: Swift.Int?

        public init(
            dataPreviewOptions: GlueClientTypes.StreamingDataPreviewOptions? = nil,
            detectSchema: Swift.Bool? = nil,
            name: Swift.String? = nil,
            streamingOptions: GlueClientTypes.KafkaStreamingSourceOptions? = nil,
            windowSize: Swift.Int? = nil
        )
        {
            self.dataPreviewOptions = dataPreviewOptions
            self.detectSchema = detectSchema
            self.name = name
            self.streamingOptions = streamingOptions
            self.windowSize = windowSize
        }
    }
}

extension GlueClientTypes {

    /// Specifies a direct Amazon Kinesis data source.
    public struct DirectKinesisSource: Swift.Sendable {
        /// Additional options for data preview.
        public var dataPreviewOptions: GlueClientTypes.StreamingDataPreviewOptions?
        /// Whether to automatically determine the schema from the incoming data.
        public var detectSchema: Swift.Bool?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// Additional options for the Kinesis streaming data source.
        public var streamingOptions: GlueClientTypes.KinesisStreamingSourceOptions?
        /// The amount of time to spend processing each micro batch.
        public var windowSize: Swift.Int?

        public init(
            dataPreviewOptions: GlueClientTypes.StreamingDataPreviewOptions? = nil,
            detectSchema: Swift.Bool? = nil,
            name: Swift.String? = nil,
            streamingOptions: GlueClientTypes.KinesisStreamingSourceOptions? = nil,
            windowSize: Swift.Int? = nil
        )
        {
            self.dataPreviewOptions = dataPreviewOptions
            self.detectSchema = detectSchema
            self.name = name
            self.streamingOptions = streamingOptions
            self.windowSize = windowSize
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that removes rows of repeating data from a data set.
    public struct DropDuplicates: Swift.Sendable {
        /// The name of the columns to be merged or removed if repeating.
        public var columns: [[Swift.String]]?
        /// The data inputs identified by their node names.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?

        public init(
            columns: [[Swift.String]]? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.columns = columns
            self.inputs = inputs
            self.name = name
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that chooses the data property keys that you want to drop.
    public struct DropFields: Swift.Sendable {
        /// The data inputs identified by their node names.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?
        /// A JSON path to a variable in the data structure.
        /// This member is required.
        public var paths: [[Swift.String]]?

        public init(
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            paths: [[Swift.String]]? = nil
        )
        {
            self.inputs = inputs
            self.name = name
            self.paths = paths
        }
    }
}

extension GlueClientTypes {

    /// Represents whether certain values are recognized as null values for removal.
    public struct NullCheckBoxList: Swift.Sendable {
        /// Specifies that an empty string is considered as a null value.
        public var isEmpty: Swift.Bool?
        /// Specifies that an integer value of -1 is considered as a null value.
        public var isNegOne: Swift.Bool?
        /// Specifies that a value spelling out the word 'null' is considered as a null value.
        public var isNullString: Swift.Bool?

        public init(
            isEmpty: Swift.Bool? = nil,
            isNegOne: Swift.Bool? = nil,
            isNullString: Swift.Bool? = nil
        )
        {
            self.isEmpty = isEmpty
            self.isNegOne = isNegOne
            self.isNullString = isNullString
        }
    }
}

extension GlueClientTypes {

    /// A structure representing the datatype of the value.
    public struct Datatype: Swift.Sendable {
        /// The datatype of the value.
        /// This member is required.
        public var id: Swift.String?
        /// A label assigned to the datatype.
        /// This member is required.
        public var label: Swift.String?

        public init(
            id: Swift.String? = nil,
            label: Swift.String? = nil
        )
        {
            self.id = id
            self.label = label
        }
    }
}

extension GlueClientTypes {

    /// Represents a custom null value such as a zeros or other value being used as a null placeholder unique to the dataset.
    public struct NullValueField: Swift.Sendable {
        /// The datatype of the value.
        /// This member is required.
        public var datatype: GlueClientTypes.Datatype?
        /// The value of the null placeholder.
        /// This member is required.
        public var value: Swift.String?

        public init(
            datatype: GlueClientTypes.Datatype? = nil,
            value: Swift.String? = nil
        )
        {
            self.datatype = datatype
            self.value = value
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that removes columns from the dataset if all values in the column are 'null'. By default, Glue Studio will recognize null objects, but some values such as empty strings, strings that are "null", -1 integers or other placeholders such as zeros, are not automatically recognized as nulls.
    public struct DropNullFields: Swift.Sendable {
        /// The data inputs identified by their node names.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?
        /// A structure that represents whether certain values are recognized as null values for removal.
        public var nullCheckBoxList: GlueClientTypes.NullCheckBoxList?
        /// A structure that specifies a list of NullValueField structures that represent a custom null value such as zero or other value being used as a null placeholder unique to the dataset. The DropNullFields transform removes custom null values only if both the value of the null placeholder and the datatype match the data.
        public var nullTextList: [GlueClientTypes.NullValueField]?

        public init(
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            nullCheckBoxList: GlueClientTypes.NullCheckBoxList? = nil,
            nullTextList: [GlueClientTypes.NullValueField]? = nil
        )
        {
            self.inputs = inputs
            self.name = name
            self.nullCheckBoxList = nullCheckBoxList
            self.nullTextList = nullTextList
        }
    }
}

extension GlueClientTypes {

    public enum ParamType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bool
        case complex
        case float
        case int
        case list
        case null
        case str
        case sdkUnknown(Swift.String)

        public static var allCases: [ParamType] {
            return [
                .bool,
                .complex,
                .float,
                .int,
                .list,
                .null,
                .str
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bool: return "bool"
            case .complex: return "complex"
            case .float: return "float"
            case .int: return "int"
            case .list: return "list"
            case .null: return "null"
            case .str: return "str"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies the parameters in the config file of the dynamic transform.
    public struct TransformConfigParameter: Swift.Sendable {
        /// Specifies whether the parameter is optional or not in the config file of the dynamic transform.
        public var isOptional: Swift.Bool?
        /// Specifies the list type of the parameter in the config file of the dynamic transform.
        public var listType: GlueClientTypes.ParamType?
        /// Specifies the name of the parameter in the config file of the dynamic transform.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the parameter type in the config file of the dynamic transform.
        /// This member is required.
        public var type: GlueClientTypes.ParamType?
        /// Specifies the validation message in the config file of the dynamic transform.
        public var validationMessage: Swift.String?
        /// Specifies the validation rule in the config file of the dynamic transform.
        public var validationRule: Swift.String?
        /// Specifies the value of the parameter in the config file of the dynamic transform.
        public var value: [Swift.String]?

        public init(
            isOptional: Swift.Bool? = nil,
            listType: GlueClientTypes.ParamType? = nil,
            name: Swift.String? = nil,
            type: GlueClientTypes.ParamType? = nil,
            validationMessage: Swift.String? = nil,
            validationRule: Swift.String? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.isOptional = isOptional
            self.listType = listType
            self.name = name
            self.type = type
            self.validationMessage = validationMessage
            self.validationRule = validationRule
            self.value = value
        }
    }
}

extension GlueClientTypes {

    /// Specifies the set of parameters needed to perform the dynamic transform.
    public struct DynamicTransform: Swift.Sendable {
        /// Specifies the name of the function of the dynamic transform.
        /// This member is required.
        public var functionName: Swift.String?
        /// Specifies the inputs for the dynamic transform that are required.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// Specifies the name of the dynamic transform.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the dynamic transform.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?
        /// Specifies the parameters of the dynamic transform.
        public var parameters: [GlueClientTypes.TransformConfigParameter]?
        /// Specifies the path of the dynamic transform source and config files.
        /// This member is required.
        public var path: Swift.String?
        /// Specifies the name of the dynamic transform as it appears in the Glue Studio visual editor.
        /// This member is required.
        public var transformName: Swift.String?
        /// This field is not used and will be deprecated in future release.
        public var version: Swift.String?

        public init(
            functionName: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil,
            parameters: [GlueClientTypes.TransformConfigParameter]? = nil,
            path: Swift.String? = nil,
            transformName: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.functionName = functionName
            self.inputs = inputs
            self.name = name
            self.outputSchemas = outputSchemas
            self.parameters = parameters
            self.path = path
            self.transformName = transformName
            self.version = version
        }
    }
}

extension GlueClientTypes {

    /// Specifies a DynamoDB data source in the Glue Data Catalog.
    public struct DynamoDBCatalogSource: Swift.Sendable {
        /// The name of the database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the table in the database to read from.
        /// This member is required.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.name = name
            self.table = table
        }
    }
}

extension GlueClientTypes {

    public enum DQTransformOutput: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case evaluationresults
        case primaryinput
        case sdkUnknown(Swift.String)

        public static var allCases: [DQTransformOutput] {
            return [
                .evaluationresults,
                .primaryinput
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .evaluationresults: return "EvaluationResults"
            case .primaryinput: return "PrimaryInput"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Options to configure how your data quality evaluation results are published.
    public struct DQResultsPublishingOptions: Swift.Sendable {
        /// Enable metrics for your data quality results.
        public var cloudWatchMetricsEnabled: Swift.Bool?
        /// The context of the evaluation.
        public var evaluationContext: Swift.String?
        /// Enable publishing for your data quality results.
        public var resultsPublishingEnabled: Swift.Bool?
        /// The Amazon S3 prefix prepended to the results.
        public var resultsS3Prefix: Swift.String?

        public init(
            cloudWatchMetricsEnabled: Swift.Bool? = nil,
            evaluationContext: Swift.String? = nil,
            resultsPublishingEnabled: Swift.Bool? = nil,
            resultsS3Prefix: Swift.String? = nil
        )
        {
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.evaluationContext = evaluationContext
            self.resultsPublishingEnabled = resultsPublishingEnabled
            self.resultsS3Prefix = resultsS3Prefix
        }
    }
}

extension GlueClientTypes {

    public enum DQStopJobOnFailureTiming: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case afterdataload
        case immediate
        case sdkUnknown(Swift.String)

        public static var allCases: [DQStopJobOnFailureTiming] {
            return [
                .afterdataload,
                .immediate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .afterdataload: return "AfterDataLoad"
            case .immediate: return "Immediate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Options to configure how your job will stop if your data quality evaluation fails.
    public struct DQStopJobOnFailureOptions: Swift.Sendable {
        /// When to stop job if your data quality evaluation fails. Options are Immediate or AfterDataLoad.
        public var stopJobOnFailureTiming: GlueClientTypes.DQStopJobOnFailureTiming?

        public init(
            stopJobOnFailureTiming: GlueClientTypes.DQStopJobOnFailureTiming? = nil
        )
        {
            self.stopJobOnFailureTiming = stopJobOnFailureTiming
        }
    }
}

extension GlueClientTypes {

    /// Specifies your data quality evaluation criteria.
    public struct EvaluateDataQuality: Swift.Sendable {
        /// The inputs of your data quality evaluation.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data quality evaluation.
        /// This member is required.
        public var name: Swift.String?
        /// The output of your data quality evaluation.
        public var output: GlueClientTypes.DQTransformOutput?
        /// Options to configure how your results are published.
        public var publishingOptions: GlueClientTypes.DQResultsPublishingOptions?
        /// The ruleset for your data quality evaluation.
        /// This member is required.
        public var ruleset: Swift.String?
        /// Options to configure how your job will stop if your data quality evaluation fails.
        public var stopJobOnFailureOptions: GlueClientTypes.DQStopJobOnFailureOptions?

        public init(
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            output: GlueClientTypes.DQTransformOutput? = nil,
            publishingOptions: GlueClientTypes.DQResultsPublishingOptions? = nil,
            ruleset: Swift.String? = nil,
            stopJobOnFailureOptions: GlueClientTypes.DQStopJobOnFailureOptions? = nil
        )
        {
            self.inputs = inputs
            self.name = name
            self.output = output
            self.publishingOptions = publishingOptions
            self.ruleset = ruleset
            self.stopJobOnFailureOptions = stopJobOnFailureOptions
        }
    }
}

extension GlueClientTypes {

    /// Specifies your data quality evaluation criteria.
    public struct EvaluateDataQualityMultiFrame: Swift.Sendable {
        /// The aliases of all data sources except primary.
        public var additionalDataSources: [Swift.String: Swift.String]?
        /// Options to configure runtime behavior of the transform.
        public var additionalOptions: [Swift.String: Swift.String]?
        /// The inputs of your data quality evaluation. The first input in this list is the primary data source.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data quality evaluation.
        /// This member is required.
        public var name: Swift.String?
        /// Options to configure how your results are published.
        public var publishingOptions: GlueClientTypes.DQResultsPublishingOptions?
        /// The ruleset for your data quality evaluation.
        /// This member is required.
        public var ruleset: Swift.String?
        /// Options to configure how your job will stop if your data quality evaluation fails.
        public var stopJobOnFailureOptions: GlueClientTypes.DQStopJobOnFailureOptions?

        public init(
            additionalDataSources: [Swift.String: Swift.String]? = nil,
            additionalOptions: [Swift.String: Swift.String]? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            publishingOptions: GlueClientTypes.DQResultsPublishingOptions? = nil,
            ruleset: Swift.String? = nil,
            stopJobOnFailureOptions: GlueClientTypes.DQStopJobOnFailureOptions? = nil
        )
        {
            self.additionalDataSources = additionalDataSources
            self.additionalOptions = additionalOptions
            self.inputs = inputs
            self.name = name
            self.publishingOptions = publishingOptions
            self.ruleset = ruleset
            self.stopJobOnFailureOptions = stopJobOnFailureOptions
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that locates records in the dataset that have missing values and adds a new field with a value determined by imputation. The input data set is used to train the machine learning model that determines what the missing value should be.
    public struct FillMissingValues: Swift.Sendable {
        /// A JSON path to a variable in the data structure for the dataset that is filled.
        public var filledPath: Swift.String?
        /// A JSON path to a variable in the data structure for the dataset that is imputed.
        /// This member is required.
        public var imputedPath: Swift.String?
        /// The data inputs identified by their node names.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?

        public init(
            filledPath: Swift.String? = nil,
            imputedPath: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.filledPath = filledPath
            self.imputedPath = imputedPath
            self.inputs = inputs
            self.name = name
        }
    }
}

extension GlueClientTypes {

    public enum FilterOperation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case eq
        case gt
        case gte
        case isnull
        case lt
        case lte
        case regex
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterOperation] {
            return [
                .eq,
                .gt,
                .gte,
                .isnull,
                .lt,
                .lte,
                .regex
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .eq: return "EQ"
            case .gt: return "GT"
            case .gte: return "GTE"
            case .isnull: return "ISNULL"
            case .lt: return "LT"
            case .lte: return "LTE"
            case .regex: return "REGEX"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum FilterValueType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case columnextracted
        case constant
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterValueType] {
            return [
                .columnextracted,
                .constant
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .columnextracted: return "COLUMNEXTRACTED"
            case .constant: return "CONSTANT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Represents a single entry in the list of values for a FilterExpression.
    public struct FilterValue: Swift.Sendable {
        /// The type of filter value.
        /// This member is required.
        public var type: GlueClientTypes.FilterValueType?
        /// The value to be associated.
        /// This member is required.
        public var value: [Swift.String]?

        public init(
            type: GlueClientTypes.FilterValueType? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }
}

extension GlueClientTypes {

    /// Specifies a filter expression.
    public struct FilterExpression: Swift.Sendable {
        /// Whether the expression is to be negated.
        public var negated: Swift.Bool?
        /// The type of operation to perform in the expression.
        /// This member is required.
        public var operation: GlueClientTypes.FilterOperation?
        /// A list of filter values.
        /// This member is required.
        public var values: [GlueClientTypes.FilterValue]?

        public init(
            negated: Swift.Bool? = nil,
            operation: GlueClientTypes.FilterOperation? = nil,
            values: [GlueClientTypes.FilterValue]? = nil
        )
        {
            self.negated = negated
            self.operation = operation
            self.values = values
        }
    }
}

extension GlueClientTypes {

    public enum FilterLogicalOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case and
        case or
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterLogicalOperator] {
            return [
                .and,
                .or
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .and: return "AND"
            case .or: return "OR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that splits a dataset into two, based on a filter condition.
    public struct Filter: Swift.Sendable {
        /// Specifies a filter expression.
        /// This member is required.
        public var filters: [GlueClientTypes.FilterExpression]?
        /// The data inputs identified by their node names.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The operator used to filter rows by comparing the key value to a specified value.
        /// This member is required.
        public var logicalOperator: GlueClientTypes.FilterLogicalOperator?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?

        public init(
            filters: [GlueClientTypes.FilterExpression]? = nil,
            inputs: [Swift.String]? = nil,
            logicalOperator: GlueClientTypes.FilterLogicalOperator? = nil,
            name: Swift.String? = nil
        )
        {
            self.filters = filters
            self.inputs = inputs
            self.logicalOperator = logicalOperator
            self.name = name
        }
    }
}

extension GlueClientTypes {

    /// Specifies additional connection options for the Amazon S3 data store.
    public struct S3SourceAdditionalOptions: Swift.Sendable {
        /// Sets the upper limit for the target number of files that will be processed.
        public var boundedFiles: Swift.Int?
        /// Sets the upper limit for the target size of the dataset in bytes that will be processed.
        public var boundedSize: Swift.Int?

        public init(
            boundedFiles: Swift.Int? = nil,
            boundedSize: Swift.Int? = nil
        )
        {
            self.boundedFiles = boundedFiles
            self.boundedSize = boundedSize
        }
    }
}

extension GlueClientTypes {

    /// Specifies the data store in the governed Glue Data Catalog.
    public struct GovernedCatalogSource: Swift.Sendable {
        /// Specifies additional connection options.
        public var additionalOptions: GlueClientTypes.S3SourceAdditionalOptions?
        /// The database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the data store.
        /// This member is required.
        public var name: Swift.String?
        /// Partitions satisfying this predicate are deleted. Files within the retention period in these partitions are not deleted. Set to "" – empty by default.
        public var partitionPredicate: Swift.String?
        /// The database table to read from.
        /// This member is required.
        public var table: Swift.String?

        public init(
            additionalOptions: GlueClientTypes.S3SourceAdditionalOptions? = nil,
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            partitionPredicate: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.additionalOptions = additionalOptions
            self.database = database
            self.name = name
            self.partitionPredicate = partitionPredicate
            self.table = table
        }
    }
}

extension GlueClientTypes {

    public enum UpdateCatalogBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case log
        case updateInDatabase
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateCatalogBehavior] {
            return [
                .log,
                .updateInDatabase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .log: return "LOG"
            case .updateInDatabase: return "UPDATE_IN_DATABASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A policy that specifies update behavior for the crawler.
    public struct CatalogSchemaChangePolicy: Swift.Sendable {
        /// Whether to use the specified update behavior when the crawler finds a changed schema.
        public var enableUpdateCatalog: Swift.Bool?
        /// The update behavior when the crawler finds a changed schema.
        public var updateBehavior: GlueClientTypes.UpdateCatalogBehavior?

        public init(
            enableUpdateCatalog: Swift.Bool? = nil,
            updateBehavior: GlueClientTypes.UpdateCatalogBehavior? = nil
        )
        {
            self.enableUpdateCatalog = enableUpdateCatalog
            self.updateBehavior = updateBehavior
        }
    }
}

extension GlueClientTypes {

    /// Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.
    public struct GovernedCatalogTarget: Swift.Sendable {
        /// The name of the database to write to.
        /// This member is required.
        public var database: Swift.String?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies native partitioning using a sequence of keys.
        public var partitionKeys: [[Swift.String]]?
        /// A policy that specifies update behavior for the governed catalog.
        public var schemaChangePolicy: GlueClientTypes.CatalogSchemaChangePolicy?
        /// The name of the table in the database to write to.
        /// This member is required.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            partitionKeys: [[Swift.String]]? = nil,
            schemaChangePolicy: GlueClientTypes.CatalogSchemaChangePolicy? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.schemaChangePolicy = schemaChangePolicy
            self.table = table
        }
    }
}

extension GlueClientTypes {

    public enum JDBCDataType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case array
        case bigint
        case binary
        case bit
        case blob
        case boolean
        case char
        case clob
        case datalink
        case date
        case decimal
        case distinct
        case double
        case float
        case integer
        case javaObject
        case longnvarchar
        case longvarbinary
        case longvarchar
        case nchar
        case nclob
        case null
        case numeric
        case nvarchar
        case other
        case real
        case ref
        case refCursor
        case rowid
        case smallint
        case sqlxml
        case `struct`
        case time
        case timestamp
        case timestampWithTimezone
        case timeWithTimezone
        case tinyint
        case varbinary
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [JDBCDataType] {
            return [
                .array,
                .bigint,
                .binary,
                .bit,
                .blob,
                .boolean,
                .char,
                .clob,
                .datalink,
                .date,
                .decimal,
                .distinct,
                .double,
                .float,
                .integer,
                .javaObject,
                .longnvarchar,
                .longvarbinary,
                .longvarchar,
                .nchar,
                .nclob,
                .null,
                .numeric,
                .nvarchar,
                .other,
                .real,
                .ref,
                .refCursor,
                .rowid,
                .smallint,
                .sqlxml,
                .struct,
                .time,
                .timestamp,
                .timestampWithTimezone,
                .timeWithTimezone,
                .tinyint,
                .varbinary,
                .varchar
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .array: return "ARRAY"
            case .bigint: return "BIGINT"
            case .binary: return "BINARY"
            case .bit: return "BIT"
            case .blob: return "BLOB"
            case .boolean: return "BOOLEAN"
            case .char: return "CHAR"
            case .clob: return "CLOB"
            case .datalink: return "DATALINK"
            case .date: return "DATE"
            case .decimal: return "DECIMAL"
            case .distinct: return "DISTINCT"
            case .double: return "DOUBLE"
            case .float: return "FLOAT"
            case .integer: return "INTEGER"
            case .javaObject: return "JAVA_OBJECT"
            case .longnvarchar: return "LONGNVARCHAR"
            case .longvarbinary: return "LONGVARBINARY"
            case .longvarchar: return "LONGVARCHAR"
            case .nchar: return "NCHAR"
            case .nclob: return "NCLOB"
            case .null: return "NULL"
            case .numeric: return "NUMERIC"
            case .nvarchar: return "NVARCHAR"
            case .other: return "OTHER"
            case .real: return "REAL"
            case .ref: return "REF"
            case .refCursor: return "REF_CURSOR"
            case .rowid: return "ROWID"
            case .smallint: return "SMALLINT"
            case .sqlxml: return "SQLXML"
            case .struct: return "STRUCT"
            case .time: return "TIME"
            case .timestamp: return "TIMESTAMP"
            case .timestampWithTimezone: return "TIMESTAMP_WITH_TIMEZONE"
            case .timeWithTimezone: return "TIME_WITH_TIMEZONE"
            case .tinyint: return "TINYINT"
            case .varbinary: return "VARBINARY"
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum GlueRecordType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bigdecimal
        case byte
        case date
        case double
        case float
        case int
        case long
        case short
        case string
        case timestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [GlueRecordType] {
            return [
                .bigdecimal,
                .byte,
                .date,
                .double,
                .float,
                .int,
                .long,
                .short,
                .string,
                .timestamp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bigdecimal: return "BIGDECIMAL"
            case .byte: return "BYTE"
            case .date: return "DATE"
            case .double: return "DOUBLE"
            case .float: return "FLOAT"
            case .int: return "INT"
            case .long: return "LONG"
            case .short: return "SHORT"
            case .string: return "STRING"
            case .timestamp: return "TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Additional connection options for the connector.
    public struct JDBCConnectorOptions: Swift.Sendable {
        /// Custom data type mapping that builds a mapping from a JDBC data type to an Glue data type. For example, the option "dataTypeMapping":{"FLOAT":"STRING"} maps data fields of JDBC type FLOAT into the Java String type by calling the ResultSet.getString() method of the driver, and uses it to build the Glue record. The ResultSet object is implemented by each driver, so the behavior is specific to the driver you use. Refer to the documentation for your JDBC driver to understand how the driver performs the conversions.
        public var dataTypeMapping: [Swift.String: GlueClientTypes.GlueRecordType]?
        /// Extra condition clause to filter data from source. For example: BillingCity='Mountain View' When using a query instead of a table name, you should validate that the query works with the specified filterPredicate.
        public var filterPredicate: Swift.String?
        /// The name of the job bookmark keys on which to sort.
        public var jobBookmarkKeys: [Swift.String]?
        /// Specifies an ascending or descending sort order.
        public var jobBookmarkKeysSortOrder: Swift.String?
        /// The minimum value of partitionColumn that is used to decide partition stride.
        public var lowerBound: Swift.Int?
        /// The number of partitions. This value, along with lowerBound (inclusive) and upperBound (exclusive), form partition strides for generated WHERE clause expressions that are used to split the partitionColumn.
        public var numPartitions: Swift.Int?
        /// The name of an integer column that is used for partitioning. This option works only when it's included with lowerBound, upperBound, and numPartitions. This option works the same way as in the Spark SQL JDBC reader.
        public var partitionColumn: Swift.String?
        /// The maximum value of partitionColumn that is used to decide partition stride.
        public var upperBound: Swift.Int?

        public init(
            dataTypeMapping: [Swift.String: GlueClientTypes.GlueRecordType]? = nil,
            filterPredicate: Swift.String? = nil,
            jobBookmarkKeys: [Swift.String]? = nil,
            jobBookmarkKeysSortOrder: Swift.String? = nil,
            lowerBound: Swift.Int? = nil,
            numPartitions: Swift.Int? = nil,
            partitionColumn: Swift.String? = nil,
            upperBound: Swift.Int? = nil
        )
        {
            self.dataTypeMapping = dataTypeMapping
            self.filterPredicate = filterPredicate
            self.jobBookmarkKeys = jobBookmarkKeys
            self.jobBookmarkKeysSortOrder = jobBookmarkKeysSortOrder
            self.lowerBound = lowerBound
            self.numPartitions = numPartitions
            self.partitionColumn = partitionColumn
            self.upperBound = upperBound
        }
    }
}

extension GlueClientTypes {

    /// Specifies a connector to a JDBC data source.
    public struct JDBCConnectorSource: Swift.Sendable {
        /// Additional connection options for the connector.
        public var additionalOptions: GlueClientTypes.JDBCConnectorOptions?
        /// The name of the connection that is associated with the connector.
        /// This member is required.
        public var connectionName: Swift.String?
        /// The name of the table in the data source.
        public var connectionTable: Swift.String?
        /// The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC data store.
        /// This member is required.
        public var connectionType: Swift.String?
        /// The name of a connector that assists with accessing the data store in Glue Studio.
        /// This member is required.
        public var connectorName: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the custom JDBC source.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?
        /// The table or SQL query to get the data from. You can specify either ConnectionTable or query, but not both.
        public var query: Swift.String?

        public init(
            additionalOptions: GlueClientTypes.JDBCConnectorOptions? = nil,
            connectionName: Swift.String? = nil,
            connectionTable: Swift.String? = nil,
            connectionType: Swift.String? = nil,
            connectorName: Swift.String? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil,
            query: Swift.String? = nil
        )
        {
            self.additionalOptions = additionalOptions
            self.connectionName = connectionName
            self.connectionTable = connectionTable
            self.connectionType = connectionType
            self.connectorName = connectorName
            self.name = name
            self.outputSchemas = outputSchemas
            self.query = query
        }
    }
}

extension GlueClientTypes {

    /// Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.
    public struct JDBCConnectorTarget: Swift.Sendable {
        /// Additional connection options for the connector.
        public var additionalOptions: [Swift.String: Swift.String]?
        /// The name of the connection that is associated with the connector.
        /// This member is required.
        public var connectionName: Swift.String?
        /// The name of the table in the data target.
        /// This member is required.
        public var connectionTable: Swift.String?
        /// The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC data target.
        /// This member is required.
        public var connectionType: Swift.String?
        /// The name of a connector that will be used.
        /// This member is required.
        public var connectorName: Swift.String?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the JDBC target.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?

        public init(
            additionalOptions: [Swift.String: Swift.String]? = nil,
            connectionName: Swift.String? = nil,
            connectionTable: Swift.String? = nil,
            connectionType: Swift.String? = nil,
            connectorName: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil
        )
        {
            self.additionalOptions = additionalOptions
            self.connectionName = connectionName
            self.connectionTable = connectionTable
            self.connectionType = connectionType
            self.connectorName = connectorName
            self.inputs = inputs
            self.name = name
            self.outputSchemas = outputSchemas
        }
    }
}

extension GlueClientTypes {

    /// Specifies a column to be joined.
    public struct JoinColumn: Swift.Sendable {
        /// The column to be joined.
        /// This member is required.
        public var from: Swift.String?
        /// The key of the column to be joined.
        /// This member is required.
        public var keys: [[Swift.String]]?

        public init(
            from: Swift.String? = nil,
            keys: [[Swift.String]]? = nil
        )
        {
            self.from = from
            self.keys = keys
        }
    }
}

extension GlueClientTypes {

    public enum JoinType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equijoin
        case `left`
        case leftAnti
        case leftSemi
        case outer
        case `right`
        case sdkUnknown(Swift.String)

        public static var allCases: [JoinType] {
            return [
                .equijoin,
                .left,
                .leftAnti,
                .leftSemi,
                .outer,
                .right
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equijoin: return "equijoin"
            case .left: return "left"
            case .leftAnti: return "leftanti"
            case .leftSemi: return "leftsemi"
            case .outer: return "outer"
            case .right: return "right"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that joins two datasets into one dataset using a comparison phrase on the specified data property keys. You can use inner, outer, left, right, left semi, and left anti joins.
    public struct Join: Swift.Sendable {
        /// A list of the two columns to be joined.
        /// This member is required.
        public var columns: [GlueClientTypes.JoinColumn]?
        /// The data inputs identified by their node names.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// Specifies the type of join to be performed on the datasets.
        /// This member is required.
        public var joinType: GlueClientTypes.JoinType?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?

        public init(
            columns: [GlueClientTypes.JoinColumn]? = nil,
            inputs: [Swift.String]? = nil,
            joinType: GlueClientTypes.JoinType? = nil,
            name: Swift.String? = nil
        )
        {
            self.columns = columns
            self.inputs = inputs
            self.joinType = joinType
            self.name = name
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that merges a DynamicFrame with a staging DynamicFrame based on the specified primary keys to identify records. Duplicate records (records with the same primary keys) are not de-duplicated.
    public struct Merge: Swift.Sendable {
        /// The data inputs identified by their node names.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?
        /// The list of primary key fields to match records from the source and staging dynamic frames.
        /// This member is required.
        public var primaryKeys: [[Swift.String]]?
        /// The source DynamicFrame that will be merged with a staging DynamicFrame.
        /// This member is required.
        public var source: Swift.String?

        public init(
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            primaryKeys: [[Swift.String]]? = nil,
            source: Swift.String? = nil
        )
        {
            self.inputs = inputs
            self.name = name
            self.primaryKeys = primaryKeys
            self.source = source
        }
    }
}

extension GlueClientTypes {

    /// Specifies a Microsoft SQL server data source in the Glue Data Catalog.
    public struct MicrosoftSQLServerCatalogSource: Swift.Sendable {
        /// The name of the database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the table in the database to read from.
        /// This member is required.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.name = name
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies a target that uses Microsoft SQL.
    public struct MicrosoftSQLServerCatalogTarget: Swift.Sendable {
        /// The name of the database to write to.
        /// This member is required.
        public var database: Swift.String?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the table in the database to write to.
        /// This member is required.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies a MySQL data source in the Glue Data Catalog.
    public struct MySQLCatalogSource: Swift.Sendable {
        /// The name of the database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the table in the database to read from.
        /// This member is required.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.name = name
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies a target that uses MySQL.
    public struct MySQLCatalogTarget: Swift.Sendable {
        /// The name of the database to write to.
        /// This member is required.
        public var database: Swift.String?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the table in the database to write to.
        /// This member is required.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies an Oracle data source in the Glue Data Catalog.
    public struct OracleSQLCatalogSource: Swift.Sendable {
        /// The name of the database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the table in the database to read from.
        /// This member is required.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.name = name
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies a target that uses Oracle SQL.
    public struct OracleSQLCatalogTarget: Swift.Sendable {
        /// The name of the database to write to.
        /// This member is required.
        public var database: Swift.String?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the table in the database to write to.
        /// This member is required.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.table = table
        }
    }
}

extension GlueClientTypes {

    public enum PiiType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case columnaudit
        case columnmasking
        case rowaudit
        case rowmasking
        case sdkUnknown(Swift.String)

        public static var allCases: [PiiType] {
            return [
                .columnaudit,
                .columnmasking,
                .rowaudit,
                .rowmasking
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .columnaudit: return "ColumnAudit"
            case .columnmasking: return "ColumnMasking"
            case .rowaudit: return "RowAudit"
            case .rowmasking: return "RowMasking"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that identifies, removes or masks PII data.
    public struct PIIDetection: Swift.Sendable {
        /// Indicates the types of entities the PIIDetection transform will identify as PII data. PII type entities include: PERSON_NAME, DATE, USA_SNN, EMAIL, USA_ITIN, USA_PASSPORT_NUMBER, PHONE_NUMBER, BANK_ACCOUNT, IP_ADDRESS, MAC_ADDRESS, USA_CPT_CODE, USA_HCPCS_CODE, USA_NATIONAL_DRUG_CODE, USA_MEDICARE_BENEFICIARY_IDENTIFIER, USA_HEALTH_INSURANCE_CLAIM_NUMBER,CREDIT_CARD,USA_NATIONAL_PROVIDER_IDENTIFIER,USA_DEA_NUMBER,USA_DRIVING_LICENSE
        /// This member is required.
        public var entityTypesToDetect: [Swift.String]?
        /// The node ID inputs to the transform.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// Indicates the value that will replace the detected entity.
        public var maskValue: Swift.String?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates the output column name that will contain any entity type detected in that row.
        public var outputColumnName: Swift.String?
        /// Indicates the type of PIIDetection transform.
        /// This member is required.
        public var piiType: GlueClientTypes.PiiType?
        /// Indicates the fraction of the data to sample when scanning for PII entities.
        public var sampleFraction: Swift.Double?
        /// Indicates the fraction of the data that must be met in order for a column to be identified as PII data.
        public var thresholdFraction: Swift.Double?

        public init(
            entityTypesToDetect: [Swift.String]? = nil,
            inputs: [Swift.String]? = nil,
            maskValue: Swift.String? = nil,
            name: Swift.String? = nil,
            outputColumnName: Swift.String? = nil,
            piiType: GlueClientTypes.PiiType? = nil,
            sampleFraction: Swift.Double? = nil,
            thresholdFraction: Swift.Double? = nil
        )
        {
            self.entityTypesToDetect = entityTypesToDetect
            self.inputs = inputs
            self.maskValue = maskValue
            self.name = name
            self.outputColumnName = outputColumnName
            self.piiType = piiType
            self.sampleFraction = sampleFraction
            self.thresholdFraction = thresholdFraction
        }
    }
}

extension GlueClientTypes {

    /// Specifies a PostgresSQL data source in the Glue Data Catalog.
    public struct PostgreSQLCatalogSource: Swift.Sendable {
        /// The name of the database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the table in the database to read from.
        /// This member is required.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.name = name
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies a target that uses Postgres SQL.
    public struct PostgreSQLCatalogTarget: Swift.Sendable {
        /// The name of the database to write to.
        /// This member is required.
        public var database: Swift.String?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the table in the database to write to.
        /// This member is required.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// A reference to a Glue DataBrew recipe.
    public struct RecipeReference: Swift.Sendable {
        /// The ARN of the DataBrew recipe.
        /// This member is required.
        public var recipeArn: Swift.String?
        /// The RecipeVersion of the DataBrew recipe.
        /// This member is required.
        public var recipeVersion: Swift.String?

        public init(
            recipeArn: Swift.String? = nil,
            recipeVersion: Swift.String? = nil
        )
        {
            self.recipeArn = recipeArn
            self.recipeVersion = recipeVersion
        }
    }
}

extension GlueClientTypes {

    /// Actions defined in the Glue Studio data preparation recipe node.
    public struct RecipeAction: Swift.Sendable {
        /// The operation of the recipe action.
        /// This member is required.
        public var operation: Swift.String?
        /// The parameters of the recipe action.
        public var parameters: [Swift.String: Swift.String]?

        public init(
            operation: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil
        )
        {
            self.operation = operation
            self.parameters = parameters
        }
    }
}

extension GlueClientTypes {

    /// Condition expression defined in the Glue Studio data preparation recipe node.
    public struct ConditionExpression: Swift.Sendable {
        /// The condition of the condition expression.
        /// This member is required.
        public var condition: Swift.String?
        /// The target column of the condition expressions.
        /// This member is required.
        public var targetColumn: Swift.String?
        /// The value of the condition expression.
        public var value: Swift.String?

        public init(
            condition: Swift.String? = nil,
            targetColumn: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.condition = condition
            self.targetColumn = targetColumn
            self.value = value
        }
    }
}

extension GlueClientTypes {

    /// A recipe step used in a Glue Studio data preparation recipe node.
    public struct RecipeStep: Swift.Sendable {
        /// The transformation action of the recipe step.
        /// This member is required.
        public var action: GlueClientTypes.RecipeAction?
        /// The condition expressions for the recipe step.
        public var conditionExpressions: [GlueClientTypes.ConditionExpression]?

        public init(
            action: GlueClientTypes.RecipeAction? = nil,
            conditionExpressions: [GlueClientTypes.ConditionExpression]? = nil
        )
        {
            self.action = action
            self.conditionExpressions = conditionExpressions
        }
    }
}

extension GlueClientTypes {

    /// A Glue Studio node that uses a Glue DataBrew recipe in Glue jobs.
    public struct Recipe: Swift.Sendable {
        /// The nodes that are inputs to the recipe node, identified by id.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the Glue Studio node.
        /// This member is required.
        public var name: Swift.String?
        /// A reference to the DataBrew recipe used by the node.
        public var recipeReference: GlueClientTypes.RecipeReference?
        /// Transform steps used in the recipe node.
        public var recipeSteps: [GlueClientTypes.RecipeStep]?

        public init(
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            recipeReference: GlueClientTypes.RecipeReference? = nil,
            recipeSteps: [GlueClientTypes.RecipeStep]? = nil
        )
        {
            self.inputs = inputs
            self.name = name
            self.recipeReference = recipeReference
            self.recipeSteps = recipeSteps
        }
    }
}

extension GlueClientTypes {

    /// Specifies an Amazon Redshift data store.
    public struct RedshiftSource: Swift.Sendable {
        /// The database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the Amazon Redshift data store.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon S3 path where temporary data can be staged when copying out of the database.
        public var redshiftTmpDir: Swift.String?
        /// The database table to read from.
        /// This member is required.
        public var table: Swift.String?
        /// The IAM role with permissions.
        public var tmpDirIAMRole: Swift.String?

        public init(
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            redshiftTmpDir: Swift.String? = nil,
            table: Swift.String? = nil,
            tmpDirIAMRole: Swift.String? = nil
        )
        {
            self.database = database
            self.name = name
            self.redshiftTmpDir = redshiftTmpDir
            self.table = table
            self.tmpDirIAMRole = tmpDirIAMRole
        }
    }
}

extension GlueClientTypes {

    /// The options to configure an upsert operation when writing to a Redshift target .
    public struct UpsertRedshiftTargetOptions: Swift.Sendable {
        /// The name of the connection to use to write to Redshift.
        public var connectionName: Swift.String?
        /// The physical location of the Redshift table.
        public var tableLocation: Swift.String?
        /// The keys used to determine whether to perform an update or insert.
        public var upsertKeys: [Swift.String]?

        public init(
            connectionName: Swift.String? = nil,
            tableLocation: Swift.String? = nil,
            upsertKeys: [Swift.String]? = nil
        )
        {
            self.connectionName = connectionName
            self.tableLocation = tableLocation
            self.upsertKeys = upsertKeys
        }
    }
}

extension GlueClientTypes {

    /// Specifies a target that uses Amazon Redshift.
    public struct RedshiftTarget: Swift.Sendable {
        /// The name of the database to write to.
        /// This member is required.
        public var database: Swift.String?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon S3 path where temporary data can be staged when copying out of the database.
        public var redshiftTmpDir: Swift.String?
        /// The name of the table in the database to write to.
        /// This member is required.
        public var table: Swift.String?
        /// The IAM role with permissions.
        public var tmpDirIAMRole: Swift.String?
        /// The set of options to configure an upsert operation when writing to a Redshift target.
        public var upsertRedshiftOptions: GlueClientTypes.UpsertRedshiftTargetOptions?

        public init(
            database: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            redshiftTmpDir: Swift.String? = nil,
            table: Swift.String? = nil,
            tmpDirIAMRole: Swift.String? = nil,
            upsertRedshiftOptions: GlueClientTypes.UpsertRedshiftTargetOptions? = nil
        )
        {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.redshiftTmpDir = redshiftTmpDir
            self.table = table
            self.tmpDirIAMRole = tmpDirIAMRole
            self.upsertRedshiftOptions = upsertRedshiftOptions
        }
    }
}

extension GlueClientTypes {

    /// Specifies a Relational database data source in the Glue Data Catalog.
    public struct RelationalCatalogSource: Swift.Sendable {
        /// The name of the database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the table in the database to read from.
        /// This member is required.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.name = name
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that renames a single data property key.
    public struct RenameField: Swift.Sendable {
        /// The data inputs identified by their node names.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?
        /// A JSON path to a variable in the data structure for the source data.
        /// This member is required.
        public var sourcePath: [Swift.String]?
        /// A JSON path to a variable in the data structure for the target data.
        /// This member is required.
        public var targetPath: [Swift.String]?

        public init(
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            sourcePath: [Swift.String]? = nil,
            targetPath: [Swift.String]? = nil
        )
        {
            self.inputs = inputs
            self.name = name
            self.sourcePath = sourcePath
            self.targetPath = targetPath
        }
    }
}

extension GlueClientTypes {

    /// Specifies a Delta Lake data source that is registered in the Glue Data Catalog. The data source must be stored in Amazon S3.
    public struct S3CatalogDeltaSource: Swift.Sendable {
        /// Specifies additional connection options.
        public var additionalDeltaOptions: [Swift.String: Swift.String]?
        /// The name of the database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the Delta Lake data source.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the Delta Lake source.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?
        /// The name of the table in the database to read from.
        /// This member is required.
        public var table: Swift.String?

        public init(
            additionalDeltaOptions: [Swift.String: Swift.String]? = nil,
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil,
            table: Swift.String? = nil
        )
        {
            self.additionalDeltaOptions = additionalDeltaOptions
            self.database = database
            self.name = name
            self.outputSchemas = outputSchemas
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies a Hudi data source that is registered in the Glue Data Catalog. The Hudi data source must be stored in Amazon S3.
    public struct S3CatalogHudiSource: Swift.Sendable {
        /// Specifies additional connection options.
        public var additionalHudiOptions: [Swift.String: Swift.String]?
        /// The name of the database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the Hudi data source.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the Hudi source.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?
        /// The name of the table in the database to read from.
        /// This member is required.
        public var table: Swift.String?

        public init(
            additionalHudiOptions: [Swift.String: Swift.String]? = nil,
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil,
            table: Swift.String? = nil
        )
        {
            self.additionalHudiOptions = additionalHudiOptions
            self.database = database
            self.name = name
            self.outputSchemas = outputSchemas
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies an Amazon S3 data store in the Glue Data Catalog.
    public struct S3CatalogSource: Swift.Sendable {
        /// Specifies additional connection options.
        public var additionalOptions: GlueClientTypes.S3SourceAdditionalOptions?
        /// The database to read from.
        /// This member is required.
        public var database: Swift.String?
        /// The name of the data store.
        /// This member is required.
        public var name: Swift.String?
        /// Partitions satisfying this predicate are deleted. Files within the retention period in these partitions are not deleted. Set to "" – empty by default.
        public var partitionPredicate: Swift.String?
        /// The database table to read from.
        /// This member is required.
        public var table: Swift.String?

        public init(
            additionalOptions: GlueClientTypes.S3SourceAdditionalOptions? = nil,
            database: Swift.String? = nil,
            name: Swift.String? = nil,
            partitionPredicate: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.additionalOptions = additionalOptions
            self.database = database
            self.name = name
            self.partitionPredicate = partitionPredicate
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.
    public struct S3CatalogTarget: Swift.Sendable {
        /// The name of the database to write to.
        /// This member is required.
        public var database: Swift.String?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies native partitioning using a sequence of keys.
        public var partitionKeys: [[Swift.String]]?
        /// A policy that specifies update behavior for the crawler.
        public var schemaChangePolicy: GlueClientTypes.CatalogSchemaChangePolicy?
        /// The name of the table in the database to write to.
        /// This member is required.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            partitionKeys: [[Swift.String]]? = nil,
            schemaChangePolicy: GlueClientTypes.CatalogSchemaChangePolicy? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.schemaChangePolicy = schemaChangePolicy
            self.table = table
        }
    }
}

extension GlueClientTypes {

    /// Specifies additional connection options for the Amazon S3 data store.
    public struct S3DirectSourceAdditionalOptions: Swift.Sendable {
        /// Sets the upper limit for the target number of files that will be processed.
        public var boundedFiles: Swift.Int?
        /// Sets the upper limit for the target size of the dataset in bytes that will be processed.
        public var boundedSize: Swift.Int?
        /// Sets option to enable a sample path.
        public var enableSamplePath: Swift.Bool?
        /// If enabled, specifies the sample path.
        public var samplePath: Swift.String?

        public init(
            boundedFiles: Swift.Int? = nil,
            boundedSize: Swift.Int? = nil,
            enableSamplePath: Swift.Bool? = nil,
            samplePath: Swift.String? = nil
        )
        {
            self.boundedFiles = boundedFiles
            self.boundedSize = boundedSize
            self.enableSamplePath = enableSamplePath
            self.samplePath = samplePath
        }
    }
}

extension GlueClientTypes {

    public enum CompressionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bzip2
        case gzip
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionType] {
            return [
                .bzip2,
                .gzip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bzip2: return "bzip2"
            case .gzip: return "gzip"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum QuoteChar: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case quillemet
        case quote
        case singleQuote
        case sdkUnknown(Swift.String)

        public static var allCases: [QuoteChar] {
            return [
                .disabled,
                .quillemet,
                .quote,
                .singleQuote
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .quillemet: return "quillemet"
            case .quote: return "quote"
            case .singleQuote: return "single_quote"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum Separator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case comma
        case ctrla
        case pipe
        case semicolon
        case tab
        case sdkUnknown(Swift.String)

        public static var allCases: [Separator] {
            return [
                .comma,
                .ctrla,
                .pipe,
                .semicolon,
                .tab
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .comma: return "comma"
            case .ctrla: return "ctrla"
            case .pipe: return "pipe"
            case .semicolon: return "semicolon"
            case .tab: return "tab"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies a command-separated value (CSV) data store stored in Amazon S3.
    public struct S3CsvSource: Swift.Sendable {
        /// Specifies additional connection options.
        public var additionalOptions: GlueClientTypes.S3DirectSourceAdditionalOptions?
        /// Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are "gzip" and "bzip").
        public var compressionType: GlueClientTypes.CompressionType?
        /// Specifies a character to use for escaping. This option is used only when reading CSV files. The default value is none. If enabled, the character which immediately follows is used as-is, except for a small set of well-known escapes (\n, \r, \t, and \0).
        public var escaper: Swift.String?
        /// A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files.
        public var exclusions: [Swift.String]?
        /// Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to "none".
        public var groupFiles: Swift.String?
        /// The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, "groupFiles" must be set to "inPartition" for this to take effect.
        public var groupSize: Swift.String?
        /// This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.
        public var maxBand: Swift.Int?
        /// This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.
        public var maxFilesInBand: Swift.Int?
        /// A Boolean value that specifies whether a single record can span multiple lines. This can occur when a field contains a quoted new-line character. You must set this option to True if any record spans multiple lines. The default value is False, which allows for more aggressive file-splitting during parsing.
        public var multiline: Swift.Bool?
        /// The name of the data store.
        /// This member is required.
        public var name: Swift.String?
        /// A Boolean value that specifies whether to use the advanced SIMD CSV reader along with Apache Arrow based columnar memory formats. Only available in Glue version 3.0.
        public var optimizePerformance: Swift.Bool
        /// Specifies the data schema for the S3 CSV source.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?
        /// A list of the Amazon S3 paths to read from.
        /// This member is required.
        public var paths: [Swift.String]?
        /// Specifies the character to use for quoting. The default is a double quote: '"'. Set this to -1 to turn off quoting entirely.
        /// This member is required.
        public var quoteChar: GlueClientTypes.QuoteChar?
        /// If set to true, recursively reads files in all subdirectories under the specified paths.
        public var recurse: Swift.Bool?
        /// Specifies the delimiter character. The default is a comma: ",", but any other character can be specified.
        /// This member is required.
        public var separator: GlueClientTypes.Separator?
        /// A Boolean value that specifies whether to skip the first data line. The default value is False.
        public var skipFirst: Swift.Bool?
        /// A Boolean value that specifies whether to treat the first line as a header. The default value is False.
        public var withHeader: Swift.Bool?
        /// A Boolean value that specifies whether to write the header to output. The default value is True.
        public var writeHeader: Swift.Bool?

        public init(
            additionalOptions: GlueClientTypes.S3DirectSourceAdditionalOptions? = nil,
            compressionType: GlueClientTypes.CompressionType? = nil,
            escaper: Swift.String? = nil,
            exclusions: [Swift.String]? = nil,
            groupFiles: Swift.String? = nil,
            groupSize: Swift.String? = nil,
            maxBand: Swift.Int? = nil,
            maxFilesInBand: Swift.Int? = nil,
            multiline: Swift.Bool? = nil,
            name: Swift.String? = nil,
            optimizePerformance: Swift.Bool = false,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil,
            paths: [Swift.String]? = nil,
            quoteChar: GlueClientTypes.QuoteChar? = nil,
            recurse: Swift.Bool? = nil,
            separator: GlueClientTypes.Separator? = nil,
            skipFirst: Swift.Bool? = nil,
            withHeader: Swift.Bool? = nil,
            writeHeader: Swift.Bool? = nil
        )
        {
            self.additionalOptions = additionalOptions
            self.compressionType = compressionType
            self.escaper = escaper
            self.exclusions = exclusions
            self.groupFiles = groupFiles
            self.groupSize = groupSize
            self.maxBand = maxBand
            self.maxFilesInBand = maxFilesInBand
            self.multiline = multiline
            self.name = name
            self.optimizePerformance = optimizePerformance
            self.outputSchemas = outputSchemas
            self.paths = paths
            self.quoteChar = quoteChar
            self.recurse = recurse
            self.separator = separator
            self.skipFirst = skipFirst
            self.withHeader = withHeader
            self.writeHeader = writeHeader
        }
    }
}

extension GlueClientTypes {

    /// Specifies a target that writes to a Delta Lake data source in the Glue Data Catalog.
    public struct S3DeltaCatalogTarget: Swift.Sendable {
        /// Specifies additional connection options for the connector.
        public var additionalOptions: [Swift.String: Swift.String]?
        /// The name of the database to write to.
        /// This member is required.
        public var database: Swift.String?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies native partitioning using a sequence of keys.
        public var partitionKeys: [[Swift.String]]?
        /// A policy that specifies update behavior for the crawler.
        public var schemaChangePolicy: GlueClientTypes.CatalogSchemaChangePolicy?
        /// The name of the table in the database to write to.
        /// This member is required.
        public var table: Swift.String?

        public init(
            additionalOptions: [Swift.String: Swift.String]? = nil,
            database: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            partitionKeys: [[Swift.String]]? = nil,
            schemaChangePolicy: GlueClientTypes.CatalogSchemaChangePolicy? = nil,
            table: Swift.String? = nil
        )
        {
            self.additionalOptions = additionalOptions
            self.database = database
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.schemaChangePolicy = schemaChangePolicy
            self.table = table
        }
    }
}

extension GlueClientTypes {

    public enum DeltaTargetCompressionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case snappy
        case uncompressed
        case sdkUnknown(Swift.String)

        public static var allCases: [DeltaTargetCompressionType] {
            return [
                .snappy,
                .uncompressed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .snappy: return "snappy"
            case .uncompressed: return "uncompressed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum TargetFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case avro
        case csv
        case delta
        case hudi
        case json
        case orc
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetFormat] {
            return [
                .avro,
                .csv,
                .delta,
                .hudi,
                .json,
                .orc,
                .parquet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .avro: return "avro"
            case .csv: return "csv"
            case .delta: return "delta"
            case .hudi: return "hudi"
            case .json: return "json"
            case .orc: return "orc"
            case .parquet: return "parquet"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A policy that specifies update behavior for the crawler.
    public struct DirectSchemaChangePolicy: Swift.Sendable {
        /// Specifies the database that the schema change policy applies to.
        public var database: Swift.String?
        /// Whether to use the specified update behavior when the crawler finds a changed schema.
        public var enableUpdateCatalog: Swift.Bool?
        /// Specifies the table in the database that the schema change policy applies to.
        public var table: Swift.String?
        /// The update behavior when the crawler finds a changed schema.
        public var updateBehavior: GlueClientTypes.UpdateCatalogBehavior?

        public init(
            database: Swift.String? = nil,
            enableUpdateCatalog: Swift.Bool? = nil,
            table: Swift.String? = nil,
            updateBehavior: GlueClientTypes.UpdateCatalogBehavior? = nil
        )
        {
            self.database = database
            self.enableUpdateCatalog = enableUpdateCatalog
            self.table = table
            self.updateBehavior = updateBehavior
        }
    }
}

extension GlueClientTypes {

    /// Specifies a target that writes to a Delta Lake data source in Amazon S3.
    public struct S3DeltaDirectTarget: Swift.Sendable {
        /// Specifies additional connection options for the connector.
        public var additionalOptions: [Swift.String: Swift.String]?
        /// Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are "gzip" and "bzip").
        /// This member is required.
        public var compression: GlueClientTypes.DeltaTargetCompressionType?
        /// Specifies the data output format for the target.
        /// This member is required.
        public var format: GlueClientTypes.TargetFormat?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies native partitioning using a sequence of keys.
        public var partitionKeys: [[Swift.String]]?
        /// The Amazon S3 path of your Delta Lake data source to write to.
        /// This member is required.
        public var path: Swift.String?
        /// A policy that specifies update behavior for the crawler.
        public var schemaChangePolicy: GlueClientTypes.DirectSchemaChangePolicy?

        public init(
            additionalOptions: [Swift.String: Swift.String]? = nil,
            compression: GlueClientTypes.DeltaTargetCompressionType? = nil,
            format: GlueClientTypes.TargetFormat? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            partitionKeys: [[Swift.String]]? = nil,
            path: Swift.String? = nil,
            schemaChangePolicy: GlueClientTypes.DirectSchemaChangePolicy? = nil
        )
        {
            self.additionalOptions = additionalOptions
            self.compression = compression
            self.format = format
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.path = path
            self.schemaChangePolicy = schemaChangePolicy
        }
    }
}

extension GlueClientTypes {

    /// Specifies a Delta Lake data source stored in Amazon S3.
    public struct S3DeltaSource: Swift.Sendable {
        /// Specifies additional connection options.
        public var additionalDeltaOptions: [Swift.String: Swift.String]?
        /// Specifies additional options for the connector.
        public var additionalOptions: GlueClientTypes.S3DirectSourceAdditionalOptions?
        /// The name of the Delta Lake source.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the Delta Lake source.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?
        /// A list of the Amazon S3 paths to read from.
        /// This member is required.
        public var paths: [Swift.String]?

        public init(
            additionalDeltaOptions: [Swift.String: Swift.String]? = nil,
            additionalOptions: GlueClientTypes.S3DirectSourceAdditionalOptions? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil,
            paths: [Swift.String]? = nil
        )
        {
            self.additionalDeltaOptions = additionalDeltaOptions
            self.additionalOptions = additionalOptions
            self.name = name
            self.outputSchemas = outputSchemas
            self.paths = paths
        }
    }
}

extension GlueClientTypes {

    /// Specifies a data target that writes to Amazon S3.
    public struct S3DirectTarget: Swift.Sendable {
        /// Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are "gzip" and "bzip").
        public var compression: Swift.String?
        /// Specifies the data output format for the target.
        /// This member is required.
        public var format: GlueClientTypes.TargetFormat?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies native partitioning using a sequence of keys.
        public var partitionKeys: [[Swift.String]]?
        /// A single Amazon S3 path to write to.
        /// This member is required.
        public var path: Swift.String?
        /// A policy that specifies update behavior for the crawler.
        public var schemaChangePolicy: GlueClientTypes.DirectSchemaChangePolicy?

        public init(
            compression: Swift.String? = nil,
            format: GlueClientTypes.TargetFormat? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            partitionKeys: [[Swift.String]]? = nil,
            path: Swift.String? = nil,
            schemaChangePolicy: GlueClientTypes.DirectSchemaChangePolicy? = nil
        )
        {
            self.compression = compression
            self.format = format
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.path = path
            self.schemaChangePolicy = schemaChangePolicy
        }
    }
}

extension GlueClientTypes {

    public enum ParquetCompressionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gzip
        case lzo
        case `none`
        case snappy
        case uncompressed
        case sdkUnknown(Swift.String)

        public static var allCases: [ParquetCompressionType] {
            return [
                .gzip,
                .lzo,
                .none,
                .snappy,
                .uncompressed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "gzip"
            case .lzo: return "lzo"
            case .none: return "none"
            case .snappy: return "snappy"
            case .uncompressed: return "uncompressed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.
    public struct S3GlueParquetTarget: Swift.Sendable {
        /// Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are "gzip" and "bzip").
        public var compression: GlueClientTypes.ParquetCompressionType?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies native partitioning using a sequence of keys.
        public var partitionKeys: [[Swift.String]]?
        /// A single Amazon S3 path to write to.
        /// This member is required.
        public var path: Swift.String?
        /// A policy that specifies update behavior for the crawler.
        public var schemaChangePolicy: GlueClientTypes.DirectSchemaChangePolicy?

        public init(
            compression: GlueClientTypes.ParquetCompressionType? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            partitionKeys: [[Swift.String]]? = nil,
            path: Swift.String? = nil,
            schemaChangePolicy: GlueClientTypes.DirectSchemaChangePolicy? = nil
        )
        {
            self.compression = compression
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.path = path
            self.schemaChangePolicy = schemaChangePolicy
        }
    }
}

extension GlueClientTypes {

    /// Specifies a target that writes to a Hudi data source in the Glue Data Catalog.
    public struct S3HudiCatalogTarget: Swift.Sendable {
        /// Specifies additional connection options for the connector.
        /// This member is required.
        public var additionalOptions: [Swift.String: Swift.String]?
        /// The name of the database to write to.
        /// This member is required.
        public var database: Swift.String?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies native partitioning using a sequence of keys.
        public var partitionKeys: [[Swift.String]]?
        /// A policy that specifies update behavior for the crawler.
        public var schemaChangePolicy: GlueClientTypes.CatalogSchemaChangePolicy?
        /// The name of the table in the database to write to.
        /// This member is required.
        public var table: Swift.String?

        public init(
            additionalOptions: [Swift.String: Swift.String]? = nil,
            database: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            partitionKeys: [[Swift.String]]? = nil,
            schemaChangePolicy: GlueClientTypes.CatalogSchemaChangePolicy? = nil,
            table: Swift.String? = nil
        )
        {
            self.additionalOptions = additionalOptions
            self.database = database
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.schemaChangePolicy = schemaChangePolicy
            self.table = table
        }
    }
}

extension GlueClientTypes {

    public enum HudiTargetCompressionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gzip
        case lzo
        case snappy
        case uncompressed
        case sdkUnknown(Swift.String)

        public static var allCases: [HudiTargetCompressionType] {
            return [
                .gzip,
                .lzo,
                .snappy,
                .uncompressed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "gzip"
            case .lzo: return "lzo"
            case .snappy: return "snappy"
            case .uncompressed: return "uncompressed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies a target that writes to a Hudi data source in Amazon S3.
    public struct S3HudiDirectTarget: Swift.Sendable {
        /// Specifies additional connection options for the connector.
        /// This member is required.
        public var additionalOptions: [Swift.String: Swift.String]?
        /// Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are "gzip" and "bzip").
        /// This member is required.
        public var compression: GlueClientTypes.HudiTargetCompressionType?
        /// Specifies the data output format for the target.
        /// This member is required.
        public var format: GlueClientTypes.TargetFormat?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies native partitioning using a sequence of keys.
        public var partitionKeys: [[Swift.String]]?
        /// The Amazon S3 path of your Hudi data source to write to.
        /// This member is required.
        public var path: Swift.String?
        /// A policy that specifies update behavior for the crawler.
        public var schemaChangePolicy: GlueClientTypes.DirectSchemaChangePolicy?

        public init(
            additionalOptions: [Swift.String: Swift.String]? = nil,
            compression: GlueClientTypes.HudiTargetCompressionType? = nil,
            format: GlueClientTypes.TargetFormat? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            partitionKeys: [[Swift.String]]? = nil,
            path: Swift.String? = nil,
            schemaChangePolicy: GlueClientTypes.DirectSchemaChangePolicy? = nil
        )
        {
            self.additionalOptions = additionalOptions
            self.compression = compression
            self.format = format
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.path = path
            self.schemaChangePolicy = schemaChangePolicy
        }
    }
}

extension GlueClientTypes {

    /// Specifies a Hudi data source stored in Amazon S3.
    public struct S3HudiSource: Swift.Sendable {
        /// Specifies additional connection options.
        public var additionalHudiOptions: [Swift.String: Swift.String]?
        /// Specifies additional options for the connector.
        public var additionalOptions: GlueClientTypes.S3DirectSourceAdditionalOptions?
        /// The name of the Hudi source.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the Hudi source.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?
        /// A list of the Amazon S3 paths to read from.
        /// This member is required.
        public var paths: [Swift.String]?

        public init(
            additionalHudiOptions: [Swift.String: Swift.String]? = nil,
            additionalOptions: GlueClientTypes.S3DirectSourceAdditionalOptions? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil,
            paths: [Swift.String]? = nil
        )
        {
            self.additionalHudiOptions = additionalHudiOptions
            self.additionalOptions = additionalOptions
            self.name = name
            self.outputSchemas = outputSchemas
            self.paths = paths
        }
    }
}

extension GlueClientTypes {

    /// Specifies a JSON data store stored in Amazon S3.
    public struct S3JsonSource: Swift.Sendable {
        /// Specifies additional connection options.
        public var additionalOptions: GlueClientTypes.S3DirectSourceAdditionalOptions?
        /// Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are "gzip" and "bzip").
        public var compressionType: GlueClientTypes.CompressionType?
        /// A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files.
        public var exclusions: [Swift.String]?
        /// Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to "none".
        public var groupFiles: Swift.String?
        /// The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, "groupFiles" must be set to "inPartition" for this to take effect.
        public var groupSize: Swift.String?
        /// A JsonPath string defining the JSON data.
        public var jsonPath: Swift.String?
        /// This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.
        public var maxBand: Swift.Int?
        /// This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.
        public var maxFilesInBand: Swift.Int?
        /// A Boolean value that specifies whether a single record can span multiple lines. This can occur when a field contains a quoted new-line character. You must set this option to True if any record spans multiple lines. The default value is False, which allows for more aggressive file-splitting during parsing.
        public var multiline: Swift.Bool?
        /// The name of the data store.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the S3 JSON source.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?
        /// A list of the Amazon S3 paths to read from.
        /// This member is required.
        public var paths: [Swift.String]?
        /// If set to true, recursively reads files in all subdirectories under the specified paths.
        public var recurse: Swift.Bool?

        public init(
            additionalOptions: GlueClientTypes.S3DirectSourceAdditionalOptions? = nil,
            compressionType: GlueClientTypes.CompressionType? = nil,
            exclusions: [Swift.String]? = nil,
            groupFiles: Swift.String? = nil,
            groupSize: Swift.String? = nil,
            jsonPath: Swift.String? = nil,
            maxBand: Swift.Int? = nil,
            maxFilesInBand: Swift.Int? = nil,
            multiline: Swift.Bool? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil,
            paths: [Swift.String]? = nil,
            recurse: Swift.Bool? = nil
        )
        {
            self.additionalOptions = additionalOptions
            self.compressionType = compressionType
            self.exclusions = exclusions
            self.groupFiles = groupFiles
            self.groupSize = groupSize
            self.jsonPath = jsonPath
            self.maxBand = maxBand
            self.maxFilesInBand = maxFilesInBand
            self.multiline = multiline
            self.name = name
            self.outputSchemas = outputSchemas
            self.paths = paths
            self.recurse = recurse
        }
    }
}

extension GlueClientTypes {

    /// Specifies an Apache Parquet data store stored in Amazon S3.
    public struct S3ParquetSource: Swift.Sendable {
        /// Specifies additional connection options.
        public var additionalOptions: GlueClientTypes.S3DirectSourceAdditionalOptions?
        /// Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are "gzip" and "bzip").
        public var compressionType: GlueClientTypes.ParquetCompressionType?
        /// A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files.
        public var exclusions: [Swift.String]?
        /// Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to "none".
        public var groupFiles: Swift.String?
        /// The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, "groupFiles" must be set to "inPartition" for this to take effect.
        public var groupSize: Swift.String?
        /// This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.
        public var maxBand: Swift.Int?
        /// This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.
        public var maxFilesInBand: Swift.Int?
        /// The name of the data store.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the S3 Parquet source.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?
        /// A list of the Amazon S3 paths to read from.
        /// This member is required.
        public var paths: [Swift.String]?
        /// If set to true, recursively reads files in all subdirectories under the specified paths.
        public var recurse: Swift.Bool?

        public init(
            additionalOptions: GlueClientTypes.S3DirectSourceAdditionalOptions? = nil,
            compressionType: GlueClientTypes.ParquetCompressionType? = nil,
            exclusions: [Swift.String]? = nil,
            groupFiles: Swift.String? = nil,
            groupSize: Swift.String? = nil,
            maxBand: Swift.Int? = nil,
            maxFilesInBand: Swift.Int? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil,
            paths: [Swift.String]? = nil,
            recurse: Swift.Bool? = nil
        )
        {
            self.additionalOptions = additionalOptions
            self.compressionType = compressionType
            self.exclusions = exclusions
            self.groupFiles = groupFiles
            self.groupSize = groupSize
            self.maxBand = maxBand
            self.maxFilesInBand = maxFilesInBand
            self.name = name
            self.outputSchemas = outputSchemas
            self.paths = paths
            self.recurse = recurse
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that chooses the data property keys that you want to keep.
    public struct SelectFields: Swift.Sendable {
        /// The data inputs identified by their node names.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?
        /// A JSON path to a variable in the data structure.
        /// This member is required.
        public var paths: [[Swift.String]]?

        public init(
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            paths: [[Swift.String]]? = nil
        )
        {
            self.inputs = inputs
            self.name = name
            self.paths = paths
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that chooses one DynamicFrame from a collection of DynamicFrames. The output is the selected DynamicFrame
    public struct SelectFromCollection: Swift.Sendable {
        /// The index for the DynamicFrame to be selected.
        /// This member is required.
        public var index: Swift.Int
        /// The data inputs identified by their node names.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?

        public init(
            index: Swift.Int = 0,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.index = index
            self.inputs = inputs
            self.name = name
        }
    }
}

extension GlueClientTypes {

    /// Specifies configuration for Snowflake nodes in Glue Studio.
    public struct SnowflakeNodeData: Swift.Sendable {
        /// Specifies what action to take when writing to a table with preexisting data. Valid values:  append, merge, truncate, drop.
        public var action: Swift.String?
        /// Specifies additional options passed to the Snowflake connector. If options are specified elsewhere in this node, this will take precedence.
        public var additionalOptions: [Swift.String: Swift.String]?
        /// Specifies whether automatic query pushdown is enabled. If pushdown is enabled, then when a query is run on Spark, if part of the query can be "pushed down" to the Snowflake server, it is pushed down. This improves performance of some queries.
        public var autoPushdown: Swift.Bool
        /// Specifies a Glue Data Catalog Connection to a Snowflake endpoint.
        public var connection: GlueClientTypes.Option?
        /// Specifies a Snowflake database for your node to use.
        public var database: Swift.String?
        /// Not currently used.
        public var iamRole: GlueClientTypes.Option?
        /// Specifies a merge action. Valid values: simple, custom. If simple, merge behavior is defined by MergeWhenMatched and  MergeWhenNotMatched. If custom, defined by MergeClause.
        public var mergeAction: Swift.String?
        /// A SQL statement that specifies a custom merge behavior.
        public var mergeClause: Swift.String?
        /// Specifies how to resolve records that match preexisting data when merging. Valid values:  update, delete.
        public var mergeWhenMatched: Swift.String?
        /// Specifies how to process records that do not match preexisting data when merging. Valid values: insert, none.
        public var mergeWhenNotMatched: Swift.String?
        /// A SQL string run after the Snowflake connector performs its standard actions.
        public var postAction: Swift.String?
        /// A SQL string run before the Snowflake connector performs its standard actions.
        public var preAction: Swift.String?
        /// A SQL string used to retrieve data with the query sourcetype.
        public var sampleQuery: Swift.String?
        /// Specifies a Snowflake database schema for your node to use.
        public var schema: Swift.String?
        /// Specifies the columns combined to identify a record when detecting matches for merges and upserts. A list of structures with value, label and  description keys. Each structure describes a column.
        public var selectedColumns: [GlueClientTypes.Option]?
        /// Specifies how retrieved data is specified. Valid values: "table",  "query".
        public var sourceType: Swift.String?
        /// The name of a staging table used when performing merge or upsert append actions. Data is written to this table, then moved to table by a generated postaction.
        public var stagingTable: Swift.String?
        /// Specifies a Snowflake table for your node to use.
        public var table: Swift.String?
        /// Manually defines the target schema for the node. A list of structures with value , label and description keys. Each structure defines a column.
        public var tableSchema: [GlueClientTypes.Option]?
        /// Not currently used.
        public var tempDir: Swift.String?
        /// Used when Action is append. Specifies the resolution behavior when a row already exists. If true, preexisting rows will be updated. If false, those rows will be inserted.
        public var upsert: Swift.Bool

        public init(
            action: Swift.String? = nil,
            additionalOptions: [Swift.String: Swift.String]? = nil,
            autoPushdown: Swift.Bool = false,
            connection: GlueClientTypes.Option? = nil,
            database: Swift.String? = nil,
            iamRole: GlueClientTypes.Option? = nil,
            mergeAction: Swift.String? = nil,
            mergeClause: Swift.String? = nil,
            mergeWhenMatched: Swift.String? = nil,
            mergeWhenNotMatched: Swift.String? = nil,
            postAction: Swift.String? = nil,
            preAction: Swift.String? = nil,
            sampleQuery: Swift.String? = nil,
            schema: Swift.String? = nil,
            selectedColumns: [GlueClientTypes.Option]? = nil,
            sourceType: Swift.String? = nil,
            stagingTable: Swift.String? = nil,
            table: Swift.String? = nil,
            tableSchema: [GlueClientTypes.Option]? = nil,
            tempDir: Swift.String? = nil,
            upsert: Swift.Bool = false
        )
        {
            self.action = action
            self.additionalOptions = additionalOptions
            self.autoPushdown = autoPushdown
            self.connection = connection
            self.database = database
            self.iamRole = iamRole
            self.mergeAction = mergeAction
            self.mergeClause = mergeClause
            self.mergeWhenMatched = mergeWhenMatched
            self.mergeWhenNotMatched = mergeWhenNotMatched
            self.postAction = postAction
            self.preAction = preAction
            self.sampleQuery = sampleQuery
            self.schema = schema
            self.selectedColumns = selectedColumns
            self.sourceType = sourceType
            self.stagingTable = stagingTable
            self.table = table
            self.tableSchema = tableSchema
            self.tempDir = tempDir
            self.upsert = upsert
        }
    }
}

extension GlueClientTypes {

    /// Specifies a Snowflake data source.
    public struct SnowflakeSource: Swift.Sendable {
        /// Configuration for the Snowflake data source.
        /// This member is required.
        public var data: GlueClientTypes.SnowflakeNodeData?
        /// The name of the Snowflake data source.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies user-defined schemas for your output data.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?

        public init(
            data: GlueClientTypes.SnowflakeNodeData? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil
        )
        {
            self.data = data
            self.name = name
            self.outputSchemas = outputSchemas
        }
    }
}

extension GlueClientTypes {

    /// Specifies a Snowflake target.
    public struct SnowflakeTarget: Swift.Sendable {
        /// Specifies the data of the Snowflake target node.
        /// This member is required.
        public var data: GlueClientTypes.SnowflakeNodeData?
        /// The nodes that are inputs to the data target.
        public var inputs: [Swift.String]?
        /// The name of the Snowflake target.
        /// This member is required.
        public var name: Swift.String?

        public init(
            data: GlueClientTypes.SnowflakeNodeData? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.data = data
            self.inputs = inputs
            self.name = name
        }
    }
}

extension GlueClientTypes {

    /// Specifies a connector to an Apache Spark data source.
    public struct SparkConnectorSource: Swift.Sendable {
        /// Additional connection options for the connector.
        public var additionalOptions: [Swift.String: Swift.String]?
        /// The name of the connection that is associated with the connector.
        /// This member is required.
        public var connectionName: Swift.String?
        /// The type of connection, such as marketplace.spark or custom.spark, designating a connection to an Apache Spark data store.
        /// This member is required.
        public var connectionType: Swift.String?
        /// The name of a connector that assists with accessing the data store in Glue Studio.
        /// This member is required.
        public var connectorName: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies data schema for the custom spark source.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?

        public init(
            additionalOptions: [Swift.String: Swift.String]? = nil,
            connectionName: Swift.String? = nil,
            connectionType: Swift.String? = nil,
            connectorName: Swift.String? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil
        )
        {
            self.additionalOptions = additionalOptions
            self.connectionName = connectionName
            self.connectionType = connectionType
            self.connectorName = connectorName
            self.name = name
            self.outputSchemas = outputSchemas
        }
    }
}

extension GlueClientTypes {

    /// Specifies a target that uses an Apache Spark connector.
    public struct SparkConnectorTarget: Swift.Sendable {
        /// Additional connection options for the connector.
        public var additionalOptions: [Swift.String: Swift.String]?
        /// The name of a connection for an Apache Spark connector.
        /// This member is required.
        public var connectionName: Swift.String?
        /// The type of connection, such as marketplace.spark or custom.spark, designating a connection to an Apache Spark data store.
        /// This member is required.
        public var connectionType: Swift.String?
        /// The name of an Apache Spark connector.
        /// This member is required.
        public var connectorName: Swift.String?
        /// The nodes that are inputs to the data target.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the data target.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the custom spark target.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?

        public init(
            additionalOptions: [Swift.String: Swift.String]? = nil,
            connectionName: Swift.String? = nil,
            connectionType: Swift.String? = nil,
            connectorName: Swift.String? = nil,
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil
        )
        {
            self.additionalOptions = additionalOptions
            self.connectionName = connectionName
            self.connectionType = connectionType
            self.connectorName = connectorName
            self.inputs = inputs
            self.name = name
            self.outputSchemas = outputSchemas
        }
    }
}

extension GlueClientTypes {

    /// Represents a single entry in the list of values for SqlAliases.
    public struct SqlAlias: Swift.Sendable {
        /// A temporary name given to a table, or a column in a table.
        /// This member is required.
        public var alias: Swift.String?
        /// A table, or a column in a table.
        /// This member is required.
        public var from: Swift.String?

        public init(
            alias: Swift.String? = nil,
            from: Swift.String? = nil
        )
        {
            self.alias = alias
            self.from = from
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform where you enter a SQL query using Spark SQL syntax to transform the data. The output is a single DynamicFrame.
    public struct SparkSQL: Swift.Sendable {
        /// The data inputs identified by their node names. You can associate a table name with each input node to use in the SQL query. The name you choose must meet the Spark SQL naming restrictions.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the data schema for the SparkSQL transform.
        public var outputSchemas: [GlueClientTypes.GlueSchema]?
        /// A list of aliases. An alias allows you to specify what name to use in the SQL for a given input. For example, you have a datasource named "MyDataSource". If you specify From as MyDataSource, and Alias as SqlName, then in your SQL you can do: select * from SqlName and that gets data from MyDataSource.
        /// This member is required.
        public var sqlAliases: [GlueClientTypes.SqlAlias]?
        /// A SQL query that must use Spark SQL syntax and return a single data set.
        /// This member is required.
        public var sqlQuery: Swift.String?

        public init(
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            outputSchemas: [GlueClientTypes.GlueSchema]? = nil,
            sqlAliases: [GlueClientTypes.SqlAlias]? = nil,
            sqlQuery: Swift.String? = nil
        )
        {
            self.inputs = inputs
            self.name = name
            self.outputSchemas = outputSchemas
            self.sqlAliases = sqlAliases
            self.sqlQuery = sqlQuery
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that writes samples of the data to an Amazon S3 bucket.
    public struct Spigot: Swift.Sendable {
        /// The data inputs identified by their node names.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?
        /// A path in Amazon S3 where the transform will write a subset of records from the dataset to a JSON file in an Amazon S3 bucket.
        /// This member is required.
        public var path: Swift.String?
        /// The probability (a decimal value with a maximum value of 1) of picking any given record. A value of 1 indicates that each row read from the dataset should be included in the sample output.
        public var prob: Swift.Double?
        /// Specifies a number of records to write starting from the beginning of the dataset.
        public var topk: Swift.Int?

        public init(
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            prob: Swift.Double? = nil,
            topk: Swift.Int? = nil
        )
        {
            self.inputs = inputs
            self.name = name
            self.path = path
            self.prob = prob
            self.topk = topk
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that splits data property keys into two DynamicFrames. The output is a collection of DynamicFrames: one with selected data property keys, and one with the remaining data property keys.
    public struct SplitFields: Swift.Sendable {
        /// The data inputs identified by their node names.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?
        /// A JSON path to a variable in the data structure.
        /// This member is required.
        public var paths: [[Swift.String]]?

        public init(
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            paths: [[Swift.String]]? = nil
        )
        {
            self.inputs = inputs
            self.name = name
            self.paths = paths
        }
    }
}

extension GlueClientTypes {

    public enum UnionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case distinct
        case sdkUnknown(Swift.String)

        public static var allCases: [UnionType] {
            return [
                .all,
                .distinct
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .distinct: return "DISTINCT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that combines the rows from two or more datasets into a single result.
    public struct Union: Swift.Sendable {
        /// The node ID inputs to the transform.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates the type of Union transform. Specify ALL to join all rows from data sources to the resulting DynamicFrame. The resulting union does not remove duplicate rows. Specify DISTINCT to remove duplicate rows in the resulting DynamicFrame.
        /// This member is required.
        public var unionType: GlueClientTypes.UnionType?

        public init(
            inputs: [Swift.String]? = nil,
            name: Swift.String? = nil,
            unionType: GlueClientTypes.UnionType? = nil
        )
        {
            self.inputs = inputs
            self.name = name
            self.unionType = unionType
        }
    }
}

extension GlueClientTypes {

    /// Specifies code that runs when a job is run.
    public struct JobCommand: Swift.Sendable {
        /// The name of the job command. For an Apache Spark ETL job, this must be glueetl. For a Python shell job, it must be pythonshell. For an Apache Spark streaming ETL job, this must be gluestreaming. For a Ray job, this must be glueray.
        public var name: Swift.String?
        /// The Python version being used to run a Python shell job. Allowed values are 2 or 3.
        public var pythonVersion: Swift.String?
        /// In Ray jobs, Runtime is used to specify the versions of Ray, Python and additional libraries available in your environment. This field is not used in other job types. For supported runtime environment values, see [Supported Ray runtime environments](https://docs.aws.amazon.com/glue/latest/dg/ray-jobs-section.html) in the Glue Developer Guide.
        public var runtime: Swift.String?
        /// Specifies the Amazon Simple Storage Service (Amazon S3) path to a script that runs a job.
        public var scriptLocation: Swift.String?

        public init(
            name: Swift.String? = nil,
            pythonVersion: Swift.String? = nil,
            runtime: Swift.String? = nil,
            scriptLocation: Swift.String? = nil
        )
        {
            self.name = name
            self.pythonVersion = pythonVersion
            self.runtime = runtime
            self.scriptLocation = scriptLocation
        }
    }
}

extension GlueClientTypes {

    /// Specifies the connections used by a job.
    public struct ConnectionsList: Swift.Sendable {
        /// A list of connections used by the job.
        public var connections: [Swift.String]?

        public init(
            connections: [Swift.String]? = nil
        )
        {
            self.connections = connections
        }
    }
}

extension GlueClientTypes {

    public enum ExecutionClass: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case flex
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionClass] {
            return [
                .flex,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .flex: return "FLEX"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// An execution property of a job.
    public struct ExecutionProperty: Swift.Sendable {
        /// The maximum number of concurrent runs allowed for the job. The default is 1. An error is returned when this threshold is reached. The maximum value you can specify is controlled by a service limit.
        public var maxConcurrentRuns: Swift.Int

        public init(
            maxConcurrentRuns: Swift.Int = 0
        )
        {
            self.maxConcurrentRuns = maxConcurrentRuns
        }
    }
}

extension GlueClientTypes {

    public enum JobMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notebook
        case script
        case visual
        case sdkUnknown(Swift.String)

        public static var allCases: [JobMode] {
            return [
                .notebook,
                .script,
                .visual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notebook: return "NOTEBOOK"
            case .script: return "SCRIPT"
            case .visual: return "VISUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum SourceControlAuthStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsSecretsManager
        case personalAccessToken
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceControlAuthStrategy] {
            return [
                .awsSecretsManager,
                .personalAccessToken
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsSecretsManager: return "AWS_SECRETS_MANAGER"
            case .personalAccessToken: return "PERSONAL_ACCESS_TOKEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum SourceControlProvider: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsCodeCommit
        case bitbucket
        case github
        case gitlab
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceControlProvider] {
            return [
                .awsCodeCommit,
                .bitbucket,
                .github,
                .gitlab
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsCodeCommit: return "AWS_CODE_COMMIT"
            case .bitbucket: return "BITBUCKET"
            case .github: return "GITHUB"
            case .gitlab: return "GITLAB"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.
    public struct SourceControlDetails: Swift.Sendable {
        /// The type of authentication, which can be an authentication token stored in Amazon Web Services Secrets Manager, or a personal access token.
        public var authStrategy: GlueClientTypes.SourceControlAuthStrategy?
        /// The value of an authorization token.
        public var authToken: Swift.String?
        /// An optional branch in the remote repository.
        public var branch: Swift.String?
        /// An optional folder in the remote repository.
        public var folder: Swift.String?
        /// The last commit ID for a commit in the remote repository.
        public var lastCommitId: Swift.String?
        /// The owner of the remote repository that contains the job artifacts.
        public var owner: Swift.String?
        /// The provider for the remote repository.
        public var provider: GlueClientTypes.SourceControlProvider?
        /// The name of the remote repository that contains the job artifacts.
        public var repository: Swift.String?

        public init(
            authStrategy: GlueClientTypes.SourceControlAuthStrategy? = nil,
            authToken: Swift.String? = nil,
            branch: Swift.String? = nil,
            folder: Swift.String? = nil,
            lastCommitId: Swift.String? = nil,
            owner: Swift.String? = nil,
            provider: GlueClientTypes.SourceControlProvider? = nil,
            repository: Swift.String? = nil
        )
        {
            self.authStrategy = authStrategy
            self.authToken = authToken
            self.branch = branch
            self.folder = folder
            self.lastCommitId = lastCommitId
            self.owner = owner
            self.provider = provider
            self.repository = repository
        }
    }
}

extension GlueClientTypes {

    public enum FederationSourceErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessdeniedexception
        case entitynotfoundexception
        case internalserviceexception
        case invalidcredentialsexception
        case invalidinputexception
        case invalidresponseexception
        case operationnotsupportedexception
        case operationtimeoutexception
        case partialfailureexception
        case throttlingexception
        case sdkUnknown(Swift.String)

        public static var allCases: [FederationSourceErrorCode] {
            return [
                .accessdeniedexception,
                .entitynotfoundexception,
                .internalserviceexception,
                .invalidcredentialsexception,
                .invalidinputexception,
                .invalidresponseexception,
                .operationnotsupportedexception,
                .operationtimeoutexception,
                .partialfailureexception,
                .throttlingexception
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .entitynotfoundexception: return "EntityNotFoundException"
            case .internalserviceexception: return "InternalServiceException"
            case .invalidcredentialsexception: return "InvalidCredentialsException"
            case .invalidinputexception: return "InvalidInputException"
            case .invalidresponseexception: return "InvalidResponseException"
            case .operationnotsupportedexception: return "OperationNotSupportedException"
            case .operationtimeoutexception: return "OperationTimeoutException"
            case .partialfailureexception: return "PartialFailureException"
            case .throttlingexception: return "ThrottlingException"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// A federation source failed.
public struct FederationSourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code of the problem.
        public internal(set) var federationSourceErrorCode: GlueClientTypes.FederationSourceErrorCode? = nil
        /// The message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FederationSourceException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        federationSourceErrorCode: GlueClientTypes.FederationSourceErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.federationSourceErrorCode = federationSourceErrorCode
        self.properties.message = message
    }
}

/// A federation source failed, but the operation may be retried.
public struct FederationSourceRetryableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FederationSourceRetryableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An error that indicates your data is in an invalid state.
public struct InvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchGetPartitionInput: Swift.Sendable {
    /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the catalog database where the partitions reside.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A list of partition values identifying the partitions to retrieve.
    /// This member is required.
    public var partitionsToGet: [GlueClientTypes.PartitionValueList]?
    /// The name of the partitions' table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        partitionsToGet: [GlueClientTypes.PartitionValueList]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionsToGet = partitionsToGet
        self.tableName = tableName
    }
}

extension GlueClientTypes {

    /// Represents a slice of table data.
    public struct Partition: Swift.Sendable {
        /// The ID of the Data Catalog in which the partition resides.
        public var catalogId: Swift.String?
        /// The time at which the partition was created.
        public var creationTime: Foundation.Date?
        /// The name of the catalog database in which to create the partition.
        public var databaseName: Swift.String?
        /// The last time at which the partition was accessed.
        public var lastAccessTime: Foundation.Date?
        /// The last time at which column statistics were computed for this partition.
        public var lastAnalyzedTime: Foundation.Date?
        /// These key-value pairs define partition parameters.
        public var parameters: [Swift.String: Swift.String]?
        /// Provides information about the physical location where the partition is stored.
        public var storageDescriptor: GlueClientTypes.StorageDescriptor?
        /// The name of the database table in which to create the partition.
        public var tableName: Swift.String?
        /// The values of the partition.
        public var values: [Swift.String]?

        public init(
            catalogId: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            databaseName: Swift.String? = nil,
            lastAccessTime: Foundation.Date? = nil,
            lastAnalyzedTime: Foundation.Date? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            storageDescriptor: GlueClientTypes.StorageDescriptor? = nil,
            tableName: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.catalogId = catalogId
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.parameters = parameters
            self.storageDescriptor = storageDescriptor
            self.tableName = tableName
            self.values = values
        }
    }
}

public struct BatchGetPartitionOutput: Swift.Sendable {
    /// A list of the requested partitions.
    public var partitions: [GlueClientTypes.Partition]?
    /// A list of the partition values in the request for which partitions were not returned.
    public var unprocessedKeys: [GlueClientTypes.PartitionValueList]?

    public init(
        partitions: [GlueClientTypes.Partition]? = nil,
        unprocessedKeys: [GlueClientTypes.PartitionValueList]? = nil
    )
    {
        self.partitions = partitions
        self.unprocessedKeys = unprocessedKeys
    }
}

/// The throttling threshhold was exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GlueClientTypes {

    public enum TableOptimizerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case compaction
        case orphanFileDeletion
        case retention
        case sdkUnknown(Swift.String)

        public static var allCases: [TableOptimizerType] {
            return [
                .compaction,
                .orphanFileDeletion,
                .retention
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .compaction: return "compaction"
            case .orphanFileDeletion: return "orphan_file_deletion"
            case .retention: return "retention"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Represents a table optimizer to retrieve in the BatchGetTableOptimizer operation.
    public struct BatchGetTableOptimizerEntry: Swift.Sendable {
        /// The Catalog ID of the table.
        public var catalogId: Swift.String?
        /// The name of the database in the catalog in which the table resides.
        public var databaseName: Swift.String?
        /// The name of the table.
        public var tableName: Swift.String?
        /// The type of table optimizer.
        public var type: GlueClientTypes.TableOptimizerType?

        public init(
            catalogId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            type: GlueClientTypes.TableOptimizerType? = nil
        )
        {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.type = type
        }
    }
}

public struct BatchGetTableOptimizerInput: Swift.Sendable {
    /// A list of BatchGetTableOptimizerEntry objects specifying the table optimizers to retrieve.
    /// This member is required.
    public var entries: [GlueClientTypes.BatchGetTableOptimizerEntry]?

    public init(
        entries: [GlueClientTypes.BatchGetTableOptimizerEntry]? = nil
    )
    {
        self.entries = entries
    }
}

extension GlueClientTypes {

    /// Contains details on one of the errors in the error list returned by the BatchGetTableOptimizer operation.
    public struct BatchGetTableOptimizerError: Swift.Sendable {
        /// The Catalog ID of the table.
        public var catalogId: Swift.String?
        /// The name of the database in the catalog in which the table resides.
        public var databaseName: Swift.String?
        /// An ErrorDetail object containing code and message details about the error.
        public var error: GlueClientTypes.ErrorDetail?
        /// The name of the table.
        public var tableName: Swift.String?
        /// The type of table optimizer.
        public var type: GlueClientTypes.TableOptimizerType?

        public init(
            catalogId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            error: GlueClientTypes.ErrorDetail? = nil,
            tableName: Swift.String? = nil,
            type: GlueClientTypes.TableOptimizerType? = nil
        )
        {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.error = error
            self.tableName = tableName
            self.type = type
        }
    }
}

extension GlueClientTypes {

    /// The configuration for an Iceberg orphan file deletion optimizer.
    public struct IcebergOrphanFileDeletionConfiguration: Swift.Sendable {
        /// Specifies a directory in which to look for files (defaults to the table's location). You may choose a sub-directory rather than the top-level table location.
        public var location: Swift.String?
        /// The number of days that orphan files should be retained before file deletion. If an input is not provided, the default value 3 will be used.
        public var orphanFileRetentionPeriodInDays: Swift.Int?

        public init(
            location: Swift.String? = nil,
            orphanFileRetentionPeriodInDays: Swift.Int? = nil
        )
        {
            self.location = location
            self.orphanFileRetentionPeriodInDays = orphanFileRetentionPeriodInDays
        }
    }
}

extension GlueClientTypes {

    /// The configuration for an orphan file deletion optimizer.
    public struct OrphanFileDeletionConfiguration: Swift.Sendable {
        /// The configuration for an Iceberg orphan file deletion optimizer.
        public var icebergConfiguration: GlueClientTypes.IcebergOrphanFileDeletionConfiguration?

        public init(
            icebergConfiguration: GlueClientTypes.IcebergOrphanFileDeletionConfiguration? = nil
        )
        {
            self.icebergConfiguration = icebergConfiguration
        }
    }
}

extension GlueClientTypes {

    /// The configuration for an Iceberg snapshot retention optimizer.
    public struct IcebergRetentionConfiguration: Swift.Sendable {
        /// If set to false, snapshots are only deleted from table metadata, and the underlying data and metadata files are not deleted.
        public var cleanExpiredFiles: Swift.Bool?
        /// The number of Iceberg snapshots to retain within the retention period. If an input is not provided, the corresponding Iceberg table configuration field will be used or if not present, the default value 1 will be used.
        public var numberOfSnapshotsToRetain: Swift.Int?
        /// The number of days to retain the Iceberg snapshots. If an input is not provided, the corresponding Iceberg table configuration field will be used or if not present, the default value 5 will be used.
        public var snapshotRetentionPeriodInDays: Swift.Int?

        public init(
            cleanExpiredFiles: Swift.Bool? = nil,
            numberOfSnapshotsToRetain: Swift.Int? = nil,
            snapshotRetentionPeriodInDays: Swift.Int? = nil
        )
        {
            self.cleanExpiredFiles = cleanExpiredFiles
            self.numberOfSnapshotsToRetain = numberOfSnapshotsToRetain
            self.snapshotRetentionPeriodInDays = snapshotRetentionPeriodInDays
        }
    }
}

extension GlueClientTypes {

    /// The configuration for a snapshot retention optimizer.
    public struct RetentionConfiguration: Swift.Sendable {
        /// The configuration for an Iceberg snapshot retention optimizer.
        public var icebergConfiguration: GlueClientTypes.IcebergRetentionConfiguration?

        public init(
            icebergConfiguration: GlueClientTypes.IcebergRetentionConfiguration? = nil
        )
        {
            self.icebergConfiguration = icebergConfiguration
        }
    }
}

extension GlueClientTypes {

    /// Contains details on the configuration of a table optimizer. You pass this configuration when creating or updating a table optimizer.
    public struct TableOptimizerConfiguration: Swift.Sendable {
        /// Whether table optimization is enabled.
        public var enabled: Swift.Bool?
        /// The configuration for an orphan file deletion optimizer.
        public var orphanFileDeletionConfiguration: GlueClientTypes.OrphanFileDeletionConfiguration?
        /// The configuration for a snapshot retention optimizer.
        public var retentionConfiguration: GlueClientTypes.RetentionConfiguration?
        /// A role passed by the caller which gives the service permission to update the resources associated with the optimizer on the caller's behalf.
        public var roleArn: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            orphanFileDeletionConfiguration: GlueClientTypes.OrphanFileDeletionConfiguration? = nil,
            retentionConfiguration: GlueClientTypes.RetentionConfiguration? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.orphanFileDeletionConfiguration = orphanFileDeletionConfiguration
            self.retentionConfiguration = retentionConfiguration
            self.roleArn = roleArn
        }
    }
}

extension GlueClientTypes {

    /// Compaction metrics for Iceberg for the optimizer run.
    public struct IcebergCompactionMetrics: Swift.Sendable {
        /// The duration of the job in hours.
        public var jobDurationInHour: Swift.Double
        /// The number of bytes removed by the compaction job run.
        public var numberOfBytesCompacted: Swift.Int
        /// The number of DPU hours consumed by the job.
        public var numberOfDpus: Swift.Int
        /// The number of files removed by the compaction job run.
        public var numberOfFilesCompacted: Swift.Int

        public init(
            jobDurationInHour: Swift.Double = 0.0,
            numberOfBytesCompacted: Swift.Int = 0,
            numberOfDpus: Swift.Int = 0,
            numberOfFilesCompacted: Swift.Int = 0
        )
        {
            self.jobDurationInHour = jobDurationInHour
            self.numberOfBytesCompacted = numberOfBytesCompacted
            self.numberOfDpus = numberOfDpus
            self.numberOfFilesCompacted = numberOfFilesCompacted
        }
    }
}

extension GlueClientTypes {

    /// A structure that contains compaction metrics for the optimizer run.
    public struct CompactionMetrics: Swift.Sendable {
        /// A structure containing the Iceberg compaction metrics for the optimizer run.
        public var icebergMetrics: GlueClientTypes.IcebergCompactionMetrics?

        public init(
            icebergMetrics: GlueClientTypes.IcebergCompactionMetrics? = nil
        )
        {
            self.icebergMetrics = icebergMetrics
        }
    }
}

extension GlueClientTypes {

    public enum TableOptimizerEventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case starting
        case sdkUnknown(Swift.String)

        public static var allCases: [TableOptimizerEventType] {
            return [
                .completed,
                .failed,
                .inProgress,
                .starting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "completed"
            case .failed: return "failed"
            case .inProgress: return "in_progress"
            case .starting: return "starting"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Metrics for the optimizer run. This structure is deprecated. See the individual metric members for compaction, retention, and orphan file deletion.
    public struct RunMetrics: Swift.Sendable {
        /// The duration of the job in hours.
        public var jobDurationInHour: Swift.String?
        /// The number of bytes removed by the compaction job run.
        public var numberOfBytesCompacted: Swift.String?
        /// The number of DPU hours consumed by the job.
        public var numberOfDpus: Swift.String?
        /// The number of files removed by the compaction job run.
        public var numberOfFilesCompacted: Swift.String?

        public init(
            jobDurationInHour: Swift.String? = nil,
            numberOfBytesCompacted: Swift.String? = nil,
            numberOfDpus: Swift.String? = nil,
            numberOfFilesCompacted: Swift.String? = nil
        )
        {
            self.jobDurationInHour = jobDurationInHour
            self.numberOfBytesCompacted = numberOfBytesCompacted
            self.numberOfDpus = numberOfDpus
            self.numberOfFilesCompacted = numberOfFilesCompacted
        }
    }
}

extension GlueClientTypes {

    /// Orphan file deletion metrics for Iceberg for the optimizer run.
    public struct IcebergOrphanFileDeletionMetrics: Swift.Sendable {
        /// The duration of the job in hours.
        public var jobDurationInHour: Swift.Double
        /// The number of DPU hours consumed by the job.
        public var numberOfDpus: Swift.Int
        /// The number of orphan files deleted by the orphan file deletion job run.
        public var numberOfOrphanFilesDeleted: Swift.Int

        public init(
            jobDurationInHour: Swift.Double = 0.0,
            numberOfDpus: Swift.Int = 0,
            numberOfOrphanFilesDeleted: Swift.Int = 0
        )
        {
            self.jobDurationInHour = jobDurationInHour
            self.numberOfDpus = numberOfDpus
            self.numberOfOrphanFilesDeleted = numberOfOrphanFilesDeleted
        }
    }
}

extension GlueClientTypes {

    /// A structure that contains orphan file deletion metrics for the optimizer run.
    public struct OrphanFileDeletionMetrics: Swift.Sendable {
        /// A structure containing the Iceberg orphan file deletion metrics for the optimizer run.
        public var icebergMetrics: GlueClientTypes.IcebergOrphanFileDeletionMetrics?

        public init(
            icebergMetrics: GlueClientTypes.IcebergOrphanFileDeletionMetrics? = nil
        )
        {
            self.icebergMetrics = icebergMetrics
        }
    }
}

extension GlueClientTypes {

    /// Snapshot retention metrics for Iceberg for the optimizer run.
    public struct IcebergRetentionMetrics: Swift.Sendable {
        /// The duration of the job in hours.
        public var jobDurationInHour: Swift.Double
        /// The number of data files deleted by the retention job run.
        public var numberOfDataFilesDeleted: Swift.Int
        /// The number of DPU hours consumed by the job.
        public var numberOfDpus: Swift.Int
        /// The number of manifest files deleted by the retention job run.
        public var numberOfManifestFilesDeleted: Swift.Int
        /// The number of manifest lists deleted by the retention job run.
        public var numberOfManifestListsDeleted: Swift.Int

        public init(
            jobDurationInHour: Swift.Double = 0.0,
            numberOfDataFilesDeleted: Swift.Int = 0,
            numberOfDpus: Swift.Int = 0,
            numberOfManifestFilesDeleted: Swift.Int = 0,
            numberOfManifestListsDeleted: Swift.Int = 0
        )
        {
            self.jobDurationInHour = jobDurationInHour
            self.numberOfDataFilesDeleted = numberOfDataFilesDeleted
            self.numberOfDpus = numberOfDpus
            self.numberOfManifestFilesDeleted = numberOfManifestFilesDeleted
            self.numberOfManifestListsDeleted = numberOfManifestListsDeleted
        }
    }
}

extension GlueClientTypes {

    /// A structure that contains retention metrics for the optimizer run.
    public struct RetentionMetrics: Swift.Sendable {
        /// A structure containing the Iceberg retention metrics for the optimizer run.
        public var icebergMetrics: GlueClientTypes.IcebergRetentionMetrics?

        public init(
            icebergMetrics: GlueClientTypes.IcebergRetentionMetrics? = nil
        )
        {
            self.icebergMetrics = icebergMetrics
        }
    }
}

extension GlueClientTypes {

    /// Contains details for a table optimizer run.
    public struct TableOptimizerRun: Swift.Sendable {
        /// A CompactionMetrics object containing metrics for the optimizer run.
        public var compactionMetrics: GlueClientTypes.CompactionMetrics?
        /// Represents the epoch timestamp at which the compaction job ended.
        public var endTimestamp: Foundation.Date?
        /// An error that occured during the optimizer run.
        public var error: Swift.String?
        /// An event type representing the status of the table optimizer run.
        public var eventType: GlueClientTypes.TableOptimizerEventType?
        /// A RunMetrics object containing metrics for the optimizer run. This member is deprecated. See the individual metric members for compaction, retention, and orphan file deletion.
        @available(*, deprecated, message: "Metrics has been replaced by optimizer type specific metrics such as IcebergCompactionMetrics")
        public var metrics: GlueClientTypes.RunMetrics?
        /// An OrphanFileDeletionMetrics object containing metrics for the optimizer run.
        public var orphanFileDeletionMetrics: GlueClientTypes.OrphanFileDeletionMetrics?
        /// A RetentionMetrics object containing metrics for the optimizer run.
        public var retentionMetrics: GlueClientTypes.RetentionMetrics?
        /// Represents the epoch timestamp at which the compaction job was started within Lake Formation.
        public var startTimestamp: Foundation.Date?

        public init(
            compactionMetrics: GlueClientTypes.CompactionMetrics? = nil,
            endTimestamp: Foundation.Date? = nil,
            error: Swift.String? = nil,
            eventType: GlueClientTypes.TableOptimizerEventType? = nil,
            metrics: GlueClientTypes.RunMetrics? = nil,
            orphanFileDeletionMetrics: GlueClientTypes.OrphanFileDeletionMetrics? = nil,
            retentionMetrics: GlueClientTypes.RetentionMetrics? = nil,
            startTimestamp: Foundation.Date? = nil
        )
        {
            self.compactionMetrics = compactionMetrics
            self.endTimestamp = endTimestamp
            self.error = error
            self.eventType = eventType
            self.metrics = metrics
            self.orphanFileDeletionMetrics = orphanFileDeletionMetrics
            self.retentionMetrics = retentionMetrics
            self.startTimestamp = startTimestamp
        }
    }
}

extension GlueClientTypes {

    /// Contains details about an optimizer associated with a table.
    public struct TableOptimizer: Swift.Sendable {
        /// A TableOptimizerConfiguration object that was specified when creating or updating a table optimizer.
        public var configuration: GlueClientTypes.TableOptimizerConfiguration?
        /// A TableOptimizerRun object representing the last run of the table optimizer.
        public var lastRun: GlueClientTypes.TableOptimizerRun?
        /// The type of table optimizer. The valid values are:
        ///
        /// * compaction: for managing compaction with a table optimizer.
        ///
        /// * retention: for managing the retention of snapshot with a table optimizer.
        ///
        /// * orphan_file_deletion: for managing the deletion of orphan files with a table optimizer.
        public var type: GlueClientTypes.TableOptimizerType?

        public init(
            configuration: GlueClientTypes.TableOptimizerConfiguration? = nil,
            lastRun: GlueClientTypes.TableOptimizerRun? = nil,
            type: GlueClientTypes.TableOptimizerType? = nil
        )
        {
            self.configuration = configuration
            self.lastRun = lastRun
            self.type = type
        }
    }
}

extension GlueClientTypes {

    /// Contains details for one of the table optimizers returned by the BatchGetTableOptimizer operation.
    public struct BatchTableOptimizer: Swift.Sendable {
        /// The Catalog ID of the table.
        public var catalogId: Swift.String?
        /// The name of the database in the catalog in which the table resides.
        public var databaseName: Swift.String?
        /// The name of the table.
        public var tableName: Swift.String?
        /// A TableOptimizer object that contains details on the configuration and last run of a table optimizer.
        public var tableOptimizer: GlueClientTypes.TableOptimizer?

        public init(
            catalogId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            tableOptimizer: GlueClientTypes.TableOptimizer? = nil
        )
        {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.tableOptimizer = tableOptimizer
        }
    }
}

public struct BatchGetTableOptimizerOutput: Swift.Sendable {
    /// A list of errors from the operation.
    public var failures: [GlueClientTypes.BatchGetTableOptimizerError]?
    /// A list of BatchTableOptimizer objects.
    public var tableOptimizers: [GlueClientTypes.BatchTableOptimizer]?

    public init(
        failures: [GlueClientTypes.BatchGetTableOptimizerError]? = nil,
        tableOptimizers: [GlueClientTypes.BatchTableOptimizer]? = nil
    )
    {
        self.failures = failures
        self.tableOptimizers = tableOptimizers
    }
}

public struct BatchGetTriggersInput: Swift.Sendable {
    /// A list of trigger names, which may be the names returned from the ListTriggers operation.
    /// This member is required.
    public var triggerNames: [Swift.String]?

    public init(
        triggerNames: [Swift.String]? = nil
    )
    {
        self.triggerNames = triggerNames
    }
}

extension GlueClientTypes {

    /// Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.
    public struct EventBatchingCondition: Swift.Sendable {
        /// Number of events that must be received from Amazon EventBridge before EventBridge event trigger fires.
        /// This member is required.
        public var batchSize: Swift.Int?
        /// Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received.
        public var batchWindow: Swift.Int?

        public init(
            batchSize: Swift.Int? = nil,
            batchWindow: Swift.Int? = nil
        )
        {
            self.batchSize = batchSize
            self.batchWindow = batchWindow
        }
    }
}

extension GlueClientTypes {

    public enum CrawlState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case error
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CrawlState] {
            return [
                .cancelled,
                .cancelling,
                .error,
                .failed,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .error: return "ERROR"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum LogicalOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [LogicalOperator] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum JobRunState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case expired
        case failed
        case running
        case starting
        case stopped
        case stopping
        case succeeded
        case timeout
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [JobRunState] {
            return [
                .error,
                .expired,
                .failed,
                .running,
                .starting,
                .stopped,
                .stopping,
                .succeeded,
                .timeout,
                .waiting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .expired: return "EXPIRED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .succeeded: return "SUCCEEDED"
            case .timeout: return "TIMEOUT"
            case .waiting: return "WAITING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Defines a condition under which a trigger fires.
    public struct Condition: Swift.Sendable {
        /// The state of the crawler to which this condition applies.
        public var crawlState: GlueClientTypes.CrawlState?
        /// The name of the crawler to which this condition applies.
        public var crawlerName: Swift.String?
        /// The name of the job whose JobRuns this condition applies to, and on which this trigger waits.
        public var jobName: Swift.String?
        /// A logical operator.
        public var logicalOperator: GlueClientTypes.LogicalOperator?
        /// The condition state. Currently, the only job states that a trigger can listen for are SUCCEEDED, STOPPED, FAILED, and TIMEOUT. The only crawler states that a trigger can listen for are SUCCEEDED, FAILED, and CANCELLED.
        public var state: GlueClientTypes.JobRunState?

        public init(
            crawlState: GlueClientTypes.CrawlState? = nil,
            crawlerName: Swift.String? = nil,
            jobName: Swift.String? = nil,
            logicalOperator: GlueClientTypes.LogicalOperator? = nil,
            state: GlueClientTypes.JobRunState? = nil
        )
        {
            self.crawlState = crawlState
            self.crawlerName = crawlerName
            self.jobName = jobName
            self.logicalOperator = logicalOperator
            self.state = state
        }
    }
}

extension GlueClientTypes {

    public enum Logical: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case and
        case any
        case sdkUnknown(Swift.String)

        public static var allCases: [Logical] {
            return [
                .and,
                .any
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .and: return "AND"
            case .any: return "ANY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Defines the predicate of the trigger, which determines when it fires.
    public struct Predicate: Swift.Sendable {
        /// A list of the conditions that determine when the trigger will fire.
        public var conditions: [GlueClientTypes.Condition]?
        /// An optional field if only one condition is listed. If multiple conditions are listed, then this field is required.
        public var logical: GlueClientTypes.Logical?

        public init(
            conditions: [GlueClientTypes.Condition]? = nil,
            logical: GlueClientTypes.Logical? = nil
        )
        {
            self.conditions = conditions
            self.logical = logical
        }
    }
}

extension GlueClientTypes {

    public enum TriggerState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activated
        case activating
        case created
        case creating
        case deactivated
        case deactivating
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerState] {
            return [
                .activated,
                .activating,
                .created,
                .creating,
                .deactivated,
                .deactivating,
                .deleting,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .activating: return "ACTIVATING"
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .deactivated: return "DEACTIVATED"
            case .deactivating: return "DEACTIVATING"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum TriggerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case conditional
        case event
        case onDemand
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerType] {
            return [
                .conditional,
                .event,
                .onDemand,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .conditional: return "CONDITIONAL"
            case .event: return "EVENT"
            case .onDemand: return "ON_DEMAND"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Information about a specific trigger.
    public struct Trigger: Swift.Sendable {
        /// The actions initiated by this trigger.
        public var actions: [GlueClientTypes.Action]?
        /// A description of this trigger.
        public var description: Swift.String?
        /// Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.
        public var eventBatchingCondition: GlueClientTypes.EventBatchingCondition?
        /// Reserved for future use.
        public var id: Swift.String?
        /// The name of the trigger.
        public var name: Swift.String?
        /// The predicate of this trigger, which defines when it will fire.
        public var predicate: GlueClientTypes.Predicate?
        /// A cron expression used to specify the schedule (see [Time-Based Schedules for Jobs and Crawlers](https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html). For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public var schedule: Swift.String?
        /// The current state of the trigger.
        public var state: GlueClientTypes.TriggerState?
        /// The type of trigger that this is.
        public var type: GlueClientTypes.TriggerType?
        /// The name of the workflow associated with the trigger.
        public var workflowName: Swift.String?

        public init(
            actions: [GlueClientTypes.Action]? = nil,
            description: Swift.String? = nil,
            eventBatchingCondition: GlueClientTypes.EventBatchingCondition? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            predicate: GlueClientTypes.Predicate? = nil,
            schedule: Swift.String? = nil,
            state: GlueClientTypes.TriggerState? = nil,
            type: GlueClientTypes.TriggerType? = nil,
            workflowName: Swift.String? = nil
        )
        {
            self.actions = actions
            self.description = description
            self.eventBatchingCondition = eventBatchingCondition
            self.id = id
            self.name = name
            self.predicate = predicate
            self.schedule = schedule
            self.state = state
            self.type = type
            self.workflowName = workflowName
        }
    }
}

public struct BatchGetTriggersOutput: Swift.Sendable {
    /// A list of trigger definitions.
    public var triggers: [GlueClientTypes.Trigger]?
    /// A list of names of triggers not found.
    public var triggersNotFound: [Swift.String]?

    public init(
        triggers: [GlueClientTypes.Trigger]? = nil,
        triggersNotFound: [Swift.String]? = nil
    )
    {
        self.triggers = triggers
        self.triggersNotFound = triggersNotFound
    }
}

public struct BatchGetWorkflowsInput: Swift.Sendable {
    /// Specifies whether to include a graph when returning the workflow resource metadata.
    public var includeGraph: Swift.Bool?
    /// A list of workflow names, which may be the names returned from the ListWorkflows operation.
    /// This member is required.
    public var names: [Swift.String]?

    public init(
        includeGraph: Swift.Bool? = nil,
        names: [Swift.String]? = nil
    )
    {
        self.includeGraph = includeGraph
        self.names = names
    }
}

extension GlueClientTypes {

    /// The details of a blueprint.
    public struct BlueprintDetails: Swift.Sendable {
        /// The name of the blueprint.
        public var blueprintName: Swift.String?
        /// The run ID for this blueprint.
        public var runId: Swift.String?

        public init(
            blueprintName: Swift.String? = nil,
            runId: Swift.String? = nil
        )
        {
            self.blueprintName = blueprintName
            self.runId = runId
        }
    }
}

extension GlueClientTypes {

    /// An edge represents a directed connection between two Glue components that are part of the workflow the edge belongs to.
    public struct Edge: Swift.Sendable {
        /// The unique of the node within the workflow where the edge ends.
        public var destinationId: Swift.String?
        /// The unique of the node within the workflow where the edge starts.
        public var sourceId: Swift.String?

        public init(
            destinationId: Swift.String? = nil,
            sourceId: Swift.String? = nil
        )
        {
            self.destinationId = destinationId
            self.sourceId = sourceId
        }
    }
}

extension GlueClientTypes {

    /// The details of a crawl in the workflow.
    public struct Crawl: Swift.Sendable {
        /// The date and time on which the crawl completed.
        public var completedOn: Foundation.Date?
        /// The error message associated with the crawl.
        public var errorMessage: Swift.String?
        /// The log group associated with the crawl.
        public var logGroup: Swift.String?
        /// The log stream associated with the crawl.
        public var logStream: Swift.String?
        /// The date and time on which the crawl started.
        public var startedOn: Foundation.Date?
        /// The state of the crawler.
        public var state: GlueClientTypes.CrawlState?

        public init(
            completedOn: Foundation.Date? = nil,
            errorMessage: Swift.String? = nil,
            logGroup: Swift.String? = nil,
            logStream: Swift.String? = nil,
            startedOn: Foundation.Date? = nil,
            state: GlueClientTypes.CrawlState? = nil
        )
        {
            self.completedOn = completedOn
            self.errorMessage = errorMessage
            self.logGroup = logGroup
            self.logStream = logStream
            self.startedOn = startedOn
            self.state = state
        }
    }
}

extension GlueClientTypes {

    /// The details of a Crawler node present in the workflow.
    public struct CrawlerNodeDetails: Swift.Sendable {
        /// A list of crawls represented by the crawl node.
        public var crawls: [GlueClientTypes.Crawl]?

        public init(
            crawls: [GlueClientTypes.Crawl]? = nil
        )
        {
            self.crawls = crawls
        }
    }
}

extension GlueClientTypes {

    /// A job run that was used in the predicate of a conditional trigger that triggered this job run.
    public struct Predecessor: Swift.Sendable {
        /// The name of the job definition used by the predecessor job run.
        public var jobName: Swift.String?
        /// The job-run ID of the predecessor job run.
        public var runId: Swift.String?

        public init(
            jobName: Swift.String? = nil,
            runId: Swift.String? = nil
        )
        {
            self.jobName = jobName
            self.runId = runId
        }
    }
}

extension GlueClientTypes {

    /// Contains information about a job run.
    public struct JobRun: Swift.Sendable {
        /// This field is deprecated. Use MaxCapacity instead. The number of Glue data processing units (DPUs) allocated to this JobRun. From 2 to 100 DPUs can be allocated; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [Glue pricing page](https://aws.amazon.com/glue/pricing/).
        @available(*, deprecated, message: "This property is deprecated, use MaxCapacity instead.")
        public var allocatedCapacity: Swift.Int
        /// The job arguments associated with this run. For this job run, they replace the default arguments set in the job definition itself. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep them within the Job. For information about how to specify and consume your own Job arguments, see the [Calling Glue APIs in Python](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html) topic in the developer guide. For information about the arguments you can provide to this field when configuring Spark jobs, see the [Special Parameters Used by Glue](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html) topic in the developer guide. For information about the arguments you can provide to this field when configuring Ray jobs, see [Using job parameters in Ray jobs](https://docs.aws.amazon.com/glue/latest/dg/author-job-ray-job-parameters.html) in the developer guide.
        public var arguments: [Swift.String: Swift.String]?
        /// The number of the attempt to run this job.
        public var attempt: Swift.Int
        /// The date and time that this job run completed.
        public var completedOn: Foundation.Date?
        /// This field can be set for either job runs with execution class FLEX or when Auto Scaling is enabled, and represents the total time each executor ran during the lifecycle of a job run in seconds, multiplied by a DPU factor (1 for G.1X, 2 for G.2X, or 0.25 for G.025X workers). This value may be different than the executionEngineRuntime * MaxCapacity as in the case of Auto Scaling jobs, as the number of executors running at a given time may be less than the MaxCapacity. Therefore, it is possible that the value of DPUSeconds is less than executionEngineRuntime * MaxCapacity.
        public var dpuSeconds: Swift.Double?
        /// An error message associated with this job run.
        public var errorMessage: Swift.String?
        /// Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. Only jobs with Glue version 3.0 and above and command type glueetl will be allowed to set ExecutionClass to FLEX. The flexible execution class is available for Spark jobs.
        public var executionClass: GlueClientTypes.ExecutionClass?
        /// The amount of time (in seconds) that the job run consumed resources.
        public var executionTime: Swift.Int
        /// In Spark jobs, GlueVersion determines the versions of Apache Spark and Python that Glue available in a job. The Python version indicates the version supported for jobs of type Spark. Ray jobs should set GlueVersion to 4.0 or greater. However, the versions of Ray, Python and additional libraries available in your Ray job are determined by the Runtime parameter of the Job command. For more information about the available Glue versions and corresponding Spark and Python versions, see [Glue version](https://docs.aws.amazon.com/glue/latest/dg/add-job.html) in the developer guide. Jobs that are created without specifying a Glue version default to Glue 0.9.
        public var glueVersion: Swift.String?
        /// The ID of this job run.
        public var id: Swift.String?
        /// A mode that describes how a job was created. Valid values are:
        ///
        /// * SCRIPT - The job was created using the Glue Studio script editor.
        ///
        /// * VISUAL - The job was created using the Glue Studio visual editor.
        ///
        /// * NOTEBOOK - The job was created using an interactive sessions notebook.
        ///
        ///
        /// When the JobMode field is missing or null, SCRIPT is assigned as the default value.
        public var jobMode: GlueClientTypes.JobMode?
        /// The name of the job definition being used in this run.
        public var jobName: Swift.String?
        /// Specifies whether job run queuing is enabled for the job run. A value of true means job run queuing is enabled for the job run. If false or not populated, the job run will not be considered for queueing.
        public var jobRunQueuingEnabled: Swift.Bool?
        /// The current state of the job run. For more information about the statuses of jobs that have terminated abnormally, see [Glue Job Run Statuses](https://docs.aws.amazon.com/glue/latest/dg/job-run-statuses.html).
        public var jobRunState: GlueClientTypes.JobRunState?
        /// The last time that this job run was modified.
        public var lastModifiedOn: Foundation.Date?
        /// The name of the log group for secure logging that can be server-side encrypted in Amazon CloudWatch using KMS. This name can be /aws-glue/jobs/, in which case the default encryption is NONE. If you add a role name and SecurityConfiguration name (in other words, /aws-glue/jobs-yourRoleName-yourSecurityConfigurationName/), then that security configuration is used to encrypt the log group.
        public var logGroupName: Swift.String?
        /// This field specifies a day of the week and hour for a maintenance window for streaming jobs. Glue periodically performs maintenance activities. During these maintenance windows, Glue will need to restart your streaming jobs. Glue will restart the job within 3 hours of the specified maintenance window. For instance, if you set up the maintenance window for Monday at 10:00AM GMT, your jobs will be restarted between 10:00AM GMT to 1:00PM GMT.
        public var maintenanceWindow: Swift.String?
        /// For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [ Glue pricing page](https://aws.amazon.com/glue/pricing/). For Glue version 2.0+ jobs, you cannot specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers. Do not set MaxCapacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:
        ///
        /// * When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.
        ///
        /// * When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
        public var maxCapacity: Swift.Double?
        /// Specifies configuration properties of a job run notification.
        public var notificationProperty: GlueClientTypes.NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs.
        public var numberOfWorkers: Swift.Int?
        /// A list of predecessors to this job run.
        public var predecessorRuns: [GlueClientTypes.Predecessor]?
        /// The ID of the previous run of this job. For example, the JobRunId specified in the StartJobRun action.
        public var previousRunId: Swift.String?
        /// The name of an Glue usage profile associated with the job run.
        public var profileName: Swift.String?
        /// The name of the SecurityConfiguration structure to be used with this job run.
        public var securityConfiguration: Swift.String?
        /// The date and time at which this job run was started.
        public var startedOn: Foundation.Date?
        /// This field holds details that pertain to the state of a job run. The field is nullable. For example, when a job run is in a WAITING state as a result of job run queuing, the field has the reason why the job run is in that state.
        public var stateDetail: Swift.String?
        /// The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. This value overrides the timeout value set in the parent job. Streaming jobs must have timeout values less than 7 days or 10080 minutes. When the value is left blank, the job will be restarted after 7 days based if you have not setup a maintenance window. If you have setup maintenance window, it will be restarted during the maintenance window after 7 days.
        public var timeout: Swift.Int?
        /// The name of the trigger that started this job run.
        public var triggerName: Swift.String?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs.
        ///
        /// * For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.
        ///
        /// * For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.
        ///
        /// * For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).
        ///
        /// * For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.
        ///
        /// * For the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.
        ///
        /// * For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.
        public var workerType: GlueClientTypes.WorkerType?

        public init(
            allocatedCapacity: Swift.Int = 0,
            arguments: [Swift.String: Swift.String]? = nil,
            attempt: Swift.Int = 0,
            completedOn: Foundation.Date? = nil,
            dpuSeconds: Swift.Double? = nil,
            errorMessage: Swift.String? = nil,
            executionClass: GlueClientTypes.ExecutionClass? = nil,
            executionTime: Swift.Int = 0,
            glueVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            jobMode: GlueClientTypes.JobMode? = nil,
            jobName: Swift.String? = nil,
            jobRunQueuingEnabled: Swift.Bool? = nil,
            jobRunState: GlueClientTypes.JobRunState? = nil,
            lastModifiedOn: Foundation.Date? = nil,
            logGroupName: Swift.String? = nil,
            maintenanceWindow: Swift.String? = nil,
            maxCapacity: Swift.Double? = nil,
            notificationProperty: GlueClientTypes.NotificationProperty? = nil,
            numberOfWorkers: Swift.Int? = nil,
            predecessorRuns: [GlueClientTypes.Predecessor]? = nil,
            previousRunId: Swift.String? = nil,
            profileName: Swift.String? = nil,
            securityConfiguration: Swift.String? = nil,
            startedOn: Foundation.Date? = nil,
            stateDetail: Swift.String? = nil,
            timeout: Swift.Int? = nil,
            triggerName: Swift.String? = nil,
            workerType: GlueClientTypes.WorkerType? = nil
        )
        {
            self.allocatedCapacity = allocatedCapacity
            self.arguments = arguments
            self.attempt = attempt
            self.completedOn = completedOn
            self.dpuSeconds = dpuSeconds
            self.errorMessage = errorMessage
            self.executionClass = executionClass
            self.executionTime = executionTime
            self.glueVersion = glueVersion
            self.id = id
            self.jobMode = jobMode
            self.jobName = jobName
            self.jobRunQueuingEnabled = jobRunQueuingEnabled
            self.jobRunState = jobRunState
            self.lastModifiedOn = lastModifiedOn
            self.logGroupName = logGroupName
            self.maintenanceWindow = maintenanceWindow
            self.maxCapacity = maxCapacity
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.predecessorRuns = predecessorRuns
            self.previousRunId = previousRunId
            self.profileName = profileName
            self.securityConfiguration = securityConfiguration
            self.startedOn = startedOn
            self.stateDetail = stateDetail
            self.timeout = timeout
            self.triggerName = triggerName
            self.workerType = workerType
        }
    }
}

extension GlueClientTypes {

    /// The details of a Job node present in the workflow.
    public struct JobNodeDetails: Swift.Sendable {
        /// The information for the job runs represented by the job node.
        public var jobRuns: [GlueClientTypes.JobRun]?

        public init(
            jobRuns: [GlueClientTypes.JobRun]? = nil
        )
        {
            self.jobRuns = jobRuns
        }
    }
}

extension GlueClientTypes {

    /// The details of a Trigger node present in the workflow.
    public struct TriggerNodeDetails: Swift.Sendable {
        /// The information of the trigger represented by the trigger node.
        public var trigger: GlueClientTypes.Trigger?

        public init(
            trigger: GlueClientTypes.Trigger? = nil
        )
        {
            self.trigger = trigger
        }
    }
}

extension GlueClientTypes {

    public enum NodeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case crawler
        case job
        case trigger
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeType] {
            return [
                .crawler,
                .job,
                .trigger
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .crawler: return "CRAWLER"
            case .job: return "JOB"
            case .trigger: return "TRIGGER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A node represents an Glue component (trigger, crawler, or job) on a workflow graph.
    public struct Node: Swift.Sendable {
        /// Details of the crawler when the node represents a crawler.
        public var crawlerDetails: GlueClientTypes.CrawlerNodeDetails?
        /// Details of the Job when the node represents a Job.
        public var jobDetails: GlueClientTypes.JobNodeDetails?
        /// The name of the Glue component represented by the node.
        public var name: Swift.String?
        /// Details of the Trigger when the node represents a Trigger.
        public var triggerDetails: GlueClientTypes.TriggerNodeDetails?
        /// The type of Glue component represented by the node.
        public var type: GlueClientTypes.NodeType?
        /// The unique Id assigned to the node within the workflow.
        public var uniqueId: Swift.String?

        public init(
            crawlerDetails: GlueClientTypes.CrawlerNodeDetails? = nil,
            jobDetails: GlueClientTypes.JobNodeDetails? = nil,
            name: Swift.String? = nil,
            triggerDetails: GlueClientTypes.TriggerNodeDetails? = nil,
            type: GlueClientTypes.NodeType? = nil,
            uniqueId: Swift.String? = nil
        )
        {
            self.crawlerDetails = crawlerDetails
            self.jobDetails = jobDetails
            self.name = name
            self.triggerDetails = triggerDetails
            self.type = type
            self.uniqueId = uniqueId
        }
    }
}

extension GlueClientTypes {

    /// A workflow graph represents the complete workflow containing all the Glue components present in the workflow and all the directed connections between them.
    public struct WorkflowGraph: Swift.Sendable {
        /// A list of all the directed connections between the nodes belonging to the workflow.
        public var edges: [GlueClientTypes.Edge]?
        /// A list of the the Glue components belong to the workflow represented as nodes.
        public var nodes: [GlueClientTypes.Node]?

        public init(
            edges: [GlueClientTypes.Edge]? = nil,
            nodes: [GlueClientTypes.Node]? = nil
        )
        {
            self.edges = edges
            self.nodes = nodes
        }
    }
}

extension GlueClientTypes {

    /// The batch condition that started the workflow run. Either the number of events in the batch size arrived, in which case the BatchSize member is non-zero, or the batch window expired, in which case the BatchWindow member is non-zero.
    public struct StartingEventBatchCondition: Swift.Sendable {
        /// Number of events in the batch.
        public var batchSize: Swift.Int?
        /// Duration of the batch window in seconds.
        public var batchWindow: Swift.Int?

        public init(
            batchSize: Swift.Int? = nil,
            batchWindow: Swift.Int? = nil
        )
        {
            self.batchSize = batchSize
            self.batchWindow = batchWindow
        }
    }
}

extension GlueClientTypes {

    /// Workflow run statistics provides statistics about the workflow run.
    public struct WorkflowRunStatistics: Swift.Sendable {
        /// Indicates the count of job runs in the ERROR state in the workflow run.
        public var erroredActions: Swift.Int
        /// Total number of Actions that have failed.
        public var failedActions: Swift.Int
        /// Total number Actions in running state.
        public var runningActions: Swift.Int
        /// Total number of Actions that have stopped.
        public var stoppedActions: Swift.Int
        /// Total number of Actions that have succeeded.
        public var succeededActions: Swift.Int
        /// Total number of Actions that timed out.
        public var timeoutActions: Swift.Int
        /// Total number of Actions in the workflow run.
        public var totalActions: Swift.Int
        /// Indicates the count of job runs in WAITING state in the workflow run.
        public var waitingActions: Swift.Int

        public init(
            erroredActions: Swift.Int = 0,
            failedActions: Swift.Int = 0,
            runningActions: Swift.Int = 0,
            stoppedActions: Swift.Int = 0,
            succeededActions: Swift.Int = 0,
            timeoutActions: Swift.Int = 0,
            totalActions: Swift.Int = 0,
            waitingActions: Swift.Int = 0
        )
        {
            self.erroredActions = erroredActions
            self.failedActions = failedActions
            self.runningActions = runningActions
            self.stoppedActions = stoppedActions
            self.succeededActions = succeededActions
            self.timeoutActions = timeoutActions
            self.totalActions = totalActions
            self.waitingActions = waitingActions
        }
    }
}

extension GlueClientTypes {

    public enum WorkflowRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case error
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowRunStatus] {
            return [
                .completed,
                .error,
                .running,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .error: return "ERROR"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A workflow run is an execution of a workflow providing all the runtime information.
    public struct WorkflowRun: Swift.Sendable {
        /// The date and time when the workflow run completed.
        public var completedOn: Foundation.Date?
        /// This error message describes any error that may have occurred in starting the workflow run. Currently the only error message is "Concurrent runs exceeded for workflow: foo."
        public var errorMessage: Swift.String?
        /// The graph representing all the Glue components that belong to the workflow as nodes and directed connections between them as edges.
        public var graph: GlueClientTypes.WorkflowGraph?
        /// Name of the workflow that was run.
        public var name: Swift.String?
        /// The ID of the previous workflow run.
        public var previousRunId: Swift.String?
        /// The date and time when the workflow run was started.
        public var startedOn: Foundation.Date?
        /// The batch condition that started the workflow run.
        public var startingEventBatchCondition: GlueClientTypes.StartingEventBatchCondition?
        /// The statistics of the run.
        public var statistics: GlueClientTypes.WorkflowRunStatistics?
        /// The status of the workflow run.
        public var status: GlueClientTypes.WorkflowRunStatus?
        /// The ID of this workflow run.
        public var workflowRunId: Swift.String?
        /// The workflow run properties which were set during the run.
        public var workflowRunProperties: [Swift.String: Swift.String]?

        public init(
            completedOn: Foundation.Date? = nil,
            errorMessage: Swift.String? = nil,
            graph: GlueClientTypes.WorkflowGraph? = nil,
            name: Swift.String? = nil,
            previousRunId: Swift.String? = nil,
            startedOn: Foundation.Date? = nil,
            startingEventBatchCondition: GlueClientTypes.StartingEventBatchCondition? = nil,
            statistics: GlueClientTypes.WorkflowRunStatistics? = nil,
            status: GlueClientTypes.WorkflowRunStatus? = nil,
            workflowRunId: Swift.String? = nil,
            workflowRunProperties: [Swift.String: Swift.String]? = nil
        )
        {
            self.completedOn = completedOn
            self.errorMessage = errorMessage
            self.graph = graph
            self.name = name
            self.previousRunId = previousRunId
            self.startedOn = startedOn
            self.startingEventBatchCondition = startingEventBatchCondition
            self.statistics = statistics
            self.status = status
            self.workflowRunId = workflowRunId
            self.workflowRunProperties = workflowRunProperties
        }
    }
}

extension GlueClientTypes {

    /// A workflow is a collection of multiple dependent Glue jobs and crawlers that are run to complete a complex ETL task. A workflow manages the execution and monitoring of all its jobs and crawlers.
    public struct Workflow: Swift.Sendable {
        /// This structure indicates the details of the blueprint that this particular workflow is created from.
        public var blueprintDetails: GlueClientTypes.BlueprintDetails?
        /// The date and time when the workflow was created.
        public var createdOn: Foundation.Date?
        /// A collection of properties to be used as part of each execution of the workflow. The run properties are made available to each job in the workflow. A job can modify the properties for the next jobs in the flow.
        public var defaultRunProperties: [Swift.String: Swift.String]?
        /// A description of the workflow.
        public var description: Swift.String?
        /// The graph representing all the Glue components that belong to the workflow as nodes and directed connections between them as edges.
        public var graph: GlueClientTypes.WorkflowGraph?
        /// The date and time when the workflow was last modified.
        public var lastModifiedOn: Foundation.Date?
        /// The information about the last execution of the workflow.
        public var lastRun: GlueClientTypes.WorkflowRun?
        /// You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.
        public var maxConcurrentRuns: Swift.Int?
        /// The name of the workflow.
        public var name: Swift.String?

        public init(
            blueprintDetails: GlueClientTypes.BlueprintDetails? = nil,
            createdOn: Foundation.Date? = nil,
            defaultRunProperties: [Swift.String: Swift.String]? = nil,
            description: Swift.String? = nil,
            graph: GlueClientTypes.WorkflowGraph? = nil,
            lastModifiedOn: Foundation.Date? = nil,
            lastRun: GlueClientTypes.WorkflowRun? = nil,
            maxConcurrentRuns: Swift.Int? = nil,
            name: Swift.String? = nil
        )
        {
            self.blueprintDetails = blueprintDetails
            self.createdOn = createdOn
            self.defaultRunProperties = defaultRunProperties
            self.description = description
            self.graph = graph
            self.lastModifiedOn = lastModifiedOn
            self.lastRun = lastRun
            self.maxConcurrentRuns = maxConcurrentRuns
            self.name = name
        }
    }
}

public struct BatchGetWorkflowsOutput: Swift.Sendable {
    /// A list of names of workflows not found.
    public var missingWorkflows: [Swift.String]?
    /// A list of workflow resource metadata.
    public var workflows: [GlueClientTypes.Workflow]?

    public init(
        missingWorkflows: [Swift.String]? = nil,
        workflows: [GlueClientTypes.Workflow]? = nil
    )
    {
        self.missingWorkflows = missingWorkflows
        self.workflows = workflows
    }
}

extension GlueClientTypes {

    /// An Inclusion Annotation.
    public struct DatapointInclusionAnnotation: Swift.Sendable {
        /// The inclusion annotation value to apply to the statistic.
        public var inclusionAnnotation: GlueClientTypes.InclusionAnnotationValue?
        /// The ID of the data quality profile the statistic belongs to.
        public var profileId: Swift.String?
        /// The Statistic ID.
        public var statisticId: Swift.String?

        public init(
            inclusionAnnotation: GlueClientTypes.InclusionAnnotationValue? = nil,
            profileId: Swift.String? = nil,
            statisticId: Swift.String? = nil
        )
        {
            self.inclusionAnnotation = inclusionAnnotation
            self.profileId = profileId
            self.statisticId = statisticId
        }
    }
}

public struct BatchPutDataQualityStatisticAnnotationInput: Swift.Sendable {
    /// Client Token.
    public var clientToken: Swift.String?
    /// A list of DatapointInclusionAnnotation's.
    /// This member is required.
    public var inclusionAnnotations: [GlueClientTypes.DatapointInclusionAnnotation]?

    public init(
        clientToken: Swift.String? = nil,
        inclusionAnnotations: [GlueClientTypes.DatapointInclusionAnnotation]? = nil
    )
    {
        self.clientToken = clientToken
        self.inclusionAnnotations = inclusionAnnotations
    }
}

public struct BatchPutDataQualityStatisticAnnotationOutput: Swift.Sendable {
    /// A list of AnnotationError's.
    public var failedInclusionAnnotations: [GlueClientTypes.AnnotationError]?

    public init(
        failedInclusionAnnotations: [GlueClientTypes.AnnotationError]? = nil
    )
    {
        self.failedInclusionAnnotations = failedInclusionAnnotations
    }
}

public struct BatchStopJobRunInput: Swift.Sendable {
    /// The name of the job definition for which to stop job runs.
    /// This member is required.
    public var jobName: Swift.String?
    /// A list of the JobRunIds that should be stopped for that job definition.
    /// This member is required.
    public var jobRunIds: [Swift.String]?

    public init(
        jobName: Swift.String? = nil,
        jobRunIds: [Swift.String]? = nil
    )
    {
        self.jobName = jobName
        self.jobRunIds = jobRunIds
    }
}

extension GlueClientTypes {

    /// Records an error that occurred when attempting to stop a specified job run.
    public struct BatchStopJobRunError: Swift.Sendable {
        /// Specifies details about the error that was encountered.
        public var errorDetail: GlueClientTypes.ErrorDetail?
        /// The name of the job definition that is used in the job run in question.
        public var jobName: Swift.String?
        /// The JobRunId of the job run in question.
        public var jobRunId: Swift.String?

        public init(
            errorDetail: GlueClientTypes.ErrorDetail? = nil,
            jobName: Swift.String? = nil,
            jobRunId: Swift.String? = nil
        )
        {
            self.errorDetail = errorDetail
            self.jobName = jobName
            self.jobRunId = jobRunId
        }
    }
}

extension GlueClientTypes {

    /// Records a successful request to stop a specified JobRun.
    public struct BatchStopJobRunSuccessfulSubmission: Swift.Sendable {
        /// The name of the job definition used in the job run that was stopped.
        public var jobName: Swift.String?
        /// The JobRunId of the job run that was stopped.
        public var jobRunId: Swift.String?

        public init(
            jobName: Swift.String? = nil,
            jobRunId: Swift.String? = nil
        )
        {
            self.jobName = jobName
            self.jobRunId = jobRunId
        }
    }
}

public struct BatchStopJobRunOutput: Swift.Sendable {
    /// A list of the errors that were encountered in trying to stop JobRuns, including the JobRunId for which each error was encountered and details about the error.
    public var errors: [GlueClientTypes.BatchStopJobRunError]?
    /// A list of the JobRuns that were successfully submitted for stopping.
    public var successfulSubmissions: [GlueClientTypes.BatchStopJobRunSuccessfulSubmission]?

    public init(
        errors: [GlueClientTypes.BatchStopJobRunError]? = nil,
        successfulSubmissions: [GlueClientTypes.BatchStopJobRunSuccessfulSubmission]? = nil
    )
    {
        self.errors = errors
        self.successfulSubmissions = successfulSubmissions
    }
}

extension GlueClientTypes {

    /// A structure that contains the values and structure used to update a partition.
    public struct BatchUpdatePartitionRequestEntry: Swift.Sendable {
        /// The structure used to update a partition.
        /// This member is required.
        public var partitionInput: GlueClientTypes.PartitionInput?
        /// A list of values defining the partitions.
        /// This member is required.
        public var partitionValueList: [Swift.String]?

        public init(
            partitionInput: GlueClientTypes.PartitionInput? = nil,
            partitionValueList: [Swift.String]? = nil
        )
        {
            self.partitionInput = partitionInput
            self.partitionValueList = partitionValueList
        }
    }
}

public struct BatchUpdatePartitionInput: Swift.Sendable {
    /// The ID of the catalog in which the partition is to be updated. Currently, this should be the Amazon Web Services account ID.
    public var catalogId: Swift.String?
    /// The name of the metadata database in which the partition is to be updated.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A list of up to 100 BatchUpdatePartitionRequestEntry objects to update.
    /// This member is required.
    public var entries: [GlueClientTypes.BatchUpdatePartitionRequestEntry]?
    /// The name of the metadata table in which the partition is to be updated.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        entries: [GlueClientTypes.BatchUpdatePartitionRequestEntry]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.entries = entries
        self.tableName = tableName
    }
}

extension GlueClientTypes {

    /// Contains information about a batch update partition error.
    public struct BatchUpdatePartitionFailureEntry: Swift.Sendable {
        /// The details about the batch update partition error.
        public var errorDetail: GlueClientTypes.ErrorDetail?
        /// A list of values defining the partitions.
        public var partitionValueList: [Swift.String]?

        public init(
            errorDetail: GlueClientTypes.ErrorDetail? = nil,
            partitionValueList: [Swift.String]? = nil
        )
        {
            self.errorDetail = errorDetail
            self.partitionValueList = partitionValueList
        }
    }
}

public struct BatchUpdatePartitionOutput: Swift.Sendable {
    /// The errors encountered when trying to update the requested partitions. A list of BatchUpdatePartitionFailureEntry objects.
    public var errors: [GlueClientTypes.BatchUpdatePartitionFailureEntry]?

    public init(
        errors: [GlueClientTypes.BatchUpdatePartitionFailureEntry]? = nil
    )
    {
        self.errors = errors
    }
}

public struct CancelDataQualityRuleRecommendationRunInput: Swift.Sendable {
    /// The unique run identifier associated with this run.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        runId: Swift.String? = nil
    )
    {
        self.runId = runId
    }
}

public struct CancelDataQualityRuleRecommendationRunOutput: Swift.Sendable {

    public init() { }
}

public struct CancelDataQualityRulesetEvaluationRunInput: Swift.Sendable {
    /// The unique run identifier associated with this run.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        runId: Swift.String? = nil
    )
    {
        self.runId = runId
    }
}

public struct CancelDataQualityRulesetEvaluationRunOutput: Swift.Sendable {

    public init() { }
}

public struct CancelMLTaskRunInput: Swift.Sendable {
    /// A unique identifier for the task run.
    /// This member is required.
    public var taskRunId: Swift.String?
    /// The unique identifier of the machine learning transform.
    /// This member is required.
    public var transformId: Swift.String?

    public init(
        taskRunId: Swift.String? = nil,
        transformId: Swift.String? = nil
    )
    {
        self.taskRunId = taskRunId
        self.transformId = transformId
    }
}

extension GlueClientTypes {

    public enum TaskStatusType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case running
        case starting
        case stopped
        case stopping
        case succeeded
        case timeout
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatusType] {
            return [
                .failed,
                .running,
                .starting,
                .stopped,
                .stopping,
                .succeeded,
                .timeout
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .succeeded: return "SUCCEEDED"
            case .timeout: return "TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CancelMLTaskRunOutput: Swift.Sendable {
    /// The status for this run.
    public var status: GlueClientTypes.TaskStatusType?
    /// The unique identifier for the task run.
    public var taskRunId: Swift.String?
    /// The unique identifier of the machine learning transform.
    public var transformId: Swift.String?

    public init(
        status: GlueClientTypes.TaskStatusType? = nil,
        taskRunId: Swift.String? = nil,
        transformId: Swift.String? = nil
    )
    {
        self.status = status
        self.taskRunId = taskRunId
        self.transformId = transformId
    }
}

/// The session is in an invalid state to perform a requested operation.
public struct IllegalSessionStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalSessionStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelStatementInput: Swift.Sendable {
    /// The ID of the statement to be cancelled.
    /// This member is required.
    public var id: Swift.Int?
    /// The origin of the request to cancel the statement.
    public var requestOrigin: Swift.String?
    /// The Session ID of the statement to be cancelled.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        id: Swift.Int? = 0,
        requestOrigin: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.id = id
        self.requestOrigin = requestOrigin
        self.sessionId = sessionId
    }
}

public struct CancelStatementOutput: Swift.Sendable {

    public init() { }
}

extension GlueClientTypes {

    public enum DataFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case avro
        case json
        case protobuf
        case sdkUnknown(Swift.String)

        public static var allCases: [DataFormat] {
            return [
                .avro,
                .json,
                .protobuf
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .avro: return "AVRO"
            case .json: return "JSON"
            case .protobuf: return "PROTOBUF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CheckSchemaVersionValidityInput: Swift.Sendable {
    /// The data format of the schema definition. Currently AVRO, JSON and PROTOBUF are supported.
    /// This member is required.
    public var dataFormat: GlueClientTypes.DataFormat?
    /// The definition of the schema that has to be validated.
    /// This member is required.
    public var schemaDefinition: Swift.String?

    public init(
        dataFormat: GlueClientTypes.DataFormat? = nil,
        schemaDefinition: Swift.String? = nil
    )
    {
        self.dataFormat = dataFormat
        self.schemaDefinition = schemaDefinition
    }
}

public struct CheckSchemaVersionValidityOutput: Swift.Sendable {
    /// A validation failure error message.
    public var error: Swift.String?
    /// Return true, if the schema is valid and false otherwise.
    public var valid: Swift.Bool

    public init(
        error: Swift.String? = nil,
        valid: Swift.Bool = false
    )
    {
        self.error = error
        self.valid = valid
    }
}

public struct CreateBlueprintInput: Swift.Sendable {
    /// Specifies a path in Amazon S3 where the blueprint is published.
    /// This member is required.
    public var blueprintLocation: Swift.String?
    /// A description of the blueprint.
    public var description: Swift.String?
    /// The name of the blueprint.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to be applied to this blueprint.
    public var tags: [Swift.String: Swift.String]?

    public init(
        blueprintLocation: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.blueprintLocation = blueprintLocation
        self.description = description
        self.name = name
        self.tags = tags
    }
}

public struct CreateBlueprintOutput: Swift.Sendable {
    /// Returns the name of the blueprint that was registered.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension GlueClientTypes {

    public enum CsvHeaderOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case absent
        case present
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [CsvHeaderOption] {
            return [
                .absent,
                .present,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .absent: return "ABSENT"
            case .present: return "PRESENT"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum CsvSerdeOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lazysimpleserde
        case `none`
        case opencsvserde
        case sdkUnknown(Swift.String)

        public static var allCases: [CsvSerdeOption] {
            return [
                .lazysimpleserde,
                .none,
                .opencsvserde
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lazysimpleserde: return "LazySimpleSerDe"
            case .none: return "None"
            case .opencsvserde: return "OpenCSVSerDe"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies a custom CSV classifier for CreateClassifier to create.
    public struct CreateCsvClassifierRequest: Swift.Sendable {
        /// Enables the processing of files that contain only one column.
        public var allowSingleColumn: Swift.Bool?
        /// Indicates whether the CSV file contains a header.
        public var containsHeader: GlueClientTypes.CsvHeaderOption?
        /// Enables the configuration of custom datatypes.
        public var customDatatypeConfigured: Swift.Bool?
        /// Creates a list of supported custom datatypes.
        public var customDatatypes: [Swift.String]?
        /// A custom symbol to denote what separates each column entry in the row.
        public var delimiter: Swift.String?
        /// Specifies not to trim values before identifying the type of column values. The default value is true.
        public var disableValueTrimming: Swift.Bool?
        /// A list of strings representing column names.
        public var header: [Swift.String]?
        /// The name of the classifier.
        /// This member is required.
        public var name: Swift.String?
        /// A custom symbol to denote what combines content into a single column value. Must be different from the column delimiter.
        public var quoteSymbol: Swift.String?
        /// Sets the SerDe for processing CSV in the classifier, which will be applied in the Data Catalog. Valid values are OpenCSVSerDe, LazySimpleSerDe, and None. You can specify the None value when you want the crawler to do the detection.
        public var serde: GlueClientTypes.CsvSerdeOption?

        public init(
            allowSingleColumn: Swift.Bool? = nil,
            containsHeader: GlueClientTypes.CsvHeaderOption? = nil,
            customDatatypeConfigured: Swift.Bool? = nil,
            customDatatypes: [Swift.String]? = nil,
            delimiter: Swift.String? = nil,
            disableValueTrimming: Swift.Bool? = nil,
            header: [Swift.String]? = nil,
            name: Swift.String? = nil,
            quoteSymbol: Swift.String? = nil,
            serde: GlueClientTypes.CsvSerdeOption? = nil
        )
        {
            self.allowSingleColumn = allowSingleColumn
            self.containsHeader = containsHeader
            self.customDatatypeConfigured = customDatatypeConfigured
            self.customDatatypes = customDatatypes
            self.delimiter = delimiter
            self.disableValueTrimming = disableValueTrimming
            self.header = header
            self.name = name
            self.quoteSymbol = quoteSymbol
            self.serde = serde
        }
    }
}

extension GlueClientTypes {

    /// Specifies a grok classifier for CreateClassifier to create.
    public struct CreateGrokClassifierRequest: Swift.Sendable {
        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
        /// This member is required.
        public var classification: Swift.String?
        /// Optional custom grok patterns used by this classifier.
        public var customPatterns: Swift.String?
        /// The grok pattern used by this classifier.
        /// This member is required.
        public var grokPattern: Swift.String?
        /// The name of the new classifier.
        /// This member is required.
        public var name: Swift.String?

        public init(
            classification: Swift.String? = nil,
            customPatterns: Swift.String? = nil,
            grokPattern: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.classification = classification
            self.customPatterns = customPatterns
            self.grokPattern = grokPattern
            self.name = name
        }
    }
}

extension GlueClientTypes {

    /// Specifies a JSON classifier for CreateClassifier to create.
    public struct CreateJsonClassifierRequest: Swift.Sendable {
        /// A JsonPath string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in [Writing JsonPath Custom Classifiers](https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json).
        /// This member is required.
        public var jsonPath: Swift.String?
        /// The name of the classifier.
        /// This member is required.
        public var name: Swift.String?

        public init(
            jsonPath: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.jsonPath = jsonPath
            self.name = name
        }
    }
}

extension GlueClientTypes {

    /// Specifies an XML classifier for CreateClassifier to create.
    public struct CreateXMLClassifierRequest: Swift.Sendable {
        /// An identifier of the data format that the classifier matches.
        /// This member is required.
        public var classification: Swift.String?
        /// The name of the classifier.
        /// This member is required.
        public var name: Swift.String?
        /// The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by />). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example,  is okay, but  is not).
        public var rowTag: Swift.String?

        public init(
            classification: Swift.String? = nil,
            name: Swift.String? = nil,
            rowTag: Swift.String? = nil
        )
        {
            self.classification = classification
            self.name = name
            self.rowTag = rowTag
        }
    }
}

public struct CreateClassifierInput: Swift.Sendable {
    /// A CsvClassifier object specifying the classifier to create.
    public var csvClassifier: GlueClientTypes.CreateCsvClassifierRequest?
    /// A GrokClassifier object specifying the classifier to create.
    public var grokClassifier: GlueClientTypes.CreateGrokClassifierRequest?
    /// A JsonClassifier object specifying the classifier to create.
    public var jsonClassifier: GlueClientTypes.CreateJsonClassifierRequest?
    /// An XMLClassifier object specifying the classifier to create.
    public var xmlClassifier: GlueClientTypes.CreateXMLClassifierRequest?

    public init(
        csvClassifier: GlueClientTypes.CreateCsvClassifierRequest? = nil,
        grokClassifier: GlueClientTypes.CreateGrokClassifierRequest? = nil,
        jsonClassifier: GlueClientTypes.CreateJsonClassifierRequest? = nil,
        xmlClassifier: GlueClientTypes.CreateXMLClassifierRequest? = nil
    )
    {
        self.csvClassifier = csvClassifier
        self.grokClassifier = grokClassifier
        self.jsonClassifier = jsonClassifier
        self.xmlClassifier = xmlClassifier
    }
}

public struct CreateClassifierOutput: Swift.Sendable {

    public init() { }
}

/// An exception thrown when you try to start another job while running a column stats generation job.
public struct ColumnStatisticsTaskRunningException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ColumnStatisticsTaskRunningException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateColumnStatisticsTaskSettingsInput: Swift.Sendable {
    /// The ID of the Data Catalog in which the database resides.
    public var catalogID: Swift.String?
    /// A list of column names for which to run statistics.
    public var columnNameList: [Swift.String]?
    /// The name of the database where the table resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The role used for running the column statistics.
    /// This member is required.
    public var role: Swift.String?
    /// The percentage of data to sample.
    public var sampleSize: Swift.Double?
    /// A schedule for running the column statistics, specified in CRON syntax.
    public var schedule: Swift.String?
    /// Name of the security configuration that is used to encrypt CloudWatch logs.
    public var securityConfiguration: Swift.String?
    /// The name of the table for which to generate column statistics.
    /// This member is required.
    public var tableName: Swift.String?
    /// A map of tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        catalogID: Swift.String? = nil,
        columnNameList: [Swift.String]? = nil,
        databaseName: Swift.String? = nil,
        role: Swift.String? = nil,
        sampleSize: Swift.Double? = 0.0,
        schedule: Swift.String? = nil,
        securityConfiguration: Swift.String? = nil,
        tableName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.catalogID = catalogID
        self.columnNameList = columnNameList
        self.databaseName = databaseName
        self.role = role
        self.sampleSize = sampleSize
        self.schedule = schedule
        self.securityConfiguration = securityConfiguration
        self.tableName = tableName
        self.tags = tags
    }
}

public struct CreateColumnStatisticsTaskSettingsOutput: Swift.Sendable {

    public init() { }
}

extension GlueClientTypes {

    public enum ConnectionPropertyKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case clusterIdentifier
        case configFiles
        case connectionUrl
        case connectorClassName
        case connectorType
        case connectorUrl
        case customJdbcCert
        case customJdbcCertString
        case database
        case encryptedKafkaClientKeystorePassword
        case encryptedKafkaClientKeyPassword
        case encryptedKafkaSaslPlainPassword
        case encryptedKafkaSaslScramPassword
        case encryptedPassword
        case host
        case instanceId
        case jdbcConnectionUrl
        case jdbcDriverClassName
        case jdbcDriverJarUri
        case jdbcEnforceSsl
        case jdbcEngine
        case jdbcEngineVersion
        case kafkaBootstrapServers
        case kafkaClientKeystore
        case kafkaClientKeystorePassword
        case kafkaClientKeyPassword
        case kafkaCustomCert
        case kafkaSaslGssapiKeytab
        case kafkaSaslGssapiKrb5Conf
        case kafkaSaslGssapiPrincipal
        case kafkaSaslGssapiService
        case kafkaSaslMechanism
        case kafkaSaslPlainPassword
        case kafkaSaslPlainUsername
        case kafkaSaslScramPassword
        case kafkaSaslScramSecretsArn
        case kafkaSaslScramUsername
        case kafkaSkipCustomCertValidation
        case kafkaSslEnabled
        case password
        case port
        case region
        case roleArn
        case secretId
        case skipCustomJdbcCertValidation
        case userName
        case workgroupName
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionPropertyKey] {
            return [
                .clusterIdentifier,
                .configFiles,
                .connectionUrl,
                .connectorClassName,
                .connectorType,
                .connectorUrl,
                .customJdbcCert,
                .customJdbcCertString,
                .database,
                .encryptedKafkaClientKeystorePassword,
                .encryptedKafkaClientKeyPassword,
                .encryptedKafkaSaslPlainPassword,
                .encryptedKafkaSaslScramPassword,
                .encryptedPassword,
                .host,
                .instanceId,
                .jdbcConnectionUrl,
                .jdbcDriverClassName,
                .jdbcDriverJarUri,
                .jdbcEnforceSsl,
                .jdbcEngine,
                .jdbcEngineVersion,
                .kafkaBootstrapServers,
                .kafkaClientKeystore,
                .kafkaClientKeystorePassword,
                .kafkaClientKeyPassword,
                .kafkaCustomCert,
                .kafkaSaslGssapiKeytab,
                .kafkaSaslGssapiKrb5Conf,
                .kafkaSaslGssapiPrincipal,
                .kafkaSaslGssapiService,
                .kafkaSaslMechanism,
                .kafkaSaslPlainPassword,
                .kafkaSaslPlainUsername,
                .kafkaSaslScramPassword,
                .kafkaSaslScramSecretsArn,
                .kafkaSaslScramUsername,
                .kafkaSkipCustomCertValidation,
                .kafkaSslEnabled,
                .password,
                .port,
                .region,
                .roleArn,
                .secretId,
                .skipCustomJdbcCertValidation,
                .userName,
                .workgroupName
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .clusterIdentifier: return "CLUSTER_IDENTIFIER"
            case .configFiles: return "CONFIG_FILES"
            case .connectionUrl: return "CONNECTION_URL"
            case .connectorClassName: return "CONNECTOR_CLASS_NAME"
            case .connectorType: return "CONNECTOR_TYPE"
            case .connectorUrl: return "CONNECTOR_URL"
            case .customJdbcCert: return "CUSTOM_JDBC_CERT"
            case .customJdbcCertString: return "CUSTOM_JDBC_CERT_STRING"
            case .database: return "DATABASE"
            case .encryptedKafkaClientKeystorePassword: return "ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"
            case .encryptedKafkaClientKeyPassword: return "ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"
            case .encryptedKafkaSaslPlainPassword: return "ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD"
            case .encryptedKafkaSaslScramPassword: return "ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD"
            case .encryptedPassword: return "ENCRYPTED_PASSWORD"
            case .host: return "HOST"
            case .instanceId: return "INSTANCE_ID"
            case .jdbcConnectionUrl: return "JDBC_CONNECTION_URL"
            case .jdbcDriverClassName: return "JDBC_DRIVER_CLASS_NAME"
            case .jdbcDriverJarUri: return "JDBC_DRIVER_JAR_URI"
            case .jdbcEnforceSsl: return "JDBC_ENFORCE_SSL"
            case .jdbcEngine: return "JDBC_ENGINE"
            case .jdbcEngineVersion: return "JDBC_ENGINE_VERSION"
            case .kafkaBootstrapServers: return "KAFKA_BOOTSTRAP_SERVERS"
            case .kafkaClientKeystore: return "KAFKA_CLIENT_KEYSTORE"
            case .kafkaClientKeystorePassword: return "KAFKA_CLIENT_KEYSTORE_PASSWORD"
            case .kafkaClientKeyPassword: return "KAFKA_CLIENT_KEY_PASSWORD"
            case .kafkaCustomCert: return "KAFKA_CUSTOM_CERT"
            case .kafkaSaslGssapiKeytab: return "KAFKA_SASL_GSSAPI_KEYTAB"
            case .kafkaSaslGssapiKrb5Conf: return "KAFKA_SASL_GSSAPI_KRB5_CONF"
            case .kafkaSaslGssapiPrincipal: return "KAFKA_SASL_GSSAPI_PRINCIPAL"
            case .kafkaSaslGssapiService: return "KAFKA_SASL_GSSAPI_SERVICE"
            case .kafkaSaslMechanism: return "KAFKA_SASL_MECHANISM"
            case .kafkaSaslPlainPassword: return "KAFKA_SASL_PLAIN_PASSWORD"
            case .kafkaSaslPlainUsername: return "KAFKA_SASL_PLAIN_USERNAME"
            case .kafkaSaslScramPassword: return "KAFKA_SASL_SCRAM_PASSWORD"
            case .kafkaSaslScramSecretsArn: return "KAFKA_SASL_SCRAM_SECRETS_ARN"
            case .kafkaSaslScramUsername: return "KAFKA_SASL_SCRAM_USERNAME"
            case .kafkaSkipCustomCertValidation: return "KAFKA_SKIP_CUSTOM_CERT_VALIDATION"
            case .kafkaSslEnabled: return "KAFKA_SSL_ENABLED"
            case .password: return "PASSWORD"
            case .port: return "PORT"
            case .region: return "REGION"
            case .roleArn: return "ROLE_ARN"
            case .secretId: return "SECRET_ID"
            case .skipCustomJdbcCertValidation: return "SKIP_CUSTOM_JDBC_CERT_VALIDATION"
            case .userName: return "USERNAME"
            case .workgroupName: return "WORKGROUP_NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum ConnectionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case jdbc
        case kafka
        case marketplace
        case mongodb
        case network
        case salesforce
        case sftp
        case viewValidationAthena
        case viewValidationRedshift
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .custom,
                .jdbc,
                .kafka,
                .marketplace,
                .mongodb,
                .network,
                .salesforce,
                .sftp,
                .viewValidationAthena,
                .viewValidationRedshift
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .jdbc: return "JDBC"
            case .kafka: return "KAFKA"
            case .marketplace: return "MARKETPLACE"
            case .mongodb: return "MONGODB"
            case .network: return "NETWORK"
            case .salesforce: return "SALESFORCE"
            case .sftp: return "SFTP"
            case .viewValidationAthena: return "VIEW_VALIDATION_ATHENA"
            case .viewValidationRedshift: return "VIEW_VALIDATION_REDSHIFT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The OAuth client app in GetConnection response.
    public struct PhysicalConnectionRequirements: Swift.Sendable {
        /// The connection's Availability Zone.
        public var availabilityZone: Swift.String?
        /// The security group ID list used by the connection.
        public var securityGroupIdList: [Swift.String]?
        /// The subnet ID used by the connection.
        public var subnetId: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            securityGroupIdList: [Swift.String]? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.securityGroupIdList = securityGroupIdList
            self.subnetId = subnetId
        }
    }
}

extension GlueClientTypes {

    /// A structure that is used to specify a connection to create or update.
    public struct ConnectionInput: Swift.Sendable {
        /// This field is not currently used.
        public var athenaProperties: [Swift.String: Swift.String]?
        /// The authentication properties of the connection. Used for a Salesforce connection.
        public var authenticationConfiguration: GlueClientTypes.AuthenticationConfigurationInput?
        /// These key-value pairs define parameters for the connection.
        /// This member is required.
        public var connectionProperties: [Swift.String: Swift.String]?
        /// The type of the connection. Currently, these types are supported:
        ///
        /// * JDBC - Designates a connection to a database through Java Database Connectivity (JDBC). JDBC Connections use the following ConnectionParameters.
        ///
        /// * Required: All of (HOST, PORT, JDBC_ENGINE) or JDBC_CONNECTION_URL.
        ///
        /// * Required: All of (USERNAME, PASSWORD) or SECRET_ID.
        ///
        /// * Optional: JDBC_ENFORCE_SSL, CUSTOM_JDBC_CERT, CUSTOM_JDBC_CERT_STRING, SKIP_CUSTOM_JDBC_CERT_VALIDATION. These parameters are used to configure SSL with JDBC.
        ///
        ///
        ///
        ///
        /// * KAFKA - Designates a connection to an Apache Kafka streaming platform. KAFKA Connections use the following ConnectionParameters.
        ///
        /// * Required: KAFKA_BOOTSTRAP_SERVERS.
        ///
        /// * Optional: KAFKA_SSL_ENABLED, KAFKA_CUSTOM_CERT, KAFKA_SKIP_CUSTOM_CERT_VALIDATION. These parameters are used to configure SSL with KAFKA.
        ///
        /// * Optional: KAFKA_CLIENT_KEYSTORE, KAFKA_CLIENT_KEYSTORE_PASSWORD, KAFKA_CLIENT_KEY_PASSWORD, ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD, ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD. These parameters are used to configure TLS client configuration with SSL in KAFKA.
        ///
        /// * Optional: KAFKA_SASL_MECHANISM. Can be specified as SCRAM-SHA-512, GSSAPI, or AWS_MSK_IAM.
        ///
        /// * Optional: KAFKA_SASL_SCRAM_USERNAME, KAFKA_SASL_SCRAM_PASSWORD, ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD. These parameters are used to configure SASL/SCRAM-SHA-512 authentication with KAFKA.
        ///
        /// * Optional: KAFKA_SASL_GSSAPI_KEYTAB, KAFKA_SASL_GSSAPI_KRB5_CONF, KAFKA_SASL_GSSAPI_SERVICE, KAFKA_SASL_GSSAPI_PRINCIPAL. These parameters are used to configure SASL/GSSAPI authentication with KAFKA.
        ///
        ///
        ///
        ///
        /// * MONGODB - Designates a connection to a MongoDB document database. MONGODB Connections use the following ConnectionParameters.
        ///
        /// * Required: CONNECTION_URL.
        ///
        /// * Required: All of (USERNAME, PASSWORD) or SECRET_ID.
        ///
        ///
        ///
        ///
        /// * SALESFORCE - Designates a connection to Salesforce using OAuth authencation.
        ///
        /// * Requires the AuthenticationConfiguration member to be configured.
        ///
        ///
        ///
        ///
        /// * VIEW_VALIDATION_REDSHIFT - Designates a connection used for view validation by Amazon Redshift.
        ///
        /// * VIEW_VALIDATION_ATHENA - Designates a connection used for view validation by Amazon Athena.
        ///
        /// * NETWORK - Designates a network connection to a data source within an Amazon Virtual Private Cloud environment (Amazon VPC). NETWORK Connections do not require ConnectionParameters. Instead, provide a PhysicalConnectionRequirements.
        ///
        /// * MARKETPLACE - Uses configuration settings contained in a connector purchased from Amazon Web Services Marketplace to read from and write to data stores that are not natively supported by Glue. MARKETPLACE Connections use the following ConnectionParameters.
        ///
        /// * Required: CONNECTOR_TYPE, CONNECTOR_URL, CONNECTOR_CLASS_NAME, CONNECTION_URL.
        ///
        /// * Required for JDBCCONNECTOR_TYPE connections: All of (USERNAME, PASSWORD) or SECRET_ID.
        ///
        ///
        ///
        ///
        /// * CUSTOM - Uses configuration settings contained in a custom connector to read from and write to data stores that are not natively supported by Glue.
        ///
        ///
        /// SFTP is not supported. For more information about how optional ConnectionProperties are used to configure features in Glue, consult [Glue connection properties](https://docs.aws.amazon.com/glue/latest/dg/connection-defining.html). For more information about how optional ConnectionProperties are used to configure features in Glue Studio, consult [Using connectors and connections](https://docs.aws.amazon.com/glue/latest/ug/connectors-chapter.html).
        /// This member is required.
        public var connectionType: GlueClientTypes.ConnectionType?
        /// The description of the connection.
        public var description: Swift.String?
        /// A list of criteria that can be used in selecting this connection.
        public var matchCriteria: [Swift.String]?
        /// The name of the connection.
        /// This member is required.
        public var name: Swift.String?
        /// The physical connection requirements, such as virtual private cloud (VPC) and SecurityGroup, that are needed to successfully make this connection.
        public var physicalConnectionRequirements: GlueClientTypes.PhysicalConnectionRequirements?
        /// A flag to validate the credentials during create connection. Used for a Salesforce connection. Default is true.
        public var validateCredentials: Swift.Bool

        public init(
            athenaProperties: [Swift.String: Swift.String]? = nil,
            authenticationConfiguration: GlueClientTypes.AuthenticationConfigurationInput? = nil,
            connectionProperties: [Swift.String: Swift.String]? = nil,
            connectionType: GlueClientTypes.ConnectionType? = nil,
            description: Swift.String? = nil,
            matchCriteria: [Swift.String]? = nil,
            name: Swift.String? = nil,
            physicalConnectionRequirements: GlueClientTypes.PhysicalConnectionRequirements? = nil,
            validateCredentials: Swift.Bool = false
        )
        {
            self.athenaProperties = athenaProperties
            self.authenticationConfiguration = authenticationConfiguration
            self.connectionProperties = connectionProperties
            self.connectionType = connectionType
            self.description = description
            self.matchCriteria = matchCriteria
            self.name = name
            self.physicalConnectionRequirements = physicalConnectionRequirements
            self.validateCredentials = validateCredentials
        }
    }
}

public struct CreateConnectionInput: Swift.Sendable {
    /// The ID of the Data Catalog in which to create the connection. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// A ConnectionInput object defining the connection to create.
    /// This member is required.
    public var connectionInput: GlueClientTypes.ConnectionInput?
    /// The tags you assign to the connection.
    public var tags: [Swift.String: Swift.String]?

    public init(
        catalogId: Swift.String? = nil,
        connectionInput: GlueClientTypes.ConnectionInput? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.catalogId = catalogId
        self.connectionInput = connectionInput
        self.tags = tags
    }
}

extension GlueClientTypes {

    public enum ConnectionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .failed,
                .inProgress,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateConnectionOutput: Swift.Sendable {
    /// The status of the connection creation request. The request can take some time for certain authentication types, for example when creating an OAuth connection with token exchange over VPC.
    public var createConnectionStatus: GlueClientTypes.ConnectionStatus?

    public init(
        createConnectionStatus: GlueClientTypes.ConnectionStatus? = nil
    )
    {
        self.createConnectionStatus = createConnectionStatus
    }
}

public struct CreateCrawlerInput: Swift.Sendable {
    /// A list of custom classifiers that the user has registered. By default, all built-in classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
    public var classifiers: [Swift.String]?
    /// Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see [Setting crawler configuration options](https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html).
    public var configuration: Swift.String?
    /// The name of the SecurityConfiguration structure to be used by this crawler.
    public var crawlerSecurityConfiguration: Swift.String?
    /// The Glue database where results are written, such as: arn:aws:daylight:us-east-1::database/sometable/*.
    public var databaseName: Swift.String?
    /// A description of the new crawler.
    public var description: Swift.String?
    /// Specifies Lake Formation configuration settings for the crawler.
    public var lakeFormationConfiguration: GlueClientTypes.LakeFormationConfiguration?
    /// Specifies data lineage configuration settings for the crawler.
    public var lineageConfiguration: GlueClientTypes.LineageConfiguration?
    /// Name of the new crawler.
    /// This member is required.
    public var name: Swift.String?
    /// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.
    public var recrawlPolicy: GlueClientTypes.RecrawlPolicy?
    /// The IAM role or Amazon Resource Name (ARN) of an IAM role used by the new crawler to access customer resources.
    /// This member is required.
    public var role: Swift.String?
    /// A cron expression used to specify the schedule (see [Time-Based Schedules for Jobs and Crawlers](https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html). For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
    public var schedule: Swift.String?
    /// The policy for the crawler's update and deletion behavior.
    public var schemaChangePolicy: GlueClientTypes.SchemaChangePolicy?
    /// The table prefix used for catalog tables that are created.
    public var tablePrefix: Swift.String?
    /// The tags to use with this crawler request. You may use tags to limit access to the crawler. For more information about tags in Glue, see [Amazon Web Services Tags in Glue](https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html) in the developer guide.
    public var tags: [Swift.String: Swift.String]?
    /// A list of collection of targets to crawl.
    /// This member is required.
    public var targets: GlueClientTypes.CrawlerTargets?

    public init(
        classifiers: [Swift.String]? = nil,
        configuration: Swift.String? = nil,
        crawlerSecurityConfiguration: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        description: Swift.String? = nil,
        lakeFormationConfiguration: GlueClientTypes.LakeFormationConfiguration? = nil,
        lineageConfiguration: GlueClientTypes.LineageConfiguration? = nil,
        name: Swift.String? = nil,
        recrawlPolicy: GlueClientTypes.RecrawlPolicy? = nil,
        role: Swift.String? = nil,
        schedule: Swift.String? = nil,
        schemaChangePolicy: GlueClientTypes.SchemaChangePolicy? = nil,
        tablePrefix: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targets: GlueClientTypes.CrawlerTargets? = nil
    )
    {
        self.classifiers = classifiers
        self.configuration = configuration
        self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
        self.databaseName = databaseName
        self.description = description
        self.lakeFormationConfiguration = lakeFormationConfiguration
        self.lineageConfiguration = lineageConfiguration
        self.name = name
        self.recrawlPolicy = recrawlPolicy
        self.role = role
        self.schedule = schedule
        self.schemaChangePolicy = schemaChangePolicy
        self.tablePrefix = tablePrefix
        self.tags = tags
        self.targets = targets
    }
}

public struct CreateCrawlerOutput: Swift.Sendable {

    public init() { }
}

/// The same unique identifier was associated with two different records.
public struct IdempotentParameterMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotentParameterMismatchException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateCustomEntityTypeInput: Swift.Sendable {
    /// A list of context words. If none of these context words are found within the vicinity of the regular expression the data will not be detected as sensitive data. If no context words are passed only a regular expression is checked.
    public var contextWords: [Swift.String]?
    /// A name for the custom pattern that allows it to be retrieved or deleted later. This name must be unique per Amazon Web Services account.
    /// This member is required.
    public var name: Swift.String?
    /// A regular expression string that is used for detecting sensitive data in a custom pattern.
    /// This member is required.
    public var regexString: Swift.String?
    /// A list of tags applied to the custom entity type.
    public var tags: [Swift.String: Swift.String]?

    public init(
        contextWords: [Swift.String]? = nil,
        name: Swift.String? = nil,
        regexString: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.contextWords = contextWords
        self.name = name
        self.regexString = regexString
        self.tags = tags
    }
}

public struct CreateCustomEntityTypeOutput: Swift.Sendable {
    /// The name of the custom pattern you created.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

/// Two processes are trying to modify a resource simultaneously.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A federated resource already exists.
public struct FederatedResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The associated Glue resource already exists.
        public internal(set) var associatedGlueResource: Swift.String? = nil
        /// The message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FederatedResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        associatedGlueResource: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.associatedGlueResource = associatedGlueResource
        self.properties.message = message
    }
}

extension GlueClientTypes {

    public enum Permission: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case alter
        case createDatabase
        case createTable
        case dataLocationAccess
        case delete
        case drop
        case insert
        case select
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .all,
                .alter,
                .createDatabase,
                .createTable,
                .dataLocationAccess,
                .delete,
                .drop,
                .insert,
                .select
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .alter: return "ALTER"
            case .createDatabase: return "CREATE_DATABASE"
            case .createTable: return "CREATE_TABLE"
            case .dataLocationAccess: return "DATA_LOCATION_ACCESS"
            case .delete: return "DELETE"
            case .drop: return "DROP"
            case .insert: return "INSERT"
            case .select: return "SELECT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The Lake Formation principal.
    public struct DataLakePrincipal: Swift.Sendable {
        /// An identifier for the Lake Formation principal.
        public var dataLakePrincipalIdentifier: Swift.String?

        public init(
            dataLakePrincipalIdentifier: Swift.String? = nil
        )
        {
            self.dataLakePrincipalIdentifier = dataLakePrincipalIdentifier
        }
    }
}

extension GlueClientTypes {

    /// Permissions granted to a principal.
    public struct PrincipalPermissions: Swift.Sendable {
        /// The permissions that are granted to the principal.
        public var permissions: [GlueClientTypes.Permission]?
        /// The principal who is granted permissions.
        public var principal: GlueClientTypes.DataLakePrincipal?

        public init(
            permissions: [GlueClientTypes.Permission]? = nil,
            principal: GlueClientTypes.DataLakePrincipal? = nil
        )
        {
            self.permissions = permissions
            self.principal = principal
        }
    }
}

extension GlueClientTypes {

    /// A database that points to an entity outside the Glue Data Catalog.
    public struct FederatedDatabase: Swift.Sendable {
        /// The name of the connection to the external metastore.
        public var connectionName: Swift.String?
        /// A unique identifier for the federated database.
        public var identifier: Swift.String?

        public init(
            connectionName: Swift.String? = nil,
            identifier: Swift.String? = nil
        )
        {
            self.connectionName = connectionName
            self.identifier = identifier
        }
    }
}

extension GlueClientTypes {

    /// A structure that describes a target database for resource linking.
    public struct DatabaseIdentifier: Swift.Sendable {
        /// The ID of the Data Catalog in which the database resides.
        public var catalogId: Swift.String?
        /// The name of the catalog database.
        public var databaseName: Swift.String?
        /// Region of the target database.
        public var region: Swift.String?

        public init(
            catalogId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.region = region
        }
    }
}

extension GlueClientTypes {

    /// The structure used to create or update a database.
    public struct DatabaseInput: Swift.Sendable {
        /// Creates a set of default permissions on the table for principals. Used by Lake Formation. Not used in the normal course of Glue operations.
        public var createTableDefaultPermissions: [GlueClientTypes.PrincipalPermissions]?
        /// A description of the database.
        public var description: Swift.String?
        /// A FederatedDatabase structure that references an entity outside the Glue Data Catalog.
        public var federatedDatabase: GlueClientTypes.FederatedDatabase?
        /// The location of the database (for example, an HDFS path).
        public var locationUri: Swift.String?
        /// The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.
        /// This member is required.
        public var name: Swift.String?
        /// These key-value pairs define parameters and properties of the database. These key-value pairs define parameters and properties of the database.
        public var parameters: [Swift.String: Swift.String]?
        /// A DatabaseIdentifier structure that describes a target database for resource linking.
        public var targetDatabase: GlueClientTypes.DatabaseIdentifier?

        public init(
            createTableDefaultPermissions: [GlueClientTypes.PrincipalPermissions]? = nil,
            description: Swift.String? = nil,
            federatedDatabase: GlueClientTypes.FederatedDatabase? = nil,
            locationUri: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            targetDatabase: GlueClientTypes.DatabaseIdentifier? = nil
        )
        {
            self.createTableDefaultPermissions = createTableDefaultPermissions
            self.description = description
            self.federatedDatabase = federatedDatabase
            self.locationUri = locationUri
            self.name = name
            self.parameters = parameters
            self.targetDatabase = targetDatabase
        }
    }
}

public struct CreateDatabaseInput: Swift.Sendable {
    /// The ID of the Data Catalog in which to create the database. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The metadata for the database.
    /// This member is required.
    public var databaseInput: GlueClientTypes.DatabaseInput?
    /// The tags you assign to the database.
    public var tags: [Swift.String: Swift.String]?

    public init(
        catalogId: Swift.String? = nil,
        databaseInput: GlueClientTypes.DatabaseInput? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseInput = databaseInput
        self.tags = tags
    }
}

public struct CreateDatabaseOutput: Swift.Sendable {

    public init() { }
}

extension GlueClientTypes {

    /// An object representing an Glue table.
    public struct DataQualityTargetTable: Swift.Sendable {
        /// The catalog id where the Glue table exists.
        public var catalogId: Swift.String?
        /// The name of the database where the Glue table exists.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The name of the Glue table.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            catalogId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
        }
    }
}

public struct CreateDataQualityRulesetInput: Swift.Sendable {
    /// Used for idempotency and is recommended to be set to a random ID (such as a UUID) to avoid creating or starting multiple instances of the same resource.
    public var clientToken: Swift.String?
    /// The name of the security configuration created with the data quality encryption option.
    public var dataQualitySecurityConfiguration: Swift.String?
    /// A description of the data quality ruleset.
    public var description: Swift.String?
    /// A unique name for the data quality ruleset.
    /// This member is required.
    public var name: Swift.String?
    /// A Data Quality Definition Language (DQDL) ruleset. For more information, see the Glue developer guide.
    /// This member is required.
    public var ruleset: Swift.String?
    /// A list of tags applied to the data quality ruleset.
    public var tags: [Swift.String: Swift.String]?
    /// A target table associated with the data quality ruleset.
    public var targetTable: GlueClientTypes.DataQualityTargetTable?

    public init(
        clientToken: Swift.String? = nil,
        dataQualitySecurityConfiguration: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        ruleset: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targetTable: GlueClientTypes.DataQualityTargetTable? = nil
    )
    {
        self.clientToken = clientToken
        self.dataQualitySecurityConfiguration = dataQualitySecurityConfiguration
        self.description = description
        self.name = name
        self.ruleset = ruleset
        self.tags = tags
        self.targetTable = targetTable
    }
}

public struct CreateDataQualityRulesetOutput: Swift.Sendable {
    /// A unique name for the data quality ruleset.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

/// A value could not be validated.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateDevEndpointInput: Swift.Sendable {
    /// A map of arguments used to configure the DevEndpoint.
    public var arguments: [Swift.String: Swift.String]?
    /// The name to be assigned to the new DevEndpoint.
    /// This member is required.
    public var endpointName: Swift.String?
    /// The path to one or more Java .jar files in an S3 bucket that should be loaded in your DevEndpoint.
    public var extraJarsS3Path: Swift.String?
    /// The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma. You can only use pure Python libraries with a DevEndpoint. Libraries that rely on C extensions, such as the [pandas](http://pandas.pydata.org/) Python data analysis library, are not yet supported.
    public var extraPythonLibsS3Path: Swift.String?
    /// Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints. For more information about the available Glue versions and corresponding Spark and Python versions, see [Glue version](https://docs.aws.amazon.com/glue/latest/dg/add-job.html) in the developer guide. Development endpoints that are created without specifying a Glue version default to Glue 0.9. You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
    public var glueVersion: Swift.String?
    /// The number of Glue Data Processing Units (DPUs) to allocate to this DevEndpoint.
    public var numberOfNodes: Swift.Int?
    /// The number of workers of a defined workerType that are allocated to the development endpoint. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X.
    public var numberOfWorkers: Swift.Int?
    /// The public key to be used by this DevEndpoint for authentication. This attribute is provided for backward compatibility because the recommended attribute to use is public keys.
    public var publicKey: Swift.String?
    /// A list of public keys to be used by the development endpoints for authentication. The use of this attribute is preferred over a single public key because the public keys allow you to have a different private key per client. If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys. Call the UpdateDevEndpoint API with the public key content in the deletePublicKeys attribute, and the list of new keys in the addPublicKeys attribute.
    public var publicKeys: [Swift.String]?
    /// The IAM role for the DevEndpoint.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the SecurityConfiguration structure to be used with this DevEndpoint.
    public var securityConfiguration: Swift.String?
    /// Security group IDs for the security groups to be used by the new DevEndpoint.
    public var securityGroupIds: [Swift.String]?
    /// The subnet ID for the new DevEndpoint to use.
    public var subnetId: Swift.String?
    /// The tags to use with this DevEndpoint. You may use tags to limit access to the DevEndpoint. For more information about tags in Glue, see [Amazon Web Services Tags in Glue](https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html) in the developer guide.
    public var tags: [Swift.String: Swift.String]?
    /// The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.
    ///
    /// * For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.
    ///
    /// * For the G.1X worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.
    ///
    /// * For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.
    ///
    ///
    /// Known issue: when a development endpoint is created with the G.2XWorkerType configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk.
    public var workerType: GlueClientTypes.WorkerType?

    public init(
        arguments: [Swift.String: Swift.String]? = nil,
        endpointName: Swift.String? = nil,
        extraJarsS3Path: Swift.String? = nil,
        extraPythonLibsS3Path: Swift.String? = nil,
        glueVersion: Swift.String? = nil,
        numberOfNodes: Swift.Int? = 0,
        numberOfWorkers: Swift.Int? = nil,
        publicKey: Swift.String? = nil,
        publicKeys: [Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        securityConfiguration: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workerType: GlueClientTypes.WorkerType? = nil
    )
    {
        self.arguments = arguments
        self.endpointName = endpointName
        self.extraJarsS3Path = extraJarsS3Path
        self.extraPythonLibsS3Path = extraPythonLibsS3Path
        self.glueVersion = glueVersion
        self.numberOfNodes = numberOfNodes
        self.numberOfWorkers = numberOfWorkers
        self.publicKey = publicKey
        self.publicKeys = publicKeys
        self.roleArn = roleArn
        self.securityConfiguration = securityConfiguration
        self.securityGroupIds = securityGroupIds
        self.subnetId = subnetId
        self.tags = tags
        self.workerType = workerType
    }
}

public struct CreateDevEndpointOutput: Swift.Sendable {
    /// The map of arguments used to configure this DevEndpoint. Valid arguments are:
    ///
    /// * "--enable-glue-datacatalog": ""
    ///
    ///
    /// You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
    public var arguments: [Swift.String: Swift.String]?
    /// The Amazon Web Services Availability Zone where this DevEndpoint is located.
    public var availabilityZone: Swift.String?
    /// The point in time at which this DevEndpoint was created.
    public var createdTimestamp: Foundation.Date?
    /// The name assigned to the new DevEndpoint.
    public var endpointName: Swift.String?
    /// Path to one or more Java .jar files in an S3 bucket that will be loaded in your DevEndpoint.
    public var extraJarsS3Path: Swift.String?
    /// The paths to one or more Python libraries in an S3 bucket that will be loaded in your DevEndpoint.
    public var extraPythonLibsS3Path: Swift.String?
    /// The reason for a current failure in this DevEndpoint.
    public var failureReason: Swift.String?
    /// Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints. For more information about the available Glue versions and corresponding Spark and Python versions, see [Glue version](https://docs.aws.amazon.com/glue/latest/dg/add-job.html) in the developer guide.
    public var glueVersion: Swift.String?
    /// The number of Glue Data Processing Units (DPUs) allocated to this DevEndpoint.
    public var numberOfNodes: Swift.Int
    /// The number of workers of a defined workerType that are allocated to the development endpoint.
    public var numberOfWorkers: Swift.Int?
    /// The Amazon Resource Name (ARN) of the role assigned to the new DevEndpoint.
    public var roleArn: Swift.String?
    /// The name of the SecurityConfiguration structure being used with this DevEndpoint.
    public var securityConfiguration: Swift.String?
    /// The security groups assigned to the new DevEndpoint.
    public var securityGroupIds: [Swift.String]?
    /// The current status of the new DevEndpoint.
    public var status: Swift.String?
    /// The subnet ID assigned to the new DevEndpoint.
    public var subnetId: Swift.String?
    /// The ID of the virtual private cloud (VPC) used by this DevEndpoint.
    public var vpcId: Swift.String?
    /// The type of predefined worker that is allocated to the development endpoint. May be a value of Standard, G.1X, or G.2X.
    public var workerType: GlueClientTypes.WorkerType?
    /// The address of the YARN endpoint used by this DevEndpoint.
    public var yarnEndpointAddress: Swift.String?
    /// The Apache Zeppelin port for the remote Apache Spark interpreter.
    public var zeppelinRemoteSparkInterpreterPort: Swift.Int

    public init(
        arguments: [Swift.String: Swift.String]? = nil,
        availabilityZone: Swift.String? = nil,
        createdTimestamp: Foundation.Date? = nil,
        endpointName: Swift.String? = nil,
        extraJarsS3Path: Swift.String? = nil,
        extraPythonLibsS3Path: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        glueVersion: Swift.String? = nil,
        numberOfNodes: Swift.Int = 0,
        numberOfWorkers: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        securityConfiguration: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        vpcId: Swift.String? = nil,
        workerType: GlueClientTypes.WorkerType? = nil,
        yarnEndpointAddress: Swift.String? = nil,
        zeppelinRemoteSparkInterpreterPort: Swift.Int = 0
    )
    {
        self.arguments = arguments
        self.availabilityZone = availabilityZone
        self.createdTimestamp = createdTimestamp
        self.endpointName = endpointName
        self.extraJarsS3Path = extraJarsS3Path
        self.extraPythonLibsS3Path = extraPythonLibsS3Path
        self.failureReason = failureReason
        self.glueVersion = glueVersion
        self.numberOfNodes = numberOfNodes
        self.numberOfWorkers = numberOfWorkers
        self.roleArn = roleArn
        self.securityConfiguration = securityConfiguration
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.subnetId = subnetId
        self.vpcId = vpcId
        self.workerType = workerType
        self.yarnEndpointAddress = yarnEndpointAddress
        self.zeppelinRemoteSparkInterpreterPort = zeppelinRemoteSparkInterpreterPort
    }
}

public struct CreateJobOutput: Swift.Sendable {
    /// The unique name that was provided for this job definition.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension GlueClientTypes {

    /// The parameters to configure the find matches transform.
    public struct FindMatchesParameters: Swift.Sendable {
        /// The value that is selected when tuning your transform for a balance between accuracy and cost. A value of 0.5 means that the system balances accuracy and cost concerns. A value of 1.0 means a bias purely for accuracy, which typically results in a higher cost, sometimes substantially higher. A value of 0.0 means a bias purely for cost, which results in a less accurate FindMatches transform, sometimes with unacceptable accuracy. Accuracy measures how well the transform finds true positives and true negatives. Increasing accuracy requires more machine resources and cost. But it also results in increased recall. Cost measures how many compute resources, and thus money, are consumed to run the transform.
        public var accuracyCostTradeoff: Swift.Double?
        /// The value to switch on or off to force the output to match the provided labels from users. If the value is True, the find matches transform forces the output to match the provided labels. The results override the normal conflation results. If the value is False, the find matches transform does not ensure all the labels provided are respected, and the results rely on the trained model. Note that setting this value to true may increase the conflation execution time.
        public var enforceProvidedLabels: Swift.Bool?
        /// The value selected when tuning your transform for a balance between precision and recall. A value of 0.5 means no preference; a value of 1.0 means a bias purely for precision, and a value of 0.0 means a bias for recall. Because this is a tradeoff, choosing values close to 1.0 means very low recall, and choosing values close to 0.0 results in very low precision. The precision metric indicates how often your model is correct when it predicts a match. The recall metric indicates that for an actual match, how often your model predicts the match.
        public var precisionRecallTradeoff: Swift.Double?
        /// The name of a column that uniquely identifies rows in the source table. Used to help identify matching records.
        public var primaryKeyColumnName: Swift.String?

        public init(
            accuracyCostTradeoff: Swift.Double? = nil,
            enforceProvidedLabels: Swift.Bool? = nil,
            precisionRecallTradeoff: Swift.Double? = nil,
            primaryKeyColumnName: Swift.String? = nil
        )
        {
            self.accuracyCostTradeoff = accuracyCostTradeoff
            self.enforceProvidedLabels = enforceProvidedLabels
            self.precisionRecallTradeoff = precisionRecallTradeoff
            self.primaryKeyColumnName = primaryKeyColumnName
        }
    }
}

extension GlueClientTypes {

    public enum TransformType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case findMatches
        case sdkUnknown(Swift.String)

        public static var allCases: [TransformType] {
            return [
                .findMatches
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .findMatches: return "FIND_MATCHES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The algorithm-specific parameters that are associated with the machine learning transform.
    public struct TransformParameters: Swift.Sendable {
        /// The parameters for the find matches algorithm.
        public var findMatchesParameters: GlueClientTypes.FindMatchesParameters?
        /// The type of machine learning transform. For information about the types of machine learning transforms, see [Creating Machine Learning Transforms](https://docs.aws.amazon.com/glue/latest/dg/add-job-machine-learning-transform.html).
        /// This member is required.
        public var transformType: GlueClientTypes.TransformType?

        public init(
            findMatchesParameters: GlueClientTypes.FindMatchesParameters? = nil,
            transformType: GlueClientTypes.TransformType? = nil
        )
        {
            self.findMatchesParameters = findMatchesParameters
            self.transformType = transformType
        }
    }
}

extension GlueClientTypes {

    public enum MLUserDataEncryptionModeString: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case ssekms
        case sdkUnknown(Swift.String)

        public static var allCases: [MLUserDataEncryptionModeString] {
            return [
                .disabled,
                .ssekms
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .ssekms: return "SSE-KMS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The encryption-at-rest settings of the transform that apply to accessing user data.
    public struct MLUserDataEncryption: Swift.Sendable {
        /// The ID for the customer-provided KMS key.
        public var kmsKeyId: Swift.String?
        /// The encryption mode applied to user data. Valid values are:
        ///
        /// * DISABLED: encryption is disabled
        ///
        /// * SSEKMS: use of server-side encryption with Key Management Service (SSE-KMS) for user data stored in Amazon S3.
        /// This member is required.
        public var mlUserDataEncryptionMode: GlueClientTypes.MLUserDataEncryptionModeString?

        public init(
            kmsKeyId: Swift.String? = nil,
            mlUserDataEncryptionMode: GlueClientTypes.MLUserDataEncryptionModeString? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.mlUserDataEncryptionMode = mlUserDataEncryptionMode
        }
    }
}

extension GlueClientTypes {

    /// The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS. Additionally, imported labels and trained transforms can now be encrypted using a customer provided KMS key.
    public struct TransformEncryption: Swift.Sendable {
        /// An MLUserDataEncryption object containing the encryption mode and customer-provided KMS key ID.
        public var mlUserDataEncryption: GlueClientTypes.MLUserDataEncryption?
        /// The name of the security configuration.
        public var taskRunSecurityConfigurationName: Swift.String?

        public init(
            mlUserDataEncryption: GlueClientTypes.MLUserDataEncryption? = nil,
            taskRunSecurityConfigurationName: Swift.String? = nil
        )
        {
            self.mlUserDataEncryption = mlUserDataEncryption
            self.taskRunSecurityConfigurationName = taskRunSecurityConfigurationName
        }
    }
}

public struct CreateMLTransformInput: Swift.Sendable {
    /// A description of the machine learning transform that is being defined. The default is an empty string.
    public var description: Swift.String?
    /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see [Glue Versions](https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions) in the developer guide.
    public var glueVersion: Swift.String?
    /// A list of Glue table definitions used by the transform.
    /// This member is required.
    public var inputRecordTables: [GlueClientTypes.GlueTable]?
    /// The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [Glue pricing page](https://aws.amazon.com/glue/pricing/). MaxCapacity is a mutually exclusive option with NumberOfWorkers and WorkerType.
    ///
    /// * If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set.
    ///
    /// * If MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set.
    ///
    /// * If WorkerType is set, then NumberOfWorkers is required (and vice versa).
    ///
    /// * MaxCapacity and NumberOfWorkers must both be at least 1.
    ///
    ///
    /// When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only. When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only.
    public var maxCapacity: Swift.Double?
    /// The maximum number of times to retry a task for this transform after a task run fails.
    public var maxRetries: Swift.Int?
    /// The unique name that you give the transform when you create it.
    /// This member is required.
    public var name: Swift.String?
    /// The number of workers of a defined workerType that are allocated when this task runs. If WorkerType is set, then NumberOfWorkers is required (and vice versa).
    public var numberOfWorkers: Swift.Int?
    /// The algorithmic parameters that are specific to the transform type used. Conditionally dependent on the transform type.
    /// This member is required.
    public var parameters: GlueClientTypes.TransformParameters?
    /// The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both Glue service role permissions to Glue resources, and Amazon S3 permissions required by the transform.
    ///
    /// * This role needs Glue service role permissions to allow access to resources in Glue. See [Attach a Policy to IAM Users That Access Glue](https://docs.aws.amazon.com/glue/latest/dg/attach-policy-iam-user.html).
    ///
    /// * This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.
    /// This member is required.
    public var role: Swift.String?
    /// The tags to use with this machine learning transform. You may use tags to limit access to the machine learning transform. For more information about tags in Glue, see [Amazon Web Services Tags in Glue](https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html) in the developer guide.
    public var tags: [Swift.String: Swift.String]?
    /// The timeout of the task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
    public var timeout: Swift.Int?
    /// The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.
    public var transformEncryption: GlueClientTypes.TransformEncryption?
    /// The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.
    ///
    /// * For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.
    ///
    /// * For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.
    ///
    /// * For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.
    ///
    ///
    /// MaxCapacity is a mutually exclusive option with NumberOfWorkers and WorkerType.
    ///
    /// * If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set.
    ///
    /// * If MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set.
    ///
    /// * If WorkerType is set, then NumberOfWorkers is required (and vice versa).
    ///
    /// * MaxCapacity and NumberOfWorkers must both be at least 1.
    public var workerType: GlueClientTypes.WorkerType?

    public init(
        description: Swift.String? = nil,
        glueVersion: Swift.String? = nil,
        inputRecordTables: [GlueClientTypes.GlueTable]? = nil,
        maxCapacity: Swift.Double? = nil,
        maxRetries: Swift.Int? = nil,
        name: Swift.String? = nil,
        numberOfWorkers: Swift.Int? = nil,
        parameters: GlueClientTypes.TransformParameters? = nil,
        role: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        timeout: Swift.Int? = nil,
        transformEncryption: GlueClientTypes.TransformEncryption? = nil,
        workerType: GlueClientTypes.WorkerType? = nil
    )
    {
        self.description = description
        self.glueVersion = glueVersion
        self.inputRecordTables = inputRecordTables
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.numberOfWorkers = numberOfWorkers
        self.parameters = parameters
        self.role = role
        self.tags = tags
        self.timeout = timeout
        self.transformEncryption = transformEncryption
        self.workerType = workerType
    }
}

public struct CreateMLTransformOutput: Swift.Sendable {
    /// A unique identifier that is generated for the transform.
    public var transformId: Swift.String?

    public init(
        transformId: Swift.String? = nil
    )
    {
        self.transformId = transformId
    }
}

public struct CreatePartitionInput: Swift.Sendable {
    /// The Amazon Web Services account ID of the catalog in which the partition is to be created.
    public var catalogId: Swift.String?
    /// The name of the metadata database in which the partition is to be created.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A PartitionInput structure defining the partition to be created.
    /// This member is required.
    public var partitionInput: GlueClientTypes.PartitionInput?
    /// The name of the metadata table in which the partition is to be created.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        partitionInput: GlueClientTypes.PartitionInput? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionInput = partitionInput
        self.tableName = tableName
    }
}

public struct CreatePartitionOutput: Swift.Sendable {

    public init() { }
}

extension GlueClientTypes {

    /// A structure for a partition index.
    public struct PartitionIndex: Swift.Sendable {
        /// The name of the partition index.
        /// This member is required.
        public var indexName: Swift.String?
        /// The keys for the partition index.
        /// This member is required.
        public var keys: [Swift.String]?

        public init(
            indexName: Swift.String? = nil,
            keys: [Swift.String]? = nil
        )
        {
            self.indexName = indexName
            self.keys = keys
        }
    }
}

public struct CreatePartitionIndexInput: Swift.Sendable {
    /// The catalog ID where the table resides.
    public var catalogId: Swift.String?
    /// Specifies the name of a database in which you want to create a partition index.
    /// This member is required.
    public var databaseName: Swift.String?
    /// Specifies a PartitionIndex structure to create a partition index in an existing table.
    /// This member is required.
    public var partitionIndex: GlueClientTypes.PartitionIndex?
    /// Specifies the name of a table in which you want to create a partition index.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        partitionIndex: GlueClientTypes.PartitionIndex? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionIndex = partitionIndex
        self.tableName = tableName
    }
}

public struct CreatePartitionIndexOutput: Swift.Sendable {

    public init() { }
}

public struct CreateRegistryInput: Swift.Sendable {
    /// A description of the registry. If description is not provided, there will not be any default value for this.
    public var description: Swift.String?
    /// Name of the registry to be created of max length of 255, and may only contain letters, numbers, hyphen, underscore, dollar sign, or hash mark. No whitespace.
    /// This member is required.
    public var registryName: Swift.String?
    /// Amazon Web Services tags that contain a key value pair and may be searched by console, command line, or API.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.registryName = registryName
        self.tags = tags
    }
}

public struct CreateRegistryOutput: Swift.Sendable {
    /// A description of the registry.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the newly created registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// The tags for the registry.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.tags = tags
    }
}

extension GlueClientTypes {

    public enum Compatibility: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case backward
        case backwardAll
        case disabled
        case forward
        case forwardAll
        case full
        case fullAll
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [Compatibility] {
            return [
                .backward,
                .backwardAll,
                .disabled,
                .forward,
                .forwardAll,
                .full,
                .fullAll,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .backward: return "BACKWARD"
            case .backwardAll: return "BACKWARD_ALL"
            case .disabled: return "DISABLED"
            case .forward: return "FORWARD"
            case .forwardAll: return "FORWARD_ALL"
            case .full: return "FULL"
            case .fullAll: return "FULL_ALL"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
    public struct RegistryId: Swift.Sendable {
        /// Arn of the registry to be updated. One of RegistryArn or RegistryName has to be provided.
        public var registryArn: Swift.String?
        /// Name of the registry. Used only for lookup. One of RegistryArn or RegistryName has to be provided.
        public var registryName: Swift.String?

        public init(
            registryArn: Swift.String? = nil,
            registryName: Swift.String? = nil
        )
        {
            self.registryArn = registryArn
            self.registryName = registryName
        }
    }
}

public struct CreateSchemaInput: Swift.Sendable {
    /// The compatibility mode of the schema. The possible values are:
    ///
    /// * NONE: No compatibility mode applies. You can use this choice in development scenarios or if you do not know the compatibility mode that you want to apply to schemas. Any new version added will be accepted without undergoing a compatibility check.
    ///
    /// * DISABLED: This compatibility choice prevents versioning for a particular schema. You can use this choice to prevent future versioning of a schema.
    ///
    /// * BACKWARD: This compatibility choice is recommended as it allows data receivers to read both the current and one previous schema version. This means that for instance, a new schema version cannot drop data fields or change the type of these fields, so they can't be read by readers using the previous version.
    ///
    /// * BACKWARD_ALL: This compatibility choice allows data receivers to read both the current and all previous schema versions. You can use this choice when you need to delete fields or add optional fields, and check compatibility against all previous schema versions.
    ///
    /// * FORWARD: This compatibility choice allows data receivers to read both the current and one next schema version, but not necessarily later versions. You can use this choice when you need to add fields or delete optional fields, but only check compatibility against the last schema version.
    ///
    /// * FORWARD_ALL: This compatibility choice allows data receivers to read written by producers of any new registered schema. You can use this choice when you need to add fields or delete optional fields, and check compatibility against all previous schema versions.
    ///
    /// * FULL: This compatibility choice allows data receivers to read data written by producers using the previous or next version of the schema, but not necessarily earlier or later versions. You can use this choice when you need to add or remove optional fields, but only check compatibility against the last schema version.
    ///
    /// * FULL_ALL: This compatibility choice allows data receivers to read data written by producers using all previous schema versions. You can use this choice when you need to add or remove optional fields, and check compatibility against all previous schema versions.
    public var compatibility: GlueClientTypes.Compatibility?
    /// The data format of the schema definition. Currently AVRO, JSON and PROTOBUF are supported.
    /// This member is required.
    public var dataFormat: GlueClientTypes.DataFormat?
    /// An optional description of the schema. If description is not provided, there will not be any automatic default value for this.
    public var description: Swift.String?
    /// This is a wrapper shape to contain the registry identity fields. If this is not provided, the default registry will be used. The ARN format for the same will be: arn:aws:glue:us-east-2::registry/default-registry:random-5-letter-id.
    public var registryId: GlueClientTypes.RegistryId?
    /// The schema definition using the DataFormat setting for SchemaName.
    public var schemaDefinition: Swift.String?
    /// Name of the schema to be created of max length of 255, and may only contain letters, numbers, hyphen, underscore, dollar sign, or hash mark. No whitespace.
    /// This member is required.
    public var schemaName: Swift.String?
    /// Amazon Web Services tags that contain a key value pair and may be searched by console, command line, or API. If specified, follows the Amazon Web Services tags-on-create pattern.
    public var tags: [Swift.String: Swift.String]?

    public init(
        compatibility: GlueClientTypes.Compatibility? = nil,
        dataFormat: GlueClientTypes.DataFormat? = nil,
        description: Swift.String? = nil,
        registryId: GlueClientTypes.RegistryId? = nil,
        schemaDefinition: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.compatibility = compatibility
        self.dataFormat = dataFormat
        self.description = description
        self.registryId = registryId
        self.schemaDefinition = schemaDefinition
        self.schemaName = schemaName
        self.tags = tags
    }
}

extension GlueClientTypes {

    public enum SchemaStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaStatus] {
            return [
                .available,
                .deleting,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum SchemaVersionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleting
        case failure
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaVersionStatus] {
            return [
                .available,
                .deleting,
                .failure,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .failure: return "FAILURE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateSchemaOutput: Swift.Sendable {
    /// The schema compatibility mode.
    public var compatibility: GlueClientTypes.Compatibility?
    /// The data format of the schema definition. Currently AVRO, JSON and PROTOBUF are supported.
    public var dataFormat: GlueClientTypes.DataFormat?
    /// A description of the schema if specified when created.
    public var description: Swift.String?
    /// The latest version of the schema associated with the returned schema definition.
    public var latestSchemaVersion: Swift.Int?
    /// The next version of the schema associated with the returned schema definition.
    public var nextSchemaVersion: Swift.Int?
    /// The Amazon Resource Name (ARN) of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// The Amazon Resource Name (ARN) of the schema.
    public var schemaArn: Swift.String?
    /// The version number of the checkpoint (the last time the compatibility mode was changed).
    public var schemaCheckpoint: Swift.Int?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The status of the schema.
    public var schemaStatus: GlueClientTypes.SchemaStatus?
    /// The unique identifier of the first schema version.
    public var schemaVersionId: Swift.String?
    /// The status of the first schema version created.
    public var schemaVersionStatus: GlueClientTypes.SchemaVersionStatus?
    /// The tags for the schema.
    public var tags: [Swift.String: Swift.String]?

    public init(
        compatibility: GlueClientTypes.Compatibility? = nil,
        dataFormat: GlueClientTypes.DataFormat? = nil,
        description: Swift.String? = nil,
        latestSchemaVersion: Swift.Int? = nil,
        nextSchemaVersion: Swift.Int? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaArn: Swift.String? = nil,
        schemaCheckpoint: Swift.Int? = nil,
        schemaName: Swift.String? = nil,
        schemaStatus: GlueClientTypes.SchemaStatus? = nil,
        schemaVersionId: Swift.String? = nil,
        schemaVersionStatus: GlueClientTypes.SchemaVersionStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.compatibility = compatibility
        self.dataFormat = dataFormat
        self.description = description
        self.latestSchemaVersion = latestSchemaVersion
        self.nextSchemaVersion = nextSchemaVersion
        self.registryArn = registryArn
        self.registryName = registryName
        self.schemaArn = schemaArn
        self.schemaCheckpoint = schemaCheckpoint
        self.schemaName = schemaName
        self.schemaStatus = schemaStatus
        self.schemaVersionId = schemaVersionId
        self.schemaVersionStatus = schemaVersionStatus
        self.tags = tags
    }
}

extension GlueClientTypes {

    /// Represents a directional edge in a directed acyclic graph (DAG).
    public struct CodeGenEdge: Swift.Sendable {
        /// The ID of the node at which the edge starts.
        /// This member is required.
        public var source: Swift.String?
        /// The ID of the node at which the edge ends.
        /// This member is required.
        public var target: Swift.String?
        /// The target of the edge.
        public var targetParameter: Swift.String?

        public init(
            source: Swift.String? = nil,
            target: Swift.String? = nil,
            targetParameter: Swift.String? = nil
        )
        {
            self.source = source
            self.target = target
            self.targetParameter = targetParameter
        }
    }
}

extension GlueClientTypes {

    /// An argument or property of a node.
    public struct CodeGenNodeArg: Swift.Sendable {
        /// The name of the argument or property.
        /// This member is required.
        public var name: Swift.String?
        /// True if the value is used as a parameter.
        public var param: Swift.Bool
        /// The value of the argument or property.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            param: Swift.Bool = false,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.param = param
            self.value = value
        }
    }
}

extension GlueClientTypes {

    /// Represents a node in a directed acyclic graph (DAG)
    public struct CodeGenNode: Swift.Sendable {
        /// Properties of the node, in the form of name-value pairs.
        /// This member is required.
        public var args: [GlueClientTypes.CodeGenNodeArg]?
        /// A node identifier that is unique within the node's graph.
        /// This member is required.
        public var id: Swift.String?
        /// The line number of the node.
        public var lineNumber: Swift.Int
        /// The type of node that this is.
        /// This member is required.
        public var nodeType: Swift.String?

        public init(
            args: [GlueClientTypes.CodeGenNodeArg]? = nil,
            id: Swift.String? = nil,
            lineNumber: Swift.Int = 0,
            nodeType: Swift.String? = nil
        )
        {
            self.args = args
            self.id = id
            self.lineNumber = lineNumber
            self.nodeType = nodeType
        }
    }
}

extension GlueClientTypes {

    public enum Language: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case python
        case scala
        case sdkUnknown(Swift.String)

        public static var allCases: [Language] {
            return [
                .python,
                .scala
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .python: return "PYTHON"
            case .scala: return "SCALA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateScriptInput: Swift.Sendable {
    /// A list of the edges in the DAG.
    public var dagEdges: [GlueClientTypes.CodeGenEdge]?
    /// A list of the nodes in the DAG.
    public var dagNodes: [GlueClientTypes.CodeGenNode]?
    /// The programming language of the resulting code from the DAG.
    public var language: GlueClientTypes.Language?

    public init(
        dagEdges: [GlueClientTypes.CodeGenEdge]? = nil,
        dagNodes: [GlueClientTypes.CodeGenNode]? = nil,
        language: GlueClientTypes.Language? = nil
    )
    {
        self.dagEdges = dagEdges
        self.dagNodes = dagNodes
        self.language = language
    }
}

public struct CreateScriptOutput: Swift.Sendable {
    /// The Python script generated from the DAG.
    public var pythonScript: Swift.String?
    /// The Scala code generated from the DAG.
    public var scalaCode: Swift.String?

    public init(
        pythonScript: Swift.String? = nil,
        scalaCode: Swift.String? = nil
    )
    {
        self.pythonScript = pythonScript
        self.scalaCode = scalaCode
    }
}

extension GlueClientTypes {

    public enum CloudWatchEncryptionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case ssekms
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchEncryptionMode] {
            return [
                .disabled,
                .ssekms
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .ssekms: return "SSE-KMS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies how Amazon CloudWatch data should be encrypted.
    public struct CloudWatchEncryption: Swift.Sendable {
        /// The encryption mode to use for CloudWatch data.
        public var cloudWatchEncryptionMode: GlueClientTypes.CloudWatchEncryptionMode?
        /// The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        public var kmsKeyArn: Swift.String?

        public init(
            cloudWatchEncryptionMode: GlueClientTypes.CloudWatchEncryptionMode? = nil,
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.cloudWatchEncryptionMode = cloudWatchEncryptionMode
            self.kmsKeyArn = kmsKeyArn
        }
    }
}

extension GlueClientTypes {

    public enum JobBookmarksEncryptionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csekms
        case disabled
        case sdkUnknown(Swift.String)

        public static var allCases: [JobBookmarksEncryptionMode] {
            return [
                .csekms,
                .disabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csekms: return "CSE-KMS"
            case .disabled: return "DISABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies how job bookmark data should be encrypted.
    public struct JobBookmarksEncryption: Swift.Sendable {
        /// The encryption mode to use for job bookmarks data.
        public var jobBookmarksEncryptionMode: GlueClientTypes.JobBookmarksEncryptionMode?
        /// The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        public var kmsKeyArn: Swift.String?

        public init(
            jobBookmarksEncryptionMode: GlueClientTypes.JobBookmarksEncryptionMode? = nil,
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.jobBookmarksEncryptionMode = jobBookmarksEncryptionMode
            self.kmsKeyArn = kmsKeyArn
        }
    }
}

extension GlueClientTypes {

    public enum S3EncryptionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case ssekms
        case sses3
        case sdkUnknown(Swift.String)

        public static var allCases: [S3EncryptionMode] {
            return [
                .disabled,
                .ssekms,
                .sses3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .ssekms: return "SSE-KMS"
            case .sses3: return "SSE-S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies how Amazon Simple Storage Service (Amazon S3) data should be encrypted.
    public struct S3Encryption: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        public var kmsKeyArn: Swift.String?
        /// The encryption mode to use for Amazon S3 data.
        public var s3EncryptionMode: GlueClientTypes.S3EncryptionMode?

        public init(
            kmsKeyArn: Swift.String? = nil,
            s3EncryptionMode: GlueClientTypes.S3EncryptionMode? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.s3EncryptionMode = s3EncryptionMode
        }
    }
}

extension GlueClientTypes {

    /// Specifies an encryption configuration.
    public struct EncryptionConfiguration: Swift.Sendable {
        /// The encryption configuration for Amazon CloudWatch.
        public var cloudWatchEncryption: GlueClientTypes.CloudWatchEncryption?
        /// The encryption configuration for job bookmarks.
        public var jobBookmarksEncryption: GlueClientTypes.JobBookmarksEncryption?
        /// The encryption configuration for Amazon Simple Storage Service (Amazon S3) data.
        public var s3Encryption: [GlueClientTypes.S3Encryption]?

        public init(
            cloudWatchEncryption: GlueClientTypes.CloudWatchEncryption? = nil,
            jobBookmarksEncryption: GlueClientTypes.JobBookmarksEncryption? = nil,
            s3Encryption: [GlueClientTypes.S3Encryption]? = nil
        )
        {
            self.cloudWatchEncryption = cloudWatchEncryption
            self.jobBookmarksEncryption = jobBookmarksEncryption
            self.s3Encryption = s3Encryption
        }
    }
}

public struct CreateSecurityConfigurationInput: Swift.Sendable {
    /// The encryption configuration for the new security configuration.
    /// This member is required.
    public var encryptionConfiguration: GlueClientTypes.EncryptionConfiguration?
    /// The name for the new security configuration.
    /// This member is required.
    public var name: Swift.String?

    public init(
        encryptionConfiguration: GlueClientTypes.EncryptionConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.encryptionConfiguration = encryptionConfiguration
        self.name = name
    }
}

public struct CreateSecurityConfigurationOutput: Swift.Sendable {
    /// The time at which the new security configuration was created.
    public var createdTimestamp: Foundation.Date?
    /// The name assigned to the new security configuration.
    public var name: Swift.String?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.name = name
    }
}

extension GlueClientTypes {

    /// The SessionCommand that runs the job.
    public struct SessionCommand: Swift.Sendable {
        /// Specifies the name of the SessionCommand. Can be 'glueetl' or 'gluestreaming'.
        public var name: Swift.String?
        /// Specifies the Python version. The Python version indicates the version supported for jobs of type Spark.
        public var pythonVersion: Swift.String?

        public init(
            name: Swift.String? = nil,
            pythonVersion: Swift.String? = nil
        )
        {
            self.name = name
            self.pythonVersion = pythonVersion
        }
    }
}

/// Request to create a new session.
public struct CreateSessionInput: Swift.Sendable {
    /// The SessionCommand that runs the job.
    /// This member is required.
    public var command: GlueClientTypes.SessionCommand?
    /// The number of connections to use for the session.
    public var connections: GlueClientTypes.ConnectionsList?
    /// A map array of key-value pairs. Max is 75 pairs.
    public var defaultArguments: [Swift.String: Swift.String]?
    /// The description of the session.
    public var description: Swift.String?
    /// The Glue version determines the versions of Apache Spark and Python that Glue supports. The GlueVersion must be greater than 2.0.
    public var glueVersion: Swift.String?
    /// The ID of the session request.
    /// This member is required.
    public var id: Swift.String?
    /// The number of minutes when idle before session times out. Default for Spark ETL jobs is value of Timeout. Consult the documentation for other job types.
    public var idleTimeout: Swift.Int?
    /// The number of Glue data processing units (DPUs) that can be allocated when the job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory.
    public var maxCapacity: Swift.Double?
    /// The number of workers of a defined WorkerType to use for the session.
    public var numberOfWorkers: Swift.Int?
    /// The origin of the request.
    public var requestOrigin: Swift.String?
    /// The IAM Role ARN
    /// This member is required.
    public var role: Swift.String?
    /// The name of the SecurityConfiguration structure to be used with the session
    public var securityConfiguration: Swift.String?
    /// The map of key value pairs (tags) belonging to the session.
    public var tags: [Swift.String: Swift.String]?
    /// The number of minutes before session times out. Default for Spark ETL jobs is 48 hours (2880 minutes), the maximum session lifetime for this job type. Consult the documentation for other job types.
    public var timeout: Swift.Int?
    /// The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, or G.8X for Spark jobs. Accepts the value Z.2X for Ray notebooks.
    ///
    /// * For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.
    ///
    /// * For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.
    ///
    /// * For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).
    ///
    /// * For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.
    ///
    /// * For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.
    public var workerType: GlueClientTypes.WorkerType?

    public init(
        command: GlueClientTypes.SessionCommand? = nil,
        connections: GlueClientTypes.ConnectionsList? = nil,
        defaultArguments: [Swift.String: Swift.String]? = nil,
        description: Swift.String? = nil,
        glueVersion: Swift.String? = nil,
        id: Swift.String? = nil,
        idleTimeout: Swift.Int? = nil,
        maxCapacity: Swift.Double? = nil,
        numberOfWorkers: Swift.Int? = nil,
        requestOrigin: Swift.String? = nil,
        role: Swift.String? = nil,
        securityConfiguration: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        timeout: Swift.Int? = nil,
        workerType: GlueClientTypes.WorkerType? = nil
    )
    {
        self.command = command
        self.connections = connections
        self.defaultArguments = defaultArguments
        self.description = description
        self.glueVersion = glueVersion
        self.id = id
        self.idleTimeout = idleTimeout
        self.maxCapacity = maxCapacity
        self.numberOfWorkers = numberOfWorkers
        self.requestOrigin = requestOrigin
        self.role = role
        self.securityConfiguration = securityConfiguration
        self.tags = tags
        self.timeout = timeout
        self.workerType = workerType
    }
}

extension GlueClientTypes {

    public enum SessionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case provisioning
        case ready
        case stopped
        case stopping
        case timeout
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionStatus] {
            return [
                .failed,
                .provisioning,
                .ready,
                .stopped,
                .stopping,
                .timeout
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .provisioning: return "PROVISIONING"
            case .ready: return "READY"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .timeout: return "TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The period in which a remote Spark runtime environment is running.
    public struct Session: Swift.Sendable {
        /// The command object.See SessionCommand.
        public var command: GlueClientTypes.SessionCommand?
        /// The date and time that this session is completed.
        public var completedOn: Foundation.Date?
        /// The number of connections used for the session.
        public var connections: GlueClientTypes.ConnectionsList?
        /// The time and date when the session was created.
        public var createdOn: Foundation.Date?
        /// A map array of key-value pairs. Max is 75 pairs.
        public var defaultArguments: [Swift.String: Swift.String]?
        /// The description of the session.
        public var description: Swift.String?
        /// The DPUs consumed by the session (formula: ExecutionTime * MaxCapacity).
        public var dpuSeconds: Swift.Double?
        /// The error message displayed during the session.
        public var errorMessage: Swift.String?
        /// The total time the session ran for.
        public var executionTime: Swift.Double?
        /// The Glue version determines the versions of Apache Spark and Python that Glue supports. The GlueVersion must be greater than 2.0.
        public var glueVersion: Swift.String?
        /// The ID of the session.
        public var id: Swift.String?
        /// The number of minutes when idle before the session times out.
        public var idleTimeout: Swift.Int?
        /// The number of Glue data processing units (DPUs) that can be allocated when the job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory.
        public var maxCapacity: Swift.Double?
        /// The number of workers of a defined WorkerType to use for the session.
        public var numberOfWorkers: Swift.Int?
        /// The name of an Glue usage profile associated with the session.
        public var profileName: Swift.String?
        /// The code execution progress of the session.
        public var progress: Swift.Double
        /// The name or Amazon Resource Name (ARN) of the IAM role associated with the Session.
        public var role: Swift.String?
        /// The name of the SecurityConfiguration structure to be used with the session.
        public var securityConfiguration: Swift.String?
        /// The session status.
        public var status: GlueClientTypes.SessionStatus?
        /// The type of predefined worker that is allocated when a session runs. Accepts a value of G.1X, G.2X, G.4X, or G.8X for Spark sessions. Accepts the value Z.2X for Ray sessions.
        public var workerType: GlueClientTypes.WorkerType?

        public init(
            command: GlueClientTypes.SessionCommand? = nil,
            completedOn: Foundation.Date? = nil,
            connections: GlueClientTypes.ConnectionsList? = nil,
            createdOn: Foundation.Date? = nil,
            defaultArguments: [Swift.String: Swift.String]? = nil,
            description: Swift.String? = nil,
            dpuSeconds: Swift.Double? = nil,
            errorMessage: Swift.String? = nil,
            executionTime: Swift.Double? = nil,
            glueVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            idleTimeout: Swift.Int? = nil,
            maxCapacity: Swift.Double? = nil,
            numberOfWorkers: Swift.Int? = nil,
            profileName: Swift.String? = nil,
            progress: Swift.Double = 0.0,
            role: Swift.String? = nil,
            securityConfiguration: Swift.String? = nil,
            status: GlueClientTypes.SessionStatus? = nil,
            workerType: GlueClientTypes.WorkerType? = nil
        )
        {
            self.command = command
            self.completedOn = completedOn
            self.connections = connections
            self.createdOn = createdOn
            self.defaultArguments = defaultArguments
            self.description = description
            self.dpuSeconds = dpuSeconds
            self.errorMessage = errorMessage
            self.executionTime = executionTime
            self.glueVersion = glueVersion
            self.id = id
            self.idleTimeout = idleTimeout
            self.maxCapacity = maxCapacity
            self.numberOfWorkers = numberOfWorkers
            self.profileName = profileName
            self.progress = progress
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.status = status
            self.workerType = workerType
        }
    }
}

public struct CreateSessionOutput: Swift.Sendable {
    /// Returns the session object in the response.
    public var session: GlueClientTypes.Session?

    public init(
        session: GlueClientTypes.Session? = nil
    )
    {
        self.session = session
    }
}

extension GlueClientTypes {

    public enum MetadataOperation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case create
        case sdkUnknown(Swift.String)

        public static var allCases: [MetadataOperation] {
            return [
                .create
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A structure that defines an Apache Iceberg metadata table to create in the catalog.
    public struct IcebergInput: Swift.Sendable {
        /// A required metadata operation. Can only be set to CREATE.
        /// This member is required.
        public var metadataOperation: GlueClientTypes.MetadataOperation?
        /// The table version for the Iceberg table. Defaults to 2.
        public var version: Swift.String?

        public init(
            metadataOperation: GlueClientTypes.MetadataOperation? = nil,
            version: Swift.String? = nil
        )
        {
            self.metadataOperation = metadataOperation
            self.version = version
        }
    }
}

extension GlueClientTypes {

    /// A structure representing an open format table.
    public struct OpenTableFormatInput: Swift.Sendable {
        /// Specifies an IcebergInput structure that defines an Apache Iceberg metadata table.
        public var icebergInput: GlueClientTypes.IcebergInput?

        public init(
            icebergInput: GlueClientTypes.IcebergInput? = nil
        )
        {
            self.icebergInput = icebergInput
        }
    }
}

extension GlueClientTypes {

    /// A structure that describes a target table for resource linking.
    public struct TableIdentifier: Swift.Sendable {
        /// The ID of the Data Catalog in which the table resides.
        public var catalogId: Swift.String?
        /// The name of the catalog database that contains the target table.
        public var databaseName: Swift.String?
        /// The name of the target table.
        public var name: Swift.String?
        /// Region of the target table.
        public var region: Swift.String?

        public init(
            catalogId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.name = name
            self.region = region
        }
    }
}

extension GlueClientTypes {

    public enum ViewDialect: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case athena
        case redshift
        case spark
        case sdkUnknown(Swift.String)

        public static var allCases: [ViewDialect] {
            return [
                .athena,
                .redshift,
                .spark
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .athena: return "ATHENA"
            case .redshift: return "REDSHIFT"
            case .spark: return "SPARK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A structure containing details of a representation to update or create a Lake Formation view.
    public struct ViewRepresentationInput: Swift.Sendable {
        /// A parameter that specifies the engine type of a specific representation.
        public var dialect: GlueClientTypes.ViewDialect?
        /// A parameter that specifies the version of the engine of a specific representation.
        public var dialectVersion: Swift.String?
        /// The name of the connection to be used to validate the specific representation of the view.
        public var validationConnection: Swift.String?
        /// A string that represents the SQL query that describes the view with expanded resource ARNs
        public var viewExpandedText: Swift.String?
        /// A string that represents the original SQL query that describes the view.
        public var viewOriginalText: Swift.String?

        public init(
            dialect: GlueClientTypes.ViewDialect? = nil,
            dialectVersion: Swift.String? = nil,
            validationConnection: Swift.String? = nil,
            viewExpandedText: Swift.String? = nil,
            viewOriginalText: Swift.String? = nil
        )
        {
            self.dialect = dialect
            self.dialectVersion = dialectVersion
            self.validationConnection = validationConnection
            self.viewExpandedText = viewExpandedText
            self.viewOriginalText = viewOriginalText
        }
    }
}

extension GlueClientTypes {

    /// A structure containing details for creating or updating an Glue view.
    public struct ViewDefinitionInput: Swift.Sendable {
        /// The definer of a view in SQL.
        public var definer: Swift.String?
        /// You can set this flag as true to instruct the engine not to push user-provided operations into the logical plan of the view during query planning. However, setting this flag does not guarantee that the engine will comply. Refer to the engine's documentation to understand the guarantees provided, if any.
        public var isProtected: Swift.Bool?
        /// A list of structures that contains the dialect of the view, and the query that defines the view.
        public var representations: [GlueClientTypes.ViewRepresentationInput]?
        /// A list of base table ARNs that make up the view.
        public var subObjects: [Swift.String]?

        public init(
            definer: Swift.String? = nil,
            isProtected: Swift.Bool? = nil,
            representations: [GlueClientTypes.ViewRepresentationInput]? = nil,
            subObjects: [Swift.String]? = nil
        )
        {
            self.definer = definer
            self.isProtected = isProtected
            self.representations = representations
            self.subObjects = subObjects
        }
    }
}

extension GlueClientTypes {

    /// A structure used to define a table.
    public struct TableInput: Swift.Sendable {
        /// A description of the table.
        public var description: Swift.String?
        /// The last time that the table was accessed.
        public var lastAccessTime: Foundation.Date?
        /// The last time that column statistics were computed for this table.
        public var lastAnalyzedTime: Foundation.Date?
        /// The table name. For Hive compatibility, this is folded to lowercase when it is stored.
        /// This member is required.
        public var name: Swift.String?
        /// The table owner. Included for Apache Hive compatibility. Not used in the normal course of Glue operations.
        public var owner: Swift.String?
        /// These key-value pairs define properties associated with the table.
        public var parameters: [Swift.String: Swift.String]?
        /// A list of columns by which the table is partitioned. Only primitive types are supported as partition keys. When you create a table used by Amazon Athena, and you do not specify any partitionKeys, you must at least set the value of partitionKeys to an empty list. For example: "PartitionKeys": []
        public var partitionKeys: [GlueClientTypes.Column]?
        /// The retention time for this table.
        public var retention: Swift.Int
        /// A storage descriptor containing information about the physical storage of this table.
        public var storageDescriptor: GlueClientTypes.StorageDescriptor?
        /// The type of this table. Glue will create tables with the EXTERNAL_TABLE type. Other services, such as Athena, may create tables with additional table types. Glue related table types: EXTERNAL_TABLE Hive compatible attribute - indicates a non-Hive managed table. GOVERNED Used by Lake Formation. The Glue Data Catalog understands GOVERNED.
        public var tableType: Swift.String?
        /// A TableIdentifier structure that describes a target table for resource linking.
        public var targetTable: GlueClientTypes.TableIdentifier?
        /// A structure that contains all the information that defines the view, including the dialect or dialects for the view, and the query.
        public var viewDefinition: GlueClientTypes.ViewDefinitionInput?
        /// Included for Apache Hive compatibility. Not used in the normal course of Glue operations.
        public var viewExpandedText: Swift.String?
        /// Included for Apache Hive compatibility. Not used in the normal course of Glue operations. If the table is a VIRTUAL_VIEW, certain Athena configuration encoded in base64.
        public var viewOriginalText: Swift.String?

        public init(
            description: Swift.String? = nil,
            lastAccessTime: Foundation.Date? = nil,
            lastAnalyzedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            partitionKeys: [GlueClientTypes.Column]? = nil,
            retention: Swift.Int = 0,
            storageDescriptor: GlueClientTypes.StorageDescriptor? = nil,
            tableType: Swift.String? = nil,
            targetTable: GlueClientTypes.TableIdentifier? = nil,
            viewDefinition: GlueClientTypes.ViewDefinitionInput? = nil,
            viewExpandedText: Swift.String? = nil,
            viewOriginalText: Swift.String? = nil
        )
        {
            self.description = description
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.partitionKeys = partitionKeys
            self.retention = retention
            self.storageDescriptor = storageDescriptor
            self.tableType = tableType
            self.targetTable = targetTable
            self.viewDefinition = viewDefinition
            self.viewExpandedText = viewExpandedText
            self.viewOriginalText = viewOriginalText
        }
    }
}

public struct CreateTableInput: Swift.Sendable {
    /// The ID of the Data Catalog in which to create the Table. If none is supplied, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The catalog database in which to create the new table. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var databaseName: Swift.String?
    /// Specifies an OpenTableFormatInput structure when creating an open format table.
    public var openTableFormatInput: GlueClientTypes.OpenTableFormatInput?
    /// A list of partition indexes, PartitionIndex structures, to create in the table.
    public var partitionIndexes: [GlueClientTypes.PartitionIndex]?
    /// The TableInput object that defines the metadata table to create in the catalog.
    /// This member is required.
    public var tableInput: GlueClientTypes.TableInput?
    /// The ID of the transaction.
    public var transactionId: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        openTableFormatInput: GlueClientTypes.OpenTableFormatInput? = nil,
        partitionIndexes: [GlueClientTypes.PartitionIndex]? = nil,
        tableInput: GlueClientTypes.TableInput? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.openTableFormatInput = openTableFormatInput
        self.partitionIndexes = partitionIndexes
        self.tableInput = tableInput
        self.transactionId = transactionId
    }
}

public struct CreateTableOutput: Swift.Sendable {

    public init() { }
}

public struct CreateTableOptimizerInput: Swift.Sendable {
    /// The Catalog ID of the table.
    /// This member is required.
    public var catalogId: Swift.String?
    /// The name of the database in the catalog in which the table resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?
    /// A TableOptimizerConfiguration object representing the configuration of a table optimizer.
    /// This member is required.
    public var tableOptimizerConfiguration: GlueClientTypes.TableOptimizerConfiguration?
    /// The type of table optimizer. Currently, the only valid value is compaction.
    /// This member is required.
    public var type: GlueClientTypes.TableOptimizerType?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil,
        tableOptimizerConfiguration: GlueClientTypes.TableOptimizerConfiguration? = nil,
        type: GlueClientTypes.TableOptimizerType? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tableName = tableName
        self.tableOptimizerConfiguration = tableOptimizerConfiguration
        self.type = type
    }
}

public struct CreateTableOptimizerOutput: Swift.Sendable {

    public init() { }
}

public struct CreateTriggerInput: Swift.Sendable {
    /// The actions initiated by this trigger when it fires.
    /// This member is required.
    public var actions: [GlueClientTypes.Action]?
    /// A description of the new trigger.
    public var description: Swift.String?
    /// Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.
    public var eventBatchingCondition: GlueClientTypes.EventBatchingCondition?
    /// The name of the trigger.
    /// This member is required.
    public var name: Swift.String?
    /// A predicate to specify when the new trigger should fire. This field is required when the trigger type is CONDITIONAL.
    public var predicate: GlueClientTypes.Predicate?
    /// A cron expression used to specify the schedule (see [Time-Based Schedules for Jobs and Crawlers](https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html). For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *). This field is required when the trigger type is SCHEDULED.
    public var schedule: Swift.String?
    /// Set to true to start SCHEDULED and CONDITIONAL triggers when created. True is not supported for ON_DEMAND triggers.
    public var startOnCreation: Swift.Bool?
    /// The tags to use with this trigger. You may use tags to limit access to the trigger. For more information about tags in Glue, see [Amazon Web Services Tags in Glue](https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html) in the developer guide.
    public var tags: [Swift.String: Swift.String]?
    /// The type of the new trigger.
    /// This member is required.
    public var type: GlueClientTypes.TriggerType?
    /// The name of the workflow associated with the trigger.
    public var workflowName: Swift.String?

    public init(
        actions: [GlueClientTypes.Action]? = nil,
        description: Swift.String? = nil,
        eventBatchingCondition: GlueClientTypes.EventBatchingCondition? = nil,
        name: Swift.String? = nil,
        predicate: GlueClientTypes.Predicate? = nil,
        schedule: Swift.String? = nil,
        startOnCreation: Swift.Bool? = false,
        tags: [Swift.String: Swift.String]? = nil,
        type: GlueClientTypes.TriggerType? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.eventBatchingCondition = eventBatchingCondition
        self.name = name
        self.predicate = predicate
        self.schedule = schedule
        self.startOnCreation = startOnCreation
        self.tags = tags
        self.type = type
        self.workflowName = workflowName
    }
}

public struct CreateTriggerOutput: Swift.Sendable {
    /// The name of the trigger.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

/// The operation is not available in the region.
public struct OperationNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotSupportedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GlueClientTypes {

    /// Specifies the values that an admin sets for each job or session parameter configured in a Glue usage profile.
    public struct ConfigurationObject: Swift.Sendable {
        /// A list of allowed values for the parameter.
        public var allowedValues: [Swift.String]?
        /// A default value for the parameter.
        public var defaultValue: Swift.String?
        /// A maximum allowed value for the parameter.
        public var maxValue: Swift.String?
        /// A minimum allowed value for the parameter.
        public var minValue: Swift.String?

        public init(
            allowedValues: [Swift.String]? = nil,
            defaultValue: Swift.String? = nil,
            maxValue: Swift.String? = nil,
            minValue: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
            self.maxValue = maxValue
            self.minValue = minValue
        }
    }
}

extension GlueClientTypes {

    /// Specifies the job and session values that an admin configures in an Glue usage profile.
    public struct ProfileConfiguration: Swift.Sendable {
        /// A key-value map of configuration parameters for Glue jobs.
        public var jobConfiguration: [Swift.String: GlueClientTypes.ConfigurationObject]?
        /// A key-value map of configuration parameters for Glue sessions.
        public var sessionConfiguration: [Swift.String: GlueClientTypes.ConfigurationObject]?

        public init(
            jobConfiguration: [Swift.String: GlueClientTypes.ConfigurationObject]? = nil,
            sessionConfiguration: [Swift.String: GlueClientTypes.ConfigurationObject]? = nil
        )
        {
            self.jobConfiguration = jobConfiguration
            self.sessionConfiguration = sessionConfiguration
        }
    }
}

public struct CreateUsageProfileInput: Swift.Sendable {
    /// A ProfileConfiguration object specifying the job and session values for the profile.
    /// This member is required.
    public var configuration: GlueClientTypes.ProfileConfiguration?
    /// A description of the usage profile.
    public var description: Swift.String?
    /// The name of the usage profile.
    /// This member is required.
    public var name: Swift.String?
    /// A list of tags applied to the usage profile.
    public var tags: [Swift.String: Swift.String]?

    public init(
        configuration: GlueClientTypes.ProfileConfiguration? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.configuration = configuration
        self.description = description
        self.name = name
        self.tags = tags
    }
}

public struct CreateUsageProfileOutput: Swift.Sendable {
    /// The name of the usage profile that was created.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension GlueClientTypes {

    public enum PrincipalType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case group
        case role
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalType] {
            return [
                .group,
                .role,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .role: return "ROLE"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case archive
        case file
        case jar
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .archive,
                .file,
                .jar
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .archive: return "ARCHIVE"
            case .file: return "FILE"
            case .jar: return "JAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The URIs for function resources.
    public struct ResourceUri: Swift.Sendable {
        /// The type of the resource.
        public var resourceType: GlueClientTypes.ResourceType?
        /// The URI for accessing the resource.
        public var uri: Swift.String?

        public init(
            resourceType: GlueClientTypes.ResourceType? = nil,
            uri: Swift.String? = nil
        )
        {
            self.resourceType = resourceType
            self.uri = uri
        }
    }
}

extension GlueClientTypes {

    /// A structure used to create or update a user-defined function.
    public struct UserDefinedFunctionInput: Swift.Sendable {
        /// The Java class that contains the function code.
        public var className: Swift.String?
        /// The name of the function.
        public var functionName: Swift.String?
        /// The owner of the function.
        public var ownerName: Swift.String?
        /// The owner type.
        public var ownerType: GlueClientTypes.PrincipalType?
        /// The resource URIs for the function.
        public var resourceUris: [GlueClientTypes.ResourceUri]?

        public init(
            className: Swift.String? = nil,
            functionName: Swift.String? = nil,
            ownerName: Swift.String? = nil,
            ownerType: GlueClientTypes.PrincipalType? = nil,
            resourceUris: [GlueClientTypes.ResourceUri]? = nil
        )
        {
            self.className = className
            self.functionName = functionName
            self.ownerName = ownerName
            self.ownerType = ownerType
            self.resourceUris = resourceUris
        }
    }
}

public struct CreateUserDefinedFunctionInput: Swift.Sendable {
    /// The ID of the Data Catalog in which to create the function. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the catalog database in which to create the function.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A FunctionInput object that defines the function to create in the Data Catalog.
    /// This member is required.
    public var functionInput: GlueClientTypes.UserDefinedFunctionInput?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        functionInput: GlueClientTypes.UserDefinedFunctionInput? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.functionInput = functionInput
    }
}

public struct CreateUserDefinedFunctionOutput: Swift.Sendable {

    public init() { }
}

public struct CreateWorkflowInput: Swift.Sendable {
    /// A collection of properties to be used as part of each execution of the workflow.
    public var defaultRunProperties: [Swift.String: Swift.String]?
    /// A description of the workflow.
    public var description: Swift.String?
    /// You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.
    public var maxConcurrentRuns: Swift.Int?
    /// The name to be assigned to the workflow. It should be unique within your account.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to be used with this workflow.
    public var tags: [Swift.String: Swift.String]?

    public init(
        defaultRunProperties: [Swift.String: Swift.String]? = nil,
        description: Swift.String? = nil,
        maxConcurrentRuns: Swift.Int? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.defaultRunProperties = defaultRunProperties
        self.description = description
        self.maxConcurrentRuns = maxConcurrentRuns
        self.name = name
        self.tags = tags
    }
}

public struct CreateWorkflowOutput: Swift.Sendable {
    /// The name of the workflow which was provided as part of the request.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteBlueprintInput: Swift.Sendable {
    /// The name of the blueprint to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteBlueprintOutput: Swift.Sendable {
    /// Returns the name of the blueprint that was deleted.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteClassifierInput: Swift.Sendable {
    /// Name of the classifier to remove.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteClassifierOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteColumnStatisticsForPartitionInput: Swift.Sendable {
    /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// Name of the column.
    /// This member is required.
    public var columnName: Swift.String?
    /// The name of the catalog database where the partitions reside.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A list of partition values identifying the partition.
    /// This member is required.
    public var partitionValues: [Swift.String]?
    /// The name of the partitions' table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        columnName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        partitionValues: [Swift.String]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.columnName = columnName
        self.databaseName = databaseName
        self.partitionValues = partitionValues
        self.tableName = tableName
    }
}

public struct DeleteColumnStatisticsForPartitionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteColumnStatisticsForTableInput: Swift.Sendable {
    /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the column.
    /// This member is required.
    public var columnName: Swift.String?
    /// The name of the catalog database where the partitions reside.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the partitions' table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        columnName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.columnName = columnName
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

public struct DeleteColumnStatisticsForTableOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteColumnStatisticsTaskSettingsInput: Swift.Sendable {
    /// The name of the database where the table resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table for which to delete column statistics.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

public struct DeleteColumnStatisticsTaskSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteConnectionInput: Swift.Sendable {
    /// The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the connection to delete.
    /// This member is required.
    public var connectionName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        connectionName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.connectionName = connectionName
    }
}

public struct DeleteConnectionOutput: Swift.Sendable {

    public init() { }
}

/// The operation cannot be performed because the crawler is already running.
public struct CrawlerRunningException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CrawlerRunningException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified scheduler is transitioning.
public struct SchedulerTransitioningException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SchedulerTransitioningException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteCrawlerInput: Swift.Sendable {
    /// The name of the crawler to remove.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteCrawlerOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCustomEntityTypeInput: Swift.Sendable {
    /// The name of the custom pattern that you want to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteCustomEntityTypeOutput: Swift.Sendable {
    /// The name of the custom pattern you deleted.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteDatabaseInput: Swift.Sendable {
    /// The ID of the Data Catalog in which the database resides. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the database to delete. For Hive compatibility, this must be all lowercase.
    /// This member is required.
    public var name: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.name = name
    }
}

public struct DeleteDatabaseOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDataQualityRulesetInput: Swift.Sendable {
    /// A name for the data quality ruleset.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteDataQualityRulesetOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDevEndpointInput: Swift.Sendable {
    /// The name of the DevEndpoint.
    /// This member is required.
    public var endpointName: Swift.String?

    public init(
        endpointName: Swift.String? = nil
    )
    {
        self.endpointName = endpointName
    }
}

public struct DeleteDevEndpointOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteJobInput: Swift.Sendable {
    /// The name of the job definition to delete.
    /// This member is required.
    public var jobName: Swift.String?

    public init(
        jobName: Swift.String? = nil
    )
    {
        self.jobName = jobName
    }
}

public struct DeleteJobOutput: Swift.Sendable {
    /// The name of the job definition that was deleted.
    public var jobName: Swift.String?

    public init(
        jobName: Swift.String? = nil
    )
    {
        self.jobName = jobName
    }
}

public struct DeleteMLTransformInput: Swift.Sendable {
    /// The unique identifier of the transform to delete.
    /// This member is required.
    public var transformId: Swift.String?

    public init(
        transformId: Swift.String? = nil
    )
    {
        self.transformId = transformId
    }
}

public struct DeleteMLTransformOutput: Swift.Sendable {
    /// The unique identifier of the transform that was deleted.
    public var transformId: Swift.String?

    public init(
        transformId: Swift.String? = nil
    )
    {
        self.transformId = transformId
    }
}

public struct DeletePartitionInput: Swift.Sendable {
    /// The ID of the Data Catalog where the partition to be deleted resides. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the catalog database in which the table in question resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The values that define the partition.
    /// This member is required.
    public var partitionValues: [Swift.String]?
    /// The name of the table that contains the partition to be deleted.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        partitionValues: [Swift.String]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionValues = partitionValues
        self.tableName = tableName
    }
}

public struct DeletePartitionOutput: Swift.Sendable {

    public init() { }
}

/// The CreatePartitions API was called on a table that has indexes enabled.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeletePartitionIndexInput: Swift.Sendable {
    /// The catalog ID where the table resides.
    public var catalogId: Swift.String?
    /// Specifies the name of a database from which you want to delete a partition index.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the partition index to be deleted.
    /// This member is required.
    public var indexName: Swift.String?
    /// Specifies the name of a table from which you want to delete a partition index.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        indexName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.indexName = indexName
        self.tableName = tableName
    }
}

public struct DeletePartitionIndexOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRegistryInput: Swift.Sendable {
    /// This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
    /// This member is required.
    public var registryId: GlueClientTypes.RegistryId?

    public init(
        registryId: GlueClientTypes.RegistryId? = nil
    )
    {
        self.registryId = registryId
    }
}

extension GlueClientTypes {

    public enum RegistryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistryStatus] {
            return [
                .available,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteRegistryOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the registry being deleted.
    public var registryArn: Swift.String?
    /// The name of the registry being deleted.
    public var registryName: Swift.String?
    /// The status of the registry. A successful operation will return the Deleting status.
    public var status: GlueClientTypes.RegistryStatus?

    public init(
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        status: GlueClientTypes.RegistryStatus? = nil
    )
    {
        self.registryArn = registryArn
        self.registryName = registryName
        self.status = status
    }
}

/// A specified condition was not satisfied.
public struct ConditionCheckFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConditionCheckFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteResourcePolicyInput: Swift.Sendable {
    /// The hash value returned when this policy was set.
    public var policyHashCondition: Swift.String?
    /// The ARN of the Glue resource for the resource policy to be deleted.
    public var resourceArn: Swift.String?

    public init(
        policyHashCondition: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policyHashCondition = policyHashCondition
        self.resourceArn = resourceArn
    }
}

public struct DeleteResourcePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSchemaInput: Swift.Sendable {
    /// This is a wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
    /// This member is required.
    public var schemaId: GlueClientTypes.SchemaId?

    public init(
        schemaId: GlueClientTypes.SchemaId? = nil
    )
    {
        self.schemaId = schemaId
    }
}

public struct DeleteSchemaOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the schema being deleted.
    public var schemaArn: Swift.String?
    /// The name of the schema being deleted.
    public var schemaName: Swift.String?
    /// The status of the schema.
    public var status: GlueClientTypes.SchemaStatus?

    public init(
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        status: GlueClientTypes.SchemaStatus? = nil
    )
    {
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.status = status
    }
}

public struct DeleteSchemaVersionsInput: Swift.Sendable {
    /// This is a wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
    /// This member is required.
    public var schemaId: GlueClientTypes.SchemaId?
    /// A version range may be supplied which may be of the format:
    ///
    /// * a single version number, 5
    ///
    /// * a range, 5-8 : deletes versions 5, 6, 7, 8
    /// This member is required.
    public var versions: Swift.String?

    public init(
        schemaId: GlueClientTypes.SchemaId? = nil,
        versions: Swift.String? = nil
    )
    {
        self.schemaId = schemaId
        self.versions = versions
    }
}

extension GlueClientTypes {

    /// An object containing error details.
    public struct ErrorDetails: Swift.Sendable {
        /// The error code for an error.
        public var errorCode: Swift.String?
        /// The error message for an error.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

extension GlueClientTypes {

    /// An object that contains the error details for an operation on a schema version.
    public struct SchemaVersionErrorItem: Swift.Sendable {
        /// The details of the error for the schema version.
        public var errorDetails: GlueClientTypes.ErrorDetails?
        /// The version number of the schema.
        public var versionNumber: Swift.Int?

        public init(
            errorDetails: GlueClientTypes.ErrorDetails? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.errorDetails = errorDetails
            self.versionNumber = versionNumber
        }
    }
}

public struct DeleteSchemaVersionsOutput: Swift.Sendable {
    /// A list of SchemaVersionErrorItem objects, each containing an error and schema version.
    public var schemaVersionErrors: [GlueClientTypes.SchemaVersionErrorItem]?

    public init(
        schemaVersionErrors: [GlueClientTypes.SchemaVersionErrorItem]? = nil
    )
    {
        self.schemaVersionErrors = schemaVersionErrors
    }
}

public struct DeleteSecurityConfigurationInput: Swift.Sendable {
    /// The name of the security configuration to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteSecurityConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSessionInput: Swift.Sendable {
    /// The ID of the session to be deleted.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the origin of the delete session request.
    public var requestOrigin: Swift.String?

    public init(
        id: Swift.String? = nil,
        requestOrigin: Swift.String? = nil
    )
    {
        self.id = id
        self.requestOrigin = requestOrigin
    }
}

public struct DeleteSessionOutput: Swift.Sendable {
    /// Returns the ID of the deleted session.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteTableInput: Swift.Sendable {
    /// The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the catalog database in which the table resides. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table to be deleted. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var name: Swift.String?
    /// The transaction ID at which to delete the table contents.
    public var transactionId: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        name: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.name = name
        self.transactionId = transactionId
    }
}

public struct DeleteTableOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTableOptimizerInput: Swift.Sendable {
    /// The Catalog ID of the table.
    /// This member is required.
    public var catalogId: Swift.String?
    /// The name of the database in the catalog in which the table resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?
    /// The type of table optimizer.
    /// This member is required.
    public var type: GlueClientTypes.TableOptimizerType?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil,
        type: GlueClientTypes.TableOptimizerType? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tableName = tableName
        self.type = type
    }
}

public struct DeleteTableOptimizerOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTableVersionInput: Swift.Sendable {
    /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var tableName: Swift.String?
    /// The ID of the table version to be deleted. A VersionID is a string representation of an integer. Each version is incremented by 1.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tableName = tableName
        self.versionId = versionId
    }
}

public struct DeleteTableVersionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTriggerInput: Swift.Sendable {
    /// The name of the trigger to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteTriggerOutput: Swift.Sendable {
    /// The name of the trigger that was deleted.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteUsageProfileInput: Swift.Sendable {
    /// The name of the usage profile to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteUsageProfileOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteUserDefinedFunctionInput: Swift.Sendable {
    /// The ID of the Data Catalog where the function to be deleted is located. If none is supplied, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the catalog database where the function is located.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the function definition to be deleted.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.functionName = functionName
    }
}

public struct DeleteUserDefinedFunctionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteWorkflowInput: Swift.Sendable {
    /// Name of the workflow to be deleted.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteWorkflowOutput: Swift.Sendable {
    /// Name of the workflow specified in input.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct GetBlueprintInput: Swift.Sendable {
    /// Specifies whether or not to include the blueprint in the response.
    public var includeBlueprint: Swift.Bool?
    /// Specifies whether or not to include the parameter specification.
    public var includeParameterSpec: Swift.Bool?
    /// The name of the blueprint.
    /// This member is required.
    public var name: Swift.String?

    public init(
        includeBlueprint: Swift.Bool? = nil,
        includeParameterSpec: Swift.Bool? = nil,
        name: Swift.String? = nil
    )
    {
        self.includeBlueprint = includeBlueprint
        self.includeParameterSpec = includeParameterSpec
        self.name = name
    }
}

public struct GetBlueprintOutput: Swift.Sendable {
    /// Returns a Blueprint object.
    public var blueprint: GlueClientTypes.Blueprint?

    public init(
        blueprint: GlueClientTypes.Blueprint? = nil
    )
    {
        self.blueprint = blueprint
    }
}

public struct GetBlueprintRunInput: Swift.Sendable {
    /// The name of the blueprint.
    /// This member is required.
    public var blueprintName: Swift.String?
    /// The run ID for the blueprint run you want to retrieve.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        blueprintName: Swift.String? = nil,
        runId: Swift.String? = nil
    )
    {
        self.blueprintName = blueprintName
        self.runId = runId
    }
}

extension GlueClientTypes {

    public enum BlueprintRunState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case rollingBack
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [BlueprintRunState] {
            return [
                .failed,
                .rollingBack,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .rollingBack: return "ROLLING_BACK"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The details of a blueprint run.
    public struct BlueprintRun: Swift.Sendable {
        /// The name of the blueprint.
        public var blueprintName: Swift.String?
        /// The date and time that the blueprint run completed.
        public var completedOn: Foundation.Date?
        /// Indicates any errors that are seen while running the blueprint.
        public var errorMessage: Swift.String?
        /// The blueprint parameters as a string. You will have to provide a value for each key that is required from the parameter spec that is defined in the Blueprint$ParameterSpec.
        public var parameters: Swift.String?
        /// The role ARN. This role will be assumed by the Glue service and will be used to create the workflow and other entities of a workflow.
        public var roleArn: Swift.String?
        /// If there are any errors while creating the entities of a workflow, we try to roll back the created entities until that point and delete them. This attribute indicates the errors seen while trying to delete the entities that are created.
        public var rollbackErrorMessage: Swift.String?
        /// The run ID for this blueprint run.
        public var runId: Swift.String?
        /// The date and time that the blueprint run started.
        public var startedOn: Foundation.Date?
        /// The state of the blueprint run. Possible values are:
        ///
        /// * Running — The blueprint run is in progress.
        ///
        /// * Succeeded — The blueprint run completed successfully.
        ///
        /// * Failed — The blueprint run failed and rollback is complete.
        ///
        /// * Rolling Back — The blueprint run failed and rollback is in progress.
        public var state: GlueClientTypes.BlueprintRunState?
        /// The name of a workflow that is created as a result of a successful blueprint run. If a blueprint run has an error, there will not be a workflow created.
        public var workflowName: Swift.String?

        public init(
            blueprintName: Swift.String? = nil,
            completedOn: Foundation.Date? = nil,
            errorMessage: Swift.String? = nil,
            parameters: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            rollbackErrorMessage: Swift.String? = nil,
            runId: Swift.String? = nil,
            startedOn: Foundation.Date? = nil,
            state: GlueClientTypes.BlueprintRunState? = nil,
            workflowName: Swift.String? = nil
        )
        {
            self.blueprintName = blueprintName
            self.completedOn = completedOn
            self.errorMessage = errorMessage
            self.parameters = parameters
            self.roleArn = roleArn
            self.rollbackErrorMessage = rollbackErrorMessage
            self.runId = runId
            self.startedOn = startedOn
            self.state = state
            self.workflowName = workflowName
        }
    }
}

public struct GetBlueprintRunOutput: Swift.Sendable {
    /// Returns a BlueprintRun object.
    public var blueprintRun: GlueClientTypes.BlueprintRun?

    public init(
        blueprintRun: GlueClientTypes.BlueprintRun? = nil
    )
    {
        self.blueprintRun = blueprintRun
    }
}

public struct GetBlueprintRunsInput: Swift.Sendable {
    /// The name of the blueprint.
    /// This member is required.
    public var blueprintName: Swift.String?
    /// The maximum size of a list to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation request.
    public var nextToken: Swift.String?

    public init(
        blueprintName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.blueprintName = blueprintName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetBlueprintRunsOutput: Swift.Sendable {
    /// Returns a list of BlueprintRun objects.
    public var blueprintRuns: [GlueClientTypes.BlueprintRun]?
    /// A continuation token, if not all blueprint runs have been returned.
    public var nextToken: Swift.String?

    public init(
        blueprintRuns: [GlueClientTypes.BlueprintRun]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.blueprintRuns = blueprintRuns
        self.nextToken = nextToken
    }
}

public struct GetCatalogImportStatusInput: Swift.Sendable {
    /// The ID of the catalog to migrate. Currently, this should be the Amazon Web Services account ID.
    public var catalogId: Swift.String?

    public init(
        catalogId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
    }
}

extension GlueClientTypes {

    /// A structure containing migration status information.
    public struct CatalogImportStatus: Swift.Sendable {
        /// True if the migration has completed, or False otherwise.
        public var importCompleted: Swift.Bool
        /// The time that the migration was started.
        public var importTime: Foundation.Date?
        /// The name of the person who initiated the migration.
        public var importedBy: Swift.String?

        public init(
            importCompleted: Swift.Bool = false,
            importTime: Foundation.Date? = nil,
            importedBy: Swift.String? = nil
        )
        {
            self.importCompleted = importCompleted
            self.importTime = importTime
            self.importedBy = importedBy
        }
    }
}

public struct GetCatalogImportStatusOutput: Swift.Sendable {
    /// The status of the specified catalog migration.
    public var importStatus: GlueClientTypes.CatalogImportStatus?

    public init(
        importStatus: GlueClientTypes.CatalogImportStatus? = nil
    )
    {
        self.importStatus = importStatus
    }
}

public struct GetClassifierInput: Swift.Sendable {
    /// Name of the classifier to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension GlueClientTypes {

    /// A classifier for custom CSV content.
    public struct CsvClassifier: Swift.Sendable {
        /// Enables the processing of files that contain only one column.
        public var allowSingleColumn: Swift.Bool?
        /// Indicates whether the CSV file contains a header.
        public var containsHeader: GlueClientTypes.CsvHeaderOption?
        /// The time that this classifier was registered.
        public var creationTime: Foundation.Date?
        /// Enables the custom datatype to be configured.
        public var customDatatypeConfigured: Swift.Bool?
        /// A list of custom datatypes including "BINARY", "BOOLEAN", "DATE", "DECIMAL", "DOUBLE", "FLOAT", "INT", "LONG", "SHORT", "STRING", "TIMESTAMP".
        public var customDatatypes: [Swift.String]?
        /// A custom symbol to denote what separates each column entry in the row.
        public var delimiter: Swift.String?
        /// Specifies not to trim values before identifying the type of column values. The default value is true.
        public var disableValueTrimming: Swift.Bool?
        /// A list of strings representing column names.
        public var header: [Swift.String]?
        /// The time that this classifier was last updated.
        public var lastUpdated: Foundation.Date?
        /// The name of the classifier.
        /// This member is required.
        public var name: Swift.String?
        /// A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
        public var quoteSymbol: Swift.String?
        /// Sets the SerDe for processing CSV in the classifier, which will be applied in the Data Catalog. Valid values are OpenCSVSerDe, LazySimpleSerDe, and None. You can specify the None value when you want the crawler to do the detection.
        public var serde: GlueClientTypes.CsvSerdeOption?
        /// The version of this classifier.
        public var version: Swift.Int

        public init(
            allowSingleColumn: Swift.Bool? = nil,
            containsHeader: GlueClientTypes.CsvHeaderOption? = nil,
            creationTime: Foundation.Date? = nil,
            customDatatypeConfigured: Swift.Bool? = nil,
            customDatatypes: [Swift.String]? = nil,
            delimiter: Swift.String? = nil,
            disableValueTrimming: Swift.Bool? = nil,
            header: [Swift.String]? = nil,
            lastUpdated: Foundation.Date? = nil,
            name: Swift.String? = nil,
            quoteSymbol: Swift.String? = nil,
            serde: GlueClientTypes.CsvSerdeOption? = nil,
            version: Swift.Int = 0
        )
        {
            self.allowSingleColumn = allowSingleColumn
            self.containsHeader = containsHeader
            self.creationTime = creationTime
            self.customDatatypeConfigured = customDatatypeConfigured
            self.customDatatypes = customDatatypes
            self.delimiter = delimiter
            self.disableValueTrimming = disableValueTrimming
            self.header = header
            self.lastUpdated = lastUpdated
            self.name = name
            self.quoteSymbol = quoteSymbol
            self.serde = serde
            self.version = version
        }
    }
}

extension GlueClientTypes {

    /// A classifier that uses grok patterns.
    public struct GrokClassifier: Swift.Sendable {
        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, and so on.
        /// This member is required.
        public var classification: Swift.String?
        /// The time that this classifier was registered.
        public var creationTime: Foundation.Date?
        /// Optional custom grok patterns defined by this classifier. For more information, see custom patterns in [Writing Custom Classifiers](https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html).
        public var customPatterns: Swift.String?
        /// The grok pattern applied to a data store by this classifier. For more information, see built-in patterns in [Writing Custom Classifiers](https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html).
        /// This member is required.
        public var grokPattern: Swift.String?
        /// The time that this classifier was last updated.
        public var lastUpdated: Foundation.Date?
        /// The name of the classifier.
        /// This member is required.
        public var name: Swift.String?
        /// The version of this classifier.
        public var version: Swift.Int

        public init(
            classification: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            customPatterns: Swift.String? = nil,
            grokPattern: Swift.String? = nil,
            lastUpdated: Foundation.Date? = nil,
            name: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.classification = classification
            self.creationTime = creationTime
            self.customPatterns = customPatterns
            self.grokPattern = grokPattern
            self.lastUpdated = lastUpdated
            self.name = name
            self.version = version
        }
    }
}

extension GlueClientTypes {

    /// A classifier for JSON content.
    public struct JsonClassifier: Swift.Sendable {
        /// The time that this classifier was registered.
        public var creationTime: Foundation.Date?
        /// A JsonPath string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in [Writing JsonPath Custom Classifiers](https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json).
        /// This member is required.
        public var jsonPath: Swift.String?
        /// The time that this classifier was last updated.
        public var lastUpdated: Foundation.Date?
        /// The name of the classifier.
        /// This member is required.
        public var name: Swift.String?
        /// The version of this classifier.
        public var version: Swift.Int

        public init(
            creationTime: Foundation.Date? = nil,
            jsonPath: Swift.String? = nil,
            lastUpdated: Foundation.Date? = nil,
            name: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.creationTime = creationTime
            self.jsonPath = jsonPath
            self.lastUpdated = lastUpdated
            self.name = name
            self.version = version
        }
    }
}

extension GlueClientTypes {

    /// A classifier for XML content.
    public struct XMLClassifier: Swift.Sendable {
        /// An identifier of the data format that the classifier matches.
        /// This member is required.
        public var classification: Swift.String?
        /// The time that this classifier was registered.
        public var creationTime: Foundation.Date?
        /// The time that this classifier was last updated.
        public var lastUpdated: Foundation.Date?
        /// The name of the classifier.
        /// This member is required.
        public var name: Swift.String?
        /// The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by />). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example,  is okay, but  is not).
        public var rowTag: Swift.String?
        /// The version of this classifier.
        public var version: Swift.Int

        public init(
            classification: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            lastUpdated: Foundation.Date? = nil,
            name: Swift.String? = nil,
            rowTag: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.classification = classification
            self.creationTime = creationTime
            self.lastUpdated = lastUpdated
            self.name = name
            self.rowTag = rowTag
            self.version = version
        }
    }
}

extension GlueClientTypes {

    /// Classifiers are triggered during a crawl task. A classifier checks whether a given file is in a format it can handle. If it is, the classifier creates a schema in the form of a StructType object that matches that data format. You can use the standard classifiers that Glue provides, or you can write your own classifiers to best categorize your data sources and specify the appropriate schemas to use for them. A classifier can be a grok classifier, an XML classifier, a JSON classifier, or a custom CSV classifier, as specified in one of the fields in the Classifier object.
    public struct Classifier: Swift.Sendable {
        /// A classifier for comma-separated values (CSV).
        public var csvClassifier: GlueClientTypes.CsvClassifier?
        /// A classifier that uses grok.
        public var grokClassifier: GlueClientTypes.GrokClassifier?
        /// A classifier for JSON content.
        public var jsonClassifier: GlueClientTypes.JsonClassifier?
        /// A classifier for XML content.
        public var xmlClassifier: GlueClientTypes.XMLClassifier?

        public init(
            csvClassifier: GlueClientTypes.CsvClassifier? = nil,
            grokClassifier: GlueClientTypes.GrokClassifier? = nil,
            jsonClassifier: GlueClientTypes.JsonClassifier? = nil,
            xmlClassifier: GlueClientTypes.XMLClassifier? = nil
        )
        {
            self.csvClassifier = csvClassifier
            self.grokClassifier = grokClassifier
            self.jsonClassifier = jsonClassifier
            self.xmlClassifier = xmlClassifier
        }
    }
}

public struct GetClassifierOutput: Swift.Sendable {
    /// The requested classifier.
    public var classifier: GlueClientTypes.Classifier?

    public init(
        classifier: GlueClientTypes.Classifier? = nil
    )
    {
        self.classifier = classifier
    }
}

public struct GetClassifiersInput: Swift.Sendable {
    /// The size of the list to return (optional).
    public var maxResults: Swift.Int?
    /// An optional continuation token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetClassifiersOutput: Swift.Sendable {
    /// The requested list of classifier objects.
    public var classifiers: [GlueClientTypes.Classifier]?
    /// A continuation token.
    public var nextToken: Swift.String?

    public init(
        classifiers: [GlueClientTypes.Classifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.classifiers = classifiers
        self.nextToken = nextToken
    }
}

public struct GetColumnStatisticsForPartitionInput: Swift.Sendable {
    /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// A list of the column names.
    /// This member is required.
    public var columnNames: [Swift.String]?
    /// The name of the catalog database where the partitions reside.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A list of partition values identifying the partition.
    /// This member is required.
    public var partitionValues: [Swift.String]?
    /// The name of the partitions' table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        columnNames: [Swift.String]? = nil,
        databaseName: Swift.String? = nil,
        partitionValues: [Swift.String]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.columnNames = columnNames
        self.databaseName = databaseName
        self.partitionValues = partitionValues
        self.tableName = tableName
    }
}

extension GlueClientTypes {

    /// Defines column statistics supported for bit sequence data values.
    public struct BinaryColumnStatisticsData: Swift.Sendable {
        /// The average bit sequence length in the column.
        /// This member is required.
        public var averageLength: Swift.Double
        /// The size of the longest bit sequence in the column.
        /// This member is required.
        public var maximumLength: Swift.Int
        /// The number of null values in the column.
        /// This member is required.
        public var numberOfNulls: Swift.Int

        public init(
            averageLength: Swift.Double = 0.0,
            maximumLength: Swift.Int = 0,
            numberOfNulls: Swift.Int = 0
        )
        {
            self.averageLength = averageLength
            self.maximumLength = maximumLength
            self.numberOfNulls = numberOfNulls
        }
    }
}

extension GlueClientTypes {

    /// Defines column statistics supported for Boolean data columns.
    public struct BooleanColumnStatisticsData: Swift.Sendable {
        /// The number of false values in the column.
        /// This member is required.
        public var numberOfFalses: Swift.Int
        /// The number of null values in the column.
        /// This member is required.
        public var numberOfNulls: Swift.Int
        /// The number of true values in the column.
        /// This member is required.
        public var numberOfTrues: Swift.Int

        public init(
            numberOfFalses: Swift.Int = 0,
            numberOfNulls: Swift.Int = 0,
            numberOfTrues: Swift.Int = 0
        )
        {
            self.numberOfFalses = numberOfFalses
            self.numberOfNulls = numberOfNulls
            self.numberOfTrues = numberOfTrues
        }
    }
}

extension GlueClientTypes {

    /// Defines column statistics supported for timestamp data columns.
    public struct DateColumnStatisticsData: Swift.Sendable {
        /// The highest value in the column.
        public var maximumValue: Foundation.Date?
        /// The lowest value in the column.
        public var minimumValue: Foundation.Date?
        /// The number of distinct values in a column.
        /// This member is required.
        public var numberOfDistinctValues: Swift.Int
        /// The number of null values in the column.
        /// This member is required.
        public var numberOfNulls: Swift.Int

        public init(
            maximumValue: Foundation.Date? = nil,
            minimumValue: Foundation.Date? = nil,
            numberOfDistinctValues: Swift.Int = 0,
            numberOfNulls: Swift.Int = 0
        )
        {
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }
    }
}

extension GlueClientTypes {

    /// Contains a numeric value in decimal format.
    public struct DecimalNumber: Swift.Sendable {
        /// The scale that determines where the decimal point falls in the unscaled value.
        /// This member is required.
        public var scale: Swift.Int
        /// The unscaled numeric value.
        /// This member is required.
        public var unscaledValue: Foundation.Data?

        public init(
            scale: Swift.Int = 0,
            unscaledValue: Foundation.Data? = nil
        )
        {
            self.scale = scale
            self.unscaledValue = unscaledValue
        }
    }
}

extension GlueClientTypes {

    /// Defines column statistics supported for fixed-point number data columns.
    public struct DecimalColumnStatisticsData: Swift.Sendable {
        /// The highest value in the column.
        public var maximumValue: GlueClientTypes.DecimalNumber?
        /// The lowest value in the column.
        public var minimumValue: GlueClientTypes.DecimalNumber?
        /// The number of distinct values in a column.
        /// This member is required.
        public var numberOfDistinctValues: Swift.Int
        /// The number of null values in the column.
        /// This member is required.
        public var numberOfNulls: Swift.Int

        public init(
            maximumValue: GlueClientTypes.DecimalNumber? = nil,
            minimumValue: GlueClientTypes.DecimalNumber? = nil,
            numberOfDistinctValues: Swift.Int = 0,
            numberOfNulls: Swift.Int = 0
        )
        {
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }
    }
}

extension GlueClientTypes {

    /// Defines column statistics supported for floating-point number data columns.
    public struct DoubleColumnStatisticsData: Swift.Sendable {
        /// The highest value in the column.
        public var maximumValue: Swift.Double
        /// The lowest value in the column.
        public var minimumValue: Swift.Double
        /// The number of distinct values in a column.
        /// This member is required.
        public var numberOfDistinctValues: Swift.Int
        /// The number of null values in the column.
        /// This member is required.
        public var numberOfNulls: Swift.Int

        public init(
            maximumValue: Swift.Double = 0.0,
            minimumValue: Swift.Double = 0.0,
            numberOfDistinctValues: Swift.Int = 0,
            numberOfNulls: Swift.Int = 0
        )
        {
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }
    }
}

extension GlueClientTypes {

    /// Defines column statistics supported for integer data columns.
    public struct LongColumnStatisticsData: Swift.Sendable {
        /// The highest value in the column.
        public var maximumValue: Swift.Int
        /// The lowest value in the column.
        public var minimumValue: Swift.Int
        /// The number of distinct values in a column.
        /// This member is required.
        public var numberOfDistinctValues: Swift.Int
        /// The number of null values in the column.
        /// This member is required.
        public var numberOfNulls: Swift.Int

        public init(
            maximumValue: Swift.Int = 0,
            minimumValue: Swift.Int = 0,
            numberOfDistinctValues: Swift.Int = 0,
            numberOfNulls: Swift.Int = 0
        )
        {
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }
    }
}

extension GlueClientTypes {

    /// Defines column statistics supported for character sequence data values.
    public struct StringColumnStatisticsData: Swift.Sendable {
        /// The average string length in the column.
        /// This member is required.
        public var averageLength: Swift.Double
        /// The size of the longest string in the column.
        /// This member is required.
        public var maximumLength: Swift.Int
        /// The number of distinct values in a column.
        /// This member is required.
        public var numberOfDistinctValues: Swift.Int
        /// The number of null values in the column.
        /// This member is required.
        public var numberOfNulls: Swift.Int

        public init(
            averageLength: Swift.Double = 0.0,
            maximumLength: Swift.Int = 0,
            numberOfDistinctValues: Swift.Int = 0,
            numberOfNulls: Swift.Int = 0
        )
        {
            self.averageLength = averageLength
            self.maximumLength = maximumLength
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }
    }
}

extension GlueClientTypes {

    public enum ColumnStatisticsType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case binary
        case boolean
        case date
        case decimal
        case double
        case long
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnStatisticsType] {
            return [
                .binary,
                .boolean,
                .date,
                .decimal,
                .double,
                .long,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .binary: return "BINARY"
            case .boolean: return "BOOLEAN"
            case .date: return "DATE"
            case .decimal: return "DECIMAL"
            case .double: return "DOUBLE"
            case .long: return "LONG"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Contains the individual types of column statistics data. Only one data object should be set and indicated by the Type attribute.
    public struct ColumnStatisticsData: Swift.Sendable {
        /// Binary column statistics data.
        public var binaryColumnStatisticsData: GlueClientTypes.BinaryColumnStatisticsData?
        /// Boolean column statistics data.
        public var booleanColumnStatisticsData: GlueClientTypes.BooleanColumnStatisticsData?
        /// Date column statistics data.
        public var dateColumnStatisticsData: GlueClientTypes.DateColumnStatisticsData?
        /// Decimal column statistics data. UnscaledValues within are Base64-encoded binary objects storing big-endian, two's complement representations of the decimal's unscaled value.
        public var decimalColumnStatisticsData: GlueClientTypes.DecimalColumnStatisticsData?
        /// Double column statistics data.
        public var doubleColumnStatisticsData: GlueClientTypes.DoubleColumnStatisticsData?
        /// Long column statistics data.
        public var longColumnStatisticsData: GlueClientTypes.LongColumnStatisticsData?
        /// String column statistics data.
        public var stringColumnStatisticsData: GlueClientTypes.StringColumnStatisticsData?
        /// The type of column statistics data.
        /// This member is required.
        public var type: GlueClientTypes.ColumnStatisticsType?

        public init(
            binaryColumnStatisticsData: GlueClientTypes.BinaryColumnStatisticsData? = nil,
            booleanColumnStatisticsData: GlueClientTypes.BooleanColumnStatisticsData? = nil,
            dateColumnStatisticsData: GlueClientTypes.DateColumnStatisticsData? = nil,
            decimalColumnStatisticsData: GlueClientTypes.DecimalColumnStatisticsData? = nil,
            doubleColumnStatisticsData: GlueClientTypes.DoubleColumnStatisticsData? = nil,
            longColumnStatisticsData: GlueClientTypes.LongColumnStatisticsData? = nil,
            stringColumnStatisticsData: GlueClientTypes.StringColumnStatisticsData? = nil,
            type: GlueClientTypes.ColumnStatisticsType? = nil
        )
        {
            self.binaryColumnStatisticsData = binaryColumnStatisticsData
            self.booleanColumnStatisticsData = booleanColumnStatisticsData
            self.dateColumnStatisticsData = dateColumnStatisticsData
            self.decimalColumnStatisticsData = decimalColumnStatisticsData
            self.doubleColumnStatisticsData = doubleColumnStatisticsData
            self.longColumnStatisticsData = longColumnStatisticsData
            self.stringColumnStatisticsData = stringColumnStatisticsData
            self.type = type
        }
    }
}

extension GlueClientTypes {

    /// Represents the generated column-level statistics for a table or partition.
    public struct ColumnStatistics: Swift.Sendable {
        /// The timestamp of when column statistics were generated.
        /// This member is required.
        public var analyzedTime: Foundation.Date?
        /// Name of column which statistics belong to.
        /// This member is required.
        public var columnName: Swift.String?
        /// The data type of the column.
        /// This member is required.
        public var columnType: Swift.String?
        /// A ColumnStatisticData object that contains the statistics data values.
        /// This member is required.
        public var statisticsData: GlueClientTypes.ColumnStatisticsData?

        public init(
            analyzedTime: Foundation.Date? = nil,
            columnName: Swift.String? = nil,
            columnType: Swift.String? = nil,
            statisticsData: GlueClientTypes.ColumnStatisticsData? = nil
        )
        {
            self.analyzedTime = analyzedTime
            self.columnName = columnName
            self.columnType = columnType
            self.statisticsData = statisticsData
        }
    }
}

extension GlueClientTypes {

    /// Encapsulates a column name that failed and the reason for failure.
    public struct ColumnError: Swift.Sendable {
        /// The name of the column that failed.
        public var columnName: Swift.String?
        /// An error message with the reason for the failure of an operation.
        public var error: GlueClientTypes.ErrorDetail?

        public init(
            columnName: Swift.String? = nil,
            error: GlueClientTypes.ErrorDetail? = nil
        )
        {
            self.columnName = columnName
            self.error = error
        }
    }
}

public struct GetColumnStatisticsForPartitionOutput: Swift.Sendable {
    /// List of ColumnStatistics that failed to be retrieved.
    public var columnStatisticsList: [GlueClientTypes.ColumnStatistics]?
    /// Error occurred during retrieving column statistics data.
    public var errors: [GlueClientTypes.ColumnError]?

    public init(
        columnStatisticsList: [GlueClientTypes.ColumnStatistics]? = nil,
        errors: [GlueClientTypes.ColumnError]? = nil
    )
    {
        self.columnStatisticsList = columnStatisticsList
        self.errors = errors
    }
}

public struct GetColumnStatisticsForTableInput: Swift.Sendable {
    /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// A list of the column names.
    /// This member is required.
    public var columnNames: [Swift.String]?
    /// The name of the catalog database where the partitions reside.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the partitions' table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        columnNames: [Swift.String]? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.columnNames = columnNames
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

public struct GetColumnStatisticsForTableOutput: Swift.Sendable {
    /// List of ColumnStatistics.
    public var columnStatisticsList: [GlueClientTypes.ColumnStatistics]?
    /// List of ColumnStatistics that failed to be retrieved.
    public var errors: [GlueClientTypes.ColumnError]?

    public init(
        columnStatisticsList: [GlueClientTypes.ColumnStatistics]? = nil,
        errors: [GlueClientTypes.ColumnError]? = nil
    )
    {
        self.columnStatisticsList = columnStatisticsList
        self.errors = errors
    }
}

public struct GetColumnStatisticsTaskRunInput: Swift.Sendable {
    /// The identifier for the particular column statistics task run.
    /// This member is required.
    public var columnStatisticsTaskRunId: Swift.String?

    public init(
        columnStatisticsTaskRunId: Swift.String? = nil
    )
    {
        self.columnStatisticsTaskRunId = columnStatisticsTaskRunId
    }
}

extension GlueClientTypes {

    public enum ComputationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case full
        case incremental
        case sdkUnknown(Swift.String)

        public static var allCases: [ComputationType] {
            return [
                .full,
                .incremental
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .incremental: return "INCREMENTAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum ColumnStatisticsState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case running
        case starting
        case stopped
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnStatisticsState] {
            return [
                .failed,
                .running,
                .starting,
                .stopped,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The object that shows the details of the column stats run.
    public struct ColumnStatisticsTaskRun: Swift.Sendable {
        /// The ID of the Data Catalog where the table resides. If none is supplied, the Amazon Web Services account ID is used by default.
        public var catalogID: Swift.String?
        /// A list of the column names. If none is supplied, all column names for the table will be used by default.
        public var columnNameList: [Swift.String]?
        /// The identifier for the particular column statistics task run.
        public var columnStatisticsTaskRunId: Swift.String?
        /// The type of column statistics computation.
        public var computationType: GlueClientTypes.ComputationType?
        /// The time that this task was created.
        public var creationTime: Foundation.Date?
        /// The Amazon Web Services account ID.
        public var customerId: Swift.String?
        /// The database where the table resides.
        public var databaseName: Swift.String?
        /// The calculated DPU usage in seconds for all autoscaled workers.
        public var dpuSeconds: Swift.Double
        /// The end time of the task.
        public var endTime: Foundation.Date?
        /// The error message for the job.
        public var errorMessage: Swift.String?
        /// The last point in time when this task was modified.
        public var lastUpdated: Foundation.Date?
        /// The number of workers used to generate column statistics. The job is preconfigured to autoscale up to 25 instances.
        public var numberOfWorkers: Swift.Int
        /// The IAM role that the service assumes to generate statistics.
        public var role: Swift.String?
        /// The percentage of rows used to generate statistics. If none is supplied, the entire table will be used to generate stats.
        public var sampleSize: Swift.Double
        /// Name of the security configuration that is used to encrypt CloudWatch logs for the column stats task run.
        public var securityConfiguration: Swift.String?
        /// The start time of the task.
        public var startTime: Foundation.Date?
        /// The status of the task run.
        public var status: GlueClientTypes.ColumnStatisticsState?
        /// The name of the table for which column statistics is generated.
        public var tableName: Swift.String?
        /// The type of workers being used for generating stats. The default is g.1x.
        public var workerType: Swift.String?

        public init(
            catalogID: Swift.String? = nil,
            columnNameList: [Swift.String]? = nil,
            columnStatisticsTaskRunId: Swift.String? = nil,
            computationType: GlueClientTypes.ComputationType? = nil,
            creationTime: Foundation.Date? = nil,
            customerId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dpuSeconds: Swift.Double = 0.0,
            endTime: Foundation.Date? = nil,
            errorMessage: Swift.String? = nil,
            lastUpdated: Foundation.Date? = nil,
            numberOfWorkers: Swift.Int = 0,
            role: Swift.String? = nil,
            sampleSize: Swift.Double = 0.0,
            securityConfiguration: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            status: GlueClientTypes.ColumnStatisticsState? = nil,
            tableName: Swift.String? = nil,
            workerType: Swift.String? = nil
        )
        {
            self.catalogID = catalogID
            self.columnNameList = columnNameList
            self.columnStatisticsTaskRunId = columnStatisticsTaskRunId
            self.computationType = computationType
            self.creationTime = creationTime
            self.customerId = customerId
            self.databaseName = databaseName
            self.dpuSeconds = dpuSeconds
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.lastUpdated = lastUpdated
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.sampleSize = sampleSize
            self.securityConfiguration = securityConfiguration
            self.startTime = startTime
            self.status = status
            self.tableName = tableName
            self.workerType = workerType
        }
    }
}

public struct GetColumnStatisticsTaskRunOutput: Swift.Sendable {
    /// A ColumnStatisticsTaskRun object representing the details of the column stats run.
    public var columnStatisticsTaskRun: GlueClientTypes.ColumnStatisticsTaskRun?

    public init(
        columnStatisticsTaskRun: GlueClientTypes.ColumnStatisticsTaskRun? = nil
    )
    {
        self.columnStatisticsTaskRun = columnStatisticsTaskRun
    }
}

public struct GetColumnStatisticsTaskRunsInput: Swift.Sendable {
    /// The name of the database where the table resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The maximum size of the response.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tableName = tableName
    }
}

public struct GetColumnStatisticsTaskRunsOutput: Swift.Sendable {
    /// A list of column statistics task runs.
    public var columnStatisticsTaskRuns: [GlueClientTypes.ColumnStatisticsTaskRun]?
    /// A continuation token, if not all task runs have yet been returned.
    public var nextToken: Swift.String?

    public init(
        columnStatisticsTaskRuns: [GlueClientTypes.ColumnStatisticsTaskRun]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.columnStatisticsTaskRuns = columnStatisticsTaskRuns
        self.nextToken = nextToken
    }
}

public struct GetColumnStatisticsTaskSettingsInput: Swift.Sendable {
    /// The name of the database where the table resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table for which to retrieve column statistics.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

extension GlueClientTypes {

    /// The settings for a column statistics task.
    public struct ColumnStatisticsTaskSettings: Swift.Sendable {
        /// The ID of the Data Catalog in which the database resides.
        public var catalogID: Swift.String?
        /// A list of column names for which to run statistics.
        public var columnNameList: [Swift.String]?
        /// The name of the database where the table resides.
        public var databaseName: Swift.String?
        /// The role used for running the column statistics.
        public var role: Swift.String?
        /// The percentage of data to sample.
        public var sampleSize: Swift.Double
        /// A schedule for running the column statistics, specified in CRON syntax.
        public var schedule: GlueClientTypes.Schedule?
        /// Name of the security configuration that is used to encrypt CloudWatch logs.
        public var securityConfiguration: Swift.String?
        /// The name of the table for which to generate column statistics.
        public var tableName: Swift.String?

        public init(
            catalogID: Swift.String? = nil,
            columnNameList: [Swift.String]? = nil,
            databaseName: Swift.String? = nil,
            role: Swift.String? = nil,
            sampleSize: Swift.Double = 0.0,
            schedule: GlueClientTypes.Schedule? = nil,
            securityConfiguration: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.catalogID = catalogID
            self.columnNameList = columnNameList
            self.databaseName = databaseName
            self.role = role
            self.sampleSize = sampleSize
            self.schedule = schedule
            self.securityConfiguration = securityConfiguration
            self.tableName = tableName
        }
    }
}

public struct GetColumnStatisticsTaskSettingsOutput: Swift.Sendable {
    /// A ColumnStatisticsTaskSettings object representing the settings for the column statistics task.
    public var columnStatisticsTaskSettings: GlueClientTypes.ColumnStatisticsTaskSettings?

    public init(
        columnStatisticsTaskSettings: GlueClientTypes.ColumnStatisticsTaskSettings? = nil
    )
    {
        self.columnStatisticsTaskSettings = columnStatisticsTaskSettings
    }
}

public struct GetConnectionInput: Swift.Sendable {
    /// The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// Allows you to retrieve the connection metadata without returning the password. For instance, the Glue console uses this flag to retrieve the connection, and does not display the password. Set this parameter when the caller might not have permission to use the KMS key to decrypt the password, but it does have permission to access the rest of the connection properties.
    public var hidePassword: Swift.Bool?
    /// The name of the connection definition to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        hidePassword: Swift.Bool? = false,
        name: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.hidePassword = hidePassword
        self.name = name
    }
}

extension GlueClientTypes {

    /// Defines a connection to a data source.
    public struct Connection: Swift.Sendable {
        /// This field is not currently used.
        public var athenaProperties: [Swift.String: Swift.String]?
        /// The authentication properties of the connection.
        public var authenticationConfiguration: GlueClientTypes.AuthenticationConfiguration?
        /// These key-value pairs define parameters for the connection:
        ///
        /// * HOST - The host URI: either the fully qualified domain name (FQDN) or the IPv4 address of the database host.
        ///
        /// * PORT - The port number, between 1024 and 65535, of the port on which the database host is listening for database connections.
        ///
        /// * USER_NAME - The name under which to log in to the database. The value string for USER_NAME is "USERNAME".
        ///
        /// * PASSWORD - A password, if one is used, for the user name.
        ///
        /// * ENCRYPTED_PASSWORD - When you enable connection password protection by setting ConnectionPasswordEncryption in the Data Catalog encryption settings, this field stores the encrypted password.
        ///
        /// * JDBC_DRIVER_JAR_URI - The Amazon Simple Storage Service (Amazon S3) path of the JAR file that contains the JDBC driver to use.
        ///
        /// * JDBC_DRIVER_CLASS_NAME - The class name of the JDBC driver to use.
        ///
        /// * JDBC_ENGINE - The name of the JDBC engine to use.
        ///
        /// * JDBC_ENGINE_VERSION - The version of the JDBC engine to use.
        ///
        /// * CONFIG_FILES - (Reserved for future use.)
        ///
        /// * INSTANCE_ID - The instance ID to use.
        ///
        /// * JDBC_CONNECTION_URL - The URL for connecting to a JDBC data source.
        ///
        /// * JDBC_ENFORCE_SSL - A Boolean string (true, false) specifying whether Secure Sockets Layer (SSL) with hostname matching is enforced for the JDBC connection on the client. The default is false.
        ///
        /// * CUSTOM_JDBC_CERT - An Amazon S3 location specifying the customer's root certificate. Glue uses this root certificate to validate the customer’s certificate when connecting to the customer database. Glue only handles X.509 certificates. The certificate provided must be DER-encoded and supplied in Base64 encoding PEM format.
        ///
        /// * SKIP_CUSTOM_JDBC_CERT_VALIDATION - By default, this is false. Glue validates the Signature algorithm and Subject Public Key Algorithm for the customer certificate. The only permitted algorithms for the Signature algorithm are SHA256withRSA, SHA384withRSA or SHA512withRSA. For the Subject Public Key Algorithm, the key length must be at least 2048. You can set the value of this property to true to skip Glue’s validation of the customer certificate.
        ///
        /// * CUSTOM_JDBC_CERT_STRING - A custom JDBC certificate string which is used for domain match or distinguished name match to prevent a man-in-the-middle attack. In Oracle database, this is used as the SSL_SERVER_CERT_DN; in Microsoft SQL Server, this is used as the hostNameInCertificate.
        ///
        /// * CONNECTION_URL - The URL for connecting to a general (non-JDBC) data source.
        ///
        /// * SECRET_ID - The secret ID used for the secret manager of credentials.
        ///
        /// * CONNECTOR_URL - The connector URL for a MARKETPLACE or CUSTOM connection.
        ///
        /// * CONNECTOR_TYPE - The connector type for a MARKETPLACE or CUSTOM connection.
        ///
        /// * CONNECTOR_CLASS_NAME - The connector class name for a MARKETPLACE or CUSTOM connection.
        ///
        /// * KAFKA_BOOTSTRAP_SERVERS - A comma-separated list of host and port pairs that are the addresses of the Apache Kafka brokers in a Kafka cluster to which a Kafka client will connect to and bootstrap itself.
        ///
        /// * KAFKA_SSL_ENABLED - Whether to enable or disable SSL on an Apache Kafka connection. Default value is "true".
        ///
        /// * KAFKA_CUSTOM_CERT - The Amazon S3 URL for the private CA cert file (.pem format). The default is an empty string.
        ///
        /// * KAFKA_SKIP_CUSTOM_CERT_VALIDATION - Whether to skip the validation of the CA cert file or not. Glue validates for three algorithms: SHA256withRSA, SHA384withRSA and SHA512withRSA. Default value is "false".
        ///
        /// * KAFKA_CLIENT_KEYSTORE - The Amazon S3 location of the client keystore file for Kafka client side authentication (Optional).
        ///
        /// * KAFKA_CLIENT_KEYSTORE_PASSWORD - The password to access the provided keystore (Optional).
        ///
        /// * KAFKA_CLIENT_KEY_PASSWORD - A keystore can consist of multiple keys, so this is the password to access the client key to be used with the Kafka server side key (Optional).
        ///
        /// * ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD - The encrypted version of the Kafka client keystore password (if the user has the Glue encrypt passwords setting selected).
        ///
        /// * ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD - The encrypted version of the Kafka client key password (if the user has the Glue encrypt passwords setting selected).
        ///
        /// * KAFKA_SASL_MECHANISM - "SCRAM-SHA-512", "GSSAPI", "AWS_MSK_IAM", or "PLAIN". These are the supported [SASL Mechanisms](https://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml).
        ///
        /// * KAFKA_SASL_PLAIN_USERNAME - A plaintext username used to authenticate with the "PLAIN" mechanism.
        ///
        /// * KAFKA_SASL_PLAIN_PASSWORD - A plaintext password used to authenticate with the "PLAIN" mechanism.
        ///
        /// * ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD - The encrypted version of the Kafka SASL PLAIN password (if the user has the Glue encrypt passwords setting selected).
        ///
        /// * KAFKA_SASL_SCRAM_USERNAME - A plaintext username used to authenticate with the "SCRAM-SHA-512" mechanism.
        ///
        /// * KAFKA_SASL_SCRAM_PASSWORD - A plaintext password used to authenticate with the "SCRAM-SHA-512" mechanism.
        ///
        /// * ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD - The encrypted version of the Kafka SASL SCRAM password (if the user has the Glue encrypt passwords setting selected).
        ///
        /// * KAFKA_SASL_SCRAM_SECRETS_ARN - The Amazon Resource Name of a secret in Amazon Web Services Secrets Manager.
        ///
        /// * KAFKA_SASL_GSSAPI_KEYTAB - The S3 location of a Kerberos keytab file. A keytab stores long-term keys for one or more principals. For more information, see [MIT Kerberos Documentation: Keytab](https://web.mit.edu/kerberos/krb5-latest/doc/basic/keytab_def.html).
        ///
        /// * KAFKA_SASL_GSSAPI_KRB5_CONF - The S3 location of a Kerberos krb5.conf file. A krb5.conf stores Kerberos configuration information, such as the location of the KDC server. For more information, see [MIT Kerberos Documentation: krb5.conf](https://web.mit.edu/kerberos/krb5-1.12/doc/admin/conf_files/krb5_conf.html).
        ///
        /// * KAFKA_SASL_GSSAPI_SERVICE - The Kerberos service name, as set with sasl.kerberos.service.name in your [Kafka Configuration](https://kafka.apache.org/documentation/#brokerconfigs_sasl.kerberos.service.name).
        ///
        /// * KAFKA_SASL_GSSAPI_PRINCIPAL - The name of the Kerberos princial used by Glue. For more information, see [Kafka Documentation: Configuring Kafka Brokers](https://kafka.apache.org/documentation/#security_sasl_kerberos_clientconfig).
        ///
        /// * ROLE_ARN - The role to be used for running queries.
        ///
        /// * REGION - The Amazon Web Services Region where queries will be run.
        ///
        /// * WORKGROUP_NAME - The name of an Amazon Redshift serverless workgroup or Amazon Athena workgroup in which queries will run.
        ///
        /// * CLUSTER_IDENTIFIER - The cluster identifier of an Amazon Redshift cluster in which queries will run.
        ///
        /// * DATABASE - The Amazon Redshift database that you are connecting to.
        public var connectionProperties: [Swift.String: Swift.String]?
        /// The type of the connection. Currently, SFTP is not supported.
        public var connectionType: GlueClientTypes.ConnectionType?
        /// The timestamp of the time that this connection definition was created.
        public var creationTime: Foundation.Date?
        /// The description of the connection.
        public var description: Swift.String?
        /// A timestamp of the time this connection was last validated.
        public var lastConnectionValidationTime: Foundation.Date?
        /// The user, group, or role that last updated this connection definition.
        public var lastUpdatedBy: Swift.String?
        /// The timestamp of the last time the connection definition was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// A list of criteria that can be used in selecting this connection.
        public var matchCriteria: [Swift.String]?
        /// The name of the connection definition.
        public var name: Swift.String?
        /// The physical connection requirements, such as virtual private cloud (VPC) and SecurityGroup, that are needed to make this connection successfully.
        public var physicalConnectionRequirements: GlueClientTypes.PhysicalConnectionRequirements?
        /// The status of the connection. Can be one of: READY, IN_PROGRESS, or FAILED.
        public var status: GlueClientTypes.ConnectionStatus?
        /// The reason for the connection status.
        public var statusReason: Swift.String?

        public init(
            athenaProperties: [Swift.String: Swift.String]? = nil,
            authenticationConfiguration: GlueClientTypes.AuthenticationConfiguration? = nil,
            connectionProperties: [Swift.String: Swift.String]? = nil,
            connectionType: GlueClientTypes.ConnectionType? = nil,
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastConnectionValidationTime: Foundation.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            matchCriteria: [Swift.String]? = nil,
            name: Swift.String? = nil,
            physicalConnectionRequirements: GlueClientTypes.PhysicalConnectionRequirements? = nil,
            status: GlueClientTypes.ConnectionStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.athenaProperties = athenaProperties
            self.authenticationConfiguration = authenticationConfiguration
            self.connectionProperties = connectionProperties
            self.connectionType = connectionType
            self.creationTime = creationTime
            self.description = description
            self.lastConnectionValidationTime = lastConnectionValidationTime
            self.lastUpdatedBy = lastUpdatedBy
            self.lastUpdatedTime = lastUpdatedTime
            self.matchCriteria = matchCriteria
            self.name = name
            self.physicalConnectionRequirements = physicalConnectionRequirements
            self.status = status
            self.statusReason = statusReason
        }
    }
}

public struct GetConnectionOutput: Swift.Sendable {
    /// The requested connection definition.
    public var connection: GlueClientTypes.Connection?

    public init(
        connection: GlueClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

extension GlueClientTypes {

    /// Filters the connection definitions that are returned by the GetConnections API operation.
    public struct GetConnectionsFilter: Swift.Sendable {
        /// The type of connections to return. Currently, SFTP is not supported.
        public var connectionType: GlueClientTypes.ConnectionType?
        /// A criteria string that must match the criteria recorded in the connection definition for that connection definition to be returned.
        public var matchCriteria: [Swift.String]?

        public init(
            connectionType: GlueClientTypes.ConnectionType? = nil,
            matchCriteria: [Swift.String]? = nil
        )
        {
            self.connectionType = connectionType
            self.matchCriteria = matchCriteria
        }
    }
}

public struct GetConnectionsInput: Swift.Sendable {
    /// The ID of the Data Catalog in which the connections reside. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// A filter that controls which connections are returned.
    public var filter: GlueClientTypes.GetConnectionsFilter?
    /// Allows you to retrieve the connection metadata without returning the password. For instance, the Glue console uses this flag to retrieve the connection, and does not display the password. Set this parameter when the caller might not have permission to use the KMS key to decrypt the password, but it does have permission to access the rest of the connection properties.
    public var hidePassword: Swift.Bool?
    /// The maximum number of connections to return in one response.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        filter: GlueClientTypes.GetConnectionsFilter? = nil,
        hidePassword: Swift.Bool? = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.filter = filter
        self.hidePassword = hidePassword
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetConnectionsOutput: Swift.Sendable {
    /// A list of requested connection definitions.
    public var connectionList: [GlueClientTypes.Connection]?
    /// A continuation token, if the list of connections returned does not include the last of the filtered connections.
    public var nextToken: Swift.String?

    public init(
        connectionList: [GlueClientTypes.Connection]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionList = connectionList
        self.nextToken = nextToken
    }
}

public struct GetCrawlerInput: Swift.Sendable {
    /// The name of the crawler to retrieve metadata for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct GetCrawlerOutput: Swift.Sendable {
    /// The metadata for the specified crawler.
    public var crawler: GlueClientTypes.Crawler?

    public init(
        crawler: GlueClientTypes.Crawler? = nil
    )
    {
        self.crawler = crawler
    }
}

public struct GetCrawlerMetricsInput: Swift.Sendable {
    /// A list of the names of crawlers about which to retrieve metrics.
    public var crawlerNameList: [Swift.String]?
    /// The maximum size of a list to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?

    public init(
        crawlerNameList: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crawlerNameList = crawlerNameList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GlueClientTypes {

    /// Metrics for a specified crawler.
    public struct CrawlerMetrics: Swift.Sendable {
        /// The name of the crawler.
        public var crawlerName: Swift.String?
        /// The duration of the crawler's most recent run, in seconds.
        public var lastRuntimeSeconds: Swift.Double
        /// The median duration of this crawler's runs, in seconds.
        public var medianRuntimeSeconds: Swift.Double
        /// True if the crawler is still estimating how long it will take to complete this run.
        public var stillEstimating: Swift.Bool
        /// The number of tables created by this crawler.
        public var tablesCreated: Swift.Int
        /// The number of tables deleted by this crawler.
        public var tablesDeleted: Swift.Int
        /// The number of tables updated by this crawler.
        public var tablesUpdated: Swift.Int
        /// The estimated time left to complete a running crawl.
        public var timeLeftSeconds: Swift.Double

        public init(
            crawlerName: Swift.String? = nil,
            lastRuntimeSeconds: Swift.Double = 0.0,
            medianRuntimeSeconds: Swift.Double = 0.0,
            stillEstimating: Swift.Bool = false,
            tablesCreated: Swift.Int = 0,
            tablesDeleted: Swift.Int = 0,
            tablesUpdated: Swift.Int = 0,
            timeLeftSeconds: Swift.Double = 0.0
        )
        {
            self.crawlerName = crawlerName
            self.lastRuntimeSeconds = lastRuntimeSeconds
            self.medianRuntimeSeconds = medianRuntimeSeconds
            self.stillEstimating = stillEstimating
            self.tablesCreated = tablesCreated
            self.tablesDeleted = tablesDeleted
            self.tablesUpdated = tablesUpdated
            self.timeLeftSeconds = timeLeftSeconds
        }
    }
}

public struct GetCrawlerMetricsOutput: Swift.Sendable {
    /// A list of metrics for the specified crawler.
    public var crawlerMetricsList: [GlueClientTypes.CrawlerMetrics]?
    /// A continuation token, if the returned list does not contain the last metric available.
    public var nextToken: Swift.String?

    public init(
        crawlerMetricsList: [GlueClientTypes.CrawlerMetrics]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crawlerMetricsList = crawlerMetricsList
        self.nextToken = nextToken
    }
}

public struct GetCrawlersInput: Swift.Sendable {
    /// The number of crawlers to return on each call.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetCrawlersOutput: Swift.Sendable {
    /// A list of crawler metadata.
    public var crawlers: [GlueClientTypes.Crawler]?
    /// A continuation token, if the returned list has not reached the end of those defined in this customer account.
    public var nextToken: Swift.String?

    public init(
        crawlers: [GlueClientTypes.Crawler]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crawlers = crawlers
        self.nextToken = nextToken
    }
}

public struct GetCustomEntityTypeInput: Swift.Sendable {
    /// The name of the custom pattern that you want to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct GetCustomEntityTypeOutput: Swift.Sendable {
    /// A list of context words if specified when you created the custom pattern. If none of these context words are found within the vicinity of the regular expression the data will not be detected as sensitive data.
    public var contextWords: [Swift.String]?
    /// The name of the custom pattern that you retrieved.
    public var name: Swift.String?
    /// A regular expression string that is used for detecting sensitive data in a custom pattern.
    public var regexString: Swift.String?

    public init(
        contextWords: [Swift.String]? = nil,
        name: Swift.String? = nil,
        regexString: Swift.String? = nil
    )
    {
        self.contextWords = contextWords
        self.name = name
        self.regexString = regexString
    }
}

public struct GetDatabaseInput: Swift.Sendable {
    /// The ID of the Data Catalog in which the database resides. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the database to retrieve. For Hive compatibility, this should be all lowercase.
    /// This member is required.
    public var name: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.name = name
    }
}

extension GlueClientTypes {

    /// The Database object represents a logical grouping of tables that might reside in a Hive metastore or an RDBMS.
    public struct Database: Swift.Sendable {
        /// The ID of the Data Catalog in which the database resides.
        public var catalogId: Swift.String?
        /// Creates a set of default permissions on the table for principals. Used by Lake Formation. Not used in the normal course of Glue operations.
        public var createTableDefaultPermissions: [GlueClientTypes.PrincipalPermissions]?
        /// The time at which the metadata database was created in the catalog.
        public var createTime: Foundation.Date?
        /// A description of the database.
        public var description: Swift.String?
        /// A FederatedDatabase structure that references an entity outside the Glue Data Catalog.
        public var federatedDatabase: GlueClientTypes.FederatedDatabase?
        /// The location of the database (for example, an HDFS path).
        public var locationUri: Swift.String?
        /// The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.
        /// This member is required.
        public var name: Swift.String?
        /// These key-value pairs define parameters and properties of the database.
        public var parameters: [Swift.String: Swift.String]?
        /// A DatabaseIdentifier structure that describes a target database for resource linking.
        public var targetDatabase: GlueClientTypes.DatabaseIdentifier?

        public init(
            catalogId: Swift.String? = nil,
            createTableDefaultPermissions: [GlueClientTypes.PrincipalPermissions]? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            federatedDatabase: GlueClientTypes.FederatedDatabase? = nil,
            locationUri: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            targetDatabase: GlueClientTypes.DatabaseIdentifier? = nil
        )
        {
            self.catalogId = catalogId
            self.createTableDefaultPermissions = createTableDefaultPermissions
            self.createTime = createTime
            self.description = description
            self.federatedDatabase = federatedDatabase
            self.locationUri = locationUri
            self.name = name
            self.parameters = parameters
            self.targetDatabase = targetDatabase
        }
    }
}

public struct GetDatabaseOutput: Swift.Sendable {
    /// The definition of the specified database in the Data Catalog.
    public var database: GlueClientTypes.Database?

    public init(
        database: GlueClientTypes.Database? = nil
    )
    {
        self.database = database
    }
}

extension GlueClientTypes {

    public enum DatabaseAttributes: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseAttributes] {
            return [
                .name
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum ResourceShareType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case federated
        case foreign
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareType] {
            return [
                .all,
                .federated,
                .foreign
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .federated: return "FEDERATED"
            case .foreign: return "FOREIGN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetDatabasesInput: Swift.Sendable {
    /// Specifies the database fields returned by the GetDatabases call. This parameter doesn’t accept an empty list. The request must include the NAME.
    public var attributesToGet: [GlueClientTypes.DatabaseAttributes]?
    /// The ID of the Data Catalog from which to retrieve Databases. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The maximum number of databases to return in one response.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?
    /// Allows you to specify that you want to list the databases shared with your account. The allowable values are FEDERATED, FOREIGN or ALL.
    ///
    /// * If set to FEDERATED, will list the federated databases (referencing an external entity) shared with your account.
    ///
    /// * If set to FOREIGN, will list the databases shared with your account.
    ///
    /// * If set to ALL, will list the databases shared with your account, as well as the databases in yor local account.
    public var resourceShareType: GlueClientTypes.ResourceShareType?

    public init(
        attributesToGet: [GlueClientTypes.DatabaseAttributes]? = nil,
        catalogId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceShareType: GlueClientTypes.ResourceShareType? = nil
    )
    {
        self.attributesToGet = attributesToGet
        self.catalogId = catalogId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareType = resourceShareType
    }
}

public struct GetDatabasesOutput: Swift.Sendable {
    /// A list of Database objects from the specified catalog.
    /// This member is required.
    public var databaseList: [GlueClientTypes.Database]?
    /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
    public var nextToken: Swift.String?

    public init(
        databaseList: [GlueClientTypes.Database]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databaseList = databaseList
        self.nextToken = nextToken
    }
}

public struct GetDataCatalogEncryptionSettingsInput: Swift.Sendable {
    /// The ID of the Data Catalog to retrieve the security configuration for. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?

    public init(
        catalogId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
    }
}

extension GlueClientTypes {

    /// The data structure used by the Data Catalog to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption. When a CreationConnection request arrives containing a password, the Data Catalog first encrypts the password using your KMS key. It then encrypts the whole connection object again if catalog encryption is also enabled. This encryption requires that you set KMS key permissions to enable or restrict access on the password key according to your security requirements. For example, you might want only administrators to have decrypt permission on the password key.
    public struct ConnectionPasswordEncryption: Swift.Sendable {
        /// An KMS key that is used to encrypt the connection password. If connection password protection is enabled, the caller of CreateConnection and UpdateConnection needs at least kms:Encrypt permission on the specified KMS key, to encrypt passwords before storing them in the Data Catalog. You can set the decrypt permission to enable or restrict access on the password key according to your security requirements.
        public var awsKmsKeyId: Swift.String?
        /// When the ReturnConnectionPasswordEncrypted flag is set to "true", passwords remain encrypted in the responses of GetConnection and GetConnections. This encryption takes effect independently from catalog encryption.
        /// This member is required.
        public var returnConnectionPasswordEncrypted: Swift.Bool

        public init(
            awsKmsKeyId: Swift.String? = nil,
            returnConnectionPasswordEncrypted: Swift.Bool = false
        )
        {
            self.awsKmsKeyId = awsKmsKeyId
            self.returnConnectionPasswordEncrypted = returnConnectionPasswordEncrypted
        }
    }
}

extension GlueClientTypes {

    public enum CatalogEncryptionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case ssekms
        case ssekmswithservicerole
        case sdkUnknown(Swift.String)

        public static var allCases: [CatalogEncryptionMode] {
            return [
                .disabled,
                .ssekms,
                .ssekmswithservicerole
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .ssekms: return "SSE-KMS"
            case .ssekmswithservicerole: return "SSE-KMS-WITH-SERVICE-ROLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies the encryption-at-rest configuration for the Data Catalog.
    public struct EncryptionAtRest: Swift.Sendable {
        /// The encryption-at-rest mode for encrypting Data Catalog data.
        /// This member is required.
        public var catalogEncryptionMode: GlueClientTypes.CatalogEncryptionMode?
        /// The role that Glue assumes to encrypt and decrypt the Data Catalog objects on the caller's behalf.
        public var catalogEncryptionServiceRole: Swift.String?
        /// The ID of the KMS key to use for encryption at rest.
        public var sseAwsKmsKeyId: Swift.String?

        public init(
            catalogEncryptionMode: GlueClientTypes.CatalogEncryptionMode? = nil,
            catalogEncryptionServiceRole: Swift.String? = nil,
            sseAwsKmsKeyId: Swift.String? = nil
        )
        {
            self.catalogEncryptionMode = catalogEncryptionMode
            self.catalogEncryptionServiceRole = catalogEncryptionServiceRole
            self.sseAwsKmsKeyId = sseAwsKmsKeyId
        }
    }
}

extension GlueClientTypes {

    /// Contains configuration information for maintaining Data Catalog security.
    public struct DataCatalogEncryptionSettings: Swift.Sendable {
        /// When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption.
        public var connectionPasswordEncryption: GlueClientTypes.ConnectionPasswordEncryption?
        /// Specifies the encryption-at-rest configuration for the Data Catalog.
        public var encryptionAtRest: GlueClientTypes.EncryptionAtRest?

        public init(
            connectionPasswordEncryption: GlueClientTypes.ConnectionPasswordEncryption? = nil,
            encryptionAtRest: GlueClientTypes.EncryptionAtRest? = nil
        )
        {
            self.connectionPasswordEncryption = connectionPasswordEncryption
            self.encryptionAtRest = encryptionAtRest
        }
    }
}

public struct GetDataCatalogEncryptionSettingsOutput: Swift.Sendable {
    /// The requested security configuration.
    public var dataCatalogEncryptionSettings: GlueClientTypes.DataCatalogEncryptionSettings?

    public init(
        dataCatalogEncryptionSettings: GlueClientTypes.DataCatalogEncryptionSettings? = nil
    )
    {
        self.dataCatalogEncryptionSettings = dataCatalogEncryptionSettings
    }
}

public struct GetDataflowGraphInput: Swift.Sendable {
    /// The Python script to transform.
    public var pythonScript: Swift.String?

    public init(
        pythonScript: Swift.String? = nil
    )
    {
        self.pythonScript = pythonScript
    }
}

public struct GetDataflowGraphOutput: Swift.Sendable {
    /// A list of the edges in the resulting DAG.
    public var dagEdges: [GlueClientTypes.CodeGenEdge]?
    /// A list of the nodes in the resulting DAG.
    public var dagNodes: [GlueClientTypes.CodeGenNode]?

    public init(
        dagEdges: [GlueClientTypes.CodeGenEdge]? = nil,
        dagNodes: [GlueClientTypes.CodeGenNode]? = nil
    )
    {
        self.dagEdges = dagEdges
        self.dagNodes = dagNodes
    }
}

public struct GetDataQualityModelInput: Swift.Sendable {
    /// The Profile ID.
    /// This member is required.
    public var profileId: Swift.String?
    /// The Statistic ID.
    public var statisticId: Swift.String?

    public init(
        profileId: Swift.String? = nil,
        statisticId: Swift.String? = nil
    )
    {
        self.profileId = profileId
        self.statisticId = statisticId
    }
}

extension GlueClientTypes {

    public enum DataQualityModelStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DataQualityModelStatus] {
            return [
                .failed,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetDataQualityModelOutput: Swift.Sendable {
    /// The timestamp when the data quality model training completed.
    public var completedOn: Foundation.Date?
    /// The training failure reason.
    public var failureReason: Swift.String?
    /// The timestamp when the data quality model training started.
    public var startedOn: Foundation.Date?
    /// The training status of the data quality model.
    public var status: GlueClientTypes.DataQualityModelStatus?

    public init(
        completedOn: Foundation.Date? = nil,
        failureReason: Swift.String? = nil,
        startedOn: Foundation.Date? = nil,
        status: GlueClientTypes.DataQualityModelStatus? = nil
    )
    {
        self.completedOn = completedOn
        self.failureReason = failureReason
        self.startedOn = startedOn
        self.status = status
    }
}

public struct GetDataQualityModelResultInput: Swift.Sendable {
    /// The Profile ID.
    /// This member is required.
    public var profileId: Swift.String?
    /// The Statistic ID.
    /// This member is required.
    public var statisticId: Swift.String?

    public init(
        profileId: Swift.String? = nil,
        statisticId: Swift.String? = nil
    )
    {
        self.profileId = profileId
        self.statisticId = statisticId
    }
}

extension GlueClientTypes {

    /// The statistic model result.
    public struct StatisticModelResult: Swift.Sendable {
        /// The actual value.
        public var actualValue: Swift.Double?
        /// The date.
        public var date: Foundation.Date?
        /// The inclusion annotation.
        public var inclusionAnnotation: GlueClientTypes.InclusionAnnotationValue?
        /// The lower bound.
        public var lowerBound: Swift.Double?
        /// The predicted value.
        public var predictedValue: Swift.Double?
        /// The upper bound.
        public var upperBound: Swift.Double?

        public init(
            actualValue: Swift.Double? = nil,
            date: Foundation.Date? = nil,
            inclusionAnnotation: GlueClientTypes.InclusionAnnotationValue? = nil,
            lowerBound: Swift.Double? = nil,
            predictedValue: Swift.Double? = nil,
            upperBound: Swift.Double? = nil
        )
        {
            self.actualValue = actualValue
            self.date = date
            self.inclusionAnnotation = inclusionAnnotation
            self.lowerBound = lowerBound
            self.predictedValue = predictedValue
            self.upperBound = upperBound
        }
    }
}

public struct GetDataQualityModelResultOutput: Swift.Sendable {
    /// The timestamp when the data quality model training completed.
    public var completedOn: Foundation.Date?
    /// A list of StatisticModelResult
    public var model: [GlueClientTypes.StatisticModelResult]?

    public init(
        completedOn: Foundation.Date? = nil,
        model: [GlueClientTypes.StatisticModelResult]? = nil
    )
    {
        self.completedOn = completedOn
        self.model = model
    }
}

public struct GetDataQualityResultInput: Swift.Sendable {
    /// A unique result ID for the data quality result.
    /// This member is required.
    public var resultId: Swift.String?

    public init(
        resultId: Swift.String? = nil
    )
    {
        self.resultId = resultId
    }
}

public struct GetDataQualityResultOutput: Swift.Sendable {
    /// A list of DataQualityAnalyzerResult objects representing the results for each analyzer.
    public var analyzerResults: [GlueClientTypes.DataQualityAnalyzerResult]?
    /// The date and time when the run for this data quality result was completed.
    public var completedOn: Foundation.Date?
    /// The table associated with the data quality result, if any.
    public var dataSource: GlueClientTypes.DataSource?
    /// In the context of a job in Glue Studio, each node in the canvas is typically assigned some sort of name and data quality nodes will have names. In the case of multiple nodes, the evaluationContext can differentiate the nodes.
    public var evaluationContext: Swift.String?
    /// The job name associated with the data quality result, if any.
    public var jobName: Swift.String?
    /// The job run ID associated with the data quality result, if any.
    public var jobRunId: Swift.String?
    /// A list of DataQualityObservation objects representing the observations generated after evaluating the rules and analyzers.
    public var observations: [GlueClientTypes.DataQualityObservation]?
    /// The Profile ID for the data quality result.
    public var profileId: Swift.String?
    /// A unique result ID for the data quality result.
    public var resultId: Swift.String?
    /// A list of DataQualityRuleResult objects representing the results for each rule.
    public var ruleResults: [GlueClientTypes.DataQualityRuleResult]?
    /// The unique run ID associated with the ruleset evaluation.
    public var rulesetEvaluationRunId: Swift.String?
    /// The name of the ruleset associated with the data quality result.
    public var rulesetName: Swift.String?
    /// An aggregate data quality score. Represents the ratio of rules that passed to the total number of rules.
    public var score: Swift.Double?
    /// The date and time when the run for this data quality result started.
    public var startedOn: Foundation.Date?

    public init(
        analyzerResults: [GlueClientTypes.DataQualityAnalyzerResult]? = nil,
        completedOn: Foundation.Date? = nil,
        dataSource: GlueClientTypes.DataSource? = nil,
        evaluationContext: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobRunId: Swift.String? = nil,
        observations: [GlueClientTypes.DataQualityObservation]? = nil,
        profileId: Swift.String? = nil,
        resultId: Swift.String? = nil,
        ruleResults: [GlueClientTypes.DataQualityRuleResult]? = nil,
        rulesetEvaluationRunId: Swift.String? = nil,
        rulesetName: Swift.String? = nil,
        score: Swift.Double? = nil,
        startedOn: Foundation.Date? = nil
    )
    {
        self.analyzerResults = analyzerResults
        self.completedOn = completedOn
        self.dataSource = dataSource
        self.evaluationContext = evaluationContext
        self.jobName = jobName
        self.jobRunId = jobRunId
        self.observations = observations
        self.profileId = profileId
        self.resultId = resultId
        self.ruleResults = ruleResults
        self.rulesetEvaluationRunId = rulesetEvaluationRunId
        self.rulesetName = rulesetName
        self.score = score
        self.startedOn = startedOn
    }
}

public struct GetDataQualityRuleRecommendationRunInput: Swift.Sendable {
    /// The unique run identifier associated with this run.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        runId: Swift.String? = nil
    )
    {
        self.runId = runId
    }
}

public struct GetDataQualityRuleRecommendationRunOutput: Swift.Sendable {
    /// The date and time when this run was completed.
    public var completedOn: Foundation.Date?
    /// The name of the ruleset that was created by the run.
    public var createdRulesetName: Swift.String?
    /// The name of the security configuration created with the data quality encryption option.
    public var dataQualitySecurityConfiguration: Swift.String?
    /// The data source (an Glue table) associated with this run.
    public var dataSource: GlueClientTypes.DataSource?
    /// The error strings that are associated with the run.
    public var errorString: Swift.String?
    /// The amount of time (in seconds) that the run consumed resources.
    public var executionTime: Swift.Int
    /// A timestamp. The last point in time when this data quality rule recommendation run was modified.
    public var lastModifiedOn: Foundation.Date?
    /// The number of G.1X workers to be used in the run. The default is 5.
    public var numberOfWorkers: Swift.Int?
    /// When a start rule recommendation run completes, it creates a recommended ruleset (a set of rules). This member has those rules in Data Quality Definition Language (DQDL) format.
    public var recommendedRuleset: Swift.String?
    /// An IAM role supplied to encrypt the results of the run.
    public var role: Swift.String?
    /// The unique run identifier associated with this run.
    public var runId: Swift.String?
    /// The date and time when this run started.
    public var startedOn: Foundation.Date?
    /// The status for this run.
    public var status: GlueClientTypes.TaskStatusType?
    /// The timeout for a run in minutes. This is the maximum time that a run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
    public var timeout: Swift.Int?

    public init(
        completedOn: Foundation.Date? = nil,
        createdRulesetName: Swift.String? = nil,
        dataQualitySecurityConfiguration: Swift.String? = nil,
        dataSource: GlueClientTypes.DataSource? = nil,
        errorString: Swift.String? = nil,
        executionTime: Swift.Int = 0,
        lastModifiedOn: Foundation.Date? = nil,
        numberOfWorkers: Swift.Int? = nil,
        recommendedRuleset: Swift.String? = nil,
        role: Swift.String? = nil,
        runId: Swift.String? = nil,
        startedOn: Foundation.Date? = nil,
        status: GlueClientTypes.TaskStatusType? = nil,
        timeout: Swift.Int? = nil
    )
    {
        self.completedOn = completedOn
        self.createdRulesetName = createdRulesetName
        self.dataQualitySecurityConfiguration = dataQualitySecurityConfiguration
        self.dataSource = dataSource
        self.errorString = errorString
        self.executionTime = executionTime
        self.lastModifiedOn = lastModifiedOn
        self.numberOfWorkers = numberOfWorkers
        self.recommendedRuleset = recommendedRuleset
        self.role = role
        self.runId = runId
        self.startedOn = startedOn
        self.status = status
        self.timeout = timeout
    }
}

public struct GetDataQualityRulesetInput: Swift.Sendable {
    /// The name of the ruleset.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct GetDataQualityRulesetOutput: Swift.Sendable {
    /// A timestamp. The time and date that this data quality ruleset was created.
    public var createdOn: Foundation.Date?
    /// The name of the security configuration created with the data quality encryption option.
    public var dataQualitySecurityConfiguration: Swift.String?
    /// A description of the ruleset.
    public var description: Swift.String?
    /// A timestamp. The last point in time when this data quality ruleset was modified.
    public var lastModifiedOn: Foundation.Date?
    /// The name of the ruleset.
    public var name: Swift.String?
    /// When a ruleset was created from a recommendation run, this run ID is generated to link the two together.
    public var recommendationRunId: Swift.String?
    /// A Data Quality Definition Language (DQDL) ruleset. For more information, see the Glue developer guide.
    public var ruleset: Swift.String?
    /// The name and database name of the target table.
    public var targetTable: GlueClientTypes.DataQualityTargetTable?

    public init(
        createdOn: Foundation.Date? = nil,
        dataQualitySecurityConfiguration: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModifiedOn: Foundation.Date? = nil,
        name: Swift.String? = nil,
        recommendationRunId: Swift.String? = nil,
        ruleset: Swift.String? = nil,
        targetTable: GlueClientTypes.DataQualityTargetTable? = nil
    )
    {
        self.createdOn = createdOn
        self.dataQualitySecurityConfiguration = dataQualitySecurityConfiguration
        self.description = description
        self.lastModifiedOn = lastModifiedOn
        self.name = name
        self.recommendationRunId = recommendationRunId
        self.ruleset = ruleset
        self.targetTable = targetTable
    }
}

public struct GetDataQualityRulesetEvaluationRunInput: Swift.Sendable {
    /// The unique run identifier associated with this run.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        runId: Swift.String? = nil
    )
    {
        self.runId = runId
    }
}

extension GlueClientTypes {

    public enum DQCompositeRuleEvaluationMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case column
        case row
        case sdkUnknown(Swift.String)

        public static var allCases: [DQCompositeRuleEvaluationMethod] {
            return [
                .column,
                .row
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .column: return "COLUMN"
            case .row: return "ROW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Additional run options you can specify for an evaluation run.
    public struct DataQualityEvaluationRunAdditionalRunOptions: Swift.Sendable {
        /// Whether or not to enable CloudWatch metrics.
        public var cloudWatchMetricsEnabled: Swift.Bool?
        /// Set the evaluation method for composite rules in the ruleset to ROW/COLUMN
        public var compositeRuleEvaluationMethod: GlueClientTypes.DQCompositeRuleEvaluationMethod?
        /// Prefix for Amazon S3 to store results.
        public var resultsS3Prefix: Swift.String?

        public init(
            cloudWatchMetricsEnabled: Swift.Bool? = nil,
            compositeRuleEvaluationMethod: GlueClientTypes.DQCompositeRuleEvaluationMethod? = nil,
            resultsS3Prefix: Swift.String? = nil
        )
        {
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.compositeRuleEvaluationMethod = compositeRuleEvaluationMethod
            self.resultsS3Prefix = resultsS3Prefix
        }
    }
}

public struct GetDataQualityRulesetEvaluationRunOutput: Swift.Sendable {
    /// A map of reference strings to additional data sources you can specify for an evaluation run.
    public var additionalDataSources: [Swift.String: GlueClientTypes.DataSource]?
    /// Additional run options you can specify for an evaluation run.
    public var additionalRunOptions: GlueClientTypes.DataQualityEvaluationRunAdditionalRunOptions?
    /// The date and time when this run was completed.
    public var completedOn: Foundation.Date?
    /// The data source (an Glue table) associated with this evaluation run.
    public var dataSource: GlueClientTypes.DataSource?
    /// The error strings that are associated with the run.
    public var errorString: Swift.String?
    /// The amount of time (in seconds) that the run consumed resources.
    public var executionTime: Swift.Int
    /// A timestamp. The last point in time when this data quality rule recommendation run was modified.
    public var lastModifiedOn: Foundation.Date?
    /// The number of G.1X workers to be used in the run. The default is 5.
    public var numberOfWorkers: Swift.Int?
    /// A list of result IDs for the data quality results for the run.
    public var resultIds: [Swift.String]?
    /// An IAM role supplied to encrypt the results of the run.
    public var role: Swift.String?
    /// A list of ruleset names for the run. Currently, this parameter takes only one Ruleset name.
    public var rulesetNames: [Swift.String]?
    /// The unique run identifier associated with this run.
    public var runId: Swift.String?
    /// The date and time when this run started.
    public var startedOn: Foundation.Date?
    /// The status for this run.
    public var status: GlueClientTypes.TaskStatusType?
    /// The timeout for a run in minutes. This is the maximum time that a run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
    public var timeout: Swift.Int?

    public init(
        additionalDataSources: [Swift.String: GlueClientTypes.DataSource]? = nil,
        additionalRunOptions: GlueClientTypes.DataQualityEvaluationRunAdditionalRunOptions? = nil,
        completedOn: Foundation.Date? = nil,
        dataSource: GlueClientTypes.DataSource? = nil,
        errorString: Swift.String? = nil,
        executionTime: Swift.Int = 0,
        lastModifiedOn: Foundation.Date? = nil,
        numberOfWorkers: Swift.Int? = nil,
        resultIds: [Swift.String]? = nil,
        role: Swift.String? = nil,
        rulesetNames: [Swift.String]? = nil,
        runId: Swift.String? = nil,
        startedOn: Foundation.Date? = nil,
        status: GlueClientTypes.TaskStatusType? = nil,
        timeout: Swift.Int? = nil
    )
    {
        self.additionalDataSources = additionalDataSources
        self.additionalRunOptions = additionalRunOptions
        self.completedOn = completedOn
        self.dataSource = dataSource
        self.errorString = errorString
        self.executionTime = executionTime
        self.lastModifiedOn = lastModifiedOn
        self.numberOfWorkers = numberOfWorkers
        self.resultIds = resultIds
        self.role = role
        self.rulesetNames = rulesetNames
        self.runId = runId
        self.startedOn = startedOn
        self.status = status
        self.timeout = timeout
    }
}

public struct GetDevEndpointInput: Swift.Sendable {
    /// Name of the DevEndpoint to retrieve information for.
    /// This member is required.
    public var endpointName: Swift.String?

    public init(
        endpointName: Swift.String? = nil
    )
    {
        self.endpointName = endpointName
    }
}

public struct GetDevEndpointOutput: Swift.Sendable {
    /// A DevEndpoint definition.
    public var devEndpoint: GlueClientTypes.DevEndpoint?

    public init(
        devEndpoint: GlueClientTypes.DevEndpoint? = nil
    )
    {
        self.devEndpoint = devEndpoint
    }
}

public struct GetDevEndpointsInput: Swift.Sendable {
    /// The maximum size of information to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetDevEndpointsOutput: Swift.Sendable {
    /// A list of DevEndpoint definitions.
    public var devEndpoints: [GlueClientTypes.DevEndpoint]?
    /// A continuation token, if not all DevEndpoint definitions have yet been returned.
    public var nextToken: Swift.String?

    public init(
        devEndpoints: [GlueClientTypes.DevEndpoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devEndpoints = devEndpoints
        self.nextToken = nextToken
    }
}

public struct GetJobInput: Swift.Sendable {
    /// The name of the job definition to retrieve.
    /// This member is required.
    public var jobName: Swift.String?

    public init(
        jobName: Swift.String? = nil
    )
    {
        self.jobName = jobName
    }
}

public struct GetJobBookmarkInput: Swift.Sendable {
    /// The name of the job in question.
    /// This member is required.
    public var jobName: Swift.String?
    /// The unique run identifier associated with this job run.
    public var runId: Swift.String?

    public init(
        jobName: Swift.String? = nil,
        runId: Swift.String? = nil
    )
    {
        self.jobName = jobName
        self.runId = runId
    }
}

extension GlueClientTypes {

    /// Defines a point that a job can resume processing.
    public struct JobBookmarkEntry: Swift.Sendable {
        /// The attempt ID number.
        public var attempt: Swift.Int
        /// The bookmark itself.
        public var jobBookmark: Swift.String?
        /// The name of the job in question.
        public var jobName: Swift.String?
        /// The unique run identifier associated with the previous job run.
        public var previousRunId: Swift.String?
        /// The run ID number.
        public var run: Swift.Int
        /// The run ID number.
        public var runId: Swift.String?
        /// The version of the job.
        public var version: Swift.Int

        public init(
            attempt: Swift.Int = 0,
            jobBookmark: Swift.String? = nil,
            jobName: Swift.String? = nil,
            previousRunId: Swift.String? = nil,
            run: Swift.Int = 0,
            runId: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.attempt = attempt
            self.jobBookmark = jobBookmark
            self.jobName = jobName
            self.previousRunId = previousRunId
            self.run = run
            self.runId = runId
            self.version = version
        }
    }
}

public struct GetJobBookmarkOutput: Swift.Sendable {
    /// A structure that defines a point that a job can resume processing.
    public var jobBookmarkEntry: GlueClientTypes.JobBookmarkEntry?

    public init(
        jobBookmarkEntry: GlueClientTypes.JobBookmarkEntry? = nil
    )
    {
        self.jobBookmarkEntry = jobBookmarkEntry
    }
}

public struct GetJobRunInput: Swift.Sendable {
    /// Name of the job definition being run.
    /// This member is required.
    public var jobName: Swift.String?
    /// True if a list of predecessor runs should be returned.
    public var predecessorsIncluded: Swift.Bool?
    /// The ID of the job run.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        jobName: Swift.String? = nil,
        predecessorsIncluded: Swift.Bool? = false,
        runId: Swift.String? = nil
    )
    {
        self.jobName = jobName
        self.predecessorsIncluded = predecessorsIncluded
        self.runId = runId
    }
}

public struct GetJobRunOutput: Swift.Sendable {
    /// The requested job-run metadata.
    public var jobRun: GlueClientTypes.JobRun?

    public init(
        jobRun: GlueClientTypes.JobRun? = nil
    )
    {
        self.jobRun = jobRun
    }
}

public struct GetJobRunsInput: Swift.Sendable {
    /// The name of the job definition for which to retrieve all job runs.
    /// This member is required.
    public var jobName: Swift.String?
    /// The maximum size of the response.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?

    public init(
        jobName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobName = jobName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetJobRunsOutput: Swift.Sendable {
    /// A list of job-run metadata objects.
    public var jobRuns: [GlueClientTypes.JobRun]?
    /// A continuation token, if not all requested job runs have been returned.
    public var nextToken: Swift.String?

    public init(
        jobRuns: [GlueClientTypes.JobRun]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobRuns = jobRuns
        self.nextToken = nextToken
    }
}

public struct GetJobsInput: Swift.Sendable {
    /// The maximum size of the response.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GlueClientTypes {

    /// The location of resources.
    public struct Location: Swift.Sendable {
        /// An Amazon DynamoDB table location.
        public var dynamoDB: [GlueClientTypes.CodeGenNodeArg]?
        /// A JDBC location.
        public var jdbc: [GlueClientTypes.CodeGenNodeArg]?
        /// An Amazon Simple Storage Service (Amazon S3) location.
        public var s3: [GlueClientTypes.CodeGenNodeArg]?

        public init(
            dynamoDB: [GlueClientTypes.CodeGenNodeArg]? = nil,
            jdbc: [GlueClientTypes.CodeGenNodeArg]? = nil,
            s3: [GlueClientTypes.CodeGenNodeArg]? = nil
        )
        {
            self.dynamoDB = dynamoDB
            self.jdbc = jdbc
            self.s3 = s3
        }
    }
}

extension GlueClientTypes {

    /// Specifies a table definition in the Glue Data Catalog.
    public struct CatalogEntry: Swift.Sendable {
        /// The database in which the table metadata resides.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The name of the table in question.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.tableName = tableName
        }
    }
}

public struct GetMappingInput: Swift.Sendable {
    /// Parameters for the mapping.
    public var location: GlueClientTypes.Location?
    /// A list of target tables.
    public var sinks: [GlueClientTypes.CatalogEntry]?
    /// Specifies the source table.
    /// This member is required.
    public var source: GlueClientTypes.CatalogEntry?

    public init(
        location: GlueClientTypes.Location? = nil,
        sinks: [GlueClientTypes.CatalogEntry]? = nil,
        source: GlueClientTypes.CatalogEntry? = nil
    )
    {
        self.location = location
        self.sinks = sinks
        self.source = source
    }
}

extension GlueClientTypes {

    /// Defines a mapping.
    public struct MappingEntry: Swift.Sendable {
        /// The source path.
        public var sourcePath: Swift.String?
        /// The name of the source table.
        public var sourceTable: Swift.String?
        /// The source type.
        public var sourceType: Swift.String?
        /// The target path.
        public var targetPath: Swift.String?
        /// The target table.
        public var targetTable: Swift.String?
        /// The target type.
        public var targetType: Swift.String?

        public init(
            sourcePath: Swift.String? = nil,
            sourceTable: Swift.String? = nil,
            sourceType: Swift.String? = nil,
            targetPath: Swift.String? = nil,
            targetTable: Swift.String? = nil,
            targetType: Swift.String? = nil
        )
        {
            self.sourcePath = sourcePath
            self.sourceTable = sourceTable
            self.sourceType = sourceType
            self.targetPath = targetPath
            self.targetTable = targetTable
            self.targetType = targetType
        }
    }
}

public struct GetMappingOutput: Swift.Sendable {
    /// A list of mappings to the specified targets.
    /// This member is required.
    public var mapping: [GlueClientTypes.MappingEntry]?

    public init(
        mapping: [GlueClientTypes.MappingEntry]? = nil
    )
    {
        self.mapping = mapping
    }
}

public struct GetMLTaskRunInput: Swift.Sendable {
    /// The unique identifier of the task run.
    /// This member is required.
    public var taskRunId: Swift.String?
    /// The unique identifier of the machine learning transform.
    /// This member is required.
    public var transformId: Swift.String?

    public init(
        taskRunId: Swift.String? = nil,
        transformId: Swift.String? = nil
    )
    {
        self.taskRunId = taskRunId
        self.transformId = transformId
    }
}

extension GlueClientTypes {

    /// Specifies configuration properties for an exporting labels task run.
    public struct ExportLabelsTaskRunProperties: Swift.Sendable {
        /// The Amazon Simple Storage Service (Amazon S3) path where you will export the labels.
        public var outputS3Path: Swift.String?

        public init(
            outputS3Path: Swift.String? = nil
        )
        {
            self.outputS3Path = outputS3Path
        }
    }
}

extension GlueClientTypes {

    /// Specifies configuration properties for a Find Matches task run.
    public struct FindMatchesTaskRunProperties: Swift.Sendable {
        /// The job ID for the Find Matches task run.
        public var jobId: Swift.String?
        /// The name assigned to the job for the Find Matches task run.
        public var jobName: Swift.String?
        /// The job run ID for the Find Matches task run.
        public var jobRunId: Swift.String?

        public init(
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobRunId: Swift.String? = nil
        )
        {
            self.jobId = jobId
            self.jobName = jobName
            self.jobRunId = jobRunId
        }
    }
}

extension GlueClientTypes {

    /// Specifies configuration properties for an importing labels task run.
    public struct ImportLabelsTaskRunProperties: Swift.Sendable {
        /// The Amazon Simple Storage Service (Amazon S3) path from where you will import the labels.
        public var inputS3Path: Swift.String?
        /// Indicates whether to overwrite your existing labels.
        public var replace: Swift.Bool

        public init(
            inputS3Path: Swift.String? = nil,
            replace: Swift.Bool = false
        )
        {
            self.inputS3Path = inputS3Path
            self.replace = replace
        }
    }
}

extension GlueClientTypes {

    /// Specifies configuration properties for a labeling set generation task run.
    public struct LabelingSetGenerationTaskRunProperties: Swift.Sendable {
        /// The Amazon Simple Storage Service (Amazon S3) path where you will generate the labeling set.
        public var outputS3Path: Swift.String?

        public init(
            outputS3Path: Swift.String? = nil
        )
        {
            self.outputS3Path = outputS3Path
        }
    }
}

extension GlueClientTypes {

    public enum TaskType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case evaluation
        case exportLabels
        case findMatches
        case importLabels
        case labelingSetGeneration
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskType] {
            return [
                .evaluation,
                .exportLabels,
                .findMatches,
                .importLabels,
                .labelingSetGeneration
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .evaluation: return "EVALUATION"
            case .exportLabels: return "EXPORT_LABELS"
            case .findMatches: return "FIND_MATCHES"
            case .importLabels: return "IMPORT_LABELS"
            case .labelingSetGeneration: return "LABELING_SET_GENERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The configuration properties for the task run.
    public struct TaskRunProperties: Swift.Sendable {
        /// The configuration properties for an exporting labels task run.
        public var exportLabelsTaskRunProperties: GlueClientTypes.ExportLabelsTaskRunProperties?
        /// The configuration properties for a find matches task run.
        public var findMatchesTaskRunProperties: GlueClientTypes.FindMatchesTaskRunProperties?
        /// The configuration properties for an importing labels task run.
        public var importLabelsTaskRunProperties: GlueClientTypes.ImportLabelsTaskRunProperties?
        /// The configuration properties for a labeling set generation task run.
        public var labelingSetGenerationTaskRunProperties: GlueClientTypes.LabelingSetGenerationTaskRunProperties?
        /// The type of task run.
        public var taskType: GlueClientTypes.TaskType?

        public init(
            exportLabelsTaskRunProperties: GlueClientTypes.ExportLabelsTaskRunProperties? = nil,
            findMatchesTaskRunProperties: GlueClientTypes.FindMatchesTaskRunProperties? = nil,
            importLabelsTaskRunProperties: GlueClientTypes.ImportLabelsTaskRunProperties? = nil,
            labelingSetGenerationTaskRunProperties: GlueClientTypes.LabelingSetGenerationTaskRunProperties? = nil,
            taskType: GlueClientTypes.TaskType? = nil
        )
        {
            self.exportLabelsTaskRunProperties = exportLabelsTaskRunProperties
            self.findMatchesTaskRunProperties = findMatchesTaskRunProperties
            self.importLabelsTaskRunProperties = importLabelsTaskRunProperties
            self.labelingSetGenerationTaskRunProperties = labelingSetGenerationTaskRunProperties
            self.taskType = taskType
        }
    }
}

public struct GetMLTaskRunOutput: Swift.Sendable {
    /// The date and time when this task run was completed.
    public var completedOn: Foundation.Date?
    /// The error strings that are associated with the task run.
    public var errorString: Swift.String?
    /// The amount of time (in seconds) that the task run consumed resources.
    public var executionTime: Swift.Int
    /// The date and time when this task run was last modified.
    public var lastModifiedOn: Foundation.Date?
    /// The names of the log groups that are associated with the task run.
    public var logGroupName: Swift.String?
    /// The list of properties that are associated with the task run.
    public var properties: GlueClientTypes.TaskRunProperties?
    /// The date and time when this task run started.
    public var startedOn: Foundation.Date?
    /// The status for this task run.
    public var status: GlueClientTypes.TaskStatusType?
    /// The unique run identifier associated with this run.
    public var taskRunId: Swift.String?
    /// The unique identifier of the task run.
    public var transformId: Swift.String?

    public init(
        completedOn: Foundation.Date? = nil,
        errorString: Swift.String? = nil,
        executionTime: Swift.Int = 0,
        lastModifiedOn: Foundation.Date? = nil,
        logGroupName: Swift.String? = nil,
        properties: GlueClientTypes.TaskRunProperties? = nil,
        startedOn: Foundation.Date? = nil,
        status: GlueClientTypes.TaskStatusType? = nil,
        taskRunId: Swift.String? = nil,
        transformId: Swift.String? = nil
    )
    {
        self.completedOn = completedOn
        self.errorString = errorString
        self.executionTime = executionTime
        self.lastModifiedOn = lastModifiedOn
        self.logGroupName = logGroupName
        self.properties = properties
        self.startedOn = startedOn
        self.status = status
        self.taskRunId = taskRunId
        self.transformId = transformId
    }
}

extension GlueClientTypes {

    /// The criteria that are used to filter the task runs for the machine learning transform.
    public struct TaskRunFilterCriteria: Swift.Sendable {
        /// Filter on task runs started after this date.
        public var startedAfter: Foundation.Date?
        /// Filter on task runs started before this date.
        public var startedBefore: Foundation.Date?
        /// The current status of the task run.
        public var status: GlueClientTypes.TaskStatusType?
        /// The type of task run.
        public var taskRunType: GlueClientTypes.TaskType?

        public init(
            startedAfter: Foundation.Date? = nil,
            startedBefore: Foundation.Date? = nil,
            status: GlueClientTypes.TaskStatusType? = nil,
            taskRunType: GlueClientTypes.TaskType? = nil
        )
        {
            self.startedAfter = startedAfter
            self.startedBefore = startedBefore
            self.status = status
            self.taskRunType = taskRunType
        }
    }
}

extension GlueClientTypes {

    public enum TaskRunSortColumnType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case started
        case status
        case taskRunType
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskRunSortColumnType] {
            return [
                .started,
                .status,
                .taskRunType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .status: return "STATUS"
            case .taskRunType: return "TASK_RUN_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum SortDirectionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortDirectionType] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The sorting criteria that are used to sort the list of task runs for the machine learning transform.
    public struct TaskRunSortCriteria: Swift.Sendable {
        /// The column to be used to sort the list of task runs for the machine learning transform.
        /// This member is required.
        public var column: GlueClientTypes.TaskRunSortColumnType?
        /// The sort direction to be used to sort the list of task runs for the machine learning transform.
        /// This member is required.
        public var sortDirection: GlueClientTypes.SortDirectionType?

        public init(
            column: GlueClientTypes.TaskRunSortColumnType? = nil,
            sortDirection: GlueClientTypes.SortDirectionType? = nil
        )
        {
            self.column = column
            self.sortDirection = sortDirection
        }
    }
}

public struct GetMLTaskRunsInput: Swift.Sendable {
    /// The filter criteria, in the TaskRunFilterCriteria structure, for the task run.
    public var filter: GlueClientTypes.TaskRunFilterCriteria?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token for pagination of the results. The default is empty.
    public var nextToken: Swift.String?
    /// The sorting criteria, in the TaskRunSortCriteria structure, for the task run.
    public var sort: GlueClientTypes.TaskRunSortCriteria?
    /// The unique identifier of the machine learning transform.
    /// This member is required.
    public var transformId: Swift.String?

    public init(
        filter: GlueClientTypes.TaskRunFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: GlueClientTypes.TaskRunSortCriteria? = nil,
        transformId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
        self.transformId = transformId
    }
}

extension GlueClientTypes {

    /// The sampling parameters that are associated with the machine learning transform.
    public struct TaskRun: Swift.Sendable {
        /// The last point in time that the requested task run was completed.
        public var completedOn: Foundation.Date?
        /// The list of error strings associated with this task run.
        public var errorString: Swift.String?
        /// The amount of time (in seconds) that the task run consumed resources.
        public var executionTime: Swift.Int
        /// The last point in time that the requested task run was updated.
        public var lastModifiedOn: Foundation.Date?
        /// The names of the log group for secure logging, associated with this task run.
        public var logGroupName: Swift.String?
        /// Specifies configuration properties associated with this task run.
        public var properties: GlueClientTypes.TaskRunProperties?
        /// The date and time that this task run started.
        public var startedOn: Foundation.Date?
        /// The current status of the requested task run.
        public var status: GlueClientTypes.TaskStatusType?
        /// The unique identifier for this task run.
        public var taskRunId: Swift.String?
        /// The unique identifier for the transform.
        public var transformId: Swift.String?

        public init(
            completedOn: Foundation.Date? = nil,
            errorString: Swift.String? = nil,
            executionTime: Swift.Int = 0,
            lastModifiedOn: Foundation.Date? = nil,
            logGroupName: Swift.String? = nil,
            properties: GlueClientTypes.TaskRunProperties? = nil,
            startedOn: Foundation.Date? = nil,
            status: GlueClientTypes.TaskStatusType? = nil,
            taskRunId: Swift.String? = nil,
            transformId: Swift.String? = nil
        )
        {
            self.completedOn = completedOn
            self.errorString = errorString
            self.executionTime = executionTime
            self.lastModifiedOn = lastModifiedOn
            self.logGroupName = logGroupName
            self.properties = properties
            self.startedOn = startedOn
            self.status = status
            self.taskRunId = taskRunId
            self.transformId = transformId
        }
    }
}

public struct GetMLTaskRunsOutput: Swift.Sendable {
    /// A pagination token, if more results are available.
    public var nextToken: Swift.String?
    /// A list of task runs that are associated with the transform.
    public var taskRuns: [GlueClientTypes.TaskRun]?

    public init(
        nextToken: Swift.String? = nil,
        taskRuns: [GlueClientTypes.TaskRun]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskRuns = taskRuns
    }
}

public struct GetMLTransformInput: Swift.Sendable {
    /// The unique identifier of the transform, generated at the time that the transform was created.
    /// This member is required.
    public var transformId: Swift.String?

    public init(
        transformId: Swift.String? = nil
    )
    {
        self.transformId = transformId
    }
}

extension GlueClientTypes {

    /// A structure containing the column name and column importance score for a column. Column importance helps you understand how columns contribute to your model, by identifying which columns in your records are more important than others.
    public struct ColumnImportance: Swift.Sendable {
        /// The name of a column.
        public var columnName: Swift.String?
        /// The column importance score for the column, as a decimal.
        public var importance: Swift.Double?

        public init(
            columnName: Swift.String? = nil,
            importance: Swift.Double? = nil
        )
        {
            self.columnName = columnName
            self.importance = importance
        }
    }
}

extension GlueClientTypes {

    /// The confusion matrix shows you what your transform is predicting accurately and what types of errors it is making. For more information, see [Confusion matrix](https://en.wikipedia.org/wiki/Confusion_matrix) in Wikipedia.
    public struct ConfusionMatrix: Swift.Sendable {
        /// The number of matches in the data that the transform didn't find, in the confusion matrix for your transform.
        public var numFalseNegatives: Swift.Int?
        /// The number of nonmatches in the data that the transform incorrectly classified as a match, in the confusion matrix for your transform.
        public var numFalsePositives: Swift.Int?
        /// The number of nonmatches in the data that the transform correctly rejected, in the confusion matrix for your transform.
        public var numTrueNegatives: Swift.Int?
        /// The number of matches in the data that the transform correctly found, in the confusion matrix for your transform.
        public var numTruePositives: Swift.Int?

        public init(
            numFalseNegatives: Swift.Int? = nil,
            numFalsePositives: Swift.Int? = nil,
            numTrueNegatives: Swift.Int? = nil,
            numTruePositives: Swift.Int? = nil
        )
        {
            self.numFalseNegatives = numFalseNegatives
            self.numFalsePositives = numFalsePositives
            self.numTrueNegatives = numTrueNegatives
            self.numTruePositives = numTruePositives
        }
    }
}

extension GlueClientTypes {

    /// The evaluation metrics for the find matches algorithm. The quality of your machine learning transform is measured by getting your transform to predict some matches and comparing the results to known matches from the same dataset. The quality metrics are based on a subset of your data, so they are not precise.
    public struct FindMatchesMetrics: Swift.Sendable {
        /// The area under the precision/recall curve (AUPRC) is a single number measuring the overall quality of the transform, that is independent of the choice made for precision vs. recall. Higher values indicate that you have a more attractive precision vs. recall tradeoff. For more information, see [Precision and recall](https://en.wikipedia.org/wiki/Precision_and_recall) in Wikipedia.
        public var areaUnderPRCurve: Swift.Double?
        /// A list of ColumnImportance structures containing column importance metrics, sorted in order of descending importance.
        public var columnImportances: [GlueClientTypes.ColumnImportance]?
        /// The confusion matrix shows you what your transform is predicting accurately and what types of errors it is making. For more information, see [Confusion matrix](https://en.wikipedia.org/wiki/Confusion_matrix) in Wikipedia.
        public var confusionMatrix: GlueClientTypes.ConfusionMatrix?
        /// The maximum F1 metric indicates the transform's accuracy between 0 and 1, where 1 is the best accuracy. For more information, see [F1 score](https://en.wikipedia.org/wiki/F1_score) in Wikipedia.
        public var f1: Swift.Double?
        /// The precision metric indicates when often your transform is correct when it predicts a match. Specifically, it measures how well the transform finds true positives from the total true positives possible. For more information, see [Precision and recall](https://en.wikipedia.org/wiki/Precision_and_recall) in Wikipedia.
        public var precision: Swift.Double?
        /// The recall metric indicates that for an actual match, how often your transform predicts the match. Specifically, it measures how well the transform finds true positives from the total records in the source data. For more information, see [Precision and recall](https://en.wikipedia.org/wiki/Precision_and_recall) in Wikipedia.
        public var recall: Swift.Double?

        public init(
            areaUnderPRCurve: Swift.Double? = nil,
            columnImportances: [GlueClientTypes.ColumnImportance]? = nil,
            confusionMatrix: GlueClientTypes.ConfusionMatrix? = nil,
            f1: Swift.Double? = nil,
            precision: Swift.Double? = nil,
            recall: Swift.Double? = nil
        )
        {
            self.areaUnderPRCurve = areaUnderPRCurve
            self.columnImportances = columnImportances
            self.confusionMatrix = confusionMatrix
            self.f1 = f1
            self.precision = precision
            self.recall = recall
        }
    }
}

extension GlueClientTypes {

    /// Evaluation metrics provide an estimate of the quality of your machine learning transform.
    public struct EvaluationMetrics: Swift.Sendable {
        /// The evaluation metrics for the find matches algorithm.
        public var findMatchesMetrics: GlueClientTypes.FindMatchesMetrics?
        /// The type of machine learning transform.
        /// This member is required.
        public var transformType: GlueClientTypes.TransformType?

        public init(
            findMatchesMetrics: GlueClientTypes.FindMatchesMetrics? = nil,
            transformType: GlueClientTypes.TransformType? = nil
        )
        {
            self.findMatchesMetrics = findMatchesMetrics
            self.transformType = transformType
        }
    }
}

extension GlueClientTypes {

    /// A key-value pair representing a column and data type that this transform can run against. The Schema parameter of the MLTransform may contain up to 100 of these structures.
    public struct SchemaColumn: Swift.Sendable {
        /// The type of data in the column.
        public var dataType: Swift.String?
        /// The name of the column.
        public var name: Swift.String?

        public init(
            dataType: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.name = name
        }
    }
}

extension GlueClientTypes {

    public enum TransformStatusType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleting
        case notReady
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [TransformStatusType] {
            return [
                .deleting,
                .notReady,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .notReady: return "NOT_READY"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetMLTransformOutput: Swift.Sendable {
    /// The date and time when the transform was created.
    public var createdOn: Foundation.Date?
    /// A description of the transform.
    public var description: Swift.String?
    /// The latest evaluation metrics.
    public var evaluationMetrics: GlueClientTypes.EvaluationMetrics?
    /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see [Glue Versions](https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions) in the developer guide.
    public var glueVersion: Swift.String?
    /// A list of Glue table definitions used by the transform.
    public var inputRecordTables: [GlueClientTypes.GlueTable]?
    /// The number of labels available for this transform.
    public var labelCount: Swift.Int
    /// The date and time when the transform was last modified.
    public var lastModifiedOn: Foundation.Date?
    /// The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [Glue pricing page](https://aws.amazon.com/glue/pricing/). When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only.
    public var maxCapacity: Swift.Double?
    /// The maximum number of times to retry a task for this transform after a task run fails.
    public var maxRetries: Swift.Int?
    /// The unique name given to the transform when it was created.
    public var name: Swift.String?
    /// The number of workers of a defined workerType that are allocated when this task runs.
    public var numberOfWorkers: Swift.Int?
    /// The configuration parameters that are specific to the algorithm used.
    public var parameters: GlueClientTypes.TransformParameters?
    /// The name or Amazon Resource Name (ARN) of the IAM role with the required permissions.
    public var role: Swift.String?
    /// The Map object that represents the schema that this transform accepts. Has an upper bound of 100 columns.
    public var schema: [GlueClientTypes.SchemaColumn]?
    /// The last known status of the transform (to indicate whether it can be used or not). One of "NOT_READY", "READY", or "DELETING".
    public var status: GlueClientTypes.TransformStatusType?
    /// The timeout for a task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
    public var timeout: Swift.Int?
    /// The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.
    public var transformEncryption: GlueClientTypes.TransformEncryption?
    /// The unique identifier of the transform, generated at the time that the transform was created.
    public var transformId: Swift.String?
    /// The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.
    ///
    /// * For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.
    ///
    /// * For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.
    ///
    /// * For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.
    public var workerType: GlueClientTypes.WorkerType?

    public init(
        createdOn: Foundation.Date? = nil,
        description: Swift.String? = nil,
        evaluationMetrics: GlueClientTypes.EvaluationMetrics? = nil,
        glueVersion: Swift.String? = nil,
        inputRecordTables: [GlueClientTypes.GlueTable]? = nil,
        labelCount: Swift.Int = 0,
        lastModifiedOn: Foundation.Date? = nil,
        maxCapacity: Swift.Double? = nil,
        maxRetries: Swift.Int? = nil,
        name: Swift.String? = nil,
        numberOfWorkers: Swift.Int? = nil,
        parameters: GlueClientTypes.TransformParameters? = nil,
        role: Swift.String? = nil,
        schema: [GlueClientTypes.SchemaColumn]? = nil,
        status: GlueClientTypes.TransformStatusType? = nil,
        timeout: Swift.Int? = nil,
        transformEncryption: GlueClientTypes.TransformEncryption? = nil,
        transformId: Swift.String? = nil,
        workerType: GlueClientTypes.WorkerType? = nil
    )
    {
        self.createdOn = createdOn
        self.description = description
        self.evaluationMetrics = evaluationMetrics
        self.glueVersion = glueVersion
        self.inputRecordTables = inputRecordTables
        self.labelCount = labelCount
        self.lastModifiedOn = lastModifiedOn
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.numberOfWorkers = numberOfWorkers
        self.parameters = parameters
        self.role = role
        self.schema = schema
        self.status = status
        self.timeout = timeout
        self.transformEncryption = transformEncryption
        self.transformId = transformId
        self.workerType = workerType
    }
}

extension GlueClientTypes {

    /// The criteria used to filter the machine learning transforms.
    public struct TransformFilterCriteria: Swift.Sendable {
        /// The time and date after which the transforms were created.
        public var createdAfter: Foundation.Date?
        /// The time and date before which the transforms were created.
        public var createdBefore: Foundation.Date?
        /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see [Glue Versions](https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions) in the developer guide.
        public var glueVersion: Swift.String?
        /// Filter on transforms last modified after this date.
        public var lastModifiedAfter: Foundation.Date?
        /// Filter on transforms last modified before this date.
        public var lastModifiedBefore: Foundation.Date?
        /// A unique transform name that is used to filter the machine learning transforms.
        public var name: Swift.String?
        /// Filters on datasets with a specific schema. The Map object is an array of key-value pairs representing the schema this transform accepts, where Column is the name of a column, and Type is the type of the data such as an integer or string. Has an upper bound of 100 columns.
        public var schema: [GlueClientTypes.SchemaColumn]?
        /// Filters the list of machine learning transforms by the last known status of the transforms (to indicate whether a transform can be used or not). One of "NOT_READY", "READY", or "DELETING".
        public var status: GlueClientTypes.TransformStatusType?
        /// The type of machine learning transform that is used to filter the machine learning transforms.
        public var transformType: GlueClientTypes.TransformType?

        public init(
            createdAfter: Foundation.Date? = nil,
            createdBefore: Foundation.Date? = nil,
            glueVersion: Swift.String? = nil,
            lastModifiedAfter: Foundation.Date? = nil,
            lastModifiedBefore: Foundation.Date? = nil,
            name: Swift.String? = nil,
            schema: [GlueClientTypes.SchemaColumn]? = nil,
            status: GlueClientTypes.TransformStatusType? = nil,
            transformType: GlueClientTypes.TransformType? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.glueVersion = glueVersion
            self.lastModifiedAfter = lastModifiedAfter
            self.lastModifiedBefore = lastModifiedBefore
            self.name = name
            self.schema = schema
            self.status = status
            self.transformType = transformType
        }
    }
}

extension GlueClientTypes {

    public enum TransformSortColumnType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case lastModified
        case name
        case status
        case transformType
        case sdkUnknown(Swift.String)

        public static var allCases: [TransformSortColumnType] {
            return [
                .created,
                .lastModified,
                .name,
                .status,
                .transformType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .lastModified: return "LAST_MODIFIED"
            case .name: return "NAME"
            case .status: return "STATUS"
            case .transformType: return "TRANSFORM_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The sorting criteria that are associated with the machine learning transform.
    public struct TransformSortCriteria: Swift.Sendable {
        /// The column to be used in the sorting criteria that are associated with the machine learning transform.
        /// This member is required.
        public var column: GlueClientTypes.TransformSortColumnType?
        /// The sort direction to be used in the sorting criteria that are associated with the machine learning transform.
        /// This member is required.
        public var sortDirection: GlueClientTypes.SortDirectionType?

        public init(
            column: GlueClientTypes.TransformSortColumnType? = nil,
            sortDirection: GlueClientTypes.SortDirectionType? = nil
        )
        {
            self.column = column
            self.sortDirection = sortDirection
        }
    }
}

public struct GetMLTransformsInput: Swift.Sendable {
    /// The filter transformation criteria.
    public var filter: GlueClientTypes.TransformFilterCriteria?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A paginated token to offset the results.
    public var nextToken: Swift.String?
    /// The sorting criteria.
    public var sort: GlueClientTypes.TransformSortCriteria?

    public init(
        filter: GlueClientTypes.TransformFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: GlueClientTypes.TransformSortCriteria? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

extension GlueClientTypes {

    /// A structure for a machine learning transform.
    public struct MLTransform: Swift.Sendable {
        /// A timestamp. The time and date that this machine learning transform was created.
        public var createdOn: Foundation.Date?
        /// A user-defined, long-form description text for the machine learning transform. Descriptions are not guaranteed to be unique and can be changed at any time.
        public var description: Swift.String?
        /// An EvaluationMetrics object. Evaluation metrics provide an estimate of the quality of your machine learning transform.
        public var evaluationMetrics: GlueClientTypes.EvaluationMetrics?
        /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see [Glue Versions](https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions) in the developer guide.
        public var glueVersion: Swift.String?
        /// A list of Glue table definitions used by the transform.
        public var inputRecordTables: [GlueClientTypes.GlueTable]?
        /// A count identifier for the labeling files generated by Glue for this transform. As you create a better transform, you can iteratively download, label, and upload the labeling file.
        public var labelCount: Swift.Int
        /// A timestamp. The last point in time when this machine learning transform was modified.
        public var lastModifiedOn: Foundation.Date?
        /// The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [Glue pricing page](http://aws.amazon.com/glue/pricing/). MaxCapacity is a mutually exclusive option with NumberOfWorkers and WorkerType.
        ///
        /// * If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set.
        ///
        /// * If MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set.
        ///
        /// * If WorkerType is set, then NumberOfWorkers is required (and vice versa).
        ///
        /// * MaxCapacity and NumberOfWorkers must both be at least 1.
        ///
        ///
        /// When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only.
        public var maxCapacity: Swift.Double?
        /// The maximum number of times to retry after an MLTaskRun of the machine learning transform fails.
        public var maxRetries: Swift.Int?
        /// A user-defined name for the machine learning transform. Names are not guaranteed unique and can be changed at any time.
        public var name: Swift.String?
        /// The number of workers of a defined workerType that are allocated when a task of the transform runs. If WorkerType is set, then NumberOfWorkers is required (and vice versa).
        public var numberOfWorkers: Swift.Int?
        /// A TransformParameters object. You can use parameters to tune (customize) the behavior of the machine learning transform by specifying what data it learns from and your preference on various tradeoffs (such as precious vs. recall, or accuracy vs. cost).
        public var parameters: GlueClientTypes.TransformParameters?
        /// The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both Glue service role permissions to Glue resources, and Amazon S3 permissions required by the transform.
        ///
        /// * This role needs Glue service role permissions to allow access to resources in Glue. See [Attach a Policy to IAM Users That Access Glue](https://docs.aws.amazon.com/glue/latest/dg/attach-policy-iam-user.html).
        ///
        /// * This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.
        public var role: Swift.String?
        /// A map of key-value pairs representing the columns and data types that this transform can run against. Has an upper bound of 100 columns.
        public var schema: [GlueClientTypes.SchemaColumn]?
        /// The current status of the machine learning transform.
        public var status: GlueClientTypes.TransformStatusType?
        /// The timeout in minutes of the machine learning transform.
        public var timeout: Swift.Int?
        /// The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.
        public var transformEncryption: GlueClientTypes.TransformEncryption?
        /// The unique transform ID that is generated for the machine learning transform. The ID is guaranteed to be unique and does not change.
        public var transformId: Swift.String?
        /// The type of predefined worker that is allocated when a task of this transform runs. Accepts a value of Standard, G.1X, or G.2X.
        ///
        /// * For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.
        ///
        /// * For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.
        ///
        /// * For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.
        ///
        ///
        /// MaxCapacity is a mutually exclusive option with NumberOfWorkers and WorkerType.
        ///
        /// * If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set.
        ///
        /// * If MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set.
        ///
        /// * If WorkerType is set, then NumberOfWorkers is required (and vice versa).
        ///
        /// * MaxCapacity and NumberOfWorkers must both be at least 1.
        public var workerType: GlueClientTypes.WorkerType?

        public init(
            createdOn: Foundation.Date? = nil,
            description: Swift.String? = nil,
            evaluationMetrics: GlueClientTypes.EvaluationMetrics? = nil,
            glueVersion: Swift.String? = nil,
            inputRecordTables: [GlueClientTypes.GlueTable]? = nil,
            labelCount: Swift.Int = 0,
            lastModifiedOn: Foundation.Date? = nil,
            maxCapacity: Swift.Double? = nil,
            maxRetries: Swift.Int? = nil,
            name: Swift.String? = nil,
            numberOfWorkers: Swift.Int? = nil,
            parameters: GlueClientTypes.TransformParameters? = nil,
            role: Swift.String? = nil,
            schema: [GlueClientTypes.SchemaColumn]? = nil,
            status: GlueClientTypes.TransformStatusType? = nil,
            timeout: Swift.Int? = nil,
            transformEncryption: GlueClientTypes.TransformEncryption? = nil,
            transformId: Swift.String? = nil,
            workerType: GlueClientTypes.WorkerType? = nil
        )
        {
            self.createdOn = createdOn
            self.description = description
            self.evaluationMetrics = evaluationMetrics
            self.glueVersion = glueVersion
            self.inputRecordTables = inputRecordTables
            self.labelCount = labelCount
            self.lastModifiedOn = lastModifiedOn
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.numberOfWorkers = numberOfWorkers
            self.parameters = parameters
            self.role = role
            self.schema = schema
            self.status = status
            self.timeout = timeout
            self.transformEncryption = transformEncryption
            self.transformId = transformId
            self.workerType = workerType
        }
    }
}

public struct GetMLTransformsOutput: Swift.Sendable {
    /// A pagination token, if more results are available.
    public var nextToken: Swift.String?
    /// A list of machine learning transforms.
    /// This member is required.
    public var transforms: [GlueClientTypes.MLTransform]?

    public init(
        nextToken: Swift.String? = nil,
        transforms: [GlueClientTypes.MLTransform]? = nil
    )
    {
        self.nextToken = nextToken
        self.transforms = transforms
    }
}

public struct GetPartitionInput: Swift.Sendable {
    /// The ID of the Data Catalog where the partition in question resides. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the catalog database where the partition resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The values that define the partition.
    /// This member is required.
    public var partitionValues: [Swift.String]?
    /// The name of the partition's table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        partitionValues: [Swift.String]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionValues = partitionValues
        self.tableName = tableName
    }
}

public struct GetPartitionOutput: Swift.Sendable {
    /// The requested information, in the form of a Partition object.
    public var partition: GlueClientTypes.Partition?

    public init(
        partition: GlueClientTypes.Partition? = nil
    )
    {
        self.partition = partition
    }
}

public struct GetPartitionIndexesInput: Swift.Sendable {
    /// The catalog ID where the table resides.
    public var catalogId: Swift.String?
    /// Specifies the name of a database from which you want to retrieve partition indexes.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A continuation token, included if this is a continuation call.
    public var nextToken: Swift.String?
    /// Specifies the name of a table for which you want to retrieve the partition indexes.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.nextToken = nextToken
        self.tableName = tableName
    }
}

extension GlueClientTypes {

    public enum BackfillErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case encryptedPartitionError
        case internalError
        case invalidPartitionTypeDataError
        case missingPartitionValueError
        case unsupportedPartitionCharacterError
        case sdkUnknown(Swift.String)

        public static var allCases: [BackfillErrorCode] {
            return [
                .encryptedPartitionError,
                .internalError,
                .invalidPartitionTypeDataError,
                .missingPartitionValueError,
                .unsupportedPartitionCharacterError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .encryptedPartitionError: return "ENCRYPTED_PARTITION_ERROR"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidPartitionTypeDataError: return "INVALID_PARTITION_TYPE_DATA_ERROR"
            case .missingPartitionValueError: return "MISSING_PARTITION_VALUE_ERROR"
            case .unsupportedPartitionCharacterError: return "UNSUPPORTED_PARTITION_CHARACTER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A list of errors that can occur when registering partition indexes for an existing table. These errors give the details about why an index registration failed and provide a limited number of partitions in the response, so that you can fix the partitions at fault and try registering the index again. The most common set of errors that can occur are categorized as follows:
    ///
    /// * EncryptedPartitionError: The partitions are encrypted.
    ///
    /// * InvalidPartitionTypeDataError: The partition value doesn't match the data type for that partition column.
    ///
    /// * MissingPartitionValueError: The partitions are encrypted.
    ///
    /// * UnsupportedPartitionCharacterError: Characters inside the partition value are not supported. For example: U+0000 , U+0001, U+0002.
    ///
    /// * InternalError: Any error which does not belong to other error codes.
    public struct BackfillError: Swift.Sendable {
        /// The error code for an error that occurred when registering partition indexes for an existing table.
        public var code: GlueClientTypes.BackfillErrorCode?
        /// A list of a limited number of partitions in the response.
        public var partitions: [GlueClientTypes.PartitionValueList]?

        public init(
            code: GlueClientTypes.BackfillErrorCode? = nil,
            partitions: [GlueClientTypes.PartitionValueList]? = nil
        )
        {
            self.code = code
            self.partitions = partitions
        }
    }
}

extension GlueClientTypes {

    public enum PartitionIndexStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [PartitionIndexStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A partition key pair consisting of a name and a type.
    public struct KeySchemaElement: Swift.Sendable {
        /// The name of a partition key.
        /// This member is required.
        public var name: Swift.String?
        /// The type of a partition key.
        /// This member is required.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }
}

extension GlueClientTypes {

    /// A descriptor for a partition index in a table.
    public struct PartitionIndexDescriptor: Swift.Sendable {
        /// A list of errors that can occur when registering partition indexes for an existing table.
        public var backfillErrors: [GlueClientTypes.BackfillError]?
        /// The name of the partition index.
        /// This member is required.
        public var indexName: Swift.String?
        /// The status of the partition index. The possible statuses are:
        ///
        /// * CREATING: The index is being created. When an index is in a CREATING state, the index or its table cannot be deleted.
        ///
        /// * ACTIVE: The index creation succeeds.
        ///
        /// * FAILED: The index creation fails.
        ///
        /// * DELETING: The index is deleted from the list of indexes.
        /// This member is required.
        public var indexStatus: GlueClientTypes.PartitionIndexStatus?
        /// A list of one or more keys, as KeySchemaElement structures, for the partition index.
        /// This member is required.
        public var keys: [GlueClientTypes.KeySchemaElement]?

        public init(
            backfillErrors: [GlueClientTypes.BackfillError]? = nil,
            indexName: Swift.String? = nil,
            indexStatus: GlueClientTypes.PartitionIndexStatus? = nil,
            keys: [GlueClientTypes.KeySchemaElement]? = nil
        )
        {
            self.backfillErrors = backfillErrors
            self.indexName = indexName
            self.indexStatus = indexStatus
            self.keys = keys
        }
    }
}

public struct GetPartitionIndexesOutput: Swift.Sendable {
    /// A continuation token, present if the current list segment is not the last.
    public var nextToken: Swift.String?
    /// A list of index descriptors.
    public var partitionIndexDescriptorList: [GlueClientTypes.PartitionIndexDescriptor]?

    public init(
        nextToken: Swift.String? = nil,
        partitionIndexDescriptorList: [GlueClientTypes.PartitionIndexDescriptor]? = nil
    )
    {
        self.nextToken = nextToken
        self.partitionIndexDescriptorList = partitionIndexDescriptorList
    }
}

extension GlueClientTypes {

    /// Defines a non-overlapping region of a table's partitions, allowing multiple requests to be run in parallel.
    public struct Segment: Swift.Sendable {
        /// The zero-based index number of the segment. For example, if the total number of segments is 4, SegmentNumber values range from 0 through 3.
        /// This member is required.
        public var segmentNumber: Swift.Int
        /// The total number of segments.
        /// This member is required.
        public var totalSegments: Swift.Int?

        public init(
            segmentNumber: Swift.Int = 0,
            totalSegments: Swift.Int? = nil
        )
        {
            self.segmentNumber = segmentNumber
            self.totalSegments = totalSegments
        }
    }
}

public struct GetPartitionsInput: Swift.Sendable {
    /// The ID of the Data Catalog where the partitions in question reside. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the catalog database where the partitions reside.
    /// This member is required.
    public var databaseName: Swift.String?
    /// When true, specifies not returning the partition column schema. Useful when you are interested only in other partition attributes such as partition values or location. This approach avoids the problem of a large response by not returning duplicate data.
    public var excludeColumnSchema: Swift.Bool?
    /// An expression that filters the partitions to be returned. The expression uses SQL syntax similar to the SQL WHERE filter clause. The SQL statement parser [JSQLParser](http://jsqlparser.sourceforge.net/home.php) parses the expression. Operators: The following are the operators that you can use in the Expression API call: = Checks whether the values of the two operands are equal; if yes, then the condition becomes true. Example: Assume 'variable a' holds 10 and 'variable b' holds 20. (a = b) is not true. < > Checks whether the values of two operands are equal; if the values are not equal, then the condition becomes true. Example: (a < > b) is true. > Checks whether the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true. Example: (a > b) is not true. < Checks whether the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true. Example: (a < b) is true. >= Checks whether the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a >= b) is not true. <= Checks whether the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a <= b) is true. AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL Logical operators. Supported Partition Key Types: The following are the supported partition keys.
    ///
    /// * string
    ///
    /// * date
    ///
    /// * timestamp
    ///
    /// * int
    ///
    /// * bigint
    ///
    /// * long
    ///
    /// * tinyint
    ///
    /// * smallint
    ///
    /// * decimal
    ///
    ///
    /// If an type is encountered that is not valid, an exception is thrown. The following list shows the valid operators on each type. When you define a crawler, the partitionKey type is created as a STRING, to be compatible with the catalog partitions. Sample API Call:
    public var expression: Swift.String?
    /// The maximum number of partitions to return in a single response.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve these partitions.
    public var nextToken: Swift.String?
    /// The time as of when to read the partition contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with TransactionId.
    public var queryAsOfTime: Foundation.Date?
    /// The segment of the table's partitions to scan in this request.
    public var segment: GlueClientTypes.Segment?
    /// The name of the partitions' table.
    /// This member is required.
    public var tableName: Swift.String?
    /// The transaction ID at which to read the partition contents.
    public var transactionId: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        excludeColumnSchema: Swift.Bool? = nil,
        expression: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryAsOfTime: Foundation.Date? = nil,
        segment: GlueClientTypes.Segment? = nil,
        tableName: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.excludeColumnSchema = excludeColumnSchema
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryAsOfTime = queryAsOfTime
        self.segment = segment
        self.tableName = tableName
        self.transactionId = transactionId
    }
}

public struct GetPartitionsOutput: Swift.Sendable {
    /// A continuation token, if the returned list of partitions does not include the last one.
    public var nextToken: Swift.String?
    /// A list of requested partitions.
    public var partitions: [GlueClientTypes.Partition]?

    public init(
        nextToken: Swift.String? = nil,
        partitions: [GlueClientTypes.Partition]? = nil
    )
    {
        self.nextToken = nextToken
        self.partitions = partitions
    }
}

public struct GetPlanInput: Swift.Sendable {
    /// A map to hold additional optional key-value parameters. Currently, these key-value pairs are supported:
    ///
    /// * inferSchema — Specifies whether to set inferSchema to true or false for the default script generated by an Glue job. For example, to set inferSchema to true, pass the following key value pair: --additional-plan-options-map '{"inferSchema":"true"}'
    public var additionalPlanOptionsMap: [Swift.String: Swift.String]?
    /// The programming language of the code to perform the mapping.
    public var language: GlueClientTypes.Language?
    /// The parameters for the mapping.
    public var location: GlueClientTypes.Location?
    /// The list of mappings from a source table to target tables.
    /// This member is required.
    public var mapping: [GlueClientTypes.MappingEntry]?
    /// The target tables.
    public var sinks: [GlueClientTypes.CatalogEntry]?
    /// The source table.
    /// This member is required.
    public var source: GlueClientTypes.CatalogEntry?

    public init(
        additionalPlanOptionsMap: [Swift.String: Swift.String]? = nil,
        language: GlueClientTypes.Language? = nil,
        location: GlueClientTypes.Location? = nil,
        mapping: [GlueClientTypes.MappingEntry]? = nil,
        sinks: [GlueClientTypes.CatalogEntry]? = nil,
        source: GlueClientTypes.CatalogEntry? = nil
    )
    {
        self.additionalPlanOptionsMap = additionalPlanOptionsMap
        self.language = language
        self.location = location
        self.mapping = mapping
        self.sinks = sinks
        self.source = source
    }
}

public struct GetPlanOutput: Swift.Sendable {
    /// A Python script to perform the mapping.
    public var pythonScript: Swift.String?
    /// The Scala code to perform the mapping.
    public var scalaCode: Swift.String?

    public init(
        pythonScript: Swift.String? = nil,
        scalaCode: Swift.String? = nil
    )
    {
        self.pythonScript = pythonScript
        self.scalaCode = scalaCode
    }
}

public struct GetRegistryInput: Swift.Sendable {
    /// This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
    /// This member is required.
    public var registryId: GlueClientTypes.RegistryId?

    public init(
        registryId: GlueClientTypes.RegistryId? = nil
    )
    {
        self.registryId = registryId
    }
}

public struct GetRegistryOutput: Swift.Sendable {
    /// The date and time the registry was created.
    public var createdTime: Swift.String?
    /// A description of the registry.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// The status of the registry.
    public var status: GlueClientTypes.RegistryStatus?
    /// The date and time the registry was updated.
    public var updatedTime: Swift.String?

    public init(
        createdTime: Swift.String? = nil,
        description: Swift.String? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        status: GlueClientTypes.RegistryStatus? = nil,
        updatedTime: Swift.String? = nil
    )
    {
        self.createdTime = createdTime
        self.description = description
        self.registryArn = registryArn
        self.registryName = registryName
        self.status = status
        self.updatedTime = updatedTime
    }
}

public struct GetResourcePoliciesInput: Swift.Sendable {
    /// The maximum size of a list to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GlueClientTypes {

    /// A structure for returning a resource policy.
    public struct GluePolicy: Swift.Sendable {
        /// The date and time at which the policy was created.
        public var createTime: Foundation.Date?
        /// Contains the hash value associated with this policy.
        public var policyHash: Swift.String?
        /// Contains the requested policy document, in JSON format.
        public var policyInJson: Swift.String?
        /// The date and time at which the policy was last updated.
        public var updateTime: Foundation.Date?

        public init(
            createTime: Foundation.Date? = nil,
            policyHash: Swift.String? = nil,
            policyInJson: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.createTime = createTime
            self.policyHash = policyHash
            self.policyInJson = policyInJson
            self.updateTime = updateTime
        }
    }
}

public struct GetResourcePoliciesOutput: Swift.Sendable {
    /// A list of the individual resource policies and the account-level resource policy.
    public var getResourcePoliciesResponseList: [GlueClientTypes.GluePolicy]?
    /// A continuation token, if the returned list does not contain the last resource policy available.
    public var nextToken: Swift.String?

    public init(
        getResourcePoliciesResponseList: [GlueClientTypes.GluePolicy]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.getResourcePoliciesResponseList = getResourcePoliciesResponseList
        self.nextToken = nextToken
    }
}

public struct GetResourcePolicyInput: Swift.Sendable {
    /// The ARN of the Glue resource for which to retrieve the resource policy. If not supplied, the Data Catalog resource policy is returned. Use GetResourcePolicies to view all existing resource policies. For more information see [Specifying Glue Resource ARNs](https://docs.aws.amazon.com/glue/latest/dg/glue-specifying-resource-arns.html).
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct GetResourcePolicyOutput: Swift.Sendable {
    /// The date and time at which the policy was created.
    public var createTime: Foundation.Date?
    /// Contains the hash value associated with this policy.
    public var policyHash: Swift.String?
    /// Contains the requested policy document, in JSON format.
    public var policyInJson: Swift.String?
    /// The date and time at which the policy was last updated.
    public var updateTime: Foundation.Date?

    public init(
        createTime: Foundation.Date? = nil,
        policyHash: Swift.String? = nil,
        policyInJson: Swift.String? = nil,
        updateTime: Foundation.Date? = nil
    )
    {
        self.createTime = createTime
        self.policyHash = policyHash
        self.policyInJson = policyInJson
        self.updateTime = updateTime
    }
}

public struct GetSchemaInput: Swift.Sendable {
    /// This is a wrapper structure to contain schema identity fields. The structure contains:
    ///
    /// * SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
    ///
    /// * SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
    /// This member is required.
    public var schemaId: GlueClientTypes.SchemaId?

    public init(
        schemaId: GlueClientTypes.SchemaId? = nil
    )
    {
        self.schemaId = schemaId
    }
}

public struct GetSchemaOutput: Swift.Sendable {
    /// The compatibility mode of the schema.
    public var compatibility: GlueClientTypes.Compatibility?
    /// The date and time the schema was created.
    public var createdTime: Swift.String?
    /// The data format of the schema definition. Currently AVRO, JSON and PROTOBUF are supported.
    public var dataFormat: GlueClientTypes.DataFormat?
    /// A description of schema if specified when created
    public var description: Swift.String?
    /// The latest version of the schema associated with the returned schema definition.
    public var latestSchemaVersion: Swift.Int?
    /// The next version of the schema associated with the returned schema definition.
    public var nextSchemaVersion: Swift.Int?
    /// The Amazon Resource Name (ARN) of the registry.
    public var registryArn: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// The Amazon Resource Name (ARN) of the schema.
    public var schemaArn: Swift.String?
    /// The version number of the checkpoint (the last time the compatibility mode was changed).
    public var schemaCheckpoint: Swift.Int?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The status of the schema.
    public var schemaStatus: GlueClientTypes.SchemaStatus?
    /// The date and time the schema was updated.
    public var updatedTime: Swift.String?

    public init(
        compatibility: GlueClientTypes.Compatibility? = nil,
        createdTime: Swift.String? = nil,
        dataFormat: GlueClientTypes.DataFormat? = nil,
        description: Swift.String? = nil,
        latestSchemaVersion: Swift.Int? = nil,
        nextSchemaVersion: Swift.Int? = nil,
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaArn: Swift.String? = nil,
        schemaCheckpoint: Swift.Int? = nil,
        schemaName: Swift.String? = nil,
        schemaStatus: GlueClientTypes.SchemaStatus? = nil,
        updatedTime: Swift.String? = nil
    )
    {
        self.compatibility = compatibility
        self.createdTime = createdTime
        self.dataFormat = dataFormat
        self.description = description
        self.latestSchemaVersion = latestSchemaVersion
        self.nextSchemaVersion = nextSchemaVersion
        self.registryArn = registryArn
        self.registryName = registryName
        self.schemaArn = schemaArn
        self.schemaCheckpoint = schemaCheckpoint
        self.schemaName = schemaName
        self.schemaStatus = schemaStatus
        self.updatedTime = updatedTime
    }
}

public struct GetSchemaByDefinitionInput: Swift.Sendable {
    /// The definition of the schema for which schema details are required.
    /// This member is required.
    public var schemaDefinition: Swift.String?
    /// This is a wrapper structure to contain schema identity fields. The structure contains:
    ///
    /// * SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.
    ///
    /// * SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to be provided.
    /// This member is required.
    public var schemaId: GlueClientTypes.SchemaId?

    public init(
        schemaDefinition: Swift.String? = nil,
        schemaId: GlueClientTypes.SchemaId? = nil
    )
    {
        self.schemaDefinition = schemaDefinition
        self.schemaId = schemaId
    }
}

public struct GetSchemaByDefinitionOutput: Swift.Sendable {
    /// The date and time the schema was created.
    public var createdTime: Swift.String?
    /// The data format of the schema definition. Currently AVRO, JSON and PROTOBUF are supported.
    public var dataFormat: GlueClientTypes.DataFormat?
    /// The Amazon Resource Name (ARN) of the schema.
    public var schemaArn: Swift.String?
    /// The schema ID of the schema version.
    public var schemaVersionId: Swift.String?
    /// The status of the schema version.
    public var status: GlueClientTypes.SchemaVersionStatus?

    public init(
        createdTime: Swift.String? = nil,
        dataFormat: GlueClientTypes.DataFormat? = nil,
        schemaArn: Swift.String? = nil,
        schemaVersionId: Swift.String? = nil,
        status: GlueClientTypes.SchemaVersionStatus? = nil
    )
    {
        self.createdTime = createdTime
        self.dataFormat = dataFormat
        self.schemaArn = schemaArn
        self.schemaVersionId = schemaVersionId
        self.status = status
    }
}

extension GlueClientTypes {

    /// A structure containing the schema version information.
    public struct SchemaVersionNumber: Swift.Sendable {
        /// The latest version available for the schema.
        public var latestVersion: Swift.Bool
        /// The version number of the schema.
        public var versionNumber: Swift.Int?

        public init(
            latestVersion: Swift.Bool = false,
            versionNumber: Swift.Int? = nil
        )
        {
            self.latestVersion = latestVersion
            self.versionNumber = versionNumber
        }
    }
}

public struct GetSchemaVersionInput: Swift.Sendable {
    /// This is a wrapper structure to contain schema identity fields. The structure contains:
    ///
    /// * SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
    ///
    /// * SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
    public var schemaId: GlueClientTypes.SchemaId?
    /// The SchemaVersionId of the schema version. This field is required for fetching by schema ID. Either this or the SchemaId wrapper has to be provided.
    public var schemaVersionId: Swift.String?
    /// The version number of the schema.
    public var schemaVersionNumber: GlueClientTypes.SchemaVersionNumber?

    public init(
        schemaId: GlueClientTypes.SchemaId? = nil,
        schemaVersionId: Swift.String? = nil,
        schemaVersionNumber: GlueClientTypes.SchemaVersionNumber? = nil
    )
    {
        self.schemaId = schemaId
        self.schemaVersionId = schemaVersionId
        self.schemaVersionNumber = schemaVersionNumber
    }
}

public struct GetSchemaVersionOutput: Swift.Sendable {
    /// The date and time the schema version was created.
    public var createdTime: Swift.String?
    /// The data format of the schema definition. Currently AVRO, JSON and PROTOBUF are supported.
    public var dataFormat: GlueClientTypes.DataFormat?
    /// The Amazon Resource Name (ARN) of the schema.
    public var schemaArn: Swift.String?
    /// The schema definition for the schema ID.
    public var schemaDefinition: Swift.String?
    /// The SchemaVersionId of the schema version.
    public var schemaVersionId: Swift.String?
    /// The status of the schema version.
    public var status: GlueClientTypes.SchemaVersionStatus?
    /// The version number of the schema.
    public var versionNumber: Swift.Int?

    public init(
        createdTime: Swift.String? = nil,
        dataFormat: GlueClientTypes.DataFormat? = nil,
        schemaArn: Swift.String? = nil,
        schemaDefinition: Swift.String? = nil,
        schemaVersionId: Swift.String? = nil,
        status: GlueClientTypes.SchemaVersionStatus? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.createdTime = createdTime
        self.dataFormat = dataFormat
        self.schemaArn = schemaArn
        self.schemaDefinition = schemaDefinition
        self.schemaVersionId = schemaVersionId
        self.status = status
        self.versionNumber = versionNumber
    }
}

extension GlueClientTypes {

    public enum SchemaDiffType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case syntaxDiff
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaDiffType] {
            return [
                .syntaxDiff
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .syntaxDiff: return "SYNTAX_DIFF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSchemaVersionsDiffInput: Swift.Sendable {
    /// The first of the two schema versions to be compared.
    /// This member is required.
    public var firstSchemaVersionNumber: GlueClientTypes.SchemaVersionNumber?
    /// Refers to SYNTAX_DIFF, which is the currently supported diff type.
    /// This member is required.
    public var schemaDiffType: GlueClientTypes.SchemaDiffType?
    /// This is a wrapper structure to contain schema identity fields. The structure contains:
    ///
    /// * SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.
    ///
    /// * SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to be provided.
    /// This member is required.
    public var schemaId: GlueClientTypes.SchemaId?
    /// The second of the two schema versions to be compared.
    /// This member is required.
    public var secondSchemaVersionNumber: GlueClientTypes.SchemaVersionNumber?

    public init(
        firstSchemaVersionNumber: GlueClientTypes.SchemaVersionNumber? = nil,
        schemaDiffType: GlueClientTypes.SchemaDiffType? = nil,
        schemaId: GlueClientTypes.SchemaId? = nil,
        secondSchemaVersionNumber: GlueClientTypes.SchemaVersionNumber? = nil
    )
    {
        self.firstSchemaVersionNumber = firstSchemaVersionNumber
        self.schemaDiffType = schemaDiffType
        self.schemaId = schemaId
        self.secondSchemaVersionNumber = secondSchemaVersionNumber
    }
}

public struct GetSchemaVersionsDiffOutput: Swift.Sendable {
    /// The difference between schemas as a string in JsonPatch format.
    public var diff: Swift.String?

    public init(
        diff: Swift.String? = nil
    )
    {
        self.diff = diff
    }
}

public struct GetSecurityConfigurationInput: Swift.Sendable {
    /// The name of the security configuration to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension GlueClientTypes {

    /// Specifies a security configuration.
    public struct SecurityConfiguration: Swift.Sendable {
        /// The time at which this security configuration was created.
        public var createdTimeStamp: Foundation.Date?
        /// The encryption configuration associated with this security configuration.
        public var encryptionConfiguration: GlueClientTypes.EncryptionConfiguration?
        /// The name of the security configuration.
        public var name: Swift.String?

        public init(
            createdTimeStamp: Foundation.Date? = nil,
            encryptionConfiguration: GlueClientTypes.EncryptionConfiguration? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdTimeStamp = createdTimeStamp
            self.encryptionConfiguration = encryptionConfiguration
            self.name = name
        }
    }
}

public struct GetSecurityConfigurationOutput: Swift.Sendable {
    /// The requested security configuration.
    public var securityConfiguration: GlueClientTypes.SecurityConfiguration?

    public init(
        securityConfiguration: GlueClientTypes.SecurityConfiguration? = nil
    )
    {
        self.securityConfiguration = securityConfiguration
    }
}

public struct GetSecurityConfigurationsInput: Swift.Sendable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetSecurityConfigurationsOutput: Swift.Sendable {
    /// A continuation token, if there are more security configurations to return.
    public var nextToken: Swift.String?
    /// A list of security configurations.
    public var securityConfigurations: [GlueClientTypes.SecurityConfiguration]?

    public init(
        nextToken: Swift.String? = nil,
        securityConfigurations: [GlueClientTypes.SecurityConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityConfigurations = securityConfigurations
    }
}

public struct GetSessionInput: Swift.Sendable {
    /// The ID of the session.
    /// This member is required.
    public var id: Swift.String?
    /// The origin of the request.
    public var requestOrigin: Swift.String?

    public init(
        id: Swift.String? = nil,
        requestOrigin: Swift.String? = nil
    )
    {
        self.id = id
        self.requestOrigin = requestOrigin
    }
}

public struct GetSessionOutput: Swift.Sendable {
    /// The session object is returned in the response.
    public var session: GlueClientTypes.Session?

    public init(
        session: GlueClientTypes.Session? = nil
    )
    {
        self.session = session
    }
}

public struct GetStatementInput: Swift.Sendable {
    /// The Id of the statement.
    /// This member is required.
    public var id: Swift.Int?
    /// The origin of the request.
    public var requestOrigin: Swift.String?
    /// The Session ID of the statement.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        id: Swift.Int? = 0,
        requestOrigin: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.id = id
        self.requestOrigin = requestOrigin
        self.sessionId = sessionId
    }
}

extension GlueClientTypes {

    /// The code execution output in JSON format.
    public struct StatementOutputData: Swift.Sendable {
        /// The code execution output in text format.
        public var textPlain: Swift.String?

        public init(
            textPlain: Swift.String? = nil
        )
        {
            self.textPlain = textPlain
        }
    }
}

extension GlueClientTypes {

    public enum StatementState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case cancelled
        case cancelling
        case error
        case running
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [StatementState] {
            return [
                .available,
                .cancelled,
                .cancelling,
                .error,
                .running,
                .waiting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .error: return "ERROR"
            case .running: return "RUNNING"
            case .waiting: return "WAITING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// The code execution output in JSON format.
    public struct StatementOutput: Swift.Sendable {
        /// The code execution output.
        public var data: GlueClientTypes.StatementOutputData?
        /// The name of the error in the output.
        public var errorName: Swift.String?
        /// The error value of the output.
        public var errorValue: Swift.String?
        /// The execution count of the output.
        public var executionCount: Swift.Int
        /// The status of the code execution output.
        public var status: GlueClientTypes.StatementState?
        /// The traceback of the output.
        public var traceback: [Swift.String]?

        public init(
            data: GlueClientTypes.StatementOutputData? = nil,
            errorName: Swift.String? = nil,
            errorValue: Swift.String? = nil,
            executionCount: Swift.Int = 0,
            status: GlueClientTypes.StatementState? = nil,
            traceback: [Swift.String]? = nil
        )
        {
            self.data = data
            self.errorName = errorName
            self.errorValue = errorValue
            self.executionCount = executionCount
            self.status = status
            self.traceback = traceback
        }
    }
}

extension GlueClientTypes {

    /// The statement or request for a particular action to occur in a session.
    public struct Statement: Swift.Sendable {
        /// The execution code of the statement.
        public var code: Swift.String?
        /// The unix time and date that the job definition was completed.
        public var completedOn: Swift.Int
        /// The ID of the statement.
        public var id: Swift.Int
        /// The output in JSON.
        public var output: GlueClientTypes.StatementOutput?
        /// The code execution progress.
        public var progress: Swift.Double
        /// The unix time and date that the job definition was started.
        public var startedOn: Swift.Int
        /// The state while request is actioned.
        public var state: GlueClientTypes.StatementState?

        public init(
            code: Swift.String? = nil,
            completedOn: Swift.Int = 0,
            id: Swift.Int = 0,
            output: GlueClientTypes.StatementOutput? = nil,
            progress: Swift.Double = 0.0,
            startedOn: Swift.Int = 0,
            state: GlueClientTypes.StatementState? = nil
        )
        {
            self.code = code
            self.completedOn = completedOn
            self.id = id
            self.output = output
            self.progress = progress
            self.startedOn = startedOn
            self.state = state
        }
    }
}

public struct GetStatementOutput: Swift.Sendable {
    /// Returns the statement.
    public var statement: GlueClientTypes.Statement?

    public init(
        statement: GlueClientTypes.Statement? = nil
    )
    {
        self.statement = statement
    }
}

public struct GetTableInput: Swift.Sendable {
    /// The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var databaseName: Swift.String?
    /// Specifies whether to include status details related to a request to create or update an Glue Data Catalog view.
    public var includeStatusDetails: Swift.Bool?
    /// The name of the table for which to retrieve the definition. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var name: Swift.String?
    /// The time as of when to read the table contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with TransactionId.
    public var queryAsOfTime: Foundation.Date?
    /// The transaction ID at which to read the table contents.
    public var transactionId: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        includeStatusDetails: Swift.Bool? = nil,
        name: Swift.String? = nil,
        queryAsOfTime: Foundation.Date? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.includeStatusDetails = includeStatusDetails
        self.name = name
        self.queryAsOfTime = queryAsOfTime
        self.transactionId = transactionId
    }
}

extension GlueClientTypes {

    /// A table that points to an entity outside the Glue Data Catalog.
    public struct FederatedTable: Swift.Sendable {
        /// The name of the connection to the external metastore.
        public var connectionName: Swift.String?
        /// A unique identifier for the federated database.
        public var databaseIdentifier: Swift.String?
        /// A unique identifier for the federated table.
        public var identifier: Swift.String?

        public init(
            connectionName: Swift.String? = nil,
            databaseIdentifier: Swift.String? = nil,
            identifier: Swift.String? = nil
        )
        {
            self.connectionName = connectionName
            self.databaseIdentifier = databaseIdentifier
            self.identifier = identifier
        }
    }
}

extension GlueClientTypes {

    public enum ResourceAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case create
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceAction] {
            return [
                .create,
                .update
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum ResourceState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case queued
        case stopped
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceState] {
            return [
                .failed,
                .inProgress,
                .queued,
                .stopped,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .stopped: return "STOPPED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A structure that contains information for an analytical engine to validate a view, prior to persisting the view metadata. Used in the case of direct UpdateTable or CreateTable API calls.
    public struct ViewValidation: Swift.Sendable {
        /// The dialect of the query engine.
        public var dialect: GlueClientTypes.ViewDialect?
        /// The version of the dialect of the query engine. For example, 3.0.0.
        public var dialectVersion: Swift.String?
        /// An error associated with the validation.
        public var error: GlueClientTypes.ErrorDetail?
        /// The state of the validation.
        public var state: GlueClientTypes.ResourceState?
        /// The time of the last update.
        public var updateTime: Foundation.Date?
        /// The SELECT query that defines the view, as provided by the customer.
        public var viewValidationText: Swift.String?

        public init(
            dialect: GlueClientTypes.ViewDialect? = nil,
            dialectVersion: Swift.String? = nil,
            error: GlueClientTypes.ErrorDetail? = nil,
            state: GlueClientTypes.ResourceState? = nil,
            updateTime: Foundation.Date? = nil,
            viewValidationText: Swift.String? = nil
        )
        {
            self.dialect = dialect
            self.dialectVersion = dialectVersion
            self.error = error
            self.state = state
            self.updateTime = updateTime
            self.viewValidationText = viewValidationText
        }
    }
}

extension GlueClientTypes {

    /// A structure that contains the dialect of the view, and the query that defines the view.
    public struct ViewRepresentation: Swift.Sendable {
        /// The dialect of the query engine.
        public var dialect: GlueClientTypes.ViewDialect?
        /// The version of the dialect of the query engine. For example, 3.0.0.
        public var dialectVersion: Swift.String?
        /// Dialects marked as stale are no longer valid and must be updated before they can be queried in their respective query engines.
        public var isStale: Swift.Bool?
        /// The name of the connection to be used to validate the specific representation of the view.
        public var validationConnection: Swift.String?
        /// The expanded SQL for the view. This SQL is used by engines while processing a query on a view. Engines may perform operations during view creation to transform ViewOriginalText to ViewExpandedText. For example:
        ///
        /// * Fully qualified identifiers: SELECT * from table1 -> SELECT * from db1.table1
        public var viewExpandedText: Swift.String?
        /// The SELECT query provided by the customer during CREATE VIEW DDL. This SQL is not used during a query on a view (ViewExpandedText is used instead). ViewOriginalText is used for cases like SHOW CREATE VIEW where users want to see the original DDL command that created the view.
        public var viewOriginalText: Swift.String?

        public init(
            dialect: GlueClientTypes.ViewDialect? = nil,
            dialectVersion: Swift.String? = nil,
            isStale: Swift.Bool? = nil,
            validationConnection: Swift.String? = nil,
            viewExpandedText: Swift.String? = nil,
            viewOriginalText: Swift.String? = nil
        )
        {
            self.dialect = dialect
            self.dialectVersion = dialectVersion
            self.isStale = isStale
            self.validationConnection = validationConnection
            self.viewExpandedText = viewExpandedText
            self.viewOriginalText = viewOriginalText
        }
    }
}

extension GlueClientTypes {

    /// A structure containing details for representations.
    public struct ViewDefinition: Swift.Sendable {
        /// The definer of a view in SQL.
        public var definer: Swift.String?
        /// You can set this flag as true to instruct the engine not to push user-provided operations into the logical plan of the view during query planning. However, setting this flag does not guarantee that the engine will comply. Refer to the engine's documentation to understand the guarantees provided, if any.
        public var isProtected: Swift.Bool?
        /// A list of representations.
        public var representations: [GlueClientTypes.ViewRepresentation]?
        /// A list of table Amazon Resource Names (ARNs).
        public var subObjects: [Swift.String]?

        public init(
            definer: Swift.String? = nil,
            isProtected: Swift.Bool? = nil,
            representations: [GlueClientTypes.ViewRepresentation]? = nil,
            subObjects: [Swift.String]? = nil
        )
        {
            self.definer = definer
            self.isProtected = isProtected
            self.representations = representations
            self.subObjects = subObjects
        }
    }
}

public struct GetTableOptimizerInput: Swift.Sendable {
    /// The Catalog ID of the table.
    /// This member is required.
    public var catalogId: Swift.String?
    /// The name of the database in the catalog in which the table resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?
    /// The type of table optimizer.
    /// This member is required.
    public var type: GlueClientTypes.TableOptimizerType?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil,
        type: GlueClientTypes.TableOptimizerType? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tableName = tableName
        self.type = type
    }
}

public struct GetTableOptimizerOutput: Swift.Sendable {
    /// The Catalog ID of the table.
    public var catalogId: Swift.String?
    /// The name of the database in the catalog in which the table resides.
    public var databaseName: Swift.String?
    /// The name of the table.
    public var tableName: Swift.String?
    /// The optimizer associated with the specified table.
    public var tableOptimizer: GlueClientTypes.TableOptimizer?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil,
        tableOptimizer: GlueClientTypes.TableOptimizer? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tableName = tableName
        self.tableOptimizer = tableOptimizer
    }
}

extension GlueClientTypes {

    public enum TableAttributes: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case tableType
        case sdkUnknown(Swift.String)

        public static var allCases: [TableAttributes] {
            return [
                .name,
                .tableType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case .tableType: return "TABLE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetTablesInput: Swift.Sendable {
    /// Specifies the table fields returned by the GetTables call. This parameter doesn’t accept an empty list. The request must include NAME. The following are the valid combinations of values:
    ///
    /// * NAME - Names of all tables in the database.
    ///
    /// * NAME, TABLE_TYPE - Names of all tables and the table types.
    public var attributesToGet: [GlueClientTypes.TableAttributes]?
    /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The database in the catalog whose tables to list. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A regular expression pattern. If present, only those tables whose names match the pattern are returned.
    public var expression: Swift.String?
    /// Specifies whether to include status details related to a request to create or update an Glue Data Catalog view.
    public var includeStatusDetails: Swift.Bool?
    /// The maximum number of tables to return in a single response.
    public var maxResults: Swift.Int?
    /// A continuation token, included if this is a continuation call.
    public var nextToken: Swift.String?
    /// The time as of when to read the table contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with TransactionId.
    public var queryAsOfTime: Foundation.Date?
    /// The transaction ID at which to read the table contents.
    public var transactionId: Swift.String?

    public init(
        attributesToGet: [GlueClientTypes.TableAttributes]? = nil,
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        expression: Swift.String? = nil,
        includeStatusDetails: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryAsOfTime: Foundation.Date? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.attributesToGet = attributesToGet
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.expression = expression
        self.includeStatusDetails = includeStatusDetails
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryAsOfTime = queryAsOfTime
        self.transactionId = transactionId
    }
}

public struct GetTableVersionInput: Swift.Sendable {
    /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var tableName: Swift.String?
    /// The ID value of the table version to be retrieved. A VersionID is a string representation of an integer. Each version is incremented by 1.
    public var versionId: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tableName = tableName
        self.versionId = versionId
    }
}

public struct GetTableVersionsInput: Swift.Sendable {
    /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The maximum number of table versions to return in one response.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call.
    public var nextToken: Swift.String?
    /// The name of the table. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tableName = tableName
    }
}

public struct GetTagsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource for which to retrieve tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct GetTagsOutput: Swift.Sendable {
    /// The requested tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct GetTriggerInput: Swift.Sendable {
    /// The name of the trigger to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct GetTriggerOutput: Swift.Sendable {
    /// The requested trigger definition.
    public var trigger: GlueClientTypes.Trigger?

    public init(
        trigger: GlueClientTypes.Trigger? = nil
    )
    {
        self.trigger = trigger
    }
}

public struct GetTriggersInput: Swift.Sendable {
    /// The name of the job to retrieve triggers for. The trigger that can start this job is returned, and if there is no such trigger, all triggers are returned.
    public var dependentJobName: Swift.String?
    /// The maximum size of the response.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?

    public init(
        dependentJobName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dependentJobName = dependentJobName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetTriggersOutput: Swift.Sendable {
    /// A continuation token, if not all the requested triggers have yet been returned.
    public var nextToken: Swift.String?
    /// A list of triggers for the specified job.
    public var triggers: [GlueClientTypes.Trigger]?

    public init(
        nextToken: Swift.String? = nil,
        triggers: [GlueClientTypes.Trigger]? = nil
    )
    {
        self.nextToken = nextToken
        self.triggers = triggers
    }
}

/// The operation timed out.
public struct PermissionTypeMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// There is a mismatch between the SupportedPermissionType used in the query request and the permissions defined on the target table.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PermissionTypeMismatchException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GlueClientTypes {

    /// A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.
    public struct QuerySessionContext: Swift.Sendable {
        /// An opaque string-string map passed by the query engine.
        public var additionalContext: [Swift.String: Swift.String]?
        /// An identifier string for the consumer cluster.
        public var clusterId: Swift.String?
        /// A cryptographically generated query identifier generated by Glue or Lake Formation.
        public var queryAuthorizationId: Swift.String?
        /// A unique identifier generated by the query engine for the query.
        public var queryId: Swift.String?
        /// A timestamp provided by the query engine for when the query started.
        public var queryStartTime: Foundation.Date?

        public init(
            additionalContext: [Swift.String: Swift.String]? = nil,
            clusterId: Swift.String? = nil,
            queryAuthorizationId: Swift.String? = nil,
            queryId: Swift.String? = nil,
            queryStartTime: Foundation.Date? = nil
        )
        {
            self.additionalContext = additionalContext
            self.clusterId = clusterId
            self.queryAuthorizationId = queryAuthorizationId
            self.queryId = queryId
            self.queryStartTime = queryStartTime
        }
    }
}

extension GlueClientTypes {

    public enum PermissionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cellFilterPermission
        case columnPermission
        case nestedCellPermission
        case nestedPermission
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .cellFilterPermission,
                .columnPermission,
                .nestedCellPermission,
                .nestedPermission
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cellFilterPermission: return "CELL_FILTER_PERMISSION"
            case .columnPermission: return "COLUMN_PERMISSION"
            case .nestedCellPermission: return "NESTED_CELL_PERMISSION"
            case .nestedPermission: return "NESTED_PERMISSION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetUnfilteredPartitionMetadataInput: Swift.Sendable {
    /// A structure containing Lake Formation audit context information.
    public var auditContext: GlueClientTypes.AuditContext?
    /// The catalog ID where the partition resides.
    /// This member is required.
    public var catalogId: Swift.String?
    /// (Required) Specifies the name of a database that contains the partition.
    /// This member is required.
    public var databaseName: Swift.String?
    /// (Required) A list of partition key values.
    /// This member is required.
    public var partitionValues: [Swift.String]?
    /// A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.
    public var querySessionContext: GlueClientTypes.QuerySessionContext?
    /// Specified only if the base tables belong to a different Amazon Web Services Region.
    public var region: Swift.String?
    /// (Required) A list of supported permission types.
    /// This member is required.
    public var supportedPermissionTypes: [GlueClientTypes.PermissionType]?
    /// (Required) Specifies the name of a table that contains the partition.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        auditContext: GlueClientTypes.AuditContext? = nil,
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        partitionValues: [Swift.String]? = nil,
        querySessionContext: GlueClientTypes.QuerySessionContext? = nil,
        region: Swift.String? = nil,
        supportedPermissionTypes: [GlueClientTypes.PermissionType]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.auditContext = auditContext
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionValues = partitionValues
        self.querySessionContext = querySessionContext
        self.region = region
        self.supportedPermissionTypes = supportedPermissionTypes
        self.tableName = tableName
    }
}

public struct GetUnfilteredPartitionMetadataOutput: Swift.Sendable {
    /// A list of column names that the user has been granted access to.
    public var authorizedColumns: [Swift.String]?
    /// A Boolean value that indicates whether the partition location is registered with Lake Formation.
    public var isRegisteredWithLakeFormation: Swift.Bool
    /// A Partition object containing the partition metadata.
    public var partition: GlueClientTypes.Partition?

    public init(
        authorizedColumns: [Swift.String]? = nil,
        isRegisteredWithLakeFormation: Swift.Bool = false,
        partition: GlueClientTypes.Partition? = nil
    )
    {
        self.authorizedColumns = authorizedColumns
        self.isRegisteredWithLakeFormation = isRegisteredWithLakeFormation
        self.partition = partition
    }
}

public struct GetUnfilteredPartitionsMetadataInput: Swift.Sendable {
    /// A structure containing Lake Formation audit context information.
    public var auditContext: GlueClientTypes.AuditContext?
    /// The ID of the Data Catalog where the partitions in question reside. If none is provided, the AWS account ID is used by default.
    /// This member is required.
    public var catalogId: Swift.String?
    /// The name of the catalog database where the partitions reside.
    /// This member is required.
    public var databaseName: Swift.String?
    /// An expression that filters the partitions to be returned. The expression uses SQL syntax similar to the SQL WHERE filter clause. The SQL statement parser [JSQLParser](http://jsqlparser.sourceforge.net/home.php) parses the expression. Operators: The following are the operators that you can use in the Expression API call: = Checks whether the values of the two operands are equal; if yes, then the condition becomes true. Example: Assume 'variable a' holds 10 and 'variable b' holds 20. (a = b) is not true. < > Checks whether the values of two operands are equal; if the values are not equal, then the condition becomes true. Example: (a < > b) is true. > Checks whether the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true. Example: (a > b) is not true. < Checks whether the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true. Example: (a < b) is true. >= Checks whether the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a >= b) is not true. <= Checks whether the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a <= b) is true. AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL Logical operators. Supported Partition Key Types: The following are the supported partition keys.
    ///
    /// * string
    ///
    /// * date
    ///
    /// * timestamp
    ///
    /// * int
    ///
    /// * bigint
    ///
    /// * long
    ///
    /// * tinyint
    ///
    /// * smallint
    ///
    /// * decimal
    ///
    ///
    /// If an type is encountered that is not valid, an exception is thrown.
    public var expression: Swift.String?
    /// The maximum number of partitions to return in a single response.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve these partitions.
    public var nextToken: Swift.String?
    /// A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.
    public var querySessionContext: GlueClientTypes.QuerySessionContext?
    /// Specified only if the base tables belong to a different Amazon Web Services Region.
    public var region: Swift.String?
    /// The segment of the table's partitions to scan in this request.
    public var segment: GlueClientTypes.Segment?
    /// A list of supported permission types.
    /// This member is required.
    public var supportedPermissionTypes: [GlueClientTypes.PermissionType]?
    /// The name of the table that contains the partition.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        auditContext: GlueClientTypes.AuditContext? = nil,
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        expression: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        querySessionContext: GlueClientTypes.QuerySessionContext? = nil,
        region: Swift.String? = nil,
        segment: GlueClientTypes.Segment? = nil,
        supportedPermissionTypes: [GlueClientTypes.PermissionType]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.auditContext = auditContext
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.querySessionContext = querySessionContext
        self.region = region
        self.segment = segment
        self.supportedPermissionTypes = supportedPermissionTypes
        self.tableName = tableName
    }
}

extension GlueClientTypes {

    /// A partition that contains unfiltered metadata.
    public struct UnfilteredPartition: Swift.Sendable {
        /// The list of columns the user has permissions to access.
        public var authorizedColumns: [Swift.String]?
        /// A Boolean value indicating that the partition location is registered with Lake Formation.
        public var isRegisteredWithLakeFormation: Swift.Bool
        /// The partition object.
        public var partition: GlueClientTypes.Partition?

        public init(
            authorizedColumns: [Swift.String]? = nil,
            isRegisteredWithLakeFormation: Swift.Bool = false,
            partition: GlueClientTypes.Partition? = nil
        )
        {
            self.authorizedColumns = authorizedColumns
            self.isRegisteredWithLakeFormation = isRegisteredWithLakeFormation
            self.partition = partition
        }
    }
}

public struct GetUnfilteredPartitionsMetadataOutput: Swift.Sendable {
    /// A continuation token, if the returned list of partitions does not include the last one.
    public var nextToken: Swift.String?
    /// A list of requested partitions.
    public var unfilteredPartitions: [GlueClientTypes.UnfilteredPartition]?

    public init(
        nextToken: Swift.String? = nil,
        unfilteredPartitions: [GlueClientTypes.UnfilteredPartition]? = nil
    )
    {
        self.nextToken = nextToken
        self.unfilteredPartitions = unfilteredPartitions
    }
}

extension GlueClientTypes {

    /// A structure specifying the dialect and dialect version used by the query engine.
    public struct SupportedDialect: Swift.Sendable {
        /// The dialect of the query engine.
        public var dialect: GlueClientTypes.ViewDialect?
        /// The version of the dialect of the query engine. For example, 3.0.0.
        public var dialectVersion: Swift.String?

        public init(
            dialect: GlueClientTypes.ViewDialect? = nil,
            dialectVersion: Swift.String? = nil
        )
        {
            self.dialect = dialect
            self.dialectVersion = dialectVersion
        }
    }
}

public struct GetUnfilteredTableMetadataInput: Swift.Sendable {
    /// A structure containing Lake Formation audit context information.
    public var auditContext: GlueClientTypes.AuditContext?
    /// The catalog ID where the table resides.
    /// This member is required.
    public var catalogId: Swift.String?
    /// (Required) Specifies the name of a database that contains the table.
    /// This member is required.
    public var databaseName: Swift.String?
    /// (Required) Specifies the name of a table for which you are requesting metadata.
    /// This member is required.
    public var name: Swift.String?
    /// The resource ARN of the view.
    public var parentResourceArn: Swift.String?
    /// The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.
    public var permissions: [GlueClientTypes.Permission]?
    /// A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.
    public var querySessionContext: GlueClientTypes.QuerySessionContext?
    /// Specified only if the base tables belong to a different Amazon Web Services Region.
    public var region: Swift.String?
    /// The resource ARN of the root view in a chain of nested views.
    public var rootResourceArn: Swift.String?
    /// A structure specifying the dialect and dialect version used by the query engine.
    public var supportedDialect: GlueClientTypes.SupportedDialect?
    /// Indicates the level of filtering a third-party analytical engine is capable of enforcing when calling the GetUnfilteredTableMetadata API operation. Accepted values are:
    ///
    /// * COLUMN_PERMISSION - Column permissions ensure that users can access only specific columns in the table. If there are particular columns contain sensitive data, data lake administrators can define column filters that exclude access to specific columns.
    ///
    /// * CELL_FILTER_PERMISSION - Cell-level filtering combines column filtering (include or exclude columns) and row filter expressions to restrict access to individual elements in the table.
    ///
    /// * NESTED_PERMISSION - Nested permissions combines cell-level filtering and nested column filtering to restrict access to columns and/or nested columns in specific rows based on row filter expressions.
    ///
    /// * NESTED_CELL_PERMISSION - Nested cell permissions combines nested permission with nested cell-level filtering. This allows different subsets of nested columns to be restricted based on an array of row filter expressions.
    ///
    ///
    /// Note: Each of these permission types follows a hierarchical order where each subsequent permission type includes all permission of the previous type. Important: If you provide a supported permission type that doesn't match the user's level of permissions on the table, then Lake Formation raises an exception. For example, if the third-party engine calling the GetUnfilteredTableMetadata operation can enforce only column-level filtering, and the user has nested cell filtering applied on the table, Lake Formation throws an exception, and will not return unfiltered table metadata and data access credentials.
    /// This member is required.
    public var supportedPermissionTypes: [GlueClientTypes.PermissionType]?

    public init(
        auditContext: GlueClientTypes.AuditContext? = nil,
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        name: Swift.String? = nil,
        parentResourceArn: Swift.String? = nil,
        permissions: [GlueClientTypes.Permission]? = nil,
        querySessionContext: GlueClientTypes.QuerySessionContext? = nil,
        region: Swift.String? = nil,
        rootResourceArn: Swift.String? = nil,
        supportedDialect: GlueClientTypes.SupportedDialect? = nil,
        supportedPermissionTypes: [GlueClientTypes.PermissionType]? = nil
    )
    {
        self.auditContext = auditContext
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.name = name
        self.parentResourceArn = parentResourceArn
        self.permissions = permissions
        self.querySessionContext = querySessionContext
        self.region = region
        self.rootResourceArn = rootResourceArn
        self.supportedDialect = supportedDialect
        self.supportedPermissionTypes = supportedPermissionTypes
    }
}

extension GlueClientTypes {

    /// A filter that uses both column-level and row-level filtering.
    public struct ColumnRowFilter: Swift.Sendable {
        /// A string containing the name of the column.
        public var columnName: Swift.String?
        /// A string containing the row-level filter expression.
        public var rowFilterExpression: Swift.String?

        public init(
            columnName: Swift.String? = nil,
            rowFilterExpression: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.rowFilterExpression = rowFilterExpression
        }
    }
}

public struct GetUsageProfileInput: Swift.Sendable {
    /// The name of the usage profile to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct GetUsageProfileOutput: Swift.Sendable {
    /// A ProfileConfiguration object specifying the job and session values for the profile.
    public var configuration: GlueClientTypes.ProfileConfiguration?
    /// The date and time when the usage profile was created.
    public var createdOn: Foundation.Date?
    /// A description of the usage profile.
    public var description: Swift.String?
    /// The date and time when the usage profile was last modified.
    public var lastModifiedOn: Foundation.Date?
    /// The name of the usage profile.
    public var name: Swift.String?

    public init(
        configuration: GlueClientTypes.ProfileConfiguration? = nil,
        createdOn: Foundation.Date? = nil,
        description: Swift.String? = nil,
        lastModifiedOn: Foundation.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.createdOn = createdOn
        self.description = description
        self.lastModifiedOn = lastModifiedOn
        self.name = name
    }
}

public struct GetUserDefinedFunctionInput: Swift.Sendable {
    /// The ID of the Data Catalog where the function to be retrieved is located. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the catalog database where the function is located.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the function.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.functionName = functionName
    }
}

extension GlueClientTypes {

    /// Represents the equivalent of a Hive user-defined function (UDF) definition.
    public struct UserDefinedFunction: Swift.Sendable {
        /// The ID of the Data Catalog in which the function resides.
        public var catalogId: Swift.String?
        /// The Java class that contains the function code.
        public var className: Swift.String?
        /// The time at which the function was created.
        public var createTime: Foundation.Date?
        /// The name of the catalog database that contains the function.
        public var databaseName: Swift.String?
        /// The name of the function.
        public var functionName: Swift.String?
        /// The owner of the function.
        public var ownerName: Swift.String?
        /// The owner type.
        public var ownerType: GlueClientTypes.PrincipalType?
        /// The resource URIs for the function.
        public var resourceUris: [GlueClientTypes.ResourceUri]?

        public init(
            catalogId: Swift.String? = nil,
            className: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            databaseName: Swift.String? = nil,
            functionName: Swift.String? = nil,
            ownerName: Swift.String? = nil,
            ownerType: GlueClientTypes.PrincipalType? = nil,
            resourceUris: [GlueClientTypes.ResourceUri]? = nil
        )
        {
            self.catalogId = catalogId
            self.className = className
            self.createTime = createTime
            self.databaseName = databaseName
            self.functionName = functionName
            self.ownerName = ownerName
            self.ownerType = ownerType
            self.resourceUris = resourceUris
        }
    }
}

public struct GetUserDefinedFunctionOutput: Swift.Sendable {
    /// The requested function definition.
    public var userDefinedFunction: GlueClientTypes.UserDefinedFunction?

    public init(
        userDefinedFunction: GlueClientTypes.UserDefinedFunction? = nil
    )
    {
        self.userDefinedFunction = userDefinedFunction
    }
}

public struct GetUserDefinedFunctionsInput: Swift.Sendable {
    /// The ID of the Data Catalog where the functions to be retrieved are located. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the catalog database where the functions are located. If none is provided, functions from all the databases across the catalog will be returned.
    public var databaseName: Swift.String?
    /// The maximum number of functions to return in one response.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?
    /// An optional function-name pattern string that filters the function definitions returned.
    /// This member is required.
    public var pattern: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pattern: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pattern = pattern
    }
}

public struct GetUserDefinedFunctionsOutput: Swift.Sendable {
    /// A continuation token, if the list of functions returned does not include the last requested function.
    public var nextToken: Swift.String?
    /// A list of requested function definitions.
    public var userDefinedFunctions: [GlueClientTypes.UserDefinedFunction]?

    public init(
        nextToken: Swift.String? = nil,
        userDefinedFunctions: [GlueClientTypes.UserDefinedFunction]? = nil
    )
    {
        self.nextToken = nextToken
        self.userDefinedFunctions = userDefinedFunctions
    }
}

public struct GetWorkflowInput: Swift.Sendable {
    /// Specifies whether to include a graph when returning the workflow resource metadata.
    public var includeGraph: Swift.Bool?
    /// The name of the workflow to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init(
        includeGraph: Swift.Bool? = nil,
        name: Swift.String? = nil
    )
    {
        self.includeGraph = includeGraph
        self.name = name
    }
}

public struct GetWorkflowOutput: Swift.Sendable {
    /// The resource metadata for the workflow.
    public var workflow: GlueClientTypes.Workflow?

    public init(
        workflow: GlueClientTypes.Workflow? = nil
    )
    {
        self.workflow = workflow
    }
}

public struct GetWorkflowRunInput: Swift.Sendable {
    /// Specifies whether to include the workflow graph in response or not.
    public var includeGraph: Swift.Bool?
    /// Name of the workflow being run.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the workflow run.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        includeGraph: Swift.Bool? = nil,
        name: Swift.String? = nil,
        runId: Swift.String? = nil
    )
    {
        self.includeGraph = includeGraph
        self.name = name
        self.runId = runId
    }
}

public struct GetWorkflowRunOutput: Swift.Sendable {
    /// The requested workflow run metadata.
    public var run: GlueClientTypes.WorkflowRun?

    public init(
        run: GlueClientTypes.WorkflowRun? = nil
    )
    {
        self.run = run
    }
}

public struct GetWorkflowRunPropertiesInput: Swift.Sendable {
    /// Name of the workflow which was run.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the workflow run whose run properties should be returned.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        name: Swift.String? = nil,
        runId: Swift.String? = nil
    )
    {
        self.name = name
        self.runId = runId
    }
}

public struct GetWorkflowRunPropertiesOutput: Swift.Sendable {
    /// The workflow run properties which were set during the specified run.
    public var runProperties: [Swift.String: Swift.String]?

    public init(
        runProperties: [Swift.String: Swift.String]? = nil
    )
    {
        self.runProperties = runProperties
    }
}

public struct GetWorkflowRunsInput: Swift.Sendable {
    /// Specifies whether to include the workflow graph in response or not.
    public var includeGraph: Swift.Bool?
    /// The maximum number of workflow runs to be included in the response.
    public var maxResults: Swift.Int?
    /// Name of the workflow whose metadata of runs should be returned.
    /// This member is required.
    public var name: Swift.String?
    /// The maximum size of the response.
    public var nextToken: Swift.String?

    public init(
        includeGraph: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.includeGraph = includeGraph
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

public struct GetWorkflowRunsOutput: Swift.Sendable {
    /// A continuation token, if not all requested workflow runs have been returned.
    public var nextToken: Swift.String?
    /// A list of workflow run metadata objects.
    public var runs: [GlueClientTypes.WorkflowRun]?

    public init(
        nextToken: Swift.String? = nil,
        runs: [GlueClientTypes.WorkflowRun]? = nil
    )
    {
        self.nextToken = nextToken
        self.runs = runs
    }
}

public struct ImportCatalogToGlueInput: Swift.Sendable {
    /// The ID of the catalog to import. Currently, this should be the Amazon Web Services account ID.
    public var catalogId: Swift.String?

    public init(
        catalogId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
    }
}

public struct ImportCatalogToGlueOutput: Swift.Sendable {

    public init() { }
}

public struct ListBlueprintsInput: Swift.Sendable {
    /// The maximum size of a list to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation request.
    public var nextToken: Swift.String?
    /// Filters the list by an Amazon Web Services resource tag.
    public var tags: [Swift.String: Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct ListBlueprintsOutput: Swift.Sendable {
    /// List of names of blueprints in the account.
    public var blueprints: [Swift.String]?
    /// A continuation token, if not all blueprint names have been returned.
    public var nextToken: Swift.String?

    public init(
        blueprints: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.blueprints = blueprints
        self.nextToken = nextToken
    }
}

public struct ListColumnStatisticsTaskRunsInput: Swift.Sendable {
    /// The maximum size of the response.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListColumnStatisticsTaskRunsOutput: Swift.Sendable {
    /// A list of column statistics task run IDs.
    public var columnStatisticsTaskRunIds: [Swift.String]?
    /// A continuation token, if not all task run IDs have yet been returned.
    public var nextToken: Swift.String?

    public init(
        columnStatisticsTaskRunIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.columnStatisticsTaskRunIds = columnStatisticsTaskRunIds
        self.nextToken = nextToken
    }
}

public struct ListCrawlersInput: Swift.Sendable {
    /// The maximum size of a list to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation request.
    public var nextToken: Swift.String?
    /// Specifies to return only these tagged resources.
    public var tags: [Swift.String: Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct ListCrawlersOutput: Swift.Sendable {
    /// The names of all crawlers in the account, or the crawlers with the specified tags.
    public var crawlerNames: [Swift.String]?
    /// A continuation token, if the returned list does not contain the last metric available.
    public var nextToken: Swift.String?

    public init(
        crawlerNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crawlerNames = crawlerNames
        self.nextToken = nextToken
    }
}

extension GlueClientTypes {

    public enum FieldName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case crawlId
        case dpuHour
        case endTime
        case startTime
        case state
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldName] {
            return [
                .crawlId,
                .dpuHour,
                .endTime,
                .startTime,
                .state
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .crawlId: return "CRAWL_ID"
            case .dpuHour: return "DPU_HOUR"
            case .endTime: return "END_TIME"
            case .startTime: return "START_TIME"
            case .state: return "STATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum FilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case eq
        case ge
        case gt
        case le
        case lt
        case ne
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterOperator] {
            return [
                .eq,
                .ge,
                .gt,
                .le,
                .lt,
                .ne
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .eq: return "EQ"
            case .ge: return "GE"
            case .gt: return "GT"
            case .le: return "LE"
            case .lt: return "LT"
            case .ne: return "NE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A list of fields, comparators and value that you can use to filter the crawler runs for a specified crawler.
    public struct CrawlsFilter: Swift.Sendable {
        /// A key used to filter the crawler runs for a specified crawler. Valid values for each of the field names are:
        ///
        /// * CRAWL_ID: A string representing the UUID identifier for a crawl.
        ///
        /// * STATE: A string representing the state of the crawl.
        ///
        /// * START_TIME and END_TIME: The epoch timestamp in milliseconds.
        ///
        /// * DPU_HOUR: The number of data processing unit (DPU) hours used for the crawl.
        public var fieldName: GlueClientTypes.FieldName?
        /// The value provided for comparison on the crawl field.
        public var fieldValue: Swift.String?
        /// A defined comparator that operates on the value. The available operators are:
        ///
        /// * GT: Greater than.
        ///
        /// * GE: Greater than or equal to.
        ///
        /// * LT: Less than.
        ///
        /// * LE: Less than or equal to.
        ///
        /// * EQ: Equal to.
        ///
        /// * NE: Not equal to.
        public var filterOperator: GlueClientTypes.FilterOperator?

        public init(
            fieldName: GlueClientTypes.FieldName? = nil,
            fieldValue: Swift.String? = nil,
            filterOperator: GlueClientTypes.FilterOperator? = nil
        )
        {
            self.fieldName = fieldName
            self.fieldValue = fieldValue
            self.filterOperator = filterOperator
        }
    }
}

public struct ListCrawlsInput: Swift.Sendable {
    /// The name of the crawler whose runs you want to retrieve.
    /// This member is required.
    public var crawlerName: Swift.String?
    /// Filters the crawls by the criteria you specify in a list of CrawlsFilter objects.
    public var filters: [GlueClientTypes.CrawlsFilter]?
    /// The maximum number of results to return. The default is 20, and maximum is 100.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?

    public init(
        crawlerName: Swift.String? = nil,
        filters: [GlueClientTypes.CrawlsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crawlerName = crawlerName
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GlueClientTypes {

    public enum CrawlerHistoryState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case running
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [CrawlerHistoryState] {
            return [
                .completed,
                .failed,
                .running,
                .stopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Contains the information for a run of a crawler.
    public struct CrawlerHistory: Swift.Sendable {
        /// A UUID identifier for each crawl.
        public var crawlId: Swift.String?
        /// The number of data processing units (DPU) used in hours for the crawl.
        public var dpuHour: Swift.Double
        /// The date and time on which the crawl ended.
        public var endTime: Foundation.Date?
        /// If an error occurred, the error message associated with the crawl.
        public var errorMessage: Swift.String?
        /// The log group associated with the crawl.
        public var logGroup: Swift.String?
        /// The log stream associated with the crawl.
        public var logStream: Swift.String?
        /// The prefix for a CloudWatch message about this crawl.
        public var messagePrefix: Swift.String?
        /// The date and time on which the crawl started.
        public var startTime: Foundation.Date?
        /// The state of the crawl.
        public var state: GlueClientTypes.CrawlerHistoryState?
        /// A run summary for the specific crawl in JSON. Contains the catalog tables and partitions that were added, updated, or deleted.
        public var summary: Swift.String?

        public init(
            crawlId: Swift.String? = nil,
            dpuHour: Swift.Double = 0.0,
            endTime: Foundation.Date? = nil,
            errorMessage: Swift.String? = nil,
            logGroup: Swift.String? = nil,
            logStream: Swift.String? = nil,
            messagePrefix: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: GlueClientTypes.CrawlerHistoryState? = nil,
            summary: Swift.String? = nil
        )
        {
            self.crawlId = crawlId
            self.dpuHour = dpuHour
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.logGroup = logGroup
            self.logStream = logStream
            self.messagePrefix = messagePrefix
            self.startTime = startTime
            self.state = state
            self.summary = summary
        }
    }
}

public struct ListCrawlsOutput: Swift.Sendable {
    /// A list of CrawlerHistory objects representing the crawl runs that meet your criteria.
    public var crawls: [GlueClientTypes.CrawlerHistory]?
    /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
    public var nextToken: Swift.String?

    public init(
        crawls: [GlueClientTypes.CrawlerHistory]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crawls = crawls
        self.nextToken = nextToken
    }
}

public struct ListCustomEntityTypesInput: Swift.Sendable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A paginated token to offset the results.
    public var nextToken: Swift.String?
    /// A list of key-value pair tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct ListCustomEntityTypesOutput: Swift.Sendable {
    /// A list of CustomEntityType objects representing custom patterns.
    public var customEntityTypes: [GlueClientTypes.CustomEntityType]?
    /// A pagination token, if more results are available.
    public var nextToken: Swift.String?

    public init(
        customEntityTypes: [GlueClientTypes.CustomEntityType]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customEntityTypes = customEntityTypes
        self.nextToken = nextToken
    }
}

extension GlueClientTypes {

    /// Criteria used to return data quality results.
    public struct DataQualityResultFilterCriteria: Swift.Sendable {
        /// Filter results by the specified data source. For example, retrieving all results for an Glue table.
        public var dataSource: GlueClientTypes.DataSource?
        /// Filter results by the specified job name.
        public var jobName: Swift.String?
        /// Filter results by the specified job run ID.
        public var jobRunId: Swift.String?
        /// Filter results by runs that started after this time.
        public var startedAfter: Foundation.Date?
        /// Filter results by runs that started before this time.
        public var startedBefore: Foundation.Date?

        public init(
            dataSource: GlueClientTypes.DataSource? = nil,
            jobName: Swift.String? = nil,
            jobRunId: Swift.String? = nil,
            startedAfter: Foundation.Date? = nil,
            startedBefore: Foundation.Date? = nil
        )
        {
            self.dataSource = dataSource
            self.jobName = jobName
            self.jobRunId = jobRunId
            self.startedAfter = startedAfter
            self.startedBefore = startedBefore
        }
    }
}

public struct ListDataQualityResultsInput: Swift.Sendable {
    /// The filter criteria.
    public var filter: GlueClientTypes.DataQualityResultFilterCriteria?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A paginated token to offset the results.
    public var nextToken: Swift.String?

    public init(
        filter: GlueClientTypes.DataQualityResultFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GlueClientTypes {

    /// Describes a data quality result.
    public struct DataQualityResultDescription: Swift.Sendable {
        /// The table name associated with the data quality result.
        public var dataSource: GlueClientTypes.DataSource?
        /// The job name associated with the data quality result.
        public var jobName: Swift.String?
        /// The job run ID associated with the data quality result.
        public var jobRunId: Swift.String?
        /// The unique result ID for this data quality result.
        public var resultId: Swift.String?
        /// The time that the run started for this data quality result.
        public var startedOn: Foundation.Date?

        public init(
            dataSource: GlueClientTypes.DataSource? = nil,
            jobName: Swift.String? = nil,
            jobRunId: Swift.String? = nil,
            resultId: Swift.String? = nil,
            startedOn: Foundation.Date? = nil
        )
        {
            self.dataSource = dataSource
            self.jobName = jobName
            self.jobRunId = jobRunId
            self.resultId = resultId
            self.startedOn = startedOn
        }
    }
}

public struct ListDataQualityResultsOutput: Swift.Sendable {
    /// A pagination token, if more results are available.
    public var nextToken: Swift.String?
    /// A list of DataQualityResultDescription objects.
    /// This member is required.
    public var results: [GlueClientTypes.DataQualityResultDescription]?

    public init(
        nextToken: Swift.String? = nil,
        results: [GlueClientTypes.DataQualityResultDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

extension GlueClientTypes {

    /// A filter for listing data quality recommendation runs.
    public struct DataQualityRuleRecommendationRunFilter: Swift.Sendable {
        /// Filter based on a specified data source (Glue table).
        /// This member is required.
        public var dataSource: GlueClientTypes.DataSource?
        /// Filter based on time for results started after provided time.
        public var startedAfter: Foundation.Date?
        /// Filter based on time for results started before provided time.
        public var startedBefore: Foundation.Date?

        public init(
            dataSource: GlueClientTypes.DataSource? = nil,
            startedAfter: Foundation.Date? = nil,
            startedBefore: Foundation.Date? = nil
        )
        {
            self.dataSource = dataSource
            self.startedAfter = startedAfter
            self.startedBefore = startedBefore
        }
    }
}

public struct ListDataQualityRuleRecommendationRunsInput: Swift.Sendable {
    /// The filter criteria.
    public var filter: GlueClientTypes.DataQualityRuleRecommendationRunFilter?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A paginated token to offset the results.
    public var nextToken: Swift.String?

    public init(
        filter: GlueClientTypes.DataQualityRuleRecommendationRunFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GlueClientTypes {

    /// Describes the result of a data quality rule recommendation run.
    public struct DataQualityRuleRecommendationRunDescription: Swift.Sendable {
        /// The data source (Glue table) associated with the recommendation run.
        public var dataSource: GlueClientTypes.DataSource?
        /// The unique run identifier associated with this run.
        public var runId: Swift.String?
        /// The date and time when this run started.
        public var startedOn: Foundation.Date?
        /// The status for this run.
        public var status: GlueClientTypes.TaskStatusType?

        public init(
            dataSource: GlueClientTypes.DataSource? = nil,
            runId: Swift.String? = nil,
            startedOn: Foundation.Date? = nil,
            status: GlueClientTypes.TaskStatusType? = nil
        )
        {
            self.dataSource = dataSource
            self.runId = runId
            self.startedOn = startedOn
            self.status = status
        }
    }
}

public struct ListDataQualityRuleRecommendationRunsOutput: Swift.Sendable {
    /// A pagination token, if more results are available.
    public var nextToken: Swift.String?
    /// A list of DataQualityRuleRecommendationRunDescription objects.
    public var runs: [GlueClientTypes.DataQualityRuleRecommendationRunDescription]?

    public init(
        nextToken: Swift.String? = nil,
        runs: [GlueClientTypes.DataQualityRuleRecommendationRunDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.runs = runs
    }
}

extension GlueClientTypes {

    /// The filter criteria.
    public struct DataQualityRulesetEvaluationRunFilter: Swift.Sendable {
        /// Filter based on a data source (an Glue table) associated with the run.
        /// This member is required.
        public var dataSource: GlueClientTypes.DataSource?
        /// Filter results by runs that started after this time.
        public var startedAfter: Foundation.Date?
        /// Filter results by runs that started before this time.
        public var startedBefore: Foundation.Date?

        public init(
            dataSource: GlueClientTypes.DataSource? = nil,
            startedAfter: Foundation.Date? = nil,
            startedBefore: Foundation.Date? = nil
        )
        {
            self.dataSource = dataSource
            self.startedAfter = startedAfter
            self.startedBefore = startedBefore
        }
    }
}

public struct ListDataQualityRulesetEvaluationRunsInput: Swift.Sendable {
    /// The filter criteria.
    public var filter: GlueClientTypes.DataQualityRulesetEvaluationRunFilter?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A paginated token to offset the results.
    public var nextToken: Swift.String?

    public init(
        filter: GlueClientTypes.DataQualityRulesetEvaluationRunFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GlueClientTypes {

    /// Describes the result of a data quality ruleset evaluation run.
    public struct DataQualityRulesetEvaluationRunDescription: Swift.Sendable {
        /// The data source (an Glue table) associated with the run.
        public var dataSource: GlueClientTypes.DataSource?
        /// The unique run identifier associated with this run.
        public var runId: Swift.String?
        /// The date and time when the run started.
        public var startedOn: Foundation.Date?
        /// The status for this run.
        public var status: GlueClientTypes.TaskStatusType?

        public init(
            dataSource: GlueClientTypes.DataSource? = nil,
            runId: Swift.String? = nil,
            startedOn: Foundation.Date? = nil,
            status: GlueClientTypes.TaskStatusType? = nil
        )
        {
            self.dataSource = dataSource
            self.runId = runId
            self.startedOn = startedOn
            self.status = status
        }
    }
}

public struct ListDataQualityRulesetEvaluationRunsOutput: Swift.Sendable {
    /// A pagination token, if more results are available.
    public var nextToken: Swift.String?
    /// A list of DataQualityRulesetEvaluationRunDescription objects representing data quality ruleset runs.
    public var runs: [GlueClientTypes.DataQualityRulesetEvaluationRunDescription]?

    public init(
        nextToken: Swift.String? = nil,
        runs: [GlueClientTypes.DataQualityRulesetEvaluationRunDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.runs = runs
    }
}

extension GlueClientTypes {

    /// The criteria used to filter data quality rulesets.
    public struct DataQualityRulesetFilterCriteria: Swift.Sendable {
        /// Filter on rulesets created after this date.
        public var createdAfter: Foundation.Date?
        /// Filter on rulesets created before this date.
        public var createdBefore: Foundation.Date?
        /// The description of the ruleset filter criteria.
        public var description: Swift.String?
        /// Filter on rulesets last modified after this date.
        public var lastModifiedAfter: Foundation.Date?
        /// Filter on rulesets last modified before this date.
        public var lastModifiedBefore: Foundation.Date?
        /// The name of the ruleset filter criteria.
        public var name: Swift.String?
        /// The name and database name of the target table.
        public var targetTable: GlueClientTypes.DataQualityTargetTable?

        public init(
            createdAfter: Foundation.Date? = nil,
            createdBefore: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedAfter: Foundation.Date? = nil,
            lastModifiedBefore: Foundation.Date? = nil,
            name: Swift.String? = nil,
            targetTable: GlueClientTypes.DataQualityTargetTable? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.description = description
            self.lastModifiedAfter = lastModifiedAfter
            self.lastModifiedBefore = lastModifiedBefore
            self.name = name
            self.targetTable = targetTable
        }
    }
}

public struct ListDataQualityRulesetsInput: Swift.Sendable {
    /// The filter criteria.
    public var filter: GlueClientTypes.DataQualityRulesetFilterCriteria?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A paginated token to offset the results.
    public var nextToken: Swift.String?
    /// A list of key-value pair tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        filter: GlueClientTypes.DataQualityRulesetFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tags = tags
    }
}

extension GlueClientTypes {

    /// Describes a data quality ruleset returned by GetDataQualityRuleset.
    public struct DataQualityRulesetListDetails: Swift.Sendable {
        /// The date and time the data quality ruleset was created.
        public var createdOn: Foundation.Date?
        /// A description of the data quality ruleset.
        public var description: Swift.String?
        /// The date and time the data quality ruleset was last modified.
        public var lastModifiedOn: Foundation.Date?
        /// The name of the data quality ruleset.
        public var name: Swift.String?
        /// When a ruleset was created from a recommendation run, this run ID is generated to link the two together.
        public var recommendationRunId: Swift.String?
        /// The number of rules in the ruleset.
        public var ruleCount: Swift.Int?
        /// An object representing an Glue table.
        public var targetTable: GlueClientTypes.DataQualityTargetTable?

        public init(
            createdOn: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedOn: Foundation.Date? = nil,
            name: Swift.String? = nil,
            recommendationRunId: Swift.String? = nil,
            ruleCount: Swift.Int? = nil,
            targetTable: GlueClientTypes.DataQualityTargetTable? = nil
        )
        {
            self.createdOn = createdOn
            self.description = description
            self.lastModifiedOn = lastModifiedOn
            self.name = name
            self.recommendationRunId = recommendationRunId
            self.ruleCount = ruleCount
            self.targetTable = targetTable
        }
    }
}

public struct ListDataQualityRulesetsOutput: Swift.Sendable {
    /// A pagination token, if more results are available.
    public var nextToken: Swift.String?
    /// A paginated list of rulesets for the specified list of Glue tables.
    public var rulesets: [GlueClientTypes.DataQualityRulesetListDetails]?

    public init(
        nextToken: Swift.String? = nil,
        rulesets: [GlueClientTypes.DataQualityRulesetListDetails]? = nil
    )
    {
        self.nextToken = nextToken
        self.rulesets = rulesets
    }
}

extension GlueClientTypes {

    /// A timestamp filter.
    public struct TimestampFilter: Swift.Sendable {
        /// The timestamp after which statistics should be included in the results.
        public var recordedAfter: Foundation.Date?
        /// The timestamp before which statistics should be included in the results.
        public var recordedBefore: Foundation.Date?

        public init(
            recordedAfter: Foundation.Date? = nil,
            recordedBefore: Foundation.Date? = nil
        )
        {
            self.recordedAfter = recordedAfter
            self.recordedBefore = recordedBefore
        }
    }
}

public struct ListDataQualityStatisticAnnotationsInput: Swift.Sendable {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A pagination token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Profile ID.
    public var profileId: Swift.String?
    /// The Statistic ID.
    public var statisticId: Swift.String?
    /// A timestamp filter.
    public var timestampFilter: GlueClientTypes.TimestampFilter?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileId: Swift.String? = nil,
        statisticId: Swift.String? = nil,
        timestampFilter: GlueClientTypes.TimestampFilter? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileId = profileId
        self.statisticId = statisticId
        self.timestampFilter = timestampFilter
    }
}

public struct ListDataQualityStatisticAnnotationsOutput: Swift.Sendable {
    /// A list of StatisticAnnotation applied to the Statistic
    public var annotations: [GlueClientTypes.StatisticAnnotation]?
    /// A pagination token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        annotations: [GlueClientTypes.StatisticAnnotation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.annotations = annotations
        self.nextToken = nextToken
    }
}

public struct ListDataQualityStatisticsInput: Swift.Sendable {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A pagination token to request the next page of results.
    public var nextToken: Swift.String?
    /// The Profile ID.
    public var profileId: Swift.String?
    /// The Statistic ID.
    public var statisticId: Swift.String?
    /// A timestamp filter.
    public var timestampFilter: GlueClientTypes.TimestampFilter?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileId: Swift.String? = nil,
        statisticId: Swift.String? = nil,
        timestampFilter: GlueClientTypes.TimestampFilter? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileId = profileId
        self.statisticId = statisticId
        self.timestampFilter = timestampFilter
    }
}

extension GlueClientTypes {

    public enum StatisticEvaluationLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case column
        case dataset
        case multicolumn
        case sdkUnknown(Swift.String)

        public static var allCases: [StatisticEvaluationLevel] {
            return [
                .column,
                .dataset,
                .multicolumn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .column: return "Column"
            case .dataset: return "Dataset"
            case .multicolumn: return "Multicolumn"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// A run identifier.
    public struct RunIdentifier: Swift.Sendable {
        /// The Job Run ID.
        public var jobRunId: Swift.String?
        /// The Run ID.
        public var runId: Swift.String?

        public init(
            jobRunId: Swift.String? = nil,
            runId: Swift.String? = nil
        )
        {
            self.jobRunId = jobRunId
            self.runId = runId
        }
    }
}

extension GlueClientTypes {

    /// Summary information about a statistic.
    public struct StatisticSummary: Swift.Sendable {
        /// The list of columns referenced by the statistic.
        public var columnsReferenced: [Swift.String]?
        /// The value of the statistic.
        public var doubleValue: Swift.Double
        /// The evaluation level of the statistic. Possible values: Dataset, Column, Multicolumn.
        public var evaluationLevel: GlueClientTypes.StatisticEvaluationLevel?
        /// The inclusion annotation for the statistic.
        public var inclusionAnnotation: GlueClientTypes.TimestampedInclusionAnnotation?
        /// The Profile ID.
        public var profileId: Swift.String?
        /// The timestamp when the statistic was recorded.
        public var recordedOn: Foundation.Date?
        /// The list of datasets referenced by the statistic.
        public var referencedDatasets: [Swift.String]?
        /// The Run Identifier
        public var runIdentifier: GlueClientTypes.RunIdentifier?
        /// The Statistic ID.
        public var statisticId: Swift.String?
        /// The name of the statistic.
        public var statisticName: Swift.String?
        /// A StatisticPropertiesMap, which contains a NameString and DescriptionString
        public var statisticProperties: [Swift.String: Swift.String]?

        public init(
            columnsReferenced: [Swift.String]? = nil,
            doubleValue: Swift.Double = 0.0,
            evaluationLevel: GlueClientTypes.StatisticEvaluationLevel? = nil,
            inclusionAnnotation: GlueClientTypes.TimestampedInclusionAnnotation? = nil,
            profileId: Swift.String? = nil,
            recordedOn: Foundation.Date? = nil,
            referencedDatasets: [Swift.String]? = nil,
            runIdentifier: GlueClientTypes.RunIdentifier? = nil,
            statisticId: Swift.String? = nil,
            statisticName: Swift.String? = nil,
            statisticProperties: [Swift.String: Swift.String]? = nil
        )
        {
            self.columnsReferenced = columnsReferenced
            self.doubleValue = doubleValue
            self.evaluationLevel = evaluationLevel
            self.inclusionAnnotation = inclusionAnnotation
            self.profileId = profileId
            self.recordedOn = recordedOn
            self.referencedDatasets = referencedDatasets
            self.runIdentifier = runIdentifier
            self.statisticId = statisticId
            self.statisticName = statisticName
            self.statisticProperties = statisticProperties
        }
    }
}

extension GlueClientTypes.StatisticSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StatisticSummary(columnsReferenced: \(Swift.String(describing: columnsReferenced)), doubleValue: \(Swift.String(describing: doubleValue)), evaluationLevel: \(Swift.String(describing: evaluationLevel)), inclusionAnnotation: \(Swift.String(describing: inclusionAnnotation)), profileId: \(Swift.String(describing: profileId)), recordedOn: \(Swift.String(describing: recordedOn)), referencedDatasets: \(Swift.String(describing: referencedDatasets)), runIdentifier: \(Swift.String(describing: runIdentifier)), statisticId: \(Swift.String(describing: statisticId)), statisticName: \(Swift.String(describing: statisticName)), statisticProperties: \"CONTENT_REDACTED\")"}
}

public struct ListDataQualityStatisticsOutput: Swift.Sendable {
    /// A pagination token to request the next page of results.
    public var nextToken: Swift.String?
    /// A StatisticSummaryList.
    public var statistics: [GlueClientTypes.StatisticSummary]?

    public init(
        nextToken: Swift.String? = nil,
        statistics: [GlueClientTypes.StatisticSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.statistics = statistics
    }
}

public struct ListDevEndpointsInput: Swift.Sendable {
    /// The maximum size of a list to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation request.
    public var nextToken: Swift.String?
    /// Specifies to return only these tagged resources.
    public var tags: [Swift.String: Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct ListDevEndpointsOutput: Swift.Sendable {
    /// The names of all the DevEndpoints in the account, or the DevEndpoints with the specified tags.
    public var devEndpointNames: [Swift.String]?
    /// A continuation token, if the returned list does not contain the last metric available.
    public var nextToken: Swift.String?

    public init(
        devEndpointNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devEndpointNames = devEndpointNames
        self.nextToken = nextToken
    }
}

public struct ListJobsInput: Swift.Sendable {
    /// The maximum size of a list to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation request.
    public var nextToken: Swift.String?
    /// Specifies to return only these tagged resources.
    public var tags: [Swift.String: Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct ListJobsOutput: Swift.Sendable {
    /// The names of all jobs in the account, or the jobs with the specified tags.
    public var jobNames: [Swift.String]?
    /// A continuation token, if the returned list does not contain the last metric available.
    public var nextToken: Swift.String?

    public init(
        jobNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobNames = jobNames
        self.nextToken = nextToken
    }
}

public struct ListMLTransformsInput: Swift.Sendable {
    /// A TransformFilterCriteria used to filter the machine learning transforms.
    public var filter: GlueClientTypes.TransformFilterCriteria?
    /// The maximum size of a list to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation request.
    public var nextToken: Swift.String?
    /// A TransformSortCriteria used to sort the machine learning transforms.
    public var sort: GlueClientTypes.TransformSortCriteria?
    /// Specifies to return only these tagged resources.
    public var tags: [Swift.String: Swift.String]?

    public init(
        filter: GlueClientTypes.TransformFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: GlueClientTypes.TransformSortCriteria? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
        self.tags = tags
    }
}

public struct ListMLTransformsOutput: Swift.Sendable {
    /// A continuation token, if the returned list does not contain the last metric available.
    public var nextToken: Swift.String?
    /// The identifiers of all the machine learning transforms in the account, or the machine learning transforms with the specified tags.
    /// This member is required.
    public var transformIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        transformIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.transformIds = transformIds
    }
}

public struct ListRegistriesInput: Swift.Sendable {
    /// Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GlueClientTypes {

    /// A structure containing the details for a registry.
    public struct RegistryListItem: Swift.Sendable {
        /// The data the registry was created.
        public var createdTime: Swift.String?
        /// A description of the registry.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the registry.
        public var registryArn: Swift.String?
        /// The name of the registry.
        public var registryName: Swift.String?
        /// The status of the registry.
        public var status: GlueClientTypes.RegistryStatus?
        /// The date the registry was updated.
        public var updatedTime: Swift.String?

        public init(
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            registryArn: Swift.String? = nil,
            registryName: Swift.String? = nil,
            status: GlueClientTypes.RegistryStatus? = nil,
            updatedTime: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
            self.status = status
            self.updatedTime = updatedTime
        }
    }
}

public struct ListRegistriesOutput: Swift.Sendable {
    /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
    public var nextToken: Swift.String?
    /// An array of RegistryDetailedListItem objects containing minimal details of each registry.
    public var registries: [GlueClientTypes.RegistryListItem]?

    public init(
        nextToken: Swift.String? = nil,
        registries: [GlueClientTypes.RegistryListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.registries = registries
    }
}

public struct ListSchemasInput: Swift.Sendable {
    /// Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?
    /// A wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
    public var registryId: GlueClientTypes.RegistryId?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: GlueClientTypes.RegistryId? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
    }
}

extension GlueClientTypes {

    /// An object that contains minimal details for a schema.
    public struct SchemaListItem: Swift.Sendable {
        /// The date and time that a schema was created.
        public var createdTime: Swift.String?
        /// A description for the schema.
        public var description: Swift.String?
        /// the name of the registry where the schema resides.
        public var registryName: Swift.String?
        /// The Amazon Resource Name (ARN) for the schema.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?
        /// The status of the schema.
        public var schemaStatus: GlueClientTypes.SchemaStatus?
        /// The date and time that a schema was updated.
        public var updatedTime: Swift.String?

        public init(
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            registryName: Swift.String? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            schemaStatus: GlueClientTypes.SchemaStatus? = nil,
            updatedTime: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.description = description
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaStatus = schemaStatus
            self.updatedTime = updatedTime
        }
    }
}

public struct ListSchemasOutput: Swift.Sendable {
    /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
    public var nextToken: Swift.String?
    /// An array of SchemaListItem objects containing details of each schema.
    public var schemas: [GlueClientTypes.SchemaListItem]?

    public init(
        nextToken: Swift.String? = nil,
        schemas: [GlueClientTypes.SchemaListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

public struct ListSchemaVersionsInput: Swift.Sendable {
    /// Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?
    /// This is a wrapper structure to contain schema identity fields. The structure contains:
    ///
    /// * SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
    ///
    /// * SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
    /// This member is required.
    public var schemaId: GlueClientTypes.SchemaId?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaId: GlueClientTypes.SchemaId? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaId = schemaId
    }
}

extension GlueClientTypes {

    /// An object containing the details about a schema version.
    public struct SchemaVersionListItem: Swift.Sendable {
        /// The date and time the schema version was created.
        public var createdTime: Swift.String?
        /// The Amazon Resource Name (ARN) of the schema.
        public var schemaArn: Swift.String?
        /// The unique identifier of the schema version.
        public var schemaVersionId: Swift.String?
        /// The status of the schema version.
        public var status: GlueClientTypes.SchemaVersionStatus?
        /// The version number of the schema.
        public var versionNumber: Swift.Int?

        public init(
            createdTime: Swift.String? = nil,
            schemaArn: Swift.String? = nil,
            schemaVersionId: Swift.String? = nil,
            status: GlueClientTypes.SchemaVersionStatus? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.createdTime = createdTime
            self.schemaArn = schemaArn
            self.schemaVersionId = schemaVersionId
            self.status = status
            self.versionNumber = versionNumber
        }
    }
}

public struct ListSchemaVersionsOutput: Swift.Sendable {
    /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
    public var nextToken: Swift.String?
    /// An array of SchemaVersionList objects containing details of each schema version.
    public var schemas: [GlueClientTypes.SchemaVersionListItem]?

    public init(
        nextToken: Swift.String? = nil,
        schemas: [GlueClientTypes.SchemaVersionListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

public struct ListSessionsInput: Swift.Sendable {
    /// The maximum number of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more result.
    public var nextToken: Swift.String?
    /// The origin of the request.
    public var requestOrigin: Swift.String?
    /// Tags belonging to the session.
    public var tags: [Swift.String: Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        requestOrigin: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.requestOrigin = requestOrigin
        self.tags = tags
    }
}

public struct ListSessionsOutput: Swift.Sendable {
    /// Returns the ID of the session.
    public var ids: [Swift.String]?
    /// The token for the next set of results, or null if there are no more result.
    public var nextToken: Swift.String?
    /// Returns the session object.
    public var sessions: [GlueClientTypes.Session]?

    public init(
        ids: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        sessions: [GlueClientTypes.Session]? = nil
    )
    {
        self.ids = ids
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

public struct ListStatementsInput: Swift.Sendable {
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?
    /// The origin of the request to list statements.
    public var requestOrigin: Swift.String?
    /// The Session ID of the statements.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        requestOrigin: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.requestOrigin = requestOrigin
        self.sessionId = sessionId
    }
}

public struct ListStatementsOutput: Swift.Sendable {
    /// A continuation token, if not all statements have yet been returned.
    public var nextToken: Swift.String?
    /// Returns the list of statements.
    public var statements: [GlueClientTypes.Statement]?

    public init(
        nextToken: Swift.String? = nil,
        statements: [GlueClientTypes.Statement]? = nil
    )
    {
        self.nextToken = nextToken
        self.statements = statements
    }
}

public struct ListTableOptimizerRunsInput: Swift.Sendable {
    /// The Catalog ID of the table.
    /// This member is required.
    public var catalogId: Swift.String?
    /// The name of the database in the catalog in which the table resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The maximum number of optimizer runs to return on each call.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?
    /// The type of table optimizer. Currently, the only valid value is compaction.
    /// This member is required.
    public var type: GlueClientTypes.TableOptimizerType?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        tableName: Swift.String? = nil,
        type: GlueClientTypes.TableOptimizerType? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tableName = tableName
        self.type = type
    }
}

public struct ListTableOptimizerRunsOutput: Swift.Sendable {
    /// The Catalog ID of the table.
    public var catalogId: Swift.String?
    /// The name of the database in the catalog in which the table resides.
    public var databaseName: Swift.String?
    /// A continuation token for paginating the returned list of optimizer runs, returned if the current segment of the list is not the last.
    public var nextToken: Swift.String?
    /// The name of the table.
    public var tableName: Swift.String?
    /// A list of the optimizer runs associated with a table.
    public var tableOptimizerRuns: [GlueClientTypes.TableOptimizerRun]?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        tableName: Swift.String? = nil,
        tableOptimizerRuns: [GlueClientTypes.TableOptimizerRun]? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.nextToken = nextToken
        self.tableName = tableName
        self.tableOptimizerRuns = tableOptimizerRuns
    }
}

public struct ListTriggersInput: Swift.Sendable {
    /// The name of the job for which to retrieve triggers. The trigger that can start this job is returned. If there is no such trigger, all triggers are returned.
    public var dependentJobName: Swift.String?
    /// The maximum size of a list to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation request.
    public var nextToken: Swift.String?
    /// Specifies to return only these tagged resources.
    public var tags: [Swift.String: Swift.String]?

    public init(
        dependentJobName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.dependentJobName = dependentJobName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct ListTriggersOutput: Swift.Sendable {
    /// A continuation token, if the returned list does not contain the last metric available.
    public var nextToken: Swift.String?
    /// The names of all triggers in the account, or the triggers with the specified tags.
    public var triggerNames: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        triggerNames: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.triggerNames = triggerNames
    }
}

public struct ListUsageProfilesInput: Swift.Sendable {
    /// The maximum number of usage profiles to return in a single response.
    public var maxResults: Swift.Int?
    /// A continuation token, included if this is a continuation call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GlueClientTypes {

    /// Describes an Glue usage profile.
    public struct UsageProfileDefinition: Swift.Sendable {
        /// The date and time when the usage profile was created.
        public var createdOn: Foundation.Date?
        /// A description of the usage profile.
        public var description: Swift.String?
        /// The date and time when the usage profile was last modified.
        public var lastModifiedOn: Foundation.Date?
        /// The name of the usage profile.
        public var name: Swift.String?

        public init(
            createdOn: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedOn: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdOn = createdOn
            self.description = description
            self.lastModifiedOn = lastModifiedOn
            self.name = name
        }
    }
}

public struct ListUsageProfilesOutput: Swift.Sendable {
    /// A continuation token, present if the current list segment is not the last.
    public var nextToken: Swift.String?
    /// A list of usage profile (UsageProfileDefinition) objects.
    public var profiles: [GlueClientTypes.UsageProfileDefinition]?

    public init(
        nextToken: Swift.String? = nil,
        profiles: [GlueClientTypes.UsageProfileDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

public struct ListWorkflowsInput: Swift.Sendable {
    /// The maximum size of a list to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListWorkflowsOutput: Swift.Sendable {
    /// A continuation token, if not all workflow names have been returned.
    public var nextToken: Swift.String?
    /// List of names of workflows in the account.
    public var workflows: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        workflows: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflows = workflows
    }
}

public struct PutDataCatalogEncryptionSettingsInput: Swift.Sendable {
    /// The ID of the Data Catalog to set the security configuration for. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The security configuration to set.
    /// This member is required.
    public var dataCatalogEncryptionSettings: GlueClientTypes.DataCatalogEncryptionSettings?

    public init(
        catalogId: Swift.String? = nil,
        dataCatalogEncryptionSettings: GlueClientTypes.DataCatalogEncryptionSettings? = nil
    )
    {
        self.catalogId = catalogId
        self.dataCatalogEncryptionSettings = dataCatalogEncryptionSettings
    }
}

public struct PutDataCatalogEncryptionSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct PutDataQualityProfileAnnotationInput: Swift.Sendable {
    /// The inclusion annotation value to apply to the profile.
    /// This member is required.
    public var inclusionAnnotation: GlueClientTypes.InclusionAnnotationValue?
    /// The ID of the data quality monitoring profile to annotate.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        inclusionAnnotation: GlueClientTypes.InclusionAnnotationValue? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.inclusionAnnotation = inclusionAnnotation
        self.profileId = profileId
    }
}

/// Left blank.
public struct PutDataQualityProfileAnnotationOutput: Swift.Sendable {

    public init() { }
}

extension GlueClientTypes {

    public enum EnableHybridValues: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [EnableHybridValues] {
            return [
                .false,
                .true
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    public enum ExistCondition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mustExist
        case `none`
        case notExist
        case sdkUnknown(Swift.String)

        public static var allCases: [ExistCondition] {
            return [
                .mustExist,
                .none,
                .notExist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mustExist: return "MUST_EXIST"
            case .none: return "NONE"
            case .notExist: return "NOT_EXIST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct PutResourcePolicyInput: Swift.Sendable {
    /// If 'TRUE', indicates that you are using both methods to grant cross-account access to Data Catalog resources:
    ///
    /// * By directly updating the resource policy with PutResourePolicy
    ///
    /// * By using the Grant permissions command on the Amazon Web Services Management Console.
    ///
    ///
    /// Must be set to 'TRUE' if you have already used the Management Console to grant cross-account access, otherwise the call fails. Default is 'FALSE'.
    public var enableHybrid: GlueClientTypes.EnableHybridValues?
    /// A value of MUST_EXIST is used to update a policy. A value of NOT_EXIST is used to create a new policy. If a value of NONE or a null value is used, the call does not depend on the existence of a policy.
    public var policyExistsCondition: GlueClientTypes.ExistCondition?
    /// The hash value returned when the previous policy was set using PutResourcePolicy. Its purpose is to prevent concurrent modifications of a policy. Do not use this parameter if no previous policy has been set.
    public var policyHashCondition: Swift.String?
    /// Contains the policy document to set, in JSON format.
    /// This member is required.
    public var policyInJson: Swift.String?
    /// Do not use. For internal use only.
    public var resourceArn: Swift.String?

    public init(
        enableHybrid: GlueClientTypes.EnableHybridValues? = nil,
        policyExistsCondition: GlueClientTypes.ExistCondition? = nil,
        policyHashCondition: Swift.String? = nil,
        policyInJson: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.enableHybrid = enableHybrid
        self.policyExistsCondition = policyExistsCondition
        self.policyHashCondition = policyHashCondition
        self.policyInJson = policyInJson
        self.resourceArn = resourceArn
    }
}

public struct PutResourcePolicyOutput: Swift.Sendable {
    /// A hash of the policy that has just been set. This must be included in a subsequent call that overwrites or updates this policy.
    public var policyHash: Swift.String?

    public init(
        policyHash: Swift.String? = nil
    )
    {
        self.policyHash = policyHash
    }
}

extension GlueClientTypes {

    /// A structure containing a key value pair for metadata.
    public struct MetadataKeyValuePair: Swift.Sendable {
        /// A metadata key.
        public var metadataKey: Swift.String?
        /// A metadata key’s corresponding value.
        public var metadataValue: Swift.String?

        public init(
            metadataKey: Swift.String? = nil,
            metadataValue: Swift.String? = nil
        )
        {
            self.metadataKey = metadataKey
            self.metadataValue = metadataValue
        }
    }
}

public struct PutSchemaVersionMetadataInput: Swift.Sendable {
    /// The metadata key's corresponding value.
    /// This member is required.
    public var metadataKeyValue: GlueClientTypes.MetadataKeyValuePair?
    /// The unique ID for the schema.
    public var schemaId: GlueClientTypes.SchemaId?
    /// The unique version ID of the schema version.
    public var schemaVersionId: Swift.String?
    /// The version number of the schema.
    public var schemaVersionNumber: GlueClientTypes.SchemaVersionNumber?

    public init(
        metadataKeyValue: GlueClientTypes.MetadataKeyValuePair? = nil,
        schemaId: GlueClientTypes.SchemaId? = nil,
        schemaVersionId: Swift.String? = nil,
        schemaVersionNumber: GlueClientTypes.SchemaVersionNumber? = nil
    )
    {
        self.metadataKeyValue = metadataKeyValue
        self.schemaId = schemaId
        self.schemaVersionId = schemaVersionId
        self.schemaVersionNumber = schemaVersionNumber
    }
}

public struct PutSchemaVersionMetadataOutput: Swift.Sendable {
    /// The latest version of the schema.
    public var latestVersion: Swift.Bool
    /// The metadata key.
    public var metadataKey: Swift.String?
    /// The value of the metadata key.
    public var metadataValue: Swift.String?
    /// The name for the registry.
    public var registryName: Swift.String?
    /// The Amazon Resource Name (ARN) for the schema.
    public var schemaArn: Swift.String?
    /// The name for the schema.
    public var schemaName: Swift.String?
    /// The unique version ID of the schema version.
    public var schemaVersionId: Swift.String?
    /// The version number of the schema.
    public var versionNumber: Swift.Int?

    public init(
        latestVersion: Swift.Bool = false,
        metadataKey: Swift.String? = nil,
        metadataValue: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersionId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.latestVersion = latestVersion
        self.metadataKey = metadataKey
        self.metadataValue = metadataValue
        self.registryName = registryName
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersionId = schemaVersionId
        self.versionNumber = versionNumber
    }
}

public struct PutWorkflowRunPropertiesInput: Swift.Sendable {
    /// Name of the workflow which was run.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the workflow run for which the run properties should be updated.
    /// This member is required.
    public var runId: Swift.String?
    /// The properties to put for the specified run.
    /// This member is required.
    public var runProperties: [Swift.String: Swift.String]?

    public init(
        name: Swift.String? = nil,
        runId: Swift.String? = nil,
        runProperties: [Swift.String: Swift.String]? = nil
    )
    {
        self.name = name
        self.runId = runId
        self.runProperties = runProperties
    }
}

public struct PutWorkflowRunPropertiesOutput: Swift.Sendable {

    public init() { }
}

public struct QuerySchemaVersionMetadataInput: Swift.Sendable {
    /// Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
    public var maxResults: Swift.Int?
    /// Search key-value pairs for metadata, if they are not provided all the metadata information will be fetched.
    public var metadataList: [GlueClientTypes.MetadataKeyValuePair]?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?
    /// A wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
    public var schemaId: GlueClientTypes.SchemaId?
    /// The unique version ID of the schema version.
    public var schemaVersionId: Swift.String?
    /// The version number of the schema.
    public var schemaVersionNumber: GlueClientTypes.SchemaVersionNumber?

    public init(
        maxResults: Swift.Int? = nil,
        metadataList: [GlueClientTypes.MetadataKeyValuePair]? = nil,
        nextToken: Swift.String? = nil,
        schemaId: GlueClientTypes.SchemaId? = nil,
        schemaVersionId: Swift.String? = nil,
        schemaVersionNumber: GlueClientTypes.SchemaVersionNumber? = nil
    )
    {
        self.maxResults = maxResults
        self.metadataList = metadataList
        self.nextToken = nextToken
        self.schemaId = schemaId
        self.schemaVersionId = schemaVersionId
        self.schemaVersionNumber = schemaVersionNumber
    }
}

extension GlueClientTypes {

    /// A structure containing other metadata for a schema version belonging to the same metadata key.
    public struct OtherMetadataValueListItem: Swift.Sendable {
        /// The time at which the entry was created.
        public var createdTime: Swift.String?
        /// The metadata key’s corresponding value for the other metadata belonging to the same metadata key.
        public var metadataValue: Swift.String?

        public init(
            createdTime: Swift.String? = nil,
            metadataValue: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.metadataValue = metadataValue
        }
    }
}

extension GlueClientTypes {

    /// A structure containing metadata information for a schema version.
    public struct MetadataInfo: Swift.Sendable {
        /// The time at which the entry was created.
        public var createdTime: Swift.String?
        /// The metadata key’s corresponding value.
        public var metadataValue: Swift.String?
        /// Other metadata belonging to the same metadata key.
        public var otherMetadataValueList: [GlueClientTypes.OtherMetadataValueListItem]?

        public init(
            createdTime: Swift.String? = nil,
            metadataValue: Swift.String? = nil,
            otherMetadataValueList: [GlueClientTypes.OtherMetadataValueListItem]? = nil
        )
        {
            self.createdTime = createdTime
            self.metadataValue = metadataValue
            self.otherMetadataValueList = otherMetadataValueList
        }
    }
}

public struct QuerySchemaVersionMetadataOutput: Swift.Sendable {
    /// A map of a metadata key and associated values.
    public var metadataInfoMap: [Swift.String: GlueClientTypes.MetadataInfo]?
    /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
    public var nextToken: Swift.String?
    /// The unique version ID of the schema version.
    public var schemaVersionId: Swift.String?

    public init(
        metadataInfoMap: [Swift.String: GlueClientTypes.MetadataInfo]? = nil,
        nextToken: Swift.String? = nil,
        schemaVersionId: Swift.String? = nil
    )
    {
        self.metadataInfoMap = metadataInfoMap
        self.nextToken = nextToken
        self.schemaVersionId = schemaVersionId
    }
}

public struct RegisterSchemaVersionInput: Swift.Sendable {
    /// The schema definition using the DataFormat setting for the SchemaName.
    /// This member is required.
    public var schemaDefinition: Swift.String?
    /// This is a wrapper structure to contain schema identity fields. The structure contains:
    ///
    /// * SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
    ///
    /// * SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
    /// This member is required.
    public var schemaId: GlueClientTypes.SchemaId?

    public init(
        schemaDefinition: Swift.String? = nil,
        schemaId: GlueClientTypes.SchemaId? = nil
    )
    {
        self.schemaDefinition = schemaDefinition
        self.schemaId = schemaId
    }
}

public struct RegisterSchemaVersionOutput: Swift.Sendable {
    /// The unique ID that represents the version of this schema.
    public var schemaVersionId: Swift.String?
    /// The status of the schema version.
    public var status: GlueClientTypes.SchemaVersionStatus?
    /// The version of this schema (for sync flow only, in case this is the first version).
    public var versionNumber: Swift.Int?

    public init(
        schemaVersionId: Swift.String? = nil,
        status: GlueClientTypes.SchemaVersionStatus? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.schemaVersionId = schemaVersionId
        self.status = status
        self.versionNumber = versionNumber
    }
}

public struct RemoveSchemaVersionMetadataInput: Swift.Sendable {
    /// The value of the metadata key.
    /// This member is required.
    public var metadataKeyValue: GlueClientTypes.MetadataKeyValuePair?
    /// A wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
    public var schemaId: GlueClientTypes.SchemaId?
    /// The unique version ID of the schema version.
    public var schemaVersionId: Swift.String?
    /// The version number of the schema.
    public var schemaVersionNumber: GlueClientTypes.SchemaVersionNumber?

    public init(
        metadataKeyValue: GlueClientTypes.MetadataKeyValuePair? = nil,
        schemaId: GlueClientTypes.SchemaId? = nil,
        schemaVersionId: Swift.String? = nil,
        schemaVersionNumber: GlueClientTypes.SchemaVersionNumber? = nil
    )
    {
        self.metadataKeyValue = metadataKeyValue
        self.schemaId = schemaId
        self.schemaVersionId = schemaVersionId
        self.schemaVersionNumber = schemaVersionNumber
    }
}

public struct RemoveSchemaVersionMetadataOutput: Swift.Sendable {
    /// The latest version of the schema.
    public var latestVersion: Swift.Bool
    /// The metadata key.
    public var metadataKey: Swift.String?
    /// The value of the metadata key.
    public var metadataValue: Swift.String?
    /// The name of the registry.
    public var registryName: Swift.String?
    /// The Amazon Resource Name (ARN) of the schema.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    public var schemaName: Swift.String?
    /// The version ID for the schema version.
    public var schemaVersionId: Swift.String?
    /// The version number of the schema.
    public var versionNumber: Swift.Int?

    public init(
        latestVersion: Swift.Bool = false,
        metadataKey: Swift.String? = nil,
        metadataValue: Swift.String? = nil,
        registryName: Swift.String? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        schemaVersionId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.latestVersion = latestVersion
        self.metadataKey = metadataKey
        self.metadataValue = metadataValue
        self.registryName = registryName
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.schemaVersionId = schemaVersionId
        self.versionNumber = versionNumber
    }
}

public struct ResetJobBookmarkInput: Swift.Sendable {
    /// The name of the job in question.
    /// This member is required.
    public var jobName: Swift.String?
    /// The unique run identifier associated with this job run.
    public var runId: Swift.String?

    public init(
        jobName: Swift.String? = nil,
        runId: Swift.String? = nil
    )
    {
        self.jobName = jobName
        self.runId = runId
    }
}

public struct ResetJobBookmarkOutput: Swift.Sendable {
    /// The reset bookmark entry.
    public var jobBookmarkEntry: GlueClientTypes.JobBookmarkEntry?

    public init(
        jobBookmarkEntry: GlueClientTypes.JobBookmarkEntry? = nil
    )
    {
        self.jobBookmarkEntry = jobBookmarkEntry
    }
}

/// Too many jobs are being run concurrently.
public struct ConcurrentRunsExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentRunsExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The workflow is in an invalid state to perform a requested operation.
public struct IllegalWorkflowStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalWorkflowStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ResumeWorkflowRunInput: Swift.Sendable {
    /// The name of the workflow to resume.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the node IDs for the nodes you want to restart. The nodes that are to be restarted must have a run attempt in the original run.
    /// This member is required.
    public var nodeIds: [Swift.String]?
    /// The ID of the workflow run to resume.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        name: Swift.String? = nil,
        nodeIds: [Swift.String]? = nil,
        runId: Swift.String? = nil
    )
    {
        self.name = name
        self.nodeIds = nodeIds
        self.runId = runId
    }
}

public struct ResumeWorkflowRunOutput: Swift.Sendable {
    /// A list of the node IDs for the nodes that were actually restarted.
    public var nodeIds: [Swift.String]?
    /// The new ID assigned to the resumed workflow run. Each resume of a workflow run will have a new run ID.
    public var runId: Swift.String?

    public init(
        nodeIds: [Swift.String]? = nil,
        runId: Swift.String? = nil
    )
    {
        self.nodeIds = nodeIds
        self.runId = runId
    }
}

public struct RunStatementInput: Swift.Sendable {
    /// The statement code to be run.
    /// This member is required.
    public var code: Swift.String?
    /// The origin of the request.
    public var requestOrigin: Swift.String?
    /// The Session Id of the statement to be run.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        code: Swift.String? = nil,
        requestOrigin: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.code = code
        self.requestOrigin = requestOrigin
        self.sessionId = sessionId
    }
}

public struct RunStatementOutput: Swift.Sendable {
    /// Returns the Id of the statement that was run.
    public var id: Swift.Int

    public init(
        id: Swift.Int = 0
    )
    {
        self.id = id
    }
}

extension GlueClientTypes {

    public enum Comparator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case greaterThan
        case greaterThanEquals
        case lessThan
        case lessThanEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [Comparator] {
            return [
                .equals,
                .greaterThan,
                .greaterThanEquals,
                .lessThan,
                .lessThanEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanEquals: return "GREATER_THAN_EQUALS"
            case .lessThan: return "LESS_THAN"
            case .lessThanEquals: return "LESS_THAN_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Defines a property predicate.
    public struct PropertyPredicate: Swift.Sendable {
        /// The comparator used to compare this property to others.
        public var comparator: GlueClientTypes.Comparator?
        /// The key of the property.
        public var key: Swift.String?
        /// The value of the property.
        public var value: Swift.String?

        public init(
            comparator: GlueClientTypes.Comparator? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparator = comparator
            self.key = key
            self.value = value
        }
    }
}

extension GlueClientTypes {

    public enum Sort: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [Sort] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASC"
            case .descending: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlueClientTypes {

    /// Specifies a field to sort by and a sort order.
    public struct SortCriterion: Swift.Sendable {
        /// The name of the field on which to sort.
        public var fieldName: Swift.String?
        /// An ascending or descending sort.
        public var sort: GlueClientTypes.Sort?

        public init(
            fieldName: Swift.String? = nil,
            sort: GlueClientTypes.Sort? = nil
        )
        {
            self.fieldName = fieldName
            self.sort = sort
        }
    }
}

public struct SearchTablesInput: Swift.Sendable {
    /// A unique identifier, consisting of  account_id .
    public var catalogId: Swift.String?
    /// A list of key-value pairs, and a comparator used to filter the search results. Returns all entities matching the predicate. The Comparator member of the PropertyPredicate struct is used only for time fields, and can be omitted for other field types. Also, when comparing string values, such as when Key=Name, a fuzzy match algorithm is used. The Key field (for example, the value of the Name field) is split on certain punctuation characters, for example, -, :, #, etc. into tokens. Then each token is exact-match compared with the Value member of PropertyPredicate. For example, if Key=Name and Value=link, tables named customer-link and xx-link-yy are returned, but xxlinkyy is not returned.
    public var filters: [GlueClientTypes.PropertyPredicate]?
    /// Specifies whether to include status details related to a request to create or update an Glue Data Catalog view.
    public var includeStatusDetails: Swift.Bool?
    /// The maximum number of tables to return in a single response.
    public var maxResults: Swift.Int?
    /// A continuation token, included if this is a continuation call.
    public var nextToken: Swift.String?
    /// Allows you to specify that you want to search the tables shared with your account. The allowable values are FOREIGN or ALL.
    ///
    /// * If set to FOREIGN, will search the tables shared with your account.
    ///
    /// * If set to ALL, will search the tables shared with your account, as well as the tables in yor local account.
    public var resourceShareType: GlueClientTypes.ResourceShareType?
    /// A string used for a text search. Specifying a value in quotes filters based on an exact match to the value.
    public var searchText: Swift.String?
    /// A list of criteria for sorting the results by a field name, in an ascending or descending order.
    public var sortCriteria: [GlueClientTypes.SortCriterion]?

    public init(
        catalogId: Swift.String? = nil,
        filters: [GlueClientTypes.PropertyPredicate]? = nil,
        includeStatusDetails: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceShareType: GlueClientTypes.ResourceShareType? = nil,
        searchText: Swift.String? = nil,
        sortCriteria: [GlueClientTypes.SortCriterion]? = nil
    )
    {
        self.catalogId = catalogId
        self.filters = filters
        self.includeStatusDetails = includeStatusDetails
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareType = resourceShareType
        self.searchText = searchText
        self.sortCriteria = sortCriteria
    }
}

/// The blueprint is in an invalid state to perform a requested operation.
public struct IllegalBlueprintStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalBlueprintStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartBlueprintRunInput: Swift.Sendable {
    /// The name of the blueprint.
    /// This member is required.
    public var blueprintName: Swift.String?
    /// Specifies the parameters as a BlueprintParameters object.
    public var parameters: Swift.String?
    /// Specifies the IAM role used to create the workflow.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        blueprintName: Swift.String? = nil,
        parameters: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.blueprintName = blueprintName
        self.parameters = parameters
        self.roleArn = roleArn
    }
}

public struct StartBlueprintRunOutput: Swift.Sendable {
    /// The run ID for this blueprint run.
    public var runId: Swift.String?

    public init(
        runId: Swift.String? = nil
    )
    {
        self.runId = runId
    }
}

public struct StartColumnStatisticsTaskRunInput: Swift.Sendable {
    /// The ID of the Data Catalog where the table reside. If none is supplied, the Amazon Web Services account ID is used by default.
    public var catalogID: Swift.String?
    /// A list of the column names to generate statistics. If none is supplied, all column names for the table will be used by default.
    public var columnNameList: [Swift.String]?
    /// The name of the database where the table resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The IAM role that the service assumes to generate statistics.
    /// This member is required.
    public var role: Swift.String?
    /// The percentage of rows used to generate statistics. If none is supplied, the entire table will be used to generate stats.
    public var sampleSize: Swift.Double?
    /// Name of the security configuration that is used to encrypt CloudWatch logs for the column stats task run.
    public var securityConfiguration: Swift.String?
    /// The name of the table to generate statistics.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogID: Swift.String? = nil,
        columnNameList: [Swift.String]? = nil,
        databaseName: Swift.String? = nil,
        role: Swift.String? = nil,
        sampleSize: Swift.Double? = 0.0,
        securityConfiguration: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogID = catalogID
        self.columnNameList = columnNameList
        self.databaseName = databaseName
        self.role = role
        self.sampleSize = sampleSize
        self.securityConfiguration = securityConfiguration
        self.tableName = tableName
    }
}

public struct StartColumnStatisticsTaskRunOutput: Swift.Sendable {
    /// The identifier for the column statistics task run.
    public var columnStatisticsTaskRunId: Swift.String?

    public init(
        columnStatisticsTaskRunId: Swift.String? = nil
    )
    {
        self.columnStatisticsTaskRunId = columnStatisticsTaskRunId
    }
}

public struct StartColumnStatisticsTaskRunScheduleInput: Swift.Sendable {
    /// The name of the database where the table resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table for which to start a column statistic task run schedule.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

public struct StartColumnStatisticsTaskRunScheduleOutput: Swift.Sendable {

    public init() { }
}

public struct StartCrawlerInput: Swift.Sendable {
    /// Name of the crawler to start.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct StartCrawlerOutput: Swift.Sendable {

    public init() { }
}

/// There is no applicable schedule.
public struct NoScheduleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoScheduleException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified scheduler is already running.
public struct SchedulerRunningException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SchedulerRunningException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartCrawlerScheduleInput: Swift.Sendable {
    /// Name of the crawler to schedule.
    /// This member is required.
    public var crawlerName: Swift.String?

    public init(
        crawlerName: Swift.String? = nil
    )
    {
        self.crawlerName = crawlerName
    }
}

public struct StartCrawlerScheduleOutput: Swift.Sendable {

    public init() { }
}

public struct StartDataQualityRuleRecommendationRunInput: Swift.Sendable {
    /// Used for idempotency and is recommended to be set to a random ID (such as a UUID) to avoid creating or starting multiple instances of the same resource.
    public var clientToken: Swift.String?
    /// A name for the ruleset.
    public var createdRulesetName: Swift.String?
    /// The name of the security configuration created with the data quality encryption option.
    public var dataQualitySecurityConfiguration: Swift.String?
    /// The data source (Glue table) associated with this run.
    /// This member is required.
    public var dataSource: GlueClientTypes.DataSource?
    /// The number of G.1X workers to be used in the run. The default is 5.
    public var numberOfWorkers: Swift.Int?
    /// An IAM role supplied to encrypt the results of the run.
    /// This member is required.
    public var role: Swift.String?
    /// The timeout for a run in minutes. This is the maximum time that a run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
    public var timeout: Swift.Int?

    public init(
        clientToken: Swift.String? = nil,
        createdRulesetName: Swift.String? = nil,
        dataQualitySecurityConfiguration: Swift.String? = nil,
        dataSource: GlueClientTypes.DataSource? = nil,
        numberOfWorkers: Swift.Int? = nil,
        role: Swift.String? = nil,
        timeout: Swift.Int? = nil
    )
    {
        self.clientToken = clientToken
        self.createdRulesetName = createdRulesetName
        self.dataQualitySecurityConfiguration = dataQualitySecurityConfiguration
        self.dataSource = dataSource
        self.numberOfWorkers = numberOfWorkers
        self.role = role
        self.timeout = timeout
    }
}

public struct StartDataQualityRuleRecommendationRunOutput: Swift.Sendable {
    /// The unique run identifier associated with this run.
    public var runId: Swift.String?

    public init(
        runId: Swift.String? = nil
    )
    {
        self.runId = runId
    }
}

public struct StartDataQualityRulesetEvaluationRunInput: Swift.Sendable {
    /// A map of reference strings to additional data sources you can specify for an evaluation run.
    public var additionalDataSources: [Swift.String: GlueClientTypes.DataSource]?
    /// Additional run options you can specify for an evaluation run.
    public var additionalRunOptions: GlueClientTypes.DataQualityEvaluationRunAdditionalRunOptions?
    /// Used for idempotency and is recommended to be set to a random ID (such as a UUID) to avoid creating or starting multiple instances of the same resource.
    public var clientToken: Swift.String?
    /// The data source (Glue table) associated with this run.
    /// This member is required.
    public var dataSource: GlueClientTypes.DataSource?
    /// The number of G.1X workers to be used in the run. The default is 5.
    public var numberOfWorkers: Swift.Int?
    /// An IAM role supplied to encrypt the results of the run.
    /// This member is required.
    public var role: Swift.String?
    /// A list of ruleset names.
    /// This member is required.
    public var rulesetNames: [Swift.String]?
    /// The timeout for a run in minutes. This is the maximum time that a run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
    public var timeout: Swift.Int?

    public init(
        additionalDataSources: [Swift.String: GlueClientTypes.DataSource]? = nil,
        additionalRunOptions: GlueClientTypes.DataQualityEvaluationRunAdditionalRunOptions? = nil,
        clientToken: Swift.String? = nil,
        dataSource: GlueClientTypes.DataSource? = nil,
        numberOfWorkers: Swift.Int? = nil,
        role: Swift.String? = nil,
        rulesetNames: [Swift.String]? = nil,
        timeout: Swift.Int? = nil
    )
    {
        self.additionalDataSources = additionalDataSources
        self.additionalRunOptions = additionalRunOptions
        self.clientToken = clientToken
        self.dataSource = dataSource
        self.numberOfWorkers = numberOfWorkers
        self.role = role
        self.rulesetNames = rulesetNames
        self.timeout = timeout
    }
}

public struct StartDataQualityRulesetEvaluationRunOutput: Swift.Sendable {
    /// The unique run identifier associated with this run.
    public var runId: Swift.String?

    public init(
        runId: Swift.String? = nil
    )
    {
        self.runId = runId
    }
}

public struct StartExportLabelsTaskRunInput: Swift.Sendable {
    /// The Amazon S3 path where you export the labels.
    /// This member is required.
    public var outputS3Path: Swift.String?
    /// The unique identifier of the machine learning transform.
    /// This member is required.
    public var transformId: Swift.String?

    public init(
        outputS3Path: Swift.String? = nil,
        transformId: Swift.String? = nil
    )
    {
        self.outputS3Path = outputS3Path
        self.transformId = transformId
    }
}

public struct StartExportLabelsTaskRunOutput: Swift.Sendable {
    /// The unique identifier for the task run.
    public var taskRunId: Swift.String?

    public init(
        taskRunId: Swift.String? = nil
    )
    {
        self.taskRunId = taskRunId
    }
}

public struct StartImportLabelsTaskRunInput: Swift.Sendable {
    /// The Amazon Simple Storage Service (Amazon S3) path from where you import the labels.
    /// This member is required.
    public var inputS3Path: Swift.String?
    /// Indicates whether to overwrite your existing labels.
    public var replaceAllLabels: Swift.Bool?
    /// The unique identifier of the machine learning transform.
    /// This member is required.
    public var transformId: Swift.String?

    public init(
        inputS3Path: Swift.String? = nil,
        replaceAllLabels: Swift.Bool? = false,
        transformId: Swift.String? = nil
    )
    {
        self.inputS3Path = inputS3Path
        self.replaceAllLabels = replaceAllLabels
        self.transformId = transformId
    }
}

public struct StartImportLabelsTaskRunOutput: Swift.Sendable {
    /// The unique identifier for the task run.
    public var taskRunId: Swift.String?

    public init(
        taskRunId: Swift.String? = nil
    )
    {
        self.taskRunId = taskRunId
    }
}

public struct StartJobRunInput: Swift.Sendable {
    /// This field is deprecated. Use MaxCapacity instead. The number of Glue data processing units (DPUs) to allocate to this JobRun. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [Glue pricing page](https://aws.amazon.com/glue/pricing/).
    @available(*, deprecated, message: "This property is deprecated, use MaxCapacity instead.")
    public var allocatedCapacity: Swift.Int?
    /// The job arguments associated with this run. For this job run, they replace the default arguments set in the job definition itself. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep them within the Job. For information about how to specify and consume your own Job arguments, see the [Calling Glue APIs in Python](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html) topic in the developer guide. For information about the arguments you can provide to this field when configuring Spark jobs, see the [Special Parameters Used by Glue](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html) topic in the developer guide. For information about the arguments you can provide to this field when configuring Ray jobs, see [Using job parameters in Ray jobs](https://docs.aws.amazon.com/glue/latest/dg/author-job-ray-job-parameters.html) in the developer guide.
    public var arguments: [Swift.String: Swift.String]?
    /// Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. Only jobs with Glue version 3.0 and above and command type glueetl will be allowed to set ExecutionClass to FLEX. The flexible execution class is available for Spark jobs.
    public var executionClass: GlueClientTypes.ExecutionClass?
    /// The name of the job definition to use.
    /// This member is required.
    public var jobName: Swift.String?
    /// The ID of a previous JobRun to retry.
    public var jobRunId: Swift.String?
    /// Specifies whether job run queuing is enabled for the job run. A value of true means job run queuing is enabled for the job run. If false or not populated, the job run will not be considered for queueing.
    public var jobRunQueuingEnabled: Swift.Bool?
    /// For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [ Glue pricing page](https://aws.amazon.com/glue/pricing/). For Glue version 2.0+ jobs, you cannot specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers. Do not set MaxCapacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:
    ///
    /// * When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.
    ///
    /// * When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
    public var maxCapacity: Swift.Double?
    /// Specifies configuration properties of a job run notification.
    public var notificationProperty: GlueClientTypes.NotificationProperty?
    /// The number of workers of a defined workerType that are allocated when a job runs.
    public var numberOfWorkers: Swift.Int?
    /// The name of the SecurityConfiguration structure to be used with this job run.
    public var securityConfiguration: Swift.String?
    /// The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. This value overrides the timeout value set in the parent job. Streaming jobs must have timeout values less than 7 days or 10080 minutes. When the value is left blank, the job will be restarted after 7 days based if you have not setup a maintenance window. If you have setup maintenance window, it will be restarted during the maintenance window after 7 days.
    public var timeout: Swift.Int?
    /// The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs.
    ///
    /// * For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.
    ///
    /// * For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.
    ///
    /// * For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).
    ///
    /// * For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.
    ///
    /// * For the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.
    ///
    /// * For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.
    public var workerType: GlueClientTypes.WorkerType?

    public init(
        allocatedCapacity: Swift.Int? = 0,
        arguments: [Swift.String: Swift.String]? = nil,
        executionClass: GlueClientTypes.ExecutionClass? = nil,
        jobName: Swift.String? = nil,
        jobRunId: Swift.String? = nil,
        jobRunQueuingEnabled: Swift.Bool? = nil,
        maxCapacity: Swift.Double? = nil,
        notificationProperty: GlueClientTypes.NotificationProperty? = nil,
        numberOfWorkers: Swift.Int? = nil,
        securityConfiguration: Swift.String? = nil,
        timeout: Swift.Int? = nil,
        workerType: GlueClientTypes.WorkerType? = nil
    )
    {
        self.allocatedCapacity = allocatedCapacity
        self.arguments = arguments
        self.executionClass = executionClass
        self.jobName = jobName
        self.jobRunId = jobRunId
        self.jobRunQueuingEnabled = jobRunQueuingEnabled
        self.maxCapacity = maxCapacity
        self.notificationProperty = notificationProperty
        self.numberOfWorkers = numberOfWorkers
        self.securityConfiguration = securityConfiguration
        self.timeout = timeout
        self.workerType = workerType
    }
}

public struct StartJobRunOutput: Swift.Sendable {
    /// The ID assigned to this job run.
    public var jobRunId: Swift.String?

    public init(
        jobRunId: Swift.String? = nil
    )
    {
        self.jobRunId = jobRunId
    }
}

/// The machine learning transform is not ready to run.
public struct MLTransformNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MLTransformNotReadyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartMLEvaluationTaskRunInput: Swift.Sendable {
    /// The unique identifier of the machine learning transform.
    /// This member is required.
    public var transformId: Swift.String?

    public init(
        transformId: Swift.String? = nil
    )
    {
        self.transformId = transformId
    }
}

public struct StartMLEvaluationTaskRunOutput: Swift.Sendable {
    /// The unique identifier associated with this run.
    public var taskRunId: Swift.String?

    public init(
        taskRunId: Swift.String? = nil
    )
    {
        self.taskRunId = taskRunId
    }
}

public struct StartMLLabelingSetGenerationTaskRunInput: Swift.Sendable {
    /// The Amazon Simple Storage Service (Amazon S3) path where you generate the labeling set.
    /// This member is required.
    public var outputS3Path: Swift.String?
    /// The unique identifier of the machine learning transform.
    /// This member is required.
    public var transformId: Swift.String?

    public init(
        outputS3Path: Swift.String? = nil,
        transformId: Swift.String? = nil
    )
    {
        self.outputS3Path = outputS3Path
        self.transformId = transformId
    }
}

public struct StartMLLabelingSetGenerationTaskRunOutput: Swift.Sendable {
    /// The unique run identifier that is associated with this task run.
    public var taskRunId: Swift.String?

    public init(
        taskRunId: Swift.String? = nil
    )
    {
        self.taskRunId = taskRunId
    }
}

public struct StartTriggerInput: Swift.Sendable {
    /// The name of the trigger to start.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct StartTriggerOutput: Swift.Sendable {
    /// The name of the trigger that was started.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct StartWorkflowRunInput: Swift.Sendable {
    /// The name of the workflow to start.
    /// This member is required.
    public var name: Swift.String?
    /// The workflow run properties for the new workflow run.
    public var runProperties: [Swift.String: Swift.String]?

    public init(
        name: Swift.String? = nil,
        runProperties: [Swift.String: Swift.String]? = nil
    )
    {
        self.name = name
        self.runProperties = runProperties
    }
}

public struct StartWorkflowRunOutput: Swift.Sendable {
    /// An Id for the new run.
    public var runId: Swift.String?

    public init(
        runId: Swift.String? = nil
    )
    {
        self.runId = runId
    }
}

/// An exception thrown when you try to stop a task run when there is no task running.
public struct ColumnStatisticsTaskNotRunningException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ColumnStatisticsTaskNotRunningException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An exception thrown when you try to stop a task run.
public struct ColumnStatisticsTaskStoppingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ColumnStatisticsTaskStoppingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StopColumnStatisticsTaskRunInput: Swift.Sendable {
    /// The name of the database where the table resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

public struct StopColumnStatisticsTaskRunOutput: Swift.Sendable {

    public init() { }
}

public struct StopColumnStatisticsTaskRunScheduleInput: Swift.Sendable {
    /// The name of the database where the table resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table for which to stop a column statistic task run schedule.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

public struct StopColumnStatisticsTaskRunScheduleOutput: Swift.Sendable {

    public init() { }
}

/// The specified crawler is not running.
public struct CrawlerNotRunningException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CrawlerNotRunningException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified crawler is stopping.
public struct CrawlerStoppingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CrawlerStoppingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StopCrawlerInput: Swift.Sendable {
    /// Name of the crawler to stop.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct StopCrawlerOutput: Swift.Sendable {

    public init() { }
}

/// The specified scheduler is not running.
public struct SchedulerNotRunningException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SchedulerNotRunningException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StopCrawlerScheduleInput: Swift.Sendable {
    /// Name of the crawler whose schedule state to set.
    /// This member is required.
    public var crawlerName: Swift.String?

    public init(
        crawlerName: Swift.String? = nil
    )
    {
        self.crawlerName = crawlerName
    }
}

public struct StopCrawlerScheduleOutput: Swift.Sendable {

    public init() { }
}

public struct StopSessionInput: Swift.Sendable {
    /// The ID of the session to be stopped.
    /// This member is required.
    public var id: Swift.String?
    /// The origin of the request.
    public var requestOrigin: Swift.String?

    public init(
        id: Swift.String? = nil,
        requestOrigin: Swift.String? = nil
    )
    {
        self.id = id
        self.requestOrigin = requestOrigin
    }
}

public struct StopSessionOutput: Swift.Sendable {
    /// Returns the Id of the stopped session.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct StopTriggerInput: Swift.Sendable {
    /// The name of the trigger to stop.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct StopTriggerOutput: Swift.Sendable {
    /// The name of the trigger that was stopped.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct StopWorkflowRunInput: Swift.Sendable {
    /// The name of the workflow to stop.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the workflow run to stop.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        name: Swift.String? = nil,
        runId: Swift.String? = nil
    )
    {
        self.name = name
        self.runId = runId
    }
}

public struct StopWorkflowRunOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the Glue resource to which to add the tags. For more information about Glue resource ARNs, see the [Glue ARN string pattern](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-common.html#aws-glue-api-regex-aws-glue-arn-id).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags to add to this resource.
    /// This member is required.
    public var tagsToAdd: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagsToAdd: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagsToAdd = tagsToAdd
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

extension GlueClientTypes {

    /// A structure that is used to specify testing a connection to a service.
    public struct TestConnectionInput: Swift.Sendable {
        /// A structure containing the authentication configuration in the TestConnection request. Required for a connection to Salesforce using OAuth authentication.
        public var authenticationConfiguration: GlueClientTypes.AuthenticationConfigurationInput?
        /// The key-value pairs that define parameters for the connection. JDBC connections use the following connection properties:
        ///
        /// * Required: All of (HOST, PORT, JDBC_ENGINE) or JDBC_CONNECTION_URL.
        ///
        /// * Required: All of (USERNAME, PASSWORD) or SECRET_ID.
        ///
        /// * Optional: JDBC_ENFORCE_SSL, CUSTOM_JDBC_CERT, CUSTOM_JDBC_CERT_STRING, SKIP_CUSTOM_JDBC_CERT_VALIDATION. These parameters are used to configure SSL with JDBC.
        ///
        ///
        /// SALESFORCE connections require the AuthenticationConfiguration member to be configured.
        /// This member is required.
        public var connectionProperties: [Swift.String: Swift.String]?
        /// The type of connection to test. This operation is only available for the JDBC or SALESFORCE connection types.
        /// This member is required.
        public var connectionType: GlueClientTypes.ConnectionType?

        public init(
            authenticationConfiguration: GlueClientTypes.AuthenticationConfigurationInput? = nil,
            connectionProperties: [Swift.String: Swift.String]? = nil,
            connectionType: GlueClientTypes.ConnectionType? = nil
        )
        {
            self.authenticationConfiguration = authenticationConfiguration
            self.connectionProperties = connectionProperties
            self.connectionType = connectionType
        }
    }
}

public struct TestConnectionInput: Swift.Sendable {
    /// Optional. The name of the connection to test. If only name is provided, the operation will get the connection and use that for testing.
    public var connectionName: Swift.String?
    /// A structure that is used to specify testing a connection to a service.
    public var testConnectionInput: GlueClientTypes.TestConnectionInput?

    public init(
        connectionName: Swift.String? = nil,
        testConnectionInput: GlueClientTypes.TestConnectionInput? = nil
    )
    {
        self.connectionName = connectionName
        self.testConnectionInput = testConnectionInput
    }
}

public struct TestConnectionOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource from which to remove the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags to remove from this resource.
    /// This member is required.
    public var tagsToRemove: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagsToRemove: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagsToRemove = tagsToRemove
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateBlueprintInput: Swift.Sendable {
    /// Specifies a path in Amazon S3 where the blueprint is published.
    /// This member is required.
    public var blueprintLocation: Swift.String?
    /// A description of the blueprint.
    public var description: Swift.String?
    /// The name of the blueprint.
    /// This member is required.
    public var name: Swift.String?

    public init(
        blueprintLocation: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.blueprintLocation = blueprintLocation
        self.description = description
        self.name = name
    }
}

public struct UpdateBlueprintOutput: Swift.Sendable {
    /// Returns the name of the blueprint that was updated.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

/// There was a version conflict.
public struct VersionMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "VersionMismatchException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GlueClientTypes {

    /// Specifies a custom CSV classifier to be updated.
    public struct UpdateCsvClassifierRequest: Swift.Sendable {
        /// Enables the processing of files that contain only one column.
        public var allowSingleColumn: Swift.Bool?
        /// Indicates whether the CSV file contains a header.
        public var containsHeader: GlueClientTypes.CsvHeaderOption?
        /// Specifies the configuration of custom datatypes.
        public var customDatatypeConfigured: Swift.Bool?
        /// Specifies a list of supported custom datatypes.
        public var customDatatypes: [Swift.String]?
        /// A custom symbol to denote what separates each column entry in the row.
        public var delimiter: Swift.String?
        /// Specifies not to trim values before identifying the type of column values. The default value is true.
        public var disableValueTrimming: Swift.Bool?
        /// A list of strings representing column names.
        public var header: [Swift.String]?
        /// The name of the classifier.
        /// This member is required.
        public var name: Swift.String?
        /// A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
        public var quoteSymbol: Swift.String?
        /// Sets the SerDe for processing CSV in the classifier, which will be applied in the Data Catalog. Valid values are OpenCSVSerDe, LazySimpleSerDe, and None. You can specify the None value when you want the crawler to do the detection.
        public var serde: GlueClientTypes.CsvSerdeOption?

        public init(
            allowSingleColumn: Swift.Bool? = nil,
            containsHeader: GlueClientTypes.CsvHeaderOption? = nil,
            customDatatypeConfigured: Swift.Bool? = nil,
            customDatatypes: [Swift.String]? = nil,
            delimiter: Swift.String? = nil,
            disableValueTrimming: Swift.Bool? = nil,
            header: [Swift.String]? = nil,
            name: Swift.String? = nil,
            quoteSymbol: Swift.String? = nil,
            serde: GlueClientTypes.CsvSerdeOption? = nil
        )
        {
            self.allowSingleColumn = allowSingleColumn
            self.containsHeader = containsHeader
            self.customDatatypeConfigured = customDatatypeConfigured
            self.customDatatypes = customDatatypes
            self.delimiter = delimiter
            self.disableValueTrimming = disableValueTrimming
            self.header = header
            self.name = name
            self.quoteSymbol = quoteSymbol
            self.serde = serde
        }
    }
}

extension GlueClientTypes {

    /// Specifies a grok classifier to update when passed to UpdateClassifier.
    public struct UpdateGrokClassifierRequest: Swift.Sendable {
        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
        public var classification: Swift.String?
        /// Optional custom grok patterns used by this classifier.
        public var customPatterns: Swift.String?
        /// The grok pattern used by this classifier.
        public var grokPattern: Swift.String?
        /// The name of the GrokClassifier.
        /// This member is required.
        public var name: Swift.String?

        public init(
            classification: Swift.String? = nil,
            customPatterns: Swift.String? = nil,
            grokPattern: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.classification = classification
            self.customPatterns = customPatterns
            self.grokPattern = grokPattern
            self.name = name
        }
    }
}

extension GlueClientTypes {

    /// Specifies a JSON classifier to be updated.
    public struct UpdateJsonClassifierRequest: Swift.Sendable {
        /// A JsonPath string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in [Writing JsonPath Custom Classifiers](https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json).
        public var jsonPath: Swift.String?
        /// The name of the classifier.
        /// This member is required.
        public var name: Swift.String?

        public init(
            jsonPath: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.jsonPath = jsonPath
            self.name = name
        }
    }
}

extension GlueClientTypes {

    /// Specifies an XML classifier to be updated.
    public struct UpdateXMLClassifierRequest: Swift.Sendable {
        /// An identifier of the data format that the classifier matches.
        public var classification: Swift.String?
        /// The name of the classifier.
        /// This member is required.
        public var name: Swift.String?
        /// The XML tag designating the element that contains each record in an XML document being parsed. This cannot identify a self-closing element (closed by />). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example,  is okay, but  is not).
        public var rowTag: Swift.String?

        public init(
            classification: Swift.String? = nil,
            name: Swift.String? = nil,
            rowTag: Swift.String? = nil
        )
        {
            self.classification = classification
            self.name = name
            self.rowTag = rowTag
        }
    }
}

public struct UpdateClassifierInput: Swift.Sendable {
    /// A CsvClassifier object with updated fields.
    public var csvClassifier: GlueClientTypes.UpdateCsvClassifierRequest?
    /// A GrokClassifier object with updated fields.
    public var grokClassifier: GlueClientTypes.UpdateGrokClassifierRequest?
    /// A JsonClassifier object with updated fields.
    public var jsonClassifier: GlueClientTypes.UpdateJsonClassifierRequest?
    /// An XMLClassifier object with updated fields.
    public var xmlClassifier: GlueClientTypes.UpdateXMLClassifierRequest?

    public init(
        csvClassifier: GlueClientTypes.UpdateCsvClassifierRequest? = nil,
        grokClassifier: GlueClientTypes.UpdateGrokClassifierRequest? = nil,
        jsonClassifier: GlueClientTypes.UpdateJsonClassifierRequest? = nil,
        xmlClassifier: GlueClientTypes.UpdateXMLClassifierRequest? = nil
    )
    {
        self.csvClassifier = csvClassifier
        self.grokClassifier = grokClassifier
        self.jsonClassifier = jsonClassifier
        self.xmlClassifier = xmlClassifier
    }
}

public struct UpdateClassifierOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateColumnStatisticsForPartitionInput: Swift.Sendable {
    /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// A list of the column statistics.
    /// This member is required.
    public var columnStatisticsList: [GlueClientTypes.ColumnStatistics]?
    /// The name of the catalog database where the partitions reside.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A list of partition values identifying the partition.
    /// This member is required.
    public var partitionValues: [Swift.String]?
    /// The name of the partitions' table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        columnStatisticsList: [GlueClientTypes.ColumnStatistics]? = nil,
        databaseName: Swift.String? = nil,
        partitionValues: [Swift.String]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.columnStatisticsList = columnStatisticsList
        self.databaseName = databaseName
        self.partitionValues = partitionValues
        self.tableName = tableName
    }
}

extension GlueClientTypes {

    /// Encapsulates a ColumnStatistics object that failed and the reason for failure.
    public struct ColumnStatisticsError: Swift.Sendable {
        /// The ColumnStatistics of the column.
        public var columnStatistics: GlueClientTypes.ColumnStatistics?
        /// An error message with the reason for the failure of an operation.
        public var error: GlueClientTypes.ErrorDetail?

        public init(
            columnStatistics: GlueClientTypes.ColumnStatistics? = nil,
            error: GlueClientTypes.ErrorDetail? = nil
        )
        {
            self.columnStatistics = columnStatistics
            self.error = error
        }
    }
}

public struct UpdateColumnStatisticsForPartitionOutput: Swift.Sendable {
    /// Error occurred during updating column statistics data.
    public var errors: [GlueClientTypes.ColumnStatisticsError]?

    public init(
        errors: [GlueClientTypes.ColumnStatisticsError]? = nil
    )
    {
        self.errors = errors
    }
}

public struct UpdateColumnStatisticsForTableInput: Swift.Sendable {
    /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// A list of the column statistics.
    /// This member is required.
    public var columnStatisticsList: [GlueClientTypes.ColumnStatistics]?
    /// The name of the catalog database where the partitions reside.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the partitions' table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        columnStatisticsList: [GlueClientTypes.ColumnStatistics]? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.columnStatisticsList = columnStatisticsList
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

public struct UpdateColumnStatisticsForTableOutput: Swift.Sendable {
    /// List of ColumnStatisticsErrors.
    public var errors: [GlueClientTypes.ColumnStatisticsError]?

    public init(
        errors: [GlueClientTypes.ColumnStatisticsError]? = nil
    )
    {
        self.errors = errors
    }
}

public struct UpdateColumnStatisticsTaskSettingsInput: Swift.Sendable {
    /// The ID of the Data Catalog in which the database resides.
    public var catalogID: Swift.String?
    /// A list of column names for which to run statistics.
    public var columnNameList: [Swift.String]?
    /// The name of the database where the table resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The role used for running the column statistics.
    public var role: Swift.String?
    /// The percentage of data to sample.
    public var sampleSize: Swift.Double?
    /// A schedule for running the column statistics, specified in CRON syntax.
    public var schedule: Swift.String?
    /// Name of the security configuration that is used to encrypt CloudWatch logs.
    public var securityConfiguration: Swift.String?
    /// The name of the table for which to generate column statistics.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogID: Swift.String? = nil,
        columnNameList: [Swift.String]? = nil,
        databaseName: Swift.String? = nil,
        role: Swift.String? = nil,
        sampleSize: Swift.Double? = 0.0,
        schedule: Swift.String? = nil,
        securityConfiguration: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogID = catalogID
        self.columnNameList = columnNameList
        self.databaseName = databaseName
        self.role = role
        self.sampleSize = sampleSize
        self.schedule = schedule
        self.securityConfiguration = securityConfiguration
        self.tableName = tableName
    }
}

public struct UpdateColumnStatisticsTaskSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateConnectionInput: Swift.Sendable {
    /// The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// A ConnectionInput object that redefines the connection in question.
    /// This member is required.
    public var connectionInput: GlueClientTypes.ConnectionInput?
    /// The name of the connection definition to update.
    /// This member is required.
    public var name: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        connectionInput: GlueClientTypes.ConnectionInput? = nil,
        name: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.connectionInput = connectionInput
        self.name = name
    }
}

public struct UpdateConnectionOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateCrawlerInput: Swift.Sendable {
    /// A list of custom classifiers that the user has registered. By default, all built-in classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
    public var classifiers: [Swift.String]?
    /// Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see [Setting crawler configuration options](https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html).
    public var configuration: Swift.String?
    /// The name of the SecurityConfiguration structure to be used by this crawler.
    public var crawlerSecurityConfiguration: Swift.String?
    /// The Glue database where results are stored, such as: arn:aws:daylight:us-east-1::database/sometable/*.
    public var databaseName: Swift.String?
    /// A description of the new crawler.
    public var description: Swift.String?
    /// Specifies Lake Formation configuration settings for the crawler.
    public var lakeFormationConfiguration: GlueClientTypes.LakeFormationConfiguration?
    /// Specifies data lineage configuration settings for the crawler.
    public var lineageConfiguration: GlueClientTypes.LineageConfiguration?
    /// Name of the new crawler.
    /// This member is required.
    public var name: Swift.String?
    /// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.
    public var recrawlPolicy: GlueClientTypes.RecrawlPolicy?
    /// The IAM role or Amazon Resource Name (ARN) of an IAM role that is used by the new crawler to access customer resources.
    public var role: Swift.String?
    /// A cron expression used to specify the schedule (see [Time-Based Schedules for Jobs and Crawlers](https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html). For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
    public var schedule: Swift.String?
    /// The policy for the crawler's update and deletion behavior.
    public var schemaChangePolicy: GlueClientTypes.SchemaChangePolicy?
    /// The table prefix used for catalog tables that are created.
    public var tablePrefix: Swift.String?
    /// A list of targets to crawl.
    public var targets: GlueClientTypes.CrawlerTargets?

    public init(
        classifiers: [Swift.String]? = nil,
        configuration: Swift.String? = nil,
        crawlerSecurityConfiguration: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        description: Swift.String? = nil,
        lakeFormationConfiguration: GlueClientTypes.LakeFormationConfiguration? = nil,
        lineageConfiguration: GlueClientTypes.LineageConfiguration? = nil,
        name: Swift.String? = nil,
        recrawlPolicy: GlueClientTypes.RecrawlPolicy? = nil,
        role: Swift.String? = nil,
        schedule: Swift.String? = nil,
        schemaChangePolicy: GlueClientTypes.SchemaChangePolicy? = nil,
        tablePrefix: Swift.String? = nil,
        targets: GlueClientTypes.CrawlerTargets? = nil
    )
    {
        self.classifiers = classifiers
        self.configuration = configuration
        self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
        self.databaseName = databaseName
        self.description = description
        self.lakeFormationConfiguration = lakeFormationConfiguration
        self.lineageConfiguration = lineageConfiguration
        self.name = name
        self.recrawlPolicy = recrawlPolicy
        self.role = role
        self.schedule = schedule
        self.schemaChangePolicy = schemaChangePolicy
        self.tablePrefix = tablePrefix
        self.targets = targets
    }
}

public struct UpdateCrawlerOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateCrawlerScheduleInput: Swift.Sendable {
    /// The name of the crawler whose schedule to update.
    /// This member is required.
    public var crawlerName: Swift.String?
    /// The updated cron expression used to specify the schedule (see [Time-Based Schedules for Jobs and Crawlers](https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html). For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
    public var schedule: Swift.String?

    public init(
        crawlerName: Swift.String? = nil,
        schedule: Swift.String? = nil
    )
    {
        self.crawlerName = crawlerName
        self.schedule = schedule
    }
}

public struct UpdateCrawlerScheduleOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDatabaseInput: Swift.Sendable {
    /// The ID of the Data Catalog in which the metadata database resides. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// A DatabaseInput object specifying the new definition of the metadata database in the catalog.
    /// This member is required.
    public var databaseInput: GlueClientTypes.DatabaseInput?
    /// The name of the database to update in the catalog. For Hive compatibility, this is folded to lowercase.
    /// This member is required.
    public var name: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseInput: GlueClientTypes.DatabaseInput? = nil,
        name: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseInput = databaseInput
        self.name = name
    }
}

public struct UpdateDatabaseOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDataQualityRulesetInput: Swift.Sendable {
    /// A description of the ruleset.
    public var description: Swift.String?
    /// The name of the data quality ruleset.
    /// This member is required.
    public var name: Swift.String?
    /// A Data Quality Definition Language (DQDL) ruleset. For more information, see the Glue developer guide.
    public var ruleset: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        ruleset: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.ruleset = ruleset
    }
}

public struct UpdateDataQualityRulesetOutput: Swift.Sendable {
    /// A description of the ruleset.
    public var description: Swift.String?
    /// The name of the data quality ruleset.
    public var name: Swift.String?
    /// A Data Quality Definition Language (DQDL) ruleset. For more information, see the Glue developer guide.
    public var ruleset: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        ruleset: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.ruleset = ruleset
    }
}

extension GlueClientTypes {

    /// Custom libraries to be loaded into a development endpoint.
    public struct DevEndpointCustomLibraries: Swift.Sendable {
        /// The path to one or more Java .jar files in an S3 bucket that should be loaded in your DevEndpoint. You can only use pure Java/Scala libraries with a DevEndpoint.
        public var extraJarsS3Path: Swift.String?
        /// The paths to one or more Python libraries in an Amazon Simple Storage Service (Amazon S3) bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma. You can only use pure Python libraries with a DevEndpoint. Libraries that rely on C extensions, such as the [pandas](http://pandas.pydata.org/) Python data analysis library, are not currently supported.
        public var extraPythonLibsS3Path: Swift.String?

        public init(
            extraJarsS3Path: Swift.String? = nil,
            extraPythonLibsS3Path: Swift.String? = nil
        )
        {
            self.extraJarsS3Path = extraJarsS3Path
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
        }
    }
}

public struct UpdateDevEndpointInput: Swift.Sendable {
    /// The map of arguments to add the map of arguments used to configure the DevEndpoint. Valid arguments are:
    ///
    /// * "--enable-glue-datacatalog": ""
    ///
    ///
    /// You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
    public var addArguments: [Swift.String: Swift.String]?
    /// The list of public keys for the DevEndpoint to use.
    public var addPublicKeys: [Swift.String]?
    /// Custom Python or Java libraries to be loaded in the DevEndpoint.
    public var customLibraries: GlueClientTypes.DevEndpointCustomLibraries?
    /// The list of argument keys to be deleted from the map of arguments used to configure the DevEndpoint.
    public var deleteArguments: [Swift.String]?
    /// The list of public keys to be deleted from the DevEndpoint.
    public var deletePublicKeys: [Swift.String]?
    /// The name of the DevEndpoint to be updated.
    /// This member is required.
    public var endpointName: Swift.String?
    /// The public key for the DevEndpoint to use.
    public var publicKey: Swift.String?
    /// True if the list of custom libraries to be loaded in the development endpoint needs to be updated, or False if otherwise.
    public var updateEtlLibraries: Swift.Bool?

    public init(
        addArguments: [Swift.String: Swift.String]? = nil,
        addPublicKeys: [Swift.String]? = nil,
        customLibraries: GlueClientTypes.DevEndpointCustomLibraries? = nil,
        deleteArguments: [Swift.String]? = nil,
        deletePublicKeys: [Swift.String]? = nil,
        endpointName: Swift.String? = nil,
        publicKey: Swift.String? = nil,
        updateEtlLibraries: Swift.Bool? = false
    )
    {
        self.addArguments = addArguments
        self.addPublicKeys = addPublicKeys
        self.customLibraries = customLibraries
        self.deleteArguments = deleteArguments
        self.deletePublicKeys = deletePublicKeys
        self.endpointName = endpointName
        self.publicKey = publicKey
        self.updateEtlLibraries = updateEtlLibraries
    }
}

public struct UpdateDevEndpointOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateJobOutput: Swift.Sendable {
    /// Returns the name of the updated job definition.
    public var jobName: Swift.String?

    public init(
        jobName: Swift.String? = nil
    )
    {
        self.jobName = jobName
    }
}

public struct UpdateJobFromSourceControlInput: Swift.Sendable {
    /// The type of authentication, which can be an authentication token stored in Amazon Web Services Secrets Manager, or a personal access token.
    public var authStrategy: GlueClientTypes.SourceControlAuthStrategy?
    /// The value of the authorization token.
    public var authToken: Swift.String?
    /// An optional branch in the remote repository.
    public var branchName: Swift.String?
    /// A commit ID for a commit in the remote repository.
    public var commitId: Swift.String?
    /// An optional folder in the remote repository.
    public var folder: Swift.String?
    /// The name of the Glue job to be synchronized to or from the remote repository.
    public var jobName: Swift.String?
    /// The provider for the remote repository. Possible values: GITHUB, AWS_CODE_COMMIT, GITLAB, BITBUCKET.
    public var provider: GlueClientTypes.SourceControlProvider?
    /// The name of the remote repository that contains the job artifacts. For BitBucket providers, RepositoryName should include WorkspaceName. Use the format /.
    public var repositoryName: Swift.String?
    /// The owner of the remote repository that contains the job artifacts.
    public var repositoryOwner: Swift.String?

    public init(
        authStrategy: GlueClientTypes.SourceControlAuthStrategy? = nil,
        authToken: Swift.String? = nil,
        branchName: Swift.String? = nil,
        commitId: Swift.String? = nil,
        folder: Swift.String? = nil,
        jobName: Swift.String? = nil,
        provider: GlueClientTypes.SourceControlProvider? = nil,
        repositoryName: Swift.String? = nil,
        repositoryOwner: Swift.String? = nil
    )
    {
        self.authStrategy = authStrategy
        self.authToken = authToken
        self.branchName = branchName
        self.commitId = commitId
        self.folder = folder
        self.jobName = jobName
        self.provider = provider
        self.repositoryName = repositoryName
        self.repositoryOwner = repositoryOwner
    }
}

public struct UpdateJobFromSourceControlOutput: Swift.Sendable {
    /// The name of the Glue job.
    public var jobName: Swift.String?

    public init(
        jobName: Swift.String? = nil
    )
    {
        self.jobName = jobName
    }
}

public struct UpdateMLTransformInput: Swift.Sendable {
    /// A description of the transform. The default is an empty string.
    public var description: Swift.String?
    /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see [Glue Versions](https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions) in the developer guide.
    public var glueVersion: Swift.String?
    /// The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [Glue pricing page](https://aws.amazon.com/glue/pricing/). When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only.
    public var maxCapacity: Swift.Double?
    /// The maximum number of times to retry a task for this transform after a task run fails.
    public var maxRetries: Swift.Int?
    /// The unique name that you gave the transform when you created it.
    public var name: Swift.String?
    /// The number of workers of a defined workerType that are allocated when this task runs.
    public var numberOfWorkers: Swift.Int?
    /// The configuration parameters that are specific to the transform type (algorithm) used. Conditionally dependent on the transform type.
    public var parameters: GlueClientTypes.TransformParameters?
    /// The name or Amazon Resource Name (ARN) of the IAM role with the required permissions.
    public var role: Swift.String?
    /// The timeout for a task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
    public var timeout: Swift.Int?
    /// A unique identifier that was generated when the transform was created.
    /// This member is required.
    public var transformId: Swift.String?
    /// The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.
    ///
    /// * For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.
    ///
    /// * For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.
    ///
    /// * For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.
    public var workerType: GlueClientTypes.WorkerType?

    public init(
        description: Swift.String? = nil,
        glueVersion: Swift.String? = nil,
        maxCapacity: Swift.Double? = nil,
        maxRetries: Swift.Int? = nil,
        name: Swift.String? = nil,
        numberOfWorkers: Swift.Int? = nil,
        parameters: GlueClientTypes.TransformParameters? = nil,
        role: Swift.String? = nil,
        timeout: Swift.Int? = nil,
        transformId: Swift.String? = nil,
        workerType: GlueClientTypes.WorkerType? = nil
    )
    {
        self.description = description
        self.glueVersion = glueVersion
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.numberOfWorkers = numberOfWorkers
        self.parameters = parameters
        self.role = role
        self.timeout = timeout
        self.transformId = transformId
        self.workerType = workerType
    }
}

public struct UpdateMLTransformOutput: Swift.Sendable {
    /// The unique identifier for the transform that was updated.
    public var transformId: Swift.String?

    public init(
        transformId: Swift.String? = nil
    )
    {
        self.transformId = transformId
    }
}

public struct UpdatePartitionInput: Swift.Sendable {
    /// The ID of the Data Catalog where the partition to be updated resides. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the catalog database in which the table in question resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The new partition object to update the partition to. The Values property can't be changed. If you want to change the partition key values for a partition, delete and recreate the partition.
    /// This member is required.
    public var partitionInput: GlueClientTypes.PartitionInput?
    /// List of partition key values that define the partition to update.
    /// This member is required.
    public var partitionValueList: [Swift.String]?
    /// The name of the table in which the partition to be updated is located.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        partitionInput: GlueClientTypes.PartitionInput? = nil,
        partitionValueList: [Swift.String]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.partitionInput = partitionInput
        self.partitionValueList = partitionValueList
        self.tableName = tableName
    }
}

public struct UpdatePartitionOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateRegistryInput: Swift.Sendable {
    /// A description of the registry. If description is not provided, this field will not be updated.
    /// This member is required.
    public var description: Swift.String?
    /// This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
    /// This member is required.
    public var registryId: GlueClientTypes.RegistryId?

    public init(
        description: Swift.String? = nil,
        registryId: GlueClientTypes.RegistryId? = nil
    )
    {
        self.description = description
        self.registryId = registryId
    }
}

public struct UpdateRegistryOutput: Swift.Sendable {
    /// The Amazon Resource name (ARN) of the updated registry.
    public var registryArn: Swift.String?
    /// The name of the updated registry.
    public var registryName: Swift.String?

    public init(
        registryArn: Swift.String? = nil,
        registryName: Swift.String? = nil
    )
    {
        self.registryArn = registryArn
        self.registryName = registryName
    }
}

public struct UpdateSchemaInput: Swift.Sendable {
    /// The new compatibility setting for the schema.
    public var compatibility: GlueClientTypes.Compatibility?
    /// The new description for the schema.
    public var description: Swift.String?
    /// This is a wrapper structure to contain schema identity fields. The structure contains:
    ///
    /// * SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.
    ///
    /// * SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to be provided.
    /// This member is required.
    public var schemaId: GlueClientTypes.SchemaId?
    /// Version number required for check pointing. One of VersionNumber or Compatibility has to be provided.
    public var schemaVersionNumber: GlueClientTypes.SchemaVersionNumber?

    public init(
        compatibility: GlueClientTypes.Compatibility? = nil,
        description: Swift.String? = nil,
        schemaId: GlueClientTypes.SchemaId? = nil,
        schemaVersionNumber: GlueClientTypes.SchemaVersionNumber? = nil
    )
    {
        self.compatibility = compatibility
        self.description = description
        self.schemaId = schemaId
        self.schemaVersionNumber = schemaVersionNumber
    }
}

public struct UpdateSchemaOutput: Swift.Sendable {
    /// The name of the registry that contains the schema.
    public var registryName: Swift.String?
    /// The Amazon Resource Name (ARN) of the schema.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    public var schemaName: Swift.String?

    public init(
        registryName: Swift.String? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.registryName = registryName
        self.schemaArn = schemaArn
        self.schemaName = schemaName
    }
}

public struct UpdateSourceControlFromJobInput: Swift.Sendable {
    /// The type of authentication, which can be an authentication token stored in Amazon Web Services Secrets Manager, or a personal access token.
    public var authStrategy: GlueClientTypes.SourceControlAuthStrategy?
    /// The value of the authorization token.
    public var authToken: Swift.String?
    /// An optional branch in the remote repository.
    public var branchName: Swift.String?
    /// A commit ID for a commit in the remote repository.
    public var commitId: Swift.String?
    /// An optional folder in the remote repository.
    public var folder: Swift.String?
    /// The name of the Glue job to be synchronized to or from the remote repository.
    public var jobName: Swift.String?
    /// The provider for the remote repository. Possible values: GITHUB, AWS_CODE_COMMIT, GITLAB, BITBUCKET.
    public var provider: GlueClientTypes.SourceControlProvider?
    /// The name of the remote repository that contains the job artifacts. For BitBucket providers, RepositoryName should include WorkspaceName. Use the format /.
    public var repositoryName: Swift.String?
    /// The owner of the remote repository that contains the job artifacts.
    public var repositoryOwner: Swift.String?

    public init(
        authStrategy: GlueClientTypes.SourceControlAuthStrategy? = nil,
        authToken: Swift.String? = nil,
        branchName: Swift.String? = nil,
        commitId: Swift.String? = nil,
        folder: Swift.String? = nil,
        jobName: Swift.String? = nil,
        provider: GlueClientTypes.SourceControlProvider? = nil,
        repositoryName: Swift.String? = nil,
        repositoryOwner: Swift.String? = nil
    )
    {
        self.authStrategy = authStrategy
        self.authToken = authToken
        self.branchName = branchName
        self.commitId = commitId
        self.folder = folder
        self.jobName = jobName
        self.provider = provider
        self.repositoryName = repositoryName
        self.repositoryOwner = repositoryOwner
    }
}

public struct UpdateSourceControlFromJobOutput: Swift.Sendable {
    /// The name of the Glue job.
    public var jobName: Swift.String?

    public init(
        jobName: Swift.String? = nil
    )
    {
        self.jobName = jobName
    }
}

extension GlueClientTypes {

    public enum ViewUpdateAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case add
        case addOrReplace
        case drop
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [ViewUpdateAction] {
            return [
                .add,
                .addOrReplace,
                .drop,
                .replace
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .addOrReplace: return "ADD_OR_REPLACE"
            case .drop: return "DROP"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateTableInput: Swift.Sendable {
    /// The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the catalog database in which the table resides. For Hive compatibility, this name is entirely lowercase.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A flag that can be set to true to ignore matching storage descriptor and subobject matching requirements.
    public var force: Swift.Bool?
    /// By default, UpdateTable always creates an archived version of the table before updating it. However, if skipArchive is set to true, UpdateTable does not create the archived version.
    public var skipArchive: Swift.Bool?
    /// An updated TableInput object to define the metadata table in the catalog.
    /// This member is required.
    public var tableInput: GlueClientTypes.TableInput?
    /// The transaction ID at which to update the table contents.
    public var transactionId: Swift.String?
    /// The version ID at which to update the table contents.
    public var versionId: Swift.String?
    /// The operation to be performed when updating the view.
    public var viewUpdateAction: GlueClientTypes.ViewUpdateAction?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        force: Swift.Bool? = false,
        skipArchive: Swift.Bool? = nil,
        tableInput: GlueClientTypes.TableInput? = nil,
        transactionId: Swift.String? = nil,
        versionId: Swift.String? = nil,
        viewUpdateAction: GlueClientTypes.ViewUpdateAction? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.force = force
        self.skipArchive = skipArchive
        self.tableInput = tableInput
        self.transactionId = transactionId
        self.versionId = versionId
        self.viewUpdateAction = viewUpdateAction
    }
}

public struct UpdateTableOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateTableOptimizerInput: Swift.Sendable {
    /// The Catalog ID of the table.
    /// This member is required.
    public var catalogId: Swift.String?
    /// The name of the database in the catalog in which the table resides.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?
    /// A TableOptimizerConfiguration object representing the configuration of a table optimizer.
    /// This member is required.
    public var tableOptimizerConfiguration: GlueClientTypes.TableOptimizerConfiguration?
    /// The type of table optimizer. Currently, the only valid value is compaction.
    /// This member is required.
    public var type: GlueClientTypes.TableOptimizerType?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil,
        tableOptimizerConfiguration: GlueClientTypes.TableOptimizerConfiguration? = nil,
        type: GlueClientTypes.TableOptimizerType? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tableName = tableName
        self.tableOptimizerConfiguration = tableOptimizerConfiguration
        self.type = type
    }
}

public struct UpdateTableOptimizerOutput: Swift.Sendable {

    public init() { }
}

extension GlueClientTypes {

    /// A structure used to provide information used to update a trigger. This object updates the previous trigger definition by overwriting it completely.
    public struct TriggerUpdate: Swift.Sendable {
        /// The actions initiated by this trigger.
        public var actions: [GlueClientTypes.Action]?
        /// A description of this trigger.
        public var description: Swift.String?
        /// Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.
        public var eventBatchingCondition: GlueClientTypes.EventBatchingCondition?
        /// Reserved for future use.
        public var name: Swift.String?
        /// The predicate of this trigger, which defines when it will fire.
        public var predicate: GlueClientTypes.Predicate?
        /// A cron expression used to specify the schedule (see [Time-Based Schedules for Jobs and Crawlers](https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html). For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public var schedule: Swift.String?

        public init(
            actions: [GlueClientTypes.Action]? = nil,
            description: Swift.String? = nil,
            eventBatchingCondition: GlueClientTypes.EventBatchingCondition? = nil,
            name: Swift.String? = nil,
            predicate: GlueClientTypes.Predicate? = nil,
            schedule: Swift.String? = nil
        )
        {
            self.actions = actions
            self.description = description
            self.eventBatchingCondition = eventBatchingCondition
            self.name = name
            self.predicate = predicate
            self.schedule = schedule
        }
    }
}

public struct UpdateTriggerInput: Swift.Sendable {
    /// The name of the trigger to update.
    /// This member is required.
    public var name: Swift.String?
    /// The new values with which to update the trigger.
    /// This member is required.
    public var triggerUpdate: GlueClientTypes.TriggerUpdate?

    public init(
        name: Swift.String? = nil,
        triggerUpdate: GlueClientTypes.TriggerUpdate? = nil
    )
    {
        self.name = name
        self.triggerUpdate = triggerUpdate
    }
}

public struct UpdateTriggerOutput: Swift.Sendable {
    /// The resulting trigger definition.
    public var trigger: GlueClientTypes.Trigger?

    public init(
        trigger: GlueClientTypes.Trigger? = nil
    )
    {
        self.trigger = trigger
    }
}

public struct UpdateUsageProfileInput: Swift.Sendable {
    /// A ProfileConfiguration object specifying the job and session values for the profile.
    /// This member is required.
    public var configuration: GlueClientTypes.ProfileConfiguration?
    /// A description of the usage profile.
    public var description: Swift.String?
    /// The name of the usage profile.
    /// This member is required.
    public var name: Swift.String?

    public init(
        configuration: GlueClientTypes.ProfileConfiguration? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.description = description
        self.name = name
    }
}

public struct UpdateUsageProfileOutput: Swift.Sendable {
    /// The name of the usage profile that was updated.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct UpdateUserDefinedFunctionInput: Swift.Sendable {
    /// The ID of the Data Catalog where the function to be updated is located. If none is provided, the Amazon Web Services account ID is used by default.
    public var catalogId: Swift.String?
    /// The name of the catalog database where the function to be updated is located.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A FunctionInput object that redefines the function in the Data Catalog.
    /// This member is required.
    public var functionInput: GlueClientTypes.UserDefinedFunctionInput?
    /// The name of the function.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        functionInput: GlueClientTypes.UserDefinedFunctionInput? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.functionInput = functionInput
        self.functionName = functionName
    }
}

public struct UpdateUserDefinedFunctionOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateWorkflowInput: Swift.Sendable {
    /// A collection of properties to be used as part of each execution of the workflow.
    public var defaultRunProperties: [Swift.String: Swift.String]?
    /// The description of the workflow.
    public var description: Swift.String?
    /// You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.
    public var maxConcurrentRuns: Swift.Int?
    /// Name of the workflow to be updated.
    /// This member is required.
    public var name: Swift.String?

    public init(
        defaultRunProperties: [Swift.String: Swift.String]? = nil,
        description: Swift.String? = nil,
        maxConcurrentRuns: Swift.Int? = nil,
        name: Swift.String? = nil
    )
    {
        self.defaultRunProperties = defaultRunProperties
        self.description = description
        self.maxConcurrentRuns = maxConcurrentRuns
        self.name = name
    }
}

public struct UpdateWorkflowOutput: Swift.Sendable {
    /// The name of the workflow which was specified in input.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension GlueClientTypes {

    /// Specifies the mapping of data property keys.
    public struct Mapping: Swift.Sendable {
        /// Only applicable to nested data structures. If you want to change the parent structure, but also one of its children, you can fill out this data strucutre. It is also Mapping, but its FromPath will be the parent's FromPath plus the FromPath from this structure. For the children part, suppose you have the structure: { "FromPath": "OuterStructure", "ToKey": "OuterStructure", "ToType": "Struct", "Dropped": false, "Chidlren": [{ "FromPath": "inner", "ToKey": "inner", "ToType": "Double", "Dropped": false, }] } You can specify a Mapping that looks like: { "FromPath": "OuterStructure", "ToKey": "OuterStructure", "ToType": "Struct", "Dropped": false, "Chidlren": [{ "FromPath": "inner", "ToKey": "inner", "ToType": "Double", "Dropped": false, }] }
        public var children: [GlueClientTypes.Mapping]?
        /// If true, then the column is removed.
        public var dropped: Swift.Bool?
        /// The table or column to be modified.
        public var fromPath: [Swift.String]?
        /// The type of the data to be modified.
        public var fromType: Swift.String?
        /// After the apply mapping, what the name of the column should be. Can be the same as FromPath.
        public var toKey: Swift.String?
        /// The data type that the data is to be modified to.
        public var toType: Swift.String?

        public init(
            children: [GlueClientTypes.Mapping]? = nil,
            dropped: Swift.Bool? = nil,
            fromPath: [Swift.String]? = nil,
            fromType: Swift.String? = nil,
            toKey: Swift.String? = nil,
            toType: Swift.String? = nil
        )
        {
            self.children = children
            self.dropped = dropped
            self.fromPath = fromPath
            self.fromType = fromType
            self.toKey = toKey
            self.toType = toType
        }
    }
}

extension GlueClientTypes {

    /// Specifies a transform that maps data property keys in the data source to data property keys in the data target. You can rename keys, modify the data types for keys, and choose which keys to drop from the dataset.
    public struct ApplyMapping: Swift.Sendable {
        /// The data inputs identified by their node names.
        /// This member is required.
        public var inputs: [Swift.String]?
        /// Specifies the mapping of data property keys in the data source to data property keys in the data target.
        /// This member is required.
        public var mapping: [GlueClientTypes.Mapping]?
        /// The name of the transform node.
        /// This member is required.
        public var name: Swift.String?

        public init(
            inputs: [Swift.String]? = nil,
            mapping: [GlueClientTypes.Mapping]? = nil,
            name: Swift.String? = nil
        )
        {
            self.inputs = inputs
            self.mapping = mapping
            self.name = name
        }
    }
}

extension GlueClientTypes {

    /// A structure containing information about an asynchronous change to a table.
    public struct StatusDetails: Swift.Sendable {
        /// A Table object representing the requested changes.
        @Indirect public var requestedChange: GlueClientTypes.Table?
        /// A list of ViewValidation objects that contain information for an analytical engine to validate a view.
        public var viewValidations: [GlueClientTypes.ViewValidation]?

        public init(
            requestedChange: GlueClientTypes.Table? = nil,
            viewValidations: [GlueClientTypes.ViewValidation]? = nil
        )
        {
            self.requestedChange = requestedChange
            self.viewValidations = viewValidations
        }
    }
}

extension GlueClientTypes {

    /// Represents a collection of related data organized in columns and rows.
    public struct Table: Swift.Sendable {
        /// The ID of the Data Catalog in which the table resides.
        public var catalogId: Swift.String?
        /// The time when the table definition was created in the Data Catalog.
        public var createTime: Foundation.Date?
        /// The person or entity who created the table.
        public var createdBy: Swift.String?
        /// The name of the database where the table metadata resides. For Hive compatibility, this must be all lowercase.
        public var databaseName: Swift.String?
        /// A description of the table.
        public var description: Swift.String?
        /// A FederatedTable structure that references an entity outside the Glue Data Catalog.
        public var federatedTable: GlueClientTypes.FederatedTable?
        /// Specifies whether the view supports the SQL dialects of one or more different query engines and can therefore be read by those engines.
        public var isMultiDialectView: Swift.Bool?
        /// Indicates whether the table has been registered with Lake Formation.
        public var isRegisteredWithLakeFormation: Swift.Bool
        /// The last time that the table was accessed. This is usually taken from HDFS, and might not be reliable.
        public var lastAccessTime: Foundation.Date?
        /// The last time that column statistics were computed for this table.
        public var lastAnalyzedTime: Foundation.Date?
        /// The table name. For Hive compatibility, this must be entirely lowercase.
        /// This member is required.
        public var name: Swift.String?
        /// The owner of the table.
        public var owner: Swift.String?
        /// These key-value pairs define properties associated with the table.
        public var parameters: [Swift.String: Swift.String]?
        /// A list of columns by which the table is partitioned. Only primitive types are supported as partition keys. When you create a table used by Amazon Athena, and you do not specify any partitionKeys, you must at least set the value of partitionKeys to an empty list. For example: "PartitionKeys": []
        public var partitionKeys: [GlueClientTypes.Column]?
        /// The retention time for this table.
        public var retention: Swift.Int
        /// A structure containing information about the state of an asynchronous change to a table.
        public var status: GlueClientTypes.TableStatus?
        /// A storage descriptor containing information about the physical storage of this table.
        public var storageDescriptor: GlueClientTypes.StorageDescriptor?
        /// The type of this table. Glue will create tables with the EXTERNAL_TABLE type. Other services, such as Athena, may create tables with additional table types. Glue related table types: EXTERNAL_TABLE Hive compatible attribute - indicates a non-Hive managed table. GOVERNED Used by Lake Formation. The Glue Data Catalog understands GOVERNED.
        public var tableType: Swift.String?
        /// A TableIdentifier structure that describes a target table for resource linking.
        public var targetTable: GlueClientTypes.TableIdentifier?
        /// The last time that the table was updated.
        public var updateTime: Foundation.Date?
        /// The ID of the table version.
        public var versionId: Swift.String?
        /// A structure that contains all the information that defines the view, including the dialect or dialects for the view, and the query.
        public var viewDefinition: GlueClientTypes.ViewDefinition?
        /// Included for Apache Hive compatibility. Not used in the normal course of Glue operations.
        public var viewExpandedText: Swift.String?
        /// Included for Apache Hive compatibility. Not used in the normal course of Glue operations. If the table is a VIRTUAL_VIEW, certain Athena configuration encoded in base64.
        public var viewOriginalText: Swift.String?

        public init(
            catalogId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            description: Swift.String? = nil,
            federatedTable: GlueClientTypes.FederatedTable? = nil,
            isMultiDialectView: Swift.Bool? = nil,
            isRegisteredWithLakeFormation: Swift.Bool = false,
            lastAccessTime: Foundation.Date? = nil,
            lastAnalyzedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            partitionKeys: [GlueClientTypes.Column]? = nil,
            retention: Swift.Int = 0,
            status: GlueClientTypes.TableStatus? = nil,
            storageDescriptor: GlueClientTypes.StorageDescriptor? = nil,
            tableType: Swift.String? = nil,
            targetTable: GlueClientTypes.TableIdentifier? = nil,
            updateTime: Foundation.Date? = nil,
            versionId: Swift.String? = nil,
            viewDefinition: GlueClientTypes.ViewDefinition? = nil,
            viewExpandedText: Swift.String? = nil,
            viewOriginalText: Swift.String? = nil
        )
        {
            self.catalogId = catalogId
            self.createTime = createTime
            self.createdBy = createdBy
            self.databaseName = databaseName
            self.description = description
            self.federatedTable = federatedTable
            self.isMultiDialectView = isMultiDialectView
            self.isRegisteredWithLakeFormation = isRegisteredWithLakeFormation
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.partitionKeys = partitionKeys
            self.retention = retention
            self.status = status
            self.storageDescriptor = storageDescriptor
            self.tableType = tableType
            self.targetTable = targetTable
            self.updateTime = updateTime
            self.versionId = versionId
            self.viewDefinition = viewDefinition
            self.viewExpandedText = viewExpandedText
            self.viewOriginalText = viewOriginalText
        }
    }
}

extension GlueClientTypes {

    /// A structure containing information about the state of an asynchronous change to a table.
    public struct TableStatus: Swift.Sendable {
        /// Indicates which action was called on the table, currently only CREATE or UPDATE.
        public var action: GlueClientTypes.ResourceAction?
        /// A StatusDetails object with information about the requested change.
        public var details: GlueClientTypes.StatusDetails?
        /// An error that will only appear when the state is "FAILED". This is a parent level exception message, there may be different Errors for each dialect.
        public var error: GlueClientTypes.ErrorDetail?
        /// An ISO 8601 formatted date string indicating the time that the change was initiated.
        public var requestTime: Foundation.Date?
        /// The ARN of the user who requested the asynchronous change.
        public var requestedBy: Swift.String?
        /// A generic status for the change in progress, such as QUEUED, IN_PROGRESS, SUCCESS, or FAILED.
        public var state: GlueClientTypes.ResourceState?
        /// An ISO 8601 formatted date string indicating the time that the state was last updated.
        public var updateTime: Foundation.Date?
        /// The ARN of the user to last manually alter the asynchronous change (requesting cancellation, etc).
        public var updatedBy: Swift.String?

        public init(
            action: GlueClientTypes.ResourceAction? = nil,
            details: GlueClientTypes.StatusDetails? = nil,
            error: GlueClientTypes.ErrorDetail? = nil,
            requestTime: Foundation.Date? = nil,
            requestedBy: Swift.String? = nil,
            state: GlueClientTypes.ResourceState? = nil,
            updateTime: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.action = action
            self.details = details
            self.error = error
            self.requestTime = requestTime
            self.requestedBy = requestedBy
            self.state = state
            self.updateTime = updateTime
            self.updatedBy = updatedBy
        }
    }
}

extension GlueClientTypes {

    /// CodeGenConfigurationNode enumerates all valid Node types. One and only one of its member variables can be populated.
    public struct CodeGenConfigurationNode: Swift.Sendable {
        /// Specifies a transform that groups rows by chosen fields and computes the aggregated value by specified function.
        public var aggregate: GlueClientTypes.Aggregate?
        /// Specifies a target that writes to a data source in Amazon Redshift.
        public var amazonRedshiftSource: GlueClientTypes.AmazonRedshiftSource?
        /// Specifies a target that writes to a data target in Amazon Redshift.
        public var amazonRedshiftTarget: GlueClientTypes.AmazonRedshiftTarget?
        /// Specifies a transform that maps data property keys in the data source to data property keys in the data target. You can rename keys, modify the data types for keys, and choose which keys to drop from the dataset.
        public var applyMapping: GlueClientTypes.ApplyMapping?
        /// Specifies a connector to an Amazon Athena data source.
        public var athenaConnectorSource: GlueClientTypes.AthenaConnectorSource?
        /// Specifies a Delta Lake data source that is registered in the Glue Data Catalog.
        public var catalogDeltaSource: GlueClientTypes.CatalogDeltaSource?
        /// Specifies a Hudi data source that is registered in the Glue Data Catalog.
        public var catalogHudiSource: GlueClientTypes.CatalogHudiSource?
        /// Specifies an Apache Kafka data store in the Data Catalog.
        public var catalogKafkaSource: GlueClientTypes.CatalogKafkaSource?
        /// Specifies a Kinesis data source in the Glue Data Catalog.
        public var catalogKinesisSource: GlueClientTypes.CatalogKinesisSource?
        /// Specifies a data store in the Glue Data Catalog.
        public var catalogSource: GlueClientTypes.CatalogSource?
        /// Specifies a target that uses a Glue Data Catalog table.
        public var catalogTarget: GlueClientTypes.BasicCatalogTarget?
        /// Specifies a source generated with standard connection options.
        public var connectorDataSource: GlueClientTypes.ConnectorDataSource?
        /// Specifies a target generated with standard connection options.
        public var connectorDataTarget: GlueClientTypes.ConnectorDataTarget?
        /// Specifies a transform that uses custom code you provide to perform the data transformation. The output is a collection of DynamicFrames.
        public var customCode: GlueClientTypes.CustomCode?
        /// Specifies the direct JDBC source connection.
        public var directJDBCSource: GlueClientTypes.DirectJDBCSource?
        /// Specifies an Apache Kafka data store.
        public var directKafkaSource: GlueClientTypes.DirectKafkaSource?
        /// Specifies a direct Amazon Kinesis data source.
        public var directKinesisSource: GlueClientTypes.DirectKinesisSource?
        /// Specifies a transform that removes rows of repeating data from a data set.
        public var dropDuplicates: GlueClientTypes.DropDuplicates?
        /// Specifies a transform that chooses the data property keys that you want to drop.
        public var dropFields: GlueClientTypes.DropFields?
        /// Specifies a transform that removes columns from the dataset if all values in the column are 'null'. By default, Glue Studio will recognize null objects, but some values such as empty strings, strings that are "null", -1 integers or other placeholders such as zeros, are not automatically recognized as nulls.
        public var dropNullFields: GlueClientTypes.DropNullFields?
        /// Specifies a custom visual transform created by a user.
        public var dynamicTransform: GlueClientTypes.DynamicTransform?
        /// Specifies a DynamoDBC Catalog data store in the Glue Data Catalog.
        public var dynamoDBCatalogSource: GlueClientTypes.DynamoDBCatalogSource?
        /// Specifies your data quality evaluation criteria.
        public var evaluateDataQuality: GlueClientTypes.EvaluateDataQuality?
        /// Specifies your data quality evaluation criteria. Allows multiple input data and returns a collection of Dynamic Frames.
        public var evaluateDataQualityMultiFrame: GlueClientTypes.EvaluateDataQualityMultiFrame?
        /// Specifies a transform that locates records in the dataset that have missing values and adds a new field with a value determined by imputation. The input data set is used to train the machine learning model that determines what the missing value should be.
        public var fillMissingValues: GlueClientTypes.FillMissingValues?
        /// Specifies a transform that splits a dataset into two, based on a filter condition.
        public var filter: GlueClientTypes.Filter?
        /// Specifies a data source in a goverened Data Catalog.
        public var governedCatalogSource: GlueClientTypes.GovernedCatalogSource?
        /// Specifies a data target that writes to a goverened catalog.
        public var governedCatalogTarget: GlueClientTypes.GovernedCatalogTarget?
        /// Specifies a connector to a JDBC data source.
        public var jdbcConnectorSource: GlueClientTypes.JDBCConnectorSource?
        /// Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.
        public var jdbcConnectorTarget: GlueClientTypes.JDBCConnectorTarget?
        /// Specifies a transform that joins two datasets into one dataset using a comparison phrase on the specified data property keys. You can use inner, outer, left, right, left semi, and left anti joins.
        public var join: GlueClientTypes.Join?
        /// Specifies a transform that merges a DynamicFrame with a staging DynamicFrame based on the specified primary keys to identify records. Duplicate records (records with the same primary keys) are not de-duplicated.
        public var merge: GlueClientTypes.Merge?
        /// Specifies a Microsoft SQL server data source in the Glue Data Catalog.
        public var microsoftSQLServerCatalogSource: GlueClientTypes.MicrosoftSQLServerCatalogSource?
        /// Specifies a target that uses Microsoft SQL.
        public var microsoftSQLServerCatalogTarget: GlueClientTypes.MicrosoftSQLServerCatalogTarget?
        /// Specifies a MySQL data source in the Glue Data Catalog.
        public var mySQLCatalogSource: GlueClientTypes.MySQLCatalogSource?
        /// Specifies a target that uses MySQL.
        public var mySQLCatalogTarget: GlueClientTypes.MySQLCatalogTarget?
        /// Specifies an Oracle data source in the Glue Data Catalog.
        public var oracleSQLCatalogSource: GlueClientTypes.OracleSQLCatalogSource?
        /// Specifies a target that uses Oracle SQL.
        public var oracleSQLCatalogTarget: GlueClientTypes.OracleSQLCatalogTarget?
        /// Specifies a transform that identifies, removes or masks PII data.
        public var piiDetection: GlueClientTypes.PIIDetection?
        /// Specifies a PostgresSQL data source in the Glue Data Catalog.
        public var postgreSQLCatalogSource: GlueClientTypes.PostgreSQLCatalogSource?
        /// Specifies a target that uses Postgres SQL.
        public var postgreSQLCatalogTarget: GlueClientTypes.PostgreSQLCatalogTarget?
        /// Specifies a Glue DataBrew recipe node.
        public var recipe: GlueClientTypes.Recipe?
        /// Specifies an Amazon Redshift data store.
        public var redshiftSource: GlueClientTypes.RedshiftSource?
        /// Specifies a target that uses Amazon Redshift.
        public var redshiftTarget: GlueClientTypes.RedshiftTarget?
        /// Specifies a relational catalog data store in the Glue Data Catalog.
        public var relationalCatalogSource: GlueClientTypes.RelationalCatalogSource?
        /// Specifies a transform that renames a single data property key.
        public var renameField: GlueClientTypes.RenameField?
        /// Specifies a Delta Lake data source that is registered in the Glue Data Catalog. The data source must be stored in Amazon S3.
        public var s3CatalogDeltaSource: GlueClientTypes.S3CatalogDeltaSource?
        /// Specifies a Hudi data source that is registered in the Glue Data Catalog. The data source must be stored in Amazon S3.
        public var s3CatalogHudiSource: GlueClientTypes.S3CatalogHudiSource?
        /// Specifies an Amazon S3 data store in the Glue Data Catalog.
        public var s3CatalogSource: GlueClientTypes.S3CatalogSource?
        /// Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.
        public var s3CatalogTarget: GlueClientTypes.S3CatalogTarget?
        /// Specifies a command-separated value (CSV) data store stored in Amazon S3.
        public var s3CsvSource: GlueClientTypes.S3CsvSource?
        /// Specifies a target that writes to a Delta Lake data source in the Glue Data Catalog.
        public var s3DeltaCatalogTarget: GlueClientTypes.S3DeltaCatalogTarget?
        /// Specifies a target that writes to a Delta Lake data source in Amazon S3.
        public var s3DeltaDirectTarget: GlueClientTypes.S3DeltaDirectTarget?
        /// Specifies a Delta Lake data source stored in Amazon S3.
        public var s3DeltaSource: GlueClientTypes.S3DeltaSource?
        /// Specifies a data target that writes to Amazon S3.
        public var s3DirectTarget: GlueClientTypes.S3DirectTarget?
        /// Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.
        public var s3GlueParquetTarget: GlueClientTypes.S3GlueParquetTarget?
        /// Specifies a target that writes to a Hudi data source in the Glue Data Catalog.
        public var s3HudiCatalogTarget: GlueClientTypes.S3HudiCatalogTarget?
        /// Specifies a target that writes to a Hudi data source in Amazon S3.
        public var s3HudiDirectTarget: GlueClientTypes.S3HudiDirectTarget?
        /// Specifies a Hudi data source stored in Amazon S3.
        public var s3HudiSource: GlueClientTypes.S3HudiSource?
        /// Specifies a JSON data store stored in Amazon S3.
        public var s3JsonSource: GlueClientTypes.S3JsonSource?
        /// Specifies an Apache Parquet data store stored in Amazon S3.
        public var s3ParquetSource: GlueClientTypes.S3ParquetSource?
        /// Specifies a transform that chooses the data property keys that you want to keep.
        public var selectFields: GlueClientTypes.SelectFields?
        /// Specifies a transform that chooses one DynamicFrame from a collection of DynamicFrames. The output is the selected DynamicFrame
        public var selectFromCollection: GlueClientTypes.SelectFromCollection?
        /// Specifies a Snowflake data source.
        public var snowflakeSource: GlueClientTypes.SnowflakeSource?
        /// Specifies a target that writes to a Snowflake data source.
        public var snowflakeTarget: GlueClientTypes.SnowflakeTarget?
        /// Specifies a connector to an Apache Spark data source.
        public var sparkConnectorSource: GlueClientTypes.SparkConnectorSource?
        /// Specifies a target that uses an Apache Spark connector.
        public var sparkConnectorTarget: GlueClientTypes.SparkConnectorTarget?
        /// Specifies a transform where you enter a SQL query using Spark SQL syntax to transform the data. The output is a single DynamicFrame.
        public var sparkSQL: GlueClientTypes.SparkSQL?
        /// Specifies a transform that writes samples of the data to an Amazon S3 bucket.
        public var spigot: GlueClientTypes.Spigot?
        /// Specifies a transform that splits data property keys into two DynamicFrames. The output is a collection of DynamicFrames: one with selected data property keys, and one with the remaining data property keys.
        public var splitFields: GlueClientTypes.SplitFields?
        /// Specifies a transform that combines the rows from two or more datasets into a single result.
        public var union: GlueClientTypes.Union?

        public init(
            aggregate: GlueClientTypes.Aggregate? = nil,
            amazonRedshiftSource: GlueClientTypes.AmazonRedshiftSource? = nil,
            amazonRedshiftTarget: GlueClientTypes.AmazonRedshiftTarget? = nil,
            applyMapping: GlueClientTypes.ApplyMapping? = nil,
            athenaConnectorSource: GlueClientTypes.AthenaConnectorSource? = nil,
            catalogDeltaSource: GlueClientTypes.CatalogDeltaSource? = nil,
            catalogHudiSource: GlueClientTypes.CatalogHudiSource? = nil,
            catalogKafkaSource: GlueClientTypes.CatalogKafkaSource? = nil,
            catalogKinesisSource: GlueClientTypes.CatalogKinesisSource? = nil,
            catalogSource: GlueClientTypes.CatalogSource? = nil,
            catalogTarget: GlueClientTypes.BasicCatalogTarget? = nil,
            connectorDataSource: GlueClientTypes.ConnectorDataSource? = nil,
            connectorDataTarget: GlueClientTypes.ConnectorDataTarget? = nil,
            customCode: GlueClientTypes.CustomCode? = nil,
            directJDBCSource: GlueClientTypes.DirectJDBCSource? = nil,
            directKafkaSource: GlueClientTypes.DirectKafkaSource? = nil,
            directKinesisSource: GlueClientTypes.DirectKinesisSource? = nil,
            dropDuplicates: GlueClientTypes.DropDuplicates? = nil,
            dropFields: GlueClientTypes.DropFields? = nil,
            dropNullFields: GlueClientTypes.DropNullFields? = nil,
            dynamicTransform: GlueClientTypes.DynamicTransform? = nil,
            dynamoDBCatalogSource: GlueClientTypes.DynamoDBCatalogSource? = nil,
            evaluateDataQuality: GlueClientTypes.EvaluateDataQuality? = nil,
            evaluateDataQualityMultiFrame: GlueClientTypes.EvaluateDataQualityMultiFrame? = nil,
            fillMissingValues: GlueClientTypes.FillMissingValues? = nil,
            filter: GlueClientTypes.Filter? = nil,
            governedCatalogSource: GlueClientTypes.GovernedCatalogSource? = nil,
            governedCatalogTarget: GlueClientTypes.GovernedCatalogTarget? = nil,
            jdbcConnectorSource: GlueClientTypes.JDBCConnectorSource? = nil,
            jdbcConnectorTarget: GlueClientTypes.JDBCConnectorTarget? = nil,
            join: GlueClientTypes.Join? = nil,
            merge: GlueClientTypes.Merge? = nil,
            microsoftSQLServerCatalogSource: GlueClientTypes.MicrosoftSQLServerCatalogSource? = nil,
            microsoftSQLServerCatalogTarget: GlueClientTypes.MicrosoftSQLServerCatalogTarget? = nil,
            mySQLCatalogSource: GlueClientTypes.MySQLCatalogSource? = nil,
            mySQLCatalogTarget: GlueClientTypes.MySQLCatalogTarget? = nil,
            oracleSQLCatalogSource: GlueClientTypes.OracleSQLCatalogSource? = nil,
            oracleSQLCatalogTarget: GlueClientTypes.OracleSQLCatalogTarget? = nil,
            piiDetection: GlueClientTypes.PIIDetection? = nil,
            postgreSQLCatalogSource: GlueClientTypes.PostgreSQLCatalogSource? = nil,
            postgreSQLCatalogTarget: GlueClientTypes.PostgreSQLCatalogTarget? = nil,
            recipe: GlueClientTypes.Recipe? = nil,
            redshiftSource: GlueClientTypes.RedshiftSource? = nil,
            redshiftTarget: GlueClientTypes.RedshiftTarget? = nil,
            relationalCatalogSource: GlueClientTypes.RelationalCatalogSource? = nil,
            renameField: GlueClientTypes.RenameField? = nil,
            s3CatalogDeltaSource: GlueClientTypes.S3CatalogDeltaSource? = nil,
            s3CatalogHudiSource: GlueClientTypes.S3CatalogHudiSource? = nil,
            s3CatalogSource: GlueClientTypes.S3CatalogSource? = nil,
            s3CatalogTarget: GlueClientTypes.S3CatalogTarget? = nil,
            s3CsvSource: GlueClientTypes.S3CsvSource? = nil,
            s3DeltaCatalogTarget: GlueClientTypes.S3DeltaCatalogTarget? = nil,
            s3DeltaDirectTarget: GlueClientTypes.S3DeltaDirectTarget? = nil,
            s3DeltaSource: GlueClientTypes.S3DeltaSource? = nil,
            s3DirectTarget: GlueClientTypes.S3DirectTarget? = nil,
            s3GlueParquetTarget: GlueClientTypes.S3GlueParquetTarget? = nil,
            s3HudiCatalogTarget: GlueClientTypes.S3HudiCatalogTarget? = nil,
            s3HudiDirectTarget: GlueClientTypes.S3HudiDirectTarget? = nil,
            s3HudiSource: GlueClientTypes.S3HudiSource? = nil,
            s3JsonSource: GlueClientTypes.S3JsonSource? = nil,
            s3ParquetSource: GlueClientTypes.S3ParquetSource? = nil,
            selectFields: GlueClientTypes.SelectFields? = nil,
            selectFromCollection: GlueClientTypes.SelectFromCollection? = nil,
            snowflakeSource: GlueClientTypes.SnowflakeSource? = nil,
            snowflakeTarget: GlueClientTypes.SnowflakeTarget? = nil,
            sparkConnectorSource: GlueClientTypes.SparkConnectorSource? = nil,
            sparkConnectorTarget: GlueClientTypes.SparkConnectorTarget? = nil,
            sparkSQL: GlueClientTypes.SparkSQL? = nil,
            spigot: GlueClientTypes.Spigot? = nil,
            splitFields: GlueClientTypes.SplitFields? = nil,
            union: GlueClientTypes.Union? = nil
        )
        {
            self.aggregate = aggregate
            self.amazonRedshiftSource = amazonRedshiftSource
            self.amazonRedshiftTarget = amazonRedshiftTarget
            self.applyMapping = applyMapping
            self.athenaConnectorSource = athenaConnectorSource
            self.catalogDeltaSource = catalogDeltaSource
            self.catalogHudiSource = catalogHudiSource
            self.catalogKafkaSource = catalogKafkaSource
            self.catalogKinesisSource = catalogKinesisSource
            self.catalogSource = catalogSource
            self.catalogTarget = catalogTarget
            self.connectorDataSource = connectorDataSource
            self.connectorDataTarget = connectorDataTarget
            self.customCode = customCode
            self.directJDBCSource = directJDBCSource
            self.directKafkaSource = directKafkaSource
            self.directKinesisSource = directKinesisSource
            self.dropDuplicates = dropDuplicates
            self.dropFields = dropFields
            self.dropNullFields = dropNullFields
            self.dynamicTransform = dynamicTransform
            self.dynamoDBCatalogSource = dynamoDBCatalogSource
            self.evaluateDataQuality = evaluateDataQuality
            self.evaluateDataQualityMultiFrame = evaluateDataQualityMultiFrame
            self.fillMissingValues = fillMissingValues
            self.filter = filter
            self.governedCatalogSource = governedCatalogSource
            self.governedCatalogTarget = governedCatalogTarget
            self.jdbcConnectorSource = jdbcConnectorSource
            self.jdbcConnectorTarget = jdbcConnectorTarget
            self.join = join
            self.merge = merge
            self.microsoftSQLServerCatalogSource = microsoftSQLServerCatalogSource
            self.microsoftSQLServerCatalogTarget = microsoftSQLServerCatalogTarget
            self.mySQLCatalogSource = mySQLCatalogSource
            self.mySQLCatalogTarget = mySQLCatalogTarget
            self.oracleSQLCatalogSource = oracleSQLCatalogSource
            self.oracleSQLCatalogTarget = oracleSQLCatalogTarget
            self.piiDetection = piiDetection
            self.postgreSQLCatalogSource = postgreSQLCatalogSource
            self.postgreSQLCatalogTarget = postgreSQLCatalogTarget
            self.recipe = recipe
            self.redshiftSource = redshiftSource
            self.redshiftTarget = redshiftTarget
            self.relationalCatalogSource = relationalCatalogSource
            self.renameField = renameField
            self.s3CatalogDeltaSource = s3CatalogDeltaSource
            self.s3CatalogHudiSource = s3CatalogHudiSource
            self.s3CatalogSource = s3CatalogSource
            self.s3CatalogTarget = s3CatalogTarget
            self.s3CsvSource = s3CsvSource
            self.s3DeltaCatalogTarget = s3DeltaCatalogTarget
            self.s3DeltaDirectTarget = s3DeltaDirectTarget
            self.s3DeltaSource = s3DeltaSource
            self.s3DirectTarget = s3DirectTarget
            self.s3GlueParquetTarget = s3GlueParquetTarget
            self.s3HudiCatalogTarget = s3HudiCatalogTarget
            self.s3HudiDirectTarget = s3HudiDirectTarget
            self.s3HudiSource = s3HudiSource
            self.s3JsonSource = s3JsonSource
            self.s3ParquetSource = s3ParquetSource
            self.selectFields = selectFields
            self.selectFromCollection = selectFromCollection
            self.snowflakeSource = snowflakeSource
            self.snowflakeTarget = snowflakeTarget
            self.sparkConnectorSource = sparkConnectorSource
            self.sparkConnectorTarget = sparkConnectorTarget
            self.sparkSQL = sparkSQL
            self.spigot = spigot
            self.splitFields = splitFields
            self.union = union
        }
    }
}

extension GlueClientTypes {

    /// Specifies a version of a table.
    public struct TableVersion: Swift.Sendable {
        /// The table in question.
        public var table: GlueClientTypes.Table?
        /// The ID value that identifies this table version. A VersionId is a string representation of an integer. Each version is incremented by 1.
        public var versionId: Swift.String?

        public init(
            table: GlueClientTypes.Table? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.table = table
            self.versionId = versionId
        }
    }
}

public struct GetTableOutput: Swift.Sendable {
    /// The Table object that defines the specified table.
    public var table: GlueClientTypes.Table?

    public init(
        table: GlueClientTypes.Table? = nil
    )
    {
        self.table = table
    }
}

public struct GetUnfilteredTableMetadataOutput: Swift.Sendable {
    /// A list of column names that the user has been granted access to.
    public var authorizedColumns: [Swift.String]?
    /// A list of column row filters.
    public var cellFilters: [GlueClientTypes.ColumnRowFilter]?
    /// Specifies whether the view supports the SQL dialects of one or more different query engines and can therefore be read by those engines.
    public var isMultiDialectView: Swift.Bool
    /// A flag that instructs the engine not to push user-provided operations into the logical plan of the view during query planning. However, if set this flag does not guarantee that the engine will comply. Refer to the engine's documentation to understand the guarantees provided, if any.
    public var isProtected: Swift.Bool
    /// A Boolean value that indicates whether the partition location is registered with Lake Formation.
    public var isRegisteredWithLakeFormation: Swift.Bool
    /// The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.
    public var permissions: [GlueClientTypes.Permission]?
    /// A cryptographically generated query identifier generated by Glue or Lake Formation.
    public var queryAuthorizationId: Swift.String?
    /// The resource ARN of the parent resource extracted from the request.
    public var resourceArn: Swift.String?
    /// The filter that applies to the table. For example when applying the filter in SQL, it would go in the WHERE clause and can be evaluated by using an AND operator with any other predicates applied by the user querying the table.
    public var rowFilter: Swift.String?
    /// A Table object containing the table metadata.
    public var table: GlueClientTypes.Table?

    public init(
        authorizedColumns: [Swift.String]? = nil,
        cellFilters: [GlueClientTypes.ColumnRowFilter]? = nil,
        isMultiDialectView: Swift.Bool = false,
        isProtected: Swift.Bool = false,
        isRegisteredWithLakeFormation: Swift.Bool = false,
        permissions: [GlueClientTypes.Permission]? = nil,
        queryAuthorizationId: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        rowFilter: Swift.String? = nil,
        table: GlueClientTypes.Table? = nil
    )
    {
        self.authorizedColumns = authorizedColumns
        self.cellFilters = cellFilters
        self.isMultiDialectView = isMultiDialectView
        self.isProtected = isProtected
        self.isRegisteredWithLakeFormation = isRegisteredWithLakeFormation
        self.permissions = permissions
        self.queryAuthorizationId = queryAuthorizationId
        self.resourceArn = resourceArn
        self.rowFilter = rowFilter
        self.table = table
    }
}

public struct GetTablesOutput: Swift.Sendable {
    /// A continuation token, present if the current list segment is not the last.
    public var nextToken: Swift.String?
    /// A list of the requested Table objects.
    public var tableList: [GlueClientTypes.Table]?

    public init(
        nextToken: Swift.String? = nil,
        tableList: [GlueClientTypes.Table]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableList = tableList
    }
}

public struct GetTableVersionOutput: Swift.Sendable {
    /// The requested table version.
    public var tableVersion: GlueClientTypes.TableVersion?

    public init(
        tableVersion: GlueClientTypes.TableVersion? = nil
    )
    {
        self.tableVersion = tableVersion
    }
}

public struct SearchTablesOutput: Swift.Sendable {
    /// A continuation token, present if the current list segment is not the last.
    public var nextToken: Swift.String?
    /// A list of the requested Table objects. The SearchTables response returns only the tables that you have access to.
    public var tableList: [GlueClientTypes.Table]?

    public init(
        nextToken: Swift.String? = nil,
        tableList: [GlueClientTypes.Table]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableList = tableList
    }
}

extension GlueClientTypes {

    /// Specifies a job definition.
    public struct Job: Swift.Sendable {
        /// This field is deprecated. Use MaxCapacity instead. The number of Glue data processing units (DPUs) allocated to runs of this job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [Glue pricing page](https://aws.amazon.com/glue/pricing/).
        @available(*, deprecated, message: "This property is deprecated, use MaxCapacity instead.")
        public var allocatedCapacity: Swift.Int
        /// The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.
        public var codeGenConfigurationNodes: [Swift.String: GlueClientTypes.CodeGenConfigurationNode]?
        /// The JobCommand that runs this job.
        public var command: GlueClientTypes.JobCommand?
        /// The connections used for this job.
        public var connections: GlueClientTypes.ConnectionsList?
        /// The time and date that this job definition was created.
        public var createdOn: Foundation.Date?
        /// The default arguments for every run of this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep them within the Job. For information about how to specify and consume your own Job arguments, see the [Calling Glue APIs in Python](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html) topic in the developer guide. For information about the arguments you can provide to this field when configuring Spark jobs, see the [Special Parameters Used by Glue](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html) topic in the developer guide. For information about the arguments you can provide to this field when configuring Ray jobs, see [Using job parameters in Ray jobs](https://docs.aws.amazon.com/glue/latest/dg/author-job-ray-job-parameters.html) in the developer guide.
        public var defaultArguments: [Swift.String: Swift.String]?
        /// A description of the job.
        public var description: Swift.String?
        /// Indicates whether the job is run with a standard or flexible execution class. The standard execution class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. Only jobs with Glue version 3.0 and above and command type glueetl will be allowed to set ExecutionClass to FLEX. The flexible execution class is available for Spark jobs.
        public var executionClass: GlueClientTypes.ExecutionClass?
        /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
        public var executionProperty: GlueClientTypes.ExecutionProperty?
        /// In Spark jobs, GlueVersion determines the versions of Apache Spark and Python that Glue available in a job. The Python version indicates the version supported for jobs of type Spark. Ray jobs should set GlueVersion to 4.0 or greater. However, the versions of Ray, Python and additional libraries available in your Ray job are determined by the Runtime parameter of the Job command. For more information about the available Glue versions and corresponding Spark and Python versions, see [Glue version](https://docs.aws.amazon.com/glue/latest/dg/add-job.html) in the developer guide. Jobs that are created without specifying a Glue version default to Glue 0.9.
        public var glueVersion: Swift.String?
        /// A mode that describes how a job was created. Valid values are:
        ///
        /// * SCRIPT - The job was created using the Glue Studio script editor.
        ///
        /// * VISUAL - The job was created using the Glue Studio visual editor.
        ///
        /// * NOTEBOOK - The job was created using an interactive sessions notebook.
        ///
        ///
        /// When the JobMode field is missing or null, SCRIPT is assigned as the default value.
        public var jobMode: GlueClientTypes.JobMode?
        /// Specifies whether job run queuing is enabled for the job runs for this job. A value of true means job run queuing is enabled for the job runs. If false or not populated, the job runs will not be considered for queueing. If this field does not match the value set in the job run, then the value from the job run field will be used.
        public var jobRunQueuingEnabled: Swift.Bool?
        /// The last point in time when this job definition was modified.
        public var lastModifiedOn: Foundation.Date?
        /// This field is reserved for future use.
        public var logUri: Swift.String?
        /// This field specifies a day of the week and hour for a maintenance window for streaming jobs. Glue periodically performs maintenance activities. During these maintenance windows, Glue will need to restart your streaming jobs. Glue will restart the job within 3 hours of the specified maintenance window. For instance, if you set up the maintenance window for Monday at 10:00AM GMT, your jobs will be restarted between 10:00AM GMT to 1:00PM GMT.
        public var maintenanceWindow: Swift.String?
        /// For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [ Glue pricing page](https://aws.amazon.com/glue/pricing/). For Glue version 2.0 or later jobs, you cannot specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers. Do not set MaxCapacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:
        ///
        /// * When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.
        ///
        /// * When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
        public var maxCapacity: Swift.Double?
        /// The maximum number of times to retry this job after a JobRun fails.
        public var maxRetries: Swift.Int
        /// The name you assign to this job definition.
        public var name: Swift.String?
        /// Arguments for this job that are not overridden when providing job arguments in a job run, specified as name-value pairs.
        public var nonOverridableArguments: [Swift.String: Swift.String]?
        /// Specifies configuration properties of a job notification.
        public var notificationProperty: GlueClientTypes.NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs.
        public var numberOfWorkers: Swift.Int?
        /// The name of an Glue usage profile associated with the job.
        public var profileName: Swift.String?
        /// The name or Amazon Resource Name (ARN) of the IAM role associated with this job.
        public var role: Swift.String?
        /// The name of the SecurityConfiguration structure to be used with this job.
        public var securityConfiguration: Swift.String?
        /// The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.
        public var sourceControlDetails: GlueClientTypes.SourceControlDetails?
        /// The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours) for batch jobs. Streaming jobs must have timeout values less than 7 days or 10080 minutes. When the value is left blank, the job will be restarted after 7 days based if you have not setup a maintenance window. If you have setup maintenance window, it will be restarted during the maintenance window after 7 days.
        public var timeout: Swift.Int?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs.
        ///
        /// * For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.
        ///
        /// * For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.
        ///
        /// * For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).
        ///
        /// * For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.
        ///
        /// * For the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.
        ///
        /// * For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.
        public var workerType: GlueClientTypes.WorkerType?

        public init(
            allocatedCapacity: Swift.Int = 0,
            codeGenConfigurationNodes: [Swift.String: GlueClientTypes.CodeGenConfigurationNode]? = nil,
            command: GlueClientTypes.JobCommand? = nil,
            connections: GlueClientTypes.ConnectionsList? = nil,
            createdOn: Foundation.Date? = nil,
            defaultArguments: [Swift.String: Swift.String]? = nil,
            description: Swift.String? = nil,
            executionClass: GlueClientTypes.ExecutionClass? = nil,
            executionProperty: GlueClientTypes.ExecutionProperty? = nil,
            glueVersion: Swift.String? = nil,
            jobMode: GlueClientTypes.JobMode? = nil,
            jobRunQueuingEnabled: Swift.Bool? = nil,
            lastModifiedOn: Foundation.Date? = nil,
            logUri: Swift.String? = nil,
            maintenanceWindow: Swift.String? = nil,
            maxCapacity: Swift.Double? = nil,
            maxRetries: Swift.Int = 0,
            name: Swift.String? = nil,
            nonOverridableArguments: [Swift.String: Swift.String]? = nil,
            notificationProperty: GlueClientTypes.NotificationProperty? = nil,
            numberOfWorkers: Swift.Int? = nil,
            profileName: Swift.String? = nil,
            role: Swift.String? = nil,
            securityConfiguration: Swift.String? = nil,
            sourceControlDetails: GlueClientTypes.SourceControlDetails? = nil,
            timeout: Swift.Int? = nil,
            workerType: GlueClientTypes.WorkerType? = nil
        )
        {
            self.allocatedCapacity = allocatedCapacity
            self.codeGenConfigurationNodes = codeGenConfigurationNodes
            self.command = command
            self.connections = connections
            self.createdOn = createdOn
            self.defaultArguments = defaultArguments
            self.description = description
            self.executionClass = executionClass
            self.executionProperty = executionProperty
            self.glueVersion = glueVersion
            self.jobMode = jobMode
            self.jobRunQueuingEnabled = jobRunQueuingEnabled
            self.lastModifiedOn = lastModifiedOn
            self.logUri = logUri
            self.maintenanceWindow = maintenanceWindow
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.nonOverridableArguments = nonOverridableArguments
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.profileName = profileName
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.sourceControlDetails = sourceControlDetails
            self.timeout = timeout
            self.workerType = workerType
        }
    }
}

extension GlueClientTypes.Job: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Job(allocatedCapacity: \(Swift.String(describing: allocatedCapacity)), command: \(Swift.String(describing: command)), connections: \(Swift.String(describing: connections)), createdOn: \(Swift.String(describing: createdOn)), defaultArguments: \(Swift.String(describing: defaultArguments)), description: \(Swift.String(describing: description)), executionClass: \(Swift.String(describing: executionClass)), executionProperty: \(Swift.String(describing: executionProperty)), glueVersion: \(Swift.String(describing: glueVersion)), jobMode: \(Swift.String(describing: jobMode)), jobRunQueuingEnabled: \(Swift.String(describing: jobRunQueuingEnabled)), lastModifiedOn: \(Swift.String(describing: lastModifiedOn)), logUri: \(Swift.String(describing: logUri)), maintenanceWindow: \(Swift.String(describing: maintenanceWindow)), maxCapacity: \(Swift.String(describing: maxCapacity)), maxRetries: \(Swift.String(describing: maxRetries)), name: \(Swift.String(describing: name)), nonOverridableArguments: \(Swift.String(describing: nonOverridableArguments)), notificationProperty: \(Swift.String(describing: notificationProperty)), numberOfWorkers: \(Swift.String(describing: numberOfWorkers)), profileName: \(Swift.String(describing: profileName)), role: \(Swift.String(describing: role)), securityConfiguration: \(Swift.String(describing: securityConfiguration)), sourceControlDetails: \(Swift.String(describing: sourceControlDetails)), timeout: \(Swift.String(describing: timeout)), workerType: \(Swift.String(describing: workerType)), codeGenConfigurationNodes: \"CONTENT_REDACTED\")"}
}

extension GlueClientTypes {

    /// Specifies information used to update an existing job definition. The previous job definition is completely overwritten by this information.
    public struct JobUpdate: Swift.Sendable {
        /// This field is deprecated. Use MaxCapacity instead. The number of Glue data processing units (DPUs) to allocate to this job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [Glue pricing page](https://aws.amazon.com/glue/pricing/).
        @available(*, deprecated, message: "This property is deprecated, use MaxCapacity instead.")
        public var allocatedCapacity: Swift.Int
        /// The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.
        public var codeGenConfigurationNodes: [Swift.String: GlueClientTypes.CodeGenConfigurationNode]?
        /// The JobCommand that runs this job (required).
        public var command: GlueClientTypes.JobCommand?
        /// The connections used for this job.
        public var connections: GlueClientTypes.ConnectionsList?
        /// The default arguments for every run of this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep them within the Job. For information about how to specify and consume your own Job arguments, see the [Calling Glue APIs in Python](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html) topic in the developer guide. For information about the arguments you can provide to this field when configuring Spark jobs, see the [Special Parameters Used by Glue](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html) topic in the developer guide. For information about the arguments you can provide to this field when configuring Ray jobs, see [Using job parameters in Ray jobs](https://docs.aws.amazon.com/glue/latest/dg/author-job-ray-job-parameters.html) in the developer guide.
        public var defaultArguments: [Swift.String: Swift.String]?
        /// Description of the job being defined.
        public var description: Swift.String?
        /// Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. Only jobs with Glue version 3.0 and above and command type glueetl will be allowed to set ExecutionClass to FLEX. The flexible execution class is available for Spark jobs.
        public var executionClass: GlueClientTypes.ExecutionClass?
        /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
        public var executionProperty: GlueClientTypes.ExecutionProperty?
        /// In Spark jobs, GlueVersion determines the versions of Apache Spark and Python that Glue available in a job. The Python version indicates the version supported for jobs of type Spark. Ray jobs should set GlueVersion to 4.0 or greater. However, the versions of Ray, Python and additional libraries available in your Ray job are determined by the Runtime parameter of the Job command. For more information about the available Glue versions and corresponding Spark and Python versions, see [Glue version](https://docs.aws.amazon.com/glue/latest/dg/add-job.html) in the developer guide. Jobs that are created without specifying a Glue version default to Glue 0.9.
        public var glueVersion: Swift.String?
        /// A mode that describes how a job was created. Valid values are:
        ///
        /// * SCRIPT - The job was created using the Glue Studio script editor.
        ///
        /// * VISUAL - The job was created using the Glue Studio visual editor.
        ///
        /// * NOTEBOOK - The job was created using an interactive sessions notebook.
        ///
        ///
        /// When the JobMode field is missing or null, SCRIPT is assigned as the default value.
        public var jobMode: GlueClientTypes.JobMode?
        /// Specifies whether job run queuing is enabled for the job runs for this job. A value of true means job run queuing is enabled for the job runs. If false or not populated, the job runs will not be considered for queueing. If this field does not match the value set in the job run, then the value from the job run field will be used.
        public var jobRunQueuingEnabled: Swift.Bool?
        /// This field is reserved for future use.
        public var logUri: Swift.String?
        /// This field specifies a day of the week and hour for a maintenance window for streaming jobs. Glue periodically performs maintenance activities. During these maintenance windows, Glue will need to restart your streaming jobs. Glue will restart the job within 3 hours of the specified maintenance window. For instance, if you set up the maintenance window for Monday at 10:00AM GMT, your jobs will be restarted between 10:00AM GMT to 1:00PM GMT.
        public var maintenanceWindow: Swift.String?
        /// For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [ Glue pricing page](https://aws.amazon.com/glue/pricing/). For Glue version 2.0+ jobs, you cannot specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers. Do not set MaxCapacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:
        ///
        /// * When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.
        ///
        /// * When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
        public var maxCapacity: Swift.Double?
        /// The maximum number of times to retry this job if it fails.
        public var maxRetries: Swift.Int
        /// Arguments for this job that are not overridden when providing job arguments in a job run, specified as name-value pairs.
        public var nonOverridableArguments: [Swift.String: Swift.String]?
        /// Specifies the configuration properties of a job notification.
        public var notificationProperty: GlueClientTypes.NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs.
        public var numberOfWorkers: Swift.Int?
        /// The name or Amazon Resource Name (ARN) of the IAM role associated with this job (required).
        public var role: Swift.String?
        /// The name of the SecurityConfiguration structure to be used with this job.
        public var securityConfiguration: Swift.String?
        /// The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.
        public var sourceControlDetails: GlueClientTypes.SourceControlDetails?
        /// The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours) for batch jobs. Streaming jobs must have timeout values less than 7 days or 10080 minutes. When the value is left blank, the job will be restarted after 7 days based if you have not setup a maintenance window. If you have setup maintenance window, it will be restarted during the maintenance window after 7 days.
        public var timeout: Swift.Int?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs.
        ///
        /// * For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.
        ///
        /// * For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.
        ///
        /// * For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).
        ///
        /// * For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.
        ///
        /// * For the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.
        ///
        /// * For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.
        public var workerType: GlueClientTypes.WorkerType?

        public init(
            allocatedCapacity: Swift.Int = 0,
            codeGenConfigurationNodes: [Swift.String: GlueClientTypes.CodeGenConfigurationNode]? = nil,
            command: GlueClientTypes.JobCommand? = nil,
            connections: GlueClientTypes.ConnectionsList? = nil,
            defaultArguments: [Swift.String: Swift.String]? = nil,
            description: Swift.String? = nil,
            executionClass: GlueClientTypes.ExecutionClass? = nil,
            executionProperty: GlueClientTypes.ExecutionProperty? = nil,
            glueVersion: Swift.String? = nil,
            jobMode: GlueClientTypes.JobMode? = nil,
            jobRunQueuingEnabled: Swift.Bool? = nil,
            logUri: Swift.String? = nil,
            maintenanceWindow: Swift.String? = nil,
            maxCapacity: Swift.Double? = nil,
            maxRetries: Swift.Int = 0,
            nonOverridableArguments: [Swift.String: Swift.String]? = nil,
            notificationProperty: GlueClientTypes.NotificationProperty? = nil,
            numberOfWorkers: Swift.Int? = nil,
            role: Swift.String? = nil,
            securityConfiguration: Swift.String? = nil,
            sourceControlDetails: GlueClientTypes.SourceControlDetails? = nil,
            timeout: Swift.Int? = nil,
            workerType: GlueClientTypes.WorkerType? = nil
        )
        {
            self.allocatedCapacity = allocatedCapacity
            self.codeGenConfigurationNodes = codeGenConfigurationNodes
            self.command = command
            self.connections = connections
            self.defaultArguments = defaultArguments
            self.description = description
            self.executionClass = executionClass
            self.executionProperty = executionProperty
            self.glueVersion = glueVersion
            self.jobMode = jobMode
            self.jobRunQueuingEnabled = jobRunQueuingEnabled
            self.logUri = logUri
            self.maintenanceWindow = maintenanceWindow
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.nonOverridableArguments = nonOverridableArguments
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.sourceControlDetails = sourceControlDetails
            self.timeout = timeout
            self.workerType = workerType
        }
    }
}

extension GlueClientTypes.JobUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobUpdate(allocatedCapacity: \(Swift.String(describing: allocatedCapacity)), command: \(Swift.String(describing: command)), connections: \(Swift.String(describing: connections)), defaultArguments: \(Swift.String(describing: defaultArguments)), description: \(Swift.String(describing: description)), executionClass: \(Swift.String(describing: executionClass)), executionProperty: \(Swift.String(describing: executionProperty)), glueVersion: \(Swift.String(describing: glueVersion)), jobMode: \(Swift.String(describing: jobMode)), jobRunQueuingEnabled: \(Swift.String(describing: jobRunQueuingEnabled)), logUri: \(Swift.String(describing: logUri)), maintenanceWindow: \(Swift.String(describing: maintenanceWindow)), maxCapacity: \(Swift.String(describing: maxCapacity)), maxRetries: \(Swift.String(describing: maxRetries)), nonOverridableArguments: \(Swift.String(describing: nonOverridableArguments)), notificationProperty: \(Swift.String(describing: notificationProperty)), numberOfWorkers: \(Swift.String(describing: numberOfWorkers)), role: \(Swift.String(describing: role)), securityConfiguration: \(Swift.String(describing: securityConfiguration)), sourceControlDetails: \(Swift.String(describing: sourceControlDetails)), timeout: \(Swift.String(describing: timeout)), workerType: \(Swift.String(describing: workerType)), codeGenConfigurationNodes: \"CONTENT_REDACTED\")"}
}

public struct CreateJobInput: Swift.Sendable {
    /// This parameter is deprecated. Use MaxCapacity instead. The number of Glue data processing units (DPUs) to allocate to this Job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [Glue pricing page](https://aws.amazon.com/glue/pricing/).
    @available(*, deprecated, message: "This property is deprecated, use MaxCapacity instead.")
    public var allocatedCapacity: Swift.Int?
    /// The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.
    public var codeGenConfigurationNodes: [Swift.String: GlueClientTypes.CodeGenConfigurationNode]?
    /// The JobCommand that runs this job.
    /// This member is required.
    public var command: GlueClientTypes.JobCommand?
    /// The connections used for this job.
    public var connections: GlueClientTypes.ConnectionsList?
    /// The default arguments for every run of this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep them within the Job. For information about how to specify and consume your own Job arguments, see the [Calling Glue APIs in Python](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html) topic in the developer guide. For information about the arguments you can provide to this field when configuring Spark jobs, see the [Special Parameters Used by Glue](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html) topic in the developer guide. For information about the arguments you can provide to this field when configuring Ray jobs, see [Using job parameters in Ray jobs](https://docs.aws.amazon.com/glue/latest/dg/author-job-ray-job-parameters.html) in the developer guide.
    public var defaultArguments: [Swift.String: Swift.String]?
    /// Description of the job being defined.
    public var description: Swift.String?
    /// Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. Only jobs with Glue version 3.0 and above and command type glueetl will be allowed to set ExecutionClass to FLEX. The flexible execution class is available for Spark jobs.
    public var executionClass: GlueClientTypes.ExecutionClass?
    /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
    public var executionProperty: GlueClientTypes.ExecutionProperty?
    /// In Spark jobs, GlueVersion determines the versions of Apache Spark and Python that Glue available in a job. The Python version indicates the version supported for jobs of type Spark. Ray jobs should set GlueVersion to 4.0 or greater. However, the versions of Ray, Python and additional libraries available in your Ray job are determined by the Runtime parameter of the Job command. For more information about the available Glue versions and corresponding Spark and Python versions, see [Glue version](https://docs.aws.amazon.com/glue/latest/dg/add-job.html) in the developer guide. Jobs that are created without specifying a Glue version default to Glue 0.9.
    public var glueVersion: Swift.String?
    /// A mode that describes how a job was created. Valid values are:
    ///
    /// * SCRIPT - The job was created using the Glue Studio script editor.
    ///
    /// * VISUAL - The job was created using the Glue Studio visual editor.
    ///
    /// * NOTEBOOK - The job was created using an interactive sessions notebook.
    ///
    ///
    /// When the JobMode field is missing or null, SCRIPT is assigned as the default value.
    public var jobMode: GlueClientTypes.JobMode?
    /// Specifies whether job run queuing is enabled for the job runs for this job. A value of true means job run queuing is enabled for the job runs. If false or not populated, the job runs will not be considered for queueing. If this field does not match the value set in the job run, then the value from the job run field will be used.
    public var jobRunQueuingEnabled: Swift.Bool?
    /// This field is reserved for future use.
    public var logUri: Swift.String?
    /// This field specifies a day of the week and hour for a maintenance window for streaming jobs. Glue periodically performs maintenance activities. During these maintenance windows, Glue will need to restart your streaming jobs. Glue will restart the job within 3 hours of the specified maintenance window. For instance, if you set up the maintenance window for Monday at 10:00AM GMT, your jobs will be restarted between 10:00AM GMT to 1:00PM GMT.
    public var maintenanceWindow: Swift.String?
    /// For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [ Glue pricing page](https://aws.amazon.com/glue/pricing/). For Glue version 2.0+ jobs, you cannot specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers. Do not set MaxCapacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:
    ///
    /// * When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.
    ///
    /// * When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
    public var maxCapacity: Swift.Double?
    /// The maximum number of times to retry this job if it fails.
    public var maxRetries: Swift.Int?
    /// The name you assign to this job definition. It must be unique in your account.
    /// This member is required.
    public var name: Swift.String?
    /// Arguments for this job that are not overridden when providing job arguments in a job run, specified as name-value pairs.
    public var nonOverridableArguments: [Swift.String: Swift.String]?
    /// Specifies configuration properties of a job notification.
    public var notificationProperty: GlueClientTypes.NotificationProperty?
    /// The number of workers of a defined workerType that are allocated when a job runs.
    public var numberOfWorkers: Swift.Int?
    /// The name or Amazon Resource Name (ARN) of the IAM role associated with this job.
    /// This member is required.
    public var role: Swift.String?
    /// The name of the SecurityConfiguration structure to be used with this job.
    public var securityConfiguration: Swift.String?
    /// The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.
    public var sourceControlDetails: GlueClientTypes.SourceControlDetails?
    /// The tags to use with this job. You may use tags to limit access to the job. For more information about tags in Glue, see [Amazon Web Services Tags in Glue](https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html) in the developer guide.
    public var tags: [Swift.String: Swift.String]?
    /// The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours) for batch jobs. Streaming jobs must have timeout values less than 7 days or 10080 minutes. When the value is left blank, the job will be restarted after 7 days based if you have not setup a maintenance window. If you have setup maintenance window, it will be restarted during the maintenance window after 7 days.
    public var timeout: Swift.Int?
    /// The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs.
    ///
    /// * For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.
    ///
    /// * For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.
    ///
    /// * For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).
    ///
    /// * For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.
    ///
    /// * For the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.
    ///
    /// * For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.
    public var workerType: GlueClientTypes.WorkerType?

    public init(
        allocatedCapacity: Swift.Int? = 0,
        codeGenConfigurationNodes: [Swift.String: GlueClientTypes.CodeGenConfigurationNode]? = nil,
        command: GlueClientTypes.JobCommand? = nil,
        connections: GlueClientTypes.ConnectionsList? = nil,
        defaultArguments: [Swift.String: Swift.String]? = nil,
        description: Swift.String? = nil,
        executionClass: GlueClientTypes.ExecutionClass? = nil,
        executionProperty: GlueClientTypes.ExecutionProperty? = nil,
        glueVersion: Swift.String? = nil,
        jobMode: GlueClientTypes.JobMode? = nil,
        jobRunQueuingEnabled: Swift.Bool? = nil,
        logUri: Swift.String? = nil,
        maintenanceWindow: Swift.String? = nil,
        maxCapacity: Swift.Double? = nil,
        maxRetries: Swift.Int? = 0,
        name: Swift.String? = nil,
        nonOverridableArguments: [Swift.String: Swift.String]? = nil,
        notificationProperty: GlueClientTypes.NotificationProperty? = nil,
        numberOfWorkers: Swift.Int? = nil,
        role: Swift.String? = nil,
        securityConfiguration: Swift.String? = nil,
        sourceControlDetails: GlueClientTypes.SourceControlDetails? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        timeout: Swift.Int? = nil,
        workerType: GlueClientTypes.WorkerType? = nil
    )
    {
        self.allocatedCapacity = allocatedCapacity
        self.codeGenConfigurationNodes = codeGenConfigurationNodes
        self.command = command
        self.connections = connections
        self.defaultArguments = defaultArguments
        self.description = description
        self.executionClass = executionClass
        self.executionProperty = executionProperty
        self.glueVersion = glueVersion
        self.jobMode = jobMode
        self.jobRunQueuingEnabled = jobRunQueuingEnabled
        self.logUri = logUri
        self.maintenanceWindow = maintenanceWindow
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.nonOverridableArguments = nonOverridableArguments
        self.notificationProperty = notificationProperty
        self.numberOfWorkers = numberOfWorkers
        self.role = role
        self.securityConfiguration = securityConfiguration
        self.sourceControlDetails = sourceControlDetails
        self.tags = tags
        self.timeout = timeout
        self.workerType = workerType
    }
}

extension CreateJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateJobInput(allocatedCapacity: \(Swift.String(describing: allocatedCapacity)), command: \(Swift.String(describing: command)), connections: \(Swift.String(describing: connections)), defaultArguments: \(Swift.String(describing: defaultArguments)), description: \(Swift.String(describing: description)), executionClass: \(Swift.String(describing: executionClass)), executionProperty: \(Swift.String(describing: executionProperty)), glueVersion: \(Swift.String(describing: glueVersion)), jobMode: \(Swift.String(describing: jobMode)), jobRunQueuingEnabled: \(Swift.String(describing: jobRunQueuingEnabled)), logUri: \(Swift.String(describing: logUri)), maintenanceWindow: \(Swift.String(describing: maintenanceWindow)), maxCapacity: \(Swift.String(describing: maxCapacity)), maxRetries: \(Swift.String(describing: maxRetries)), name: \(Swift.String(describing: name)), nonOverridableArguments: \(Swift.String(describing: nonOverridableArguments)), notificationProperty: \(Swift.String(describing: notificationProperty)), numberOfWorkers: \(Swift.String(describing: numberOfWorkers)), role: \(Swift.String(describing: role)), securityConfiguration: \(Swift.String(describing: securityConfiguration)), sourceControlDetails: \(Swift.String(describing: sourceControlDetails)), tags: \(Swift.String(describing: tags)), timeout: \(Swift.String(describing: timeout)), workerType: \(Swift.String(describing: workerType)), codeGenConfigurationNodes: \"CONTENT_REDACTED\")"}
}

public struct GetTableVersionsOutput: Swift.Sendable {
    /// A continuation token, if the list of available versions does not include the last one.
    public var nextToken: Swift.String?
    /// A list of strings identifying available versions of the specified table.
    public var tableVersions: [GlueClientTypes.TableVersion]?

    public init(
        nextToken: Swift.String? = nil,
        tableVersions: [GlueClientTypes.TableVersion]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableVersions = tableVersions
    }
}

public struct GetJobOutput: Swift.Sendable {
    /// The requested job definition.
    public var job: GlueClientTypes.Job?

    public init(
        job: GlueClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

public struct UpdateJobInput: Swift.Sendable {
    /// The name of the job definition to update.
    /// This member is required.
    public var jobName: Swift.String?
    /// Specifies the values with which to update the job definition. Unspecified configuration is removed or reset to default values.
    /// This member is required.
    public var jobUpdate: GlueClientTypes.JobUpdate?

    public init(
        jobName: Swift.String? = nil,
        jobUpdate: GlueClientTypes.JobUpdate? = nil
    )
    {
        self.jobName = jobName
        self.jobUpdate = jobUpdate
    }
}

public struct BatchGetJobsOutput: Swift.Sendable {
    /// A list of job definitions.
    public var jobs: [GlueClientTypes.Job]?
    /// A list of names of jobs not found.
    public var jobsNotFound: [Swift.String]?

    public init(
        jobs: [GlueClientTypes.Job]? = nil,
        jobsNotFound: [Swift.String]? = nil
    )
    {
        self.jobs = jobs
        self.jobsNotFound = jobsNotFound
    }
}

public struct GetJobsOutput: Swift.Sendable {
    /// A list of job definitions.
    public var jobs: [GlueClientTypes.Job]?
    /// A continuation token, if not all job definitions have yet been returned.
    public var nextToken: Swift.String?

    public init(
        jobs: [GlueClientTypes.Job]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

extension BatchCreatePartitionInput {

    static func urlPathProvider(_ value: BatchCreatePartitionInput) -> Swift.String? {
        return "/"
    }
}

extension BatchDeleteConnectionInput {

    static func urlPathProvider(_ value: BatchDeleteConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension BatchDeletePartitionInput {

    static func urlPathProvider(_ value: BatchDeletePartitionInput) -> Swift.String? {
        return "/"
    }
}

extension BatchDeleteTableInput {

    static func urlPathProvider(_ value: BatchDeleteTableInput) -> Swift.String? {
        return "/"
    }
}

extension BatchDeleteTableVersionInput {

    static func urlPathProvider(_ value: BatchDeleteTableVersionInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetBlueprintsInput {

    static func urlPathProvider(_ value: BatchGetBlueprintsInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetCrawlersInput {

    static func urlPathProvider(_ value: BatchGetCrawlersInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetCustomEntityTypesInput {

    static func urlPathProvider(_ value: BatchGetCustomEntityTypesInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetDataQualityResultInput {

    static func urlPathProvider(_ value: BatchGetDataQualityResultInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetDevEndpointsInput {

    static func urlPathProvider(_ value: BatchGetDevEndpointsInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetJobsInput {

    static func urlPathProvider(_ value: BatchGetJobsInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetPartitionInput {

    static func urlPathProvider(_ value: BatchGetPartitionInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetTableOptimizerInput {

    static func urlPathProvider(_ value: BatchGetTableOptimizerInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetTriggersInput {

    static func urlPathProvider(_ value: BatchGetTriggersInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetWorkflowsInput {

    static func urlPathProvider(_ value: BatchGetWorkflowsInput) -> Swift.String? {
        return "/"
    }
}

extension BatchPutDataQualityStatisticAnnotationInput {

    static func urlPathProvider(_ value: BatchPutDataQualityStatisticAnnotationInput) -> Swift.String? {
        return "/"
    }
}

extension BatchStopJobRunInput {

    static func urlPathProvider(_ value: BatchStopJobRunInput) -> Swift.String? {
        return "/"
    }
}

extension BatchUpdatePartitionInput {

    static func urlPathProvider(_ value: BatchUpdatePartitionInput) -> Swift.String? {
        return "/"
    }
}

extension CancelDataQualityRuleRecommendationRunInput {

    static func urlPathProvider(_ value: CancelDataQualityRuleRecommendationRunInput) -> Swift.String? {
        return "/"
    }
}

extension CancelDataQualityRulesetEvaluationRunInput {

    static func urlPathProvider(_ value: CancelDataQualityRulesetEvaluationRunInput) -> Swift.String? {
        return "/"
    }
}

extension CancelMLTaskRunInput {

    static func urlPathProvider(_ value: CancelMLTaskRunInput) -> Swift.String? {
        return "/"
    }
}

extension CancelStatementInput {

    static func urlPathProvider(_ value: CancelStatementInput) -> Swift.String? {
        return "/"
    }
}

extension CheckSchemaVersionValidityInput {

    static func urlPathProvider(_ value: CheckSchemaVersionValidityInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBlueprintInput {

    static func urlPathProvider(_ value: CreateBlueprintInput) -> Swift.String? {
        return "/"
    }
}

extension CreateClassifierInput {

    static func urlPathProvider(_ value: CreateClassifierInput) -> Swift.String? {
        return "/"
    }
}

extension CreateColumnStatisticsTaskSettingsInput {

    static func urlPathProvider(_ value: CreateColumnStatisticsTaskSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension CreateConnectionInput {

    static func urlPathProvider(_ value: CreateConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCrawlerInput {

    static func urlPathProvider(_ value: CreateCrawlerInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCustomEntityTypeInput {

    static func urlPathProvider(_ value: CreateCustomEntityTypeInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDatabaseInput {

    static func urlPathProvider(_ value: CreateDatabaseInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDataQualityRulesetInput {

    static func urlPathProvider(_ value: CreateDataQualityRulesetInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDevEndpointInput {

    static func urlPathProvider(_ value: CreateDevEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension CreateJobInput {

    static func urlPathProvider(_ value: CreateJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateMLTransformInput {

    static func urlPathProvider(_ value: CreateMLTransformInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePartitionInput {

    static func urlPathProvider(_ value: CreatePartitionInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePartitionIndexInput {

    static func urlPathProvider(_ value: CreatePartitionIndexInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRegistryInput {

    static func urlPathProvider(_ value: CreateRegistryInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSchemaInput {

    static func urlPathProvider(_ value: CreateSchemaInput) -> Swift.String? {
        return "/"
    }
}

extension CreateScriptInput {

    static func urlPathProvider(_ value: CreateScriptInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSecurityConfigurationInput {

    static func urlPathProvider(_ value: CreateSecurityConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSessionInput {

    static func urlPathProvider(_ value: CreateSessionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTableInput {

    static func urlPathProvider(_ value: CreateTableInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTableOptimizerInput {

    static func urlPathProvider(_ value: CreateTableOptimizerInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTriggerInput {

    static func urlPathProvider(_ value: CreateTriggerInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUsageProfileInput {

    static func urlPathProvider(_ value: CreateUsageProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUserDefinedFunctionInput {

    static func urlPathProvider(_ value: CreateUserDefinedFunctionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWorkflowInput {

    static func urlPathProvider(_ value: CreateWorkflowInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteBlueprintInput {

    static func urlPathProvider(_ value: DeleteBlueprintInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteClassifierInput {

    static func urlPathProvider(_ value: DeleteClassifierInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteColumnStatisticsForPartitionInput {

    static func urlPathProvider(_ value: DeleteColumnStatisticsForPartitionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteColumnStatisticsForTableInput {

    static func urlPathProvider(_ value: DeleteColumnStatisticsForTableInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteColumnStatisticsTaskSettingsInput {

    static func urlPathProvider(_ value: DeleteColumnStatisticsTaskSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteConnectionInput {

    static func urlPathProvider(_ value: DeleteConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCrawlerInput {

    static func urlPathProvider(_ value: DeleteCrawlerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCustomEntityTypeInput {

    static func urlPathProvider(_ value: DeleteCustomEntityTypeInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDatabaseInput {

    static func urlPathProvider(_ value: DeleteDatabaseInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDataQualityRulesetInput {

    static func urlPathProvider(_ value: DeleteDataQualityRulesetInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDevEndpointInput {

    static func urlPathProvider(_ value: DeleteDevEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteJobInput {

    static func urlPathProvider(_ value: DeleteJobInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteMLTransformInput {

    static func urlPathProvider(_ value: DeleteMLTransformInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePartitionInput {

    static func urlPathProvider(_ value: DeletePartitionInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePartitionIndexInput {

    static func urlPathProvider(_ value: DeletePartitionIndexInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRegistryInput {

    static func urlPathProvider(_ value: DeleteRegistryInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSchemaInput {

    static func urlPathProvider(_ value: DeleteSchemaInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSchemaVersionsInput {

    static func urlPathProvider(_ value: DeleteSchemaVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSecurityConfigurationInput {

    static func urlPathProvider(_ value: DeleteSecurityConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSessionInput {

    static func urlPathProvider(_ value: DeleteSessionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTableInput {

    static func urlPathProvider(_ value: DeleteTableInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTableOptimizerInput {

    static func urlPathProvider(_ value: DeleteTableOptimizerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTableVersionInput {

    static func urlPathProvider(_ value: DeleteTableVersionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTriggerInput {

    static func urlPathProvider(_ value: DeleteTriggerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUsageProfileInput {

    static func urlPathProvider(_ value: DeleteUsageProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUserDefinedFunctionInput {

    static func urlPathProvider(_ value: DeleteUserDefinedFunctionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWorkflowInput {

    static func urlPathProvider(_ value: DeleteWorkflowInput) -> Swift.String? {
        return "/"
    }
}

extension GetBlueprintInput {

    static func urlPathProvider(_ value: GetBlueprintInput) -> Swift.String? {
        return "/"
    }
}

extension GetBlueprintRunInput {

    static func urlPathProvider(_ value: GetBlueprintRunInput) -> Swift.String? {
        return "/"
    }
}

extension GetBlueprintRunsInput {

    static func urlPathProvider(_ value: GetBlueprintRunsInput) -> Swift.String? {
        return "/"
    }
}

extension GetCatalogImportStatusInput {

    static func urlPathProvider(_ value: GetCatalogImportStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetClassifierInput {

    static func urlPathProvider(_ value: GetClassifierInput) -> Swift.String? {
        return "/"
    }
}

extension GetClassifiersInput {

    static func urlPathProvider(_ value: GetClassifiersInput) -> Swift.String? {
        return "/"
    }
}

extension GetColumnStatisticsForPartitionInput {

    static func urlPathProvider(_ value: GetColumnStatisticsForPartitionInput) -> Swift.String? {
        return "/"
    }
}

extension GetColumnStatisticsForTableInput {

    static func urlPathProvider(_ value: GetColumnStatisticsForTableInput) -> Swift.String? {
        return "/"
    }
}

extension GetColumnStatisticsTaskRunInput {

    static func urlPathProvider(_ value: GetColumnStatisticsTaskRunInput) -> Swift.String? {
        return "/"
    }
}

extension GetColumnStatisticsTaskRunsInput {

    static func urlPathProvider(_ value: GetColumnStatisticsTaskRunsInput) -> Swift.String? {
        return "/"
    }
}

extension GetColumnStatisticsTaskSettingsInput {

    static func urlPathProvider(_ value: GetColumnStatisticsTaskSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension GetConnectionInput {

    static func urlPathProvider(_ value: GetConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension GetConnectionsInput {

    static func urlPathProvider(_ value: GetConnectionsInput) -> Swift.String? {
        return "/"
    }
}

extension GetCrawlerInput {

    static func urlPathProvider(_ value: GetCrawlerInput) -> Swift.String? {
        return "/"
    }
}

extension GetCrawlerMetricsInput {

    static func urlPathProvider(_ value: GetCrawlerMetricsInput) -> Swift.String? {
        return "/"
    }
}

extension GetCrawlersInput {

    static func urlPathProvider(_ value: GetCrawlersInput) -> Swift.String? {
        return "/"
    }
}

extension GetCustomEntityTypeInput {

    static func urlPathProvider(_ value: GetCustomEntityTypeInput) -> Swift.String? {
        return "/"
    }
}

extension GetDatabaseInput {

    static func urlPathProvider(_ value: GetDatabaseInput) -> Swift.String? {
        return "/"
    }
}

extension GetDatabasesInput {

    static func urlPathProvider(_ value: GetDatabasesInput) -> Swift.String? {
        return "/"
    }
}

extension GetDataCatalogEncryptionSettingsInput {

    static func urlPathProvider(_ value: GetDataCatalogEncryptionSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension GetDataflowGraphInput {

    static func urlPathProvider(_ value: GetDataflowGraphInput) -> Swift.String? {
        return "/"
    }
}

extension GetDataQualityModelInput {

    static func urlPathProvider(_ value: GetDataQualityModelInput) -> Swift.String? {
        return "/"
    }
}

extension GetDataQualityModelResultInput {

    static func urlPathProvider(_ value: GetDataQualityModelResultInput) -> Swift.String? {
        return "/"
    }
}

extension GetDataQualityResultInput {

    static func urlPathProvider(_ value: GetDataQualityResultInput) -> Swift.String? {
        return "/"
    }
}

extension GetDataQualityRuleRecommendationRunInput {

    static func urlPathProvider(_ value: GetDataQualityRuleRecommendationRunInput) -> Swift.String? {
        return "/"
    }
}

extension GetDataQualityRulesetInput {

    static func urlPathProvider(_ value: GetDataQualityRulesetInput) -> Swift.String? {
        return "/"
    }
}

extension GetDataQualityRulesetEvaluationRunInput {

    static func urlPathProvider(_ value: GetDataQualityRulesetEvaluationRunInput) -> Swift.String? {
        return "/"
    }
}

extension GetDevEndpointInput {

    static func urlPathProvider(_ value: GetDevEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension GetDevEndpointsInput {

    static func urlPathProvider(_ value: GetDevEndpointsInput) -> Swift.String? {
        return "/"
    }
}

extension GetJobInput {

    static func urlPathProvider(_ value: GetJobInput) -> Swift.String? {
        return "/"
    }
}

extension GetJobBookmarkInput {

    static func urlPathProvider(_ value: GetJobBookmarkInput) -> Swift.String? {
        return "/"
    }
}

extension GetJobRunInput {

    static func urlPathProvider(_ value: GetJobRunInput) -> Swift.String? {
        return "/"
    }
}

extension GetJobRunsInput {

    static func urlPathProvider(_ value: GetJobRunsInput) -> Swift.String? {
        return "/"
    }
}

extension GetJobsInput {

    static func urlPathProvider(_ value: GetJobsInput) -> Swift.String? {
        return "/"
    }
}

extension GetMappingInput {

    static func urlPathProvider(_ value: GetMappingInput) -> Swift.String? {
        return "/"
    }
}

extension GetMLTaskRunInput {

    static func urlPathProvider(_ value: GetMLTaskRunInput) -> Swift.String? {
        return "/"
    }
}

extension GetMLTaskRunsInput {

    static func urlPathProvider(_ value: GetMLTaskRunsInput) -> Swift.String? {
        return "/"
    }
}

extension GetMLTransformInput {

    static func urlPathProvider(_ value: GetMLTransformInput) -> Swift.String? {
        return "/"
    }
}

extension GetMLTransformsInput {

    static func urlPathProvider(_ value: GetMLTransformsInput) -> Swift.String? {
        return "/"
    }
}

extension GetPartitionInput {

    static func urlPathProvider(_ value: GetPartitionInput) -> Swift.String? {
        return "/"
    }
}

extension GetPartitionIndexesInput {

    static func urlPathProvider(_ value: GetPartitionIndexesInput) -> Swift.String? {
        return "/"
    }
}

extension GetPartitionsInput {

    static func urlPathProvider(_ value: GetPartitionsInput) -> Swift.String? {
        return "/"
    }
}

extension GetPlanInput {

    static func urlPathProvider(_ value: GetPlanInput) -> Swift.String? {
        return "/"
    }
}

extension GetRegistryInput {

    static func urlPathProvider(_ value: GetRegistryInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourcePoliciesInput {

    static func urlPathProvider(_ value: GetResourcePoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetSchemaInput {

    static func urlPathProvider(_ value: GetSchemaInput) -> Swift.String? {
        return "/"
    }
}

extension GetSchemaByDefinitionInput {

    static func urlPathProvider(_ value: GetSchemaByDefinitionInput) -> Swift.String? {
        return "/"
    }
}

extension GetSchemaVersionInput {

    static func urlPathProvider(_ value: GetSchemaVersionInput) -> Swift.String? {
        return "/"
    }
}

extension GetSchemaVersionsDiffInput {

    static func urlPathProvider(_ value: GetSchemaVersionsDiffInput) -> Swift.String? {
        return "/"
    }
}

extension GetSecurityConfigurationInput {

    static func urlPathProvider(_ value: GetSecurityConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension GetSecurityConfigurationsInput {

    static func urlPathProvider(_ value: GetSecurityConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension GetSessionInput {

    static func urlPathProvider(_ value: GetSessionInput) -> Swift.String? {
        return "/"
    }
}

extension GetStatementInput {

    static func urlPathProvider(_ value: GetStatementInput) -> Swift.String? {
        return "/"
    }
}

extension GetTableInput {

    static func urlPathProvider(_ value: GetTableInput) -> Swift.String? {
        return "/"
    }
}

extension GetTableOptimizerInput {

    static func urlPathProvider(_ value: GetTableOptimizerInput) -> Swift.String? {
        return "/"
    }
}

extension GetTablesInput {

    static func urlPathProvider(_ value: GetTablesInput) -> Swift.String? {
        return "/"
    }
}

extension GetTableVersionInput {

    static func urlPathProvider(_ value: GetTableVersionInput) -> Swift.String? {
        return "/"
    }
}

extension GetTableVersionsInput {

    static func urlPathProvider(_ value: GetTableVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension GetTagsInput {

    static func urlPathProvider(_ value: GetTagsInput) -> Swift.String? {
        return "/"
    }
}

extension GetTriggerInput {

    static func urlPathProvider(_ value: GetTriggerInput) -> Swift.String? {
        return "/"
    }
}

extension GetTriggersInput {

    static func urlPathProvider(_ value: GetTriggersInput) -> Swift.String? {
        return "/"
    }
}

extension GetUnfilteredPartitionMetadataInput {

    static func urlPathProvider(_ value: GetUnfilteredPartitionMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension GetUnfilteredPartitionsMetadataInput {

    static func urlPathProvider(_ value: GetUnfilteredPartitionsMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension GetUnfilteredTableMetadataInput {

    static func urlPathProvider(_ value: GetUnfilteredTableMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension GetUsageProfileInput {

    static func urlPathProvider(_ value: GetUsageProfileInput) -> Swift.String? {
        return "/"
    }
}

extension GetUserDefinedFunctionInput {

    static func urlPathProvider(_ value: GetUserDefinedFunctionInput) -> Swift.String? {
        return "/"
    }
}

extension GetUserDefinedFunctionsInput {

    static func urlPathProvider(_ value: GetUserDefinedFunctionsInput) -> Swift.String? {
        return "/"
    }
}

extension GetWorkflowInput {

    static func urlPathProvider(_ value: GetWorkflowInput) -> Swift.String? {
        return "/"
    }
}

extension GetWorkflowRunInput {

    static func urlPathProvider(_ value: GetWorkflowRunInput) -> Swift.String? {
        return "/"
    }
}

extension GetWorkflowRunPropertiesInput {

    static func urlPathProvider(_ value: GetWorkflowRunPropertiesInput) -> Swift.String? {
        return "/"
    }
}

extension GetWorkflowRunsInput {

    static func urlPathProvider(_ value: GetWorkflowRunsInput) -> Swift.String? {
        return "/"
    }
}

extension ImportCatalogToGlueInput {

    static func urlPathProvider(_ value: ImportCatalogToGlueInput) -> Swift.String? {
        return "/"
    }
}

extension ListBlueprintsInput {

    static func urlPathProvider(_ value: ListBlueprintsInput) -> Swift.String? {
        return "/"
    }
}

extension ListColumnStatisticsTaskRunsInput {

    static func urlPathProvider(_ value: ListColumnStatisticsTaskRunsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCrawlersInput {

    static func urlPathProvider(_ value: ListCrawlersInput) -> Swift.String? {
        return "/"
    }
}

extension ListCrawlsInput {

    static func urlPathProvider(_ value: ListCrawlsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCustomEntityTypesInput {

    static func urlPathProvider(_ value: ListCustomEntityTypesInput) -> Swift.String? {
        return "/"
    }
}

extension ListDataQualityResultsInput {

    static func urlPathProvider(_ value: ListDataQualityResultsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDataQualityRuleRecommendationRunsInput {

    static func urlPathProvider(_ value: ListDataQualityRuleRecommendationRunsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDataQualityRulesetEvaluationRunsInput {

    static func urlPathProvider(_ value: ListDataQualityRulesetEvaluationRunsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDataQualityRulesetsInput {

    static func urlPathProvider(_ value: ListDataQualityRulesetsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDataQualityStatisticAnnotationsInput {

    static func urlPathProvider(_ value: ListDataQualityStatisticAnnotationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDataQualityStatisticsInput {

    static func urlPathProvider(_ value: ListDataQualityStatisticsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDevEndpointsInput {

    static func urlPathProvider(_ value: ListDevEndpointsInput) -> Swift.String? {
        return "/"
    }
}

extension ListJobsInput {

    static func urlPathProvider(_ value: ListJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListMLTransformsInput {

    static func urlPathProvider(_ value: ListMLTransformsInput) -> Swift.String? {
        return "/"
    }
}

extension ListRegistriesInput {

    static func urlPathProvider(_ value: ListRegistriesInput) -> Swift.String? {
        return "/"
    }
}

extension ListSchemasInput {

    static func urlPathProvider(_ value: ListSchemasInput) -> Swift.String? {
        return "/"
    }
}

extension ListSchemaVersionsInput {

    static func urlPathProvider(_ value: ListSchemaVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSessionsInput {

    static func urlPathProvider(_ value: ListSessionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListStatementsInput {

    static func urlPathProvider(_ value: ListStatementsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTableOptimizerRunsInput {

    static func urlPathProvider(_ value: ListTableOptimizerRunsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTriggersInput {

    static func urlPathProvider(_ value: ListTriggersInput) -> Swift.String? {
        return "/"
    }
}

extension ListUsageProfilesInput {

    static func urlPathProvider(_ value: ListUsageProfilesInput) -> Swift.String? {
        return "/"
    }
}

extension ListWorkflowsInput {

    static func urlPathProvider(_ value: ListWorkflowsInput) -> Swift.String? {
        return "/"
    }
}

extension PutDataCatalogEncryptionSettingsInput {

    static func urlPathProvider(_ value: PutDataCatalogEncryptionSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension PutDataQualityProfileAnnotationInput {

    static func urlPathProvider(_ value: PutDataQualityProfileAnnotationInput) -> Swift.String? {
        return "/"
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension PutSchemaVersionMetadataInput {

    static func urlPathProvider(_ value: PutSchemaVersionMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension PutWorkflowRunPropertiesInput {

    static func urlPathProvider(_ value: PutWorkflowRunPropertiesInput) -> Swift.String? {
        return "/"
    }
}

extension QuerySchemaVersionMetadataInput {

    static func urlPathProvider(_ value: QuerySchemaVersionMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterSchemaVersionInput {

    static func urlPathProvider(_ value: RegisterSchemaVersionInput) -> Swift.String? {
        return "/"
    }
}

extension RemoveSchemaVersionMetadataInput {

    static func urlPathProvider(_ value: RemoveSchemaVersionMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension ResetJobBookmarkInput {

    static func urlPathProvider(_ value: ResetJobBookmarkInput) -> Swift.String? {
        return "/"
    }
}

extension ResumeWorkflowRunInput {

    static func urlPathProvider(_ value: ResumeWorkflowRunInput) -> Swift.String? {
        return "/"
    }
}

extension RunStatementInput {

    static func urlPathProvider(_ value: RunStatementInput) -> Swift.String? {
        return "/"
    }
}

extension SearchTablesInput {

    static func urlPathProvider(_ value: SearchTablesInput) -> Swift.String? {
        return "/"
    }
}

extension StartBlueprintRunInput {

    static func urlPathProvider(_ value: StartBlueprintRunInput) -> Swift.String? {
        return "/"
    }
}

extension StartColumnStatisticsTaskRunInput {

    static func urlPathProvider(_ value: StartColumnStatisticsTaskRunInput) -> Swift.String? {
        return "/"
    }
}

extension StartColumnStatisticsTaskRunScheduleInput {

    static func urlPathProvider(_ value: StartColumnStatisticsTaskRunScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension StartCrawlerInput {

    static func urlPathProvider(_ value: StartCrawlerInput) -> Swift.String? {
        return "/"
    }
}

extension StartCrawlerScheduleInput {

    static func urlPathProvider(_ value: StartCrawlerScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension StartDataQualityRuleRecommendationRunInput {

    static func urlPathProvider(_ value: StartDataQualityRuleRecommendationRunInput) -> Swift.String? {
        return "/"
    }
}

extension StartDataQualityRulesetEvaluationRunInput {

    static func urlPathProvider(_ value: StartDataQualityRulesetEvaluationRunInput) -> Swift.String? {
        return "/"
    }
}

extension StartExportLabelsTaskRunInput {

    static func urlPathProvider(_ value: StartExportLabelsTaskRunInput) -> Swift.String? {
        return "/"
    }
}

extension StartImportLabelsTaskRunInput {

    static func urlPathProvider(_ value: StartImportLabelsTaskRunInput) -> Swift.String? {
        return "/"
    }
}

extension StartJobRunInput {

    static func urlPathProvider(_ value: StartJobRunInput) -> Swift.String? {
        return "/"
    }
}

extension StartMLEvaluationTaskRunInput {

    static func urlPathProvider(_ value: StartMLEvaluationTaskRunInput) -> Swift.String? {
        return "/"
    }
}

extension StartMLLabelingSetGenerationTaskRunInput {

    static func urlPathProvider(_ value: StartMLLabelingSetGenerationTaskRunInput) -> Swift.String? {
        return "/"
    }
}

extension StartTriggerInput {

    static func urlPathProvider(_ value: StartTriggerInput) -> Swift.String? {
        return "/"
    }
}

extension StartWorkflowRunInput {

    static func urlPathProvider(_ value: StartWorkflowRunInput) -> Swift.String? {
        return "/"
    }
}

extension StopColumnStatisticsTaskRunInput {

    static func urlPathProvider(_ value: StopColumnStatisticsTaskRunInput) -> Swift.String? {
        return "/"
    }
}

extension StopColumnStatisticsTaskRunScheduleInput {

    static func urlPathProvider(_ value: StopColumnStatisticsTaskRunScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension StopCrawlerInput {

    static func urlPathProvider(_ value: StopCrawlerInput) -> Swift.String? {
        return "/"
    }
}

extension StopCrawlerScheduleInput {

    static func urlPathProvider(_ value: StopCrawlerScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension StopSessionInput {

    static func urlPathProvider(_ value: StopSessionInput) -> Swift.String? {
        return "/"
    }
}

extension StopTriggerInput {

    static func urlPathProvider(_ value: StopTriggerInput) -> Swift.String? {
        return "/"
    }
}

extension StopWorkflowRunInput {

    static func urlPathProvider(_ value: StopWorkflowRunInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TestConnectionInput {

    static func urlPathProvider(_ value: TestConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateBlueprintInput {

    static func urlPathProvider(_ value: UpdateBlueprintInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateClassifierInput {

    static func urlPathProvider(_ value: UpdateClassifierInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateColumnStatisticsForPartitionInput {

    static func urlPathProvider(_ value: UpdateColumnStatisticsForPartitionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateColumnStatisticsForTableInput {

    static func urlPathProvider(_ value: UpdateColumnStatisticsForTableInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateColumnStatisticsTaskSettingsInput {

    static func urlPathProvider(_ value: UpdateColumnStatisticsTaskSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateConnectionInput {

    static func urlPathProvider(_ value: UpdateConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCrawlerInput {

    static func urlPathProvider(_ value: UpdateCrawlerInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCrawlerScheduleInput {

    static func urlPathProvider(_ value: UpdateCrawlerScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDatabaseInput {

    static func urlPathProvider(_ value: UpdateDatabaseInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDataQualityRulesetInput {

    static func urlPathProvider(_ value: UpdateDataQualityRulesetInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDevEndpointInput {

    static func urlPathProvider(_ value: UpdateDevEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateJobInput {

    static func urlPathProvider(_ value: UpdateJobInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateJobFromSourceControlInput {

    static func urlPathProvider(_ value: UpdateJobFromSourceControlInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateMLTransformInput {

    static func urlPathProvider(_ value: UpdateMLTransformInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePartitionInput {

    static func urlPathProvider(_ value: UpdatePartitionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRegistryInput {

    static func urlPathProvider(_ value: UpdateRegistryInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSchemaInput {

    static func urlPathProvider(_ value: UpdateSchemaInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSourceControlFromJobInput {

    static func urlPathProvider(_ value: UpdateSourceControlFromJobInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateTableInput {

    static func urlPathProvider(_ value: UpdateTableInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateTableOptimizerInput {

    static func urlPathProvider(_ value: UpdateTableOptimizerInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateTriggerInput {

    static func urlPathProvider(_ value: UpdateTriggerInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateUsageProfileInput {

    static func urlPathProvider(_ value: UpdateUsageProfileInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateUserDefinedFunctionInput {

    static func urlPathProvider(_ value: UpdateUserDefinedFunctionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateWorkflowInput {

    static func urlPathProvider(_ value: UpdateWorkflowInput) -> Swift.String? {
        return "/"
    }
}

extension BatchCreatePartitionInput {

    static func write(value: BatchCreatePartitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["PartitionInputList"].writeList(value.partitionInputList, memberWritingClosure: GlueClientTypes.PartitionInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableName"].write(value.tableName)
    }
}

extension BatchDeleteConnectionInput {

    static func write(value: BatchDeleteConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["ConnectionNameList"].writeList(value.connectionNameList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDeletePartitionInput {

    static func write(value: BatchDeletePartitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["PartitionsToDelete"].writeList(value.partitionsToDelete, memberWritingClosure: GlueClientTypes.PartitionValueList.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableName"].write(value.tableName)
    }
}

extension BatchDeleteTableInput {

    static func write(value: BatchDeleteTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TablesToDelete"].writeList(value.tablesToDelete, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension BatchDeleteTableVersionInput {

    static func write(value: BatchDeleteTableVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
        try writer["VersionIds"].writeList(value.versionIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetBlueprintsInput {

    static func write(value: BatchGetBlueprintsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncludeBlueprint"].write(value.includeBlueprint)
        try writer["IncludeParameterSpec"].write(value.includeParameterSpec)
        try writer["Names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetCrawlersInput {

    static func write(value: BatchGetCrawlersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrawlerNames"].writeList(value.crawlerNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetCustomEntityTypesInput {

    static func write(value: BatchGetCustomEntityTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetDataQualityResultInput {

    static func write(value: BatchGetDataQualityResultInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResultIds"].writeList(value.resultIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetDevEndpointsInput {

    static func write(value: BatchGetDevEndpointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DevEndpointNames"].writeList(value.devEndpointNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetJobsInput {

    static func write(value: BatchGetJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobNames"].writeList(value.jobNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetPartitionInput {

    static func write(value: BatchGetPartitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["PartitionsToGet"].writeList(value.partitionsToGet, memberWritingClosure: GlueClientTypes.PartitionValueList.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableName"].write(value.tableName)
    }
}

extension BatchGetTableOptimizerInput {

    static func write(value: BatchGetTableOptimizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Entries"].writeList(value.entries, memberWritingClosure: GlueClientTypes.BatchGetTableOptimizerEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetTriggersInput {

    static func write(value: BatchGetTriggersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TriggerNames"].writeList(value.triggerNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetWorkflowsInput {

    static func write(value: BatchGetWorkflowsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncludeGraph"].write(value.includeGraph)
        try writer["Names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchPutDataQualityStatisticAnnotationInput {

    static func write(value: BatchPutDataQualityStatisticAnnotationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["InclusionAnnotations"].writeList(value.inclusionAnnotations, memberWritingClosure: GlueClientTypes.DatapointInclusionAnnotation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchStopJobRunInput {

    static func write(value: BatchStopJobRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobName"].write(value.jobName)
        try writer["JobRunIds"].writeList(value.jobRunIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdatePartitionInput {

    static func write(value: BatchUpdatePartitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Entries"].writeList(value.entries, memberWritingClosure: GlueClientTypes.BatchUpdatePartitionRequestEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableName"].write(value.tableName)
    }
}

extension CancelDataQualityRuleRecommendationRunInput {

    static func write(value: CancelDataQualityRuleRecommendationRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RunId"].write(value.runId)
    }
}

extension CancelDataQualityRulesetEvaluationRunInput {

    static func write(value: CancelDataQualityRulesetEvaluationRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RunId"].write(value.runId)
    }
}

extension CancelMLTaskRunInput {

    static func write(value: CancelMLTaskRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TaskRunId"].write(value.taskRunId)
        try writer["TransformId"].write(value.transformId)
    }
}

extension CancelStatementInput {

    static func write(value: CancelStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["RequestOrigin"].write(value.requestOrigin)
        try writer["SessionId"].write(value.sessionId)
    }
}

extension CheckSchemaVersionValidityInput {

    static func write(value: CheckSchemaVersionValidityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataFormat"].write(value.dataFormat)
        try writer["SchemaDefinition"].write(value.schemaDefinition)
    }
}

extension CreateBlueprintInput {

    static func write(value: CreateBlueprintInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlueprintLocation"].write(value.blueprintLocation)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateClassifierInput {

    static func write(value: CreateClassifierInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CsvClassifier"].write(value.csvClassifier, with: GlueClientTypes.CreateCsvClassifierRequest.write(value:to:))
        try writer["GrokClassifier"].write(value.grokClassifier, with: GlueClientTypes.CreateGrokClassifierRequest.write(value:to:))
        try writer["JsonClassifier"].write(value.jsonClassifier, with: GlueClientTypes.CreateJsonClassifierRequest.write(value:to:))
        try writer["XMLClassifier"].write(value.xmlClassifier, with: GlueClientTypes.CreateXMLClassifierRequest.write(value:to:))
    }
}

extension CreateColumnStatisticsTaskSettingsInput {

    static func write(value: CreateColumnStatisticsTaskSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogID"].write(value.catalogID)
        try writer["ColumnNameList"].writeList(value.columnNameList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Role"].write(value.role)
        try writer["SampleSize"].write(value.sampleSize)
        try writer["Schedule"].write(value.schedule)
        try writer["SecurityConfiguration"].write(value.securityConfiguration)
        try writer["TableName"].write(value.tableName)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateConnectionInput {

    static func write(value: CreateConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["ConnectionInput"].write(value.connectionInput, with: GlueClientTypes.ConnectionInput.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateCrawlerInput {

    static func write(value: CreateCrawlerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Classifiers"].writeList(value.classifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Configuration"].write(value.configuration)
        try writer["CrawlerSecurityConfiguration"].write(value.crawlerSecurityConfiguration)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Description"].write(value.description)
        try writer["LakeFormationConfiguration"].write(value.lakeFormationConfiguration, with: GlueClientTypes.LakeFormationConfiguration.write(value:to:))
        try writer["LineageConfiguration"].write(value.lineageConfiguration, with: GlueClientTypes.LineageConfiguration.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["RecrawlPolicy"].write(value.recrawlPolicy, with: GlueClientTypes.RecrawlPolicy.write(value:to:))
        try writer["Role"].write(value.role)
        try writer["Schedule"].write(value.schedule)
        try writer["SchemaChangePolicy"].write(value.schemaChangePolicy, with: GlueClientTypes.SchemaChangePolicy.write(value:to:))
        try writer["TablePrefix"].write(value.tablePrefix)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Targets"].write(value.targets, with: GlueClientTypes.CrawlerTargets.write(value:to:))
    }
}

extension CreateCustomEntityTypeInput {

    static func write(value: CreateCustomEntityTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContextWords"].writeList(value.contextWords, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["RegexString"].write(value.regexString)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDatabaseInput {

    static func write(value: CreateDatabaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseInput"].write(value.databaseInput, with: GlueClientTypes.DatabaseInput.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDataQualityRulesetInput {

    static func write(value: CreateDataQualityRulesetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DataQualitySecurityConfiguration"].write(value.dataQualitySecurityConfiguration)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Ruleset"].write(value.ruleset)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TargetTable"].write(value.targetTable, with: GlueClientTypes.DataQualityTargetTable.write(value:to:))
    }
}

extension CreateDevEndpointInput {

    static func write(value: CreateDevEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arguments"].writeMap(value.arguments, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["EndpointName"].write(value.endpointName)
        try writer["ExtraJarsS3Path"].write(value.extraJarsS3Path)
        try writer["ExtraPythonLibsS3Path"].write(value.extraPythonLibsS3Path)
        try writer["GlueVersion"].write(value.glueVersion)
        try writer["NumberOfNodes"].write(value.numberOfNodes)
        try writer["NumberOfWorkers"].write(value.numberOfWorkers)
        try writer["PublicKey"].write(value.publicKey)
        try writer["PublicKeys"].writeList(value.publicKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RoleArn"].write(value.roleArn)
        try writer["SecurityConfiguration"].write(value.securityConfiguration)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetId"].write(value.subnetId)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["WorkerType"].write(value.workerType)
    }
}

extension CreateJobInput {

    static func write(value: CreateJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllocatedCapacity"].write(value.allocatedCapacity)
        try writer["CodeGenConfigurationNodes"].writeMap(value.codeGenConfigurationNodes, valueWritingClosure: GlueClientTypes.CodeGenConfigurationNode.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Command"].write(value.command, with: GlueClientTypes.JobCommand.write(value:to:))
        try writer["Connections"].write(value.connections, with: GlueClientTypes.ConnectionsList.write(value:to:))
        try writer["DefaultArguments"].writeMap(value.defaultArguments, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["ExecutionClass"].write(value.executionClass)
        try writer["ExecutionProperty"].write(value.executionProperty, with: GlueClientTypes.ExecutionProperty.write(value:to:))
        try writer["GlueVersion"].write(value.glueVersion)
        try writer["JobMode"].write(value.jobMode)
        try writer["JobRunQueuingEnabled"].write(value.jobRunQueuingEnabled)
        try writer["LogUri"].write(value.logUri)
        try writer["MaintenanceWindow"].write(value.maintenanceWindow)
        try writer["MaxCapacity"].write(value.maxCapacity)
        try writer["MaxRetries"].write(value.maxRetries)
        try writer["Name"].write(value.name)
        try writer["NonOverridableArguments"].writeMap(value.nonOverridableArguments, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["NotificationProperty"].write(value.notificationProperty, with: GlueClientTypes.NotificationProperty.write(value:to:))
        try writer["NumberOfWorkers"].write(value.numberOfWorkers)
        try writer["Role"].write(value.role)
        try writer["SecurityConfiguration"].write(value.securityConfiguration)
        try writer["SourceControlDetails"].write(value.sourceControlDetails, with: GlueClientTypes.SourceControlDetails.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Timeout"].write(value.timeout)
        try writer["WorkerType"].write(value.workerType)
    }
}

extension CreateMLTransformInput {

    static func write(value: CreateMLTransformInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["GlueVersion"].write(value.glueVersion)
        try writer["InputRecordTables"].writeList(value.inputRecordTables, memberWritingClosure: GlueClientTypes.GlueTable.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxCapacity"].write(value.maxCapacity)
        try writer["MaxRetries"].write(value.maxRetries)
        try writer["Name"].write(value.name)
        try writer["NumberOfWorkers"].write(value.numberOfWorkers)
        try writer["Parameters"].write(value.parameters, with: GlueClientTypes.TransformParameters.write(value:to:))
        try writer["Role"].write(value.role)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Timeout"].write(value.timeout)
        try writer["TransformEncryption"].write(value.transformEncryption, with: GlueClientTypes.TransformEncryption.write(value:to:))
        try writer["WorkerType"].write(value.workerType)
    }
}

extension CreatePartitionInput {

    static func write(value: CreatePartitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["PartitionInput"].write(value.partitionInput, with: GlueClientTypes.PartitionInput.write(value:to:))
        try writer["TableName"].write(value.tableName)
    }
}

extension CreatePartitionIndexInput {

    static func write(value: CreatePartitionIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["PartitionIndex"].write(value.partitionIndex, with: GlueClientTypes.PartitionIndex.write(value:to:))
        try writer["TableName"].write(value.tableName)
    }
}

extension CreateRegistryInput {

    static func write(value: CreateRegistryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["RegistryName"].write(value.registryName)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateSchemaInput {

    static func write(value: CreateSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Compatibility"].write(value.compatibility)
        try writer["DataFormat"].write(value.dataFormat)
        try writer["Description"].write(value.description)
        try writer["RegistryId"].write(value.registryId, with: GlueClientTypes.RegistryId.write(value:to:))
        try writer["SchemaDefinition"].write(value.schemaDefinition)
        try writer["SchemaName"].write(value.schemaName)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateScriptInput {

    static func write(value: CreateScriptInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DagEdges"].writeList(value.dagEdges, memberWritingClosure: GlueClientTypes.CodeGenEdge.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DagNodes"].writeList(value.dagNodes, memberWritingClosure: GlueClientTypes.CodeGenNode.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Language"].write(value.language)
    }
}

extension CreateSecurityConfigurationInput {

    static func write(value: CreateSecurityConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncryptionConfiguration"].write(value.encryptionConfiguration, with: GlueClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["Name"].write(value.name)
    }
}

extension CreateSessionInput {

    static func write(value: CreateSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Command"].write(value.command, with: GlueClientTypes.SessionCommand.write(value:to:))
        try writer["Connections"].write(value.connections, with: GlueClientTypes.ConnectionsList.write(value:to:))
        try writer["DefaultArguments"].writeMap(value.defaultArguments, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["GlueVersion"].write(value.glueVersion)
        try writer["Id"].write(value.id)
        try writer["IdleTimeout"].write(value.idleTimeout)
        try writer["MaxCapacity"].write(value.maxCapacity)
        try writer["NumberOfWorkers"].write(value.numberOfWorkers)
        try writer["RequestOrigin"].write(value.requestOrigin)
        try writer["Role"].write(value.role)
        try writer["SecurityConfiguration"].write(value.securityConfiguration)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Timeout"].write(value.timeout)
        try writer["WorkerType"].write(value.workerType)
    }
}

extension CreateTableInput {

    static func write(value: CreateTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["OpenTableFormatInput"].write(value.openTableFormatInput, with: GlueClientTypes.OpenTableFormatInput.write(value:to:))
        try writer["PartitionIndexes"].writeList(value.partitionIndexes, memberWritingClosure: GlueClientTypes.PartitionIndex.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableInput"].write(value.tableInput, with: GlueClientTypes.TableInput.write(value:to:))
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension CreateTableOptimizerInput {

    static func write(value: CreateTableOptimizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
        try writer["TableOptimizerConfiguration"].write(value.tableOptimizerConfiguration, with: GlueClientTypes.TableOptimizerConfiguration.write(value:to:))
        try writer["Type"].write(value.type)
    }
}

extension CreateTriggerInput {

    static func write(value: CreateTriggerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: GlueClientTypes.Action.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["EventBatchingCondition"].write(value.eventBatchingCondition, with: GlueClientTypes.EventBatchingCondition.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Predicate"].write(value.predicate, with: GlueClientTypes.Predicate.write(value:to:))
        try writer["Schedule"].write(value.schedule)
        try writer["StartOnCreation"].write(value.startOnCreation)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Type"].write(value.type)
        try writer["WorkflowName"].write(value.workflowName)
    }
}

extension CreateUsageProfileInput {

    static func write(value: CreateUsageProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configuration"].write(value.configuration, with: GlueClientTypes.ProfileConfiguration.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateUserDefinedFunctionInput {

    static func write(value: CreateUserDefinedFunctionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["FunctionInput"].write(value.functionInput, with: GlueClientTypes.UserDefinedFunctionInput.write(value:to:))
    }
}

extension CreateWorkflowInput {

    static func write(value: CreateWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultRunProperties"].writeMap(value.defaultRunProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["MaxConcurrentRuns"].write(value.maxConcurrentRuns)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeleteBlueprintInput {

    static func write(value: DeleteBlueprintInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteClassifierInput {

    static func write(value: DeleteClassifierInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteColumnStatisticsForPartitionInput {

    static func write(value: DeleteColumnStatisticsForPartitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["ColumnName"].write(value.columnName)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["PartitionValues"].writeList(value.partitionValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableName"].write(value.tableName)
    }
}

extension DeleteColumnStatisticsForTableInput {

    static func write(value: DeleteColumnStatisticsForTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["ColumnName"].write(value.columnName)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
    }
}

extension DeleteColumnStatisticsTaskSettingsInput {

    static func write(value: DeleteColumnStatisticsTaskSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
    }
}

extension DeleteConnectionInput {

    static func write(value: DeleteConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["ConnectionName"].write(value.connectionName)
    }
}

extension DeleteCrawlerInput {

    static func write(value: DeleteCrawlerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteCustomEntityTypeInput {

    static func write(value: DeleteCustomEntityTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteDatabaseInput {

    static func write(value: DeleteDatabaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["Name"].write(value.name)
    }
}

extension DeleteDataQualityRulesetInput {

    static func write(value: DeleteDataQualityRulesetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteDevEndpointInput {

    static func write(value: DeleteDevEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointName"].write(value.endpointName)
    }
}

extension DeleteJobInput {

    static func write(value: DeleteJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobName"].write(value.jobName)
    }
}

extension DeleteMLTransformInput {

    static func write(value: DeleteMLTransformInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TransformId"].write(value.transformId)
    }
}

extension DeletePartitionInput {

    static func write(value: DeletePartitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["PartitionValues"].writeList(value.partitionValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableName"].write(value.tableName)
    }
}

extension DeletePartitionIndexInput {

    static func write(value: DeletePartitionIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["IndexName"].write(value.indexName)
        try writer["TableName"].write(value.tableName)
    }
}

extension DeleteRegistryInput {

    static func write(value: DeleteRegistryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RegistryId"].write(value.registryId, with: GlueClientTypes.RegistryId.write(value:to:))
    }
}

extension DeleteResourcePolicyInput {

    static func write(value: DeleteResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PolicyHashCondition"].write(value.policyHashCondition)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension DeleteSchemaInput {

    static func write(value: DeleteSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SchemaId"].write(value.schemaId, with: GlueClientTypes.SchemaId.write(value:to:))
    }
}

extension DeleteSchemaVersionsInput {

    static func write(value: DeleteSchemaVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SchemaId"].write(value.schemaId, with: GlueClientTypes.SchemaId.write(value:to:))
        try writer["Versions"].write(value.versions)
    }
}

extension DeleteSecurityConfigurationInput {

    static func write(value: DeleteSecurityConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteSessionInput {

    static func write(value: DeleteSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["RequestOrigin"].write(value.requestOrigin)
    }
}

extension DeleteTableInput {

    static func write(value: DeleteTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Name"].write(value.name)
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension DeleteTableOptimizerInput {

    static func write(value: DeleteTableOptimizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
        try writer["Type"].write(value.type)
    }
}

extension DeleteTableVersionInput {

    static func write(value: DeleteTableVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
        try writer["VersionId"].write(value.versionId)
    }
}

extension DeleteTriggerInput {

    static func write(value: DeleteTriggerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteUsageProfileInput {

    static func write(value: DeleteUsageProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteUserDefinedFunctionInput {

    static func write(value: DeleteUserDefinedFunctionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["FunctionName"].write(value.functionName)
    }
}

extension DeleteWorkflowInput {

    static func write(value: DeleteWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension GetBlueprintInput {

    static func write(value: GetBlueprintInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncludeBlueprint"].write(value.includeBlueprint)
        try writer["IncludeParameterSpec"].write(value.includeParameterSpec)
        try writer["Name"].write(value.name)
    }
}

extension GetBlueprintRunInput {

    static func write(value: GetBlueprintRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlueprintName"].write(value.blueprintName)
        try writer["RunId"].write(value.runId)
    }
}

extension GetBlueprintRunsInput {

    static func write(value: GetBlueprintRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlueprintName"].write(value.blueprintName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetCatalogImportStatusInput {

    static func write(value: GetCatalogImportStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
    }
}

extension GetClassifierInput {

    static func write(value: GetClassifierInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension GetClassifiersInput {

    static func write(value: GetClassifiersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetColumnStatisticsForPartitionInput {

    static func write(value: GetColumnStatisticsForPartitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["ColumnNames"].writeList(value.columnNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["PartitionValues"].writeList(value.partitionValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableName"].write(value.tableName)
    }
}

extension GetColumnStatisticsForTableInput {

    static func write(value: GetColumnStatisticsForTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["ColumnNames"].writeList(value.columnNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
    }
}

extension GetColumnStatisticsTaskRunInput {

    static func write(value: GetColumnStatisticsTaskRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnStatisticsTaskRunId"].write(value.columnStatisticsTaskRunId)
    }
}

extension GetColumnStatisticsTaskRunsInput {

    static func write(value: GetColumnStatisticsTaskRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["TableName"].write(value.tableName)
    }
}

extension GetColumnStatisticsTaskSettingsInput {

    static func write(value: GetColumnStatisticsTaskSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
    }
}

extension GetConnectionInput {

    static func write(value: GetConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["HidePassword"].write(value.hidePassword)
        try writer["Name"].write(value.name)
    }
}

extension GetConnectionsInput {

    static func write(value: GetConnectionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["Filter"].write(value.filter, with: GlueClientTypes.GetConnectionsFilter.write(value:to:))
        try writer["HidePassword"].write(value.hidePassword)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetCrawlerInput {

    static func write(value: GetCrawlerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension GetCrawlerMetricsInput {

    static func write(value: GetCrawlerMetricsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrawlerNameList"].writeList(value.crawlerNameList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetCrawlersInput {

    static func write(value: GetCrawlersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetCustomEntityTypeInput {

    static func write(value: GetCustomEntityTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension GetDatabaseInput {

    static func write(value: GetDatabaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["Name"].write(value.name)
    }
}

extension GetDatabasesInput {

    static func write(value: GetDatabasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributesToGet"].writeList(value.attributesToGet, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GlueClientTypes.DatabaseAttributes>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CatalogId"].write(value.catalogId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceShareType"].write(value.resourceShareType)
    }
}

extension GetDataCatalogEncryptionSettingsInput {

    static func write(value: GetDataCatalogEncryptionSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
    }
}

extension GetDataflowGraphInput {

    static func write(value: GetDataflowGraphInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PythonScript"].write(value.pythonScript)
    }
}

extension GetDataQualityModelInput {

    static func write(value: GetDataQualityModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProfileId"].write(value.profileId)
        try writer["StatisticId"].write(value.statisticId)
    }
}

extension GetDataQualityModelResultInput {

    static func write(value: GetDataQualityModelResultInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProfileId"].write(value.profileId)
        try writer["StatisticId"].write(value.statisticId)
    }
}

extension GetDataQualityResultInput {

    static func write(value: GetDataQualityResultInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResultId"].write(value.resultId)
    }
}

extension GetDataQualityRuleRecommendationRunInput {

    static func write(value: GetDataQualityRuleRecommendationRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RunId"].write(value.runId)
    }
}

extension GetDataQualityRulesetInput {

    static func write(value: GetDataQualityRulesetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension GetDataQualityRulesetEvaluationRunInput {

    static func write(value: GetDataQualityRulesetEvaluationRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RunId"].write(value.runId)
    }
}

extension GetDevEndpointInput {

    static func write(value: GetDevEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointName"].write(value.endpointName)
    }
}

extension GetDevEndpointsInput {

    static func write(value: GetDevEndpointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetJobInput {

    static func write(value: GetJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobName"].write(value.jobName)
    }
}

extension GetJobBookmarkInput {

    static func write(value: GetJobBookmarkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobName"].write(value.jobName)
        try writer["RunId"].write(value.runId)
    }
}

extension GetJobRunInput {

    static func write(value: GetJobRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobName"].write(value.jobName)
        try writer["PredecessorsIncluded"].write(value.predecessorsIncluded)
        try writer["RunId"].write(value.runId)
    }
}

extension GetJobRunsInput {

    static func write(value: GetJobRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobName"].write(value.jobName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetJobsInput {

    static func write(value: GetJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetMappingInput {

    static func write(value: GetMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Location"].write(value.location, with: GlueClientTypes.Location.write(value:to:))
        try writer["Sinks"].writeList(value.sinks, memberWritingClosure: GlueClientTypes.CatalogEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Source"].write(value.source, with: GlueClientTypes.CatalogEntry.write(value:to:))
    }
}

extension GetMLTaskRunInput {

    static func write(value: GetMLTaskRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TaskRunId"].write(value.taskRunId)
        try writer["TransformId"].write(value.transformId)
    }
}

extension GetMLTaskRunsInput {

    static func write(value: GetMLTaskRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: GlueClientTypes.TaskRunFilterCriteria.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Sort"].write(value.sort, with: GlueClientTypes.TaskRunSortCriteria.write(value:to:))
        try writer["TransformId"].write(value.transformId)
    }
}

extension GetMLTransformInput {

    static func write(value: GetMLTransformInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TransformId"].write(value.transformId)
    }
}

extension GetMLTransformsInput {

    static func write(value: GetMLTransformsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: GlueClientTypes.TransformFilterCriteria.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Sort"].write(value.sort, with: GlueClientTypes.TransformSortCriteria.write(value:to:))
    }
}

extension GetPartitionInput {

    static func write(value: GetPartitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["PartitionValues"].writeList(value.partitionValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableName"].write(value.tableName)
    }
}

extension GetPartitionIndexesInput {

    static func write(value: GetPartitionIndexesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["NextToken"].write(value.nextToken)
        try writer["TableName"].write(value.tableName)
    }
}

extension GetPartitionsInput {

    static func write(value: GetPartitionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["ExcludeColumnSchema"].write(value.excludeColumnSchema)
        try writer["Expression"].write(value.expression)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["QueryAsOfTime"].writeTimestamp(value.queryAsOfTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Segment"].write(value.segment, with: GlueClientTypes.Segment.write(value:to:))
        try writer["TableName"].write(value.tableName)
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension GetPlanInput {

    static func write(value: GetPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalPlanOptionsMap"].writeMap(value.additionalPlanOptionsMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Language"].write(value.language)
        try writer["Location"].write(value.location, with: GlueClientTypes.Location.write(value:to:))
        try writer["Mapping"].writeList(value.mapping, memberWritingClosure: GlueClientTypes.MappingEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sinks"].writeList(value.sinks, memberWritingClosure: GlueClientTypes.CatalogEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Source"].write(value.source, with: GlueClientTypes.CatalogEntry.write(value:to:))
    }
}

extension GetRegistryInput {

    static func write(value: GetRegistryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RegistryId"].write(value.registryId, with: GlueClientTypes.RegistryId.write(value:to:))
    }
}

extension GetResourcePoliciesInput {

    static func write(value: GetResourcePoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetResourcePolicyInput {

    static func write(value: GetResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension GetSchemaInput {

    static func write(value: GetSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SchemaId"].write(value.schemaId, with: GlueClientTypes.SchemaId.write(value:to:))
    }
}

extension GetSchemaByDefinitionInput {

    static func write(value: GetSchemaByDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SchemaDefinition"].write(value.schemaDefinition)
        try writer["SchemaId"].write(value.schemaId, with: GlueClientTypes.SchemaId.write(value:to:))
    }
}

extension GetSchemaVersionInput {

    static func write(value: GetSchemaVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SchemaId"].write(value.schemaId, with: GlueClientTypes.SchemaId.write(value:to:))
        try writer["SchemaVersionId"].write(value.schemaVersionId)
        try writer["SchemaVersionNumber"].write(value.schemaVersionNumber, with: GlueClientTypes.SchemaVersionNumber.write(value:to:))
    }
}

extension GetSchemaVersionsDiffInput {

    static func write(value: GetSchemaVersionsDiffInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirstSchemaVersionNumber"].write(value.firstSchemaVersionNumber, with: GlueClientTypes.SchemaVersionNumber.write(value:to:))
        try writer["SchemaDiffType"].write(value.schemaDiffType)
        try writer["SchemaId"].write(value.schemaId, with: GlueClientTypes.SchemaId.write(value:to:))
        try writer["SecondSchemaVersionNumber"].write(value.secondSchemaVersionNumber, with: GlueClientTypes.SchemaVersionNumber.write(value:to:))
    }
}

extension GetSecurityConfigurationInput {

    static func write(value: GetSecurityConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension GetSecurityConfigurationsInput {

    static func write(value: GetSecurityConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetSessionInput {

    static func write(value: GetSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["RequestOrigin"].write(value.requestOrigin)
    }
}

extension GetStatementInput {

    static func write(value: GetStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["RequestOrigin"].write(value.requestOrigin)
        try writer["SessionId"].write(value.sessionId)
    }
}

extension GetTableInput {

    static func write(value: GetTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["IncludeStatusDetails"].write(value.includeStatusDetails)
        try writer["Name"].write(value.name)
        try writer["QueryAsOfTime"].writeTimestamp(value.queryAsOfTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension GetTableOptimizerInput {

    static func write(value: GetTableOptimizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
        try writer["Type"].write(value.type)
    }
}

extension GetTablesInput {

    static func write(value: GetTablesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributesToGet"].writeList(value.attributesToGet, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GlueClientTypes.TableAttributes>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Expression"].write(value.expression)
        try writer["IncludeStatusDetails"].write(value.includeStatusDetails)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["QueryAsOfTime"].writeTimestamp(value.queryAsOfTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension GetTableVersionInput {

    static func write(value: GetTableVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
        try writer["VersionId"].write(value.versionId)
    }
}

extension GetTableVersionsInput {

    static func write(value: GetTableVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["TableName"].write(value.tableName)
    }
}

extension GetTagsInput {

    static func write(value: GetTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension GetTriggerInput {

    static func write(value: GetTriggerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension GetTriggersInput {

    static func write(value: GetTriggersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DependentJobName"].write(value.dependentJobName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetUnfilteredPartitionMetadataInput {

    static func write(value: GetUnfilteredPartitionMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuditContext"].write(value.auditContext, with: GlueClientTypes.AuditContext.write(value:to:))
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["PartitionValues"].writeList(value.partitionValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QuerySessionContext"].write(value.querySessionContext, with: GlueClientTypes.QuerySessionContext.write(value:to:))
        try writer["Region"].write(value.region)
        try writer["SupportedPermissionTypes"].writeList(value.supportedPermissionTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GlueClientTypes.PermissionType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableName"].write(value.tableName)
    }
}

extension GetUnfilteredPartitionsMetadataInput {

    static func write(value: GetUnfilteredPartitionsMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuditContext"].write(value.auditContext, with: GlueClientTypes.AuditContext.write(value:to:))
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Expression"].write(value.expression)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["QuerySessionContext"].write(value.querySessionContext, with: GlueClientTypes.QuerySessionContext.write(value:to:))
        try writer["Region"].write(value.region)
        try writer["Segment"].write(value.segment, with: GlueClientTypes.Segment.write(value:to:))
        try writer["SupportedPermissionTypes"].writeList(value.supportedPermissionTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GlueClientTypes.PermissionType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableName"].write(value.tableName)
    }
}

extension GetUnfilteredTableMetadataInput {

    static func write(value: GetUnfilteredTableMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuditContext"].write(value.auditContext, with: GlueClientTypes.AuditContext.write(value:to:))
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Name"].write(value.name)
        try writer["ParentResourceArn"].write(value.parentResourceArn)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GlueClientTypes.Permission>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QuerySessionContext"].write(value.querySessionContext, with: GlueClientTypes.QuerySessionContext.write(value:to:))
        try writer["Region"].write(value.region)
        try writer["RootResourceArn"].write(value.rootResourceArn)
        try writer["SupportedDialect"].write(value.supportedDialect, with: GlueClientTypes.SupportedDialect.write(value:to:))
        try writer["SupportedPermissionTypes"].writeList(value.supportedPermissionTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GlueClientTypes.PermissionType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetUsageProfileInput {

    static func write(value: GetUsageProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension GetUserDefinedFunctionInput {

    static func write(value: GetUserDefinedFunctionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["FunctionName"].write(value.functionName)
    }
}

extension GetUserDefinedFunctionsInput {

    static func write(value: GetUserDefinedFunctionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Pattern"].write(value.pattern)
    }
}

extension GetWorkflowInput {

    static func write(value: GetWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncludeGraph"].write(value.includeGraph)
        try writer["Name"].write(value.name)
    }
}

extension GetWorkflowRunInput {

    static func write(value: GetWorkflowRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncludeGraph"].write(value.includeGraph)
        try writer["Name"].write(value.name)
        try writer["RunId"].write(value.runId)
    }
}

extension GetWorkflowRunPropertiesInput {

    static func write(value: GetWorkflowRunPropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["RunId"].write(value.runId)
    }
}

extension GetWorkflowRunsInput {

    static func write(value: GetWorkflowRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncludeGraph"].write(value.includeGraph)
        try writer["MaxResults"].write(value.maxResults)
        try writer["Name"].write(value.name)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ImportCatalogToGlueInput {

    static func write(value: ImportCatalogToGlueInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
    }
}

extension ListBlueprintsInput {

    static func write(value: ListBlueprintsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListColumnStatisticsTaskRunsInput {

    static func write(value: ListColumnStatisticsTaskRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCrawlersInput {

    static func write(value: ListCrawlersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListCrawlsInput {

    static func write(value: ListCrawlsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrawlerName"].write(value.crawlerName)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: GlueClientTypes.CrawlsFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCustomEntityTypesInput {

    static func write(value: ListCustomEntityTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListDataQualityResultsInput {

    static func write(value: ListDataQualityResultsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: GlueClientTypes.DataQualityResultFilterCriteria.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListDataQualityRuleRecommendationRunsInput {

    static func write(value: ListDataQualityRuleRecommendationRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: GlueClientTypes.DataQualityRuleRecommendationRunFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListDataQualityRulesetEvaluationRunsInput {

    static func write(value: ListDataQualityRulesetEvaluationRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: GlueClientTypes.DataQualityRulesetEvaluationRunFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListDataQualityRulesetsInput {

    static func write(value: ListDataQualityRulesetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: GlueClientTypes.DataQualityRulesetFilterCriteria.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListDataQualityStatisticAnnotationsInput {

    static func write(value: ListDataQualityStatisticAnnotationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ProfileId"].write(value.profileId)
        try writer["StatisticId"].write(value.statisticId)
        try writer["TimestampFilter"].write(value.timestampFilter, with: GlueClientTypes.TimestampFilter.write(value:to:))
    }
}

extension ListDataQualityStatisticsInput {

    static func write(value: ListDataQualityStatisticsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ProfileId"].write(value.profileId)
        try writer["StatisticId"].write(value.statisticId)
        try writer["TimestampFilter"].write(value.timestampFilter, with: GlueClientTypes.TimestampFilter.write(value:to:))
    }
}

extension ListDevEndpointsInput {

    static func write(value: ListDevEndpointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListJobsInput {

    static func write(value: ListJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListMLTransformsInput {

    static func write(value: ListMLTransformsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: GlueClientTypes.TransformFilterCriteria.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Sort"].write(value.sort, with: GlueClientTypes.TransformSortCriteria.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListRegistriesInput {

    static func write(value: ListRegistriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListSchemasInput {

    static func write(value: ListSchemasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RegistryId"].write(value.registryId, with: GlueClientTypes.RegistryId.write(value:to:))
    }
}

extension ListSchemaVersionsInput {

    static func write(value: ListSchemaVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SchemaId"].write(value.schemaId, with: GlueClientTypes.SchemaId.write(value:to:))
    }
}

extension ListSessionsInput {

    static func write(value: ListSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RequestOrigin"].write(value.requestOrigin)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListStatementsInput {

    static func write(value: ListStatementsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["RequestOrigin"].write(value.requestOrigin)
        try writer["SessionId"].write(value.sessionId)
    }
}

extension ListTableOptimizerRunsInput {

    static func write(value: ListTableOptimizerRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["TableName"].write(value.tableName)
        try writer["Type"].write(value.type)
    }
}

extension ListTriggersInput {

    static func write(value: ListTriggersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DependentJobName"].write(value.dependentJobName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListUsageProfilesInput {

    static func write(value: ListUsageProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListWorkflowsInput {

    static func write(value: ListWorkflowsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension PutDataCatalogEncryptionSettingsInput {

    static func write(value: PutDataCatalogEncryptionSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DataCatalogEncryptionSettings"].write(value.dataCatalogEncryptionSettings, with: GlueClientTypes.DataCatalogEncryptionSettings.write(value:to:))
    }
}

extension PutDataQualityProfileAnnotationInput {

    static func write(value: PutDataQualityProfileAnnotationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InclusionAnnotation"].write(value.inclusionAnnotation)
        try writer["ProfileId"].write(value.profileId)
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableHybrid"].write(value.enableHybrid)
        try writer["PolicyExistsCondition"].write(value.policyExistsCondition)
        try writer["PolicyHashCondition"].write(value.policyHashCondition)
        try writer["PolicyInJson"].write(value.policyInJson)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension PutSchemaVersionMetadataInput {

    static func write(value: PutSchemaVersionMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MetadataKeyValue"].write(value.metadataKeyValue, with: GlueClientTypes.MetadataKeyValuePair.write(value:to:))
        try writer["SchemaId"].write(value.schemaId, with: GlueClientTypes.SchemaId.write(value:to:))
        try writer["SchemaVersionId"].write(value.schemaVersionId)
        try writer["SchemaVersionNumber"].write(value.schemaVersionNumber, with: GlueClientTypes.SchemaVersionNumber.write(value:to:))
    }
}

extension PutWorkflowRunPropertiesInput {

    static func write(value: PutWorkflowRunPropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["RunId"].write(value.runId)
        try writer["RunProperties"].writeMap(value.runProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension QuerySchemaVersionMetadataInput {

    static func write(value: QuerySchemaVersionMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["MetadataList"].writeList(value.metadataList, memberWritingClosure: GlueClientTypes.MetadataKeyValuePair.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
        try writer["SchemaId"].write(value.schemaId, with: GlueClientTypes.SchemaId.write(value:to:))
        try writer["SchemaVersionId"].write(value.schemaVersionId)
        try writer["SchemaVersionNumber"].write(value.schemaVersionNumber, with: GlueClientTypes.SchemaVersionNumber.write(value:to:))
    }
}

extension RegisterSchemaVersionInput {

    static func write(value: RegisterSchemaVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SchemaDefinition"].write(value.schemaDefinition)
        try writer["SchemaId"].write(value.schemaId, with: GlueClientTypes.SchemaId.write(value:to:))
    }
}

extension RemoveSchemaVersionMetadataInput {

    static func write(value: RemoveSchemaVersionMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MetadataKeyValue"].write(value.metadataKeyValue, with: GlueClientTypes.MetadataKeyValuePair.write(value:to:))
        try writer["SchemaId"].write(value.schemaId, with: GlueClientTypes.SchemaId.write(value:to:))
        try writer["SchemaVersionId"].write(value.schemaVersionId)
        try writer["SchemaVersionNumber"].write(value.schemaVersionNumber, with: GlueClientTypes.SchemaVersionNumber.write(value:to:))
    }
}

extension ResetJobBookmarkInput {

    static func write(value: ResetJobBookmarkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobName"].write(value.jobName)
        try writer["RunId"].write(value.runId)
    }
}

extension ResumeWorkflowRunInput {

    static func write(value: ResumeWorkflowRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["NodeIds"].writeList(value.nodeIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RunId"].write(value.runId)
    }
}

extension RunStatementInput {

    static func write(value: RunStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Code"].write(value.code)
        try writer["RequestOrigin"].write(value.requestOrigin)
        try writer["SessionId"].write(value.sessionId)
    }
}

extension SearchTablesInput {

    static func write(value: SearchTablesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: GlueClientTypes.PropertyPredicate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludeStatusDetails"].write(value.includeStatusDetails)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceShareType"].write(value.resourceShareType)
        try writer["SearchText"].write(value.searchText)
        try writer["SortCriteria"].writeList(value.sortCriteria, memberWritingClosure: GlueClientTypes.SortCriterion.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartBlueprintRunInput {

    static func write(value: StartBlueprintRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlueprintName"].write(value.blueprintName)
        try writer["Parameters"].write(value.parameters)
        try writer["RoleArn"].write(value.roleArn)
    }
}

extension StartColumnStatisticsTaskRunInput {

    static func write(value: StartColumnStatisticsTaskRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogID"].write(value.catalogID)
        try writer["ColumnNameList"].writeList(value.columnNameList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Role"].write(value.role)
        try writer["SampleSize"].write(value.sampleSize)
        try writer["SecurityConfiguration"].write(value.securityConfiguration)
        try writer["TableName"].write(value.tableName)
    }
}

extension StartColumnStatisticsTaskRunScheduleInput {

    static func write(value: StartColumnStatisticsTaskRunScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
    }
}

extension StartCrawlerInput {

    static func write(value: StartCrawlerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension StartCrawlerScheduleInput {

    static func write(value: StartCrawlerScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrawlerName"].write(value.crawlerName)
    }
}

extension StartDataQualityRuleRecommendationRunInput {

    static func write(value: StartDataQualityRuleRecommendationRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["CreatedRulesetName"].write(value.createdRulesetName)
        try writer["DataQualitySecurityConfiguration"].write(value.dataQualitySecurityConfiguration)
        try writer["DataSource"].write(value.dataSource, with: GlueClientTypes.DataSource.write(value:to:))
        try writer["NumberOfWorkers"].write(value.numberOfWorkers)
        try writer["Role"].write(value.role)
        try writer["Timeout"].write(value.timeout)
    }
}

extension StartDataQualityRulesetEvaluationRunInput {

    static func write(value: StartDataQualityRulesetEvaluationRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalDataSources"].writeMap(value.additionalDataSources, valueWritingClosure: GlueClientTypes.DataSource.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["AdditionalRunOptions"].write(value.additionalRunOptions, with: GlueClientTypes.DataQualityEvaluationRunAdditionalRunOptions.write(value:to:))
        try writer["ClientToken"].write(value.clientToken)
        try writer["DataSource"].write(value.dataSource, with: GlueClientTypes.DataSource.write(value:to:))
        try writer["NumberOfWorkers"].write(value.numberOfWorkers)
        try writer["Role"].write(value.role)
        try writer["RulesetNames"].writeList(value.rulesetNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Timeout"].write(value.timeout)
    }
}

extension StartExportLabelsTaskRunInput {

    static func write(value: StartExportLabelsTaskRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OutputS3Path"].write(value.outputS3Path)
        try writer["TransformId"].write(value.transformId)
    }
}

extension StartImportLabelsTaskRunInput {

    static func write(value: StartImportLabelsTaskRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputS3Path"].write(value.inputS3Path)
        try writer["ReplaceAllLabels"].write(value.replaceAllLabels)
        try writer["TransformId"].write(value.transformId)
    }
}

extension StartJobRunInput {

    static func write(value: StartJobRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllocatedCapacity"].write(value.allocatedCapacity)
        try writer["Arguments"].writeMap(value.arguments, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ExecutionClass"].write(value.executionClass)
        try writer["JobName"].write(value.jobName)
        try writer["JobRunId"].write(value.jobRunId)
        try writer["JobRunQueuingEnabled"].write(value.jobRunQueuingEnabled)
        try writer["MaxCapacity"].write(value.maxCapacity)
        try writer["NotificationProperty"].write(value.notificationProperty, with: GlueClientTypes.NotificationProperty.write(value:to:))
        try writer["NumberOfWorkers"].write(value.numberOfWorkers)
        try writer["SecurityConfiguration"].write(value.securityConfiguration)
        try writer["Timeout"].write(value.timeout)
        try writer["WorkerType"].write(value.workerType)
    }
}

extension StartMLEvaluationTaskRunInput {

    static func write(value: StartMLEvaluationTaskRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TransformId"].write(value.transformId)
    }
}

extension StartMLLabelingSetGenerationTaskRunInput {

    static func write(value: StartMLLabelingSetGenerationTaskRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OutputS3Path"].write(value.outputS3Path)
        try writer["TransformId"].write(value.transformId)
    }
}

extension StartTriggerInput {

    static func write(value: StartTriggerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension StartWorkflowRunInput {

    static func write(value: StartWorkflowRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["RunProperties"].writeMap(value.runProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StopColumnStatisticsTaskRunInput {

    static func write(value: StopColumnStatisticsTaskRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
    }
}

extension StopColumnStatisticsTaskRunScheduleInput {

    static func write(value: StopColumnStatisticsTaskRunScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
    }
}

extension StopCrawlerInput {

    static func write(value: StopCrawlerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension StopCrawlerScheduleInput {

    static func write(value: StopCrawlerScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrawlerName"].write(value.crawlerName)
    }
}

extension StopSessionInput {

    static func write(value: StopSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["RequestOrigin"].write(value.requestOrigin)
    }
}

extension StopTriggerInput {

    static func write(value: StopTriggerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension StopWorkflowRunInput {

    static func write(value: StopWorkflowRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["RunId"].write(value.runId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagsToAdd"].writeMap(value.tagsToAdd, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TestConnectionInput {

    static func write(value: TestConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionName"].write(value.connectionName)
        try writer["TestConnectionInput"].write(value.testConnectionInput, with: GlueClientTypes.TestConnectionInput.write(value:to:))
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagsToRemove"].writeList(value.tagsToRemove, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateBlueprintInput {

    static func write(value: UpdateBlueprintInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlueprintLocation"].write(value.blueprintLocation)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension UpdateClassifierInput {

    static func write(value: UpdateClassifierInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CsvClassifier"].write(value.csvClassifier, with: GlueClientTypes.UpdateCsvClassifierRequest.write(value:to:))
        try writer["GrokClassifier"].write(value.grokClassifier, with: GlueClientTypes.UpdateGrokClassifierRequest.write(value:to:))
        try writer["JsonClassifier"].write(value.jsonClassifier, with: GlueClientTypes.UpdateJsonClassifierRequest.write(value:to:))
        try writer["XMLClassifier"].write(value.xmlClassifier, with: GlueClientTypes.UpdateXMLClassifierRequest.write(value:to:))
    }
}

extension UpdateColumnStatisticsForPartitionInput {

    static func write(value: UpdateColumnStatisticsForPartitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["ColumnStatisticsList"].writeList(value.columnStatisticsList, memberWritingClosure: GlueClientTypes.ColumnStatistics.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["PartitionValues"].writeList(value.partitionValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableName"].write(value.tableName)
    }
}

extension UpdateColumnStatisticsForTableInput {

    static func write(value: UpdateColumnStatisticsForTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["ColumnStatisticsList"].writeList(value.columnStatisticsList, memberWritingClosure: GlueClientTypes.ColumnStatistics.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
    }
}

extension UpdateColumnStatisticsTaskSettingsInput {

    static func write(value: UpdateColumnStatisticsTaskSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogID"].write(value.catalogID)
        try writer["ColumnNameList"].writeList(value.columnNameList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Role"].write(value.role)
        try writer["SampleSize"].write(value.sampleSize)
        try writer["Schedule"].write(value.schedule)
        try writer["SecurityConfiguration"].write(value.securityConfiguration)
        try writer["TableName"].write(value.tableName)
    }
}

extension UpdateConnectionInput {

    static func write(value: UpdateConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["ConnectionInput"].write(value.connectionInput, with: GlueClientTypes.ConnectionInput.write(value:to:))
        try writer["Name"].write(value.name)
    }
}

extension UpdateCrawlerInput {

    static func write(value: UpdateCrawlerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Classifiers"].writeList(value.classifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Configuration"].write(value.configuration)
        try writer["CrawlerSecurityConfiguration"].write(value.crawlerSecurityConfiguration)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Description"].write(value.description)
        try writer["LakeFormationConfiguration"].write(value.lakeFormationConfiguration, with: GlueClientTypes.LakeFormationConfiguration.write(value:to:))
        try writer["LineageConfiguration"].write(value.lineageConfiguration, with: GlueClientTypes.LineageConfiguration.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["RecrawlPolicy"].write(value.recrawlPolicy, with: GlueClientTypes.RecrawlPolicy.write(value:to:))
        try writer["Role"].write(value.role)
        try writer["Schedule"].write(value.schedule)
        try writer["SchemaChangePolicy"].write(value.schemaChangePolicy, with: GlueClientTypes.SchemaChangePolicy.write(value:to:))
        try writer["TablePrefix"].write(value.tablePrefix)
        try writer["Targets"].write(value.targets, with: GlueClientTypes.CrawlerTargets.write(value:to:))
    }
}

extension UpdateCrawlerScheduleInput {

    static func write(value: UpdateCrawlerScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrawlerName"].write(value.crawlerName)
        try writer["Schedule"].write(value.schedule)
    }
}

extension UpdateDatabaseInput {

    static func write(value: UpdateDatabaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseInput"].write(value.databaseInput, with: GlueClientTypes.DatabaseInput.write(value:to:))
        try writer["Name"].write(value.name)
    }
}

extension UpdateDataQualityRulesetInput {

    static func write(value: UpdateDataQualityRulesetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Ruleset"].write(value.ruleset)
    }
}

extension UpdateDevEndpointInput {

    static func write(value: UpdateDevEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddArguments"].writeMap(value.addArguments, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["AddPublicKeys"].writeList(value.addPublicKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CustomLibraries"].write(value.customLibraries, with: GlueClientTypes.DevEndpointCustomLibraries.write(value:to:))
        try writer["DeleteArguments"].writeList(value.deleteArguments, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeletePublicKeys"].writeList(value.deletePublicKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndpointName"].write(value.endpointName)
        try writer["PublicKey"].write(value.publicKey)
        try writer["UpdateEtlLibraries"].write(value.updateEtlLibraries)
    }
}

extension UpdateJobInput {

    static func write(value: UpdateJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobName"].write(value.jobName)
        try writer["JobUpdate"].write(value.jobUpdate, with: GlueClientTypes.JobUpdate.write(value:to:))
    }
}

extension UpdateJobFromSourceControlInput {

    static func write(value: UpdateJobFromSourceControlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthStrategy"].write(value.authStrategy)
        try writer["AuthToken"].write(value.authToken)
        try writer["BranchName"].write(value.branchName)
        try writer["CommitId"].write(value.commitId)
        try writer["Folder"].write(value.folder)
        try writer["JobName"].write(value.jobName)
        try writer["Provider"].write(value.provider)
        try writer["RepositoryName"].write(value.repositoryName)
        try writer["RepositoryOwner"].write(value.repositoryOwner)
    }
}

extension UpdateMLTransformInput {

    static func write(value: UpdateMLTransformInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["GlueVersion"].write(value.glueVersion)
        try writer["MaxCapacity"].write(value.maxCapacity)
        try writer["MaxRetries"].write(value.maxRetries)
        try writer["Name"].write(value.name)
        try writer["NumberOfWorkers"].write(value.numberOfWorkers)
        try writer["Parameters"].write(value.parameters, with: GlueClientTypes.TransformParameters.write(value:to:))
        try writer["Role"].write(value.role)
        try writer["Timeout"].write(value.timeout)
        try writer["TransformId"].write(value.transformId)
        try writer["WorkerType"].write(value.workerType)
    }
}

extension UpdatePartitionInput {

    static func write(value: UpdatePartitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["PartitionInput"].write(value.partitionInput, with: GlueClientTypes.PartitionInput.write(value:to:))
        try writer["PartitionValueList"].writeList(value.partitionValueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableName"].write(value.tableName)
    }
}

extension UpdateRegistryInput {

    static func write(value: UpdateRegistryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["RegistryId"].write(value.registryId, with: GlueClientTypes.RegistryId.write(value:to:))
    }
}

extension UpdateSchemaInput {

    static func write(value: UpdateSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Compatibility"].write(value.compatibility)
        try writer["Description"].write(value.description)
        try writer["SchemaId"].write(value.schemaId, with: GlueClientTypes.SchemaId.write(value:to:))
        try writer["SchemaVersionNumber"].write(value.schemaVersionNumber, with: GlueClientTypes.SchemaVersionNumber.write(value:to:))
    }
}

extension UpdateSourceControlFromJobInput {

    static func write(value: UpdateSourceControlFromJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthStrategy"].write(value.authStrategy)
        try writer["AuthToken"].write(value.authToken)
        try writer["BranchName"].write(value.branchName)
        try writer["CommitId"].write(value.commitId)
        try writer["Folder"].write(value.folder)
        try writer["JobName"].write(value.jobName)
        try writer["Provider"].write(value.provider)
        try writer["RepositoryName"].write(value.repositoryName)
        try writer["RepositoryOwner"].write(value.repositoryOwner)
    }
}

extension UpdateTableInput {

    static func write(value: UpdateTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Force"].write(value.force)
        try writer["SkipArchive"].write(value.skipArchive)
        try writer["TableInput"].write(value.tableInput, with: GlueClientTypes.TableInput.write(value:to:))
        try writer["TransactionId"].write(value.transactionId)
        try writer["VersionId"].write(value.versionId)
        try writer["ViewUpdateAction"].write(value.viewUpdateAction)
    }
}

extension UpdateTableOptimizerInput {

    static func write(value: UpdateTableOptimizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
        try writer["TableOptimizerConfiguration"].write(value.tableOptimizerConfiguration, with: GlueClientTypes.TableOptimizerConfiguration.write(value:to:))
        try writer["Type"].write(value.type)
    }
}

extension UpdateTriggerInput {

    static func write(value: UpdateTriggerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["TriggerUpdate"].write(value.triggerUpdate, with: GlueClientTypes.TriggerUpdate.write(value:to:))
    }
}

extension UpdateUsageProfileInput {

    static func write(value: UpdateUsageProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configuration"].write(value.configuration, with: GlueClientTypes.ProfileConfiguration.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension UpdateUserDefinedFunctionInput {

    static func write(value: UpdateUserDefinedFunctionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["FunctionInput"].write(value.functionInput, with: GlueClientTypes.UserDefinedFunctionInput.write(value:to:))
        try writer["FunctionName"].write(value.functionName)
    }
}

extension UpdateWorkflowInput {

    static func write(value: UpdateWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultRunProperties"].writeMap(value.defaultRunProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["MaxConcurrentRuns"].write(value.maxConcurrentRuns)
        try writer["Name"].write(value.name)
    }
}

extension BatchCreatePartitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreatePartitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreatePartitionOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: GlueClientTypes.PartitionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDeleteConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteConnectionOutput()
        value.errors = try reader["Errors"].readMapIfPresent(valueReadingClosure: GlueClientTypes.ErrorDetail.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.succeeded = try reader["Succeeded"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDeletePartitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeletePartitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeletePartitionOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: GlueClientTypes.PartitionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDeleteTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteTableOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: GlueClientTypes.TableError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDeleteTableVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteTableVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteTableVersionOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: GlueClientTypes.TableVersionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetBlueprintsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetBlueprintsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetBlueprintsOutput()
        value.blueprints = try reader["Blueprints"].readListIfPresent(memberReadingClosure: GlueClientTypes.Blueprint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.missingBlueprints = try reader["MissingBlueprints"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetCrawlersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetCrawlersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetCrawlersOutput()
        value.crawlers = try reader["Crawlers"].readListIfPresent(memberReadingClosure: GlueClientTypes.Crawler.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.crawlersNotFound = try reader["CrawlersNotFound"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetCustomEntityTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetCustomEntityTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetCustomEntityTypesOutput()
        value.customEntityTypes = try reader["CustomEntityTypes"].readListIfPresent(memberReadingClosure: GlueClientTypes.CustomEntityType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.customEntityTypesNotFound = try reader["CustomEntityTypesNotFound"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetDataQualityResultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetDataQualityResultOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetDataQualityResultOutput()
        value.results = try reader["Results"].readListIfPresent(memberReadingClosure: GlueClientTypes.DataQualityResult.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.resultsNotFound = try reader["ResultsNotFound"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetDevEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetDevEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetDevEndpointsOutput()
        value.devEndpoints = try reader["DevEndpoints"].readListIfPresent(memberReadingClosure: GlueClientTypes.DevEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.devEndpointsNotFound = try reader["DevEndpointsNotFound"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetJobsOutput()
        value.jobs = try reader["Jobs"].readListIfPresent(memberReadingClosure: GlueClientTypes.Job.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.jobsNotFound = try reader["JobsNotFound"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetPartitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetPartitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetPartitionOutput()
        value.partitions = try reader["Partitions"].readListIfPresent(memberReadingClosure: GlueClientTypes.Partition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedKeys = try reader["UnprocessedKeys"].readListIfPresent(memberReadingClosure: GlueClientTypes.PartitionValueList.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetTableOptimizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetTableOptimizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetTableOptimizerOutput()
        value.failures = try reader["Failures"].readListIfPresent(memberReadingClosure: GlueClientTypes.BatchGetTableOptimizerError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tableOptimizers = try reader["TableOptimizers"].readListIfPresent(memberReadingClosure: GlueClientTypes.BatchTableOptimizer.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetTriggersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetTriggersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetTriggersOutput()
        value.triggers = try reader["Triggers"].readListIfPresent(memberReadingClosure: GlueClientTypes.Trigger.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.triggersNotFound = try reader["TriggersNotFound"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetWorkflowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetWorkflowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetWorkflowsOutput()
        value.missingWorkflows = try reader["MissingWorkflows"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.workflows = try reader["Workflows"].readListIfPresent(memberReadingClosure: GlueClientTypes.Workflow.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchPutDataQualityStatisticAnnotationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchPutDataQualityStatisticAnnotationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchPutDataQualityStatisticAnnotationOutput()
        value.failedInclusionAnnotations = try reader["FailedInclusionAnnotations"].readListIfPresent(memberReadingClosure: GlueClientTypes.AnnotationError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchStopJobRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchStopJobRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchStopJobRunOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: GlueClientTypes.BatchStopJobRunError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.successfulSubmissions = try reader["SuccessfulSubmissions"].readListIfPresent(memberReadingClosure: GlueClientTypes.BatchStopJobRunSuccessfulSubmission.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchUpdatePartitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdatePartitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdatePartitionOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: GlueClientTypes.BatchUpdatePartitionFailureEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CancelDataQualityRuleRecommendationRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelDataQualityRuleRecommendationRunOutput {
        return CancelDataQualityRuleRecommendationRunOutput()
    }
}

extension CancelDataQualityRulesetEvaluationRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelDataQualityRulesetEvaluationRunOutput {
        return CancelDataQualityRulesetEvaluationRunOutput()
    }
}

extension CancelMLTaskRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelMLTaskRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelMLTaskRunOutput()
        value.status = try reader["Status"].readIfPresent()
        value.taskRunId = try reader["TaskRunId"].readIfPresent()
        value.transformId = try reader["TransformId"].readIfPresent()
        return value
    }
}

extension CancelStatementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelStatementOutput {
        return CancelStatementOutput()
    }
}

extension CheckSchemaVersionValidityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CheckSchemaVersionValidityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CheckSchemaVersionValidityOutput()
        value.error = try reader["Error"].readIfPresent()
        value.valid = try reader["Valid"].readIfPresent() ?? false
        return value
    }
}

extension CreateBlueprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBlueprintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBlueprintOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateClassifierOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateClassifierOutput {
        return CreateClassifierOutput()
    }
}

extension CreateColumnStatisticsTaskSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateColumnStatisticsTaskSettingsOutput {
        return CreateColumnStatisticsTaskSettingsOutput()
    }
}

extension CreateConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectionOutput()
        value.createConnectionStatus = try reader["CreateConnectionStatus"].readIfPresent()
        return value
    }
}

extension CreateCrawlerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCrawlerOutput {
        return CreateCrawlerOutput()
    }
}

extension CreateCustomEntityTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCustomEntityTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCustomEntityTypeOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateDatabaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDatabaseOutput {
        return CreateDatabaseOutput()
    }
}

extension CreateDataQualityRulesetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataQualityRulesetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataQualityRulesetOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateDevEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDevEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDevEndpointOutput()
        value.arguments = try reader["Arguments"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endpointName = try reader["EndpointName"].readIfPresent()
        value.extraJarsS3Path = try reader["ExtraJarsS3Path"].readIfPresent()
        value.extraPythonLibsS3Path = try reader["ExtraPythonLibsS3Path"].readIfPresent()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.glueVersion = try reader["GlueVersion"].readIfPresent()
        value.numberOfNodes = try reader["NumberOfNodes"].readIfPresent() ?? 0
        value.numberOfWorkers = try reader["NumberOfWorkers"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.securityConfiguration = try reader["SecurityConfiguration"].readIfPresent()
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.workerType = try reader["WorkerType"].readIfPresent()
        value.yarnEndpointAddress = try reader["YarnEndpointAddress"].readIfPresent()
        value.zeppelinRemoteSparkInterpreterPort = try reader["ZeppelinRemoteSparkInterpreterPort"].readIfPresent() ?? 0
        return value
    }
}

extension CreateJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateJobOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateMLTransformOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMLTransformOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMLTransformOutput()
        value.transformId = try reader["TransformId"].readIfPresent()
        return value
    }
}

extension CreatePartitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePartitionOutput {
        return CreatePartitionOutput()
    }
}

extension CreatePartitionIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePartitionIndexOutput {
        return CreatePartitionIndexOutput()
    }
}

extension CreateRegistryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRegistryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRegistryOutput()
        value.description = try reader["Description"].readIfPresent()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSchemaOutput()
        value.compatibility = try reader["Compatibility"].readIfPresent()
        value.dataFormat = try reader["DataFormat"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.latestSchemaVersion = try reader["LatestSchemaVersion"].readIfPresent()
        value.nextSchemaVersion = try reader["NextSchemaVersion"].readIfPresent()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaCheckpoint = try reader["SchemaCheckpoint"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaStatus = try reader["SchemaStatus"].readIfPresent()
        value.schemaVersionId = try reader["SchemaVersionId"].readIfPresent()
        value.schemaVersionStatus = try reader["SchemaVersionStatus"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateScriptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateScriptOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateScriptOutput()
        value.pythonScript = try reader["PythonScript"].readIfPresent()
        value.scalaCode = try reader["ScalaCode"].readIfPresent()
        return value
    }
}

extension CreateSecurityConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSecurityConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSecurityConfigurationOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSessionOutput()
        value.session = try reader["Session"].readIfPresent(with: GlueClientTypes.Session.read(from:))
        return value
    }
}

extension CreateTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTableOutput {
        return CreateTableOutput()
    }
}

extension CreateTableOptimizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTableOptimizerOutput {
        return CreateTableOptimizerOutput()
    }
}

extension CreateTriggerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTriggerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTriggerOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateUsageProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUsageProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUsageProfileOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateUserDefinedFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserDefinedFunctionOutput {
        return CreateUserDefinedFunctionOutput()
    }
}

extension CreateWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkflowOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension DeleteBlueprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBlueprintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBlueprintOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension DeleteClassifierOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteClassifierOutput {
        return DeleteClassifierOutput()
    }
}

extension DeleteColumnStatisticsForPartitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteColumnStatisticsForPartitionOutput {
        return DeleteColumnStatisticsForPartitionOutput()
    }
}

extension DeleteColumnStatisticsForTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteColumnStatisticsForTableOutput {
        return DeleteColumnStatisticsForTableOutput()
    }
}

extension DeleteColumnStatisticsTaskSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteColumnStatisticsTaskSettingsOutput {
        return DeleteColumnStatisticsTaskSettingsOutput()
    }
}

extension DeleteConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectionOutput {
        return DeleteConnectionOutput()
    }
}

extension DeleteCrawlerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCrawlerOutput {
        return DeleteCrawlerOutput()
    }
}

extension DeleteCustomEntityTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCustomEntityTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCustomEntityTypeOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension DeleteDatabaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDatabaseOutput {
        return DeleteDatabaseOutput()
    }
}

extension DeleteDataQualityRulesetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataQualityRulesetOutput {
        return DeleteDataQualityRulesetOutput()
    }
}

extension DeleteDevEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDevEndpointOutput {
        return DeleteDevEndpointOutput()
    }
}

extension DeleteJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteJobOutput()
        value.jobName = try reader["JobName"].readIfPresent()
        return value
    }
}

extension DeleteMLTransformOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMLTransformOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteMLTransformOutput()
        value.transformId = try reader["TransformId"].readIfPresent()
        return value
    }
}

extension DeletePartitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePartitionOutput {
        return DeletePartitionOutput()
    }
}

extension DeletePartitionIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePartitionIndexOutput {
        return DeletePartitionIndexOutput()
    }
}

extension DeleteRegistryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRegistryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRegistryOutput()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourcePolicyOutput {
        return DeleteResourcePolicyOutput()
    }
}

extension DeleteSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSchemaOutput()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DeleteSchemaVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSchemaVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSchemaVersionsOutput()
        value.schemaVersionErrors = try reader["SchemaVersionErrors"].readListIfPresent(memberReadingClosure: GlueClientTypes.SchemaVersionErrorItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeleteSecurityConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSecurityConfigurationOutput {
        return DeleteSecurityConfigurationOutput()
    }
}

extension DeleteSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSessionOutput()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension DeleteTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTableOutput {
        return DeleteTableOutput()
    }
}

extension DeleteTableOptimizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTableOptimizerOutput {
        return DeleteTableOptimizerOutput()
    }
}

extension DeleteTableVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTableVersionOutput {
        return DeleteTableVersionOutput()
    }
}

extension DeleteTriggerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTriggerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTriggerOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension DeleteUsageProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUsageProfileOutput {
        return DeleteUsageProfileOutput()
    }
}

extension DeleteUserDefinedFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserDefinedFunctionOutput {
        return DeleteUserDefinedFunctionOutput()
    }
}

extension DeleteWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteWorkflowOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GetBlueprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBlueprintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBlueprintOutput()
        value.blueprint = try reader["Blueprint"].readIfPresent(with: GlueClientTypes.Blueprint.read(from:))
        return value
    }
}

extension GetBlueprintRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBlueprintRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBlueprintRunOutput()
        value.blueprintRun = try reader["BlueprintRun"].readIfPresent(with: GlueClientTypes.BlueprintRun.read(from:))
        return value
    }
}

extension GetBlueprintRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBlueprintRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBlueprintRunsOutput()
        value.blueprintRuns = try reader["BlueprintRuns"].readListIfPresent(memberReadingClosure: GlueClientTypes.BlueprintRun.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetCatalogImportStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCatalogImportStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCatalogImportStatusOutput()
        value.importStatus = try reader["ImportStatus"].readIfPresent(with: GlueClientTypes.CatalogImportStatus.read(from:))
        return value
    }
}

extension GetClassifierOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetClassifierOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetClassifierOutput()
        value.classifier = try reader["Classifier"].readIfPresent(with: GlueClientTypes.Classifier.read(from:))
        return value
    }
}

extension GetClassifiersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetClassifiersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetClassifiersOutput()
        value.classifiers = try reader["Classifiers"].readListIfPresent(memberReadingClosure: GlueClientTypes.Classifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetColumnStatisticsForPartitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetColumnStatisticsForPartitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetColumnStatisticsForPartitionOutput()
        value.columnStatisticsList = try reader["ColumnStatisticsList"].readListIfPresent(memberReadingClosure: GlueClientTypes.ColumnStatistics.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: GlueClientTypes.ColumnError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetColumnStatisticsForTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetColumnStatisticsForTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetColumnStatisticsForTableOutput()
        value.columnStatisticsList = try reader["ColumnStatisticsList"].readListIfPresent(memberReadingClosure: GlueClientTypes.ColumnStatistics.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: GlueClientTypes.ColumnError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetColumnStatisticsTaskRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetColumnStatisticsTaskRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetColumnStatisticsTaskRunOutput()
        value.columnStatisticsTaskRun = try reader["ColumnStatisticsTaskRun"].readIfPresent(with: GlueClientTypes.ColumnStatisticsTaskRun.read(from:))
        return value
    }
}

extension GetColumnStatisticsTaskRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetColumnStatisticsTaskRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetColumnStatisticsTaskRunsOutput()
        value.columnStatisticsTaskRuns = try reader["ColumnStatisticsTaskRuns"].readListIfPresent(memberReadingClosure: GlueClientTypes.ColumnStatisticsTaskRun.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetColumnStatisticsTaskSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetColumnStatisticsTaskSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetColumnStatisticsTaskSettingsOutput()
        value.columnStatisticsTaskSettings = try reader["ColumnStatisticsTaskSettings"].readIfPresent(with: GlueClientTypes.ColumnStatisticsTaskSettings.read(from:))
        return value
    }
}

extension GetConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectionOutput()
        value.connection = try reader["Connection"].readIfPresent(with: GlueClientTypes.Connection.read(from:))
        return value
    }
}

extension GetConnectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectionsOutput()
        value.connectionList = try reader["ConnectionList"].readListIfPresent(memberReadingClosure: GlueClientTypes.Connection.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetCrawlerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCrawlerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCrawlerOutput()
        value.crawler = try reader["Crawler"].readIfPresent(with: GlueClientTypes.Crawler.read(from:))
        return value
    }
}

extension GetCrawlerMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCrawlerMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCrawlerMetricsOutput()
        value.crawlerMetricsList = try reader["CrawlerMetricsList"].readListIfPresent(memberReadingClosure: GlueClientTypes.CrawlerMetrics.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetCrawlersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCrawlersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCrawlersOutput()
        value.crawlers = try reader["Crawlers"].readListIfPresent(memberReadingClosure: GlueClientTypes.Crawler.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetCustomEntityTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCustomEntityTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCustomEntityTypeOutput()
        value.contextWords = try reader["ContextWords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.regexString = try reader["RegexString"].readIfPresent()
        return value
    }
}

extension GetDatabaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDatabaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDatabaseOutput()
        value.database = try reader["Database"].readIfPresent(with: GlueClientTypes.Database.read(from:))
        return value
    }
}

extension GetDatabasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDatabasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDatabasesOutput()
        value.databaseList = try reader["DatabaseList"].readListIfPresent(memberReadingClosure: GlueClientTypes.Database.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetDataCatalogEncryptionSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataCatalogEncryptionSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataCatalogEncryptionSettingsOutput()
        value.dataCatalogEncryptionSettings = try reader["DataCatalogEncryptionSettings"].readIfPresent(with: GlueClientTypes.DataCatalogEncryptionSettings.read(from:))
        return value
    }
}

extension GetDataflowGraphOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataflowGraphOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataflowGraphOutput()
        value.dagEdges = try reader["DagEdges"].readListIfPresent(memberReadingClosure: GlueClientTypes.CodeGenEdge.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dagNodes = try reader["DagNodes"].readListIfPresent(memberReadingClosure: GlueClientTypes.CodeGenNode.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetDataQualityModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataQualityModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataQualityModelOutput()
        value.completedOn = try reader["CompletedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GetDataQualityModelResultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataQualityModelResultOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataQualityModelResultOutput()
        value.completedOn = try reader["CompletedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.model = try reader["Model"].readListIfPresent(memberReadingClosure: GlueClientTypes.StatisticModelResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetDataQualityResultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataQualityResultOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataQualityResultOutput()
        value.analyzerResults = try reader["AnalyzerResults"].readListIfPresent(memberReadingClosure: GlueClientTypes.DataQualityAnalyzerResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.completedOn = try reader["CompletedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataSource = try reader["DataSource"].readIfPresent(with: GlueClientTypes.DataSource.read(from:))
        value.evaluationContext = try reader["EvaluationContext"].readIfPresent()
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobRunId = try reader["JobRunId"].readIfPresent()
        value.observations = try reader["Observations"].readListIfPresent(memberReadingClosure: GlueClientTypes.DataQualityObservation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.profileId = try reader["ProfileId"].readIfPresent()
        value.resultId = try reader["ResultId"].readIfPresent()
        value.ruleResults = try reader["RuleResults"].readListIfPresent(memberReadingClosure: GlueClientTypes.DataQualityRuleResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.rulesetEvaluationRunId = try reader["RulesetEvaluationRunId"].readIfPresent()
        value.rulesetName = try reader["RulesetName"].readIfPresent()
        value.score = try reader["Score"].readIfPresent()
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetDataQualityRuleRecommendationRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataQualityRuleRecommendationRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataQualityRuleRecommendationRunOutput()
        value.completedOn = try reader["CompletedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdRulesetName = try reader["CreatedRulesetName"].readIfPresent()
        value.dataQualitySecurityConfiguration = try reader["DataQualitySecurityConfiguration"].readIfPresent()
        value.dataSource = try reader["DataSource"].readIfPresent(with: GlueClientTypes.DataSource.read(from:))
        value.errorString = try reader["ErrorString"].readIfPresent()
        value.executionTime = try reader["ExecutionTime"].readIfPresent() ?? 0
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.numberOfWorkers = try reader["NumberOfWorkers"].readIfPresent()
        value.recommendedRuleset = try reader["RecommendedRuleset"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.runId = try reader["RunId"].readIfPresent()
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        return value
    }
}

extension GetDataQualityRulesetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataQualityRulesetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataQualityRulesetOutput()
        value.createdOn = try reader["CreatedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataQualitySecurityConfiguration = try reader["DataQualitySecurityConfiguration"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        value.recommendationRunId = try reader["RecommendationRunId"].readIfPresent()
        value.ruleset = try reader["Ruleset"].readIfPresent()
        value.targetTable = try reader["TargetTable"].readIfPresent(with: GlueClientTypes.DataQualityTargetTable.read(from:))
        return value
    }
}

extension GetDataQualityRulesetEvaluationRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataQualityRulesetEvaluationRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataQualityRulesetEvaluationRunOutput()
        value.additionalDataSources = try reader["AdditionalDataSources"].readMapIfPresent(valueReadingClosure: GlueClientTypes.DataSource.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.additionalRunOptions = try reader["AdditionalRunOptions"].readIfPresent(with: GlueClientTypes.DataQualityEvaluationRunAdditionalRunOptions.read(from:))
        value.completedOn = try reader["CompletedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataSource = try reader["DataSource"].readIfPresent(with: GlueClientTypes.DataSource.read(from:))
        value.errorString = try reader["ErrorString"].readIfPresent()
        value.executionTime = try reader["ExecutionTime"].readIfPresent() ?? 0
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.numberOfWorkers = try reader["NumberOfWorkers"].readIfPresent()
        value.resultIds = try reader["ResultIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.role = try reader["Role"].readIfPresent()
        value.rulesetNames = try reader["RulesetNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.runId = try reader["RunId"].readIfPresent()
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        return value
    }
}

extension GetDevEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDevEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDevEndpointOutput()
        value.devEndpoint = try reader["DevEndpoint"].readIfPresent(with: GlueClientTypes.DevEndpoint.read(from:))
        return value
    }
}

extension GetDevEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDevEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDevEndpointsOutput()
        value.devEndpoints = try reader["DevEndpoints"].readListIfPresent(memberReadingClosure: GlueClientTypes.DevEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJobOutput()
        value.job = try reader["Job"].readIfPresent(with: GlueClientTypes.Job.read(from:))
        return value
    }
}

extension GetJobBookmarkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJobBookmarkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJobBookmarkOutput()
        value.jobBookmarkEntry = try reader["JobBookmarkEntry"].readIfPresent(with: GlueClientTypes.JobBookmarkEntry.read(from:))
        return value
    }
}

extension GetJobRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJobRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJobRunOutput()
        value.jobRun = try reader["JobRun"].readIfPresent(with: GlueClientTypes.JobRun.read(from:))
        return value
    }
}

extension GetJobRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJobRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJobRunsOutput()
        value.jobRuns = try reader["JobRuns"].readListIfPresent(memberReadingClosure: GlueClientTypes.JobRun.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJobsOutput()
        value.jobs = try reader["Jobs"].readListIfPresent(memberReadingClosure: GlueClientTypes.Job.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMappingOutput()
        value.mapping = try reader["Mapping"].readListIfPresent(memberReadingClosure: GlueClientTypes.MappingEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetMLTaskRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMLTaskRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMLTaskRunOutput()
        value.completedOn = try reader["CompletedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errorString = try reader["ErrorString"].readIfPresent()
        value.executionTime = try reader["ExecutionTime"].readIfPresent() ?? 0
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.logGroupName = try reader["LogGroupName"].readIfPresent()
        value.properties = try reader["Properties"].readIfPresent(with: GlueClientTypes.TaskRunProperties.read(from:))
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.taskRunId = try reader["TaskRunId"].readIfPresent()
        value.transformId = try reader["TransformId"].readIfPresent()
        return value
    }
}

extension GetMLTaskRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMLTaskRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMLTaskRunsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.taskRuns = try reader["TaskRuns"].readListIfPresent(memberReadingClosure: GlueClientTypes.TaskRun.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetMLTransformOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMLTransformOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMLTransformOutput()
        value.createdOn = try reader["CreatedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.evaluationMetrics = try reader["EvaluationMetrics"].readIfPresent(with: GlueClientTypes.EvaluationMetrics.read(from:))
        value.glueVersion = try reader["GlueVersion"].readIfPresent()
        value.inputRecordTables = try reader["InputRecordTables"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueTable.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.labelCount = try reader["LabelCount"].readIfPresent() ?? 0
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maxCapacity = try reader["MaxCapacity"].readIfPresent()
        value.maxRetries = try reader["MaxRetries"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.numberOfWorkers = try reader["NumberOfWorkers"].readIfPresent()
        value.parameters = try reader["Parameters"].readIfPresent(with: GlueClientTypes.TransformParameters.read(from:))
        value.role = try reader["Role"].readIfPresent()
        value.schema = try reader["Schema"].readListIfPresent(memberReadingClosure: GlueClientTypes.SchemaColumn.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        value.transformEncryption = try reader["TransformEncryption"].readIfPresent(with: GlueClientTypes.TransformEncryption.read(from:))
        value.transformId = try reader["TransformId"].readIfPresent()
        value.workerType = try reader["WorkerType"].readIfPresent()
        return value
    }
}

extension GetMLTransformsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMLTransformsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMLTransformsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.transforms = try reader["Transforms"].readListIfPresent(memberReadingClosure: GlueClientTypes.MLTransform.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetPartitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPartitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPartitionOutput()
        value.partition = try reader["Partition"].readIfPresent(with: GlueClientTypes.Partition.read(from:))
        return value
    }
}

extension GetPartitionIndexesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPartitionIndexesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPartitionIndexesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.partitionIndexDescriptorList = try reader["PartitionIndexDescriptorList"].readListIfPresent(memberReadingClosure: GlueClientTypes.PartitionIndexDescriptor.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetPartitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPartitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPartitionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.partitions = try reader["Partitions"].readListIfPresent(memberReadingClosure: GlueClientTypes.Partition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPlanOutput()
        value.pythonScript = try reader["PythonScript"].readIfPresent()
        value.scalaCode = try reader["ScalaCode"].readIfPresent()
        return value
    }
}

extension GetRegistryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRegistryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRegistryOutput()
        value.createdTime = try reader["CreatedTime"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.updatedTime = try reader["UpdatedTime"].readIfPresent()
        return value
    }
}

extension GetResourcePoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePoliciesOutput()
        value.getResourcePoliciesResponseList = try reader["GetResourcePoliciesResponseList"].readListIfPresent(memberReadingClosure: GlueClientTypes.GluePolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.policyHash = try reader["PolicyHash"].readIfPresent()
        value.policyInJson = try reader["PolicyInJson"].readIfPresent()
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSchemaOutput()
        value.compatibility = try reader["Compatibility"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readIfPresent()
        value.dataFormat = try reader["DataFormat"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.latestSchemaVersion = try reader["LatestSchemaVersion"].readIfPresent()
        value.nextSchemaVersion = try reader["NextSchemaVersion"].readIfPresent()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaCheckpoint = try reader["SchemaCheckpoint"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaStatus = try reader["SchemaStatus"].readIfPresent()
        value.updatedTime = try reader["UpdatedTime"].readIfPresent()
        return value
    }
}

extension GetSchemaByDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSchemaByDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSchemaByDefinitionOutput()
        value.createdTime = try reader["CreatedTime"].readIfPresent()
        value.dataFormat = try reader["DataFormat"].readIfPresent()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaVersionId = try reader["SchemaVersionId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GetSchemaVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSchemaVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSchemaVersionOutput()
        value.createdTime = try reader["CreatedTime"].readIfPresent()
        value.dataFormat = try reader["DataFormat"].readIfPresent()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaDefinition = try reader["SchemaDefinition"].readIfPresent()
        value.schemaVersionId = try reader["SchemaVersionId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.versionNumber = try reader["VersionNumber"].readIfPresent()
        return value
    }
}

extension GetSchemaVersionsDiffOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSchemaVersionsDiffOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSchemaVersionsDiffOutput()
        value.diff = try reader["Diff"].readIfPresent()
        return value
    }
}

extension GetSecurityConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSecurityConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSecurityConfigurationOutput()
        value.securityConfiguration = try reader["SecurityConfiguration"].readIfPresent(with: GlueClientTypes.SecurityConfiguration.read(from:))
        return value
    }
}

extension GetSecurityConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSecurityConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSecurityConfigurationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.securityConfigurations = try reader["SecurityConfigurations"].readListIfPresent(memberReadingClosure: GlueClientTypes.SecurityConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSessionOutput()
        value.session = try reader["Session"].readIfPresent(with: GlueClientTypes.Session.read(from:))
        return value
    }
}

extension GetStatementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStatementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStatementOutput()
        value.statement = try reader["Statement"].readIfPresent(with: GlueClientTypes.Statement.read(from:))
        return value
    }
}

extension GetTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableOutput()
        value.table = try reader["Table"].readIfPresent(with: GlueClientTypes.Table.read(from:))
        return value
    }
}

extension GetTableOptimizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableOptimizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableOptimizerOutput()
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        value.tableOptimizer = try reader["TableOptimizer"].readIfPresent(with: GlueClientTypes.TableOptimizer.read(from:))
        return value
    }
}

extension GetTablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTablesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tableList = try reader["TableList"].readListIfPresent(memberReadingClosure: GlueClientTypes.Table.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetTableVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableVersionOutput()
        value.tableVersion = try reader["TableVersion"].readIfPresent(with: GlueClientTypes.TableVersion.read(from:))
        return value
    }
}

extension GetTableVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tableVersions = try reader["TableVersions"].readListIfPresent(memberReadingClosure: GlueClientTypes.TableVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTagsOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetTriggerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTriggerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTriggerOutput()
        value.trigger = try reader["Trigger"].readIfPresent(with: GlueClientTypes.Trigger.read(from:))
        return value
    }
}

extension GetTriggersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTriggersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTriggersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.triggers = try reader["Triggers"].readListIfPresent(memberReadingClosure: GlueClientTypes.Trigger.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetUnfilteredPartitionMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUnfilteredPartitionMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUnfilteredPartitionMetadataOutput()
        value.authorizedColumns = try reader["AuthorizedColumns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.isRegisteredWithLakeFormation = try reader["IsRegisteredWithLakeFormation"].readIfPresent() ?? false
        value.partition = try reader["Partition"].readIfPresent(with: GlueClientTypes.Partition.read(from:))
        return value
    }
}

extension GetUnfilteredPartitionsMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUnfilteredPartitionsMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUnfilteredPartitionsMetadataOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.unfilteredPartitions = try reader["UnfilteredPartitions"].readListIfPresent(memberReadingClosure: GlueClientTypes.UnfilteredPartition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetUnfilteredTableMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUnfilteredTableMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUnfilteredTableMetadataOutput()
        value.authorizedColumns = try reader["AuthorizedColumns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.cellFilters = try reader["CellFilters"].readListIfPresent(memberReadingClosure: GlueClientTypes.ColumnRowFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isMultiDialectView = try reader["IsMultiDialectView"].readIfPresent() ?? false
        value.isProtected = try reader["IsProtected"].readIfPresent() ?? false
        value.isRegisteredWithLakeFormation = try reader["IsRegisteredWithLakeFormation"].readIfPresent() ?? false
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GlueClientTypes.Permission>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.queryAuthorizationId = try reader["QueryAuthorizationId"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.rowFilter = try reader["RowFilter"].readIfPresent()
        value.table = try reader["Table"].readIfPresent(with: GlueClientTypes.Table.read(from:))
        return value
    }
}

extension GetUsageProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUsageProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUsageProfileOutput()
        value.configuration = try reader["Configuration"].readIfPresent(with: GlueClientTypes.ProfileConfiguration.read(from:))
        value.createdOn = try reader["CreatedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GetUserDefinedFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUserDefinedFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUserDefinedFunctionOutput()
        value.userDefinedFunction = try reader["UserDefinedFunction"].readIfPresent(with: GlueClientTypes.UserDefinedFunction.read(from:))
        return value
    }
}

extension GetUserDefinedFunctionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUserDefinedFunctionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUserDefinedFunctionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.userDefinedFunctions = try reader["UserDefinedFunctions"].readListIfPresent(memberReadingClosure: GlueClientTypes.UserDefinedFunction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowOutput()
        value.workflow = try reader["Workflow"].readIfPresent(with: GlueClientTypes.Workflow.read(from:))
        return value
    }
}

extension GetWorkflowRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowRunOutput()
        value.run = try reader["Run"].readIfPresent(with: GlueClientTypes.WorkflowRun.read(from:))
        return value
    }
}

extension GetWorkflowRunPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowRunPropertiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowRunPropertiesOutput()
        value.runProperties = try reader["RunProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetWorkflowRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowRunsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.runs = try reader["Runs"].readListIfPresent(memberReadingClosure: GlueClientTypes.WorkflowRun.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImportCatalogToGlueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportCatalogToGlueOutput {
        return ImportCatalogToGlueOutput()
    }
}

extension ListBlueprintsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBlueprintsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBlueprintsOutput()
        value.blueprints = try reader["Blueprints"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListColumnStatisticsTaskRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListColumnStatisticsTaskRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListColumnStatisticsTaskRunsOutput()
        value.columnStatisticsTaskRunIds = try reader["ColumnStatisticsTaskRunIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCrawlersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCrawlersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCrawlersOutput()
        value.crawlerNames = try reader["CrawlerNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCrawlsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCrawlsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCrawlsOutput()
        value.crawls = try reader["Crawls"].readListIfPresent(memberReadingClosure: GlueClientTypes.CrawlerHistory.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCustomEntityTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomEntityTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomEntityTypesOutput()
        value.customEntityTypes = try reader["CustomEntityTypes"].readListIfPresent(memberReadingClosure: GlueClientTypes.CustomEntityType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDataQualityResultsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataQualityResultsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataQualityResultsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.results = try reader["Results"].readListIfPresent(memberReadingClosure: GlueClientTypes.DataQualityResultDescription.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListDataQualityRuleRecommendationRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataQualityRuleRecommendationRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataQualityRuleRecommendationRunsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.runs = try reader["Runs"].readListIfPresent(memberReadingClosure: GlueClientTypes.DataQualityRuleRecommendationRunDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDataQualityRulesetEvaluationRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataQualityRulesetEvaluationRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataQualityRulesetEvaluationRunsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.runs = try reader["Runs"].readListIfPresent(memberReadingClosure: GlueClientTypes.DataQualityRulesetEvaluationRunDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDataQualityRulesetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataQualityRulesetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataQualityRulesetsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.rulesets = try reader["Rulesets"].readListIfPresent(memberReadingClosure: GlueClientTypes.DataQualityRulesetListDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDataQualityStatisticAnnotationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataQualityStatisticAnnotationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataQualityStatisticAnnotationsOutput()
        value.annotations = try reader["Annotations"].readListIfPresent(memberReadingClosure: GlueClientTypes.StatisticAnnotation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDataQualityStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataQualityStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataQualityStatisticsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.statistics = try reader["Statistics"].readListIfPresent(memberReadingClosure: GlueClientTypes.StatisticSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDevEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDevEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDevEndpointsOutput()
        value.devEndpointNames = try reader["DevEndpointNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJobsOutput()
        value.jobNames = try reader["JobNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMLTransformsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMLTransformsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMLTransformsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.transformIds = try reader["TransformIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListRegistriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRegistriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRegistriesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.registries = try reader["Registries"].readListIfPresent(memberReadingClosure: GlueClientTypes.RegistryListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSchemasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSchemasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSchemasOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemas = try reader["Schemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.SchemaListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSchemaVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSchemaVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSchemaVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemas = try reader["Schemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.SchemaVersionListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSessionsOutput()
        value.ids = try reader["Ids"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.sessions = try reader["Sessions"].readListIfPresent(memberReadingClosure: GlueClientTypes.Session.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListStatementsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStatementsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStatementsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.statements = try reader["Statements"].readListIfPresent(memberReadingClosure: GlueClientTypes.Statement.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTableOptimizerRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTableOptimizerRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTableOptimizerRunsOutput()
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        value.tableOptimizerRuns = try reader["TableOptimizerRuns"].readListIfPresent(memberReadingClosure: GlueClientTypes.TableOptimizerRun.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTriggersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTriggersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTriggersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.triggerNames = try reader["TriggerNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUsageProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUsageProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUsageProfilesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.profiles = try reader["Profiles"].readListIfPresent(memberReadingClosure: GlueClientTypes.UsageProfileDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorkflowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkflowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkflowsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workflows = try reader["Workflows"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutDataCatalogEncryptionSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutDataCatalogEncryptionSettingsOutput {
        return PutDataCatalogEncryptionSettingsOutput()
    }
}

extension PutDataQualityProfileAnnotationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutDataQualityProfileAnnotationOutput {
        return PutDataQualityProfileAnnotationOutput()
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutResourcePolicyOutput()
        value.policyHash = try reader["PolicyHash"].readIfPresent()
        return value
    }
}

extension PutSchemaVersionMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutSchemaVersionMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutSchemaVersionMetadataOutput()
        value.latestVersion = try reader["LatestVersion"].readIfPresent() ?? false
        value.metadataKey = try reader["MetadataKey"].readIfPresent()
        value.metadataValue = try reader["MetadataValue"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaVersionId = try reader["SchemaVersionId"].readIfPresent()
        value.versionNumber = try reader["VersionNumber"].readIfPresent()
        return value
    }
}

extension PutWorkflowRunPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutWorkflowRunPropertiesOutput {
        return PutWorkflowRunPropertiesOutput()
    }
}

extension QuerySchemaVersionMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> QuerySchemaVersionMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = QuerySchemaVersionMetadataOutput()
        value.metadataInfoMap = try reader["MetadataInfoMap"].readMapIfPresent(valueReadingClosure: GlueClientTypes.MetadataInfo.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemaVersionId = try reader["SchemaVersionId"].readIfPresent()
        return value
    }
}

extension RegisterSchemaVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterSchemaVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterSchemaVersionOutput()
        value.schemaVersionId = try reader["SchemaVersionId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.versionNumber = try reader["VersionNumber"].readIfPresent()
        return value
    }
}

extension RemoveSchemaVersionMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveSchemaVersionMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveSchemaVersionMetadataOutput()
        value.latestVersion = try reader["LatestVersion"].readIfPresent() ?? false
        value.metadataKey = try reader["MetadataKey"].readIfPresent()
        value.metadataValue = try reader["MetadataValue"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaVersionId = try reader["SchemaVersionId"].readIfPresent()
        value.versionNumber = try reader["VersionNumber"].readIfPresent()
        return value
    }
}

extension ResetJobBookmarkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetJobBookmarkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResetJobBookmarkOutput()
        value.jobBookmarkEntry = try reader["JobBookmarkEntry"].readIfPresent(with: GlueClientTypes.JobBookmarkEntry.read(from:))
        return value
    }
}

extension ResumeWorkflowRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResumeWorkflowRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResumeWorkflowRunOutput()
        value.nodeIds = try reader["NodeIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.runId = try reader["RunId"].readIfPresent()
        return value
    }
}

extension RunStatementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RunStatementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RunStatementOutput()
        value.id = try reader["Id"].readIfPresent() ?? 0
        return value
    }
}

extension SearchTablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchTablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchTablesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tableList = try reader["TableList"].readListIfPresent(memberReadingClosure: GlueClientTypes.Table.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartBlueprintRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartBlueprintRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartBlueprintRunOutput()
        value.runId = try reader["RunId"].readIfPresent()
        return value
    }
}

extension StartColumnStatisticsTaskRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartColumnStatisticsTaskRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartColumnStatisticsTaskRunOutput()
        value.columnStatisticsTaskRunId = try reader["ColumnStatisticsTaskRunId"].readIfPresent()
        return value
    }
}

extension StartColumnStatisticsTaskRunScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartColumnStatisticsTaskRunScheduleOutput {
        return StartColumnStatisticsTaskRunScheduleOutput()
    }
}

extension StartCrawlerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartCrawlerOutput {
        return StartCrawlerOutput()
    }
}

extension StartCrawlerScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartCrawlerScheduleOutput {
        return StartCrawlerScheduleOutput()
    }
}

extension StartDataQualityRuleRecommendationRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDataQualityRuleRecommendationRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDataQualityRuleRecommendationRunOutput()
        value.runId = try reader["RunId"].readIfPresent()
        return value
    }
}

extension StartDataQualityRulesetEvaluationRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDataQualityRulesetEvaluationRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDataQualityRulesetEvaluationRunOutput()
        value.runId = try reader["RunId"].readIfPresent()
        return value
    }
}

extension StartExportLabelsTaskRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartExportLabelsTaskRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartExportLabelsTaskRunOutput()
        value.taskRunId = try reader["TaskRunId"].readIfPresent()
        return value
    }
}

extension StartImportLabelsTaskRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartImportLabelsTaskRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartImportLabelsTaskRunOutput()
        value.taskRunId = try reader["TaskRunId"].readIfPresent()
        return value
    }
}

extension StartJobRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartJobRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartJobRunOutput()
        value.jobRunId = try reader["JobRunId"].readIfPresent()
        return value
    }
}

extension StartMLEvaluationTaskRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMLEvaluationTaskRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMLEvaluationTaskRunOutput()
        value.taskRunId = try reader["TaskRunId"].readIfPresent()
        return value
    }
}

extension StartMLLabelingSetGenerationTaskRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMLLabelingSetGenerationTaskRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMLLabelingSetGenerationTaskRunOutput()
        value.taskRunId = try reader["TaskRunId"].readIfPresent()
        return value
    }
}

extension StartTriggerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartTriggerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartTriggerOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension StartWorkflowRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartWorkflowRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartWorkflowRunOutput()
        value.runId = try reader["RunId"].readIfPresent()
        return value
    }
}

extension StopColumnStatisticsTaskRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopColumnStatisticsTaskRunOutput {
        return StopColumnStatisticsTaskRunOutput()
    }
}

extension StopColumnStatisticsTaskRunScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopColumnStatisticsTaskRunScheduleOutput {
        return StopColumnStatisticsTaskRunScheduleOutput()
    }
}

extension StopCrawlerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopCrawlerOutput {
        return StopCrawlerOutput()
    }
}

extension StopCrawlerScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopCrawlerScheduleOutput {
        return StopCrawlerScheduleOutput()
    }
}

extension StopSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopSessionOutput()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension StopTriggerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopTriggerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopTriggerOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension StopWorkflowRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopWorkflowRunOutput {
        return StopWorkflowRunOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TestConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestConnectionOutput {
        return TestConnectionOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateBlueprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBlueprintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBlueprintOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension UpdateClassifierOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateClassifierOutput {
        return UpdateClassifierOutput()
    }
}

extension UpdateColumnStatisticsForPartitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateColumnStatisticsForPartitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateColumnStatisticsForPartitionOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: GlueClientTypes.ColumnStatisticsError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateColumnStatisticsForTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateColumnStatisticsForTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateColumnStatisticsForTableOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: GlueClientTypes.ColumnStatisticsError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateColumnStatisticsTaskSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateColumnStatisticsTaskSettingsOutput {
        return UpdateColumnStatisticsTaskSettingsOutput()
    }
}

extension UpdateConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectionOutput {
        return UpdateConnectionOutput()
    }
}

extension UpdateCrawlerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCrawlerOutput {
        return UpdateCrawlerOutput()
    }
}

extension UpdateCrawlerScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCrawlerScheduleOutput {
        return UpdateCrawlerScheduleOutput()
    }
}

extension UpdateDatabaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDatabaseOutput {
        return UpdateDatabaseOutput()
    }
}

extension UpdateDataQualityRulesetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataQualityRulesetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataQualityRulesetOutput()
        value.description = try reader["Description"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.ruleset = try reader["Ruleset"].readIfPresent()
        return value
    }
}

extension UpdateDevEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDevEndpointOutput {
        return UpdateDevEndpointOutput()
    }
}

extension UpdateJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateJobOutput()
        value.jobName = try reader["JobName"].readIfPresent()
        return value
    }
}

extension UpdateJobFromSourceControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateJobFromSourceControlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateJobFromSourceControlOutput()
        value.jobName = try reader["JobName"].readIfPresent()
        return value
    }
}

extension UpdateMLTransformOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMLTransformOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMLTransformOutput()
        value.transformId = try reader["TransformId"].readIfPresent()
        return value
    }
}

extension UpdatePartitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePartitionOutput {
        return UpdatePartitionOutput()
    }
}

extension UpdateRegistryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRegistryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRegistryOutput()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        return value
    }
}

extension UpdateSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSchemaOutput()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        return value
    }
}

extension UpdateSourceControlFromJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSourceControlFromJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSourceControlFromJobOutput()
        value.jobName = try reader["JobName"].readIfPresent()
        return value
    }
}

extension UpdateTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTableOutput {
        return UpdateTableOutput()
    }
}

extension UpdateTableOptimizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTableOptimizerOutput {
        return UpdateTableOptimizerOutput()
    }
}

extension UpdateTriggerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTriggerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTriggerOutput()
        value.trigger = try reader["Trigger"].readIfPresent(with: GlueClientTypes.Trigger.read(from:))
        return value
    }
}

extension UpdateUsageProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUsageProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUsageProfileOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension UpdateUserDefinedFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserDefinedFunctionOutput {
        return UpdateUserDefinedFunctionOutput()
    }
}

extension UpdateWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorkflowOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

enum BatchCreatePartitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeletePartitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteTableVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetBlueprintsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetCrawlersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetCustomEntityTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetDataQualityResultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetDevEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetPartitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "FederationSourceException": return try FederationSourceException.makeError(baseError: baseError)
            case "FederationSourceRetryableException": return try FederationSourceRetryableException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetTableOptimizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetTriggersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetWorkflowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchPutDataQualityStatisticAnnotationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchStopJobRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdatePartitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelDataQualityRuleRecommendationRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelDataQualityRulesetEvaluationRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelMLTaskRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelStatementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "IllegalSessionStateException": return try IllegalSessionStateException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CheckSchemaVersionValidityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBlueprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateClassifierOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateColumnStatisticsTaskSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ColumnStatisticsTaskRunningException": return try ColumnStatisticsTaskRunningException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCrawlerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCustomEntityTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDatabaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "FederatedResourceAlreadyExistsException": return try FederatedResourceAlreadyExistsException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataQualityRulesetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDevEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMLTransformOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePartitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePartitionIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRegistryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateScriptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSecurityConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTableOptimizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTriggerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUsageProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserDefinedFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBlueprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteClassifierOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteColumnStatisticsForPartitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteColumnStatisticsForTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteColumnStatisticsTaskSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCrawlerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CrawlerRunningException": return try CrawlerRunningException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "SchedulerTransitioningException": return try SchedulerTransitioningException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCustomEntityTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDatabaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataQualityRulesetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDevEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMLTransformOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePartitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePartitionIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRegistryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConditionCheckFailureException": return try ConditionCheckFailureException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSchemaVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSecurityConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "IllegalSessionStateException": return try IllegalSessionStateException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTableOptimizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTableVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTriggerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUsageProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserDefinedFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBlueprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBlueprintRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBlueprintRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCatalogImportStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetClassifierOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetClassifiersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetColumnStatisticsForPartitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetColumnStatisticsForTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetColumnStatisticsTaskRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetColumnStatisticsTaskRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetColumnStatisticsTaskSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCrawlerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCrawlerMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCrawlersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCustomEntityTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDatabaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "FederationSourceException": return try FederationSourceException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDatabasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataCatalogEncryptionSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataflowGraphOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataQualityModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataQualityModelResultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataQualityResultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataQualityRuleRecommendationRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataQualityRulesetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataQualityRulesetEvaluationRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDevEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDevEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJobBookmarkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJobRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJobRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMLTaskRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMLTaskRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMLTransformOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMLTransformsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPartitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "FederationSourceException": return try FederationSourceException.makeError(baseError: baseError)
            case "FederationSourceRetryableException": return try FederationSourceRetryableException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPartitionIndexesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPartitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "FederationSourceException": return try FederationSourceException.makeError(baseError: baseError)
            case "FederationSourceRetryableException": return try FederationSourceRetryableException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRegistryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSchemaByDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSchemaVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSchemaVersionsDiffOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSecurityConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSecurityConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStatementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "IllegalSessionStateException": return try IllegalSessionStateException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "FederationSourceException": return try FederationSourceException.makeError(baseError: baseError)
            case "FederationSourceRetryableException": return try FederationSourceRetryableException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableOptimizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "FederationSourceException": return try FederationSourceException.makeError(baseError: baseError)
            case "FederationSourceRetryableException": return try FederationSourceRetryableException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTriggerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTriggersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUnfilteredPartitionMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "FederationSourceException": return try FederationSourceException.makeError(baseError: baseError)
            case "FederationSourceRetryableException": return try FederationSourceRetryableException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "PermissionTypeMismatchException": return try PermissionTypeMismatchException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUnfilteredPartitionsMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "FederationSourceException": return try FederationSourceException.makeError(baseError: baseError)
            case "FederationSourceRetryableException": return try FederationSourceRetryableException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "PermissionTypeMismatchException": return try PermissionTypeMismatchException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUnfilteredTableMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "FederationSourceException": return try FederationSourceException.makeError(baseError: baseError)
            case "FederationSourceRetryableException": return try FederationSourceRetryableException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "PermissionTypeMismatchException": return try PermissionTypeMismatchException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUsageProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUserDefinedFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUserDefinedFunctionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowRunPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportCatalogToGlueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBlueprintsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListColumnStatisticsTaskRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCrawlersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCrawlsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomEntityTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataQualityResultsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataQualityRuleRecommendationRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataQualityRulesetEvaluationRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataQualityRulesetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataQualityStatisticAnnotationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataQualityStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDevEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMLTransformsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRegistriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSchemasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSchemaVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStatementsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "IllegalSessionStateException": return try IllegalSessionStateException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTableOptimizerRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTriggersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUsageProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkflowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutDataCatalogEncryptionSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutDataQualityProfileAnnotationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConditionCheckFailureException": return try ConditionCheckFailureException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutSchemaVersionMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutWorkflowRunPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum QuerySchemaVersionMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterSchemaVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveSchemaVersionMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetJobBookmarkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResumeWorkflowRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentRunsExceededException": return try ConcurrentRunsExceededException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "IllegalWorkflowStateException": return try IllegalWorkflowStateException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RunStatementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "IllegalSessionStateException": return try IllegalSessionStateException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchTablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartBlueprintRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "IllegalBlueprintStateException": return try IllegalBlueprintStateException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartColumnStatisticsTaskRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ColumnStatisticsTaskRunningException": return try ColumnStatisticsTaskRunningException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartColumnStatisticsTaskRunScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartCrawlerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CrawlerRunningException": return try CrawlerRunningException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartCrawlerScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "NoScheduleException": return try NoScheduleException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "SchedulerRunningException": return try SchedulerRunningException.makeError(baseError: baseError)
            case "SchedulerTransitioningException": return try SchedulerTransitioningException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDataQualityRuleRecommendationRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDataQualityRulesetEvaluationRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartExportLabelsTaskRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartImportLabelsTaskRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartJobRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentRunsExceededException": return try ConcurrentRunsExceededException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMLEvaluationTaskRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentRunsExceededException": return try ConcurrentRunsExceededException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "MLTransformNotReadyException": return try MLTransformNotReadyException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMLLabelingSetGenerationTaskRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentRunsExceededException": return try ConcurrentRunsExceededException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartTriggerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentRunsExceededException": return try ConcurrentRunsExceededException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartWorkflowRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentRunsExceededException": return try ConcurrentRunsExceededException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopColumnStatisticsTaskRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ColumnStatisticsTaskNotRunningException": return try ColumnStatisticsTaskNotRunningException.makeError(baseError: baseError)
            case "ColumnStatisticsTaskStoppingException": return try ColumnStatisticsTaskStoppingException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopColumnStatisticsTaskRunScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopCrawlerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CrawlerNotRunningException": return try CrawlerNotRunningException.makeError(baseError: baseError)
            case "CrawlerStoppingException": return try CrawlerStoppingException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopCrawlerScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "SchedulerNotRunningException": return try SchedulerNotRunningException.makeError(baseError: baseError)
            case "SchedulerTransitioningException": return try SchedulerTransitioningException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "IllegalSessionStateException": return try IllegalSessionStateException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopTriggerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopWorkflowRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "IllegalWorkflowStateException": return try IllegalWorkflowStateException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "FederationSourceException": return try FederationSourceException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBlueprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "IllegalBlueprintStateException": return try IllegalBlueprintStateException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateClassifierOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "VersionMismatchException": return try VersionMismatchException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateColumnStatisticsForPartitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateColumnStatisticsForTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateColumnStatisticsTaskSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "VersionMismatchException": return try VersionMismatchException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCrawlerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CrawlerRunningException": return try CrawlerRunningException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "VersionMismatchException": return try VersionMismatchException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCrawlerScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "SchedulerTransitioningException": return try SchedulerTransitioningException.makeError(baseError: baseError)
            case "VersionMismatchException": return try VersionMismatchException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDatabaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataQualityRulesetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDevEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateJobFromSourceControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMLTransformOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePartitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRegistryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSourceControlFromJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTableOptimizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTriggerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUsageProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserDefinedFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GlueEncryptionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> GlueEncryptionException {
        let reader = baseError.errorBodyReader
        var value = GlueEncryptionException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServiceException {
        let reader = baseError.errorBodyReader
        var value = InternalServiceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = AlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntityNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EntityNotFoundException {
        let reader = baseError.errorBodyReader
        var value = EntityNotFoundException()
        value.properties.fromFederationSource = try reader["FromFederationSource"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInputException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInputException {
        let reader = baseError.errorBodyReader
        var value = InvalidInputException()
        value.properties.fromFederationSource = try reader["FromFederationSource"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperationTimeoutException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OperationTimeoutException {
        let reader = baseError.errorBodyReader
        var value = OperationTimeoutException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNumberLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNumberLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourceNumberLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotReadyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotReadyException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotReadyException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidStateException {
        let reader = baseError.errorBodyReader
        var value = InvalidStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FederationSourceRetryableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FederationSourceRetryableException {
        let reader = baseError.errorBodyReader
        var value = FederationSourceRetryableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FederationSourceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FederationSourceException {
        let reader = baseError.errorBodyReader
        var value = FederationSourceException()
        value.properties.federationSourceErrorCode = try reader["FederationSourceErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IllegalSessionStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IllegalSessionStateException {
        let reader = baseError.errorBodyReader
        var value = IllegalSessionStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ColumnStatisticsTaskRunningException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ColumnStatisticsTaskRunningException {
        let reader = baseError.errorBodyReader
        var value = ColumnStatisticsTaskRunningException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IdempotentParameterMismatchException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IdempotentParameterMismatchException {
        let reader = baseError.errorBodyReader
        var value = IdempotentParameterMismatchException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FederatedResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FederatedResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = FederatedResourceAlreadyExistsException()
        value.properties.associatedGlueResource = try reader["AssociatedGlueResource"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperationNotSupportedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OperationNotSupportedException {
        let reader = baseError.errorBodyReader
        var value = OperationNotSupportedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SchedulerTransitioningException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SchedulerTransitioningException {
        let reader = baseError.errorBodyReader
        var value = SchedulerTransitioningException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CrawlerRunningException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CrawlerRunningException {
        let reader = baseError.errorBodyReader
        var value = CrawlerRunningException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConditionCheckFailureException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConditionCheckFailureException {
        let reader = baseError.errorBodyReader
        var value = ConditionCheckFailureException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PermissionTypeMismatchException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> PermissionTypeMismatchException {
        let reader = baseError.errorBodyReader
        var value = PermissionTypeMismatchException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IllegalWorkflowStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IllegalWorkflowStateException {
        let reader = baseError.errorBodyReader
        var value = IllegalWorkflowStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentRunsExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConcurrentRunsExceededException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentRunsExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IllegalBlueprintStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IllegalBlueprintStateException {
        let reader = baseError.errorBodyReader
        var value = IllegalBlueprintStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoScheduleException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoScheduleException {
        let reader = baseError.errorBodyReader
        var value = NoScheduleException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SchedulerRunningException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SchedulerRunningException {
        let reader = baseError.errorBodyReader
        var value = SchedulerRunningException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MLTransformNotReadyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MLTransformNotReadyException {
        let reader = baseError.errorBodyReader
        var value = MLTransformNotReadyException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ColumnStatisticsTaskStoppingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ColumnStatisticsTaskStoppingException {
        let reader = baseError.errorBodyReader
        var value = ColumnStatisticsTaskStoppingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ColumnStatisticsTaskNotRunningException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ColumnStatisticsTaskNotRunningException {
        let reader = baseError.errorBodyReader
        var value = ColumnStatisticsTaskNotRunningException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CrawlerNotRunningException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CrawlerNotRunningException {
        let reader = baseError.errorBodyReader
        var value = CrawlerNotRunningException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CrawlerStoppingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CrawlerStoppingException {
        let reader = baseError.errorBodyReader
        var value = CrawlerStoppingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SchedulerNotRunningException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SchedulerNotRunningException {
        let reader = baseError.errorBodyReader
        var value = SchedulerNotRunningException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension VersionMismatchException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> VersionMismatchException {
        let reader = baseError.errorBodyReader
        var value = VersionMismatchException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GlueClientTypes.PartitionError {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.PartitionError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.PartitionError()
        value.partitionValues = try reader["PartitionValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorDetail = try reader["ErrorDetail"].readIfPresent(with: GlueClientTypes.ErrorDetail.read(from:))
        return value
    }
}

extension GlueClientTypes.ErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ErrorDetail()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.TableError {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TableError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TableError()
        value.tableName = try reader["TableName"].readIfPresent()
        value.errorDetail = try reader["ErrorDetail"].readIfPresent(with: GlueClientTypes.ErrorDetail.read(from:))
        return value
    }
}

extension GlueClientTypes.TableVersionError {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TableVersionError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TableVersionError()
        value.tableName = try reader["TableName"].readIfPresent()
        value.versionId = try reader["VersionId"].readIfPresent()
        value.errorDetail = try reader["ErrorDetail"].readIfPresent(with: GlueClientTypes.ErrorDetail.read(from:))
        return value
    }
}

extension GlueClientTypes.Blueprint {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Blueprint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Blueprint()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdOn = try reader["CreatedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.parameterSpec = try reader["ParameterSpec"].readIfPresent()
        value.blueprintLocation = try reader["BlueprintLocation"].readIfPresent()
        value.blueprintServiceLocation = try reader["BlueprintServiceLocation"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.lastActiveDefinition = try reader["LastActiveDefinition"].readIfPresent(with: GlueClientTypes.LastActiveDefinition.read(from:))
        return value
    }
}

extension GlueClientTypes.LastActiveDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.LastActiveDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.LastActiveDefinition()
        value.description = try reader["Description"].readIfPresent()
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.parameterSpec = try reader["ParameterSpec"].readIfPresent()
        value.blueprintLocation = try reader["BlueprintLocation"].readIfPresent()
        value.blueprintServiceLocation = try reader["BlueprintServiceLocation"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.Crawler {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Crawler {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Crawler()
        value.name = try reader["Name"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.targets = try reader["Targets"].readIfPresent(with: GlueClientTypes.CrawlerTargets.read(from:))
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.classifiers = try reader["Classifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.recrawlPolicy = try reader["RecrawlPolicy"].readIfPresent(with: GlueClientTypes.RecrawlPolicy.read(from:))
        value.schemaChangePolicy = try reader["SchemaChangePolicy"].readIfPresent(with: GlueClientTypes.SchemaChangePolicy.read(from:))
        value.lineageConfiguration = try reader["LineageConfiguration"].readIfPresent(with: GlueClientTypes.LineageConfiguration.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.tablePrefix = try reader["TablePrefix"].readIfPresent()
        value.schedule = try reader["Schedule"].readIfPresent(with: GlueClientTypes.Schedule.read(from:))
        value.crawlElapsedTime = try reader["CrawlElapsedTime"].readIfPresent() ?? 0
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastCrawl = try reader["LastCrawl"].readIfPresent(with: GlueClientTypes.LastCrawlInfo.read(from:))
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.configuration = try reader["Configuration"].readIfPresent()
        value.crawlerSecurityConfiguration = try reader["CrawlerSecurityConfiguration"].readIfPresent()
        value.lakeFormationConfiguration = try reader["LakeFormationConfiguration"].readIfPresent(with: GlueClientTypes.LakeFormationConfiguration.read(from:))
        return value
    }
}

extension GlueClientTypes.LakeFormationConfiguration {

    static func write(value: GlueClientTypes.LakeFormationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["UseLakeFormationCredentials"].write(value.useLakeFormationCredentials)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.LakeFormationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.LakeFormationConfiguration()
        value.useLakeFormationCredentials = try reader["UseLakeFormationCredentials"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.LastCrawlInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.LastCrawlInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.LastCrawlInfo()
        value.status = try reader["Status"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.logGroup = try reader["LogGroup"].readIfPresent()
        value.logStream = try reader["LogStream"].readIfPresent()
        value.messagePrefix = try reader["MessagePrefix"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GlueClientTypes.Schedule {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Schedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Schedule()
        value.scheduleExpression = try reader["ScheduleExpression"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.LineageConfiguration {

    static func write(value: GlueClientTypes.LineageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrawlerLineageSettings"].write(value.crawlerLineageSettings)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.LineageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.LineageConfiguration()
        value.crawlerLineageSettings = try reader["CrawlerLineageSettings"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.SchemaChangePolicy {

    static func write(value: GlueClientTypes.SchemaChangePolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteBehavior"].write(value.deleteBehavior)
        try writer["UpdateBehavior"].write(value.updateBehavior)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SchemaChangePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SchemaChangePolicy()
        value.updateBehavior = try reader["UpdateBehavior"].readIfPresent()
        value.deleteBehavior = try reader["DeleteBehavior"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.RecrawlPolicy {

    static func write(value: GlueClientTypes.RecrawlPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecrawlBehavior"].write(value.recrawlBehavior)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.RecrawlPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.RecrawlPolicy()
        value.recrawlBehavior = try reader["RecrawlBehavior"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.CrawlerTargets {

    static func write(value: GlueClientTypes.CrawlerTargets?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogTargets"].writeList(value.catalogTargets, memberWritingClosure: GlueClientTypes.CatalogTarget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeltaTargets"].writeList(value.deltaTargets, memberWritingClosure: GlueClientTypes.DeltaTarget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DynamoDBTargets"].writeList(value.dynamoDBTargets, memberWritingClosure: GlueClientTypes.DynamoDBTarget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HudiTargets"].writeList(value.hudiTargets, memberWritingClosure: GlueClientTypes.HudiTarget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IcebergTargets"].writeList(value.icebergTargets, memberWritingClosure: GlueClientTypes.IcebergTarget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["JdbcTargets"].writeList(value.jdbcTargets, memberWritingClosure: GlueClientTypes.JdbcTarget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MongoDBTargets"].writeList(value.mongoDBTargets, memberWritingClosure: GlueClientTypes.MongoDBTarget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["S3Targets"].writeList(value.s3Targets, memberWritingClosure: GlueClientTypes.S3Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CrawlerTargets {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CrawlerTargets()
        value.s3Targets = try reader["S3Targets"].readListIfPresent(memberReadingClosure: GlueClientTypes.S3Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.jdbcTargets = try reader["JdbcTargets"].readListIfPresent(memberReadingClosure: GlueClientTypes.JdbcTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mongoDBTargets = try reader["MongoDBTargets"].readListIfPresent(memberReadingClosure: GlueClientTypes.MongoDBTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dynamoDBTargets = try reader["DynamoDBTargets"].readListIfPresent(memberReadingClosure: GlueClientTypes.DynamoDBTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.catalogTargets = try reader["CatalogTargets"].readListIfPresent(memberReadingClosure: GlueClientTypes.CatalogTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.deltaTargets = try reader["DeltaTargets"].readListIfPresent(memberReadingClosure: GlueClientTypes.DeltaTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.icebergTargets = try reader["IcebergTargets"].readListIfPresent(memberReadingClosure: GlueClientTypes.IcebergTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.hudiTargets = try reader["HudiTargets"].readListIfPresent(memberReadingClosure: GlueClientTypes.HudiTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.HudiTarget {

    static func write(value: GlueClientTypes.HudiTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionName"].write(value.connectionName)
        try writer["Exclusions"].writeList(value.exclusions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaximumTraversalDepth"].write(value.maximumTraversalDepth)
        try writer["Paths"].writeList(value.paths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.HudiTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.HudiTarget()
        value.paths = try reader["Paths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionName = try reader["ConnectionName"].readIfPresent()
        value.exclusions = try reader["Exclusions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.maximumTraversalDepth = try reader["MaximumTraversalDepth"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.IcebergTarget {

    static func write(value: GlueClientTypes.IcebergTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionName"].write(value.connectionName)
        try writer["Exclusions"].writeList(value.exclusions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaximumTraversalDepth"].write(value.maximumTraversalDepth)
        try writer["Paths"].writeList(value.paths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.IcebergTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.IcebergTarget()
        value.paths = try reader["Paths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionName = try reader["ConnectionName"].readIfPresent()
        value.exclusions = try reader["Exclusions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.maximumTraversalDepth = try reader["MaximumTraversalDepth"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.DeltaTarget {

    static func write(value: GlueClientTypes.DeltaTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionName"].write(value.connectionName)
        try writer["CreateNativeDeltaTable"].write(value.createNativeDeltaTable)
        try writer["DeltaTables"].writeList(value.deltaTables, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WriteManifest"].write(value.writeManifest)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DeltaTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DeltaTarget()
        value.deltaTables = try reader["DeltaTables"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionName = try reader["ConnectionName"].readIfPresent()
        value.writeManifest = try reader["WriteManifest"].readIfPresent()
        value.createNativeDeltaTable = try reader["CreateNativeDeltaTable"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.CatalogTarget {

    static func write(value: GlueClientTypes.CatalogTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionName"].write(value.connectionName)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["DlqEventQueueArn"].write(value.dlqEventQueueArn)
        try writer["EventQueueArn"].write(value.eventQueueArn)
        try writer["Tables"].writeList(value.tables, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CatalogTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CatalogTarget()
        value.databaseName = try reader["DatabaseName"].readIfPresent() ?? ""
        value.tables = try reader["Tables"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.connectionName = try reader["ConnectionName"].readIfPresent()
        value.eventQueueArn = try reader["EventQueueArn"].readIfPresent()
        value.dlqEventQueueArn = try reader["DlqEventQueueArn"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.DynamoDBTarget {

    static func write(value: GlueClientTypes.DynamoDBTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Path"].write(value.path)
        try writer["scanAll"].write(value.scanAll)
        try writer["scanRate"].write(value.scanRate)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DynamoDBTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DynamoDBTarget()
        value.path = try reader["Path"].readIfPresent()
        value.scanAll = try reader["scanAll"].readIfPresent()
        value.scanRate = try reader["scanRate"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.MongoDBTarget {

    static func write(value: GlueClientTypes.MongoDBTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionName"].write(value.connectionName)
        try writer["Path"].write(value.path)
        try writer["ScanAll"].write(value.scanAll)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.MongoDBTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.MongoDBTarget()
        value.connectionName = try reader["ConnectionName"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.scanAll = try reader["ScanAll"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.JdbcTarget {

    static func write(value: GlueClientTypes.JdbcTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionName"].write(value.connectionName)
        try writer["EnableAdditionalMetadata"].writeList(value.enableAdditionalMetadata, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GlueClientTypes.JdbcMetadataEntry>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Exclusions"].writeList(value.exclusions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Path"].write(value.path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.JdbcTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.JdbcTarget()
        value.connectionName = try reader["ConnectionName"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.exclusions = try reader["Exclusions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.enableAdditionalMetadata = try reader["EnableAdditionalMetadata"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GlueClientTypes.JdbcMetadataEntry>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.S3Target {

    static func write(value: GlueClientTypes.S3Target?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionName"].write(value.connectionName)
        try writer["DlqEventQueueArn"].write(value.dlqEventQueueArn)
        try writer["EventQueueArn"].write(value.eventQueueArn)
        try writer["Exclusions"].writeList(value.exclusions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Path"].write(value.path)
        try writer["SampleSize"].write(value.sampleSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3Target {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3Target()
        value.path = try reader["Path"].readIfPresent()
        value.exclusions = try reader["Exclusions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionName = try reader["ConnectionName"].readIfPresent()
        value.sampleSize = try reader["SampleSize"].readIfPresent()
        value.eventQueueArn = try reader["EventQueueArn"].readIfPresent()
        value.dlqEventQueueArn = try reader["DlqEventQueueArn"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.CustomEntityType {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CustomEntityType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CustomEntityType()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.regexString = try reader["RegexString"].readIfPresent() ?? ""
        value.contextWords = try reader["ContextWords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.DataQualityResult {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DataQualityResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DataQualityResult()
        value.resultId = try reader["ResultId"].readIfPresent()
        value.profileId = try reader["ProfileId"].readIfPresent()
        value.score = try reader["Score"].readIfPresent()
        value.dataSource = try reader["DataSource"].readIfPresent(with: GlueClientTypes.DataSource.read(from:))
        value.rulesetName = try reader["RulesetName"].readIfPresent()
        value.evaluationContext = try reader["EvaluationContext"].readIfPresent()
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completedOn = try reader["CompletedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobRunId = try reader["JobRunId"].readIfPresent()
        value.rulesetEvaluationRunId = try reader["RulesetEvaluationRunId"].readIfPresent()
        value.ruleResults = try reader["RuleResults"].readListIfPresent(memberReadingClosure: GlueClientTypes.DataQualityRuleResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.analyzerResults = try reader["AnalyzerResults"].readListIfPresent(memberReadingClosure: GlueClientTypes.DataQualityAnalyzerResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.observations = try reader["Observations"].readListIfPresent(memberReadingClosure: GlueClientTypes.DataQualityObservation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.DataQualityObservation {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DataQualityObservation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DataQualityObservation()
        value.description = try reader["Description"].readIfPresent()
        value.metricBasedObservation = try reader["MetricBasedObservation"].readIfPresent(with: GlueClientTypes.MetricBasedObservation.read(from:))
        return value
    }
}

extension GlueClientTypes.MetricBasedObservation {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.MetricBasedObservation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.MetricBasedObservation()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.statisticId = try reader["StatisticId"].readIfPresent()
        value.metricValues = try reader["MetricValues"].readIfPresent(with: GlueClientTypes.DataQualityMetricValues.read(from:))
        value.newRules = try reader["NewRules"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.DataQualityMetricValues {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DataQualityMetricValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DataQualityMetricValues()
        value.actualValue = try reader["ActualValue"].readIfPresent()
        value.expectedValue = try reader["ExpectedValue"].readIfPresent()
        value.lowerLimit = try reader["LowerLimit"].readIfPresent()
        value.upperLimit = try reader["UpperLimit"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.DataQualityAnalyzerResult {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DataQualityAnalyzerResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DataQualityAnalyzerResult()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.evaluationMessage = try reader["EvaluationMessage"].readIfPresent()
        value.evaluatedMetrics = try reader["EvaluatedMetrics"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.DataQualityRuleResult {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DataQualityRuleResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DataQualityRuleResult()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.evaluationMessage = try reader["EvaluationMessage"].readIfPresent()
        value.result = try reader["Result"].readIfPresent()
        value.evaluatedMetrics = try reader["EvaluatedMetrics"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.evaluatedRule = try reader["EvaluatedRule"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.DataSource {

    static func write(value: GlueClientTypes.DataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GlueTable"].write(value.glueTable, with: GlueClientTypes.GlueTable.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DataSource()
        value.glueTable = try reader["GlueTable"].readIfPresent(with: GlueClientTypes.GlueTable.read(from:))
        return value
    }
}

extension GlueClientTypes.GlueTable {

    static func write(value: GlueClientTypes.GlueTable?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOptions"].writeMap(value.additionalOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["CatalogId"].write(value.catalogId)
        try writer["ConnectionName"].write(value.connectionName)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.GlueTable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.GlueTable()
        value.databaseName = try reader["DatabaseName"].readIfPresent() ?? ""
        value.tableName = try reader["TableName"].readIfPresent() ?? ""
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.connectionName = try reader["ConnectionName"].readIfPresent()
        value.additionalOptions = try reader["AdditionalOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.DevEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DevEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DevEndpoint()
        value.endpointName = try reader["EndpointName"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetId = try reader["SubnetId"].readIfPresent()
        value.yarnEndpointAddress = try reader["YarnEndpointAddress"].readIfPresent()
        value.privateAddress = try reader["PrivateAddress"].readIfPresent()
        value.zeppelinRemoteSparkInterpreterPort = try reader["ZeppelinRemoteSparkInterpreterPort"].readIfPresent() ?? 0
        value.publicAddress = try reader["PublicAddress"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.workerType = try reader["WorkerType"].readIfPresent()
        value.glueVersion = try reader["GlueVersion"].readIfPresent()
        value.numberOfWorkers = try reader["NumberOfWorkers"].readIfPresent()
        value.numberOfNodes = try reader["NumberOfNodes"].readIfPresent() ?? 0
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.extraPythonLibsS3Path = try reader["ExtraPythonLibsS3Path"].readIfPresent()
        value.extraJarsS3Path = try reader["ExtraJarsS3Path"].readIfPresent()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.lastUpdateStatus = try reader["LastUpdateStatus"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTimestamp = try reader["LastModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.publicKey = try reader["PublicKey"].readIfPresent()
        value.publicKeys = try reader["PublicKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityConfiguration = try reader["SecurityConfiguration"].readIfPresent()
        value.arguments = try reader["Arguments"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.Job {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Job {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Job()
        value.name = try reader["Name"].readIfPresent()
        value.jobMode = try reader["JobMode"].readIfPresent()
        value.jobRunQueuingEnabled = try reader["JobRunQueuingEnabled"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.logUri = try reader["LogUri"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.createdOn = try reader["CreatedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.executionProperty = try reader["ExecutionProperty"].readIfPresent(with: GlueClientTypes.ExecutionProperty.read(from:))
        value.command = try reader["Command"].readIfPresent(with: GlueClientTypes.JobCommand.read(from:))
        value.defaultArguments = try reader["DefaultArguments"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.nonOverridableArguments = try reader["NonOverridableArguments"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.connections = try reader["Connections"].readIfPresent(with: GlueClientTypes.ConnectionsList.read(from:))
        value.maxRetries = try reader["MaxRetries"].readIfPresent() ?? 0
        value.allocatedCapacity = try reader["AllocatedCapacity"].readIfPresent() ?? 0
        value.timeout = try reader["Timeout"].readIfPresent()
        value.maxCapacity = try reader["MaxCapacity"].readIfPresent()
        value.workerType = try reader["WorkerType"].readIfPresent()
        value.numberOfWorkers = try reader["NumberOfWorkers"].readIfPresent()
        value.securityConfiguration = try reader["SecurityConfiguration"].readIfPresent()
        value.notificationProperty = try reader["NotificationProperty"].readIfPresent(with: GlueClientTypes.NotificationProperty.read(from:))
        value.glueVersion = try reader["GlueVersion"].readIfPresent()
        value.codeGenConfigurationNodes = try reader["CodeGenConfigurationNodes"].readMapIfPresent(valueReadingClosure: GlueClientTypes.CodeGenConfigurationNode.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.executionClass = try reader["ExecutionClass"].readIfPresent()
        value.sourceControlDetails = try reader["SourceControlDetails"].readIfPresent(with: GlueClientTypes.SourceControlDetails.read(from:))
        value.maintenanceWindow = try reader["MaintenanceWindow"].readIfPresent()
        value.profileName = try reader["ProfileName"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.SourceControlDetails {

    static func write(value: GlueClientTypes.SourceControlDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthStrategy"].write(value.authStrategy)
        try writer["AuthToken"].write(value.authToken)
        try writer["Branch"].write(value.branch)
        try writer["Folder"].write(value.folder)
        try writer["LastCommitId"].write(value.lastCommitId)
        try writer["Owner"].write(value.owner)
        try writer["Provider"].write(value.provider)
        try writer["Repository"].write(value.repository)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SourceControlDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SourceControlDetails()
        value.provider = try reader["Provider"].readIfPresent()
        value.repository = try reader["Repository"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.branch = try reader["Branch"].readIfPresent()
        value.folder = try reader["Folder"].readIfPresent()
        value.lastCommitId = try reader["LastCommitId"].readIfPresent()
        value.authStrategy = try reader["AuthStrategy"].readIfPresent()
        value.authToken = try reader["AuthToken"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.CodeGenConfigurationNode {

    static func write(value: GlueClientTypes.CodeGenConfigurationNode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregate"].write(value.aggregate, with: GlueClientTypes.Aggregate.write(value:to:))
        try writer["AmazonRedshiftSource"].write(value.amazonRedshiftSource, with: GlueClientTypes.AmazonRedshiftSource.write(value:to:))
        try writer["AmazonRedshiftTarget"].write(value.amazonRedshiftTarget, with: GlueClientTypes.AmazonRedshiftTarget.write(value:to:))
        try writer["ApplyMapping"].write(value.applyMapping, with: GlueClientTypes.ApplyMapping.write(value:to:))
        try writer["AthenaConnectorSource"].write(value.athenaConnectorSource, with: GlueClientTypes.AthenaConnectorSource.write(value:to:))
        try writer["CatalogDeltaSource"].write(value.catalogDeltaSource, with: GlueClientTypes.CatalogDeltaSource.write(value:to:))
        try writer["CatalogHudiSource"].write(value.catalogHudiSource, with: GlueClientTypes.CatalogHudiSource.write(value:to:))
        try writer["CatalogKafkaSource"].write(value.catalogKafkaSource, with: GlueClientTypes.CatalogKafkaSource.write(value:to:))
        try writer["CatalogKinesisSource"].write(value.catalogKinesisSource, with: GlueClientTypes.CatalogKinesisSource.write(value:to:))
        try writer["CatalogSource"].write(value.catalogSource, with: GlueClientTypes.CatalogSource.write(value:to:))
        try writer["CatalogTarget"].write(value.catalogTarget, with: GlueClientTypes.BasicCatalogTarget.write(value:to:))
        try writer["ConnectorDataSource"].write(value.connectorDataSource, with: GlueClientTypes.ConnectorDataSource.write(value:to:))
        try writer["ConnectorDataTarget"].write(value.connectorDataTarget, with: GlueClientTypes.ConnectorDataTarget.write(value:to:))
        try writer["CustomCode"].write(value.customCode, with: GlueClientTypes.CustomCode.write(value:to:))
        try writer["DirectJDBCSource"].write(value.directJDBCSource, with: GlueClientTypes.DirectJDBCSource.write(value:to:))
        try writer["DirectKafkaSource"].write(value.directKafkaSource, with: GlueClientTypes.DirectKafkaSource.write(value:to:))
        try writer["DirectKinesisSource"].write(value.directKinesisSource, with: GlueClientTypes.DirectKinesisSource.write(value:to:))
        try writer["DropDuplicates"].write(value.dropDuplicates, with: GlueClientTypes.DropDuplicates.write(value:to:))
        try writer["DropFields"].write(value.dropFields, with: GlueClientTypes.DropFields.write(value:to:))
        try writer["DropNullFields"].write(value.dropNullFields, with: GlueClientTypes.DropNullFields.write(value:to:))
        try writer["DynamicTransform"].write(value.dynamicTransform, with: GlueClientTypes.DynamicTransform.write(value:to:))
        try writer["DynamoDBCatalogSource"].write(value.dynamoDBCatalogSource, with: GlueClientTypes.DynamoDBCatalogSource.write(value:to:))
        try writer["EvaluateDataQuality"].write(value.evaluateDataQuality, with: GlueClientTypes.EvaluateDataQuality.write(value:to:))
        try writer["EvaluateDataQualityMultiFrame"].write(value.evaluateDataQualityMultiFrame, with: GlueClientTypes.EvaluateDataQualityMultiFrame.write(value:to:))
        try writer["FillMissingValues"].write(value.fillMissingValues, with: GlueClientTypes.FillMissingValues.write(value:to:))
        try writer["Filter"].write(value.filter, with: GlueClientTypes.Filter.write(value:to:))
        try writer["GovernedCatalogSource"].write(value.governedCatalogSource, with: GlueClientTypes.GovernedCatalogSource.write(value:to:))
        try writer["GovernedCatalogTarget"].write(value.governedCatalogTarget, with: GlueClientTypes.GovernedCatalogTarget.write(value:to:))
        try writer["JDBCConnectorSource"].write(value.jdbcConnectorSource, with: GlueClientTypes.JDBCConnectorSource.write(value:to:))
        try writer["JDBCConnectorTarget"].write(value.jdbcConnectorTarget, with: GlueClientTypes.JDBCConnectorTarget.write(value:to:))
        try writer["Join"].write(value.join, with: GlueClientTypes.Join.write(value:to:))
        try writer["Merge"].write(value.merge, with: GlueClientTypes.Merge.write(value:to:))
        try writer["MicrosoftSQLServerCatalogSource"].write(value.microsoftSQLServerCatalogSource, with: GlueClientTypes.MicrosoftSQLServerCatalogSource.write(value:to:))
        try writer["MicrosoftSQLServerCatalogTarget"].write(value.microsoftSQLServerCatalogTarget, with: GlueClientTypes.MicrosoftSQLServerCatalogTarget.write(value:to:))
        try writer["MySQLCatalogSource"].write(value.mySQLCatalogSource, with: GlueClientTypes.MySQLCatalogSource.write(value:to:))
        try writer["MySQLCatalogTarget"].write(value.mySQLCatalogTarget, with: GlueClientTypes.MySQLCatalogTarget.write(value:to:))
        try writer["OracleSQLCatalogSource"].write(value.oracleSQLCatalogSource, with: GlueClientTypes.OracleSQLCatalogSource.write(value:to:))
        try writer["OracleSQLCatalogTarget"].write(value.oracleSQLCatalogTarget, with: GlueClientTypes.OracleSQLCatalogTarget.write(value:to:))
        try writer["PIIDetection"].write(value.piiDetection, with: GlueClientTypes.PIIDetection.write(value:to:))
        try writer["PostgreSQLCatalogSource"].write(value.postgreSQLCatalogSource, with: GlueClientTypes.PostgreSQLCatalogSource.write(value:to:))
        try writer["PostgreSQLCatalogTarget"].write(value.postgreSQLCatalogTarget, with: GlueClientTypes.PostgreSQLCatalogTarget.write(value:to:))
        try writer["Recipe"].write(value.recipe, with: GlueClientTypes.Recipe.write(value:to:))
        try writer["RedshiftSource"].write(value.redshiftSource, with: GlueClientTypes.RedshiftSource.write(value:to:))
        try writer["RedshiftTarget"].write(value.redshiftTarget, with: GlueClientTypes.RedshiftTarget.write(value:to:))
        try writer["RelationalCatalogSource"].write(value.relationalCatalogSource, with: GlueClientTypes.RelationalCatalogSource.write(value:to:))
        try writer["RenameField"].write(value.renameField, with: GlueClientTypes.RenameField.write(value:to:))
        try writer["S3CatalogDeltaSource"].write(value.s3CatalogDeltaSource, with: GlueClientTypes.S3CatalogDeltaSource.write(value:to:))
        try writer["S3CatalogHudiSource"].write(value.s3CatalogHudiSource, with: GlueClientTypes.S3CatalogHudiSource.write(value:to:))
        try writer["S3CatalogSource"].write(value.s3CatalogSource, with: GlueClientTypes.S3CatalogSource.write(value:to:))
        try writer["S3CatalogTarget"].write(value.s3CatalogTarget, with: GlueClientTypes.S3CatalogTarget.write(value:to:))
        try writer["S3CsvSource"].write(value.s3CsvSource, with: GlueClientTypes.S3CsvSource.write(value:to:))
        try writer["S3DeltaCatalogTarget"].write(value.s3DeltaCatalogTarget, with: GlueClientTypes.S3DeltaCatalogTarget.write(value:to:))
        try writer["S3DeltaDirectTarget"].write(value.s3DeltaDirectTarget, with: GlueClientTypes.S3DeltaDirectTarget.write(value:to:))
        try writer["S3DeltaSource"].write(value.s3DeltaSource, with: GlueClientTypes.S3DeltaSource.write(value:to:))
        try writer["S3DirectTarget"].write(value.s3DirectTarget, with: GlueClientTypes.S3DirectTarget.write(value:to:))
        try writer["S3GlueParquetTarget"].write(value.s3GlueParquetTarget, with: GlueClientTypes.S3GlueParquetTarget.write(value:to:))
        try writer["S3HudiCatalogTarget"].write(value.s3HudiCatalogTarget, with: GlueClientTypes.S3HudiCatalogTarget.write(value:to:))
        try writer["S3HudiDirectTarget"].write(value.s3HudiDirectTarget, with: GlueClientTypes.S3HudiDirectTarget.write(value:to:))
        try writer["S3HudiSource"].write(value.s3HudiSource, with: GlueClientTypes.S3HudiSource.write(value:to:))
        try writer["S3JsonSource"].write(value.s3JsonSource, with: GlueClientTypes.S3JsonSource.write(value:to:))
        try writer["S3ParquetSource"].write(value.s3ParquetSource, with: GlueClientTypes.S3ParquetSource.write(value:to:))
        try writer["SelectFields"].write(value.selectFields, with: GlueClientTypes.SelectFields.write(value:to:))
        try writer["SelectFromCollection"].write(value.selectFromCollection, with: GlueClientTypes.SelectFromCollection.write(value:to:))
        try writer["SnowflakeSource"].write(value.snowflakeSource, with: GlueClientTypes.SnowflakeSource.write(value:to:))
        try writer["SnowflakeTarget"].write(value.snowflakeTarget, with: GlueClientTypes.SnowflakeTarget.write(value:to:))
        try writer["SparkConnectorSource"].write(value.sparkConnectorSource, with: GlueClientTypes.SparkConnectorSource.write(value:to:))
        try writer["SparkConnectorTarget"].write(value.sparkConnectorTarget, with: GlueClientTypes.SparkConnectorTarget.write(value:to:))
        try writer["SparkSQL"].write(value.sparkSQL, with: GlueClientTypes.SparkSQL.write(value:to:))
        try writer["Spigot"].write(value.spigot, with: GlueClientTypes.Spigot.write(value:to:))
        try writer["SplitFields"].write(value.splitFields, with: GlueClientTypes.SplitFields.write(value:to:))
        try writer["Union"].write(value.union, with: GlueClientTypes.Union.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CodeGenConfigurationNode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CodeGenConfigurationNode()
        value.athenaConnectorSource = try reader["AthenaConnectorSource"].readIfPresent(with: GlueClientTypes.AthenaConnectorSource.read(from:))
        value.jdbcConnectorSource = try reader["JDBCConnectorSource"].readIfPresent(with: GlueClientTypes.JDBCConnectorSource.read(from:))
        value.sparkConnectorSource = try reader["SparkConnectorSource"].readIfPresent(with: GlueClientTypes.SparkConnectorSource.read(from:))
        value.catalogSource = try reader["CatalogSource"].readIfPresent(with: GlueClientTypes.CatalogSource.read(from:))
        value.redshiftSource = try reader["RedshiftSource"].readIfPresent(with: GlueClientTypes.RedshiftSource.read(from:))
        value.s3CatalogSource = try reader["S3CatalogSource"].readIfPresent(with: GlueClientTypes.S3CatalogSource.read(from:))
        value.s3CsvSource = try reader["S3CsvSource"].readIfPresent(with: GlueClientTypes.S3CsvSource.read(from:))
        value.s3JsonSource = try reader["S3JsonSource"].readIfPresent(with: GlueClientTypes.S3JsonSource.read(from:))
        value.s3ParquetSource = try reader["S3ParquetSource"].readIfPresent(with: GlueClientTypes.S3ParquetSource.read(from:))
        value.relationalCatalogSource = try reader["RelationalCatalogSource"].readIfPresent(with: GlueClientTypes.RelationalCatalogSource.read(from:))
        value.dynamoDBCatalogSource = try reader["DynamoDBCatalogSource"].readIfPresent(with: GlueClientTypes.DynamoDBCatalogSource.read(from:))
        value.jdbcConnectorTarget = try reader["JDBCConnectorTarget"].readIfPresent(with: GlueClientTypes.JDBCConnectorTarget.read(from:))
        value.sparkConnectorTarget = try reader["SparkConnectorTarget"].readIfPresent(with: GlueClientTypes.SparkConnectorTarget.read(from:))
        value.catalogTarget = try reader["CatalogTarget"].readIfPresent(with: GlueClientTypes.BasicCatalogTarget.read(from:))
        value.redshiftTarget = try reader["RedshiftTarget"].readIfPresent(with: GlueClientTypes.RedshiftTarget.read(from:))
        value.s3CatalogTarget = try reader["S3CatalogTarget"].readIfPresent(with: GlueClientTypes.S3CatalogTarget.read(from:))
        value.s3GlueParquetTarget = try reader["S3GlueParquetTarget"].readIfPresent(with: GlueClientTypes.S3GlueParquetTarget.read(from:))
        value.s3DirectTarget = try reader["S3DirectTarget"].readIfPresent(with: GlueClientTypes.S3DirectTarget.read(from:))
        value.applyMapping = try reader["ApplyMapping"].readIfPresent(with: GlueClientTypes.ApplyMapping.read(from:))
        value.selectFields = try reader["SelectFields"].readIfPresent(with: GlueClientTypes.SelectFields.read(from:))
        value.dropFields = try reader["DropFields"].readIfPresent(with: GlueClientTypes.DropFields.read(from:))
        value.renameField = try reader["RenameField"].readIfPresent(with: GlueClientTypes.RenameField.read(from:))
        value.spigot = try reader["Spigot"].readIfPresent(with: GlueClientTypes.Spigot.read(from:))
        value.join = try reader["Join"].readIfPresent(with: GlueClientTypes.Join.read(from:))
        value.splitFields = try reader["SplitFields"].readIfPresent(with: GlueClientTypes.SplitFields.read(from:))
        value.selectFromCollection = try reader["SelectFromCollection"].readIfPresent(with: GlueClientTypes.SelectFromCollection.read(from:))
        value.fillMissingValues = try reader["FillMissingValues"].readIfPresent(with: GlueClientTypes.FillMissingValues.read(from:))
        value.filter = try reader["Filter"].readIfPresent(with: GlueClientTypes.Filter.read(from:))
        value.customCode = try reader["CustomCode"].readIfPresent(with: GlueClientTypes.CustomCode.read(from:))
        value.sparkSQL = try reader["SparkSQL"].readIfPresent(with: GlueClientTypes.SparkSQL.read(from:))
        value.directKinesisSource = try reader["DirectKinesisSource"].readIfPresent(with: GlueClientTypes.DirectKinesisSource.read(from:))
        value.directKafkaSource = try reader["DirectKafkaSource"].readIfPresent(with: GlueClientTypes.DirectKafkaSource.read(from:))
        value.catalogKinesisSource = try reader["CatalogKinesisSource"].readIfPresent(with: GlueClientTypes.CatalogKinesisSource.read(from:))
        value.catalogKafkaSource = try reader["CatalogKafkaSource"].readIfPresent(with: GlueClientTypes.CatalogKafkaSource.read(from:))
        value.dropNullFields = try reader["DropNullFields"].readIfPresent(with: GlueClientTypes.DropNullFields.read(from:))
        value.merge = try reader["Merge"].readIfPresent(with: GlueClientTypes.Merge.read(from:))
        value.union = try reader["Union"].readIfPresent(with: GlueClientTypes.Union.read(from:))
        value.piiDetection = try reader["PIIDetection"].readIfPresent(with: GlueClientTypes.PIIDetection.read(from:))
        value.aggregate = try reader["Aggregate"].readIfPresent(with: GlueClientTypes.Aggregate.read(from:))
        value.dropDuplicates = try reader["DropDuplicates"].readIfPresent(with: GlueClientTypes.DropDuplicates.read(from:))
        value.governedCatalogTarget = try reader["GovernedCatalogTarget"].readIfPresent(with: GlueClientTypes.GovernedCatalogTarget.read(from:))
        value.governedCatalogSource = try reader["GovernedCatalogSource"].readIfPresent(with: GlueClientTypes.GovernedCatalogSource.read(from:))
        value.microsoftSQLServerCatalogSource = try reader["MicrosoftSQLServerCatalogSource"].readIfPresent(with: GlueClientTypes.MicrosoftSQLServerCatalogSource.read(from:))
        value.mySQLCatalogSource = try reader["MySQLCatalogSource"].readIfPresent(with: GlueClientTypes.MySQLCatalogSource.read(from:))
        value.oracleSQLCatalogSource = try reader["OracleSQLCatalogSource"].readIfPresent(with: GlueClientTypes.OracleSQLCatalogSource.read(from:))
        value.postgreSQLCatalogSource = try reader["PostgreSQLCatalogSource"].readIfPresent(with: GlueClientTypes.PostgreSQLCatalogSource.read(from:))
        value.microsoftSQLServerCatalogTarget = try reader["MicrosoftSQLServerCatalogTarget"].readIfPresent(with: GlueClientTypes.MicrosoftSQLServerCatalogTarget.read(from:))
        value.mySQLCatalogTarget = try reader["MySQLCatalogTarget"].readIfPresent(with: GlueClientTypes.MySQLCatalogTarget.read(from:))
        value.oracleSQLCatalogTarget = try reader["OracleSQLCatalogTarget"].readIfPresent(with: GlueClientTypes.OracleSQLCatalogTarget.read(from:))
        value.postgreSQLCatalogTarget = try reader["PostgreSQLCatalogTarget"].readIfPresent(with: GlueClientTypes.PostgreSQLCatalogTarget.read(from:))
        value.dynamicTransform = try reader["DynamicTransform"].readIfPresent(with: GlueClientTypes.DynamicTransform.read(from:))
        value.evaluateDataQuality = try reader["EvaluateDataQuality"].readIfPresent(with: GlueClientTypes.EvaluateDataQuality.read(from:))
        value.s3CatalogHudiSource = try reader["S3CatalogHudiSource"].readIfPresent(with: GlueClientTypes.S3CatalogHudiSource.read(from:))
        value.catalogHudiSource = try reader["CatalogHudiSource"].readIfPresent(with: GlueClientTypes.CatalogHudiSource.read(from:))
        value.s3HudiSource = try reader["S3HudiSource"].readIfPresent(with: GlueClientTypes.S3HudiSource.read(from:))
        value.s3HudiCatalogTarget = try reader["S3HudiCatalogTarget"].readIfPresent(with: GlueClientTypes.S3HudiCatalogTarget.read(from:))
        value.s3HudiDirectTarget = try reader["S3HudiDirectTarget"].readIfPresent(with: GlueClientTypes.S3HudiDirectTarget.read(from:))
        value.directJDBCSource = try reader["DirectJDBCSource"].readIfPresent(with: GlueClientTypes.DirectJDBCSource.read(from:))
        value.s3CatalogDeltaSource = try reader["S3CatalogDeltaSource"].readIfPresent(with: GlueClientTypes.S3CatalogDeltaSource.read(from:))
        value.catalogDeltaSource = try reader["CatalogDeltaSource"].readIfPresent(with: GlueClientTypes.CatalogDeltaSource.read(from:))
        value.s3DeltaSource = try reader["S3DeltaSource"].readIfPresent(with: GlueClientTypes.S3DeltaSource.read(from:))
        value.s3DeltaCatalogTarget = try reader["S3DeltaCatalogTarget"].readIfPresent(with: GlueClientTypes.S3DeltaCatalogTarget.read(from:))
        value.s3DeltaDirectTarget = try reader["S3DeltaDirectTarget"].readIfPresent(with: GlueClientTypes.S3DeltaDirectTarget.read(from:))
        value.amazonRedshiftSource = try reader["AmazonRedshiftSource"].readIfPresent(with: GlueClientTypes.AmazonRedshiftSource.read(from:))
        value.amazonRedshiftTarget = try reader["AmazonRedshiftTarget"].readIfPresent(with: GlueClientTypes.AmazonRedshiftTarget.read(from:))
        value.evaluateDataQualityMultiFrame = try reader["EvaluateDataQualityMultiFrame"].readIfPresent(with: GlueClientTypes.EvaluateDataQualityMultiFrame.read(from:))
        value.recipe = try reader["Recipe"].readIfPresent(with: GlueClientTypes.Recipe.read(from:))
        value.snowflakeSource = try reader["SnowflakeSource"].readIfPresent(with: GlueClientTypes.SnowflakeSource.read(from:))
        value.snowflakeTarget = try reader["SnowflakeTarget"].readIfPresent(with: GlueClientTypes.SnowflakeTarget.read(from:))
        value.connectorDataSource = try reader["ConnectorDataSource"].readIfPresent(with: GlueClientTypes.ConnectorDataSource.read(from:))
        value.connectorDataTarget = try reader["ConnectorDataTarget"].readIfPresent(with: GlueClientTypes.ConnectorDataTarget.read(from:))
        return value
    }
}

extension GlueClientTypes.ConnectorDataTarget {

    static func write(value: GlueClientTypes.ConnectorDataTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionType"].write(value.connectionType)
        try writer["Data"].writeMap(value.data, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ConnectorDataTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ConnectorDataTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.connectionType = try reader["ConnectionType"].readIfPresent() ?? ""
        value.data = try reader["Data"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.ConnectorDataSource {

    static func write(value: GlueClientTypes.ConnectorDataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionType"].write(value.connectionType)
        try writer["Data"].writeMap(value.data, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ConnectorDataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ConnectorDataSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.connectionType = try reader["ConnectionType"].readIfPresent() ?? ""
        value.data = try reader["Data"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.GlueSchema {

    static func write(value: GlueClientTypes.GlueSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Columns"].writeList(value.columns, memberWritingClosure: GlueClientTypes.GlueStudioSchemaColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.GlueSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.GlueSchema()
        value.columns = try reader["Columns"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueStudioSchemaColumn.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.GlueStudioSchemaColumn {

    static func write(value: GlueClientTypes.GlueStudioSchemaColumn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.GlueStudioSchemaColumn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.GlueStudioSchemaColumn()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.SnowflakeTarget {

    static func write(value: GlueClientTypes.SnowflakeTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Data"].write(value.data, with: GlueClientTypes.SnowflakeNodeData.write(value:to:))
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SnowflakeTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SnowflakeTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.data = try reader["Data"].readIfPresent(with: GlueClientTypes.SnowflakeNodeData.read(from:))
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.SnowflakeNodeData {

    static func write(value: GlueClientTypes.SnowflakeNodeData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["AdditionalOptions"].writeMap(value.additionalOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["AutoPushdown"].write(value.autoPushdown)
        try writer["Connection"].write(value.connection, with: GlueClientTypes.Option.write(value:to:))
        try writer["Database"].write(value.database)
        try writer["IamRole"].write(value.iamRole, with: GlueClientTypes.Option.write(value:to:))
        try writer["MergeAction"].write(value.mergeAction)
        try writer["MergeClause"].write(value.mergeClause)
        try writer["MergeWhenMatched"].write(value.mergeWhenMatched)
        try writer["MergeWhenNotMatched"].write(value.mergeWhenNotMatched)
        try writer["PostAction"].write(value.postAction)
        try writer["PreAction"].write(value.preAction)
        try writer["SampleQuery"].write(value.sampleQuery)
        try writer["Schema"].write(value.schema)
        try writer["SelectedColumns"].writeList(value.selectedColumns, memberWritingClosure: GlueClientTypes.Option.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceType"].write(value.sourceType)
        try writer["StagingTable"].write(value.stagingTable)
        try writer["Table"].write(value.table)
        try writer["TableSchema"].writeList(value.tableSchema, memberWritingClosure: GlueClientTypes.Option.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TempDir"].write(value.tempDir)
        try writer["Upsert"].write(value.upsert)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SnowflakeNodeData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SnowflakeNodeData()
        value.sourceType = try reader["SourceType"].readIfPresent()
        value.connection = try reader["Connection"].readIfPresent(with: GlueClientTypes.Option.read(from:))
        value.schema = try reader["Schema"].readIfPresent()
        value.table = try reader["Table"].readIfPresent()
        value.database = try reader["Database"].readIfPresent()
        value.tempDir = try reader["TempDir"].readIfPresent()
        value.iamRole = try reader["IamRole"].readIfPresent(with: GlueClientTypes.Option.read(from:))
        value.additionalOptions = try reader["AdditionalOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.sampleQuery = try reader["SampleQuery"].readIfPresent()
        value.preAction = try reader["PreAction"].readIfPresent()
        value.postAction = try reader["PostAction"].readIfPresent()
        value.action = try reader["Action"].readIfPresent()
        value.upsert = try reader["Upsert"].readIfPresent() ?? false
        value.mergeAction = try reader["MergeAction"].readIfPresent()
        value.mergeWhenMatched = try reader["MergeWhenMatched"].readIfPresent()
        value.mergeWhenNotMatched = try reader["MergeWhenNotMatched"].readIfPresent()
        value.mergeClause = try reader["MergeClause"].readIfPresent()
        value.stagingTable = try reader["StagingTable"].readIfPresent()
        value.selectedColumns = try reader["SelectedColumns"].readListIfPresent(memberReadingClosure: GlueClientTypes.Option.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.autoPushdown = try reader["AutoPushdown"].readIfPresent() ?? false
        value.tableSchema = try reader["TableSchema"].readListIfPresent(memberReadingClosure: GlueClientTypes.Option.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.Option {

    static func write(value: GlueClientTypes.Option?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Label"].write(value.label)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Option {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Option()
        value.value = try reader["Value"].readIfPresent()
        value.label = try reader["Label"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.SnowflakeSource {

    static func write(value: GlueClientTypes.SnowflakeSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Data"].write(value.data, with: GlueClientTypes.SnowflakeNodeData.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SnowflakeSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SnowflakeSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.data = try reader["Data"].readIfPresent(with: GlueClientTypes.SnowflakeNodeData.read(from:))
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.Recipe {

    static func write(value: GlueClientTypes.Recipe?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["RecipeReference"].write(value.recipeReference, with: GlueClientTypes.RecipeReference.write(value:to:))
        try writer["RecipeSteps"].writeList(value.recipeSteps, memberWritingClosure: GlueClientTypes.RecipeStep.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Recipe {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Recipe()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.recipeReference = try reader["RecipeReference"].readIfPresent(with: GlueClientTypes.RecipeReference.read(from:))
        value.recipeSteps = try reader["RecipeSteps"].readListIfPresent(memberReadingClosure: GlueClientTypes.RecipeStep.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.RecipeStep {

    static func write(value: GlueClientTypes.RecipeStep?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action, with: GlueClientTypes.RecipeAction.write(value:to:))
        try writer["ConditionExpressions"].writeList(value.conditionExpressions, memberWritingClosure: GlueClientTypes.ConditionExpression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.RecipeStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.RecipeStep()
        value.action = try reader["Action"].readIfPresent(with: GlueClientTypes.RecipeAction.read(from:))
        value.conditionExpressions = try reader["ConditionExpressions"].readListIfPresent(memberReadingClosure: GlueClientTypes.ConditionExpression.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.ConditionExpression {

    static func write(value: GlueClientTypes.ConditionExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Condition"].write(value.condition)
        try writer["TargetColumn"].write(value.targetColumn)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ConditionExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ConditionExpression()
        value.condition = try reader["Condition"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent()
        value.targetColumn = try reader["TargetColumn"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.RecipeAction {

    static func write(value: GlueClientTypes.RecipeAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Operation"].write(value.operation)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.RecipeAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.RecipeAction()
        value.operation = try reader["Operation"].readIfPresent() ?? ""
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.RecipeReference {

    static func write(value: GlueClientTypes.RecipeReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecipeArn"].write(value.recipeArn)
        try writer["RecipeVersion"].write(value.recipeVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.RecipeReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.RecipeReference()
        value.recipeArn = try reader["RecipeArn"].readIfPresent() ?? ""
        value.recipeVersion = try reader["RecipeVersion"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.EvaluateDataQualityMultiFrame {

    static func write(value: GlueClientTypes.EvaluateDataQualityMultiFrame?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalDataSources"].writeMap(value.additionalDataSources, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["AdditionalOptions"].writeMap(value.additionalOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PublishingOptions"].write(value.publishingOptions, with: GlueClientTypes.DQResultsPublishingOptions.write(value:to:))
        try writer["Ruleset"].write(value.ruleset)
        try writer["StopJobOnFailureOptions"].write(value.stopJobOnFailureOptions, with: GlueClientTypes.DQStopJobOnFailureOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.EvaluateDataQualityMultiFrame {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.EvaluateDataQualityMultiFrame()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.additionalDataSources = try reader["AdditionalDataSources"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.ruleset = try reader["Ruleset"].readIfPresent() ?? ""
        value.publishingOptions = try reader["PublishingOptions"].readIfPresent(with: GlueClientTypes.DQResultsPublishingOptions.read(from:))
        value.additionalOptions = try reader["AdditionalOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stopJobOnFailureOptions = try reader["StopJobOnFailureOptions"].readIfPresent(with: GlueClientTypes.DQStopJobOnFailureOptions.read(from:))
        return value
    }
}

extension GlueClientTypes.DQStopJobOnFailureOptions {

    static func write(value: GlueClientTypes.DQStopJobOnFailureOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StopJobOnFailureTiming"].write(value.stopJobOnFailureTiming)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DQStopJobOnFailureOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DQStopJobOnFailureOptions()
        value.stopJobOnFailureTiming = try reader["StopJobOnFailureTiming"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.DQResultsPublishingOptions {

    static func write(value: GlueClientTypes.DQResultsPublishingOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchMetricsEnabled"].write(value.cloudWatchMetricsEnabled)
        try writer["EvaluationContext"].write(value.evaluationContext)
        try writer["ResultsPublishingEnabled"].write(value.resultsPublishingEnabled)
        try writer["ResultsS3Prefix"].write(value.resultsS3Prefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DQResultsPublishingOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DQResultsPublishingOptions()
        value.evaluationContext = try reader["EvaluationContext"].readIfPresent()
        value.resultsS3Prefix = try reader["ResultsS3Prefix"].readIfPresent()
        value.cloudWatchMetricsEnabled = try reader["CloudWatchMetricsEnabled"].readIfPresent()
        value.resultsPublishingEnabled = try reader["ResultsPublishingEnabled"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.AmazonRedshiftTarget {

    static func write(value: GlueClientTypes.AmazonRedshiftTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Data"].write(value.data, with: GlueClientTypes.AmazonRedshiftNodeData.write(value:to:))
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.AmazonRedshiftTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.AmazonRedshiftTarget()
        value.name = try reader["Name"].readIfPresent()
        value.data = try reader["Data"].readIfPresent(with: GlueClientTypes.AmazonRedshiftNodeData.read(from:))
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.AmazonRedshiftNodeData {

    static func write(value: GlueClientTypes.AmazonRedshiftNodeData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessType"].write(value.accessType)
        try writer["Action"].write(value.action)
        try writer["AdvancedOptions"].writeList(value.advancedOptions, memberWritingClosure: GlueClientTypes.AmazonRedshiftAdvancedOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CatalogDatabase"].write(value.catalogDatabase, with: GlueClientTypes.Option.write(value:to:))
        try writer["CatalogRedshiftSchema"].write(value.catalogRedshiftSchema)
        try writer["CatalogRedshiftTable"].write(value.catalogRedshiftTable)
        try writer["CatalogTable"].write(value.catalogTable, with: GlueClientTypes.Option.write(value:to:))
        try writer["Connection"].write(value.connection, with: GlueClientTypes.Option.write(value:to:))
        try writer["CrawlerConnection"].write(value.crawlerConnection)
        try writer["IamRole"].write(value.iamRole, with: GlueClientTypes.Option.write(value:to:))
        try writer["MergeAction"].write(value.mergeAction)
        try writer["MergeClause"].write(value.mergeClause)
        try writer["MergeWhenMatched"].write(value.mergeWhenMatched)
        try writer["MergeWhenNotMatched"].write(value.mergeWhenNotMatched)
        try writer["PostAction"].write(value.postAction)
        try writer["PreAction"].write(value.preAction)
        try writer["SampleQuery"].write(value.sampleQuery)
        try writer["Schema"].write(value.schema, with: GlueClientTypes.Option.write(value:to:))
        try writer["SelectedColumns"].writeList(value.selectedColumns, memberWritingClosure: GlueClientTypes.Option.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceType"].write(value.sourceType)
        try writer["StagingTable"].write(value.stagingTable)
        try writer["Table"].write(value.table, with: GlueClientTypes.Option.write(value:to:))
        try writer["TablePrefix"].write(value.tablePrefix)
        try writer["TableSchema"].writeList(value.tableSchema, memberWritingClosure: GlueClientTypes.Option.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TempDir"].write(value.tempDir)
        try writer["Upsert"].write(value.upsert)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.AmazonRedshiftNodeData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.AmazonRedshiftNodeData()
        value.accessType = try reader["AccessType"].readIfPresent()
        value.sourceType = try reader["SourceType"].readIfPresent()
        value.connection = try reader["Connection"].readIfPresent(with: GlueClientTypes.Option.read(from:))
        value.schema = try reader["Schema"].readIfPresent(with: GlueClientTypes.Option.read(from:))
        value.table = try reader["Table"].readIfPresent(with: GlueClientTypes.Option.read(from:))
        value.catalogDatabase = try reader["CatalogDatabase"].readIfPresent(with: GlueClientTypes.Option.read(from:))
        value.catalogTable = try reader["CatalogTable"].readIfPresent(with: GlueClientTypes.Option.read(from:))
        value.catalogRedshiftSchema = try reader["CatalogRedshiftSchema"].readIfPresent()
        value.catalogRedshiftTable = try reader["CatalogRedshiftTable"].readIfPresent()
        value.tempDir = try reader["TempDir"].readIfPresent()
        value.iamRole = try reader["IamRole"].readIfPresent(with: GlueClientTypes.Option.read(from:))
        value.advancedOptions = try reader["AdvancedOptions"].readListIfPresent(memberReadingClosure: GlueClientTypes.AmazonRedshiftAdvancedOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sampleQuery = try reader["SampleQuery"].readIfPresent()
        value.preAction = try reader["PreAction"].readIfPresent()
        value.postAction = try reader["PostAction"].readIfPresent()
        value.action = try reader["Action"].readIfPresent()
        value.tablePrefix = try reader["TablePrefix"].readIfPresent()
        value.upsert = try reader["Upsert"].readIfPresent() ?? false
        value.mergeAction = try reader["MergeAction"].readIfPresent()
        value.mergeWhenMatched = try reader["MergeWhenMatched"].readIfPresent()
        value.mergeWhenNotMatched = try reader["MergeWhenNotMatched"].readIfPresent()
        value.mergeClause = try reader["MergeClause"].readIfPresent()
        value.crawlerConnection = try reader["CrawlerConnection"].readIfPresent()
        value.tableSchema = try reader["TableSchema"].readListIfPresent(memberReadingClosure: GlueClientTypes.Option.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.stagingTable = try reader["StagingTable"].readIfPresent()
        value.selectedColumns = try reader["SelectedColumns"].readListIfPresent(memberReadingClosure: GlueClientTypes.Option.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.AmazonRedshiftAdvancedOption {

    static func write(value: GlueClientTypes.AmazonRedshiftAdvancedOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.AmazonRedshiftAdvancedOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.AmazonRedshiftAdvancedOption()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.AmazonRedshiftSource {

    static func write(value: GlueClientTypes.AmazonRedshiftSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Data"].write(value.data, with: GlueClientTypes.AmazonRedshiftNodeData.write(value:to:))
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.AmazonRedshiftSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.AmazonRedshiftSource()
        value.name = try reader["Name"].readIfPresent()
        value.data = try reader["Data"].readIfPresent(with: GlueClientTypes.AmazonRedshiftNodeData.read(from:))
        return value
    }
}

extension GlueClientTypes.S3DeltaDirectTarget {

    static func write(value: GlueClientTypes.S3DeltaDirectTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOptions"].writeMap(value.additionalOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Compression"].write(value.compression)
        try writer["Format"].write(value.format)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PartitionKeys"].writeList(value.partitionKeys, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["Path"].write(value.path)
        try writer["SchemaChangePolicy"].write(value.schemaChangePolicy, with: GlueClientTypes.DirectSchemaChangePolicy.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3DeltaDirectTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3DeltaDirectTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.partitionKeys = try reader["PartitionKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.path = try reader["Path"].readIfPresent() ?? ""
        value.compression = try reader["Compression"].readIfPresent() ?? .sdkUnknown("")
        value.format = try reader["Format"].readIfPresent() ?? .sdkUnknown("")
        value.additionalOptions = try reader["AdditionalOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.schemaChangePolicy = try reader["SchemaChangePolicy"].readIfPresent(with: GlueClientTypes.DirectSchemaChangePolicy.read(from:))
        return value
    }
}

extension GlueClientTypes.DirectSchemaChangePolicy {

    static func write(value: GlueClientTypes.DirectSchemaChangePolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["EnableUpdateCatalog"].write(value.enableUpdateCatalog)
        try writer["Table"].write(value.table)
        try writer["UpdateBehavior"].write(value.updateBehavior)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DirectSchemaChangePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DirectSchemaChangePolicy()
        value.enableUpdateCatalog = try reader["EnableUpdateCatalog"].readIfPresent()
        value.updateBehavior = try reader["UpdateBehavior"].readIfPresent()
        value.table = try reader["Table"].readIfPresent()
        value.database = try reader["Database"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.S3DeltaCatalogTarget {

    static func write(value: GlueClientTypes.S3DeltaCatalogTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOptions"].writeMap(value.additionalOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Database"].write(value.database)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PartitionKeys"].writeList(value.partitionKeys, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["SchemaChangePolicy"].write(value.schemaChangePolicy, with: GlueClientTypes.CatalogSchemaChangePolicy.write(value:to:))
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3DeltaCatalogTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3DeltaCatalogTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.partitionKeys = try reader["PartitionKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.additionalOptions = try reader["AdditionalOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.schemaChangePolicy = try reader["SchemaChangePolicy"].readIfPresent(with: GlueClientTypes.CatalogSchemaChangePolicy.read(from:))
        return value
    }
}

extension GlueClientTypes.CatalogSchemaChangePolicy {

    static func write(value: GlueClientTypes.CatalogSchemaChangePolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableUpdateCatalog"].write(value.enableUpdateCatalog)
        try writer["UpdateBehavior"].write(value.updateBehavior)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CatalogSchemaChangePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CatalogSchemaChangePolicy()
        value.enableUpdateCatalog = try reader["EnableUpdateCatalog"].readIfPresent()
        value.updateBehavior = try reader["UpdateBehavior"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.S3DeltaSource {

    static func write(value: GlueClientTypes.S3DeltaSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalDeltaOptions"].writeMap(value.additionalDeltaOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["AdditionalOptions"].write(value.additionalOptions, with: GlueClientTypes.S3DirectSourceAdditionalOptions.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Paths"].writeList(value.paths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3DeltaSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3DeltaSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.paths = try reader["Paths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.additionalDeltaOptions = try reader["AdditionalDeltaOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.additionalOptions = try reader["AdditionalOptions"].readIfPresent(with: GlueClientTypes.S3DirectSourceAdditionalOptions.read(from:))
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.S3DirectSourceAdditionalOptions {

    static func write(value: GlueClientTypes.S3DirectSourceAdditionalOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundedFiles"].write(value.boundedFiles)
        try writer["BoundedSize"].write(value.boundedSize)
        try writer["EnableSamplePath"].write(value.enableSamplePath)
        try writer["SamplePath"].write(value.samplePath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3DirectSourceAdditionalOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3DirectSourceAdditionalOptions()
        value.boundedSize = try reader["BoundedSize"].readIfPresent()
        value.boundedFiles = try reader["BoundedFiles"].readIfPresent()
        value.enableSamplePath = try reader["EnableSamplePath"].readIfPresent()
        value.samplePath = try reader["SamplePath"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.CatalogDeltaSource {

    static func write(value: GlueClientTypes.CatalogDeltaSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalDeltaOptions"].writeMap(value.additionalDeltaOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CatalogDeltaSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CatalogDeltaSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.additionalDeltaOptions = try reader["AdditionalDeltaOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.S3CatalogDeltaSource {

    static func write(value: GlueClientTypes.S3CatalogDeltaSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalDeltaOptions"].writeMap(value.additionalDeltaOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3CatalogDeltaSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3CatalogDeltaSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.additionalDeltaOptions = try reader["AdditionalDeltaOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.DirectJDBCSource {

    static func write(value: GlueClientTypes.DirectJDBCSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionName"].write(value.connectionName)
        try writer["ConnectionType"].write(value.connectionType)
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["RedshiftTmpDir"].write(value.redshiftTmpDir)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DirectJDBCSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DirectJDBCSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.connectionName = try reader["ConnectionName"].readIfPresent() ?? ""
        value.connectionType = try reader["ConnectionType"].readIfPresent() ?? .sdkUnknown("")
        value.redshiftTmpDir = try reader["RedshiftTmpDir"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.S3HudiDirectTarget {

    static func write(value: GlueClientTypes.S3HudiDirectTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOptions"].writeMap(value.additionalOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Compression"].write(value.compression)
        try writer["Format"].write(value.format)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PartitionKeys"].writeList(value.partitionKeys, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["Path"].write(value.path)
        try writer["SchemaChangePolicy"].write(value.schemaChangePolicy, with: GlueClientTypes.DirectSchemaChangePolicy.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3HudiDirectTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3HudiDirectTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.path = try reader["Path"].readIfPresent() ?? ""
        value.compression = try reader["Compression"].readIfPresent() ?? .sdkUnknown("")
        value.partitionKeys = try reader["PartitionKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.format = try reader["Format"].readIfPresent() ?? .sdkUnknown("")
        value.additionalOptions = try reader["AdditionalOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.schemaChangePolicy = try reader["SchemaChangePolicy"].readIfPresent(with: GlueClientTypes.DirectSchemaChangePolicy.read(from:))
        return value
    }
}

extension GlueClientTypes.S3HudiCatalogTarget {

    static func write(value: GlueClientTypes.S3HudiCatalogTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOptions"].writeMap(value.additionalOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Database"].write(value.database)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PartitionKeys"].writeList(value.partitionKeys, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["SchemaChangePolicy"].write(value.schemaChangePolicy, with: GlueClientTypes.CatalogSchemaChangePolicy.write(value:to:))
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3HudiCatalogTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3HudiCatalogTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.partitionKeys = try reader["PartitionKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.additionalOptions = try reader["AdditionalOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.schemaChangePolicy = try reader["SchemaChangePolicy"].readIfPresent(with: GlueClientTypes.CatalogSchemaChangePolicy.read(from:))
        return value
    }
}

extension GlueClientTypes.S3HudiSource {

    static func write(value: GlueClientTypes.S3HudiSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalHudiOptions"].writeMap(value.additionalHudiOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["AdditionalOptions"].write(value.additionalOptions, with: GlueClientTypes.S3DirectSourceAdditionalOptions.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Paths"].writeList(value.paths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3HudiSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3HudiSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.paths = try reader["Paths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.additionalHudiOptions = try reader["AdditionalHudiOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.additionalOptions = try reader["AdditionalOptions"].readIfPresent(with: GlueClientTypes.S3DirectSourceAdditionalOptions.read(from:))
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.CatalogHudiSource {

    static func write(value: GlueClientTypes.CatalogHudiSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalHudiOptions"].writeMap(value.additionalHudiOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CatalogHudiSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CatalogHudiSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.additionalHudiOptions = try reader["AdditionalHudiOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.S3CatalogHudiSource {

    static func write(value: GlueClientTypes.S3CatalogHudiSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalHudiOptions"].writeMap(value.additionalHudiOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3CatalogHudiSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3CatalogHudiSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.additionalHudiOptions = try reader["AdditionalHudiOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.EvaluateDataQuality {

    static func write(value: GlueClientTypes.EvaluateDataQuality?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Output"].write(value.output)
        try writer["PublishingOptions"].write(value.publishingOptions, with: GlueClientTypes.DQResultsPublishingOptions.write(value:to:))
        try writer["Ruleset"].write(value.ruleset)
        try writer["StopJobOnFailureOptions"].write(value.stopJobOnFailureOptions, with: GlueClientTypes.DQStopJobOnFailureOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.EvaluateDataQuality {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.EvaluateDataQuality()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.ruleset = try reader["Ruleset"].readIfPresent() ?? ""
        value.output = try reader["Output"].readIfPresent()
        value.publishingOptions = try reader["PublishingOptions"].readIfPresent(with: GlueClientTypes.DQResultsPublishingOptions.read(from:))
        value.stopJobOnFailureOptions = try reader["StopJobOnFailureOptions"].readIfPresent(with: GlueClientTypes.DQStopJobOnFailureOptions.read(from:))
        return value
    }
}

extension GlueClientTypes.DynamicTransform {

    static func write(value: GlueClientTypes.DynamicTransform?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FunctionName"].write(value.functionName)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Parameters"].writeList(value.parameters, memberWritingClosure: GlueClientTypes.TransformConfigParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Path"].write(value.path)
        try writer["TransformName"].write(value.transformName)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DynamicTransform {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DynamicTransform()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.transformName = try reader["TransformName"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.parameters = try reader["Parameters"].readListIfPresent(memberReadingClosure: GlueClientTypes.TransformConfigParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.functionName = try reader["FunctionName"].readIfPresent() ?? ""
        value.path = try reader["Path"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent()
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.TransformConfigParameter {

    static func write(value: GlueClientTypes.TransformConfigParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsOptional"].write(value.isOptional)
        try writer["ListType"].write(value.listType)
        try writer["Name"].write(value.name)
        try writer["Type"].write(value.type)
        try writer["ValidationMessage"].write(value.validationMessage)
        try writer["ValidationRule"].write(value.validationRule)
        try writer["Value"].writeList(value.value, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TransformConfigParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TransformConfigParameter()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.validationRule = try reader["ValidationRule"].readIfPresent()
        value.validationMessage = try reader["ValidationMessage"].readIfPresent()
        value.value = try reader["Value"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.listType = try reader["ListType"].readIfPresent()
        value.isOptional = try reader["IsOptional"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.PostgreSQLCatalogTarget {

    static func write(value: GlueClientTypes.PostgreSQLCatalogTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.PostgreSQLCatalogTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.PostgreSQLCatalogTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.OracleSQLCatalogTarget {

    static func write(value: GlueClientTypes.OracleSQLCatalogTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.OracleSQLCatalogTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.OracleSQLCatalogTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.MySQLCatalogTarget {

    static func write(value: GlueClientTypes.MySQLCatalogTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.MySQLCatalogTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.MySQLCatalogTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.MicrosoftSQLServerCatalogTarget {

    static func write(value: GlueClientTypes.MicrosoftSQLServerCatalogTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.MicrosoftSQLServerCatalogTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.MicrosoftSQLServerCatalogTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.PostgreSQLCatalogSource {

    static func write(value: GlueClientTypes.PostgreSQLCatalogSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.PostgreSQLCatalogSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.PostgreSQLCatalogSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.OracleSQLCatalogSource {

    static func write(value: GlueClientTypes.OracleSQLCatalogSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.OracleSQLCatalogSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.OracleSQLCatalogSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.MySQLCatalogSource {

    static func write(value: GlueClientTypes.MySQLCatalogSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.MySQLCatalogSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.MySQLCatalogSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.MicrosoftSQLServerCatalogSource {

    static func write(value: GlueClientTypes.MicrosoftSQLServerCatalogSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.MicrosoftSQLServerCatalogSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.MicrosoftSQLServerCatalogSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.GovernedCatalogSource {

    static func write(value: GlueClientTypes.GovernedCatalogSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOptions"].write(value.additionalOptions, with: GlueClientTypes.S3SourceAdditionalOptions.write(value:to:))
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["PartitionPredicate"].write(value.partitionPredicate)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.GovernedCatalogSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.GovernedCatalogSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.partitionPredicate = try reader["PartitionPredicate"].readIfPresent()
        value.additionalOptions = try reader["AdditionalOptions"].readIfPresent(with: GlueClientTypes.S3SourceAdditionalOptions.read(from:))
        return value
    }
}

extension GlueClientTypes.S3SourceAdditionalOptions {

    static func write(value: GlueClientTypes.S3SourceAdditionalOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundedFiles"].write(value.boundedFiles)
        try writer["BoundedSize"].write(value.boundedSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3SourceAdditionalOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3SourceAdditionalOptions()
        value.boundedSize = try reader["BoundedSize"].readIfPresent()
        value.boundedFiles = try reader["BoundedFiles"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.GovernedCatalogTarget {

    static func write(value: GlueClientTypes.GovernedCatalogTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PartitionKeys"].writeList(value.partitionKeys, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["SchemaChangePolicy"].write(value.schemaChangePolicy, with: GlueClientTypes.CatalogSchemaChangePolicy.write(value:to:))
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.GovernedCatalogTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.GovernedCatalogTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.partitionKeys = try reader["PartitionKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.schemaChangePolicy = try reader["SchemaChangePolicy"].readIfPresent(with: GlueClientTypes.CatalogSchemaChangePolicy.read(from:))
        return value
    }
}

extension GlueClientTypes.DropDuplicates {

    static func write(value: GlueClientTypes.DropDuplicates?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Columns"].writeList(value.columns, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DropDuplicates {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DropDuplicates()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.columns = try reader["Columns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.Aggregate {

    static func write(value: GlueClientTypes.Aggregate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggs"].writeList(value.aggs, memberWritingClosure: GlueClientTypes.AggregateOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Groups"].writeList(value.groups, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Aggregate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Aggregate()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false) ?? []
        value.aggs = try reader["Aggs"].readListIfPresent(memberReadingClosure: GlueClientTypes.AggregateOperation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GlueClientTypes.AggregateOperation {

    static func write(value: GlueClientTypes.AggregateOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggFunc"].write(value.aggFunc)
        try writer["Column"].writeList(value.column, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.AggregateOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.AggregateOperation()
        value.column = try reader["Column"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.aggFunc = try reader["AggFunc"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GlueClientTypes.PIIDetection {

    static func write(value: GlueClientTypes.PIIDetection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityTypesToDetect"].writeList(value.entityTypesToDetect, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaskValue"].write(value.maskValue)
        try writer["Name"].write(value.name)
        try writer["OutputColumnName"].write(value.outputColumnName)
        try writer["PiiType"].write(value.piiType)
        try writer["SampleFraction"].write(value.sampleFraction)
        try writer["ThresholdFraction"].write(value.thresholdFraction)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.PIIDetection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.PIIDetection()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.piiType = try reader["PiiType"].readIfPresent() ?? .sdkUnknown("")
        value.entityTypesToDetect = try reader["EntityTypesToDetect"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.outputColumnName = try reader["OutputColumnName"].readIfPresent()
        value.sampleFraction = try reader["SampleFraction"].readIfPresent()
        value.thresholdFraction = try reader["ThresholdFraction"].readIfPresent()
        value.maskValue = try reader["MaskValue"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.Union {

    static func write(value: GlueClientTypes.Union?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["UnionType"].write(value.unionType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Union {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Union()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.unionType = try reader["UnionType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GlueClientTypes.Merge {

    static func write(value: GlueClientTypes.Merge?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PrimaryKeys"].writeList(value.primaryKeys, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["Source"].write(value.source)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Merge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Merge()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.source = try reader["Source"].readIfPresent() ?? ""
        value.primaryKeys = try reader["PrimaryKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GlueClientTypes.DropNullFields {

    static func write(value: GlueClientTypes.DropNullFields?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["NullCheckBoxList"].write(value.nullCheckBoxList, with: GlueClientTypes.NullCheckBoxList.write(value:to:))
        try writer["NullTextList"].writeList(value.nullTextList, memberWritingClosure: GlueClientTypes.NullValueField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DropNullFields {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DropNullFields()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nullCheckBoxList = try reader["NullCheckBoxList"].readIfPresent(with: GlueClientTypes.NullCheckBoxList.read(from:))
        value.nullTextList = try reader["NullTextList"].readListIfPresent(memberReadingClosure: GlueClientTypes.NullValueField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.NullValueField {

    static func write(value: GlueClientTypes.NullValueField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Datatype"].write(value.datatype, with: GlueClientTypes.Datatype.write(value:to:))
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.NullValueField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.NullValueField()
        value.value = try reader["Value"].readIfPresent() ?? ""
        value.datatype = try reader["Datatype"].readIfPresent(with: GlueClientTypes.Datatype.read(from:))
        return value
    }
}

extension GlueClientTypes.Datatype {

    static func write(value: GlueClientTypes.Datatype?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Label"].write(value.label)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Datatype {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Datatype()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.label = try reader["Label"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.NullCheckBoxList {

    static func write(value: GlueClientTypes.NullCheckBoxList?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsEmpty"].write(value.isEmpty)
        try writer["IsNegOne"].write(value.isNegOne)
        try writer["IsNullString"].write(value.isNullString)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.NullCheckBoxList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.NullCheckBoxList()
        value.isEmpty = try reader["IsEmpty"].readIfPresent()
        value.isNullString = try reader["IsNullString"].readIfPresent()
        value.isNegOne = try reader["IsNegOne"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.CatalogKafkaSource {

    static func write(value: GlueClientTypes.CatalogKafkaSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataPreviewOptions"].write(value.dataPreviewOptions, with: GlueClientTypes.StreamingDataPreviewOptions.write(value:to:))
        try writer["Database"].write(value.database)
        try writer["DetectSchema"].write(value.detectSchema)
        try writer["Name"].write(value.name)
        try writer["StreamingOptions"].write(value.streamingOptions, with: GlueClientTypes.KafkaStreamingSourceOptions.write(value:to:))
        try writer["Table"].write(value.table)
        try writer["WindowSize"].write(value.windowSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CatalogKafkaSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CatalogKafkaSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.windowSize = try reader["WindowSize"].readIfPresent()
        value.detectSchema = try reader["DetectSchema"].readIfPresent()
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.streamingOptions = try reader["StreamingOptions"].readIfPresent(with: GlueClientTypes.KafkaStreamingSourceOptions.read(from:))
        value.dataPreviewOptions = try reader["DataPreviewOptions"].readIfPresent(with: GlueClientTypes.StreamingDataPreviewOptions.read(from:))
        return value
    }
}

extension GlueClientTypes.StreamingDataPreviewOptions {

    static func write(value: GlueClientTypes.StreamingDataPreviewOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PollingTime"].write(value.pollingTime)
        try writer["RecordPollingLimit"].write(value.recordPollingLimit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.StreamingDataPreviewOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.StreamingDataPreviewOptions()
        value.pollingTime = try reader["PollingTime"].readIfPresent()
        value.recordPollingLimit = try reader["RecordPollingLimit"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.KafkaStreamingSourceOptions {

    static func write(value: GlueClientTypes.KafkaStreamingSourceOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddRecordTimestamp"].write(value.addRecordTimestamp)
        try writer["Assign"].write(value.assign)
        try writer["BootstrapServers"].write(value.bootstrapServers)
        try writer["Classification"].write(value.classification)
        try writer["ConnectionName"].write(value.connectionName)
        try writer["Delimiter"].write(value.delimiter)
        try writer["EmitConsumerLagMetrics"].write(value.emitConsumerLagMetrics)
        try writer["EndingOffsets"].write(value.endingOffsets)
        try writer["IncludeHeaders"].write(value.includeHeaders)
        try writer["MaxOffsetsPerTrigger"].write(value.maxOffsetsPerTrigger)
        try writer["MinPartitions"].write(value.minPartitions)
        try writer["NumRetries"].write(value.numRetries)
        try writer["PollTimeoutMs"].write(value.pollTimeoutMs)
        try writer["RetryIntervalMs"].write(value.retryIntervalMs)
        try writer["SecurityProtocol"].write(value.securityProtocol)
        try writer["StartingOffsets"].write(value.startingOffsets)
        try writer["StartingTimestamp"].writeTimestamp(value.startingTimestamp, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["SubscribePattern"].write(value.subscribePattern)
        try writer["TopicName"].write(value.topicName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.KafkaStreamingSourceOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.KafkaStreamingSourceOptions()
        value.bootstrapServers = try reader["BootstrapServers"].readIfPresent()
        value.securityProtocol = try reader["SecurityProtocol"].readIfPresent()
        value.connectionName = try reader["ConnectionName"].readIfPresent()
        value.topicName = try reader["TopicName"].readIfPresent()
        value.assign = try reader["Assign"].readIfPresent()
        value.subscribePattern = try reader["SubscribePattern"].readIfPresent()
        value.classification = try reader["Classification"].readIfPresent()
        value.delimiter = try reader["Delimiter"].readIfPresent()
        value.startingOffsets = try reader["StartingOffsets"].readIfPresent()
        value.endingOffsets = try reader["EndingOffsets"].readIfPresent()
        value.pollTimeoutMs = try reader["PollTimeoutMs"].readIfPresent()
        value.numRetries = try reader["NumRetries"].readIfPresent()
        value.retryIntervalMs = try reader["RetryIntervalMs"].readIfPresent()
        value.maxOffsetsPerTrigger = try reader["MaxOffsetsPerTrigger"].readIfPresent()
        value.minPartitions = try reader["MinPartitions"].readIfPresent()
        value.includeHeaders = try reader["IncludeHeaders"].readIfPresent()
        value.addRecordTimestamp = try reader["AddRecordTimestamp"].readIfPresent()
        value.emitConsumerLagMetrics = try reader["EmitConsumerLagMetrics"].readIfPresent()
        value.startingTimestamp = try reader["StartingTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GlueClientTypes.CatalogKinesisSource {

    static func write(value: GlueClientTypes.CatalogKinesisSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataPreviewOptions"].write(value.dataPreviewOptions, with: GlueClientTypes.StreamingDataPreviewOptions.write(value:to:))
        try writer["Database"].write(value.database)
        try writer["DetectSchema"].write(value.detectSchema)
        try writer["Name"].write(value.name)
        try writer["StreamingOptions"].write(value.streamingOptions, with: GlueClientTypes.KinesisStreamingSourceOptions.write(value:to:))
        try writer["Table"].write(value.table)
        try writer["WindowSize"].write(value.windowSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CatalogKinesisSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CatalogKinesisSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.windowSize = try reader["WindowSize"].readIfPresent()
        value.detectSchema = try reader["DetectSchema"].readIfPresent()
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.streamingOptions = try reader["StreamingOptions"].readIfPresent(with: GlueClientTypes.KinesisStreamingSourceOptions.read(from:))
        value.dataPreviewOptions = try reader["DataPreviewOptions"].readIfPresent(with: GlueClientTypes.StreamingDataPreviewOptions.read(from:))
        return value
    }
}

extension GlueClientTypes.KinesisStreamingSourceOptions {

    static func write(value: GlueClientTypes.KinesisStreamingSourceOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddIdleTimeBetweenReads"].write(value.addIdleTimeBetweenReads)
        try writer["AddRecordTimestamp"].write(value.addRecordTimestamp)
        try writer["AvoidEmptyBatches"].write(value.avoidEmptyBatches)
        try writer["Classification"].write(value.classification)
        try writer["Delimiter"].write(value.delimiter)
        try writer["DescribeShardInterval"].write(value.describeShardInterval)
        try writer["EmitConsumerLagMetrics"].write(value.emitConsumerLagMetrics)
        try writer["EndpointUrl"].write(value.endpointUrl)
        try writer["IdleTimeBetweenReadsInMs"].write(value.idleTimeBetweenReadsInMs)
        try writer["MaxFetchRecordsPerShard"].write(value.maxFetchRecordsPerShard)
        try writer["MaxFetchTimeInMs"].write(value.maxFetchTimeInMs)
        try writer["MaxRecordPerRead"].write(value.maxRecordPerRead)
        try writer["MaxRetryIntervalMs"].write(value.maxRetryIntervalMs)
        try writer["NumRetries"].write(value.numRetries)
        try writer["RetryIntervalMs"].write(value.retryIntervalMs)
        try writer["RoleArn"].write(value.roleArn)
        try writer["RoleSessionName"].write(value.roleSessionName)
        try writer["StartingPosition"].write(value.startingPosition)
        try writer["StartingTimestamp"].writeTimestamp(value.startingTimestamp, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["StreamArn"].write(value.streamArn)
        try writer["StreamName"].write(value.streamName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.KinesisStreamingSourceOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.KinesisStreamingSourceOptions()
        value.endpointUrl = try reader["EndpointUrl"].readIfPresent()
        value.streamName = try reader["StreamName"].readIfPresent()
        value.classification = try reader["Classification"].readIfPresent()
        value.delimiter = try reader["Delimiter"].readIfPresent()
        value.startingPosition = try reader["StartingPosition"].readIfPresent()
        value.maxFetchTimeInMs = try reader["MaxFetchTimeInMs"].readIfPresent()
        value.maxFetchRecordsPerShard = try reader["MaxFetchRecordsPerShard"].readIfPresent()
        value.maxRecordPerRead = try reader["MaxRecordPerRead"].readIfPresent()
        value.addIdleTimeBetweenReads = try reader["AddIdleTimeBetweenReads"].readIfPresent()
        value.idleTimeBetweenReadsInMs = try reader["IdleTimeBetweenReadsInMs"].readIfPresent()
        value.describeShardInterval = try reader["DescribeShardInterval"].readIfPresent()
        value.numRetries = try reader["NumRetries"].readIfPresent()
        value.retryIntervalMs = try reader["RetryIntervalMs"].readIfPresent()
        value.maxRetryIntervalMs = try reader["MaxRetryIntervalMs"].readIfPresent()
        value.avoidEmptyBatches = try reader["AvoidEmptyBatches"].readIfPresent()
        value.streamArn = try reader["StreamArn"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.roleSessionName = try reader["RoleSessionName"].readIfPresent()
        value.addRecordTimestamp = try reader["AddRecordTimestamp"].readIfPresent()
        value.emitConsumerLagMetrics = try reader["EmitConsumerLagMetrics"].readIfPresent()
        value.startingTimestamp = try reader["StartingTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GlueClientTypes.DirectKafkaSource {

    static func write(value: GlueClientTypes.DirectKafkaSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataPreviewOptions"].write(value.dataPreviewOptions, with: GlueClientTypes.StreamingDataPreviewOptions.write(value:to:))
        try writer["DetectSchema"].write(value.detectSchema)
        try writer["Name"].write(value.name)
        try writer["StreamingOptions"].write(value.streamingOptions, with: GlueClientTypes.KafkaStreamingSourceOptions.write(value:to:))
        try writer["WindowSize"].write(value.windowSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DirectKafkaSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DirectKafkaSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.streamingOptions = try reader["StreamingOptions"].readIfPresent(with: GlueClientTypes.KafkaStreamingSourceOptions.read(from:))
        value.windowSize = try reader["WindowSize"].readIfPresent()
        value.detectSchema = try reader["DetectSchema"].readIfPresent()
        value.dataPreviewOptions = try reader["DataPreviewOptions"].readIfPresent(with: GlueClientTypes.StreamingDataPreviewOptions.read(from:))
        return value
    }
}

extension GlueClientTypes.DirectKinesisSource {

    static func write(value: GlueClientTypes.DirectKinesisSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataPreviewOptions"].write(value.dataPreviewOptions, with: GlueClientTypes.StreamingDataPreviewOptions.write(value:to:))
        try writer["DetectSchema"].write(value.detectSchema)
        try writer["Name"].write(value.name)
        try writer["StreamingOptions"].write(value.streamingOptions, with: GlueClientTypes.KinesisStreamingSourceOptions.write(value:to:))
        try writer["WindowSize"].write(value.windowSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DirectKinesisSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DirectKinesisSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.windowSize = try reader["WindowSize"].readIfPresent()
        value.detectSchema = try reader["DetectSchema"].readIfPresent()
        value.streamingOptions = try reader["StreamingOptions"].readIfPresent(with: GlueClientTypes.KinesisStreamingSourceOptions.read(from:))
        value.dataPreviewOptions = try reader["DataPreviewOptions"].readIfPresent(with: GlueClientTypes.StreamingDataPreviewOptions.read(from:))
        return value
    }
}

extension GlueClientTypes.SparkSQL {

    static func write(value: GlueClientTypes.SparkSQL?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SqlAliases"].writeList(value.sqlAliases, memberWritingClosure: GlueClientTypes.SqlAlias.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SqlQuery"].write(value.sqlQuery)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SparkSQL {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SparkSQL()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.sqlQuery = try reader["SqlQuery"].readIfPresent() ?? ""
        value.sqlAliases = try reader["SqlAliases"].readListIfPresent(memberReadingClosure: GlueClientTypes.SqlAlias.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.SqlAlias {

    static func write(value: GlueClientTypes.SqlAlias?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Alias"].write(value.alias)
        try writer["From"].write(value.from)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SqlAlias {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SqlAlias()
        value.from = try reader["From"].readIfPresent() ?? ""
        value.alias = try reader["Alias"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.CustomCode {

    static func write(value: GlueClientTypes.CustomCode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClassName"].write(value.className)
        try writer["Code"].write(value.code)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CustomCode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CustomCode()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.code = try reader["Code"].readIfPresent() ?? ""
        value.className = try reader["ClassName"].readIfPresent() ?? ""
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.Filter {

    static func write(value: GlueClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: GlueClientTypes.FilterExpression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LogicalOperator"].write(value.logicalOperator)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Filter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Filter()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.logicalOperator = try reader["LogicalOperator"].readIfPresent() ?? .sdkUnknown("")
        value.filters = try reader["Filters"].readListIfPresent(memberReadingClosure: GlueClientTypes.FilterExpression.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GlueClientTypes.FilterExpression {

    static func write(value: GlueClientTypes.FilterExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Negated"].write(value.negated)
        try writer["Operation"].write(value.operation)
        try writer["Values"].writeList(value.values, memberWritingClosure: GlueClientTypes.FilterValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.FilterExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.FilterExpression()
        value.operation = try reader["Operation"].readIfPresent() ?? .sdkUnknown("")
        value.negated = try reader["Negated"].readIfPresent()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: GlueClientTypes.FilterValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GlueClientTypes.FilterValue {

    static func write(value: GlueClientTypes.FilterValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["Value"].writeList(value.value, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.FilterValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.FilterValue()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["Value"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GlueClientTypes.FillMissingValues {

    static func write(value: GlueClientTypes.FillMissingValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilledPath"].write(value.filledPath)
        try writer["ImputedPath"].write(value.imputedPath)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.FillMissingValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.FillMissingValues()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.imputedPath = try reader["ImputedPath"].readIfPresent() ?? ""
        value.filledPath = try reader["FilledPath"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.SelectFromCollection {

    static func write(value: GlueClientTypes.SelectFromCollection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Index"].write(value.index)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SelectFromCollection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SelectFromCollection()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.index = try reader["Index"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.SplitFields {

    static func write(value: GlueClientTypes.SplitFields?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Paths"].writeList(value.paths, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SplitFields {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SplitFields()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.paths = try reader["Paths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GlueClientTypes.Join {

    static func write(value: GlueClientTypes.Join?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Columns"].writeList(value.columns, memberWritingClosure: GlueClientTypes.JoinColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["JoinType"].write(value.joinType)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Join {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Join()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.joinType = try reader["JoinType"].readIfPresent() ?? .sdkUnknown("")
        value.columns = try reader["Columns"].readListIfPresent(memberReadingClosure: GlueClientTypes.JoinColumn.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GlueClientTypes.JoinColumn {

    static func write(value: GlueClientTypes.JoinColumn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["From"].write(value.from)
        try writer["Keys"].writeList(value.keys, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.JoinColumn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.JoinColumn()
        value.from = try reader["From"].readIfPresent() ?? ""
        value.keys = try reader["Keys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GlueClientTypes.Spigot {

    static func write(value: GlueClientTypes.Spigot?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Path"].write(value.path)
        try writer["Prob"].write(value.prob)
        try writer["Topk"].write(value.topk)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Spigot {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Spigot()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.path = try reader["Path"].readIfPresent() ?? ""
        value.topk = try reader["Topk"].readIfPresent()
        value.prob = try reader["Prob"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.RenameField {

    static func write(value: GlueClientTypes.RenameField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["SourcePath"].writeList(value.sourcePath, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetPath"].writeList(value.targetPath, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.RenameField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.RenameField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.sourcePath = try reader["SourcePath"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.targetPath = try reader["TargetPath"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GlueClientTypes.DropFields {

    static func write(value: GlueClientTypes.DropFields?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Paths"].writeList(value.paths, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DropFields {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DropFields()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.paths = try reader["Paths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GlueClientTypes.SelectFields {

    static func write(value: GlueClientTypes.SelectFields?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Paths"].writeList(value.paths, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SelectFields {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SelectFields()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.paths = try reader["Paths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GlueClientTypes.ApplyMapping {

    static func write(value: GlueClientTypes.ApplyMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Mapping"].writeList(value.mapping, memberWritingClosure: GlueClientTypes.Mapping.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ApplyMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ApplyMapping()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.mapping = try reader["Mapping"].readListIfPresent(memberReadingClosure: GlueClientTypes.Mapping.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GlueClientTypes.Mapping {

    static func write(value: GlueClientTypes.Mapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Children"].writeList(value.children, memberWritingClosure: GlueClientTypes.Mapping.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Dropped"].write(value.dropped)
        try writer["FromPath"].writeList(value.fromPath, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FromType"].write(value.fromType)
        try writer["ToKey"].write(value.toKey)
        try writer["ToType"].write(value.toType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Mapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Mapping()
        value.toKey = try reader["ToKey"].readIfPresent()
        value.fromPath = try reader["FromPath"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.fromType = try reader["FromType"].readIfPresent()
        value.toType = try reader["ToType"].readIfPresent()
        value.dropped = try reader["Dropped"].readIfPresent()
        value.children = try reader["Children"].readListIfPresent(memberReadingClosure: GlueClientTypes.Mapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.S3DirectTarget {

    static func write(value: GlueClientTypes.S3DirectTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Compression"].write(value.compression)
        try writer["Format"].write(value.format)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PartitionKeys"].writeList(value.partitionKeys, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["Path"].write(value.path)
        try writer["SchemaChangePolicy"].write(value.schemaChangePolicy, with: GlueClientTypes.DirectSchemaChangePolicy.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3DirectTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3DirectTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.partitionKeys = try reader["PartitionKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.path = try reader["Path"].readIfPresent() ?? ""
        value.compression = try reader["Compression"].readIfPresent()
        value.format = try reader["Format"].readIfPresent() ?? .sdkUnknown("")
        value.schemaChangePolicy = try reader["SchemaChangePolicy"].readIfPresent(with: GlueClientTypes.DirectSchemaChangePolicy.read(from:))
        return value
    }
}

extension GlueClientTypes.S3GlueParquetTarget {

    static func write(value: GlueClientTypes.S3GlueParquetTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Compression"].write(value.compression)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PartitionKeys"].writeList(value.partitionKeys, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["Path"].write(value.path)
        try writer["SchemaChangePolicy"].write(value.schemaChangePolicy, with: GlueClientTypes.DirectSchemaChangePolicy.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3GlueParquetTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3GlueParquetTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.partitionKeys = try reader["PartitionKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.path = try reader["Path"].readIfPresent() ?? ""
        value.compression = try reader["Compression"].readIfPresent()
        value.schemaChangePolicy = try reader["SchemaChangePolicy"].readIfPresent(with: GlueClientTypes.DirectSchemaChangePolicy.read(from:))
        return value
    }
}

extension GlueClientTypes.S3CatalogTarget {

    static func write(value: GlueClientTypes.S3CatalogTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PartitionKeys"].writeList(value.partitionKeys, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["SchemaChangePolicy"].write(value.schemaChangePolicy, with: GlueClientTypes.CatalogSchemaChangePolicy.write(value:to:))
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3CatalogTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3CatalogTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.partitionKeys = try reader["PartitionKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.schemaChangePolicy = try reader["SchemaChangePolicy"].readIfPresent(with: GlueClientTypes.CatalogSchemaChangePolicy.read(from:))
        return value
    }
}

extension GlueClientTypes.RedshiftTarget {

    static func write(value: GlueClientTypes.RedshiftTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["RedshiftTmpDir"].write(value.redshiftTmpDir)
        try writer["Table"].write(value.table)
        try writer["TmpDirIAMRole"].write(value.tmpDirIAMRole)
        try writer["UpsertRedshiftOptions"].write(value.upsertRedshiftOptions, with: GlueClientTypes.UpsertRedshiftTargetOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.RedshiftTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.RedshiftTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.redshiftTmpDir = try reader["RedshiftTmpDir"].readIfPresent()
        value.tmpDirIAMRole = try reader["TmpDirIAMRole"].readIfPresent()
        value.upsertRedshiftOptions = try reader["UpsertRedshiftOptions"].readIfPresent(with: GlueClientTypes.UpsertRedshiftTargetOptions.read(from:))
        return value
    }
}

extension GlueClientTypes.UpsertRedshiftTargetOptions {

    static func write(value: GlueClientTypes.UpsertRedshiftTargetOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionName"].write(value.connectionName)
        try writer["TableLocation"].write(value.tableLocation)
        try writer["UpsertKeys"].writeList(value.upsertKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.UpsertRedshiftTargetOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.UpsertRedshiftTargetOptions()
        value.tableLocation = try reader["TableLocation"].readIfPresent()
        value.connectionName = try reader["ConnectionName"].readIfPresent()
        value.upsertKeys = try reader["UpsertKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.BasicCatalogTarget {

    static func write(value: GlueClientTypes.BasicCatalogTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PartitionKeys"].writeList(value.partitionKeys, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.BasicCatalogTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.BasicCatalogTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.partitionKeys = try reader["PartitionKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.SparkConnectorTarget {

    static func write(value: GlueClientTypes.SparkConnectorTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOptions"].writeMap(value.additionalOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ConnectionName"].write(value.connectionName)
        try writer["ConnectionType"].write(value.connectionType)
        try writer["ConnectorName"].write(value.connectorName)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SparkConnectorTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SparkConnectorTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.connectionName = try reader["ConnectionName"].readIfPresent() ?? ""
        value.connectorName = try reader["ConnectorName"].readIfPresent() ?? ""
        value.connectionType = try reader["ConnectionType"].readIfPresent() ?? ""
        value.additionalOptions = try reader["AdditionalOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.JDBCConnectorTarget {

    static func write(value: GlueClientTypes.JDBCConnectorTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOptions"].writeMap(value.additionalOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ConnectionName"].write(value.connectionName)
        try writer["ConnectionTable"].write(value.connectionTable)
        try writer["ConnectionType"].write(value.connectionType)
        try writer["ConnectorName"].write(value.connectorName)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.JDBCConnectorTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.JDBCConnectorTarget()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.connectionName = try reader["ConnectionName"].readIfPresent() ?? ""
        value.connectionTable = try reader["ConnectionTable"].readIfPresent() ?? ""
        value.connectorName = try reader["ConnectorName"].readIfPresent() ?? ""
        value.connectionType = try reader["ConnectionType"].readIfPresent() ?? ""
        value.additionalOptions = try reader["AdditionalOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.DynamoDBCatalogSource {

    static func write(value: GlueClientTypes.DynamoDBCatalogSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DynamoDBCatalogSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DynamoDBCatalogSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.RelationalCatalogSource {

    static func write(value: GlueClientTypes.RelationalCatalogSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.RelationalCatalogSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.RelationalCatalogSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.S3ParquetSource {

    static func write(value: GlueClientTypes.S3ParquetSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOptions"].write(value.additionalOptions, with: GlueClientTypes.S3DirectSourceAdditionalOptions.write(value:to:))
        try writer["CompressionType"].write(value.compressionType)
        try writer["Exclusions"].writeList(value.exclusions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GroupFiles"].write(value.groupFiles)
        try writer["GroupSize"].write(value.groupSize)
        try writer["MaxBand"].write(value.maxBand)
        try writer["MaxFilesInBand"].write(value.maxFilesInBand)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Paths"].writeList(value.paths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Recurse"].write(value.recurse)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3ParquetSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3ParquetSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.paths = try reader["Paths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.compressionType = try reader["CompressionType"].readIfPresent()
        value.exclusions = try reader["Exclusions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.groupSize = try reader["GroupSize"].readIfPresent()
        value.groupFiles = try reader["GroupFiles"].readIfPresent()
        value.recurse = try reader["Recurse"].readIfPresent()
        value.maxBand = try reader["MaxBand"].readIfPresent()
        value.maxFilesInBand = try reader["MaxFilesInBand"].readIfPresent()
        value.additionalOptions = try reader["AdditionalOptions"].readIfPresent(with: GlueClientTypes.S3DirectSourceAdditionalOptions.read(from:))
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.S3JsonSource {

    static func write(value: GlueClientTypes.S3JsonSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOptions"].write(value.additionalOptions, with: GlueClientTypes.S3DirectSourceAdditionalOptions.write(value:to:))
        try writer["CompressionType"].write(value.compressionType)
        try writer["Exclusions"].writeList(value.exclusions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GroupFiles"].write(value.groupFiles)
        try writer["GroupSize"].write(value.groupSize)
        try writer["JsonPath"].write(value.jsonPath)
        try writer["MaxBand"].write(value.maxBand)
        try writer["MaxFilesInBand"].write(value.maxFilesInBand)
        try writer["Multiline"].write(value.multiline)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Paths"].writeList(value.paths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Recurse"].write(value.recurse)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3JsonSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3JsonSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.paths = try reader["Paths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.compressionType = try reader["CompressionType"].readIfPresent()
        value.exclusions = try reader["Exclusions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.groupSize = try reader["GroupSize"].readIfPresent()
        value.groupFiles = try reader["GroupFiles"].readIfPresent()
        value.recurse = try reader["Recurse"].readIfPresent()
        value.maxBand = try reader["MaxBand"].readIfPresent()
        value.maxFilesInBand = try reader["MaxFilesInBand"].readIfPresent()
        value.additionalOptions = try reader["AdditionalOptions"].readIfPresent(with: GlueClientTypes.S3DirectSourceAdditionalOptions.read(from:))
        value.jsonPath = try reader["JsonPath"].readIfPresent()
        value.multiline = try reader["Multiline"].readIfPresent()
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.S3CsvSource {

    static func write(value: GlueClientTypes.S3CsvSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOptions"].write(value.additionalOptions, with: GlueClientTypes.S3DirectSourceAdditionalOptions.write(value:to:))
        try writer["CompressionType"].write(value.compressionType)
        try writer["Escaper"].write(value.escaper)
        try writer["Exclusions"].writeList(value.exclusions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GroupFiles"].write(value.groupFiles)
        try writer["GroupSize"].write(value.groupSize)
        try writer["MaxBand"].write(value.maxBand)
        try writer["MaxFilesInBand"].write(value.maxFilesInBand)
        try writer["Multiline"].write(value.multiline)
        try writer["Name"].write(value.name)
        try writer["OptimizePerformance"].write(value.optimizePerformance)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Paths"].writeList(value.paths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QuoteChar"].write(value.quoteChar)
        try writer["Recurse"].write(value.recurse)
        try writer["Separator"].write(value.separator)
        try writer["SkipFirst"].write(value.skipFirst)
        try writer["WithHeader"].write(value.withHeader)
        try writer["WriteHeader"].write(value.writeHeader)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3CsvSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3CsvSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.paths = try reader["Paths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.compressionType = try reader["CompressionType"].readIfPresent()
        value.exclusions = try reader["Exclusions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.groupSize = try reader["GroupSize"].readIfPresent()
        value.groupFiles = try reader["GroupFiles"].readIfPresent()
        value.recurse = try reader["Recurse"].readIfPresent()
        value.maxBand = try reader["MaxBand"].readIfPresent()
        value.maxFilesInBand = try reader["MaxFilesInBand"].readIfPresent()
        value.additionalOptions = try reader["AdditionalOptions"].readIfPresent(with: GlueClientTypes.S3DirectSourceAdditionalOptions.read(from:))
        value.separator = try reader["Separator"].readIfPresent() ?? .sdkUnknown("")
        value.escaper = try reader["Escaper"].readIfPresent()
        value.quoteChar = try reader["QuoteChar"].readIfPresent() ?? .sdkUnknown("")
        value.multiline = try reader["Multiline"].readIfPresent()
        value.withHeader = try reader["WithHeader"].readIfPresent()
        value.writeHeader = try reader["WriteHeader"].readIfPresent()
        value.skipFirst = try reader["SkipFirst"].readIfPresent()
        value.optimizePerformance = try reader["OptimizePerformance"].readIfPresent() ?? false
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.S3CatalogSource {

    static func write(value: GlueClientTypes.S3CatalogSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOptions"].write(value.additionalOptions, with: GlueClientTypes.S3SourceAdditionalOptions.write(value:to:))
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["PartitionPredicate"].write(value.partitionPredicate)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3CatalogSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3CatalogSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.partitionPredicate = try reader["PartitionPredicate"].readIfPresent()
        value.additionalOptions = try reader["AdditionalOptions"].readIfPresent(with: GlueClientTypes.S3SourceAdditionalOptions.read(from:))
        return value
    }
}

extension GlueClientTypes.RedshiftSource {

    static func write(value: GlueClientTypes.RedshiftSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["RedshiftTmpDir"].write(value.redshiftTmpDir)
        try writer["Table"].write(value.table)
        try writer["TmpDirIAMRole"].write(value.tmpDirIAMRole)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.RedshiftSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.RedshiftSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        value.redshiftTmpDir = try reader["RedshiftTmpDir"].readIfPresent()
        value.tmpDirIAMRole = try reader["TmpDirIAMRole"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.CatalogSource {

    static func write(value: GlueClientTypes.CatalogSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Name"].write(value.name)
        try writer["Table"].write(value.table)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CatalogSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CatalogSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.table = try reader["Table"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.SparkConnectorSource {

    static func write(value: GlueClientTypes.SparkConnectorSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOptions"].writeMap(value.additionalOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ConnectionName"].write(value.connectionName)
        try writer["ConnectionType"].write(value.connectionType)
        try writer["ConnectorName"].write(value.connectorName)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SparkConnectorSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SparkConnectorSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.connectionName = try reader["ConnectionName"].readIfPresent() ?? ""
        value.connectorName = try reader["ConnectorName"].readIfPresent() ?? ""
        value.connectionType = try reader["ConnectionType"].readIfPresent() ?? ""
        value.additionalOptions = try reader["AdditionalOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.JDBCConnectorSource {

    static func write(value: GlueClientTypes.JDBCConnectorSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOptions"].write(value.additionalOptions, with: GlueClientTypes.JDBCConnectorOptions.write(value:to:))
        try writer["ConnectionName"].write(value.connectionName)
        try writer["ConnectionTable"].write(value.connectionTable)
        try writer["ConnectionType"].write(value.connectionType)
        try writer["ConnectorName"].write(value.connectorName)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Query"].write(value.query)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.JDBCConnectorSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.JDBCConnectorSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.connectionName = try reader["ConnectionName"].readIfPresent() ?? ""
        value.connectorName = try reader["ConnectorName"].readIfPresent() ?? ""
        value.connectionType = try reader["ConnectionType"].readIfPresent() ?? ""
        value.additionalOptions = try reader["AdditionalOptions"].readIfPresent(with: GlueClientTypes.JDBCConnectorOptions.read(from:))
        value.connectionTable = try reader["ConnectionTable"].readIfPresent()
        value.query = try reader["Query"].readIfPresent()
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.JDBCConnectorOptions {

    static func write(value: GlueClientTypes.JDBCConnectorOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataTypeMapping"].writeMap(value.dataTypeMapping, valueWritingClosure: SmithyReadWrite.WritingClosureBox<GlueClientTypes.GlueRecordType>().write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["FilterPredicate"].write(value.filterPredicate)
        try writer["JobBookmarkKeys"].writeList(value.jobBookmarkKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["JobBookmarkKeysSortOrder"].write(value.jobBookmarkKeysSortOrder)
        try writer["LowerBound"].write(value.lowerBound)
        try writer["NumPartitions"].write(value.numPartitions)
        try writer["PartitionColumn"].write(value.partitionColumn)
        try writer["UpperBound"].write(value.upperBound)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.JDBCConnectorOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.JDBCConnectorOptions()
        value.filterPredicate = try reader["FilterPredicate"].readIfPresent()
        value.partitionColumn = try reader["PartitionColumn"].readIfPresent()
        value.lowerBound = try reader["LowerBound"].readIfPresent()
        value.upperBound = try reader["UpperBound"].readIfPresent()
        value.numPartitions = try reader["NumPartitions"].readIfPresent()
        value.jobBookmarkKeys = try reader["JobBookmarkKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.jobBookmarkKeysSortOrder = try reader["JobBookmarkKeysSortOrder"].readIfPresent()
        value.dataTypeMapping = try reader["DataTypeMapping"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosureBox<GlueClientTypes.GlueRecordType>().read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.AthenaConnectorSource {

    static func write(value: GlueClientTypes.AthenaConnectorSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionName"].write(value.connectionName)
        try writer["ConnectionTable"].write(value.connectionTable)
        try writer["ConnectionType"].write(value.connectionType)
        try writer["ConnectorName"].write(value.connectorName)
        try writer["Name"].write(value.name)
        try writer["OutputSchemas"].writeList(value.outputSchemas, memberWritingClosure: GlueClientTypes.GlueSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SchemaName"].write(value.schemaName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.AthenaConnectorSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.AthenaConnectorSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.connectionName = try reader["ConnectionName"].readIfPresent() ?? ""
        value.connectorName = try reader["ConnectorName"].readIfPresent() ?? ""
        value.connectionType = try reader["ConnectionType"].readIfPresent() ?? ""
        value.connectionTable = try reader["ConnectionTable"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent() ?? ""
        value.outputSchemas = try reader["OutputSchemas"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.NotificationProperty {

    static func write(value: GlueClientTypes.NotificationProperty?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NotifyDelayAfter"].write(value.notifyDelayAfter)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.NotificationProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.NotificationProperty()
        value.notifyDelayAfter = try reader["NotifyDelayAfter"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.ConnectionsList {

    static func write(value: GlueClientTypes.ConnectionsList?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Connections"].writeList(value.connections, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ConnectionsList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ConnectionsList()
        value.connections = try reader["Connections"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.JobCommand {

    static func write(value: GlueClientTypes.JobCommand?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["PythonVersion"].write(value.pythonVersion)
        try writer["Runtime"].write(value.runtime)
        try writer["ScriptLocation"].write(value.scriptLocation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.JobCommand {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.JobCommand()
        value.name = try reader["Name"].readIfPresent()
        value.scriptLocation = try reader["ScriptLocation"].readIfPresent()
        value.pythonVersion = try reader["PythonVersion"].readIfPresent()
        value.runtime = try reader["Runtime"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.ExecutionProperty {

    static func write(value: GlueClientTypes.ExecutionProperty?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxConcurrentRuns"].write(value.maxConcurrentRuns)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ExecutionProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ExecutionProperty()
        value.maxConcurrentRuns = try reader["MaxConcurrentRuns"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.Partition {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Partition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Partition()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastAccessTime = try reader["LastAccessTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.storageDescriptor = try reader["StorageDescriptor"].readIfPresent(with: GlueClientTypes.StorageDescriptor.read(from:))
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastAnalyzedTime = try reader["LastAnalyzedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.catalogId = try reader["CatalogId"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.StorageDescriptor {

    static func write(value: GlueClientTypes.StorageDescriptor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalLocations"].writeList(value.additionalLocations, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BucketColumns"].writeList(value.bucketColumns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Columns"].writeList(value.columns, memberWritingClosure: GlueClientTypes.Column.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Compressed"].write(value.compressed)
        try writer["InputFormat"].write(value.inputFormat)
        try writer["Location"].write(value.location)
        try writer["NumberOfBuckets"].write(value.numberOfBuckets)
        try writer["OutputFormat"].write(value.outputFormat)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SchemaReference"].write(value.schemaReference, with: GlueClientTypes.SchemaReference.write(value:to:))
        try writer["SerdeInfo"].write(value.serdeInfo, with: GlueClientTypes.SerDeInfo.write(value:to:))
        try writer["SkewedInfo"].write(value.skewedInfo, with: GlueClientTypes.SkewedInfo.write(value:to:))
        try writer["SortColumns"].writeList(value.sortColumns, memberWritingClosure: GlueClientTypes.Order.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StoredAsSubDirectories"].write(value.storedAsSubDirectories)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.StorageDescriptor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.StorageDescriptor()
        value.columns = try reader["Columns"].readListIfPresent(memberReadingClosure: GlueClientTypes.Column.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.location = try reader["Location"].readIfPresent()
        value.additionalLocations = try reader["AdditionalLocations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.inputFormat = try reader["InputFormat"].readIfPresent()
        value.outputFormat = try reader["OutputFormat"].readIfPresent()
        value.compressed = try reader["Compressed"].readIfPresent() ?? false
        value.numberOfBuckets = try reader["NumberOfBuckets"].readIfPresent() ?? 0
        value.serdeInfo = try reader["SerdeInfo"].readIfPresent(with: GlueClientTypes.SerDeInfo.read(from:))
        value.bucketColumns = try reader["BucketColumns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sortColumns = try reader["SortColumns"].readListIfPresent(memberReadingClosure: GlueClientTypes.Order.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.skewedInfo = try reader["SkewedInfo"].readIfPresent(with: GlueClientTypes.SkewedInfo.read(from:))
        value.storedAsSubDirectories = try reader["StoredAsSubDirectories"].readIfPresent() ?? false
        value.schemaReference = try reader["SchemaReference"].readIfPresent(with: GlueClientTypes.SchemaReference.read(from:))
        return value
    }
}

extension GlueClientTypes.SchemaReference {

    static func write(value: GlueClientTypes.SchemaReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SchemaId"].write(value.schemaId, with: GlueClientTypes.SchemaId.write(value:to:))
        try writer["SchemaVersionId"].write(value.schemaVersionId)
        try writer["SchemaVersionNumber"].write(value.schemaVersionNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SchemaReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SchemaReference()
        value.schemaId = try reader["SchemaId"].readIfPresent(with: GlueClientTypes.SchemaId.read(from:))
        value.schemaVersionId = try reader["SchemaVersionId"].readIfPresent()
        value.schemaVersionNumber = try reader["SchemaVersionNumber"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.SchemaId {

    static func write(value: GlueClientTypes.SchemaId?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RegistryName"].write(value.registryName)
        try writer["SchemaArn"].write(value.schemaArn)
        try writer["SchemaName"].write(value.schemaName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SchemaId {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SchemaId()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.SkewedInfo {

    static func write(value: GlueClientTypes.SkewedInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SkewedColumnNames"].writeList(value.skewedColumnNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SkewedColumnValueLocationMaps"].writeMap(value.skewedColumnValueLocationMaps, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SkewedColumnValues"].writeList(value.skewedColumnValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SkewedInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SkewedInfo()
        value.skewedColumnNames = try reader["SkewedColumnNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.skewedColumnValues = try reader["SkewedColumnValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.skewedColumnValueLocationMaps = try reader["SkewedColumnValueLocationMaps"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.Order {

    static func write(value: GlueClientTypes.Order?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column)
        try writer["SortOrder"].write(value.sortOrder)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Order {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Order()
        value.column = try reader["Column"].readIfPresent() ?? ""
        value.sortOrder = try reader["SortOrder"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.SerDeInfo {

    static func write(value: GlueClientTypes.SerDeInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SerializationLibrary"].write(value.serializationLibrary)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SerDeInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SerDeInfo()
        value.name = try reader["Name"].readIfPresent()
        value.serializationLibrary = try reader["SerializationLibrary"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.Column {

    static func write(value: GlueClientTypes.Column?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Comment"].write(value.comment)
        try writer["Name"].write(value.name)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Column {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Column()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent()
        value.comment = try reader["Comment"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.PartitionValueList {

    static func write(value: GlueClientTypes.PartitionValueList?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.PartitionValueList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.PartitionValueList()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GlueClientTypes.BatchTableOptimizer {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.BatchTableOptimizer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.BatchTableOptimizer()
        value.catalogId = try reader["catalogId"].readIfPresent()
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.tableName = try reader["tableName"].readIfPresent()
        value.tableOptimizer = try reader["tableOptimizer"].readIfPresent(with: GlueClientTypes.TableOptimizer.read(from:))
        return value
    }
}

extension GlueClientTypes.TableOptimizer {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TableOptimizer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TableOptimizer()
        value.type = try reader["type"].readIfPresent()
        value.configuration = try reader["configuration"].readIfPresent(with: GlueClientTypes.TableOptimizerConfiguration.read(from:))
        value.lastRun = try reader["lastRun"].readIfPresent(with: GlueClientTypes.TableOptimizerRun.read(from:))
        return value
    }
}

extension GlueClientTypes.TableOptimizerRun {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TableOptimizerRun {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TableOptimizerRun()
        value.eventType = try reader["eventType"].readIfPresent()
        value.startTimestamp = try reader["startTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTimestamp = try reader["endTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.metrics = try reader["metrics"].readIfPresent(with: GlueClientTypes.RunMetrics.read(from:))
        value.error = try reader["error"].readIfPresent()
        value.compactionMetrics = try reader["compactionMetrics"].readIfPresent(with: GlueClientTypes.CompactionMetrics.read(from:))
        value.retentionMetrics = try reader["retentionMetrics"].readIfPresent(with: GlueClientTypes.RetentionMetrics.read(from:))
        value.orphanFileDeletionMetrics = try reader["orphanFileDeletionMetrics"].readIfPresent(with: GlueClientTypes.OrphanFileDeletionMetrics.read(from:))
        return value
    }
}

extension GlueClientTypes.OrphanFileDeletionMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.OrphanFileDeletionMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.OrphanFileDeletionMetrics()
        value.icebergMetrics = try reader["IcebergMetrics"].readIfPresent(with: GlueClientTypes.IcebergOrphanFileDeletionMetrics.read(from:))
        return value
    }
}

extension GlueClientTypes.IcebergOrphanFileDeletionMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.IcebergOrphanFileDeletionMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.IcebergOrphanFileDeletionMetrics()
        value.numberOfOrphanFilesDeleted = try reader["NumberOfOrphanFilesDeleted"].readIfPresent() ?? 0
        value.numberOfDpus = try reader["NumberOfDpus"].readIfPresent() ?? 0
        value.jobDurationInHour = try reader["JobDurationInHour"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.RetentionMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.RetentionMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.RetentionMetrics()
        value.icebergMetrics = try reader["IcebergMetrics"].readIfPresent(with: GlueClientTypes.IcebergRetentionMetrics.read(from:))
        return value
    }
}

extension GlueClientTypes.IcebergRetentionMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.IcebergRetentionMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.IcebergRetentionMetrics()
        value.numberOfDataFilesDeleted = try reader["NumberOfDataFilesDeleted"].readIfPresent() ?? 0
        value.numberOfManifestFilesDeleted = try reader["NumberOfManifestFilesDeleted"].readIfPresent() ?? 0
        value.numberOfManifestListsDeleted = try reader["NumberOfManifestListsDeleted"].readIfPresent() ?? 0
        value.numberOfDpus = try reader["NumberOfDpus"].readIfPresent() ?? 0
        value.jobDurationInHour = try reader["JobDurationInHour"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.CompactionMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CompactionMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CompactionMetrics()
        value.icebergMetrics = try reader["IcebergMetrics"].readIfPresent(with: GlueClientTypes.IcebergCompactionMetrics.read(from:))
        return value
    }
}

extension GlueClientTypes.IcebergCompactionMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.IcebergCompactionMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.IcebergCompactionMetrics()
        value.numberOfBytesCompacted = try reader["NumberOfBytesCompacted"].readIfPresent() ?? 0
        value.numberOfFilesCompacted = try reader["NumberOfFilesCompacted"].readIfPresent() ?? 0
        value.numberOfDpus = try reader["NumberOfDpus"].readIfPresent() ?? 0
        value.jobDurationInHour = try reader["JobDurationInHour"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.RunMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.RunMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.RunMetrics()
        value.numberOfBytesCompacted = try reader["NumberOfBytesCompacted"].readIfPresent()
        value.numberOfFilesCompacted = try reader["NumberOfFilesCompacted"].readIfPresent()
        value.numberOfDpus = try reader["NumberOfDpus"].readIfPresent()
        value.jobDurationInHour = try reader["JobDurationInHour"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.TableOptimizerConfiguration {

    static func write(value: GlueClientTypes.TableOptimizerConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["orphanFileDeletionConfiguration"].write(value.orphanFileDeletionConfiguration, with: GlueClientTypes.OrphanFileDeletionConfiguration.write(value:to:))
        try writer["retentionConfiguration"].write(value.retentionConfiguration, with: GlueClientTypes.RetentionConfiguration.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TableOptimizerConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TableOptimizerConfiguration()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.retentionConfiguration = try reader["retentionConfiguration"].readIfPresent(with: GlueClientTypes.RetentionConfiguration.read(from:))
        value.orphanFileDeletionConfiguration = try reader["orphanFileDeletionConfiguration"].readIfPresent(with: GlueClientTypes.OrphanFileDeletionConfiguration.read(from:))
        return value
    }
}

extension GlueClientTypes.OrphanFileDeletionConfiguration {

    static func write(value: GlueClientTypes.OrphanFileDeletionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["icebergConfiguration"].write(value.icebergConfiguration, with: GlueClientTypes.IcebergOrphanFileDeletionConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.OrphanFileDeletionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.OrphanFileDeletionConfiguration()
        value.icebergConfiguration = try reader["icebergConfiguration"].readIfPresent(with: GlueClientTypes.IcebergOrphanFileDeletionConfiguration.read(from:))
        return value
    }
}

extension GlueClientTypes.IcebergOrphanFileDeletionConfiguration {

    static func write(value: GlueClientTypes.IcebergOrphanFileDeletionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["location"].write(value.location)
        try writer["orphanFileRetentionPeriodInDays"].write(value.orphanFileRetentionPeriodInDays)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.IcebergOrphanFileDeletionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.IcebergOrphanFileDeletionConfiguration()
        value.orphanFileRetentionPeriodInDays = try reader["orphanFileRetentionPeriodInDays"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.RetentionConfiguration {

    static func write(value: GlueClientTypes.RetentionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["icebergConfiguration"].write(value.icebergConfiguration, with: GlueClientTypes.IcebergRetentionConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.RetentionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.RetentionConfiguration()
        value.icebergConfiguration = try reader["icebergConfiguration"].readIfPresent(with: GlueClientTypes.IcebergRetentionConfiguration.read(from:))
        return value
    }
}

extension GlueClientTypes.IcebergRetentionConfiguration {

    static func write(value: GlueClientTypes.IcebergRetentionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cleanExpiredFiles"].write(value.cleanExpiredFiles)
        try writer["numberOfSnapshotsToRetain"].write(value.numberOfSnapshotsToRetain)
        try writer["snapshotRetentionPeriodInDays"].write(value.snapshotRetentionPeriodInDays)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.IcebergRetentionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.IcebergRetentionConfiguration()
        value.snapshotRetentionPeriodInDays = try reader["snapshotRetentionPeriodInDays"].readIfPresent()
        value.numberOfSnapshotsToRetain = try reader["numberOfSnapshotsToRetain"].readIfPresent()
        value.cleanExpiredFiles = try reader["cleanExpiredFiles"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.BatchGetTableOptimizerError {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.BatchGetTableOptimizerError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.BatchGetTableOptimizerError()
        value.error = try reader["error"].readIfPresent(with: GlueClientTypes.ErrorDetail.read(from:))
        value.catalogId = try reader["catalogId"].readIfPresent()
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.tableName = try reader["tableName"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.Trigger {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Trigger {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Trigger()
        value.name = try reader["Name"].readIfPresent()
        value.workflowName = try reader["WorkflowName"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.schedule = try reader["Schedule"].readIfPresent()
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: GlueClientTypes.Action.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.predicate = try reader["Predicate"].readIfPresent(with: GlueClientTypes.Predicate.read(from:))
        value.eventBatchingCondition = try reader["EventBatchingCondition"].readIfPresent(with: GlueClientTypes.EventBatchingCondition.read(from:))
        return value
    }
}

extension GlueClientTypes.EventBatchingCondition {

    static func write(value: GlueClientTypes.EventBatchingCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BatchSize"].write(value.batchSize)
        try writer["BatchWindow"].write(value.batchWindow)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.EventBatchingCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.EventBatchingCondition()
        value.batchSize = try reader["BatchSize"].readIfPresent() ?? 0
        value.batchWindow = try reader["BatchWindow"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.Predicate {

    static func write(value: GlueClientTypes.Predicate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Conditions"].writeList(value.conditions, memberWritingClosure: GlueClientTypes.Condition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Logical"].write(value.logical)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Predicate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Predicate()
        value.logical = try reader["Logical"].readIfPresent()
        value.conditions = try reader["Conditions"].readListIfPresent(memberReadingClosure: GlueClientTypes.Condition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.Condition {

    static func write(value: GlueClientTypes.Condition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrawlState"].write(value.crawlState)
        try writer["CrawlerName"].write(value.crawlerName)
        try writer["JobName"].write(value.jobName)
        try writer["LogicalOperator"].write(value.logicalOperator)
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Condition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Condition()
        value.logicalOperator = try reader["LogicalOperator"].readIfPresent()
        value.jobName = try reader["JobName"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.crawlerName = try reader["CrawlerName"].readIfPresent()
        value.crawlState = try reader["CrawlState"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.Action {

    static func write(value: GlueClientTypes.Action?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arguments"].writeMap(value.arguments, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["CrawlerName"].write(value.crawlerName)
        try writer["JobName"].write(value.jobName)
        try writer["NotificationProperty"].write(value.notificationProperty, with: GlueClientTypes.NotificationProperty.write(value:to:))
        try writer["SecurityConfiguration"].write(value.securityConfiguration)
        try writer["Timeout"].write(value.timeout)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Action()
        value.jobName = try reader["JobName"].readIfPresent()
        value.arguments = try reader["Arguments"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.timeout = try reader["Timeout"].readIfPresent()
        value.securityConfiguration = try reader["SecurityConfiguration"].readIfPresent()
        value.notificationProperty = try reader["NotificationProperty"].readIfPresent(with: GlueClientTypes.NotificationProperty.read(from:))
        value.crawlerName = try reader["CrawlerName"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.Workflow {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Workflow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Workflow()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.defaultRunProperties = try reader["DefaultRunProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdOn = try reader["CreatedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastRun = try reader["LastRun"].readIfPresent(with: GlueClientTypes.WorkflowRun.read(from:))
        value.graph = try reader["Graph"].readIfPresent(with: GlueClientTypes.WorkflowGraph.read(from:))
        value.maxConcurrentRuns = try reader["MaxConcurrentRuns"].readIfPresent()
        value.blueprintDetails = try reader["BlueprintDetails"].readIfPresent(with: GlueClientTypes.BlueprintDetails.read(from:))
        return value
    }
}

extension GlueClientTypes.BlueprintDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.BlueprintDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.BlueprintDetails()
        value.blueprintName = try reader["BlueprintName"].readIfPresent()
        value.runId = try reader["RunId"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.WorkflowGraph {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.WorkflowGraph {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.WorkflowGraph()
        value.nodes = try reader["Nodes"].readListIfPresent(memberReadingClosure: GlueClientTypes.Node.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.edges = try reader["Edges"].readListIfPresent(memberReadingClosure: GlueClientTypes.Edge.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.Edge {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Edge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Edge()
        value.sourceId = try reader["SourceId"].readIfPresent()
        value.destinationId = try reader["DestinationId"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.Node {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Node {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Node()
        value.type = try reader["Type"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.uniqueId = try reader["UniqueId"].readIfPresent()
        value.triggerDetails = try reader["TriggerDetails"].readIfPresent(with: GlueClientTypes.TriggerNodeDetails.read(from:))
        value.jobDetails = try reader["JobDetails"].readIfPresent(with: GlueClientTypes.JobNodeDetails.read(from:))
        value.crawlerDetails = try reader["CrawlerDetails"].readIfPresent(with: GlueClientTypes.CrawlerNodeDetails.read(from:))
        return value
    }
}

extension GlueClientTypes.CrawlerNodeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CrawlerNodeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CrawlerNodeDetails()
        value.crawls = try reader["Crawls"].readListIfPresent(memberReadingClosure: GlueClientTypes.Crawl.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.Crawl {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Crawl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Crawl()
        value.state = try reader["State"].readIfPresent()
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completedOn = try reader["CompletedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.logGroup = try reader["LogGroup"].readIfPresent()
        value.logStream = try reader["LogStream"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.JobNodeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.JobNodeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.JobNodeDetails()
        value.jobRuns = try reader["JobRuns"].readListIfPresent(memberReadingClosure: GlueClientTypes.JobRun.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.JobRun {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.JobRun {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.JobRun()
        value.id = try reader["Id"].readIfPresent()
        value.attempt = try reader["Attempt"].readIfPresent() ?? 0
        value.previousRunId = try reader["PreviousRunId"].readIfPresent()
        value.triggerName = try reader["TriggerName"].readIfPresent()
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobMode = try reader["JobMode"].readIfPresent()
        value.jobRunQueuingEnabled = try reader["JobRunQueuingEnabled"].readIfPresent()
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completedOn = try reader["CompletedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobRunState = try reader["JobRunState"].readIfPresent()
        value.arguments = try reader["Arguments"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.predecessorRuns = try reader["PredecessorRuns"].readListIfPresent(memberReadingClosure: GlueClientTypes.Predecessor.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.allocatedCapacity = try reader["AllocatedCapacity"].readIfPresent() ?? 0
        value.executionTime = try reader["ExecutionTime"].readIfPresent() ?? 0
        value.timeout = try reader["Timeout"].readIfPresent()
        value.maxCapacity = try reader["MaxCapacity"].readIfPresent()
        value.workerType = try reader["WorkerType"].readIfPresent()
        value.numberOfWorkers = try reader["NumberOfWorkers"].readIfPresent()
        value.securityConfiguration = try reader["SecurityConfiguration"].readIfPresent()
        value.logGroupName = try reader["LogGroupName"].readIfPresent()
        value.notificationProperty = try reader["NotificationProperty"].readIfPresent(with: GlueClientTypes.NotificationProperty.read(from:))
        value.glueVersion = try reader["GlueVersion"].readIfPresent()
        value.dpuSeconds = try reader["DPUSeconds"].readIfPresent()
        value.executionClass = try reader["ExecutionClass"].readIfPresent()
        value.maintenanceWindow = try reader["MaintenanceWindow"].readIfPresent()
        value.profileName = try reader["ProfileName"].readIfPresent()
        value.stateDetail = try reader["StateDetail"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.Predecessor {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Predecessor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Predecessor()
        value.jobName = try reader["JobName"].readIfPresent()
        value.runId = try reader["RunId"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.TriggerNodeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TriggerNodeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TriggerNodeDetails()
        value.trigger = try reader["Trigger"].readIfPresent(with: GlueClientTypes.Trigger.read(from:))
        return value
    }
}

extension GlueClientTypes.WorkflowRun {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.WorkflowRun {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.WorkflowRun()
        value.name = try reader["Name"].readIfPresent()
        value.workflowRunId = try reader["WorkflowRunId"].readIfPresent()
        value.previousRunId = try reader["PreviousRunId"].readIfPresent()
        value.workflowRunProperties = try reader["WorkflowRunProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completedOn = try reader["CompletedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.statistics = try reader["Statistics"].readIfPresent(with: GlueClientTypes.WorkflowRunStatistics.read(from:))
        value.graph = try reader["Graph"].readIfPresent(with: GlueClientTypes.WorkflowGraph.read(from:))
        value.startingEventBatchCondition = try reader["StartingEventBatchCondition"].readIfPresent(with: GlueClientTypes.StartingEventBatchCondition.read(from:))
        return value
    }
}

extension GlueClientTypes.StartingEventBatchCondition {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.StartingEventBatchCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.StartingEventBatchCondition()
        value.batchSize = try reader["BatchSize"].readIfPresent()
        value.batchWindow = try reader["BatchWindow"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.WorkflowRunStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.WorkflowRunStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.WorkflowRunStatistics()
        value.totalActions = try reader["TotalActions"].readIfPresent() ?? 0
        value.timeoutActions = try reader["TimeoutActions"].readIfPresent() ?? 0
        value.failedActions = try reader["FailedActions"].readIfPresent() ?? 0
        value.stoppedActions = try reader["StoppedActions"].readIfPresent() ?? 0
        value.succeededActions = try reader["SucceededActions"].readIfPresent() ?? 0
        value.runningActions = try reader["RunningActions"].readIfPresent() ?? 0
        value.erroredActions = try reader["ErroredActions"].readIfPresent() ?? 0
        value.waitingActions = try reader["WaitingActions"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.AnnotationError {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.AnnotationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.AnnotationError()
        value.profileId = try reader["ProfileId"].readIfPresent()
        value.statisticId = try reader["StatisticId"].readIfPresent()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.BatchStopJobRunSuccessfulSubmission {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.BatchStopJobRunSuccessfulSubmission {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.BatchStopJobRunSuccessfulSubmission()
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobRunId = try reader["JobRunId"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.BatchStopJobRunError {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.BatchStopJobRunError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.BatchStopJobRunError()
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobRunId = try reader["JobRunId"].readIfPresent()
        value.errorDetail = try reader["ErrorDetail"].readIfPresent(with: GlueClientTypes.ErrorDetail.read(from:))
        return value
    }
}

extension GlueClientTypes.BatchUpdatePartitionFailureEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.BatchUpdatePartitionFailureEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.BatchUpdatePartitionFailureEntry()
        value.partitionValueList = try reader["PartitionValueList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorDetail = try reader["ErrorDetail"].readIfPresent(with: GlueClientTypes.ErrorDetail.read(from:))
        return value
    }
}

extension GlueClientTypes.Session {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Session {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Session()
        value.id = try reader["Id"].readIfPresent()
        value.createdOn = try reader["CreatedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.command = try reader["Command"].readIfPresent(with: GlueClientTypes.SessionCommand.read(from:))
        value.defaultArguments = try reader["DefaultArguments"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.connections = try reader["Connections"].readIfPresent(with: GlueClientTypes.ConnectionsList.read(from:))
        value.progress = try reader["Progress"].readIfPresent() ?? 0
        value.maxCapacity = try reader["MaxCapacity"].readIfPresent()
        value.securityConfiguration = try reader["SecurityConfiguration"].readIfPresent()
        value.glueVersion = try reader["GlueVersion"].readIfPresent()
        value.numberOfWorkers = try reader["NumberOfWorkers"].readIfPresent()
        value.workerType = try reader["WorkerType"].readIfPresent()
        value.completedOn = try reader["CompletedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.executionTime = try reader["ExecutionTime"].readIfPresent()
        value.dpuSeconds = try reader["DPUSeconds"].readIfPresent()
        value.idleTimeout = try reader["IdleTimeout"].readIfPresent()
        value.profileName = try reader["ProfileName"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.SessionCommand {

    static func write(value: GlueClientTypes.SessionCommand?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["PythonVersion"].write(value.pythonVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SessionCommand {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SessionCommand()
        value.name = try reader["Name"].readIfPresent()
        value.pythonVersion = try reader["PythonVersion"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.SchemaVersionErrorItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SchemaVersionErrorItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SchemaVersionErrorItem()
        value.versionNumber = try reader["VersionNumber"].readIfPresent()
        value.errorDetails = try reader["ErrorDetails"].readIfPresent(with: GlueClientTypes.ErrorDetails.read(from:))
        return value
    }
}

extension GlueClientTypes.ErrorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ErrorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ErrorDetails()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.BlueprintRun {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.BlueprintRun {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.BlueprintRun()
        value.blueprintName = try reader["BlueprintName"].readIfPresent()
        value.runId = try reader["RunId"].readIfPresent()
        value.workflowName = try reader["WorkflowName"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completedOn = try reader["CompletedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.rollbackErrorMessage = try reader["RollbackErrorMessage"].readIfPresent()
        value.parameters = try reader["Parameters"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.CatalogImportStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CatalogImportStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CatalogImportStatus()
        value.importCompleted = try reader["ImportCompleted"].readIfPresent() ?? false
        value.importTime = try reader["ImportTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.importedBy = try reader["ImportedBy"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.Classifier {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Classifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Classifier()
        value.grokClassifier = try reader["GrokClassifier"].readIfPresent(with: GlueClientTypes.GrokClassifier.read(from:))
        value.xmlClassifier = try reader["XMLClassifier"].readIfPresent(with: GlueClientTypes.XMLClassifier.read(from:))
        value.jsonClassifier = try reader["JsonClassifier"].readIfPresent(with: GlueClientTypes.JsonClassifier.read(from:))
        value.csvClassifier = try reader["CsvClassifier"].readIfPresent(with: GlueClientTypes.CsvClassifier.read(from:))
        return value
    }
}

extension GlueClientTypes.CsvClassifier {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CsvClassifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CsvClassifier()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.delimiter = try reader["Delimiter"].readIfPresent()
        value.quoteSymbol = try reader["QuoteSymbol"].readIfPresent()
        value.containsHeader = try reader["ContainsHeader"].readIfPresent()
        value.header = try reader["Header"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.disableValueTrimming = try reader["DisableValueTrimming"].readIfPresent()
        value.allowSingleColumn = try reader["AllowSingleColumn"].readIfPresent()
        value.customDatatypeConfigured = try reader["CustomDatatypeConfigured"].readIfPresent()
        value.customDatatypes = try reader["CustomDatatypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.serde = try reader["Serde"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.JsonClassifier {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.JsonClassifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.JsonClassifier()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.jsonPath = try reader["JsonPath"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.XMLClassifier {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.XMLClassifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.XMLClassifier()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.classification = try reader["Classification"].readIfPresent() ?? ""
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.rowTag = try reader["RowTag"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.GrokClassifier {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.GrokClassifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.GrokClassifier()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.classification = try reader["Classification"].readIfPresent() ?? ""
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.grokPattern = try reader["GrokPattern"].readIfPresent() ?? ""
        value.customPatterns = try reader["CustomPatterns"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.ColumnStatistics {

    static func write(value: GlueClientTypes.ColumnStatistics?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnalyzedTime"].writeTimestamp(value.analyzedTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ColumnName"].write(value.columnName)
        try writer["ColumnType"].write(value.columnType)
        try writer["StatisticsData"].write(value.statisticsData, with: GlueClientTypes.ColumnStatisticsData.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ColumnStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ColumnStatistics()
        value.columnName = try reader["ColumnName"].readIfPresent() ?? ""
        value.columnType = try reader["ColumnType"].readIfPresent() ?? ""
        value.analyzedTime = try reader["AnalyzedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.statisticsData = try reader["StatisticsData"].readIfPresent(with: GlueClientTypes.ColumnStatisticsData.read(from:))
        return value
    }
}

extension GlueClientTypes.ColumnStatisticsData {

    static func write(value: GlueClientTypes.ColumnStatisticsData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BinaryColumnStatisticsData"].write(value.binaryColumnStatisticsData, with: GlueClientTypes.BinaryColumnStatisticsData.write(value:to:))
        try writer["BooleanColumnStatisticsData"].write(value.booleanColumnStatisticsData, with: GlueClientTypes.BooleanColumnStatisticsData.write(value:to:))
        try writer["DateColumnStatisticsData"].write(value.dateColumnStatisticsData, with: GlueClientTypes.DateColumnStatisticsData.write(value:to:))
        try writer["DecimalColumnStatisticsData"].write(value.decimalColumnStatisticsData, with: GlueClientTypes.DecimalColumnStatisticsData.write(value:to:))
        try writer["DoubleColumnStatisticsData"].write(value.doubleColumnStatisticsData, with: GlueClientTypes.DoubleColumnStatisticsData.write(value:to:))
        try writer["LongColumnStatisticsData"].write(value.longColumnStatisticsData, with: GlueClientTypes.LongColumnStatisticsData.write(value:to:))
        try writer["StringColumnStatisticsData"].write(value.stringColumnStatisticsData, with: GlueClientTypes.StringColumnStatisticsData.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ColumnStatisticsData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ColumnStatisticsData()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.booleanColumnStatisticsData = try reader["BooleanColumnStatisticsData"].readIfPresent(with: GlueClientTypes.BooleanColumnStatisticsData.read(from:))
        value.dateColumnStatisticsData = try reader["DateColumnStatisticsData"].readIfPresent(with: GlueClientTypes.DateColumnStatisticsData.read(from:))
        value.decimalColumnStatisticsData = try reader["DecimalColumnStatisticsData"].readIfPresent(with: GlueClientTypes.DecimalColumnStatisticsData.read(from:))
        value.doubleColumnStatisticsData = try reader["DoubleColumnStatisticsData"].readIfPresent(with: GlueClientTypes.DoubleColumnStatisticsData.read(from:))
        value.longColumnStatisticsData = try reader["LongColumnStatisticsData"].readIfPresent(with: GlueClientTypes.LongColumnStatisticsData.read(from:))
        value.stringColumnStatisticsData = try reader["StringColumnStatisticsData"].readIfPresent(with: GlueClientTypes.StringColumnStatisticsData.read(from:))
        value.binaryColumnStatisticsData = try reader["BinaryColumnStatisticsData"].readIfPresent(with: GlueClientTypes.BinaryColumnStatisticsData.read(from:))
        return value
    }
}

extension GlueClientTypes.BinaryColumnStatisticsData {

    static func write(value: GlueClientTypes.BinaryColumnStatisticsData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AverageLength"].write(value.averageLength)
        try writer["MaximumLength"].write(value.maximumLength)
        try writer["NumberOfNulls"].write(value.numberOfNulls)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.BinaryColumnStatisticsData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.BinaryColumnStatisticsData()
        value.maximumLength = try reader["MaximumLength"].readIfPresent() ?? 0
        value.averageLength = try reader["AverageLength"].readIfPresent() ?? 0
        value.numberOfNulls = try reader["NumberOfNulls"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.StringColumnStatisticsData {

    static func write(value: GlueClientTypes.StringColumnStatisticsData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AverageLength"].write(value.averageLength)
        try writer["MaximumLength"].write(value.maximumLength)
        try writer["NumberOfDistinctValues"].write(value.numberOfDistinctValues)
        try writer["NumberOfNulls"].write(value.numberOfNulls)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.StringColumnStatisticsData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.StringColumnStatisticsData()
        value.maximumLength = try reader["MaximumLength"].readIfPresent() ?? 0
        value.averageLength = try reader["AverageLength"].readIfPresent() ?? 0
        value.numberOfNulls = try reader["NumberOfNulls"].readIfPresent() ?? 0
        value.numberOfDistinctValues = try reader["NumberOfDistinctValues"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.LongColumnStatisticsData {

    static func write(value: GlueClientTypes.LongColumnStatisticsData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaximumValue"].write(value.maximumValue)
        try writer["MinimumValue"].write(value.minimumValue)
        try writer["NumberOfDistinctValues"].write(value.numberOfDistinctValues)
        try writer["NumberOfNulls"].write(value.numberOfNulls)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.LongColumnStatisticsData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.LongColumnStatisticsData()
        value.minimumValue = try reader["MinimumValue"].readIfPresent() ?? 0
        value.maximumValue = try reader["MaximumValue"].readIfPresent() ?? 0
        value.numberOfNulls = try reader["NumberOfNulls"].readIfPresent() ?? 0
        value.numberOfDistinctValues = try reader["NumberOfDistinctValues"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.DoubleColumnStatisticsData {

    static func write(value: GlueClientTypes.DoubleColumnStatisticsData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaximumValue"].write(value.maximumValue)
        try writer["MinimumValue"].write(value.minimumValue)
        try writer["NumberOfDistinctValues"].write(value.numberOfDistinctValues)
        try writer["NumberOfNulls"].write(value.numberOfNulls)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DoubleColumnStatisticsData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DoubleColumnStatisticsData()
        value.minimumValue = try reader["MinimumValue"].readIfPresent() ?? 0
        value.maximumValue = try reader["MaximumValue"].readIfPresent() ?? 0
        value.numberOfNulls = try reader["NumberOfNulls"].readIfPresent() ?? 0
        value.numberOfDistinctValues = try reader["NumberOfDistinctValues"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.DecimalColumnStatisticsData {

    static func write(value: GlueClientTypes.DecimalColumnStatisticsData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaximumValue"].write(value.maximumValue, with: GlueClientTypes.DecimalNumber.write(value:to:))
        try writer["MinimumValue"].write(value.minimumValue, with: GlueClientTypes.DecimalNumber.write(value:to:))
        try writer["NumberOfDistinctValues"].write(value.numberOfDistinctValues)
        try writer["NumberOfNulls"].write(value.numberOfNulls)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DecimalColumnStatisticsData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DecimalColumnStatisticsData()
        value.minimumValue = try reader["MinimumValue"].readIfPresent(with: GlueClientTypes.DecimalNumber.read(from:))
        value.maximumValue = try reader["MaximumValue"].readIfPresent(with: GlueClientTypes.DecimalNumber.read(from:))
        value.numberOfNulls = try reader["NumberOfNulls"].readIfPresent() ?? 0
        value.numberOfDistinctValues = try reader["NumberOfDistinctValues"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.DecimalNumber {

    static func write(value: GlueClientTypes.DecimalNumber?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Scale"].write(value.scale)
        try writer["UnscaledValue"].write(value.unscaledValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DecimalNumber {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DecimalNumber()
        value.unscaledValue = try reader["UnscaledValue"].readIfPresent() ?? Foundation.Data("".utf8)
        value.scale = try reader["Scale"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.DateColumnStatisticsData {

    static func write(value: GlueClientTypes.DateColumnStatisticsData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaximumValue"].writeTimestamp(value.maximumValue, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["MinimumValue"].writeTimestamp(value.minimumValue, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["NumberOfDistinctValues"].write(value.numberOfDistinctValues)
        try writer["NumberOfNulls"].write(value.numberOfNulls)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DateColumnStatisticsData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DateColumnStatisticsData()
        value.minimumValue = try reader["MinimumValue"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maximumValue = try reader["MaximumValue"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.numberOfNulls = try reader["NumberOfNulls"].readIfPresent() ?? 0
        value.numberOfDistinctValues = try reader["NumberOfDistinctValues"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.BooleanColumnStatisticsData {

    static func write(value: GlueClientTypes.BooleanColumnStatisticsData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NumberOfFalses"].write(value.numberOfFalses)
        try writer["NumberOfNulls"].write(value.numberOfNulls)
        try writer["NumberOfTrues"].write(value.numberOfTrues)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.BooleanColumnStatisticsData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.BooleanColumnStatisticsData()
        value.numberOfTrues = try reader["NumberOfTrues"].readIfPresent() ?? 0
        value.numberOfFalses = try reader["NumberOfFalses"].readIfPresent() ?? 0
        value.numberOfNulls = try reader["NumberOfNulls"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.ColumnError {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ColumnError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ColumnError()
        value.columnName = try reader["ColumnName"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: GlueClientTypes.ErrorDetail.read(from:))
        return value
    }
}

extension GlueClientTypes.ColumnStatisticsTaskRun {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ColumnStatisticsTaskRun {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ColumnStatisticsTaskRun()
        value.customerId = try reader["CustomerId"].readIfPresent()
        value.columnStatisticsTaskRunId = try reader["ColumnStatisticsTaskRunId"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        value.columnNameList = try reader["ColumnNameList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.catalogID = try reader["CatalogID"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.sampleSize = try reader["SampleSize"].readIfPresent() ?? 0
        value.securityConfiguration = try reader["SecurityConfiguration"].readIfPresent()
        value.numberOfWorkers = try reader["NumberOfWorkers"].readIfPresent() ?? 0
        value.workerType = try reader["WorkerType"].readIfPresent()
        value.computationType = try reader["ComputationType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.dpuSeconds = try reader["DPUSeconds"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.ColumnStatisticsTaskSettings {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ColumnStatisticsTaskSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ColumnStatisticsTaskSettings()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        value.schedule = try reader["Schedule"].readIfPresent(with: GlueClientTypes.Schedule.read(from:))
        value.columnNameList = try reader["ColumnNameList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.catalogID = try reader["CatalogID"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.sampleSize = try reader["SampleSize"].readIfPresent() ?? 0
        value.securityConfiguration = try reader["SecurityConfiguration"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.Connection {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Connection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Connection()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.connectionType = try reader["ConnectionType"].readIfPresent()
        value.matchCriteria = try reader["MatchCriteria"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionProperties = try reader["ConnectionProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.athenaProperties = try reader["AthenaProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.physicalConnectionRequirements = try reader["PhysicalConnectionRequirements"].readIfPresent(with: GlueClientTypes.PhysicalConnectionRequirements.read(from:))
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedBy = try reader["LastUpdatedBy"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.lastConnectionValidationTime = try reader["LastConnectionValidationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.authenticationConfiguration = try reader["AuthenticationConfiguration"].readIfPresent(with: GlueClientTypes.AuthenticationConfiguration.read(from:))
        return value
    }
}

extension GlueClientTypes.AuthenticationConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.AuthenticationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.AuthenticationConfiguration()
        value.authenticationType = try reader["AuthenticationType"].readIfPresent()
        value.secretArn = try reader["SecretArn"].readIfPresent()
        value.oAuth2Properties = try reader["OAuth2Properties"].readIfPresent(with: GlueClientTypes.OAuth2Properties.read(from:))
        return value
    }
}

extension GlueClientTypes.OAuth2Properties {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.OAuth2Properties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.OAuth2Properties()
        value.oAuth2GrantType = try reader["OAuth2GrantType"].readIfPresent()
        value.oAuth2ClientApplication = try reader["OAuth2ClientApplication"].readIfPresent(with: GlueClientTypes.OAuth2ClientApplication.read(from:))
        value.tokenUrl = try reader["TokenUrl"].readIfPresent()
        value.tokenUrlParametersMap = try reader["TokenUrlParametersMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.OAuth2ClientApplication {

    static func write(value: GlueClientTypes.OAuth2ClientApplication?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AWSManagedClientApplicationReference"].write(value.awsManagedClientApplicationReference)
        try writer["UserManagedClientApplicationClientId"].write(value.userManagedClientApplicationClientId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.OAuth2ClientApplication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.OAuth2ClientApplication()
        value.userManagedClientApplicationClientId = try reader["UserManagedClientApplicationClientId"].readIfPresent()
        value.awsManagedClientApplicationReference = try reader["AWSManagedClientApplicationReference"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.PhysicalConnectionRequirements {

    static func write(value: GlueClientTypes.PhysicalConnectionRequirements?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["SecurityGroupIdList"].writeList(value.securityGroupIdList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetId"].write(value.subnetId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.PhysicalConnectionRequirements {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.PhysicalConnectionRequirements()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        value.securityGroupIdList = try reader["SecurityGroupIdList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.CrawlerMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CrawlerMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CrawlerMetrics()
        value.crawlerName = try reader["CrawlerName"].readIfPresent()
        value.timeLeftSeconds = try reader["TimeLeftSeconds"].readIfPresent() ?? 0
        value.stillEstimating = try reader["StillEstimating"].readIfPresent() ?? false
        value.lastRuntimeSeconds = try reader["LastRuntimeSeconds"].readIfPresent() ?? 0
        value.medianRuntimeSeconds = try reader["MedianRuntimeSeconds"].readIfPresent() ?? 0
        value.tablesCreated = try reader["TablesCreated"].readIfPresent() ?? 0
        value.tablesUpdated = try reader["TablesUpdated"].readIfPresent() ?? 0
        value.tablesDeleted = try reader["TablesDeleted"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.Database {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Database {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Database()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.locationUri = try reader["LocationUri"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createTableDefaultPermissions = try reader["CreateTableDefaultPermissions"].readListIfPresent(memberReadingClosure: GlueClientTypes.PrincipalPermissions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetDatabase = try reader["TargetDatabase"].readIfPresent(with: GlueClientTypes.DatabaseIdentifier.read(from:))
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.federatedDatabase = try reader["FederatedDatabase"].readIfPresent(with: GlueClientTypes.FederatedDatabase.read(from:))
        return value
    }
}

extension GlueClientTypes.FederatedDatabase {

    static func write(value: GlueClientTypes.FederatedDatabase?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionName"].write(value.connectionName)
        try writer["Identifier"].write(value.identifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.FederatedDatabase {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.FederatedDatabase()
        value.identifier = try reader["Identifier"].readIfPresent()
        value.connectionName = try reader["ConnectionName"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.DatabaseIdentifier {

    static func write(value: GlueClientTypes.DatabaseIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Region"].write(value.region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DatabaseIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DatabaseIdentifier()
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.PrincipalPermissions {

    static func write(value: GlueClientTypes.PrincipalPermissions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GlueClientTypes.Permission>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Principal"].write(value.principal, with: GlueClientTypes.DataLakePrincipal.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.PrincipalPermissions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.PrincipalPermissions()
        value.principal = try reader["Principal"].readIfPresent(with: GlueClientTypes.DataLakePrincipal.read(from:))
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GlueClientTypes.Permission>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.DataLakePrincipal {

    static func write(value: GlueClientTypes.DataLakePrincipal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataLakePrincipalIdentifier"].write(value.dataLakePrincipalIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DataLakePrincipal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DataLakePrincipal()
        value.dataLakePrincipalIdentifier = try reader["DataLakePrincipalIdentifier"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.DataCatalogEncryptionSettings {

    static func write(value: GlueClientTypes.DataCatalogEncryptionSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionPasswordEncryption"].write(value.connectionPasswordEncryption, with: GlueClientTypes.ConnectionPasswordEncryption.write(value:to:))
        try writer["EncryptionAtRest"].write(value.encryptionAtRest, with: GlueClientTypes.EncryptionAtRest.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DataCatalogEncryptionSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DataCatalogEncryptionSettings()
        value.encryptionAtRest = try reader["EncryptionAtRest"].readIfPresent(with: GlueClientTypes.EncryptionAtRest.read(from:))
        value.connectionPasswordEncryption = try reader["ConnectionPasswordEncryption"].readIfPresent(with: GlueClientTypes.ConnectionPasswordEncryption.read(from:))
        return value
    }
}

extension GlueClientTypes.ConnectionPasswordEncryption {

    static func write(value: GlueClientTypes.ConnectionPasswordEncryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsKmsKeyId"].write(value.awsKmsKeyId)
        try writer["ReturnConnectionPasswordEncrypted"].write(value.returnConnectionPasswordEncrypted)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ConnectionPasswordEncryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ConnectionPasswordEncryption()
        value.returnConnectionPasswordEncrypted = try reader["ReturnConnectionPasswordEncrypted"].readIfPresent() ?? false
        value.awsKmsKeyId = try reader["AwsKmsKeyId"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.EncryptionAtRest {

    static func write(value: GlueClientTypes.EncryptionAtRest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogEncryptionMode"].write(value.catalogEncryptionMode)
        try writer["CatalogEncryptionServiceRole"].write(value.catalogEncryptionServiceRole)
        try writer["SseAwsKmsKeyId"].write(value.sseAwsKmsKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.EncryptionAtRest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.EncryptionAtRest()
        value.catalogEncryptionMode = try reader["CatalogEncryptionMode"].readIfPresent() ?? .sdkUnknown("")
        value.sseAwsKmsKeyId = try reader["SseAwsKmsKeyId"].readIfPresent()
        value.catalogEncryptionServiceRole = try reader["CatalogEncryptionServiceRole"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.CodeGenNode {

    static func write(value: GlueClientTypes.CodeGenNode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Args"].writeList(value.args, memberWritingClosure: GlueClientTypes.CodeGenNodeArg.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Id"].write(value.id)
        try writer["LineNumber"].write(value.lineNumber)
        try writer["NodeType"].write(value.nodeType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CodeGenNode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CodeGenNode()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.nodeType = try reader["NodeType"].readIfPresent() ?? ""
        value.args = try reader["Args"].readListIfPresent(memberReadingClosure: GlueClientTypes.CodeGenNodeArg.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.lineNumber = try reader["LineNumber"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.CodeGenNodeArg {

    static func write(value: GlueClientTypes.CodeGenNodeArg?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Param"].write(value.param)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CodeGenNodeArg {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CodeGenNodeArg()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        value.param = try reader["Param"].readIfPresent() ?? false
        return value
    }
}

extension GlueClientTypes.CodeGenEdge {

    static func write(value: GlueClientTypes.CodeGenEdge?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Source"].write(value.source)
        try writer["Target"].write(value.target)
        try writer["TargetParameter"].write(value.targetParameter)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CodeGenEdge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CodeGenEdge()
        value.source = try reader["Source"].readIfPresent() ?? ""
        value.target = try reader["Target"].readIfPresent() ?? ""
        value.targetParameter = try reader["TargetParameter"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.StatisticModelResult {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.StatisticModelResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.StatisticModelResult()
        value.lowerBound = try reader["LowerBound"].readIfPresent()
        value.upperBound = try reader["UpperBound"].readIfPresent()
        value.predictedValue = try reader["PredictedValue"].readIfPresent()
        value.actualValue = try reader["ActualValue"].readIfPresent()
        value.date = try reader["Date"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.inclusionAnnotation = try reader["InclusionAnnotation"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.DataQualityTargetTable {

    static func write(value: GlueClientTypes.DataQualityTargetTable?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DataQualityTargetTable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DataQualityTargetTable()
        value.tableName = try reader["TableName"].readIfPresent() ?? ""
        value.databaseName = try reader["DatabaseName"].readIfPresent() ?? ""
        value.catalogId = try reader["CatalogId"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.DataQualityEvaluationRunAdditionalRunOptions {

    static func write(value: GlueClientTypes.DataQualityEvaluationRunAdditionalRunOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchMetricsEnabled"].write(value.cloudWatchMetricsEnabled)
        try writer["CompositeRuleEvaluationMethod"].write(value.compositeRuleEvaluationMethod)
        try writer["ResultsS3Prefix"].write(value.resultsS3Prefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DataQualityEvaluationRunAdditionalRunOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DataQualityEvaluationRunAdditionalRunOptions()
        value.cloudWatchMetricsEnabled = try reader["CloudWatchMetricsEnabled"].readIfPresent()
        value.resultsS3Prefix = try reader["ResultsS3Prefix"].readIfPresent()
        value.compositeRuleEvaluationMethod = try reader["CompositeRuleEvaluationMethod"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.JobBookmarkEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.JobBookmarkEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.JobBookmarkEntry()
        value.jobName = try reader["JobName"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.run = try reader["Run"].readIfPresent() ?? 0
        value.attempt = try reader["Attempt"].readIfPresent() ?? 0
        value.previousRunId = try reader["PreviousRunId"].readIfPresent()
        value.runId = try reader["RunId"].readIfPresent()
        value.jobBookmark = try reader["JobBookmark"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.MappingEntry {

    static func write(value: GlueClientTypes.MappingEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SourcePath"].write(value.sourcePath)
        try writer["SourceTable"].write(value.sourceTable)
        try writer["SourceType"].write(value.sourceType)
        try writer["TargetPath"].write(value.targetPath)
        try writer["TargetTable"].write(value.targetTable)
        try writer["TargetType"].write(value.targetType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.MappingEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.MappingEntry()
        value.sourceTable = try reader["SourceTable"].readIfPresent()
        value.sourcePath = try reader["SourcePath"].readIfPresent()
        value.sourceType = try reader["SourceType"].readIfPresent()
        value.targetTable = try reader["TargetTable"].readIfPresent()
        value.targetPath = try reader["TargetPath"].readIfPresent()
        value.targetType = try reader["TargetType"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.TaskRunProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TaskRunProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TaskRunProperties()
        value.taskType = try reader["TaskType"].readIfPresent()
        value.importLabelsTaskRunProperties = try reader["ImportLabelsTaskRunProperties"].readIfPresent(with: GlueClientTypes.ImportLabelsTaskRunProperties.read(from:))
        value.exportLabelsTaskRunProperties = try reader["ExportLabelsTaskRunProperties"].readIfPresent(with: GlueClientTypes.ExportLabelsTaskRunProperties.read(from:))
        value.labelingSetGenerationTaskRunProperties = try reader["LabelingSetGenerationTaskRunProperties"].readIfPresent(with: GlueClientTypes.LabelingSetGenerationTaskRunProperties.read(from:))
        value.findMatchesTaskRunProperties = try reader["FindMatchesTaskRunProperties"].readIfPresent(with: GlueClientTypes.FindMatchesTaskRunProperties.read(from:))
        return value
    }
}

extension GlueClientTypes.FindMatchesTaskRunProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.FindMatchesTaskRunProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.FindMatchesTaskRunProperties()
        value.jobId = try reader["JobId"].readIfPresent()
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobRunId = try reader["JobRunId"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.LabelingSetGenerationTaskRunProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.LabelingSetGenerationTaskRunProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.LabelingSetGenerationTaskRunProperties()
        value.outputS3Path = try reader["OutputS3Path"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.ExportLabelsTaskRunProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ExportLabelsTaskRunProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ExportLabelsTaskRunProperties()
        value.outputS3Path = try reader["OutputS3Path"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.ImportLabelsTaskRunProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ImportLabelsTaskRunProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ImportLabelsTaskRunProperties()
        value.inputS3Path = try reader["InputS3Path"].readIfPresent()
        value.replace = try reader["Replace"].readIfPresent() ?? false
        return value
    }
}

extension GlueClientTypes.TaskRun {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TaskRun {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TaskRun()
        value.transformId = try reader["TransformId"].readIfPresent()
        value.taskRunId = try reader["TaskRunId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.logGroupName = try reader["LogGroupName"].readIfPresent()
        value.properties = try reader["Properties"].readIfPresent(with: GlueClientTypes.TaskRunProperties.read(from:))
        value.errorString = try reader["ErrorString"].readIfPresent()
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completedOn = try reader["CompletedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.executionTime = try reader["ExecutionTime"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.TransformParameters {

    static func write(value: GlueClientTypes.TransformParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FindMatchesParameters"].write(value.findMatchesParameters, with: GlueClientTypes.FindMatchesParameters.write(value:to:))
        try writer["TransformType"].write(value.transformType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TransformParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TransformParameters()
        value.transformType = try reader["TransformType"].readIfPresent() ?? .sdkUnknown("")
        value.findMatchesParameters = try reader["FindMatchesParameters"].readIfPresent(with: GlueClientTypes.FindMatchesParameters.read(from:))
        return value
    }
}

extension GlueClientTypes.FindMatchesParameters {

    static func write(value: GlueClientTypes.FindMatchesParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccuracyCostTradeoff"].write(value.accuracyCostTradeoff)
        try writer["EnforceProvidedLabels"].write(value.enforceProvidedLabels)
        try writer["PrecisionRecallTradeoff"].write(value.precisionRecallTradeoff)
        try writer["PrimaryKeyColumnName"].write(value.primaryKeyColumnName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.FindMatchesParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.FindMatchesParameters()
        value.primaryKeyColumnName = try reader["PrimaryKeyColumnName"].readIfPresent()
        value.precisionRecallTradeoff = try reader["PrecisionRecallTradeoff"].readIfPresent()
        value.accuracyCostTradeoff = try reader["AccuracyCostTradeoff"].readIfPresent()
        value.enforceProvidedLabels = try reader["EnforceProvidedLabels"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.EvaluationMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.EvaluationMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.EvaluationMetrics()
        value.transformType = try reader["TransformType"].readIfPresent() ?? .sdkUnknown("")
        value.findMatchesMetrics = try reader["FindMatchesMetrics"].readIfPresent(with: GlueClientTypes.FindMatchesMetrics.read(from:))
        return value
    }
}

extension GlueClientTypes.FindMatchesMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.FindMatchesMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.FindMatchesMetrics()
        value.areaUnderPRCurve = try reader["AreaUnderPRCurve"].readIfPresent()
        value.precision = try reader["Precision"].readIfPresent()
        value.recall = try reader["Recall"].readIfPresent()
        value.f1 = try reader["F1"].readIfPresent()
        value.confusionMatrix = try reader["ConfusionMatrix"].readIfPresent(with: GlueClientTypes.ConfusionMatrix.read(from:))
        value.columnImportances = try reader["ColumnImportances"].readListIfPresent(memberReadingClosure: GlueClientTypes.ColumnImportance.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.ColumnImportance {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ColumnImportance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ColumnImportance()
        value.columnName = try reader["ColumnName"].readIfPresent()
        value.importance = try reader["Importance"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.ConfusionMatrix {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ConfusionMatrix {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ConfusionMatrix()
        value.numTruePositives = try reader["NumTruePositives"].readIfPresent()
        value.numFalsePositives = try reader["NumFalsePositives"].readIfPresent()
        value.numTrueNegatives = try reader["NumTrueNegatives"].readIfPresent()
        value.numFalseNegatives = try reader["NumFalseNegatives"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.SchemaColumn {

    static func write(value: GlueClientTypes.SchemaColumn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataType"].write(value.dataType)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SchemaColumn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SchemaColumn()
        value.name = try reader["Name"].readIfPresent()
        value.dataType = try reader["DataType"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.TransformEncryption {

    static func write(value: GlueClientTypes.TransformEncryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MlUserDataEncryption"].write(value.mlUserDataEncryption, with: GlueClientTypes.MLUserDataEncryption.write(value:to:))
        try writer["TaskRunSecurityConfigurationName"].write(value.taskRunSecurityConfigurationName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TransformEncryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TransformEncryption()
        value.mlUserDataEncryption = try reader["MlUserDataEncryption"].readIfPresent(with: GlueClientTypes.MLUserDataEncryption.read(from:))
        value.taskRunSecurityConfigurationName = try reader["TaskRunSecurityConfigurationName"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.MLUserDataEncryption {

    static func write(value: GlueClientTypes.MLUserDataEncryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["MlUserDataEncryptionMode"].write(value.mlUserDataEncryptionMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.MLUserDataEncryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.MLUserDataEncryption()
        value.mlUserDataEncryptionMode = try reader["MlUserDataEncryptionMode"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.MLTransform {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.MLTransform {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.MLTransform()
        value.transformId = try reader["TransformId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdOn = try reader["CreatedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.inputRecordTables = try reader["InputRecordTables"].readListIfPresent(memberReadingClosure: GlueClientTypes.GlueTable.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.parameters = try reader["Parameters"].readIfPresent(with: GlueClientTypes.TransformParameters.read(from:))
        value.evaluationMetrics = try reader["EvaluationMetrics"].readIfPresent(with: GlueClientTypes.EvaluationMetrics.read(from:))
        value.labelCount = try reader["LabelCount"].readIfPresent() ?? 0
        value.schema = try reader["Schema"].readListIfPresent(memberReadingClosure: GlueClientTypes.SchemaColumn.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.role = try reader["Role"].readIfPresent()
        value.glueVersion = try reader["GlueVersion"].readIfPresent()
        value.maxCapacity = try reader["MaxCapacity"].readIfPresent()
        value.workerType = try reader["WorkerType"].readIfPresent()
        value.numberOfWorkers = try reader["NumberOfWorkers"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        value.maxRetries = try reader["MaxRetries"].readIfPresent()
        value.transformEncryption = try reader["TransformEncryption"].readIfPresent(with: GlueClientTypes.TransformEncryption.read(from:))
        return value
    }
}

extension GlueClientTypes.PartitionIndexDescriptor {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.PartitionIndexDescriptor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.PartitionIndexDescriptor()
        value.indexName = try reader["IndexName"].readIfPresent() ?? ""
        value.keys = try reader["Keys"].readListIfPresent(memberReadingClosure: GlueClientTypes.KeySchemaElement.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.indexStatus = try reader["IndexStatus"].readIfPresent() ?? .sdkUnknown("")
        value.backfillErrors = try reader["BackfillErrors"].readListIfPresent(memberReadingClosure: GlueClientTypes.BackfillError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.BackfillError {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.BackfillError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.BackfillError()
        value.code = try reader["Code"].readIfPresent()
        value.partitions = try reader["Partitions"].readListIfPresent(memberReadingClosure: GlueClientTypes.PartitionValueList.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.KeySchemaElement {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.KeySchemaElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.KeySchemaElement()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent() ?? ""
        return value
    }
}

extension GlueClientTypes.GluePolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.GluePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.GluePolicy()
        value.policyInJson = try reader["PolicyInJson"].readIfPresent()
        value.policyHash = try reader["PolicyHash"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GlueClientTypes.SecurityConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SecurityConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SecurityConfiguration()
        value.name = try reader["Name"].readIfPresent()
        value.createdTimeStamp = try reader["CreatedTimeStamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.encryptionConfiguration = try reader["EncryptionConfiguration"].readIfPresent(with: GlueClientTypes.EncryptionConfiguration.read(from:))
        return value
    }
}

extension GlueClientTypes.EncryptionConfiguration {

    static func write(value: GlueClientTypes.EncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchEncryption"].write(value.cloudWatchEncryption, with: GlueClientTypes.CloudWatchEncryption.write(value:to:))
        try writer["JobBookmarksEncryption"].write(value.jobBookmarksEncryption, with: GlueClientTypes.JobBookmarksEncryption.write(value:to:))
        try writer["S3Encryption"].writeList(value.s3Encryption, memberWritingClosure: GlueClientTypes.S3Encryption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.EncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.EncryptionConfiguration()
        value.s3Encryption = try reader["S3Encryption"].readListIfPresent(memberReadingClosure: GlueClientTypes.S3Encryption.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.cloudWatchEncryption = try reader["CloudWatchEncryption"].readIfPresent(with: GlueClientTypes.CloudWatchEncryption.read(from:))
        value.jobBookmarksEncryption = try reader["JobBookmarksEncryption"].readIfPresent(with: GlueClientTypes.JobBookmarksEncryption.read(from:))
        return value
    }
}

extension GlueClientTypes.JobBookmarksEncryption {

    static func write(value: GlueClientTypes.JobBookmarksEncryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobBookmarksEncryptionMode"].write(value.jobBookmarksEncryptionMode)
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.JobBookmarksEncryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.JobBookmarksEncryption()
        value.jobBookmarksEncryptionMode = try reader["JobBookmarksEncryptionMode"].readIfPresent()
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.CloudWatchEncryption {

    static func write(value: GlueClientTypes.CloudWatchEncryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchEncryptionMode"].write(value.cloudWatchEncryptionMode)
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CloudWatchEncryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CloudWatchEncryption()
        value.cloudWatchEncryptionMode = try reader["CloudWatchEncryptionMode"].readIfPresent()
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.S3Encryption {

    static func write(value: GlueClientTypes.S3Encryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
        try writer["S3EncryptionMode"].write(value.s3EncryptionMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.S3Encryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.S3Encryption()
        value.s3EncryptionMode = try reader["S3EncryptionMode"].readIfPresent()
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.Statement {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Statement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Statement()
        value.id = try reader["Id"].readIfPresent() ?? 0
        value.code = try reader["Code"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.output = try reader["Output"].readIfPresent(with: GlueClientTypes.StatementOutput.read(from:))
        value.progress = try reader["Progress"].readIfPresent() ?? 0
        value.startedOn = try reader["StartedOn"].readIfPresent() ?? 0
        value.completedOn = try reader["CompletedOn"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.StatementOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.StatementOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.StatementOutput()
        value.data = try reader["Data"].readIfPresent(with: GlueClientTypes.StatementOutputData.read(from:))
        value.executionCount = try reader["ExecutionCount"].readIfPresent() ?? 0
        value.status = try reader["Status"].readIfPresent()
        value.errorName = try reader["ErrorName"].readIfPresent()
        value.errorValue = try reader["ErrorValue"].readIfPresent()
        value.traceback = try reader["Traceback"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.StatementOutputData {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.StatementOutputData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.StatementOutputData()
        value.textPlain = try reader["TextPlain"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.Table {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.Table {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.Table()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastAccessTime = try reader["LastAccessTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastAnalyzedTime = try reader["LastAnalyzedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.retention = try reader["Retention"].readIfPresent() ?? 0
        value.storageDescriptor = try reader["StorageDescriptor"].readIfPresent(with: GlueClientTypes.StorageDescriptor.read(from:))
        value.partitionKeys = try reader["PartitionKeys"].readListIfPresent(memberReadingClosure: GlueClientTypes.Column.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.viewOriginalText = try reader["ViewOriginalText"].readIfPresent()
        value.viewExpandedText = try reader["ViewExpandedText"].readIfPresent()
        value.tableType = try reader["TableType"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        value.isRegisteredWithLakeFormation = try reader["IsRegisteredWithLakeFormation"].readIfPresent() ?? false
        value.targetTable = try reader["TargetTable"].readIfPresent(with: GlueClientTypes.TableIdentifier.read(from:))
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.versionId = try reader["VersionId"].readIfPresent()
        value.federatedTable = try reader["FederatedTable"].readIfPresent(with: GlueClientTypes.FederatedTable.read(from:))
        value.viewDefinition = try reader["ViewDefinition"].readIfPresent(with: GlueClientTypes.ViewDefinition.read(from:))
        value.isMultiDialectView = try reader["IsMultiDialectView"].readIfPresent()
        value.status = try reader["Status"].readIfPresent(with: GlueClientTypes.TableStatus.read(from:))
        return value
    }
}

extension GlueClientTypes.TableStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TableStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TableStatus()
        value.requestedBy = try reader["RequestedBy"].readIfPresent()
        value.updatedBy = try reader["UpdatedBy"].readIfPresent()
        value.requestTime = try reader["RequestTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.action = try reader["Action"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: GlueClientTypes.ErrorDetail.read(from:))
        value.details = try reader["Details"].readIfPresent(with: GlueClientTypes.StatusDetails.read(from:))
        return value
    }
}

extension GlueClientTypes.StatusDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.StatusDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.StatusDetails()
        value.requestedChange = try reader["RequestedChange"].readIfPresent(with: GlueClientTypes.Table.read(from:))
        value.viewValidations = try reader["ViewValidations"].readListIfPresent(memberReadingClosure: GlueClientTypes.ViewValidation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.ViewValidation {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ViewValidation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ViewValidation()
        value.dialect = try reader["Dialect"].readIfPresent()
        value.dialectVersion = try reader["DialectVersion"].readIfPresent()
        value.viewValidationText = try reader["ViewValidationText"].readIfPresent()
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: GlueClientTypes.ErrorDetail.read(from:))
        return value
    }
}

extension GlueClientTypes.ViewDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ViewDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ViewDefinition()
        value.isProtected = try reader["IsProtected"].readIfPresent()
        value.definer = try reader["Definer"].readIfPresent()
        value.subObjects = try reader["SubObjects"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.representations = try reader["Representations"].readListIfPresent(memberReadingClosure: GlueClientTypes.ViewRepresentation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.ViewRepresentation {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ViewRepresentation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ViewRepresentation()
        value.dialect = try reader["Dialect"].readIfPresent()
        value.dialectVersion = try reader["DialectVersion"].readIfPresent()
        value.viewOriginalText = try reader["ViewOriginalText"].readIfPresent()
        value.viewExpandedText = try reader["ViewExpandedText"].readIfPresent()
        value.validationConnection = try reader["ValidationConnection"].readIfPresent()
        value.isStale = try reader["IsStale"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.FederatedTable {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.FederatedTable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.FederatedTable()
        value.identifier = try reader["Identifier"].readIfPresent()
        value.databaseIdentifier = try reader["DatabaseIdentifier"].readIfPresent()
        value.connectionName = try reader["ConnectionName"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.TableIdentifier {

    static func write(value: GlueClientTypes.TableIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Name"].write(value.name)
        try writer["Region"].write(value.region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TableIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TableIdentifier()
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.TableVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TableVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TableVersion()
        value.table = try reader["Table"].readIfPresent(with: GlueClientTypes.Table.read(from:))
        value.versionId = try reader["VersionId"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.UnfilteredPartition {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.UnfilteredPartition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.UnfilteredPartition()
        value.partition = try reader["Partition"].readIfPresent(with: GlueClientTypes.Partition.read(from:))
        value.authorizedColumns = try reader["AuthorizedColumns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.isRegisteredWithLakeFormation = try reader["IsRegisteredWithLakeFormation"].readIfPresent() ?? false
        return value
    }
}

extension GlueClientTypes.ColumnRowFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ColumnRowFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ColumnRowFilter()
        value.columnName = try reader["ColumnName"].readIfPresent()
        value.rowFilterExpression = try reader["RowFilterExpression"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.ProfileConfiguration {

    static func write(value: GlueClientTypes.ProfileConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobConfiguration"].writeMap(value.jobConfiguration, valueWritingClosure: GlueClientTypes.ConfigurationObject.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SessionConfiguration"].writeMap(value.sessionConfiguration, valueWritingClosure: GlueClientTypes.ConfigurationObject.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ProfileConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ProfileConfiguration()
        value.sessionConfiguration = try reader["SessionConfiguration"].readMapIfPresent(valueReadingClosure: GlueClientTypes.ConfigurationObject.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.jobConfiguration = try reader["JobConfiguration"].readMapIfPresent(valueReadingClosure: GlueClientTypes.ConfigurationObject.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.ConfigurationObject {

    static func write(value: GlueClientTypes.ConfigurationObject?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedValues"].writeList(value.allowedValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["MaxValue"].write(value.maxValue)
        try writer["MinValue"].write(value.minValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ConfigurationObject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ConfigurationObject()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.allowedValues = try reader["AllowedValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.minValue = try reader["MinValue"].readIfPresent()
        value.maxValue = try reader["MaxValue"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.UserDefinedFunction {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.UserDefinedFunction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.UserDefinedFunction()
        value.functionName = try reader["FunctionName"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.className = try reader["ClassName"].readIfPresent()
        value.ownerName = try reader["OwnerName"].readIfPresent()
        value.ownerType = try reader["OwnerType"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceUris = try reader["ResourceUris"].readListIfPresent(memberReadingClosure: GlueClientTypes.ResourceUri.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.catalogId = try reader["CatalogId"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.ResourceUri {

    static func write(value: GlueClientTypes.ResourceUri?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceType"].write(value.resourceType)
        try writer["Uri"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ResourceUri {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ResourceUri()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.uri = try reader["Uri"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.CrawlerHistory {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.CrawlerHistory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.CrawlerHistory()
        value.crawlId = try reader["CrawlId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.summary = try reader["Summary"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.logGroup = try reader["LogGroup"].readIfPresent()
        value.logStream = try reader["LogStream"].readIfPresent()
        value.messagePrefix = try reader["MessagePrefix"].readIfPresent()
        value.dpuHour = try reader["DPUHour"].readIfPresent() ?? 0
        return value
    }
}

extension GlueClientTypes.DataQualityResultDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DataQualityResultDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DataQualityResultDescription()
        value.resultId = try reader["ResultId"].readIfPresent()
        value.dataSource = try reader["DataSource"].readIfPresent(with: GlueClientTypes.DataSource.read(from:))
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobRunId = try reader["JobRunId"].readIfPresent()
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GlueClientTypes.DataQualityRuleRecommendationRunDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DataQualityRuleRecommendationRunDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DataQualityRuleRecommendationRunDescription()
        value.runId = try reader["RunId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataSource = try reader["DataSource"].readIfPresent(with: GlueClientTypes.DataSource.read(from:))
        return value
    }
}

extension GlueClientTypes.DataQualityRulesetEvaluationRunDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DataQualityRulesetEvaluationRunDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DataQualityRulesetEvaluationRunDescription()
        value.runId = try reader["RunId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataSource = try reader["DataSource"].readIfPresent(with: GlueClientTypes.DataSource.read(from:))
        return value
    }
}

extension GlueClientTypes.DataQualityRulesetListDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.DataQualityRulesetListDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.DataQualityRulesetListDetails()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdOn = try reader["CreatedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.targetTable = try reader["TargetTable"].readIfPresent(with: GlueClientTypes.DataQualityTargetTable.read(from:))
        value.recommendationRunId = try reader["RecommendationRunId"].readIfPresent()
        value.ruleCount = try reader["RuleCount"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.StatisticAnnotation {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.StatisticAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.StatisticAnnotation()
        value.profileId = try reader["ProfileId"].readIfPresent()
        value.statisticId = try reader["StatisticId"].readIfPresent()
        value.statisticRecordedOn = try reader["StatisticRecordedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.inclusionAnnotation = try reader["InclusionAnnotation"].readIfPresent(with: GlueClientTypes.TimestampedInclusionAnnotation.read(from:))
        return value
    }
}

extension GlueClientTypes.TimestampedInclusionAnnotation {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.TimestampedInclusionAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.TimestampedInclusionAnnotation()
        value.value = try reader["Value"].readIfPresent()
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GlueClientTypes.StatisticSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.StatisticSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.StatisticSummary()
        value.statisticId = try reader["StatisticId"].readIfPresent()
        value.profileId = try reader["ProfileId"].readIfPresent()
        value.runIdentifier = try reader["RunIdentifier"].readIfPresent(with: GlueClientTypes.RunIdentifier.read(from:))
        value.statisticName = try reader["StatisticName"].readIfPresent()
        value.doubleValue = try reader["DoubleValue"].readIfPresent() ?? 0
        value.evaluationLevel = try reader["EvaluationLevel"].readIfPresent()
        value.columnsReferenced = try reader["ColumnsReferenced"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.referencedDatasets = try reader["ReferencedDatasets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.statisticProperties = try reader["StatisticProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.recordedOn = try reader["RecordedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.inclusionAnnotation = try reader["InclusionAnnotation"].readIfPresent(with: GlueClientTypes.TimestampedInclusionAnnotation.read(from:))
        return value
    }
}

extension GlueClientTypes.RunIdentifier {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.RunIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.RunIdentifier()
        value.runId = try reader["RunId"].readIfPresent()
        value.jobRunId = try reader["JobRunId"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.RegistryListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.RegistryListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.RegistryListItem()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readIfPresent()
        value.updatedTime = try reader["UpdatedTime"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.SchemaListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SchemaListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SchemaListItem()
        value.registryName = try reader["RegistryName"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.schemaStatus = try reader["SchemaStatus"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readIfPresent()
        value.updatedTime = try reader["UpdatedTime"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.SchemaVersionListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.SchemaVersionListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.SchemaVersionListItem()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.schemaVersionId = try reader["SchemaVersionId"].readIfPresent()
        value.versionNumber = try reader["VersionNumber"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.UsageProfileDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.UsageProfileDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.UsageProfileDefinition()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdOn = try reader["CreatedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedOn = try reader["LastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GlueClientTypes.MetadataInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.MetadataInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.MetadataInfo()
        value.metadataValue = try reader["MetadataValue"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readIfPresent()
        value.otherMetadataValueList = try reader["OtherMetadataValueList"].readListIfPresent(memberReadingClosure: GlueClientTypes.OtherMetadataValueListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlueClientTypes.OtherMetadataValueListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.OtherMetadataValueListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.OtherMetadataValueListItem()
        value.metadataValue = try reader["MetadataValue"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readIfPresent()
        return value
    }
}

extension GlueClientTypes.ColumnStatisticsError {

    static func read(from reader: SmithyJSON.Reader) throws -> GlueClientTypes.ColumnStatisticsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlueClientTypes.ColumnStatisticsError()
        value.columnStatistics = try reader["ColumnStatistics"].readIfPresent(with: GlueClientTypes.ColumnStatistics.read(from:))
        value.error = try reader["Error"].readIfPresent(with: GlueClientTypes.ErrorDetail.read(from:))
        return value
    }
}

extension GlueClientTypes.PartitionInput {

    static func write(value: GlueClientTypes.PartitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LastAccessTime"].writeTimestamp(value.lastAccessTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["LastAnalyzedTime"].writeTimestamp(value.lastAnalyzedTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["StorageDescriptor"].write(value.storageDescriptor, with: GlueClientTypes.StorageDescriptor.write(value:to:))
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GlueClientTypes.BatchGetTableOptimizerEntry {

    static func write(value: GlueClientTypes.BatchGetTableOptimizerEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["catalogId"].write(value.catalogId)
        try writer["databaseName"].write(value.databaseName)
        try writer["tableName"].write(value.tableName)
        try writer["type"].write(value.type)
    }
}

extension GlueClientTypes.DatapointInclusionAnnotation {

    static func write(value: GlueClientTypes.DatapointInclusionAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InclusionAnnotation"].write(value.inclusionAnnotation)
        try writer["ProfileId"].write(value.profileId)
        try writer["StatisticId"].write(value.statisticId)
    }
}

extension GlueClientTypes.BatchUpdatePartitionRequestEntry {

    static func write(value: GlueClientTypes.BatchUpdatePartitionRequestEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PartitionInput"].write(value.partitionInput, with: GlueClientTypes.PartitionInput.write(value:to:))
        try writer["PartitionValueList"].writeList(value.partitionValueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GlueClientTypes.CreateGrokClassifierRequest {

    static func write(value: GlueClientTypes.CreateGrokClassifierRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Classification"].write(value.classification)
        try writer["CustomPatterns"].write(value.customPatterns)
        try writer["GrokPattern"].write(value.grokPattern)
        try writer["Name"].write(value.name)
    }
}

extension GlueClientTypes.CreateXMLClassifierRequest {

    static func write(value: GlueClientTypes.CreateXMLClassifierRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Classification"].write(value.classification)
        try writer["Name"].write(value.name)
        try writer["RowTag"].write(value.rowTag)
    }
}

extension GlueClientTypes.CreateJsonClassifierRequest {

    static func write(value: GlueClientTypes.CreateJsonClassifierRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JsonPath"].write(value.jsonPath)
        try writer["Name"].write(value.name)
    }
}

extension GlueClientTypes.CreateCsvClassifierRequest {

    static func write(value: GlueClientTypes.CreateCsvClassifierRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowSingleColumn"].write(value.allowSingleColumn)
        try writer["ContainsHeader"].write(value.containsHeader)
        try writer["CustomDatatypeConfigured"].write(value.customDatatypeConfigured)
        try writer["CustomDatatypes"].writeList(value.customDatatypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Delimiter"].write(value.delimiter)
        try writer["DisableValueTrimming"].write(value.disableValueTrimming)
        try writer["Header"].writeList(value.header, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["QuoteSymbol"].write(value.quoteSymbol)
        try writer["Serde"].write(value.serde)
    }
}

extension GlueClientTypes.ConnectionInput {

    static func write(value: GlueClientTypes.ConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AthenaProperties"].writeMap(value.athenaProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["AuthenticationConfiguration"].write(value.authenticationConfiguration, with: GlueClientTypes.AuthenticationConfigurationInput.write(value:to:))
        try writer["ConnectionProperties"].writeMap(value.connectionProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ConnectionType"].write(value.connectionType)
        try writer["Description"].write(value.description)
        try writer["MatchCriteria"].writeList(value.matchCriteria, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PhysicalConnectionRequirements"].write(value.physicalConnectionRequirements, with: GlueClientTypes.PhysicalConnectionRequirements.write(value:to:))
        try writer["ValidateCredentials"].write(value.validateCredentials)
    }
}

extension GlueClientTypes.AuthenticationConfigurationInput {

    static func write(value: GlueClientTypes.AuthenticationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationType"].write(value.authenticationType)
        try writer["OAuth2Properties"].write(value.oAuth2Properties, with: GlueClientTypes.OAuth2PropertiesInput.write(value:to:))
        try writer["SecretArn"].write(value.secretArn)
    }
}

extension GlueClientTypes.OAuth2PropertiesInput {

    static func write(value: GlueClientTypes.OAuth2PropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizationCodeProperties"].write(value.authorizationCodeProperties, with: GlueClientTypes.AuthorizationCodeProperties.write(value:to:))
        try writer["OAuth2ClientApplication"].write(value.oAuth2ClientApplication, with: GlueClientTypes.OAuth2ClientApplication.write(value:to:))
        try writer["OAuth2GrantType"].write(value.oAuth2GrantType)
        try writer["TokenUrl"].write(value.tokenUrl)
        try writer["TokenUrlParametersMap"].writeMap(value.tokenUrlParametersMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension GlueClientTypes.AuthorizationCodeProperties {

    static func write(value: GlueClientTypes.AuthorizationCodeProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizationCode"].write(value.authorizationCode)
        try writer["RedirectUri"].write(value.redirectUri)
    }
}

extension GlueClientTypes.DatabaseInput {

    static func write(value: GlueClientTypes.DatabaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreateTableDefaultPermissions"].writeList(value.createTableDefaultPermissions, memberWritingClosure: GlueClientTypes.PrincipalPermissions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["FederatedDatabase"].write(value.federatedDatabase, with: GlueClientTypes.FederatedDatabase.write(value:to:))
        try writer["LocationUri"].write(value.locationUri)
        try writer["Name"].write(value.name)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TargetDatabase"].write(value.targetDatabase, with: GlueClientTypes.DatabaseIdentifier.write(value:to:))
    }
}

extension GlueClientTypes.PartitionIndex {

    static func write(value: GlueClientTypes.PartitionIndex?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IndexName"].write(value.indexName)
        try writer["Keys"].writeList(value.keys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GlueClientTypes.RegistryId {

    static func write(value: GlueClientTypes.RegistryId?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RegistryArn"].write(value.registryArn)
        try writer["RegistryName"].write(value.registryName)
    }
}

extension GlueClientTypes.TableInput {

    static func write(value: GlueClientTypes.TableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["LastAccessTime"].writeTimestamp(value.lastAccessTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["LastAnalyzedTime"].writeTimestamp(value.lastAnalyzedTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Name"].write(value.name)
        try writer["Owner"].write(value.owner)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["PartitionKeys"].writeList(value.partitionKeys, memberWritingClosure: GlueClientTypes.Column.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Retention"].write(value.retention)
        try writer["StorageDescriptor"].write(value.storageDescriptor, with: GlueClientTypes.StorageDescriptor.write(value:to:))
        try writer["TableType"].write(value.tableType)
        try writer["TargetTable"].write(value.targetTable, with: GlueClientTypes.TableIdentifier.write(value:to:))
        try writer["ViewDefinition"].write(value.viewDefinition, with: GlueClientTypes.ViewDefinitionInput.write(value:to:))
        try writer["ViewExpandedText"].write(value.viewExpandedText)
        try writer["ViewOriginalText"].write(value.viewOriginalText)
    }
}

extension GlueClientTypes.ViewDefinitionInput {

    static func write(value: GlueClientTypes.ViewDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Definer"].write(value.definer)
        try writer["IsProtected"].write(value.isProtected)
        try writer["Representations"].writeList(value.representations, memberWritingClosure: GlueClientTypes.ViewRepresentationInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubObjects"].writeList(value.subObjects, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GlueClientTypes.ViewRepresentationInput {

    static func write(value: GlueClientTypes.ViewRepresentationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dialect"].write(value.dialect)
        try writer["DialectVersion"].write(value.dialectVersion)
        try writer["ValidationConnection"].write(value.validationConnection)
        try writer["ViewExpandedText"].write(value.viewExpandedText)
        try writer["ViewOriginalText"].write(value.viewOriginalText)
    }
}

extension GlueClientTypes.OpenTableFormatInput {

    static func write(value: GlueClientTypes.OpenTableFormatInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IcebergInput"].write(value.icebergInput, with: GlueClientTypes.IcebergInput.write(value:to:))
    }
}

extension GlueClientTypes.IcebergInput {

    static func write(value: GlueClientTypes.IcebergInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MetadataOperation"].write(value.metadataOperation)
        try writer["Version"].write(value.version)
    }
}

extension GlueClientTypes.UserDefinedFunctionInput {

    static func write(value: GlueClientTypes.UserDefinedFunctionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClassName"].write(value.className)
        try writer["FunctionName"].write(value.functionName)
        try writer["OwnerName"].write(value.ownerName)
        try writer["OwnerType"].write(value.ownerType)
        try writer["ResourceUris"].writeList(value.resourceUris, memberWritingClosure: GlueClientTypes.ResourceUri.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GlueClientTypes.GetConnectionsFilter {

    static func write(value: GlueClientTypes.GetConnectionsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionType"].write(value.connectionType)
        try writer["MatchCriteria"].writeList(value.matchCriteria, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GlueClientTypes.CatalogEntry {

    static func write(value: GlueClientTypes.CatalogEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
    }
}

extension GlueClientTypes.Location {

    static func write(value: GlueClientTypes.Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DynamoDB"].writeList(value.dynamoDB, memberWritingClosure: GlueClientTypes.CodeGenNodeArg.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Jdbc"].writeList(value.jdbc, memberWritingClosure: GlueClientTypes.CodeGenNodeArg.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["S3"].writeList(value.s3, memberWritingClosure: GlueClientTypes.CodeGenNodeArg.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GlueClientTypes.TaskRunFilterCriteria {

    static func write(value: GlueClientTypes.TaskRunFilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StartedAfter"].writeTimestamp(value.startedAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartedBefore"].writeTimestamp(value.startedBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Status"].write(value.status)
        try writer["TaskRunType"].write(value.taskRunType)
    }
}

extension GlueClientTypes.TaskRunSortCriteria {

    static func write(value: GlueClientTypes.TaskRunSortCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column)
        try writer["SortDirection"].write(value.sortDirection)
    }
}

extension GlueClientTypes.TransformFilterCriteria {

    static func write(value: GlueClientTypes.TransformFilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatedAfter"].writeTimestamp(value.createdAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["CreatedBefore"].writeTimestamp(value.createdBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["GlueVersion"].write(value.glueVersion)
        try writer["LastModifiedAfter"].writeTimestamp(value.lastModifiedAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["LastModifiedBefore"].writeTimestamp(value.lastModifiedBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Name"].write(value.name)
        try writer["Schema"].writeList(value.schema, memberWritingClosure: GlueClientTypes.SchemaColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Status"].write(value.status)
        try writer["TransformType"].write(value.transformType)
    }
}

extension GlueClientTypes.TransformSortCriteria {

    static func write(value: GlueClientTypes.TransformSortCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column)
        try writer["SortDirection"].write(value.sortDirection)
    }
}

extension GlueClientTypes.Segment {

    static func write(value: GlueClientTypes.Segment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SegmentNumber"].write(value.segmentNumber)
        try writer["TotalSegments"].write(value.totalSegments)
    }
}

extension GlueClientTypes.SchemaVersionNumber {

    static func write(value: GlueClientTypes.SchemaVersionNumber?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LatestVersion"].write(value.latestVersion)
        try writer["VersionNumber"].write(value.versionNumber)
    }
}

extension GlueClientTypes.AuditContext {

    static func write(value: GlueClientTypes.AuditContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalAuditContext"].write(value.additionalAuditContext)
        try writer["AllColumnsRequested"].write(value.allColumnsRequested)
        try writer["RequestedColumns"].writeList(value.requestedColumns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GlueClientTypes.QuerySessionContext {

    static func write(value: GlueClientTypes.QuerySessionContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalContext"].writeMap(value.additionalContext, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ClusterId"].write(value.clusterId)
        try writer["QueryAuthorizationId"].write(value.queryAuthorizationId)
        try writer["QueryId"].write(value.queryId)
        try writer["QueryStartTime"].writeTimestamp(value.queryStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension GlueClientTypes.SupportedDialect {

    static func write(value: GlueClientTypes.SupportedDialect?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dialect"].write(value.dialect)
        try writer["DialectVersion"].write(value.dialectVersion)
    }
}

extension GlueClientTypes.CrawlsFilter {

    static func write(value: GlueClientTypes.CrawlsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldName"].write(value.fieldName)
        try writer["FieldValue"].write(value.fieldValue)
        try writer["FilterOperator"].write(value.filterOperator)
    }
}

extension GlueClientTypes.DataQualityResultFilterCriteria {

    static func write(value: GlueClientTypes.DataQualityResultFilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSource"].write(value.dataSource, with: GlueClientTypes.DataSource.write(value:to:))
        try writer["JobName"].write(value.jobName)
        try writer["JobRunId"].write(value.jobRunId)
        try writer["StartedAfter"].writeTimestamp(value.startedAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartedBefore"].writeTimestamp(value.startedBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension GlueClientTypes.DataQualityRuleRecommendationRunFilter {

    static func write(value: GlueClientTypes.DataQualityRuleRecommendationRunFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSource"].write(value.dataSource, with: GlueClientTypes.DataSource.write(value:to:))
        try writer["StartedAfter"].writeTimestamp(value.startedAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartedBefore"].writeTimestamp(value.startedBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension GlueClientTypes.DataQualityRulesetEvaluationRunFilter {

    static func write(value: GlueClientTypes.DataQualityRulesetEvaluationRunFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSource"].write(value.dataSource, with: GlueClientTypes.DataSource.write(value:to:))
        try writer["StartedAfter"].writeTimestamp(value.startedAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartedBefore"].writeTimestamp(value.startedBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension GlueClientTypes.DataQualityRulesetFilterCriteria {

    static func write(value: GlueClientTypes.DataQualityRulesetFilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatedAfter"].writeTimestamp(value.createdAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["CreatedBefore"].writeTimestamp(value.createdBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Description"].write(value.description)
        try writer["LastModifiedAfter"].writeTimestamp(value.lastModifiedAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["LastModifiedBefore"].writeTimestamp(value.lastModifiedBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Name"].write(value.name)
        try writer["TargetTable"].write(value.targetTable, with: GlueClientTypes.DataQualityTargetTable.write(value:to:))
    }
}

extension GlueClientTypes.TimestampFilter {

    static func write(value: GlueClientTypes.TimestampFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecordedAfter"].writeTimestamp(value.recordedAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["RecordedBefore"].writeTimestamp(value.recordedBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension GlueClientTypes.MetadataKeyValuePair {

    static func write(value: GlueClientTypes.MetadataKeyValuePair?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MetadataKey"].write(value.metadataKey)
        try writer["MetadataValue"].write(value.metadataValue)
    }
}

extension GlueClientTypes.PropertyPredicate {

    static func write(value: GlueClientTypes.PropertyPredicate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Comparator"].write(value.comparator)
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }
}

extension GlueClientTypes.SortCriterion {

    static func write(value: GlueClientTypes.SortCriterion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldName"].write(value.fieldName)
        try writer["Sort"].write(value.sort)
    }
}

extension GlueClientTypes.TestConnectionInput {

    static func write(value: GlueClientTypes.TestConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationConfiguration"].write(value.authenticationConfiguration, with: GlueClientTypes.AuthenticationConfigurationInput.write(value:to:))
        try writer["ConnectionProperties"].writeMap(value.connectionProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ConnectionType"].write(value.connectionType)
    }
}

extension GlueClientTypes.UpdateGrokClassifierRequest {

    static func write(value: GlueClientTypes.UpdateGrokClassifierRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Classification"].write(value.classification)
        try writer["CustomPatterns"].write(value.customPatterns)
        try writer["GrokPattern"].write(value.grokPattern)
        try writer["Name"].write(value.name)
    }
}

extension GlueClientTypes.UpdateXMLClassifierRequest {

    static func write(value: GlueClientTypes.UpdateXMLClassifierRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Classification"].write(value.classification)
        try writer["Name"].write(value.name)
        try writer["RowTag"].write(value.rowTag)
    }
}

extension GlueClientTypes.UpdateJsonClassifierRequest {

    static func write(value: GlueClientTypes.UpdateJsonClassifierRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JsonPath"].write(value.jsonPath)
        try writer["Name"].write(value.name)
    }
}

extension GlueClientTypes.UpdateCsvClassifierRequest {

    static func write(value: GlueClientTypes.UpdateCsvClassifierRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowSingleColumn"].write(value.allowSingleColumn)
        try writer["ContainsHeader"].write(value.containsHeader)
        try writer["CustomDatatypeConfigured"].write(value.customDatatypeConfigured)
        try writer["CustomDatatypes"].writeList(value.customDatatypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Delimiter"].write(value.delimiter)
        try writer["DisableValueTrimming"].write(value.disableValueTrimming)
        try writer["Header"].writeList(value.header, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["QuoteSymbol"].write(value.quoteSymbol)
        try writer["Serde"].write(value.serde)
    }
}

extension GlueClientTypes.DevEndpointCustomLibraries {

    static func write(value: GlueClientTypes.DevEndpointCustomLibraries?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExtraJarsS3Path"].write(value.extraJarsS3Path)
        try writer["ExtraPythonLibsS3Path"].write(value.extraPythonLibsS3Path)
    }
}

extension GlueClientTypes.JobUpdate {

    static func write(value: GlueClientTypes.JobUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllocatedCapacity"].write(value.allocatedCapacity)
        try writer["CodeGenConfigurationNodes"].writeMap(value.codeGenConfigurationNodes, valueWritingClosure: GlueClientTypes.CodeGenConfigurationNode.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Command"].write(value.command, with: GlueClientTypes.JobCommand.write(value:to:))
        try writer["Connections"].write(value.connections, with: GlueClientTypes.ConnectionsList.write(value:to:))
        try writer["DefaultArguments"].writeMap(value.defaultArguments, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["ExecutionClass"].write(value.executionClass)
        try writer["ExecutionProperty"].write(value.executionProperty, with: GlueClientTypes.ExecutionProperty.write(value:to:))
        try writer["GlueVersion"].write(value.glueVersion)
        try writer["JobMode"].write(value.jobMode)
        try writer["JobRunQueuingEnabled"].write(value.jobRunQueuingEnabled)
        try writer["LogUri"].write(value.logUri)
        try writer["MaintenanceWindow"].write(value.maintenanceWindow)
        try writer["MaxCapacity"].write(value.maxCapacity)
        try writer["MaxRetries"].write(value.maxRetries)
        try writer["NonOverridableArguments"].writeMap(value.nonOverridableArguments, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["NotificationProperty"].write(value.notificationProperty, with: GlueClientTypes.NotificationProperty.write(value:to:))
        try writer["NumberOfWorkers"].write(value.numberOfWorkers)
        try writer["Role"].write(value.role)
        try writer["SecurityConfiguration"].write(value.securityConfiguration)
        try writer["SourceControlDetails"].write(value.sourceControlDetails, with: GlueClientTypes.SourceControlDetails.write(value:to:))
        try writer["Timeout"].write(value.timeout)
        try writer["WorkerType"].write(value.workerType)
    }
}

extension GlueClientTypes.TriggerUpdate {

    static func write(value: GlueClientTypes.TriggerUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: GlueClientTypes.Action.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["EventBatchingCondition"].write(value.eventBatchingCondition, with: GlueClientTypes.EventBatchingCondition.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Predicate"].write(value.predicate, with: GlueClientTypes.Predicate.write(value:to:))
        try writer["Schedule"].write(value.schedule)
    }
}

public enum GlueClientTypes {}
