//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.
    public struct AmexCardSecurityCodeVersion1 {
        /// The expiry date of a payment card.
        /// This member is required.
        public var cardExpiryDate: Swift.String?

        public init(
            cardExpiryDate: Swift.String? = nil
        )
        {
            self.cardExpiryDate = cardExpiryDate
        }
    }

}

extension PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion1: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AmexCardSecurityCodeVersion1(cardExpiryDate: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.
    public struct AmexCardSecurityCodeVersion2 {
        /// The expiry date of a payment card.
        /// This member is required.
        public var cardExpiryDate: Swift.String?
        /// The service code of the AMEX payment card. This is different from the Card Security Code (CSC).
        /// This member is required.
        public var serviceCode: Swift.String?

        public init(
            cardExpiryDate: Swift.String? = nil,
            serviceCode: Swift.String? = nil
        )
        {
            self.cardExpiryDate = cardExpiryDate
            self.serviceCode = serviceCode
        }
    }

}

extension PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion2: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AmexCardSecurityCodeVersion2(cardExpiryDate: \"CONTENT_REDACTED\", serviceCode: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {

    public enum PaddingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oaepSha1
        case oaepSha256
        case oaepSha512
        case pkcs1
        case sdkUnknown(Swift.String)

        public static var allCases: [PaddingType] {
            return [
                .oaepSha1,
                .oaepSha256,
                .oaepSha512,
                .pkcs1
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oaepSha1: return "OAEP_SHA1"
            case .oaepSha256: return "OAEP_SHA256"
            case .oaepSha512: return "OAEP_SHA512"
            case .pkcs1: return "PKCS1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters for plaintext encryption using asymmetric keys.
    public struct AsymmetricEncryptionAttributes {
        /// The padding to be included with the data.
        public var paddingType: PaymentCryptographyDataClientTypes.PaddingType?

        public init(
            paddingType: PaymentCryptographyDataClientTypes.PaddingType? = nil
        )
        {
            self.paddingType = paddingType
        }
    }

}

extension PaymentCryptographyDataClientTypes {
    /// Card data parameters that are required to generate a cardholder verification value for the payment card.
    public struct CardHolderVerificationValue {
        /// The transaction counter value that comes from a point of sale terminal.
        /// This member is required.
        public var applicationTransactionCounter: Swift.String?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// A random number generated by the issuer.
        /// This member is required.
        public var unpredictableNumber: Swift.String?

        public init(
            applicationTransactionCounter: Swift.String? = nil,
            panSequenceNumber: Swift.String? = nil,
            unpredictableNumber: Swift.String? = nil
        )
        {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.unpredictableNumber = unpredictableNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes {
    /// Card data parameters that are required to verify CVV (Card Verification Value) for the payment card.
    public struct CardVerificationValue1 {
        /// The expiry date of a payment card.
        /// This member is required.
        public var cardExpiryDate: Swift.String?
        /// The service code of the payment card. This is different from Card Security Code (CSC).
        /// This member is required.
        public var serviceCode: Swift.String?

        public init(
            cardExpiryDate: Swift.String? = nil,
            serviceCode: Swift.String? = nil
        )
        {
            self.cardExpiryDate = cardExpiryDate
            self.serviceCode = serviceCode
        }
    }

}

extension PaymentCryptographyDataClientTypes.CardVerificationValue1: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CardVerificationValue1(cardExpiryDate: \"CONTENT_REDACTED\", serviceCode: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Card data parameters that are required to verify Card Verification Value (CVV2) for the payment card.
    public struct CardVerificationValue2 {
        /// The expiry date of a payment card.
        /// This member is required.
        public var cardExpiryDate: Swift.String?

        public init(
            cardExpiryDate: Swift.String? = nil
        )
        {
            self.cardExpiryDate = cardExpiryDate
        }
    }

}

extension PaymentCryptographyDataClientTypes.CardVerificationValue2: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CardVerificationValue2(cardExpiryDate: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Dynamic Card Verification Value (dCVV).
    public struct DynamicCardVerificationCode {
        /// The transaction counter value that comes from the terminal.
        /// This member is required.
        public var applicationTransactionCounter: Swift.String?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The data on the two tracks of magnetic cards used for financial transactions. This includes the cardholder name, PAN, expiration date, bank ID (BIN) and several other numbers the issuing bank uses to validate the data received.
        /// This member is required.
        public var trackData: Swift.String?
        /// A random number generated by the issuer.
        /// This member is required.
        public var unpredictableNumber: Swift.String?

        public init(
            applicationTransactionCounter: Swift.String? = nil,
            panSequenceNumber: Swift.String? = nil,
            trackData: Swift.String? = nil,
            unpredictableNumber: Swift.String? = nil
        )
        {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.trackData = trackData
            self.unpredictableNumber = unpredictableNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.DynamicCardVerificationCode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DynamicCardVerificationCode(applicationTransactionCounter: \(Swift.String(describing: applicationTransactionCounter)), panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), unpredictableNumber: \(Swift.String(describing: unpredictableNumber)), trackData: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Dynamic Card Verification Value (dCVV).
    public struct DynamicCardVerificationValue {
        /// The transaction counter value that comes from the terminal.
        /// This member is required.
        public var applicationTransactionCounter: Swift.String?
        /// The expiry date of a payment card.
        /// This member is required.
        public var cardExpiryDate: Swift.String?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The service code of the payment card. This is different from Card Security Code (CSC).
        /// This member is required.
        public var serviceCode: Swift.String?

        public init(
            applicationTransactionCounter: Swift.String? = nil,
            cardExpiryDate: Swift.String? = nil,
            panSequenceNumber: Swift.String? = nil,
            serviceCode: Swift.String? = nil
        )
        {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.cardExpiryDate = cardExpiryDate
            self.panSequenceNumber = panSequenceNumber
            self.serviceCode = serviceCode
        }
    }

}

extension PaymentCryptographyDataClientTypes.DynamicCardVerificationValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DynamicCardVerificationValue(applicationTransactionCounter: \(Swift.String(describing: applicationTransactionCounter)), panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), cardExpiryDate: \"CONTENT_REDACTED\", serviceCode: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Card data parameters that are required to generate Card Verification Values (CVV/CVV2), Dynamic Card Verification Values (dCVV/dCVV2), or Card Security Codes (CSC).
    public enum CardGenerationAttributes {
        /// Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.
        case amexcardsecuritycodeversion1(PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion1)
        /// Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.
        case amexcardsecuritycodeversion2(PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion2)
        /// Card data parameters that are required to generate Card Verification Value (CVV) for the payment card.
        case cardverificationvalue1(PaymentCryptographyDataClientTypes.CardVerificationValue1)
        /// Card data parameters that are required to generate Card Verification Value (CVV2) for the payment card.
        case cardverificationvalue2(PaymentCryptographyDataClientTypes.CardVerificationValue2)
        /// Card data parameters that are required to generate a cardholder verification value for the payment card.
        case cardholderverificationvalue(PaymentCryptographyDataClientTypes.CardHolderVerificationValue)
        /// Card data parameters that are required to generate CDynamic Card Verification Code (dCVC) for the payment card.
        case dynamiccardverificationcode(PaymentCryptographyDataClientTypes.DynamicCardVerificationCode)
        /// Card data parameters that are required to generate CDynamic Card Verification Value (dCVV) for the payment card.
        case dynamiccardverificationvalue(PaymentCryptographyDataClientTypes.DynamicCardVerificationValue)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify dCVC (Dynamic Card Verification Code).
    public struct DiscoverDynamicCardVerificationCode {
        /// The transaction counter value that comes from the terminal.
        /// This member is required.
        public var applicationTransactionCounter: Swift.String?
        /// The expiry date of a payment card.
        /// This member is required.
        public var cardExpiryDate: Swift.String?
        /// A random number that is generated by the issuer.
        /// This member is required.
        public var unpredictableNumber: Swift.String?

        public init(
            applicationTransactionCounter: Swift.String? = nil,
            cardExpiryDate: Swift.String? = nil,
            unpredictableNumber: Swift.String? = nil
        )
        {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.cardExpiryDate = cardExpiryDate
            self.unpredictableNumber = unpredictableNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.DiscoverDynamicCardVerificationCode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DiscoverDynamicCardVerificationCode(applicationTransactionCounter: \(Swift.String(describing: applicationTransactionCounter)), unpredictableNumber: \(Swift.String(describing: unpredictableNumber)), cardExpiryDate: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Card data parameters that are requried to verify Card Verification Values (CVV/CVV2), Dynamic Card Verification Values (dCVV/dCVV2), or Card Security Codes (CSC).
    public enum CardVerificationAttributes {
        /// Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.
        case amexcardsecuritycodeversion1(PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion1)
        /// Card data parameters that are required to verify a Card Security Code (CSC2) for an AMEX payment card.
        case amexcardsecuritycodeversion2(PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion2)
        /// Card data parameters that are required to verify Card Verification Value (CVV) for the payment card.
        case cardverificationvalue1(PaymentCryptographyDataClientTypes.CardVerificationValue1)
        /// Card data parameters that are required to verify Card Verification Value (CVV2) for the payment card.
        case cardverificationvalue2(PaymentCryptographyDataClientTypes.CardVerificationValue2)
        /// Card data parameters that are required to verify a cardholder verification value for the payment card.
        case cardholderverificationvalue(PaymentCryptographyDataClientTypes.CardHolderVerificationValue)
        /// Card data parameters that are required to verify CDynamic Card Verification Code (dCVC) for the payment card.
        case dynamiccardverificationcode(PaymentCryptographyDataClientTypes.DynamicCardVerificationCode)
        /// Card data parameters that are required to verify CDynamic Card Verification Value (dCVV) for the payment card.
        case dynamiccardverificationvalue(PaymentCryptographyDataClientTypes.DynamicCardVerificationValue)
        /// Card data parameters that are required to verify CDynamic Card Verification Code (dCVC) for the payment card.
        case discoverdynamiccardverificationcode(PaymentCryptographyDataClientTypes.DiscoverDynamicCardVerificationCode)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for ARPC response generation using method1 after ARQC verification is successful.
    public struct CryptogramVerificationArpcMethod1 {
        /// The auth code used to calculate APRC after ARQC verification is successful. This is the same auth code used for ARQC generation outside of Amazon Web Services Payment Cryptography.
        /// This member is required.
        public var authResponseCode: Swift.String?

        public init(
            authResponseCode: Swift.String? = nil
        )
        {
            self.authResponseCode = authResponseCode
        }
    }

}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for ARPC response generation using method2 after ARQC verification is successful.
    public struct CryptogramVerificationArpcMethod2 {
        /// The data indicating whether the issuer approves or declines an online transaction using an EMV chip card.
        /// This member is required.
        public var cardStatusUpdate: Swift.String?
        /// The proprietary authentication data used by issuer for communication during online transaction using an EMV chip card.
        public var proprietaryAuthenticationData: Swift.String?

        public init(
            cardStatusUpdate: Swift.String? = nil,
            proprietaryAuthenticationData: Swift.String? = nil
        )
        {
            self.cardStatusUpdate = cardStatusUpdate
            self.proprietaryAuthenticationData = proprietaryAuthenticationData
        }
    }

}

extension PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod2: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CryptogramVerificationArpcMethod2(cardStatusUpdate: \(Swift.String(describing: cardStatusUpdate)), proprietaryAuthenticationData: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for Authorization Response Cryptogram (ARPC) generation after Authorization Request Cryptogram (ARQC) verification is successful.
    public enum CryptogramAuthResponse {
        /// Parameters that are required for ARPC response generation using method1 after ARQC verification is successful.
        case arpcmethod1(PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod1)
        /// Parameters that are required for ARPC response generation using method2 after ARQC verification is successful.
        case arpcmethod2(PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod2)
        case sdkUnknown(Swift.String)
    }

}

/// The request processing has failed because of an unknown error, exception, or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to an invalid resource error.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The resource that is missing.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        resourceId: Swift.String? = nil
    )
    {
        self.properties.resourceId = resourceId
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PaymentCryptographyDataClientTypes {
    /// The request was denied due to an invalid request error.
    public struct ValidationExceptionField {
        /// The request was denied due to an invalid request error.
        /// This member is required.
        public var message: Swift.String?
        /// The request was denied due to an invalid request error.
        /// This member is required.
        public var path: Swift.String?

        public init(
            message: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.message = message
            self.path = path
        }
    }

}

/// The request was denied due to an invalid request error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The request was denied due to an invalid request error.
        public internal(set) var fieldList: [PaymentCryptographyDataClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [PaymentCryptographyDataClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
    }
}

extension PaymentCryptographyDataClientTypes {

    public enum DukptDerivationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aes128
        case aes192
        case aes256
        case tdes2key
        case tdes3key
        case sdkUnknown(Swift.String)

        public static var allCases: [DukptDerivationType] {
            return [
                .aes128,
                .aes192,
                .aes256,
                .tdes2key,
                .tdes3key
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aes128: return "AES_128"
            case .aes192: return "AES_192"
            case .aes256: return "AES_256"
            case .tdes2key: return "TDES_2KEY"
            case .tdes3key: return "TDES_3KEY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PaymentCryptographyDataClientTypes {

    public enum DukptKeyVariant: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bidirectional
        case request
        case response
        case sdkUnknown(Swift.String)

        public static var allCases: [DukptKeyVariant] {
            return [
                .bidirectional,
                .request,
                .response
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bidirectional: return "BIDIRECTIONAL"
            case .request: return "REQUEST"
            case .response: return "RESPONSE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PaymentCryptographyDataClientTypes {

    public enum DukptEncryptionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cbc
        case ecb
        case sdkUnknown(Swift.String)

        public static var allCases: [DukptEncryptionMode] {
            return [
                .cbc,
                .ecb
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cbc: return "CBC"
            case .ecb: return "ECB"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to encrypt plaintext data using DUKPT.
    public struct DukptEncryptionAttributes {
        /// The key type encrypted using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use AES_128 as a derivation type for a BDK of AES_128 or TDES_2KEY
        public var dukptKeyDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType?
        /// The type of use of DUKPT, which can be incoming data decryption, outgoing data encryption, or both.
        public var dukptKeyVariant: PaymentCryptographyDataClientTypes.DukptKeyVariant?
        /// An input used to provide the intial state. If no value is provided, Amazon Web Services Payment Cryptography defaults it to zero.
        public var initializationVector: Swift.String?
        /// The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.
        /// This member is required.
        public var keySerialNumber: Swift.String?
        /// The block cipher method to use for encryption. The default is CBC.
        public var mode: PaymentCryptographyDataClientTypes.DukptEncryptionMode?

        public init(
            dukptKeyDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType? = nil,
            dukptKeyVariant: PaymentCryptographyDataClientTypes.DukptKeyVariant? = nil,
            initializationVector: Swift.String? = nil,
            keySerialNumber: Swift.String? = nil,
            mode: PaymentCryptographyDataClientTypes.DukptEncryptionMode? = nil
        )
        {
            self.dukptKeyDerivationType = dukptKeyDerivationType
            self.dukptKeyVariant = dukptKeyVariant
            self.initializationVector = initializationVector
            self.keySerialNumber = keySerialNumber
            self.mode = mode
        }
    }

}

extension PaymentCryptographyDataClientTypes.DukptEncryptionAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DukptEncryptionAttributes(dukptKeyDerivationType: \(Swift.String(describing: dukptKeyDerivationType)), dukptKeyVariant: \(Swift.String(describing: dukptKeyVariant)), keySerialNumber: \(Swift.String(describing: keySerialNumber)), mode: \(Swift.String(describing: mode)), initializationVector: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {

    public enum EmvMajorKeyDerivationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case emvOptionA
        case emvOptionB
        case sdkUnknown(Swift.String)

        public static var allCases: [EmvMajorKeyDerivationMode] {
            return [
                .emvOptionA,
                .emvOptionB
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .emvOptionA: return "EMV_OPTION_A"
            case .emvOptionB: return "EMV_OPTION_B"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PaymentCryptographyDataClientTypes {

    public enum EmvEncryptionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cbc
        case ecb
        case sdkUnknown(Swift.String)

        public static var allCases: [EmvEncryptionMode] {
            return [
                .cbc,
                .ecb
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cbc: return "CBC"
            case .ecb: return "ECB"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters for plaintext encryption using EMV keys.
    public struct EmvEncryptionAttributes {
        /// An input used to provide the intial state. If no value is provided, Amazon Web Services Payment Cryptography defaults it to zero.
        public var initializationVector: Swift.String?
        /// The EMV derivation mode to use for ICC master key derivation as per EMV version 4.3 book 2.
        /// This member is required.
        public var majorKeyDerivationMode: PaymentCryptographyDataClientTypes.EmvMajorKeyDerivationMode?
        /// The block cipher method to use for encryption.
        public var mode: PaymentCryptographyDataClientTypes.EmvEncryptionMode?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?
        /// The derivation value used to derive the ICC session key. It is typically the application transaction counter value padded with zeros or previous ARQC value padded with zeros as per EMV version 4.3 book 2.
        /// This member is required.
        public var sessionDerivationData: Swift.String?

        public init(
            initializationVector: Swift.String? = nil,
            majorKeyDerivationMode: PaymentCryptographyDataClientTypes.EmvMajorKeyDerivationMode? = nil,
            mode: PaymentCryptographyDataClientTypes.EmvEncryptionMode? = nil,
            panSequenceNumber: Swift.String? = nil,
            primaryAccountNumber: Swift.String? = nil,
            sessionDerivationData: Swift.String? = nil
        )
        {
            self.initializationVector = initializationVector
            self.majorKeyDerivationMode = majorKeyDerivationMode
            self.mode = mode
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
            self.sessionDerivationData = sessionDerivationData
        }
    }

}

extension PaymentCryptographyDataClientTypes.EmvEncryptionAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EmvEncryptionAttributes(majorKeyDerivationMode: \(Swift.String(describing: majorKeyDerivationMode)), mode: \(Swift.String(describing: mode)), panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), initializationVector: \"CONTENT_REDACTED\", primaryAccountNumber: \"CONTENT_REDACTED\", sessionDerivationData: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {

    public enum EncryptionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cbc
        case cfb
        case cfb1
        case cfb128
        case cfb64
        case cfb8
        case ecb
        case ofb
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionMode] {
            return [
                .cbc,
                .cfb,
                .cfb1,
                .cfb128,
                .cfb64,
                .cfb8,
                .ecb,
                .ofb
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cbc: return "CBC"
            case .cfb: return "CFB"
            case .cfb1: return "CFB1"
            case .cfb128: return "CFB128"
            case .cfb64: return "CFB64"
            case .cfb8: return "CFB8"
            case .ecb: return "ECB"
            case .ofb: return "OFB"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters requried to encrypt plaintext data using symmetric keys.
    public struct SymmetricEncryptionAttributes {
        /// An input used to provide the intial state. If no value is provided, Amazon Web Services Payment Cryptography defaults it to zero.
        public var initializationVector: Swift.String?
        /// The block cipher method to use for encryption.
        /// This member is required.
        public var mode: PaymentCryptographyDataClientTypes.EncryptionMode?
        /// The padding to be included with the data.
        public var paddingType: PaymentCryptographyDataClientTypes.PaddingType?

        public init(
            initializationVector: Swift.String? = nil,
            mode: PaymentCryptographyDataClientTypes.EncryptionMode? = nil,
            paddingType: PaymentCryptographyDataClientTypes.PaddingType? = nil
        )
        {
            self.initializationVector = initializationVector
            self.mode = mode
            self.paddingType = paddingType
        }
    }

}

extension PaymentCryptographyDataClientTypes.SymmetricEncryptionAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SymmetricEncryptionAttributes(mode: \(Swift.String(describing: mode)), paddingType: \(Swift.String(describing: paddingType)), initializationVector: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to perform encryption and decryption operations.
    public enum EncryptionDecryptionAttributes {
        /// Parameters that are required to perform encryption and decryption using symmetric keys.
        case symmetric(PaymentCryptographyDataClientTypes.SymmetricEncryptionAttributes)
        /// Parameters for plaintext encryption using asymmetric keys.
        case asymmetric(PaymentCryptographyDataClientTypes.AsymmetricEncryptionAttributes)
        /// Parameters that are required to encrypt plaintext data using DUKPT.
        case dukpt(PaymentCryptographyDataClientTypes.DukptEncryptionAttributes)
        /// Parameters for plaintext encryption using EMV keys.
        case emv(PaymentCryptographyDataClientTypes.EmvEncryptionAttributes)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes {

    public enum KeyCheckValueAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ansiX924
        case cmac
        case sdkUnknown(Swift.String)

        public static var allCases: [KeyCheckValueAlgorithm] {
            return [
                .ansiX924,
                .cmac
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ansiX924: return "ANSI_X9_24"
            case .cmac: return "CMAC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameter information of a WrappedKeyBlock for encryption key exchange.
    public enum WrappedKeyMaterial {
        /// The TR-31 wrapped key block.
        case tr31keyblock(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes {
    /// Parameter information of a WrappedKeyBlock for encryption key exchange.
    public struct WrappedKey {
        /// The algorithm that Amazon Web Services Payment Cryptography uses to calculate the key check value (KCV). It is used to validate the key integrity. For TDES keys, the KCV is computed by encrypting 8 bytes, each with value of zero, with the key to be checked and retaining the 3 highest order bytes of the encrypted result. For AES keys, the KCV is computed using a CMAC algorithm where the input data is 16 bytes of zero and retaining the 3 highest order bytes of the encrypted result.
        public var keyCheckValueAlgorithm: PaymentCryptographyDataClientTypes.KeyCheckValueAlgorithm?
        /// Parameter information of a WrappedKeyBlock for encryption key exchange.
        /// This member is required.
        public var wrappedKeyMaterial: PaymentCryptographyDataClientTypes.WrappedKeyMaterial?

        public init(
            keyCheckValueAlgorithm: PaymentCryptographyDataClientTypes.KeyCheckValueAlgorithm? = nil,
            wrappedKeyMaterial: PaymentCryptographyDataClientTypes.WrappedKeyMaterial? = nil
        )
        {
            self.keyCheckValueAlgorithm = keyCheckValueAlgorithm
            self.wrappedKeyMaterial = wrappedKeyMaterial
        }
    }

}

public struct DecryptDataInput {
    /// The ciphertext to decrypt.
    /// This member is required.
    public var cipherText: Swift.String?
    /// The encryption key type and attributes for ciphertext decryption.
    /// This member is required.
    public var decryptionAttributes: PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes?
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for ciphertext decryption. When a WrappedKeyBlock is provided, this value will be the identifier to the key wrapping key. Otherwise, it is the key identifier used to perform the operation.
    /// This member is required.
    public var keyIdentifier: Swift.String?
    /// The WrappedKeyBlock containing the encryption key for ciphertext decryption.
    public var wrappedKey: PaymentCryptographyDataClientTypes.WrappedKey?

    public init(
        cipherText: Swift.String? = nil,
        decryptionAttributes: PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes? = nil,
        keyIdentifier: Swift.String? = nil,
        wrappedKey: PaymentCryptographyDataClientTypes.WrappedKey? = nil
    )
    {
        self.cipherText = cipherText
        self.decryptionAttributes = decryptionAttributes
        self.keyIdentifier = keyIdentifier
        self.wrappedKey = wrappedKey
    }
}

extension DecryptDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecryptDataInput(decryptionAttributes: \(Swift.String(describing: decryptionAttributes)), keyIdentifier: \(Swift.String(describing: keyIdentifier)), wrappedKey: \(Swift.String(describing: wrappedKey)), cipherText: \"CONTENT_REDACTED\")"}
}

public struct DecryptDataOutput {
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for ciphertext decryption.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
    /// This member is required.
    public var keyCheckValue: Swift.String?
    /// The decrypted plaintext data in hexBinary format.
    /// This member is required.
    public var plainText: Swift.String?

    public init(
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil,
        plainText: Swift.String? = nil
    )
    {
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
        self.plainText = plainText
    }
}

extension DecryptDataOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecryptDataOutput(keyArn: \(Swift.String(describing: keyArn)), keyCheckValue: \(Swift.String(describing: keyCheckValue)), plainText: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are used for Derived Unique Key Per Transaction (DUKPT) derivation algorithm.
    public struct DukptAttributes {
        /// The key type derived using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use AES_128 as a derivation type for a BDK of AES_128 or TDES_2KEY.
        /// This member is required.
        public var dukptDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType?
        /// The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.
        /// This member is required.
        public var keySerialNumber: Swift.String?

        public init(
            dukptDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType? = nil,
            keySerialNumber: Swift.String? = nil
        )
        {
            self.dukptDerivationType = dukptDerivationType
            self.keySerialNumber = keySerialNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes {
    /// Parameters required for encryption or decryption of data using DUKPT.
    public struct DukptDerivationAttributes {
        /// The key type derived using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use AES_128 as a derivation type for a BDK of AES_128 or TDES_2KEY
        public var dukptKeyDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType?
        /// The type of use of DUKPT, which can be for incoming data decryption, outgoing data encryption, or both.
        public var dukptKeyVariant: PaymentCryptographyDataClientTypes.DukptKeyVariant?
        /// The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.
        /// This member is required.
        public var keySerialNumber: Swift.String?

        public init(
            dukptKeyDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType? = nil,
            dukptKeyVariant: PaymentCryptographyDataClientTypes.DukptKeyVariant? = nil,
            keySerialNumber: Swift.String? = nil
        )
        {
            self.dukptKeyDerivationType = dukptKeyDerivationType
            self.dukptKeyVariant = dukptKeyVariant
            self.keySerialNumber = keySerialNumber
        }
    }

}

public struct EncryptDataInput {
    /// The encryption key type and attributes for plaintext encryption.
    /// This member is required.
    public var encryptionAttributes: PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes?
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for plaintext encryption. When a WrappedKeyBlock is provided, this value will be the identifier to the key wrapping key. Otherwise, it is the key identifier used to perform the operation.
    /// This member is required.
    public var keyIdentifier: Swift.String?
    /// The plaintext to be encrypted. For encryption using asymmetric keys, plaintext data length is constrained by encryption key strength that you define in KeyAlgorithm and padding type that you define in AsymmetricEncryptionAttributes. For more information, see [Encrypt data](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/encrypt-data.html) in the Amazon Web Services Payment Cryptography User Guide.
    /// This member is required.
    public var plainText: Swift.String?
    /// The WrappedKeyBlock containing the encryption key for plaintext encryption.
    public var wrappedKey: PaymentCryptographyDataClientTypes.WrappedKey?

    public init(
        encryptionAttributes: PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes? = nil,
        keyIdentifier: Swift.String? = nil,
        plainText: Swift.String? = nil,
        wrappedKey: PaymentCryptographyDataClientTypes.WrappedKey? = nil
    )
    {
        self.encryptionAttributes = encryptionAttributes
        self.keyIdentifier = keyIdentifier
        self.plainText = plainText
        self.wrappedKey = wrappedKey
    }
}

extension EncryptDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptDataInput(encryptionAttributes: \(Swift.String(describing: encryptionAttributes)), keyIdentifier: \(Swift.String(describing: keyIdentifier)), wrappedKey: \(Swift.String(describing: wrappedKey)), plainText: \"CONTENT_REDACTED\")"}
}

public struct EncryptDataOutput {
    /// The encrypted ciphertext.
    /// This member is required.
    public var cipherText: Swift.String?
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for plaintext encryption.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
    public var keyCheckValue: Swift.String?

    public init(
        cipherText: Swift.String? = nil,
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil
    )
    {
        self.cipherText = cipherText
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
    }
}

extension EncryptDataOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptDataOutput(keyArn: \(Swift.String(describing: keyArn)), keyCheckValue: \(Swift.String(describing: keyCheckValue)), cipherText: \"CONTENT_REDACTED\")"}
}

public struct GenerateCardValidationDataInput {
    /// The algorithm for generating CVV or CSC values for the card within Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var generationAttributes: PaymentCryptographyDataClientTypes.CardGenerationAttributes?
    /// The keyARN of the CVK encryption key that Amazon Web Services Payment Cryptography uses to generate card data.
    /// This member is required.
    public var keyIdentifier: Swift.String?
    /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.
    /// This member is required.
    public var primaryAccountNumber: Swift.String?
    /// The length of the CVV or CSC to be generated. The default value is 3.
    public var validationDataLength: Swift.Int?

    public init(
        generationAttributes: PaymentCryptographyDataClientTypes.CardGenerationAttributes? = nil,
        keyIdentifier: Swift.String? = nil,
        primaryAccountNumber: Swift.String? = nil,
        validationDataLength: Swift.Int? = nil
    )
    {
        self.generationAttributes = generationAttributes
        self.keyIdentifier = keyIdentifier
        self.primaryAccountNumber = primaryAccountNumber
        self.validationDataLength = validationDataLength
    }
}

extension GenerateCardValidationDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerateCardValidationDataInput(generationAttributes: \(Swift.String(describing: generationAttributes)), keyIdentifier: \(Swift.String(describing: keyIdentifier)), validationDataLength: \(Swift.String(describing: validationDataLength)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

public struct GenerateCardValidationDataOutput {
    /// The keyARN of the CVK encryption key that Amazon Web Services Payment Cryptography uses to generate CVV or CSC.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
    /// This member is required.
    public var keyCheckValue: Swift.String?
    /// The CVV or CSC value that Amazon Web Services Payment Cryptography generates for the card.
    /// This member is required.
    public var validationData: Swift.String?

    public init(
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil,
        validationData: Swift.String? = nil
    )
    {
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
        self.validationData = validationData
    }
}

extension GenerateCardValidationDataOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerateCardValidationDataOutput(keyArn: \(Swift.String(describing: keyArn)), keyCheckValue: \(Swift.String(describing: keyCheckValue)), validationData: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {

    public enum MacAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cmac
        case hmacSha224
        case hmacSha256
        case hmacSha384
        case hmacSha512
        case iso9797Algorithm1
        case iso9797Algorithm3
        case sdkUnknown(Swift.String)

        public static var allCases: [MacAlgorithm] {
            return [
                .cmac,
                .hmacSha224,
                .hmacSha256,
                .hmacSha384,
                .hmacSha512,
                .iso9797Algorithm1,
                .iso9797Algorithm3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cmac: return "CMAC"
            case .hmacSha224: return "HMAC_SHA224"
            case .hmacSha256: return "HMAC_SHA256"
            case .hmacSha384: return "HMAC_SHA384"
            case .hmacSha512: return "HMAC_SHA512"
            case .iso9797Algorithm1: return "ISO9797_ALGORITHM1"
            case .iso9797Algorithm3: return "ISO9797_ALGORITHM3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters required for DUKPT MAC generation and verification.
    public struct MacAlgorithmDukpt {
        /// The key type derived using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use AES_128 as a derivation type for a BDK of AES_128 or TDES_2KEY.
        public var dukptDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType?
        /// The type of use of DUKPT, which can be MAC generation, MAC verification, or both.
        /// This member is required.
        public var dukptKeyVariant: PaymentCryptographyDataClientTypes.DukptKeyVariant?
        /// The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.
        /// This member is required.
        public var keySerialNumber: Swift.String?

        public init(
            dukptDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType? = nil,
            dukptKeyVariant: PaymentCryptographyDataClientTypes.DukptKeyVariant? = nil,
            keySerialNumber: Swift.String? = nil
        )
        {
            self.dukptDerivationType = dukptDerivationType
            self.dukptKeyVariant = dukptKeyVariant
            self.keySerialNumber = keySerialNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes {

    public enum MajorKeyDerivationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case emvOptionA
        case emvOptionB
        case sdkUnknown(Swift.String)

        public static var allCases: [MajorKeyDerivationMode] {
            return [
                .emvOptionA,
                .emvOptionB
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .emvOptionA: return "EMV_OPTION_A"
            case .emvOptionB: return "EMV_OPTION_B"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PaymentCryptographyDataClientTypes {

    public enum SessionKeyDerivationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amex
        case emv2000
        case emvCommonSessionKey
        case mastercardSessionKey
        case visa
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionKeyDerivationMode] {
            return [
                .amex,
                .emv2000,
                .emvCommonSessionKey,
                .mastercardSessionKey,
                .visa
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amex: return "AMEX"
            case .emv2000: return "EMV2000"
            case .emvCommonSessionKey: return "EMV_COMMON_SESSION_KEY"
            case .mastercardSessionKey: return "MASTERCARD_SESSION_KEY"
            case .visa: return "VISA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters to derive session key value using a MAC EMV algorithm.
    public enum SessionKeyDerivationValue {
        /// The cryptogram provided by the terminal during transaction processing.
        case applicationcryptogram(Swift.String)
        /// The transaction counter that is provided by the terminal during transaction processing.
        case applicationtransactioncounter(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for EMV MAC generation and verification.
    public struct MacAlgorithmEmv {
        /// The method to use when deriving the master key for EMV MAC generation or verification.
        /// This member is required.
        public var majorKeyDerivationMode: PaymentCryptographyDataClientTypes.MajorKeyDerivationMode?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?
        /// The method of deriving a session key for EMV MAC generation or verification.
        /// This member is required.
        public var sessionKeyDerivationMode: PaymentCryptographyDataClientTypes.SessionKeyDerivationMode?
        /// Parameters that are required to generate session key for EMV generation and verification.
        /// This member is required.
        public var sessionKeyDerivationValue: PaymentCryptographyDataClientTypes.SessionKeyDerivationValue?

        public init(
            majorKeyDerivationMode: PaymentCryptographyDataClientTypes.MajorKeyDerivationMode? = nil,
            panSequenceNumber: Swift.String? = nil,
            primaryAccountNumber: Swift.String? = nil,
            sessionKeyDerivationMode: PaymentCryptographyDataClientTypes.SessionKeyDerivationMode? = nil,
            sessionKeyDerivationValue: PaymentCryptographyDataClientTypes.SessionKeyDerivationValue? = nil
        )
        {
            self.majorKeyDerivationMode = majorKeyDerivationMode
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
            self.sessionKeyDerivationMode = sessionKeyDerivationMode
            self.sessionKeyDerivationValue = sessionKeyDerivationValue
        }
    }

}

extension PaymentCryptographyDataClientTypes.MacAlgorithmEmv: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MacAlgorithmEmv(majorKeyDerivationMode: \(Swift.String(describing: majorKeyDerivationMode)), panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), sessionKeyDerivationMode: \(Swift.String(describing: sessionKeyDerivationMode)), sessionKeyDerivationValue: \(Swift.String(describing: sessionKeyDerivationValue)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for DUKPT, HMAC, or EMV MAC generation or verification.
    public enum MacAttributes {
        /// The encryption algorithm for MAC generation or verification.
        case algorithm(PaymentCryptographyDataClientTypes.MacAlgorithm)
        /// Parameters that are required for MAC generation or verification using EMV MAC algorithm.
        case emvmac(PaymentCryptographyDataClientTypes.MacAlgorithmEmv)
        /// Parameters that are required for MAC generation or verification using DUKPT ISO 9797 algorithm1.
        case dukptiso9797algorithm1(PaymentCryptographyDataClientTypes.MacAlgorithmDukpt)
        /// Parameters that are required for MAC generation or verification using DUKPT ISO 9797 algorithm3.
        case dukptiso9797algorithm3(PaymentCryptographyDataClientTypes.MacAlgorithmDukpt)
        /// Parameters that are required for MAC generation or verification using DUKPT CMAC algorithm.
        case dukptcmac(PaymentCryptographyDataClientTypes.MacAlgorithmDukpt)
        case sdkUnknown(Swift.String)
    }

}

public struct GenerateMacInput {
    /// The attributes and data values to use for MAC generation within Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var generationAttributes: PaymentCryptographyDataClientTypes.MacAttributes?
    /// The keyARN of the MAC generation encryption key.
    /// This member is required.
    public var keyIdentifier: Swift.String?
    /// The length of a MAC under generation.
    public var macLength: Swift.Int?
    /// The data for which a MAC is under generation. This value must be hexBinary.
    /// This member is required.
    public var messageData: Swift.String?

    public init(
        generationAttributes: PaymentCryptographyDataClientTypes.MacAttributes? = nil,
        keyIdentifier: Swift.String? = nil,
        macLength: Swift.Int? = nil,
        messageData: Swift.String? = nil
    )
    {
        self.generationAttributes = generationAttributes
        self.keyIdentifier = keyIdentifier
        self.macLength = macLength
        self.messageData = messageData
    }
}

extension GenerateMacInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerateMacInput(generationAttributes: \(Swift.String(describing: generationAttributes)), keyIdentifier: \(Swift.String(describing: keyIdentifier)), macLength: \(Swift.String(describing: macLength)), messageData: \"CONTENT_REDACTED\")"}
}

public struct GenerateMacOutput {
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for MAC generation.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
    /// This member is required.
    public var keyCheckValue: Swift.String?
    /// The MAC cryptogram generated within Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var mac: Swift.String?

    public init(
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil,
        mac: Swift.String? = nil
    )
    {
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
        self.mac = mac
    }
}

extension GenerateMacOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerateMacOutput(keyArn: \(Swift.String(describing: keyArn)), keyCheckValue: \(Swift.String(describing: keyCheckValue)), mac: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Ibm3624 natural PIN.
    public struct Ibm3624NaturalPin {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        /// This member is required.
        public var decimalizationTable: Swift.String?
        /// The unique data for cardholder identification.
        /// This member is required.
        public var pinValidationData: Swift.String?
        /// The padding character for validation data.
        /// This member is required.
        public var pinValidationDataPadCharacter: Swift.String?

        public init(
            decimalizationTable: Swift.String? = nil,
            pinValidationData: Swift.String? = nil,
            pinValidationDataPadCharacter: Swift.String? = nil
        )
        {
            self.decimalizationTable = decimalizationTable
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }
    }

}

extension PaymentCryptographyDataClientTypes.Ibm3624NaturalPin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Ibm3624NaturalPin(pinValidationDataPadCharacter: \(Swift.String(describing: pinValidationDataPadCharacter)), decimalizationTable: \"CONTENT_REDACTED\", pinValidationData: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Ibm3624 PIN from offset PIN.
    public struct Ibm3624PinFromOffset {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        /// This member is required.
        public var decimalizationTable: Swift.String?
        /// The PIN offset value.
        /// This member is required.
        public var pinOffset: Swift.String?
        /// The unique data for cardholder identification.
        /// This member is required.
        public var pinValidationData: Swift.String?
        /// The padding character for validation data.
        /// This member is required.
        public var pinValidationDataPadCharacter: Swift.String?

        public init(
            decimalizationTable: Swift.String? = nil,
            pinOffset: Swift.String? = nil,
            pinValidationData: Swift.String? = nil,
            pinValidationDataPadCharacter: Swift.String? = nil
        )
        {
            self.decimalizationTable = decimalizationTable
            self.pinOffset = pinOffset
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }
    }

}

extension PaymentCryptographyDataClientTypes.Ibm3624PinFromOffset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Ibm3624PinFromOffset(pinValidationDataPadCharacter: \(Swift.String(describing: pinValidationDataPadCharacter)), decimalizationTable: \"CONTENT_REDACTED\", pinOffset: \"CONTENT_REDACTED\", pinValidationData: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Pparameters that are required to generate or verify Ibm3624 PIN offset PIN.
    public struct Ibm3624PinOffset {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        /// This member is required.
        public var decimalizationTable: Swift.String?
        /// The encrypted PIN block data. According to ISO 9564 standard, a PIN Block is an encoded representation of a payment card Personal Account Number (PAN) and the cardholder Personal Identification Number (PIN).
        /// This member is required.
        public var encryptedPinBlock: Swift.String?
        /// The unique data for cardholder identification.
        /// This member is required.
        public var pinValidationData: Swift.String?
        /// The padding character for validation data.
        /// This member is required.
        public var pinValidationDataPadCharacter: Swift.String?

        public init(
            decimalizationTable: Swift.String? = nil,
            encryptedPinBlock: Swift.String? = nil,
            pinValidationData: Swift.String? = nil,
            pinValidationDataPadCharacter: Swift.String? = nil
        )
        {
            self.decimalizationTable = decimalizationTable
            self.encryptedPinBlock = encryptedPinBlock
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }
    }

}

extension PaymentCryptographyDataClientTypes.Ibm3624PinOffset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Ibm3624PinOffset(pinValidationDataPadCharacter: \(Swift.String(describing: pinValidationDataPadCharacter)), decimalizationTable: \"CONTENT_REDACTED\", encryptedPinBlock: \"CONTENT_REDACTED\", pinValidationData: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Ibm3624 random PIN.
    public struct Ibm3624RandomPin {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        /// This member is required.
        public var decimalizationTable: Swift.String?
        /// The unique data for cardholder identification.
        /// This member is required.
        public var pinValidationData: Swift.String?
        /// The padding character for validation data.
        /// This member is required.
        public var pinValidationDataPadCharacter: Swift.String?

        public init(
            decimalizationTable: Swift.String? = nil,
            pinValidationData: Swift.String? = nil,
            pinValidationDataPadCharacter: Swift.String? = nil
        )
        {
            self.decimalizationTable = decimalizationTable
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }
    }

}

extension PaymentCryptographyDataClientTypes.Ibm3624RandomPin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Ibm3624RandomPin(pinValidationDataPadCharacter: \(Swift.String(describing: pinValidationDataPadCharacter)), decimalizationTable: \"CONTENT_REDACTED\", pinValidationData: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Visa PIN.
    public struct VisaPin {
        /// The value for PIN verification index. It is used in the Visa PIN algorithm to calculate the PVV (PIN Verification Value).
        /// This member is required.
        public var pinVerificationKeyIndex: Swift.Int?

        public init(
            pinVerificationKeyIndex: Swift.Int? = nil
        )
        {
            self.pinVerificationKeyIndex = pinVerificationKeyIndex
        }
    }

}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Visa PVV (PIN Verification Value).
    public struct VisaPinVerificationValue {
        /// The encrypted PIN block data to verify.
        /// This member is required.
        public var encryptedPinBlock: Swift.String?
        /// The value for PIN verification index. It is used in the Visa PIN algorithm to calculate the PVV (PIN Verification Value).
        /// This member is required.
        public var pinVerificationKeyIndex: Swift.Int?

        public init(
            encryptedPinBlock: Swift.String? = nil,
            pinVerificationKeyIndex: Swift.Int? = nil
        )
        {
            self.encryptedPinBlock = encryptedPinBlock
            self.pinVerificationKeyIndex = pinVerificationKeyIndex
        }
    }

}

extension PaymentCryptographyDataClientTypes.VisaPinVerificationValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VisaPinVerificationValue(pinVerificationKeyIndex: \(Swift.String(describing: pinVerificationKeyIndex)), encryptedPinBlock: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for PIN data generation.
    public enum PinGenerationAttributes {
        /// Parameters that are required to generate or verify Visa PIN.
        case visapin(PaymentCryptographyDataClientTypes.VisaPin)
        /// Parameters that are required to generate or verify Visa PIN Verification Value (PVV).
        case visapinverificationvalue(PaymentCryptographyDataClientTypes.VisaPinVerificationValue)
        /// Parameters that are required to generate or verify Ibm3624 PIN offset PIN.
        case ibm3624pinoffset(PaymentCryptographyDataClientTypes.Ibm3624PinOffset)
        /// Parameters that are required to generate or verify Ibm3624 natural PIN.
        case ibm3624naturalpin(PaymentCryptographyDataClientTypes.Ibm3624NaturalPin)
        /// Parameters that are required to generate or verify Ibm3624 random PIN.
        case ibm3624randompin(PaymentCryptographyDataClientTypes.Ibm3624RandomPin)
        /// Parameters that are required to generate or verify Ibm3624 PIN from offset PIN.
        case ibm3624pinfromoffset(PaymentCryptographyDataClientTypes.Ibm3624PinFromOffset)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes {

    public enum PinBlockFormatForPinData: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case isoFormat0
        case isoFormat3
        case sdkUnknown(Swift.String)

        public static var allCases: [PinBlockFormatForPinData] {
            return [
                .isoFormat0,
                .isoFormat3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .isoFormat0: return "ISO_FORMAT_0"
            case .isoFormat3: return "ISO_FORMAT_3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GeneratePinDataInput {
    /// The keyARN of the PEK that Amazon Web Services Payment Cryptography uses to encrypt the PIN Block.
    /// This member is required.
    public var encryptionKeyIdentifier: Swift.String?
    /// The attributes and values to use for PIN, PVV, or PIN Offset generation.
    /// This member is required.
    public var generationAttributes: PaymentCryptographyDataClientTypes.PinGenerationAttributes?
    /// The keyARN of the PEK that Amazon Web Services Payment Cryptography uses for pin data generation.
    /// This member is required.
    public var generationKeyIdentifier: Swift.String?
    /// The PIN encoding format for pin data generation as specified in ISO 9564. Amazon Web Services Payment Cryptography supports ISO_Format_0 and ISO_Format_3. The ISO_Format_0 PIN block format is equivalent to the ANSI X9.8, VISA-1, and ECI-1 PIN block formats. It is similar to a VISA-4 PIN block format. It supports a PIN from 4 to 12 digits in length. The ISO_Format_3 PIN block format is the same as ISO_Format_0 except that the fill digits are random values from 10 to 15.
    /// This member is required.
    public var pinBlockFormat: PaymentCryptographyDataClientTypes.PinBlockFormatForPinData?
    /// The length of PIN under generation.
    public var pinDataLength: Swift.Int?
    /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.
    /// This member is required.
    public var primaryAccountNumber: Swift.String?

    public init(
        encryptionKeyIdentifier: Swift.String? = nil,
        generationAttributes: PaymentCryptographyDataClientTypes.PinGenerationAttributes? = nil,
        generationKeyIdentifier: Swift.String? = nil,
        pinBlockFormat: PaymentCryptographyDataClientTypes.PinBlockFormatForPinData? = nil,
        pinDataLength: Swift.Int? = nil,
        primaryAccountNumber: Swift.String? = nil
    )
    {
        self.encryptionKeyIdentifier = encryptionKeyIdentifier
        self.generationAttributes = generationAttributes
        self.generationKeyIdentifier = generationKeyIdentifier
        self.pinBlockFormat = pinBlockFormat
        self.pinDataLength = pinDataLength
        self.primaryAccountNumber = primaryAccountNumber
    }
}

extension GeneratePinDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeneratePinDataInput(encryptionKeyIdentifier: \(Swift.String(describing: encryptionKeyIdentifier)), generationAttributes: \(Swift.String(describing: generationAttributes)), generationKeyIdentifier: \(Swift.String(describing: generationKeyIdentifier)), pinBlockFormat: \(Swift.String(describing: pinBlockFormat)), pinDataLength: \(Swift.String(describing: pinDataLength)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate, translate, or verify PIN data.
    public enum PinData {
        /// The PIN offset value.
        case pinoffset(Swift.String)
        /// The unique data to identify a cardholder. In most cases, this is the same as cardholder's Primary Account Number (PAN). If a value is not provided, it defaults to PAN.
        case verificationvalue(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

public struct GeneratePinDataOutput {
    /// The PIN block encrypted under PEK from Amazon Web Services Payment Cryptography. The encrypted PIN block is a composite of PAN (Primary Account Number) and PIN (Personal Identification Number), generated in accordance with ISO 9564 standard.
    /// This member is required.
    public var encryptedPinBlock: Swift.String?
    /// The keyARN of the PEK that Amazon Web Services Payment Cryptography uses for encrypted pin block generation.
    /// This member is required.
    public var encryptionKeyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
    /// This member is required.
    public var encryptionKeyCheckValue: Swift.String?
    /// The keyARN of the pin data generation key that Amazon Web Services Payment Cryptography uses for PIN, PVV or PIN Offset generation.
    /// This member is required.
    public var generationKeyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
    /// This member is required.
    public var generationKeyCheckValue: Swift.String?
    /// The attributes and values Amazon Web Services Payment Cryptography uses for pin data generation.
    /// This member is required.
    public var pinData: PaymentCryptographyDataClientTypes.PinData?

    public init(
        encryptedPinBlock: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil,
        encryptionKeyCheckValue: Swift.String? = nil,
        generationKeyArn: Swift.String? = nil,
        generationKeyCheckValue: Swift.String? = nil,
        pinData: PaymentCryptographyDataClientTypes.PinData? = nil
    )
    {
        self.encryptedPinBlock = encryptedPinBlock
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionKeyCheckValue = encryptionKeyCheckValue
        self.generationKeyArn = generationKeyArn
        self.generationKeyCheckValue = generationKeyCheckValue
        self.pinData = pinData
    }
}

extension GeneratePinDataOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeneratePinDataOutput(encryptionKeyArn: \(Swift.String(describing: encryptionKeyArn)), encryptionKeyCheckValue: \(Swift.String(describing: encryptionKeyCheckValue)), generationKeyArn: \(Swift.String(describing: generationKeyArn)), generationKeyCheckValue: \(Swift.String(describing: generationKeyCheckValue)), pinData: \(Swift.String(describing: pinData)), encryptedPinBlock: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Ibm3624 PIN verification PIN.
    public struct Ibm3624PinVerification {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        /// This member is required.
        public var decimalizationTable: Swift.String?
        /// The PIN offset value.
        /// This member is required.
        public var pinOffset: Swift.String?
        /// The unique data for cardholder identification.
        /// This member is required.
        public var pinValidationData: Swift.String?
        /// The padding character for validation data.
        /// This member is required.
        public var pinValidationDataPadCharacter: Swift.String?

        public init(
            decimalizationTable: Swift.String? = nil,
            pinOffset: Swift.String? = nil,
            pinValidationData: Swift.String? = nil,
            pinValidationDataPadCharacter: Swift.String? = nil
        )
        {
            self.decimalizationTable = decimalizationTable
            self.pinOffset = pinOffset
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }
    }

}

extension PaymentCryptographyDataClientTypes.Ibm3624PinVerification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Ibm3624PinVerification(pinValidationDataPadCharacter: \(Swift.String(describing: pinValidationDataPadCharacter)), decimalizationTable: \"CONTENT_REDACTED\", pinOffset: \"CONTENT_REDACTED\", pinValidationData: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to perform reencryption operation.
    public enum ReEncryptionAttributes {
        /// Parameters that are required to encrypt data using symmetric keys.
        case symmetric(PaymentCryptographyDataClientTypes.SymmetricEncryptionAttributes)
        /// Parameters that are required to encrypt plaintext data using DUKPT.
        case dukpt(PaymentCryptographyDataClientTypes.DukptEncryptionAttributes)
        case sdkUnknown(Swift.String)
    }

}

public struct ReEncryptDataInput {
    /// Ciphertext to be encrypted. The minimum allowed length is 16 bytes and maximum allowed length is 4096 bytes.
    /// This member is required.
    public var cipherText: Swift.String?
    /// The attributes and values for incoming ciphertext.
    /// This member is required.
    public var incomingEncryptionAttributes: PaymentCryptographyDataClientTypes.ReEncryptionAttributes?
    /// The keyARN of the encryption key of incoming ciphertext data. When a WrappedKeyBlock is provided, this value will be the identifier to the key wrapping key. Otherwise, it is the key identifier used to perform the operation.
    /// This member is required.
    public var incomingKeyIdentifier: Swift.String?
    /// The WrappedKeyBlock containing the encryption key of incoming ciphertext data.
    public var incomingWrappedKey: PaymentCryptographyDataClientTypes.WrappedKey?
    /// The attributes and values for outgoing ciphertext data after encryption by Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var outgoingEncryptionAttributes: PaymentCryptographyDataClientTypes.ReEncryptionAttributes?
    /// The keyARN of the encryption key of outgoing ciphertext data after encryption by Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var outgoingKeyIdentifier: Swift.String?
    /// The WrappedKeyBlock containing the encryption key of outgoing ciphertext data after encryption by Amazon Web Services Payment Cryptography.
    public var outgoingWrappedKey: PaymentCryptographyDataClientTypes.WrappedKey?

    public init(
        cipherText: Swift.String? = nil,
        incomingEncryptionAttributes: PaymentCryptographyDataClientTypes.ReEncryptionAttributes? = nil,
        incomingKeyIdentifier: Swift.String? = nil,
        incomingWrappedKey: PaymentCryptographyDataClientTypes.WrappedKey? = nil,
        outgoingEncryptionAttributes: PaymentCryptographyDataClientTypes.ReEncryptionAttributes? = nil,
        outgoingKeyIdentifier: Swift.String? = nil,
        outgoingWrappedKey: PaymentCryptographyDataClientTypes.WrappedKey? = nil
    )
    {
        self.cipherText = cipherText
        self.incomingEncryptionAttributes = incomingEncryptionAttributes
        self.incomingKeyIdentifier = incomingKeyIdentifier
        self.incomingWrappedKey = incomingWrappedKey
        self.outgoingEncryptionAttributes = outgoingEncryptionAttributes
        self.outgoingKeyIdentifier = outgoingKeyIdentifier
        self.outgoingWrappedKey = outgoingWrappedKey
    }
}

extension ReEncryptDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReEncryptDataInput(incomingEncryptionAttributes: \(Swift.String(describing: incomingEncryptionAttributes)), incomingKeyIdentifier: \(Swift.String(describing: incomingKeyIdentifier)), incomingWrappedKey: \(Swift.String(describing: incomingWrappedKey)), outgoingEncryptionAttributes: \(Swift.String(describing: outgoingEncryptionAttributes)), outgoingKeyIdentifier: \(Swift.String(describing: outgoingKeyIdentifier)), outgoingWrappedKey: \(Swift.String(describing: outgoingWrappedKey)), cipherText: \"CONTENT_REDACTED\")"}
}

public struct ReEncryptDataOutput {
    /// The encrypted ciphertext.
    /// This member is required.
    public var cipherText: Swift.String?
    /// The keyARN (Amazon Resource Name) of the encryption key that Amazon Web Services Payment Cryptography uses for plaintext encryption.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
    /// This member is required.
    public var keyCheckValue: Swift.String?

    public init(
        cipherText: Swift.String? = nil,
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil
    )
    {
        self.cipherText = cipherText
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
    }
}

extension ReEncryptDataOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReEncryptDataOutput(keyArn: \(Swift.String(describing: keyArn)), keyCheckValue: \(Swift.String(describing: keyCheckValue)), cipherText: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for tranlation between ISO9564 PIN format 0,3,4 tranlation.
    public struct TranslationPinDataIsoFormat034 {
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?

        public init(
            primaryAccountNumber: Swift.String? = nil
        )
        {
            self.primaryAccountNumber = primaryAccountNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TranslationPinDataIsoFormat034(primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for ISO9564 PIN format 1 tranlation.
    public struct TranslationPinDataIsoFormat1 {

        public init() { }
    }

}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for translation between ISO9564 PIN block formats 0,1,3,4.
    public enum TranslationIsoFormats {
        /// Parameters that are required for ISO9564 PIN format 0 tranlation.
        case isoformat0(PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034)
        /// Parameters that are required for ISO9564 PIN format 1 tranlation.
        case isoformat1(PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat1)
        /// Parameters that are required for ISO9564 PIN format 3 tranlation.
        case isoformat3(PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034)
        /// Parameters that are required for ISO9564 PIN format 4 tranlation.
        case isoformat4(PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034)
        case sdkUnknown(Swift.String)
    }

}

public struct TranslatePinDataInput {
    /// The encrypted PIN block data that Amazon Web Services Payment Cryptography translates.
    /// This member is required.
    public var encryptedPinBlock: Swift.String?
    /// The attributes and values to use for incoming DUKPT encryption key for PIN block translation.
    public var incomingDukptAttributes: PaymentCryptographyDataClientTypes.DukptDerivationAttributes?
    /// The keyARN of the encryption key under which incoming PIN block data is encrypted. This key type can be PEK or BDK. When a WrappedKeyBlock is provided, this value will be the identifier to the key wrapping key for PIN block. Otherwise, it is the key identifier used to perform the operation.
    /// This member is required.
    public var incomingKeyIdentifier: Swift.String?
    /// The format of the incoming PIN block data for translation within Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var incomingTranslationAttributes: PaymentCryptographyDataClientTypes.TranslationIsoFormats?
    /// The WrappedKeyBlock containing the encryption key under which incoming PIN block data is encrypted.
    public var incomingWrappedKey: PaymentCryptographyDataClientTypes.WrappedKey?
    /// The attributes and values to use for outgoing DUKPT encryption key after PIN block translation.
    public var outgoingDukptAttributes: PaymentCryptographyDataClientTypes.DukptDerivationAttributes?
    /// The keyARN of the encryption key for encrypting outgoing PIN block data. This key type can be PEK or BDK.
    /// This member is required.
    public var outgoingKeyIdentifier: Swift.String?
    /// The format of the outgoing PIN block data after translation by Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var outgoingTranslationAttributes: PaymentCryptographyDataClientTypes.TranslationIsoFormats?
    /// The WrappedKeyBlock containing the encryption key for encrypting outgoing PIN block data.
    public var outgoingWrappedKey: PaymentCryptographyDataClientTypes.WrappedKey?

    public init(
        encryptedPinBlock: Swift.String? = nil,
        incomingDukptAttributes: PaymentCryptographyDataClientTypes.DukptDerivationAttributes? = nil,
        incomingKeyIdentifier: Swift.String? = nil,
        incomingTranslationAttributes: PaymentCryptographyDataClientTypes.TranslationIsoFormats? = nil,
        incomingWrappedKey: PaymentCryptographyDataClientTypes.WrappedKey? = nil,
        outgoingDukptAttributes: PaymentCryptographyDataClientTypes.DukptDerivationAttributes? = nil,
        outgoingKeyIdentifier: Swift.String? = nil,
        outgoingTranslationAttributes: PaymentCryptographyDataClientTypes.TranslationIsoFormats? = nil,
        outgoingWrappedKey: PaymentCryptographyDataClientTypes.WrappedKey? = nil
    )
    {
        self.encryptedPinBlock = encryptedPinBlock
        self.incomingDukptAttributes = incomingDukptAttributes
        self.incomingKeyIdentifier = incomingKeyIdentifier
        self.incomingTranslationAttributes = incomingTranslationAttributes
        self.incomingWrappedKey = incomingWrappedKey
        self.outgoingDukptAttributes = outgoingDukptAttributes
        self.outgoingKeyIdentifier = outgoingKeyIdentifier
        self.outgoingTranslationAttributes = outgoingTranslationAttributes
        self.outgoingWrappedKey = outgoingWrappedKey
    }
}

extension TranslatePinDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TranslatePinDataInput(incomingDukptAttributes: \(Swift.String(describing: incomingDukptAttributes)), incomingKeyIdentifier: \(Swift.String(describing: incomingKeyIdentifier)), incomingTranslationAttributes: \(Swift.String(describing: incomingTranslationAttributes)), incomingWrappedKey: \(Swift.String(describing: incomingWrappedKey)), outgoingDukptAttributes: \(Swift.String(describing: outgoingDukptAttributes)), outgoingKeyIdentifier: \(Swift.String(describing: outgoingKeyIdentifier)), outgoingTranslationAttributes: \(Swift.String(describing: outgoingTranslationAttributes)), outgoingWrappedKey: \(Swift.String(describing: outgoingWrappedKey)), encryptedPinBlock: \"CONTENT_REDACTED\")"}
}

public struct TranslatePinDataOutput {
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses to encrypt outgoing PIN block data after translation.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
    /// This member is required.
    public var keyCheckValue: Swift.String?
    /// The outgoing encrypted PIN block data after translation.
    /// This member is required.
    public var pinBlock: Swift.String?

    public init(
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil,
        pinBlock: Swift.String? = nil
    )
    {
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
        self.pinBlock = pinBlock
    }
}

extension TranslatePinDataOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TranslatePinDataOutput(keyArn: \(Swift.String(describing: keyArn)), keyCheckValue: \(Swift.String(describing: keyCheckValue)), pinBlock: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {

    public enum VerificationFailedReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case invalidAuthRequestCryptogram
        case invalidMac
        case invalidPin
        case invalidValidationData
        case sdkUnknown(Swift.String)

        public static var allCases: [VerificationFailedReason] {
            return [
                .invalidAuthRequestCryptogram,
                .invalidMac,
                .invalidPin,
                .invalidValidationData
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .invalidAuthRequestCryptogram: return "INVALID_AUTH_REQUEST_CRYPTOGRAM"
            case .invalidMac: return "INVALID_MAC"
            case .invalidPin: return "INVALID_PIN"
            case .invalidValidationData: return "INVALID_VALIDATION_DATA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// This request failed verification.
public struct VerificationFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        /// This member is required.
        public internal(set) var reason: PaymentCryptographyDataClientTypes.VerificationFailedReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "VerificationFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PaymentCryptographyDataClientTypes.VerificationFailedReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters to derive session key for an Amex payment card.
    public struct SessionKeyAmex {
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?

        public init(
            panSequenceNumber: Swift.String? = nil,
            primaryAccountNumber: Swift.String? = nil
        )
        {
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.SessionKeyAmex: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionKeyAmex(panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters to derive session key for an Emv2000 payment card for ARQC verification.
    public struct SessionKeyEmv2000 {
        /// The transaction counter that is provided by the terminal during transaction processing.
        /// This member is required.
        public var applicationTransactionCounter: Swift.String?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?

        public init(
            applicationTransactionCounter: Swift.String? = nil,
            panSequenceNumber: Swift.String? = nil,
            primaryAccountNumber: Swift.String? = nil
        )
        {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.SessionKeyEmv2000: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionKeyEmv2000(applicationTransactionCounter: \(Swift.String(describing: applicationTransactionCounter)), panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters to derive session key for an Emv common payment card for ARQC verification.
    public struct SessionKeyEmvCommon {
        /// The transaction counter that is provided by the terminal during transaction processing.
        /// This member is required.
        public var applicationTransactionCounter: Swift.String?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?

        public init(
            applicationTransactionCounter: Swift.String? = nil,
            panSequenceNumber: Swift.String? = nil,
            primaryAccountNumber: Swift.String? = nil
        )
        {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.SessionKeyEmvCommon: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionKeyEmvCommon(applicationTransactionCounter: \(Swift.String(describing: applicationTransactionCounter)), panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters to derive session key for Mastercard payment card for ARQC verification.
    public struct SessionKeyMastercard {
        /// The transaction counter that is provided by the terminal during transaction processing.
        /// This member is required.
        public var applicationTransactionCounter: Swift.String?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?
        /// A random number generated by the issuer.
        /// This member is required.
        public var unpredictableNumber: Swift.String?

        public init(
            applicationTransactionCounter: Swift.String? = nil,
            panSequenceNumber: Swift.String? = nil,
            primaryAccountNumber: Swift.String? = nil,
            unpredictableNumber: Swift.String? = nil
        )
        {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
            self.unpredictableNumber = unpredictableNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.SessionKeyMastercard: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionKeyMastercard(applicationTransactionCounter: \(Swift.String(describing: applicationTransactionCounter)), panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), unpredictableNumber: \(Swift.String(describing: unpredictableNumber)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters to derive session key for Visa payment card for ARQC verification.
    public struct SessionKeyVisa {
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?

        public init(
            panSequenceNumber: Swift.String? = nil,
            primaryAccountNumber: Swift.String? = nil
        )
        {
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.SessionKeyVisa: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionKeyVisa(panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters to derive a session key for Authorization Response Cryptogram (ARQC) verification.
    public enum SessionKeyDerivation {
        /// Parameters to derive session key for an Emv common payment card for ARQC verification.
        case emvcommon(PaymentCryptographyDataClientTypes.SessionKeyEmvCommon)
        /// Parameters to derive session key for a Mastercard payment card for ARQC verification.
        case mastercard(PaymentCryptographyDataClientTypes.SessionKeyMastercard)
        /// Parameters to derive session key for an Emv2000 payment card for ARQC verification.
        case emv2000(PaymentCryptographyDataClientTypes.SessionKeyEmv2000)
        /// Parameters to derive session key for an Amex payment card for ARQC verification.
        case amex(PaymentCryptographyDataClientTypes.SessionKeyAmex)
        /// Parameters to derive session key for a Visa payment cardfor ARQC verification.
        case visa(PaymentCryptographyDataClientTypes.SessionKeyVisa)
        case sdkUnknown(Swift.String)
    }

}

public struct VerifyAuthRequestCryptogramInput {
    /// The auth request cryptogram imported into Amazon Web Services Payment Cryptography for ARQC verification using a major encryption key and transaction data.
    /// This member is required.
    public var authRequestCryptogram: Swift.String?
    /// The attributes and values for auth request cryptogram verification. These parameters are required in case using ARPC Method 1 or Method 2 for ARQC verification.
    public var authResponseAttributes: PaymentCryptographyDataClientTypes.CryptogramAuthResponse?
    /// The keyARN of the major encryption key that Amazon Web Services Payment Cryptography uses for ARQC verification.
    /// This member is required.
    public var keyIdentifier: Swift.String?
    /// The method to use when deriving the major encryption key for ARQC verification within Amazon Web Services Payment Cryptography. The same key derivation mode was used for ARQC generation outside of Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var majorKeyDerivationMode: PaymentCryptographyDataClientTypes.MajorKeyDerivationMode?
    /// The attributes and values to use for deriving a session key for ARQC verification within Amazon Web Services Payment Cryptography. The same attributes were used for ARQC generation outside of Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var sessionKeyDerivationAttributes: PaymentCryptographyDataClientTypes.SessionKeyDerivation?
    /// The transaction data that Amazon Web Services Payment Cryptography uses for ARQC verification. The same transaction is used for ARQC generation outside of Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var transactionData: Swift.String?

    public init(
        authRequestCryptogram: Swift.String? = nil,
        authResponseAttributes: PaymentCryptographyDataClientTypes.CryptogramAuthResponse? = nil,
        keyIdentifier: Swift.String? = nil,
        majorKeyDerivationMode: PaymentCryptographyDataClientTypes.MajorKeyDerivationMode? = nil,
        sessionKeyDerivationAttributes: PaymentCryptographyDataClientTypes.SessionKeyDerivation? = nil,
        transactionData: Swift.String? = nil
    )
    {
        self.authRequestCryptogram = authRequestCryptogram
        self.authResponseAttributes = authResponseAttributes
        self.keyIdentifier = keyIdentifier
        self.majorKeyDerivationMode = majorKeyDerivationMode
        self.sessionKeyDerivationAttributes = sessionKeyDerivationAttributes
        self.transactionData = transactionData
    }
}

extension VerifyAuthRequestCryptogramInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VerifyAuthRequestCryptogramInput(authResponseAttributes: \(Swift.String(describing: authResponseAttributes)), keyIdentifier: \(Swift.String(describing: keyIdentifier)), majorKeyDerivationMode: \(Swift.String(describing: majorKeyDerivationMode)), sessionKeyDerivationAttributes: \(Swift.String(describing: sessionKeyDerivationAttributes)), authRequestCryptogram: \"CONTENT_REDACTED\", transactionData: \"CONTENT_REDACTED\")"}
}

public struct VerifyAuthRequestCryptogramOutput {
    /// The result for ARQC verification or ARPC generation within Amazon Web Services Payment Cryptography.
    public var authResponseValue: Swift.String?
    /// The keyARN of the major encryption key that Amazon Web Services Payment Cryptography uses for ARQC verification.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
    /// This member is required.
    public var keyCheckValue: Swift.String?

    public init(
        authResponseValue: Swift.String? = nil,
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil
    )
    {
        self.authResponseValue = authResponseValue
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
    }
}

extension VerifyAuthRequestCryptogramOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VerifyAuthRequestCryptogramOutput(keyArn: \(Swift.String(describing: keyArn)), keyCheckValue: \(Swift.String(describing: keyCheckValue)), authResponseValue: \"CONTENT_REDACTED\")"}
}

public struct VerifyCardValidationDataInput {
    /// The keyARN of the CVK encryption key that Amazon Web Services Payment Cryptography uses to verify card data.
    /// This member is required.
    public var keyIdentifier: Swift.String?
    /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.
    /// This member is required.
    public var primaryAccountNumber: Swift.String?
    /// The CVV or CSC value for use for card data verification within Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var validationData: Swift.String?
    /// The algorithm to use for verification of card data within Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var verificationAttributes: PaymentCryptographyDataClientTypes.CardVerificationAttributes?

    public init(
        keyIdentifier: Swift.String? = nil,
        primaryAccountNumber: Swift.String? = nil,
        validationData: Swift.String? = nil,
        verificationAttributes: PaymentCryptographyDataClientTypes.CardVerificationAttributes? = nil
    )
    {
        self.keyIdentifier = keyIdentifier
        self.primaryAccountNumber = primaryAccountNumber
        self.validationData = validationData
        self.verificationAttributes = verificationAttributes
    }
}

extension VerifyCardValidationDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VerifyCardValidationDataInput(keyIdentifier: \(Swift.String(describing: keyIdentifier)), verificationAttributes: \(Swift.String(describing: verificationAttributes)), primaryAccountNumber: \"CONTENT_REDACTED\", validationData: \"CONTENT_REDACTED\")"}
}

public struct VerifyCardValidationDataOutput {
    /// The keyARN of the CVK encryption key that Amazon Web Services Payment Cryptography uses to verify CVV or CSC.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
    /// This member is required.
    public var keyCheckValue: Swift.String?

    public init(
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil
    )
    {
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
    }
}

public struct VerifyMacInput {
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses to verify MAC data.
    /// This member is required.
    public var keyIdentifier: Swift.String?
    /// The MAC being verified.
    /// This member is required.
    public var mac: Swift.String?
    /// The length of the MAC.
    public var macLength: Swift.Int?
    /// The data on for which MAC is under verification. This value must be hexBinary.
    /// This member is required.
    public var messageData: Swift.String?
    /// The attributes and data values to use for MAC verification within Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var verificationAttributes: PaymentCryptographyDataClientTypes.MacAttributes?

    public init(
        keyIdentifier: Swift.String? = nil,
        mac: Swift.String? = nil,
        macLength: Swift.Int? = nil,
        messageData: Swift.String? = nil,
        verificationAttributes: PaymentCryptographyDataClientTypes.MacAttributes? = nil
    )
    {
        self.keyIdentifier = keyIdentifier
        self.mac = mac
        self.macLength = macLength
        self.messageData = messageData
        self.verificationAttributes = verificationAttributes
    }
}

extension VerifyMacInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VerifyMacInput(keyIdentifier: \(Swift.String(describing: keyIdentifier)), macLength: \(Swift.String(describing: macLength)), verificationAttributes: \(Swift.String(describing: verificationAttributes)), mac: \"CONTENT_REDACTED\", messageData: \"CONTENT_REDACTED\")"}
}

public struct VerifyMacOutput {
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for MAC verification.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
    /// This member is required.
    public var keyCheckValue: Swift.String?

    public init(
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil
    )
    {
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Visa PIN.
    public struct VisaPinVerification {
        /// The value for PIN verification index. It is used in the Visa PIN algorithm to calculate the PVV (PIN Verification Value).
        /// This member is required.
        public var pinVerificationKeyIndex: Swift.Int?
        /// Parameters that are required to generate or verify Visa PVV (PIN Verification Value).
        /// This member is required.
        public var verificationValue: Swift.String?

        public init(
            pinVerificationKeyIndex: Swift.Int? = nil,
            verificationValue: Swift.String? = nil
        )
        {
            self.pinVerificationKeyIndex = pinVerificationKeyIndex
            self.verificationValue = verificationValue
        }
    }

}

extension PaymentCryptographyDataClientTypes.VisaPinVerification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VisaPinVerification(pinVerificationKeyIndex: \(Swift.String(describing: pinVerificationKeyIndex)), verificationValue: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for PIN data verification.
    public enum PinVerificationAttributes {
        /// Parameters that are required to generate or verify Visa PIN.
        case visapin(PaymentCryptographyDataClientTypes.VisaPinVerification)
        /// Parameters that are required to generate or verify Ibm3624 PIN.
        case ibm3624pin(PaymentCryptographyDataClientTypes.Ibm3624PinVerification)
        case sdkUnknown(Swift.String)
    }

}

public struct VerifyPinDataInput {
    /// The attributes and values for the DUKPT encrypted PIN block data.
    public var dukptAttributes: PaymentCryptographyDataClientTypes.DukptAttributes?
    /// The encrypted PIN block data that Amazon Web Services Payment Cryptography verifies.
    /// This member is required.
    public var encryptedPinBlock: Swift.String?
    /// The keyARN of the encryption key under which the PIN block data is encrypted. This key type can be PEK or BDK.
    /// This member is required.
    public var encryptionKeyIdentifier: Swift.String?
    /// The PIN encoding format for pin data generation as specified in ISO 9564. Amazon Web Services Payment Cryptography supports ISO_Format_0 and ISO_Format_3. The ISO_Format_0 PIN block format is equivalent to the ANSI X9.8, VISA-1, and ECI-1 PIN block formats. It is similar to a VISA-4 PIN block format. It supports a PIN from 4 to 12 digits in length. The ISO_Format_3 PIN block format is the same as ISO_Format_0 except that the fill digits are random values from 10 to 15.
    /// This member is required.
    public var pinBlockFormat: PaymentCryptographyDataClientTypes.PinBlockFormatForPinData?
    /// The length of PIN being verified.
    public var pinDataLength: Swift.Int?
    /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.
    /// This member is required.
    public var primaryAccountNumber: Swift.String?
    /// The attributes and values for PIN data verification.
    /// This member is required.
    public var verificationAttributes: PaymentCryptographyDataClientTypes.PinVerificationAttributes?
    /// The keyARN of the PIN verification key.
    /// This member is required.
    public var verificationKeyIdentifier: Swift.String?

    public init(
        dukptAttributes: PaymentCryptographyDataClientTypes.DukptAttributes? = nil,
        encryptedPinBlock: Swift.String? = nil,
        encryptionKeyIdentifier: Swift.String? = nil,
        pinBlockFormat: PaymentCryptographyDataClientTypes.PinBlockFormatForPinData? = nil,
        pinDataLength: Swift.Int? = nil,
        primaryAccountNumber: Swift.String? = nil,
        verificationAttributes: PaymentCryptographyDataClientTypes.PinVerificationAttributes? = nil,
        verificationKeyIdentifier: Swift.String? = nil
    )
    {
        self.dukptAttributes = dukptAttributes
        self.encryptedPinBlock = encryptedPinBlock
        self.encryptionKeyIdentifier = encryptionKeyIdentifier
        self.pinBlockFormat = pinBlockFormat
        self.pinDataLength = pinDataLength
        self.primaryAccountNumber = primaryAccountNumber
        self.verificationAttributes = verificationAttributes
        self.verificationKeyIdentifier = verificationKeyIdentifier
    }
}

extension VerifyPinDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VerifyPinDataInput(dukptAttributes: \(Swift.String(describing: dukptAttributes)), encryptionKeyIdentifier: \(Swift.String(describing: encryptionKeyIdentifier)), pinBlockFormat: \(Swift.String(describing: pinBlockFormat)), pinDataLength: \(Swift.String(describing: pinDataLength)), verificationAttributes: \(Swift.String(describing: verificationAttributes)), verificationKeyIdentifier: \(Swift.String(describing: verificationKeyIdentifier)), encryptedPinBlock: \"CONTENT_REDACTED\", primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

public struct VerifyPinDataOutput {
    /// The keyARN of the PEK that Amazon Web Services Payment Cryptography uses for encrypted pin block generation.
    /// This member is required.
    public var encryptionKeyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
    /// This member is required.
    public var encryptionKeyCheckValue: Swift.String?
    /// The keyARN of the PIN encryption key that Amazon Web Services Payment Cryptography uses for PIN or PIN Offset verification.
    /// This member is required.
    public var verificationKeyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
    /// This member is required.
    public var verificationKeyCheckValue: Swift.String?

    public init(
        encryptionKeyArn: Swift.String? = nil,
        encryptionKeyCheckValue: Swift.String? = nil,
        verificationKeyArn: Swift.String? = nil,
        verificationKeyCheckValue: Swift.String? = nil
    )
    {
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionKeyCheckValue = encryptionKeyCheckValue
        self.verificationKeyArn = verificationKeyArn
        self.verificationKeyCheckValue = verificationKeyCheckValue
    }
}

extension DecryptDataInput {

    static func urlPathProvider(_ value: DecryptDataInput) -> Swift.String? {
        guard let keyIdentifier = value.keyIdentifier else {
            return nil
        }
        return "/keys/\(keyIdentifier.urlPercentEncoding())/decrypt"
    }
}

extension EncryptDataInput {

    static func urlPathProvider(_ value: EncryptDataInput) -> Swift.String? {
        guard let keyIdentifier = value.keyIdentifier else {
            return nil
        }
        return "/keys/\(keyIdentifier.urlPercentEncoding())/encrypt"
    }
}

extension GenerateCardValidationDataInput {

    static func urlPathProvider(_ value: GenerateCardValidationDataInput) -> Swift.String? {
        return "/cardvalidationdata/generate"
    }
}

extension GenerateMacInput {

    static func urlPathProvider(_ value: GenerateMacInput) -> Swift.String? {
        return "/mac/generate"
    }
}

extension GeneratePinDataInput {

    static func urlPathProvider(_ value: GeneratePinDataInput) -> Swift.String? {
        return "/pindata/generate"
    }
}

extension ReEncryptDataInput {

    static func urlPathProvider(_ value: ReEncryptDataInput) -> Swift.String? {
        guard let incomingKeyIdentifier = value.incomingKeyIdentifier else {
            return nil
        }
        return "/keys/\(incomingKeyIdentifier.urlPercentEncoding())/reencrypt"
    }
}

extension TranslatePinDataInput {

    static func urlPathProvider(_ value: TranslatePinDataInput) -> Swift.String? {
        return "/pindata/translate"
    }
}

extension VerifyAuthRequestCryptogramInput {

    static func urlPathProvider(_ value: VerifyAuthRequestCryptogramInput) -> Swift.String? {
        return "/cryptogram/verify"
    }
}

extension VerifyCardValidationDataInput {

    static func urlPathProvider(_ value: VerifyCardValidationDataInput) -> Swift.String? {
        return "/cardvalidationdata/verify"
    }
}

extension VerifyMacInput {

    static func urlPathProvider(_ value: VerifyMacInput) -> Swift.String? {
        return "/mac/verify"
    }
}

extension VerifyPinDataInput {

    static func urlPathProvider(_ value: VerifyPinDataInput) -> Swift.String? {
        return "/pindata/verify"
    }
}

extension DecryptDataInput {

    static func write(value: DecryptDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CipherText"].write(value.cipherText)
        try writer["DecryptionAttributes"].write(value.decryptionAttributes, with: PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes.write(value:to:))
        try writer["WrappedKey"].write(value.wrappedKey, with: PaymentCryptographyDataClientTypes.WrappedKey.write(value:to:))
    }
}

extension EncryptDataInput {

    static func write(value: EncryptDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncryptionAttributes"].write(value.encryptionAttributes, with: PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes.write(value:to:))
        try writer["PlainText"].write(value.plainText)
        try writer["WrappedKey"].write(value.wrappedKey, with: PaymentCryptographyDataClientTypes.WrappedKey.write(value:to:))
    }
}

extension GenerateCardValidationDataInput {

    static func write(value: GenerateCardValidationDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GenerationAttributes"].write(value.generationAttributes, with: PaymentCryptographyDataClientTypes.CardGenerationAttributes.write(value:to:))
        try writer["KeyIdentifier"].write(value.keyIdentifier)
        try writer["PrimaryAccountNumber"].write(value.primaryAccountNumber)
        try writer["ValidationDataLength"].write(value.validationDataLength)
    }
}

extension GenerateMacInput {

    static func write(value: GenerateMacInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GenerationAttributes"].write(value.generationAttributes, with: PaymentCryptographyDataClientTypes.MacAttributes.write(value:to:))
        try writer["KeyIdentifier"].write(value.keyIdentifier)
        try writer["MacLength"].write(value.macLength)
        try writer["MessageData"].write(value.messageData)
    }
}

extension GeneratePinDataInput {

    static func write(value: GeneratePinDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncryptionKeyIdentifier"].write(value.encryptionKeyIdentifier)
        try writer["GenerationAttributes"].write(value.generationAttributes, with: PaymentCryptographyDataClientTypes.PinGenerationAttributes.write(value:to:))
        try writer["GenerationKeyIdentifier"].write(value.generationKeyIdentifier)
        try writer["PinBlockFormat"].write(value.pinBlockFormat)
        try writer["PinDataLength"].write(value.pinDataLength)
        try writer["PrimaryAccountNumber"].write(value.primaryAccountNumber)
    }
}

extension ReEncryptDataInput {

    static func write(value: ReEncryptDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CipherText"].write(value.cipherText)
        try writer["IncomingEncryptionAttributes"].write(value.incomingEncryptionAttributes, with: PaymentCryptographyDataClientTypes.ReEncryptionAttributes.write(value:to:))
        try writer["IncomingWrappedKey"].write(value.incomingWrappedKey, with: PaymentCryptographyDataClientTypes.WrappedKey.write(value:to:))
        try writer["OutgoingEncryptionAttributes"].write(value.outgoingEncryptionAttributes, with: PaymentCryptographyDataClientTypes.ReEncryptionAttributes.write(value:to:))
        try writer["OutgoingKeyIdentifier"].write(value.outgoingKeyIdentifier)
        try writer["OutgoingWrappedKey"].write(value.outgoingWrappedKey, with: PaymentCryptographyDataClientTypes.WrappedKey.write(value:to:))
    }
}

extension TranslatePinDataInput {

    static func write(value: TranslatePinDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncryptedPinBlock"].write(value.encryptedPinBlock)
        try writer["IncomingDukptAttributes"].write(value.incomingDukptAttributes, with: PaymentCryptographyDataClientTypes.DukptDerivationAttributes.write(value:to:))
        try writer["IncomingKeyIdentifier"].write(value.incomingKeyIdentifier)
        try writer["IncomingTranslationAttributes"].write(value.incomingTranslationAttributes, with: PaymentCryptographyDataClientTypes.TranslationIsoFormats.write(value:to:))
        try writer["IncomingWrappedKey"].write(value.incomingWrappedKey, with: PaymentCryptographyDataClientTypes.WrappedKey.write(value:to:))
        try writer["OutgoingDukptAttributes"].write(value.outgoingDukptAttributes, with: PaymentCryptographyDataClientTypes.DukptDerivationAttributes.write(value:to:))
        try writer["OutgoingKeyIdentifier"].write(value.outgoingKeyIdentifier)
        try writer["OutgoingTranslationAttributes"].write(value.outgoingTranslationAttributes, with: PaymentCryptographyDataClientTypes.TranslationIsoFormats.write(value:to:))
        try writer["OutgoingWrappedKey"].write(value.outgoingWrappedKey, with: PaymentCryptographyDataClientTypes.WrappedKey.write(value:to:))
    }
}

extension VerifyAuthRequestCryptogramInput {

    static func write(value: VerifyAuthRequestCryptogramInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthRequestCryptogram"].write(value.authRequestCryptogram)
        try writer["AuthResponseAttributes"].write(value.authResponseAttributes, with: PaymentCryptographyDataClientTypes.CryptogramAuthResponse.write(value:to:))
        try writer["KeyIdentifier"].write(value.keyIdentifier)
        try writer["MajorKeyDerivationMode"].write(value.majorKeyDerivationMode)
        try writer["SessionKeyDerivationAttributes"].write(value.sessionKeyDerivationAttributes, with: PaymentCryptographyDataClientTypes.SessionKeyDerivation.write(value:to:))
        try writer["TransactionData"].write(value.transactionData)
    }
}

extension VerifyCardValidationDataInput {

    static func write(value: VerifyCardValidationDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyIdentifier"].write(value.keyIdentifier)
        try writer["PrimaryAccountNumber"].write(value.primaryAccountNumber)
        try writer["ValidationData"].write(value.validationData)
        try writer["VerificationAttributes"].write(value.verificationAttributes, with: PaymentCryptographyDataClientTypes.CardVerificationAttributes.write(value:to:))
    }
}

extension VerifyMacInput {

    static func write(value: VerifyMacInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyIdentifier"].write(value.keyIdentifier)
        try writer["Mac"].write(value.mac)
        try writer["MacLength"].write(value.macLength)
        try writer["MessageData"].write(value.messageData)
        try writer["VerificationAttributes"].write(value.verificationAttributes, with: PaymentCryptographyDataClientTypes.MacAttributes.write(value:to:))
    }
}

extension VerifyPinDataInput {

    static func write(value: VerifyPinDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DukptAttributes"].write(value.dukptAttributes, with: PaymentCryptographyDataClientTypes.DukptAttributes.write(value:to:))
        try writer["EncryptedPinBlock"].write(value.encryptedPinBlock)
        try writer["EncryptionKeyIdentifier"].write(value.encryptionKeyIdentifier)
        try writer["PinBlockFormat"].write(value.pinBlockFormat)
        try writer["PinDataLength"].write(value.pinDataLength)
        try writer["PrimaryAccountNumber"].write(value.primaryAccountNumber)
        try writer["VerificationAttributes"].write(value.verificationAttributes, with: PaymentCryptographyDataClientTypes.PinVerificationAttributes.write(value:to:))
        try writer["VerificationKeyIdentifier"].write(value.verificationKeyIdentifier)
    }
}

extension DecryptDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DecryptDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DecryptDataOutput()
        value.keyArn = try reader["KeyArn"].readIfPresent() ?? ""
        value.keyCheckValue = try reader["KeyCheckValue"].readIfPresent() ?? ""
        value.plainText = try reader["PlainText"].readIfPresent() ?? ""
        return value
    }
}

extension EncryptDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EncryptDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EncryptDataOutput()
        value.cipherText = try reader["CipherText"].readIfPresent() ?? ""
        value.keyArn = try reader["KeyArn"].readIfPresent() ?? ""
        value.keyCheckValue = try reader["KeyCheckValue"].readIfPresent()
        return value
    }
}

extension GenerateCardValidationDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GenerateCardValidationDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GenerateCardValidationDataOutput()
        value.keyArn = try reader["KeyArn"].readIfPresent() ?? ""
        value.keyCheckValue = try reader["KeyCheckValue"].readIfPresent() ?? ""
        value.validationData = try reader["ValidationData"].readIfPresent() ?? ""
        return value
    }
}

extension GenerateMacOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GenerateMacOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GenerateMacOutput()
        value.keyArn = try reader["KeyArn"].readIfPresent() ?? ""
        value.keyCheckValue = try reader["KeyCheckValue"].readIfPresent() ?? ""
        value.mac = try reader["Mac"].readIfPresent() ?? ""
        return value
    }
}

extension GeneratePinDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GeneratePinDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GeneratePinDataOutput()
        value.encryptedPinBlock = try reader["EncryptedPinBlock"].readIfPresent() ?? ""
        value.encryptionKeyArn = try reader["EncryptionKeyArn"].readIfPresent() ?? ""
        value.encryptionKeyCheckValue = try reader["EncryptionKeyCheckValue"].readIfPresent() ?? ""
        value.generationKeyArn = try reader["GenerationKeyArn"].readIfPresent() ?? ""
        value.generationKeyCheckValue = try reader["GenerationKeyCheckValue"].readIfPresent() ?? ""
        value.pinData = try reader["PinData"].readIfPresent(with: PaymentCryptographyDataClientTypes.PinData.read(from:))
        return value
    }
}

extension ReEncryptDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ReEncryptDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ReEncryptDataOutput()
        value.cipherText = try reader["CipherText"].readIfPresent() ?? ""
        value.keyArn = try reader["KeyArn"].readIfPresent() ?? ""
        value.keyCheckValue = try reader["KeyCheckValue"].readIfPresent() ?? ""
        return value
    }
}

extension TranslatePinDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TranslatePinDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TranslatePinDataOutput()
        value.keyArn = try reader["KeyArn"].readIfPresent() ?? ""
        value.keyCheckValue = try reader["KeyCheckValue"].readIfPresent() ?? ""
        value.pinBlock = try reader["PinBlock"].readIfPresent() ?? ""
        return value
    }
}

extension VerifyAuthRequestCryptogramOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> VerifyAuthRequestCryptogramOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = VerifyAuthRequestCryptogramOutput()
        value.authResponseValue = try reader["AuthResponseValue"].readIfPresent()
        value.keyArn = try reader["KeyArn"].readIfPresent() ?? ""
        value.keyCheckValue = try reader["KeyCheckValue"].readIfPresent() ?? ""
        return value
    }
}

extension VerifyCardValidationDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> VerifyCardValidationDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = VerifyCardValidationDataOutput()
        value.keyArn = try reader["KeyArn"].readIfPresent() ?? ""
        value.keyCheckValue = try reader["KeyCheckValue"].readIfPresent() ?? ""
        return value
    }
}

extension VerifyMacOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> VerifyMacOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = VerifyMacOutput()
        value.keyArn = try reader["KeyArn"].readIfPresent() ?? ""
        value.keyCheckValue = try reader["KeyCheckValue"].readIfPresent() ?? ""
        return value
    }
}

extension VerifyPinDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> VerifyPinDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = VerifyPinDataOutput()
        value.encryptionKeyArn = try reader["EncryptionKeyArn"].readIfPresent() ?? ""
        value.encryptionKeyCheckValue = try reader["EncryptionKeyCheckValue"].readIfPresent() ?? ""
        value.verificationKeyArn = try reader["VerificationKeyArn"].readIfPresent() ?? ""
        value.verificationKeyCheckValue = try reader["VerificationKeyCheckValue"].readIfPresent() ?? ""
        return value
    }
}

enum DecryptDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EncryptDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GenerateCardValidationDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GenerateMacOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GeneratePinDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ReEncryptDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TranslatePinDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum VerifyAuthRequestCryptogramOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            case "VerificationFailedException": return try VerificationFailedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum VerifyCardValidationDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            case "VerificationFailedException": return try VerificationFailedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum VerifyMacOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            case "VerificationFailedException": return try VerificationFailedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum VerifyPinDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            case "VerificationFailedException": return try VerificationFailedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: PaymentCryptographyDataClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension VerificationFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> VerificationFailedException {
        let reader = baseError.errorBodyReader
        var value = VerificationFailedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PaymentCryptographyDataClientTypes.PinData {

    static func read(from reader: SmithyJSON.Reader) throws -> PaymentCryptographyDataClientTypes.PinData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "PinOffset":
                return .pinoffset(try reader["PinOffset"].read())
            case "VerificationValue":
                return .verificationvalue(try reader["VerificationValue"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension PaymentCryptographyDataClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> PaymentCryptographyDataClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PaymentCryptographyDataClientTypes.ValidationExceptionField()
        value.path = try reader["path"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes {

    static func write(value: PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .asymmetric(asymmetric):
                try writer["Asymmetric"].write(asymmetric, with: PaymentCryptographyDataClientTypes.AsymmetricEncryptionAttributes.write(value:to:))
            case let .dukpt(dukpt):
                try writer["Dukpt"].write(dukpt, with: PaymentCryptographyDataClientTypes.DukptEncryptionAttributes.write(value:to:))
            case let .emv(emv):
                try writer["Emv"].write(emv, with: PaymentCryptographyDataClientTypes.EmvEncryptionAttributes.write(value:to:))
            case let .symmetric(symmetric):
                try writer["Symmetric"].write(symmetric, with: PaymentCryptographyDataClientTypes.SymmetricEncryptionAttributes.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PaymentCryptographyDataClientTypes.EmvEncryptionAttributes {

    static func write(value: PaymentCryptographyDataClientTypes.EmvEncryptionAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitializationVector"].write(value.initializationVector)
        try writer["MajorKeyDerivationMode"].write(value.majorKeyDerivationMode)
        try writer["Mode"].write(value.mode)
        try writer["PanSequenceNumber"].write(value.panSequenceNumber)
        try writer["PrimaryAccountNumber"].write(value.primaryAccountNumber)
        try writer["SessionDerivationData"].write(value.sessionDerivationData)
    }
}

extension PaymentCryptographyDataClientTypes.DukptEncryptionAttributes {

    static func write(value: PaymentCryptographyDataClientTypes.DukptEncryptionAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DukptKeyDerivationType"].write(value.dukptKeyDerivationType)
        try writer["DukptKeyVariant"].write(value.dukptKeyVariant)
        try writer["InitializationVector"].write(value.initializationVector)
        try writer["KeySerialNumber"].write(value.keySerialNumber)
        try writer["Mode"].write(value.mode)
    }
}

extension PaymentCryptographyDataClientTypes.AsymmetricEncryptionAttributes {

    static func write(value: PaymentCryptographyDataClientTypes.AsymmetricEncryptionAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PaddingType"].write(value.paddingType)
    }
}

extension PaymentCryptographyDataClientTypes.SymmetricEncryptionAttributes {

    static func write(value: PaymentCryptographyDataClientTypes.SymmetricEncryptionAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitializationVector"].write(value.initializationVector)
        try writer["Mode"].write(value.mode)
        try writer["PaddingType"].write(value.paddingType)
    }
}

extension PaymentCryptographyDataClientTypes.WrappedKey {

    static func write(value: PaymentCryptographyDataClientTypes.WrappedKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyCheckValueAlgorithm"].write(value.keyCheckValueAlgorithm)
        try writer["WrappedKeyMaterial"].write(value.wrappedKeyMaterial, with: PaymentCryptographyDataClientTypes.WrappedKeyMaterial.write(value:to:))
    }
}

extension PaymentCryptographyDataClientTypes.WrappedKeyMaterial {

    static func write(value: PaymentCryptographyDataClientTypes.WrappedKeyMaterial?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .tr31keyblock(tr31keyblock):
                try writer["Tr31KeyBlock"].write(tr31keyblock)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PaymentCryptographyDataClientTypes.CardGenerationAttributes {

    static func write(value: PaymentCryptographyDataClientTypes.CardGenerationAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .amexcardsecuritycodeversion1(amexcardsecuritycodeversion1):
                try writer["AmexCardSecurityCodeVersion1"].write(amexcardsecuritycodeversion1, with: PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion1.write(value:to:))
            case let .amexcardsecuritycodeversion2(amexcardsecuritycodeversion2):
                try writer["AmexCardSecurityCodeVersion2"].write(amexcardsecuritycodeversion2, with: PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion2.write(value:to:))
            case let .cardholderverificationvalue(cardholderverificationvalue):
                try writer["CardHolderVerificationValue"].write(cardholderverificationvalue, with: PaymentCryptographyDataClientTypes.CardHolderVerificationValue.write(value:to:))
            case let .cardverificationvalue1(cardverificationvalue1):
                try writer["CardVerificationValue1"].write(cardverificationvalue1, with: PaymentCryptographyDataClientTypes.CardVerificationValue1.write(value:to:))
            case let .cardverificationvalue2(cardverificationvalue2):
                try writer["CardVerificationValue2"].write(cardverificationvalue2, with: PaymentCryptographyDataClientTypes.CardVerificationValue2.write(value:to:))
            case let .dynamiccardverificationcode(dynamiccardverificationcode):
                try writer["DynamicCardVerificationCode"].write(dynamiccardverificationcode, with: PaymentCryptographyDataClientTypes.DynamicCardVerificationCode.write(value:to:))
            case let .dynamiccardverificationvalue(dynamiccardverificationvalue):
                try writer["DynamicCardVerificationValue"].write(dynamiccardverificationvalue, with: PaymentCryptographyDataClientTypes.DynamicCardVerificationValue.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PaymentCryptographyDataClientTypes.DynamicCardVerificationValue {

    static func write(value: PaymentCryptographyDataClientTypes.DynamicCardVerificationValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationTransactionCounter"].write(value.applicationTransactionCounter)
        try writer["CardExpiryDate"].write(value.cardExpiryDate)
        try writer["PanSequenceNumber"].write(value.panSequenceNumber)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension PaymentCryptographyDataClientTypes.DynamicCardVerificationCode {

    static func write(value: PaymentCryptographyDataClientTypes.DynamicCardVerificationCode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationTransactionCounter"].write(value.applicationTransactionCounter)
        try writer["PanSequenceNumber"].write(value.panSequenceNumber)
        try writer["TrackData"].write(value.trackData)
        try writer["UnpredictableNumber"].write(value.unpredictableNumber)
    }
}

extension PaymentCryptographyDataClientTypes.CardHolderVerificationValue {

    static func write(value: PaymentCryptographyDataClientTypes.CardHolderVerificationValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationTransactionCounter"].write(value.applicationTransactionCounter)
        try writer["PanSequenceNumber"].write(value.panSequenceNumber)
        try writer["UnpredictableNumber"].write(value.unpredictableNumber)
    }
}

extension PaymentCryptographyDataClientTypes.CardVerificationValue2 {

    static func write(value: PaymentCryptographyDataClientTypes.CardVerificationValue2?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CardExpiryDate"].write(value.cardExpiryDate)
    }
}

extension PaymentCryptographyDataClientTypes.CardVerificationValue1 {

    static func write(value: PaymentCryptographyDataClientTypes.CardVerificationValue1?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CardExpiryDate"].write(value.cardExpiryDate)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion2 {

    static func write(value: PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion2?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CardExpiryDate"].write(value.cardExpiryDate)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion1 {

    static func write(value: PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion1?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CardExpiryDate"].write(value.cardExpiryDate)
    }
}

extension PaymentCryptographyDataClientTypes.MacAttributes {

    static func write(value: PaymentCryptographyDataClientTypes.MacAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .algorithm(algorithm):
                try writer["Algorithm"].write(algorithm)
            case let .dukptcmac(dukptcmac):
                try writer["DukptCmac"].write(dukptcmac, with: PaymentCryptographyDataClientTypes.MacAlgorithmDukpt.write(value:to:))
            case let .dukptiso9797algorithm1(dukptiso9797algorithm1):
                try writer["DukptIso9797Algorithm1"].write(dukptiso9797algorithm1, with: PaymentCryptographyDataClientTypes.MacAlgorithmDukpt.write(value:to:))
            case let .dukptiso9797algorithm3(dukptiso9797algorithm3):
                try writer["DukptIso9797Algorithm3"].write(dukptiso9797algorithm3, with: PaymentCryptographyDataClientTypes.MacAlgorithmDukpt.write(value:to:))
            case let .emvmac(emvmac):
                try writer["EmvMac"].write(emvmac, with: PaymentCryptographyDataClientTypes.MacAlgorithmEmv.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PaymentCryptographyDataClientTypes.MacAlgorithmDukpt {

    static func write(value: PaymentCryptographyDataClientTypes.MacAlgorithmDukpt?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DukptDerivationType"].write(value.dukptDerivationType)
        try writer["DukptKeyVariant"].write(value.dukptKeyVariant)
        try writer["KeySerialNumber"].write(value.keySerialNumber)
    }
}

extension PaymentCryptographyDataClientTypes.MacAlgorithmEmv {

    static func write(value: PaymentCryptographyDataClientTypes.MacAlgorithmEmv?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MajorKeyDerivationMode"].write(value.majorKeyDerivationMode)
        try writer["PanSequenceNumber"].write(value.panSequenceNumber)
        try writer["PrimaryAccountNumber"].write(value.primaryAccountNumber)
        try writer["SessionKeyDerivationMode"].write(value.sessionKeyDerivationMode)
        try writer["SessionKeyDerivationValue"].write(value.sessionKeyDerivationValue, with: PaymentCryptographyDataClientTypes.SessionKeyDerivationValue.write(value:to:))
    }
}

extension PaymentCryptographyDataClientTypes.SessionKeyDerivationValue {

    static func write(value: PaymentCryptographyDataClientTypes.SessionKeyDerivationValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .applicationcryptogram(applicationcryptogram):
                try writer["ApplicationCryptogram"].write(applicationcryptogram)
            case let .applicationtransactioncounter(applicationtransactioncounter):
                try writer["ApplicationTransactionCounter"].write(applicationtransactioncounter)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PaymentCryptographyDataClientTypes.PinGenerationAttributes {

    static func write(value: PaymentCryptographyDataClientTypes.PinGenerationAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .ibm3624naturalpin(ibm3624naturalpin):
                try writer["Ibm3624NaturalPin"].write(ibm3624naturalpin, with: PaymentCryptographyDataClientTypes.Ibm3624NaturalPin.write(value:to:))
            case let .ibm3624pinfromoffset(ibm3624pinfromoffset):
                try writer["Ibm3624PinFromOffset"].write(ibm3624pinfromoffset, with: PaymentCryptographyDataClientTypes.Ibm3624PinFromOffset.write(value:to:))
            case let .ibm3624pinoffset(ibm3624pinoffset):
                try writer["Ibm3624PinOffset"].write(ibm3624pinoffset, with: PaymentCryptographyDataClientTypes.Ibm3624PinOffset.write(value:to:))
            case let .ibm3624randompin(ibm3624randompin):
                try writer["Ibm3624RandomPin"].write(ibm3624randompin, with: PaymentCryptographyDataClientTypes.Ibm3624RandomPin.write(value:to:))
            case let .visapin(visapin):
                try writer["VisaPin"].write(visapin, with: PaymentCryptographyDataClientTypes.VisaPin.write(value:to:))
            case let .visapinverificationvalue(visapinverificationvalue):
                try writer["VisaPinVerificationValue"].write(visapinverificationvalue, with: PaymentCryptographyDataClientTypes.VisaPinVerificationValue.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PaymentCryptographyDataClientTypes.Ibm3624PinFromOffset {

    static func write(value: PaymentCryptographyDataClientTypes.Ibm3624PinFromOffset?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DecimalizationTable"].write(value.decimalizationTable)
        try writer["PinOffset"].write(value.pinOffset)
        try writer["PinValidationData"].write(value.pinValidationData)
        try writer["PinValidationDataPadCharacter"].write(value.pinValidationDataPadCharacter)
    }
}

extension PaymentCryptographyDataClientTypes.Ibm3624RandomPin {

    static func write(value: PaymentCryptographyDataClientTypes.Ibm3624RandomPin?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DecimalizationTable"].write(value.decimalizationTable)
        try writer["PinValidationData"].write(value.pinValidationData)
        try writer["PinValidationDataPadCharacter"].write(value.pinValidationDataPadCharacter)
    }
}

extension PaymentCryptographyDataClientTypes.Ibm3624NaturalPin {

    static func write(value: PaymentCryptographyDataClientTypes.Ibm3624NaturalPin?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DecimalizationTable"].write(value.decimalizationTable)
        try writer["PinValidationData"].write(value.pinValidationData)
        try writer["PinValidationDataPadCharacter"].write(value.pinValidationDataPadCharacter)
    }
}

extension PaymentCryptographyDataClientTypes.Ibm3624PinOffset {

    static func write(value: PaymentCryptographyDataClientTypes.Ibm3624PinOffset?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DecimalizationTable"].write(value.decimalizationTable)
        try writer["EncryptedPinBlock"].write(value.encryptedPinBlock)
        try writer["PinValidationData"].write(value.pinValidationData)
        try writer["PinValidationDataPadCharacter"].write(value.pinValidationDataPadCharacter)
    }
}

extension PaymentCryptographyDataClientTypes.VisaPinVerificationValue {

    static func write(value: PaymentCryptographyDataClientTypes.VisaPinVerificationValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncryptedPinBlock"].write(value.encryptedPinBlock)
        try writer["PinVerificationKeyIndex"].write(value.pinVerificationKeyIndex)
    }
}

extension PaymentCryptographyDataClientTypes.VisaPin {

    static func write(value: PaymentCryptographyDataClientTypes.VisaPin?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PinVerificationKeyIndex"].write(value.pinVerificationKeyIndex)
    }
}

extension PaymentCryptographyDataClientTypes.ReEncryptionAttributes {

    static func write(value: PaymentCryptographyDataClientTypes.ReEncryptionAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .dukpt(dukpt):
                try writer["Dukpt"].write(dukpt, with: PaymentCryptographyDataClientTypes.DukptEncryptionAttributes.write(value:to:))
            case let .symmetric(symmetric):
                try writer["Symmetric"].write(symmetric, with: PaymentCryptographyDataClientTypes.SymmetricEncryptionAttributes.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PaymentCryptographyDataClientTypes.TranslationIsoFormats {

    static func write(value: PaymentCryptographyDataClientTypes.TranslationIsoFormats?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .isoformat0(isoformat0):
                try writer["IsoFormat0"].write(isoformat0, with: PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034.write(value:to:))
            case let .isoformat1(isoformat1):
                try writer["IsoFormat1"].write(isoformat1, with: PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat1.write(value:to:))
            case let .isoformat3(isoformat3):
                try writer["IsoFormat3"].write(isoformat3, with: PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034.write(value:to:))
            case let .isoformat4(isoformat4):
                try writer["IsoFormat4"].write(isoformat4, with: PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034 {

    static func write(value: PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PrimaryAccountNumber"].write(value.primaryAccountNumber)
    }
}

extension PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat1 {

    static func write(value: PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat1?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension PaymentCryptographyDataClientTypes.DukptDerivationAttributes {

    static func write(value: PaymentCryptographyDataClientTypes.DukptDerivationAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DukptKeyDerivationType"].write(value.dukptKeyDerivationType)
        try writer["DukptKeyVariant"].write(value.dukptKeyVariant)
        try writer["KeySerialNumber"].write(value.keySerialNumber)
    }
}

extension PaymentCryptographyDataClientTypes.SessionKeyDerivation {

    static func write(value: PaymentCryptographyDataClientTypes.SessionKeyDerivation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .amex(amex):
                try writer["Amex"].write(amex, with: PaymentCryptographyDataClientTypes.SessionKeyAmex.write(value:to:))
            case let .emv2000(emv2000):
                try writer["Emv2000"].write(emv2000, with: PaymentCryptographyDataClientTypes.SessionKeyEmv2000.write(value:to:))
            case let .emvcommon(emvcommon):
                try writer["EmvCommon"].write(emvcommon, with: PaymentCryptographyDataClientTypes.SessionKeyEmvCommon.write(value:to:))
            case let .mastercard(mastercard):
                try writer["Mastercard"].write(mastercard, with: PaymentCryptographyDataClientTypes.SessionKeyMastercard.write(value:to:))
            case let .visa(visa):
                try writer["Visa"].write(visa, with: PaymentCryptographyDataClientTypes.SessionKeyVisa.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PaymentCryptographyDataClientTypes.SessionKeyVisa {

    static func write(value: PaymentCryptographyDataClientTypes.SessionKeyVisa?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PanSequenceNumber"].write(value.panSequenceNumber)
        try writer["PrimaryAccountNumber"].write(value.primaryAccountNumber)
    }
}

extension PaymentCryptographyDataClientTypes.SessionKeyAmex {

    static func write(value: PaymentCryptographyDataClientTypes.SessionKeyAmex?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PanSequenceNumber"].write(value.panSequenceNumber)
        try writer["PrimaryAccountNumber"].write(value.primaryAccountNumber)
    }
}

extension PaymentCryptographyDataClientTypes.SessionKeyEmv2000 {

    static func write(value: PaymentCryptographyDataClientTypes.SessionKeyEmv2000?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationTransactionCounter"].write(value.applicationTransactionCounter)
        try writer["PanSequenceNumber"].write(value.panSequenceNumber)
        try writer["PrimaryAccountNumber"].write(value.primaryAccountNumber)
    }
}

extension PaymentCryptographyDataClientTypes.SessionKeyMastercard {

    static func write(value: PaymentCryptographyDataClientTypes.SessionKeyMastercard?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationTransactionCounter"].write(value.applicationTransactionCounter)
        try writer["PanSequenceNumber"].write(value.panSequenceNumber)
        try writer["PrimaryAccountNumber"].write(value.primaryAccountNumber)
        try writer["UnpredictableNumber"].write(value.unpredictableNumber)
    }
}

extension PaymentCryptographyDataClientTypes.SessionKeyEmvCommon {

    static func write(value: PaymentCryptographyDataClientTypes.SessionKeyEmvCommon?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationTransactionCounter"].write(value.applicationTransactionCounter)
        try writer["PanSequenceNumber"].write(value.panSequenceNumber)
        try writer["PrimaryAccountNumber"].write(value.primaryAccountNumber)
    }
}

extension PaymentCryptographyDataClientTypes.CryptogramAuthResponse {

    static func write(value: PaymentCryptographyDataClientTypes.CryptogramAuthResponse?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .arpcmethod1(arpcmethod1):
                try writer["ArpcMethod1"].write(arpcmethod1, with: PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod1.write(value:to:))
            case let .arpcmethod2(arpcmethod2):
                try writer["ArpcMethod2"].write(arpcmethod2, with: PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod2.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod2 {

    static func write(value: PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod2?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CardStatusUpdate"].write(value.cardStatusUpdate)
        try writer["ProprietaryAuthenticationData"].write(value.proprietaryAuthenticationData)
    }
}

extension PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod1 {

    static func write(value: PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod1?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthResponseCode"].write(value.authResponseCode)
    }
}

extension PaymentCryptographyDataClientTypes.CardVerificationAttributes {

    static func write(value: PaymentCryptographyDataClientTypes.CardVerificationAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .amexcardsecuritycodeversion1(amexcardsecuritycodeversion1):
                try writer["AmexCardSecurityCodeVersion1"].write(amexcardsecuritycodeversion1, with: PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion1.write(value:to:))
            case let .amexcardsecuritycodeversion2(amexcardsecuritycodeversion2):
                try writer["AmexCardSecurityCodeVersion2"].write(amexcardsecuritycodeversion2, with: PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion2.write(value:to:))
            case let .cardholderverificationvalue(cardholderverificationvalue):
                try writer["CardHolderVerificationValue"].write(cardholderverificationvalue, with: PaymentCryptographyDataClientTypes.CardHolderVerificationValue.write(value:to:))
            case let .cardverificationvalue1(cardverificationvalue1):
                try writer["CardVerificationValue1"].write(cardverificationvalue1, with: PaymentCryptographyDataClientTypes.CardVerificationValue1.write(value:to:))
            case let .cardverificationvalue2(cardverificationvalue2):
                try writer["CardVerificationValue2"].write(cardverificationvalue2, with: PaymentCryptographyDataClientTypes.CardVerificationValue2.write(value:to:))
            case let .discoverdynamiccardverificationcode(discoverdynamiccardverificationcode):
                try writer["DiscoverDynamicCardVerificationCode"].write(discoverdynamiccardverificationcode, with: PaymentCryptographyDataClientTypes.DiscoverDynamicCardVerificationCode.write(value:to:))
            case let .dynamiccardverificationcode(dynamiccardverificationcode):
                try writer["DynamicCardVerificationCode"].write(dynamiccardverificationcode, with: PaymentCryptographyDataClientTypes.DynamicCardVerificationCode.write(value:to:))
            case let .dynamiccardverificationvalue(dynamiccardverificationvalue):
                try writer["DynamicCardVerificationValue"].write(dynamiccardverificationvalue, with: PaymentCryptographyDataClientTypes.DynamicCardVerificationValue.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PaymentCryptographyDataClientTypes.DiscoverDynamicCardVerificationCode {

    static func write(value: PaymentCryptographyDataClientTypes.DiscoverDynamicCardVerificationCode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationTransactionCounter"].write(value.applicationTransactionCounter)
        try writer["CardExpiryDate"].write(value.cardExpiryDate)
        try writer["UnpredictableNumber"].write(value.unpredictableNumber)
    }
}

extension PaymentCryptographyDataClientTypes.PinVerificationAttributes {

    static func write(value: PaymentCryptographyDataClientTypes.PinVerificationAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .ibm3624pin(ibm3624pin):
                try writer["Ibm3624Pin"].write(ibm3624pin, with: PaymentCryptographyDataClientTypes.Ibm3624PinVerification.write(value:to:))
            case let .visapin(visapin):
                try writer["VisaPin"].write(visapin, with: PaymentCryptographyDataClientTypes.VisaPinVerification.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PaymentCryptographyDataClientTypes.Ibm3624PinVerification {

    static func write(value: PaymentCryptographyDataClientTypes.Ibm3624PinVerification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DecimalizationTable"].write(value.decimalizationTable)
        try writer["PinOffset"].write(value.pinOffset)
        try writer["PinValidationData"].write(value.pinValidationData)
        try writer["PinValidationDataPadCharacter"].write(value.pinValidationDataPadCharacter)
    }
}

extension PaymentCryptographyDataClientTypes.VisaPinVerification {

    static func write(value: PaymentCryptographyDataClientTypes.VisaPinVerification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PinVerificationKeyIndex"].write(value.pinVerificationKeyIndex)
        try writer["VerificationValue"].write(value.verificationValue)
    }
}

extension PaymentCryptographyDataClientTypes.DukptAttributes {

    static func write(value: PaymentCryptographyDataClientTypes.DukptAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DukptDerivationType"].write(value.dukptDerivationType)
        try writer["KeySerialNumber"].write(value.keySerialNumber)
    }
}

public enum PaymentCryptographyDataClientTypes {}
