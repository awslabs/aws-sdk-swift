//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Smithy
import class AWSSDKIdentity.DefaultAWSCredentialIdentityResolverChain
import class ClientRuntime.HttpClientConfiguration
import class ClientRuntime.SdkHttpClient
import class Smithy.Context
import class SmithyHTTPAPI.HTTPRequest
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum AWSClientRuntime.AWSClockSkewProvider
import enum AWSClientRuntime.AWSRetryErrorInfoProvider
import enum AWSClientRuntime.AWSRetryMode
import enum AWSSDKChecksums.AWSChecksumCalculationMode
import enum ClientRuntime.ClientLogMode
import enum ClientRuntime.DefaultTelemetry
import enum ClientRuntime.OrchestratorMetricsAttributesKeys
import protocol AWSClientRuntime.AWSDefaultClientConfiguration
import protocol AWSClientRuntime.AWSRegionClientConfiguration
import protocol AWSClientRuntime.AWSServiceClient
import protocol ClientRuntime.DefaultClientConfiguration
import protocol ClientRuntime.DefaultHttpClientConfiguration
import protocol ClientRuntime.IdempotencyTokenGenerator
import protocol ClientRuntime.TelemetryProvider
import protocol Smithy.LogAgent
import protocol SmithyHTTPAPI.HTTPClient
import protocol SmithyHTTPAuthAPI.AuthSchemeResolver
@_spi(AWSCredentialIdentityResolver) import protocol SmithyIdentity.AWSCredentialIdentityResolver
import protocol SmithyIdentity.BearerTokenIdentityResolver
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(AWSEndpointResolverMiddleware) import struct AWSClientRuntime.AWSEndpointResolverMiddleware
import struct AWSClientRuntime.AmzSdkInvocationIdMiddleware
import struct AWSClientRuntime.UserAgentMiddleware
import struct AWSSDKHTTPAuth.SigV4AuthScheme
import struct ClientRuntime.AuthSchemeMiddleware
@_spi(SmithyReadWrite) import struct ClientRuntime.BodyMiddleware
import struct ClientRuntime.ContentLengthMiddleware
import struct ClientRuntime.ContentTypeMiddleware
@_spi(SmithyReadWrite) import struct ClientRuntime.DeserializeMiddleware
import struct ClientRuntime.LoggerMiddleware
import struct ClientRuntime.SignerMiddleware
import struct ClientRuntime.URLHostMiddleware
import struct ClientRuntime.URLPathMiddleware
import struct Smithy.Attributes
import struct SmithyIdentity.BearerTokenIdentity
@_spi(StaticBearerTokenIdentityResolver) import struct SmithyIdentity.StaticBearerTokenIdentityResolver
import struct SmithyRetries.DefaultRetryStrategy
import struct SmithyRetriesAPI.RetryStrategyOptions
import typealias SmithyHTTPAuthAPI.AuthSchemes

public class PaymentCryptographyDataClient: AWSClientRuntime.AWSServiceClient {
    public static let clientName = "PaymentCryptographyDataClient"
    let client: ClientRuntime.SdkHttpClient
    let config: PaymentCryptographyDataClient.PaymentCryptographyDataClientConfiguration
    let serviceName = "Payment Cryptography Data"

    public required init(config: PaymentCryptographyDataClient.PaymentCryptographyDataClientConfiguration) {
        client = ClientRuntime.SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        self.config = config
    }

    public convenience init(region: Swift.String) throws {
        let config = try PaymentCryptographyDataClient.PaymentCryptographyDataClientConfiguration(region: region)
        self.init(config: config)
    }

    public convenience required init() async throws {
        let config = try await PaymentCryptographyDataClient.PaymentCryptographyDataClientConfiguration()
        self.init(config: config)
    }
}

extension PaymentCryptographyDataClient {

    public struct PaymentCryptographyDataClientConfiguration: AWSClientRuntime.AWSDefaultClientConfiguration & AWSClientRuntime.AWSRegionClientConfiguration & ClientRuntime.DefaultClientConfiguration & ClientRuntime.DefaultHttpClientConfiguration, Sendable {
        public let useFIPS: Swift.Bool?
        public let useDualStack: Swift.Bool?
        public let appID: Swift.String?
        public let awsCredentialIdentityResolver: any SmithyIdentity.AWSCredentialIdentityResolver
        public let awsRetryMode: AWSClientRuntime.AWSRetryMode
        public let maxAttempts: Swift.Int?
        public let requestChecksumCalculation: AWSSDKChecksums.AWSChecksumCalculationMode
        public let responseChecksumValidation: AWSSDKChecksums.AWSChecksumCalculationMode
        public let ignoreConfiguredEndpointURLs: Swift.Bool?
        public let region: Swift.String?
        public let signingRegion: Swift.String?
        public let endpointResolver: EndpointResolver
        public let telemetryProvider: ClientRuntime.TelemetryProvider
        public let retryStrategyOptions: SmithyRetriesAPI.RetryStrategyOptions
        public let clientLogMode: ClientRuntime.ClientLogMode
        public let endpoint: Swift.String?
        public let idempotencyTokenGenerator: ClientRuntime.IdempotencyTokenGenerator
        public let interceptorProviders: [ClientRuntime.InterceptorProvider]
        public let httpClientEngine: SmithyHTTPAPI.HTTPClient
        public let httpClientConfiguration: ClientRuntime.HttpClientConfiguration
        public let authSchemes: SmithyHTTPAuthAPI.AuthSchemes?
        public let authSchemePreference: [String]?
        public let authSchemeResolver: SmithyHTTPAuthAPI.AuthSchemeResolver
        public let httpInterceptorProviders: [ClientRuntime.HttpInterceptorProvider]
        public let bearerTokenIdentityResolver: any SmithyIdentity.BearerTokenIdentityResolver
        public let logger: Smithy.LogAgent

        public init(
            useFIPS: Swift.Bool? = nil,
            useDualStack: Swift.Bool? = nil,
            appID: Swift.String? = nil,
            awsCredentialIdentityResolver: (any SmithyIdentity.AWSCredentialIdentityResolver)? = nil,
            awsRetryMode: AWSClientRuntime.AWSRetryMode? = nil,
            maxAttempts: Swift.Int? = nil,
            requestChecksumCalculation: AWSSDKChecksums.AWSChecksumCalculationMode? = nil,
            responseChecksumValidation: AWSSDKChecksums.AWSChecksumCalculationMode? = nil,
            ignoreConfiguredEndpointURLs: Swift.Bool? = nil,
            region: Swift.String? = nil,
            signingRegion: Swift.String? = nil,
            endpointResolver: EndpointResolver? = nil,
            telemetryProvider: ClientRuntime.TelemetryProvider? = nil,
            retryStrategyOptions: SmithyRetriesAPI.RetryStrategyOptions? = nil,
            clientLogMode: ClientRuntime.ClientLogMode? = nil,
            endpoint: Swift.String? = nil,
            idempotencyTokenGenerator: ClientRuntime.IdempotencyTokenGenerator? = nil,
            interceptorProviders: [ClientRuntime.InterceptorProvider]? = nil,
            httpClientEngine: SmithyHTTPAPI.HTTPClient? = nil,
            httpClientConfiguration: ClientRuntime.HttpClientConfiguration? = nil,
            authSchemes: SmithyHTTPAuthAPI.AuthSchemes? = nil,
            authSchemePreference: [String]? = nil,
            authSchemeResolver: SmithyHTTPAuthAPI.AuthSchemeResolver? = nil,
            httpInterceptorProviders: [ClientRuntime.HttpInterceptorProvider]? = nil,
            bearerTokenIdentityResolver: (any SmithyIdentity.BearerTokenIdentityResolver)? = nil
        ) throws {
            self.useFIPS = useFIPS
            self.useDualStack = useDualStack
            self.appID = try appID ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.appID()
            self.awsCredentialIdentityResolver = awsCredentialIdentityResolver ?? AWSSDKIdentity.DefaultAWSCredentialIdentityResolverChain()
            self.awsRetryMode = try awsRetryMode ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.retryMode()
            self.maxAttempts = maxAttempts
            self.requestChecksumCalculation = try requestChecksumCalculation ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.requestChecksumCalculation(requestChecksumCalculation)
            self.responseChecksumValidation = try responseChecksumValidation ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.responseChecksumValidation(responseChecksumValidation)
            self.ignoreConfiguredEndpointURLs = ignoreConfiguredEndpointURLs
            self.region = region
            self.signingRegion = signingRegion
            self.endpointResolver = try endpointResolver ?? DefaultEndpointResolver()
            self.telemetryProvider = telemetryProvider ?? ClientRuntime.DefaultTelemetry.provider
            self.retryStrategyOptions = try retryStrategyOptions ?? AWSClientConfigDefaultsProvider.retryStrategyOptions(awsRetryMode, maxAttempts)
            self.clientLogMode = clientLogMode ?? AWSClientConfigDefaultsProvider.clientLogMode()
            self.endpoint = endpoint
            self.idempotencyTokenGenerator = idempotencyTokenGenerator ?? AWSClientConfigDefaultsProvider.idempotencyTokenGenerator()
            self.interceptorProviders = interceptorProviders ?? []
            self.httpClientEngine = httpClientEngine ?? AWSClientConfigDefaultsProvider.httpClientEngine(httpClientConfiguration)
            self.httpClientConfiguration = httpClientConfiguration ?? AWSClientConfigDefaultsProvider.httpClientConfiguration()
            self.authSchemes = authSchemes ?? [AWSSDKHTTPAuth.SigV4AuthScheme()]
            self.authSchemePreference = authSchemePreference ?? nil
            self.authSchemeResolver = authSchemeResolver ?? DefaultPaymentCryptographyDataAuthSchemeResolver()
            self.httpInterceptorProviders = httpInterceptorProviders ?? []
            self.bearerTokenIdentityResolver = bearerTokenIdentityResolver ?? SmithyIdentity.StaticBearerTokenIdentityResolver(token: SmithyIdentity.BearerTokenIdentity(token: ""))
            self.logger = (telemetryProvider ?? ClientRuntime.DefaultTelemetry.provider).loggerProvider.getLogger(name: PaymentCryptographyDataClient.clientName)
        }

        public init(
            useFIPS: Swift.Bool? = nil,
            useDualStack: Swift.Bool? = nil,
            appID: Swift.String? = nil,
            awsCredentialIdentityResolver: (any SmithyIdentity.AWSCredentialIdentityResolver)? = nil,
            awsRetryMode: AWSClientRuntime.AWSRetryMode? = nil,
            maxAttempts: Swift.Int? = nil,
            requestChecksumCalculation: AWSSDKChecksums.AWSChecksumCalculationMode? = nil,
            responseChecksumValidation: AWSSDKChecksums.AWSChecksumCalculationMode? = nil,
            ignoreConfiguredEndpointURLs: Swift.Bool? = nil,
            region: Swift.String? = nil,
            signingRegion: Swift.String? = nil,
            endpointResolver: EndpointResolver? = nil,
            telemetryProvider: ClientRuntime.TelemetryProvider? = nil,
            retryStrategyOptions: SmithyRetriesAPI.RetryStrategyOptions? = nil,
            clientLogMode: ClientRuntime.ClientLogMode? = nil,
            endpoint: Swift.String? = nil,
            idempotencyTokenGenerator: ClientRuntime.IdempotencyTokenGenerator? = nil,
            interceptorProviders: [ClientRuntime.InterceptorProvider]? = nil,
            httpClientEngine: SmithyHTTPAPI.HTTPClient? = nil,
            httpClientConfiguration: ClientRuntime.HttpClientConfiguration? = nil,
            authSchemes: SmithyHTTPAuthAPI.AuthSchemes? = nil,
            authSchemePreference: [String]? = nil,
            authSchemeResolver: SmithyHTTPAuthAPI.AuthSchemeResolver? = nil,
            httpInterceptorProviders: [ClientRuntime.HttpInterceptorProvider]? = nil,
            bearerTokenIdentityResolver: (any SmithyIdentity.BearerTokenIdentityResolver)? = nil
        ) async throws {
            self.useFIPS = useFIPS
            self.useDualStack = useDualStack
            self.appID = try appID ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.appID()
            self.awsCredentialIdentityResolver = awsCredentialIdentityResolver ?? AWSSDKIdentity.DefaultAWSCredentialIdentityResolverChain()
            self.awsRetryMode = try awsRetryMode ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.retryMode()
            self.maxAttempts = maxAttempts
            self.requestChecksumCalculation = try requestChecksumCalculation ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.requestChecksumCalculation(requestChecksumCalculation)
            self.responseChecksumValidation = try responseChecksumValidation ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.responseChecksumValidation(responseChecksumValidation)
            self.ignoreConfiguredEndpointURLs = ignoreConfiguredEndpointURLs
            self.region = try await AWSClientRuntime.AWSClientConfigDefaultsProvider.region(region)
            self.signingRegion = try await AWSClientRuntime.AWSClientConfigDefaultsProvider.region(region)
            self.endpointResolver = try endpointResolver ?? DefaultEndpointResolver()
            self.telemetryProvider = telemetryProvider ?? ClientRuntime.DefaultTelemetry.provider
            self.retryStrategyOptions = try retryStrategyOptions ?? AWSClientConfigDefaultsProvider.retryStrategyOptions(awsRetryMode, maxAttempts)
            self.clientLogMode = clientLogMode ?? AWSClientConfigDefaultsProvider.clientLogMode()
            self.endpoint = endpoint
            self.idempotencyTokenGenerator = idempotencyTokenGenerator ?? AWSClientConfigDefaultsProvider.idempotencyTokenGenerator()
            self.interceptorProviders = interceptorProviders ?? []
            self.httpClientEngine = httpClientEngine ?? AWSClientConfigDefaultsProvider.httpClientEngine(httpClientConfiguration)
            self.httpClientConfiguration = httpClientConfiguration ?? AWSClientConfigDefaultsProvider.httpClientConfiguration()
            self.authSchemes = authSchemes ?? [AWSSDKHTTPAuth.SigV4AuthScheme()]
            self.authSchemePreference = authSchemePreference ?? nil
            self.authSchemeResolver = authSchemeResolver ?? DefaultPaymentCryptographyDataAuthSchemeResolver()
            self.httpInterceptorProviders = httpInterceptorProviders ?? []
            self.bearerTokenIdentityResolver = bearerTokenIdentityResolver ?? SmithyIdentity.StaticBearerTokenIdentityResolver(token: SmithyIdentity.BearerTokenIdentity(token: ""))
            self.logger = (telemetryProvider ?? ClientRuntime.DefaultTelemetry.provider).loggerProvider.getLogger(name: PaymentCryptographyDataClient.clientName)
        }

        public init() async throws {
            try await self.init(
                useFIPS: nil,
                useDualStack: nil,
                appID: nil,
                awsCredentialIdentityResolver: nil,
                awsRetryMode: nil,
                maxAttempts: nil,
                requestChecksumCalculation: nil,
                responseChecksumValidation: nil,
                ignoreConfiguredEndpointURLs: nil,
                region: nil,
                signingRegion: nil,
                endpointResolver: nil,
                telemetryProvider: nil,
                retryStrategyOptions: nil,
                clientLogMode: nil,
                endpoint: nil,
                idempotencyTokenGenerator: nil,
                interceptorProviders: nil,
                httpClientEngine: nil,
                httpClientConfiguration: nil,
                authSchemes: nil,
                authSchemePreference: nil,
                authSchemeResolver: nil,
                httpInterceptorProviders: nil,
                bearerTokenIdentityResolver: nil
            )
        }

        public init(region: Swift.String) throws {
            try self.init(
                useFIPS: nil,
                useDualStack: nil,
                appID: try AWSClientRuntime.AWSClientConfigDefaultsProvider.appID(),
                awsCredentialIdentityResolver: AWSSDKIdentity.DefaultAWSCredentialIdentityResolverChain(),
                awsRetryMode: try AWSClientRuntime.AWSClientConfigDefaultsProvider.retryMode(),
                maxAttempts: nil,
                requestChecksumCalculation: try AWSClientConfigDefaultsProvider.requestChecksumCalculation(),
                responseChecksumValidation: try AWSClientConfigDefaultsProvider.responseChecksumValidation(),
                ignoreConfiguredEndpointURLs: nil,
                region: region,
                signingRegion: region,
                endpointResolver: try DefaultEndpointResolver(),
                telemetryProvider: ClientRuntime.DefaultTelemetry.provider,
                retryStrategyOptions: try AWSClientConfigDefaultsProvider.retryStrategyOptions(),
                clientLogMode: AWSClientConfigDefaultsProvider.clientLogMode(),
                endpoint: nil,
                idempotencyTokenGenerator: AWSClientConfigDefaultsProvider.idempotencyTokenGenerator(),
                interceptorProviders: [],
                httpClientEngine: AWSClientConfigDefaultsProvider.httpClientEngine(),
                httpClientConfiguration: AWSClientConfigDefaultsProvider.httpClientConfiguration(),
                authSchemes: [AWSSDKHTTPAuth.SigV4AuthScheme()],
                authSchemePreference: nil,
                authSchemeResolver: DefaultPaymentCryptographyDataAuthSchemeResolver(),
                httpInterceptorProviders: [],
                bearerTokenIdentityResolver: SmithyIdentity.StaticBearerTokenIdentityResolver(token: SmithyIdentity.BearerTokenIdentity(token: ""))
            )
        }

        public var partitionID: String? {
            return "\(PaymentCryptographyDataClient.clientName) - \(region ?? "")"
        }

    }

    public static func builder() -> ClientRuntime.ClientBuilder<PaymentCryptographyDataClient> {
        return ClientRuntime.ClientBuilder<PaymentCryptographyDataClient>(defaultPlugins: [
            ClientRuntime.DefaultClientPlugin(),
            AWSClientRuntime.DefaultAWSClientPlugin(clientName: self.clientName),
            DefaultAWSAuthSchemePlugin()
        ])
    }
}

extension PaymentCryptographyDataClient {
    /// Performs the `DecryptData` operation on the `PaymentCryptographyData` service.
    ///
    /// Decrypts ciphertext data to plaintext using a symmetric (TDES, AES), asymmetric (RSA), or derived (DUKPT or EMV) encryption key scheme. For more information, see [Decrypt data](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/decrypt-data.html) in the Amazon Web Services Payment Cryptography User Guide. You can use an decryption key generated within Amazon Web Services Payment Cryptography, or you can import your own decryption key by calling [ImportKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_ImportKey.html). For this operation, the key must have KeyModesOfUse set to Decrypt. In asymmetric decryption, Amazon Web Services Payment Cryptography decrypts the ciphertext using the private component of the asymmetric encryption key pair. For data encryption outside of Amazon Web Services Payment Cryptography, you can export the public component of the asymmetric key pair by calling [GetPublicCertificate](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_GetPublicKeyCertificate.html). This operation also supports dynamic keys, allowing you to pass a dynamic decryption key as a TR-31 WrappedKeyBlock. This can be used when key material is frequently rotated, such as during every card transaction, and there is need to avoid importing short-lived keys into Amazon Web Services Payment Cryptography. To decrypt using dynamic keys, the keyARN is the Key Encryption Key (KEK) of the TR-31 wrapped decryption key material. The incoming wrapped key shall have a key purpose of D0 with a mode of use of B or D. For more information, see [Using Dynamic Keys](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/use-cases-acquirers-dynamickeys.html) in the Amazon Web Services Payment Cryptography User Guide. For symmetric and DUKPT decryption, Amazon Web Services Payment Cryptography supports TDES and AES algorithms. For EMV decryption, Amazon Web Services Payment Cryptography supports TDES algorithms. For asymmetric decryption, Amazon Web Services Payment Cryptography supports RSA. When you use TDES or TDES DUKPT, the ciphertext data length must be a multiple of 8 bytes. For AES or AES DUKPT, the ciphertext data length must be a multiple of 16 bytes. For RSA, it sould be equal to the key size unless padding is enabled. For information about valid keys for this operation, see [Understanding key attributes](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/keys-validattributes.html) and [Key types for specific data operations](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/crypto-ops-validkeys-ops.html) in the Amazon Web Services Payment Cryptography User Guide. Cross-account use: This operation can't be used across different Amazon Web Services accounts. Related operations:
    ///
    /// * [EncryptData]
    ///
    /// * [GetPublicCertificate](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_GetPublicKeyCertificate.html)
    ///
    /// * [ImportKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_ImportKey.html)
    ///
    /// - Parameter input: [no documentation found] (Type: `DecryptDataInput`)
    ///
    /// - Returns: [no documentation found] (Type: `DecryptDataOutput`)
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You do not have sufficient access to perform this action.
    /// - `InternalServerException` : The request processing has failed because of an unknown error, exception, or failure.
    /// - `ResourceNotFoundException` : The request was denied due to an invalid resource error.
    /// - `ThrottlingException` : The request was denied due to request throttling.
    /// - `ValidationException` : The request was denied due to an invalid request error.
    public func decryptData(input: DecryptDataInput) async throws -> DecryptDataOutput {
        let context = Smithy.ContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "decryptData")
                      .withUnsignedPayloadTrait(value: false)
                      .withSmithyDefaultConfig(config)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withRequestChecksumCalculation(value: config.requestChecksumCalculation)
                      .withResponseChecksumValidation(value: config.responseChecksumValidation)
                      .withSigningName(value: "payment-cryptography")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        let builder = ClientRuntime.OrchestratorBuilder<DecryptDataInput, DecryptDataOutput, SmithyHTTPAPI.HTTPRequest, SmithyHTTPAPI.HTTPResponse>()
        config.interceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        config.httpInterceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        builder.interceptors.add(ClientRuntime.URLPathMiddleware<DecryptDataInput, DecryptDataOutput>(DecryptDataInput.urlPathProvider(_:)))
        builder.interceptors.add(ClientRuntime.URLHostMiddleware<DecryptDataInput, DecryptDataOutput>())
        builder.interceptors.add(ClientRuntime.ContentTypeMiddleware<DecryptDataInput, DecryptDataOutput>(contentType: "application/json"))
        builder.serialize(ClientRuntime.BodyMiddleware<DecryptDataInput, DecryptDataOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: DecryptDataInput.write(value:to:)))
        builder.interceptors.add(ClientRuntime.ContentLengthMiddleware<DecryptDataInput, DecryptDataOutput>())
        builder.deserialize(ClientRuntime.DeserializeMiddleware<DecryptDataOutput>(DecryptDataOutput.httpOutput(from:), DecryptDataOutputError.httpError(from:)))
        builder.interceptors.add(ClientRuntime.LoggerMiddleware<DecryptDataInput, DecryptDataOutput>(clientLogMode: config.clientLogMode))
        builder.clockSkewProvider(AWSClientRuntime.AWSClockSkewProvider.provider())
        builder.retryStrategy(SmithyRetries.DefaultRetryStrategy(options: config.retryStrategyOptions))
        builder.retryErrorInfoProvider(AWSClientRuntime.AWSRetryErrorInfoProvider.errorInfo(for:))
        builder.applySigner(ClientRuntime.SignerMiddleware<DecryptDataOutput>())
        let configuredEndpoint = try config.endpoint ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.configuredEndpoint("Payment Cryptography Data", config.ignoreConfiguredEndpointURLs)
        let endpointParamsBlock = { [config] (context: Smithy.Context) in
            EndpointParams(endpoint: configuredEndpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        }
        builder.applyEndpoint(AWSClientRuntime.AWSEndpointResolverMiddleware<DecryptDataOutput, EndpointParams>(paramsBlock: endpointParamsBlock, resolverBlock: { [config] in try config.endpointResolver.resolve(params: $0) }))
        builder.selectAuthScheme(ClientRuntime.AuthSchemeMiddleware<DecryptDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkInvocationIdMiddleware<DecryptDataInput, DecryptDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkRequestMiddleware<DecryptDataInput, DecryptDataOutput>(maxRetries: config.retryStrategyOptions.maxRetriesBase))
        builder.interceptors.add(AWSClientRuntime.UserAgentMiddleware<DecryptDataInput, DecryptDataOutput>(serviceID: serviceName, version: PaymentCryptographyDataClient.version, config: config))
        var metricsAttributes = Smithy.Attributes()
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.service, value: "PaymentCryptographyData")
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.method, value: "DecryptData")
        let op = builder.attributes(context)
            .telemetry(ClientRuntime.OrchestratorTelemetry(
                telemetryProvider: config.telemetryProvider,
                metricsAttributes: metricsAttributes,
                meterScope: serviceName,
                tracerScope: serviceName
            ))
            .executeRequest(client)
            .build()
        return try await op.execute(input: input)
    }

    /// Performs the `EncryptData` operation on the `PaymentCryptographyData` service.
    ///
    /// Encrypts plaintext data to ciphertext using a symmetric (TDES, AES), asymmetric (RSA), or derived (DUKPT or EMV) encryption key scheme. For more information, see [Encrypt data](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/encrypt-data.html) in the Amazon Web Services Payment Cryptography User Guide. You can generate an encryption key within Amazon Web Services Payment Cryptography by calling [CreateKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_CreateKey.html). You can import your own encryption key by calling [ImportKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_ImportKey.html). For this operation, the key must have KeyModesOfUse set to Encrypt. In asymmetric encryption, plaintext is encrypted using public component. You can import the public component of an asymmetric key pair created outside Amazon Web Services Payment Cryptography by calling [ImportKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_ImportKey.html). This operation also supports dynamic keys, allowing you to pass a dynamic encryption key as a TR-31 WrappedKeyBlock. This can be used when key material is frequently rotated, such as during every card transaction, and there is need to avoid importing short-lived keys into Amazon Web Services Payment Cryptography. To encrypt using dynamic keys, the keyARN is the Key Encryption Key (KEK) of the TR-31 wrapped encryption key material. The incoming wrapped key shall have a key purpose of D0 with a mode of use of B or D. For more information, see [Using Dynamic Keys](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/use-cases-acquirers-dynamickeys.html) in the Amazon Web Services Payment Cryptography User Guide. For symmetric and DUKPT encryption, Amazon Web Services Payment Cryptography supports TDES and AES algorithms. For EMV encryption, Amazon Web Services Payment Cryptography supports TDES algorithms.For asymmetric encryption, Amazon Web Services Payment Cryptography supports RSA. When you use TDES or TDES DUKPT, the plaintext data length must be a multiple of 8 bytes. For AES or AES DUKPT, the plaintext data length must be a multiple of 16 bytes. For RSA, it sould be equal to the key size unless padding is enabled. To encrypt using DUKPT, you must already have a BDK (Base Derivation Key) key in your account with KeyModesOfUse set to DeriveKey, or you can generate a new DUKPT key by calling [CreateKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_CreateKey.html). To encrypt using EMV, you must already have an IMK (Issuer Master Key) key in your account with KeyModesOfUse set to DeriveKey. For information about valid keys for this operation, see [Understanding key attributes](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/keys-validattributes.html) and [Key types for specific data operations](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/crypto-ops-validkeys-ops.html) in the Amazon Web Services Payment Cryptography User Guide. Cross-account use: This operation can't be used across different Amazon Web Services accounts. Related operations:
    ///
    /// * [DecryptData]
    ///
    /// * [GetPublicCertificate](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_GetPublicKeyCertificate.html)
    ///
    /// * [ImportKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_ImportKey.html)
    ///
    /// * [ReEncryptData]
    ///
    /// - Parameter input: [no documentation found] (Type: `EncryptDataInput`)
    ///
    /// - Returns: [no documentation found] (Type: `EncryptDataOutput`)
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You do not have sufficient access to perform this action.
    /// - `InternalServerException` : The request processing has failed because of an unknown error, exception, or failure.
    /// - `ResourceNotFoundException` : The request was denied due to an invalid resource error.
    /// - `ThrottlingException` : The request was denied due to request throttling.
    /// - `ValidationException` : The request was denied due to an invalid request error.
    public func encryptData(input: EncryptDataInput) async throws -> EncryptDataOutput {
        let context = Smithy.ContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "encryptData")
                      .withUnsignedPayloadTrait(value: false)
                      .withSmithyDefaultConfig(config)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withRequestChecksumCalculation(value: config.requestChecksumCalculation)
                      .withResponseChecksumValidation(value: config.responseChecksumValidation)
                      .withSigningName(value: "payment-cryptography")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        let builder = ClientRuntime.OrchestratorBuilder<EncryptDataInput, EncryptDataOutput, SmithyHTTPAPI.HTTPRequest, SmithyHTTPAPI.HTTPResponse>()
        config.interceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        config.httpInterceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        builder.interceptors.add(ClientRuntime.URLPathMiddleware<EncryptDataInput, EncryptDataOutput>(EncryptDataInput.urlPathProvider(_:)))
        builder.interceptors.add(ClientRuntime.URLHostMiddleware<EncryptDataInput, EncryptDataOutput>())
        builder.interceptors.add(ClientRuntime.ContentTypeMiddleware<EncryptDataInput, EncryptDataOutput>(contentType: "application/json"))
        builder.serialize(ClientRuntime.BodyMiddleware<EncryptDataInput, EncryptDataOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: EncryptDataInput.write(value:to:)))
        builder.interceptors.add(ClientRuntime.ContentLengthMiddleware<EncryptDataInput, EncryptDataOutput>())
        builder.deserialize(ClientRuntime.DeserializeMiddleware<EncryptDataOutput>(EncryptDataOutput.httpOutput(from:), EncryptDataOutputError.httpError(from:)))
        builder.interceptors.add(ClientRuntime.LoggerMiddleware<EncryptDataInput, EncryptDataOutput>(clientLogMode: config.clientLogMode))
        builder.clockSkewProvider(AWSClientRuntime.AWSClockSkewProvider.provider())
        builder.retryStrategy(SmithyRetries.DefaultRetryStrategy(options: config.retryStrategyOptions))
        builder.retryErrorInfoProvider(AWSClientRuntime.AWSRetryErrorInfoProvider.errorInfo(for:))
        builder.applySigner(ClientRuntime.SignerMiddleware<EncryptDataOutput>())
        let configuredEndpoint = try config.endpoint ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.configuredEndpoint("Payment Cryptography Data", config.ignoreConfiguredEndpointURLs)
        let endpointParamsBlock = { [config] (context: Smithy.Context) in
            EndpointParams(endpoint: configuredEndpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        }
        builder.applyEndpoint(AWSClientRuntime.AWSEndpointResolverMiddleware<EncryptDataOutput, EndpointParams>(paramsBlock: endpointParamsBlock, resolverBlock: { [config] in try config.endpointResolver.resolve(params: $0) }))
        builder.selectAuthScheme(ClientRuntime.AuthSchemeMiddleware<EncryptDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkInvocationIdMiddleware<EncryptDataInput, EncryptDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkRequestMiddleware<EncryptDataInput, EncryptDataOutput>(maxRetries: config.retryStrategyOptions.maxRetriesBase))
        builder.interceptors.add(AWSClientRuntime.UserAgentMiddleware<EncryptDataInput, EncryptDataOutput>(serviceID: serviceName, version: PaymentCryptographyDataClient.version, config: config))
        var metricsAttributes = Smithy.Attributes()
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.service, value: "PaymentCryptographyData")
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.method, value: "EncryptData")
        let op = builder.attributes(context)
            .telemetry(ClientRuntime.OrchestratorTelemetry(
                telemetryProvider: config.telemetryProvider,
                metricsAttributes: metricsAttributes,
                meterScope: serviceName,
                tracerScope: serviceName
            ))
            .executeRequest(client)
            .build()
        return try await op.execute(input: input)
    }

    /// Performs the `GenerateAs2805KekValidation` operation on the `PaymentCryptographyData` service.
    ///
    /// Establishes node-to-node initialization between payment processing nodes such as an acquirer, issuer or payment network using Australian Standard 2805 (AS2805). During node-to-node initialization, both communicating nodes must validate that they possess the correct Key Encrypting Keys (KEKs) before proceeding with session key exchange. In AS2805, the sending KEK (KEKs) of one node corresponds to the receiving KEK (KEKr) of its partner node. Each node uses its KEK to encrypt and decrypt session keys exchanged between the nodes. A KEK can be created or imported into Amazon Web Services Payment Cryptography using either the [CreateKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_CreateKey.html) or [ImportKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_ImportKey.html) operations. The node initiating communication can use GenerateAS2805KekValidation to generate a combined KEK validation request and KEK validation response to send to the partnering node for validation. When invoked, the API internally generates a random sending key encrypted under KEKs and provides a receiving key encrypted under KEKr as response. The initiating node sends the response returned by this API to its partner for validation. For information about valid keys for this operation, see [Understanding key attributes](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/keys-validattributes.html) and [Key types for specific data operations](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/crypto-ops-validkeys-ops.html) in the Amazon Web Services Payment Cryptography User Guide. Cross-account use: This operation can't be used across different Amazon Web Services accounts.
    ///
    /// - Parameter input: [no documentation found] (Type: `GenerateAs2805KekValidationInput`)
    ///
    /// - Returns: [no documentation found] (Type: `GenerateAs2805KekValidationOutput`)
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You do not have sufficient access to perform this action.
    /// - `InternalServerException` : The request processing has failed because of an unknown error, exception, or failure.
    /// - `ResourceNotFoundException` : The request was denied due to an invalid resource error.
    /// - `ThrottlingException` : The request was denied due to request throttling.
    /// - `ValidationException` : The request was denied due to an invalid request error.
    public func generateAs2805KekValidation(input: GenerateAs2805KekValidationInput) async throws -> GenerateAs2805KekValidationOutput {
        let context = Smithy.ContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "generateAs2805KekValidation")
                      .withUnsignedPayloadTrait(value: false)
                      .withSmithyDefaultConfig(config)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withRequestChecksumCalculation(value: config.requestChecksumCalculation)
                      .withResponseChecksumValidation(value: config.responseChecksumValidation)
                      .withSigningName(value: "payment-cryptography")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        let builder = ClientRuntime.OrchestratorBuilder<GenerateAs2805KekValidationInput, GenerateAs2805KekValidationOutput, SmithyHTTPAPI.HTTPRequest, SmithyHTTPAPI.HTTPResponse>()
        config.interceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        config.httpInterceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        builder.interceptors.add(ClientRuntime.URLPathMiddleware<GenerateAs2805KekValidationInput, GenerateAs2805KekValidationOutput>(GenerateAs2805KekValidationInput.urlPathProvider(_:)))
        builder.interceptors.add(ClientRuntime.URLHostMiddleware<GenerateAs2805KekValidationInput, GenerateAs2805KekValidationOutput>())
        builder.interceptors.add(ClientRuntime.ContentTypeMiddleware<GenerateAs2805KekValidationInput, GenerateAs2805KekValidationOutput>(contentType: "application/json"))
        builder.serialize(ClientRuntime.BodyMiddleware<GenerateAs2805KekValidationInput, GenerateAs2805KekValidationOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: GenerateAs2805KekValidationInput.write(value:to:)))
        builder.interceptors.add(ClientRuntime.ContentLengthMiddleware<GenerateAs2805KekValidationInput, GenerateAs2805KekValidationOutput>())
        builder.deserialize(ClientRuntime.DeserializeMiddleware<GenerateAs2805KekValidationOutput>(GenerateAs2805KekValidationOutput.httpOutput(from:), GenerateAs2805KekValidationOutputError.httpError(from:)))
        builder.interceptors.add(ClientRuntime.LoggerMiddleware<GenerateAs2805KekValidationInput, GenerateAs2805KekValidationOutput>(clientLogMode: config.clientLogMode))
        builder.clockSkewProvider(AWSClientRuntime.AWSClockSkewProvider.provider())
        builder.retryStrategy(SmithyRetries.DefaultRetryStrategy(options: config.retryStrategyOptions))
        builder.retryErrorInfoProvider(AWSClientRuntime.AWSRetryErrorInfoProvider.errorInfo(for:))
        builder.applySigner(ClientRuntime.SignerMiddleware<GenerateAs2805KekValidationOutput>())
        let configuredEndpoint = try config.endpoint ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.configuredEndpoint("Payment Cryptography Data", config.ignoreConfiguredEndpointURLs)
        let endpointParamsBlock = { [config] (context: Smithy.Context) in
            EndpointParams(endpoint: configuredEndpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        }
        builder.applyEndpoint(AWSClientRuntime.AWSEndpointResolverMiddleware<GenerateAs2805KekValidationOutput, EndpointParams>(paramsBlock: endpointParamsBlock, resolverBlock: { [config] in try config.endpointResolver.resolve(params: $0) }))
        builder.selectAuthScheme(ClientRuntime.AuthSchemeMiddleware<GenerateAs2805KekValidationOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkInvocationIdMiddleware<GenerateAs2805KekValidationInput, GenerateAs2805KekValidationOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkRequestMiddleware<GenerateAs2805KekValidationInput, GenerateAs2805KekValidationOutput>(maxRetries: config.retryStrategyOptions.maxRetriesBase))
        builder.interceptors.add(AWSClientRuntime.UserAgentMiddleware<GenerateAs2805KekValidationInput, GenerateAs2805KekValidationOutput>(serviceID: serviceName, version: PaymentCryptographyDataClient.version, config: config))
        var metricsAttributes = Smithy.Attributes()
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.service, value: "PaymentCryptographyData")
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.method, value: "GenerateAs2805KekValidation")
        let op = builder.attributes(context)
            .telemetry(ClientRuntime.OrchestratorTelemetry(
                telemetryProvider: config.telemetryProvider,
                metricsAttributes: metricsAttributes,
                meterScope: serviceName,
                tracerScope: serviceName
            ))
            .executeRequest(client)
            .build()
        return try await op.execute(input: input)
    }

    /// Performs the `GenerateCardValidationData` operation on the `PaymentCryptographyData` service.
    ///
    /// Generates card-related validation data using algorithms such as Card Verification Values (CVV/CVV2), Dynamic Card Verification Values (dCVV/dCVV2), or Card Security Codes (CSC). For more information, see [Generate card data](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/generate-card-data.html) in the Amazon Web Services Payment Cryptography User Guide. This operation generates a CVV or CSC value that is printed on a payment credit or debit card during card production. The CVV or CSC, PAN (Primary Account Number) and expiration date of the card are required to check its validity during transaction processing. To begin this operation, a CVK (Card Verification Key) encryption key is required. You can use [CreateKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_CreateKey.html) or [ImportKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_ImportKey.html) to establish a CVK within Amazon Web Services Payment Cryptography. The KeyModesOfUse should be set to Generate and Verify for a CVK encryption key. For information about valid keys for this operation, see [Understanding key attributes](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/keys-validattributes.html) and [Key types for specific data operations](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/crypto-ops-validkeys-ops.html) in the Amazon Web Services Payment Cryptography User Guide. Cross-account use: This operation can't be used across different Amazon Web Services accounts. Related operations:
    ///
    /// * [ImportKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_ImportKey.html)
    ///
    /// * [VerifyCardValidationData]
    ///
    /// - Parameter input: [no documentation found] (Type: `GenerateCardValidationDataInput`)
    ///
    /// - Returns: [no documentation found] (Type: `GenerateCardValidationDataOutput`)
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You do not have sufficient access to perform this action.
    /// - `InternalServerException` : The request processing has failed because of an unknown error, exception, or failure.
    /// - `ResourceNotFoundException` : The request was denied due to an invalid resource error.
    /// - `ThrottlingException` : The request was denied due to request throttling.
    /// - `ValidationException` : The request was denied due to an invalid request error.
    public func generateCardValidationData(input: GenerateCardValidationDataInput) async throws -> GenerateCardValidationDataOutput {
        let context = Smithy.ContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "generateCardValidationData")
                      .withUnsignedPayloadTrait(value: false)
                      .withSmithyDefaultConfig(config)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withRequestChecksumCalculation(value: config.requestChecksumCalculation)
                      .withResponseChecksumValidation(value: config.responseChecksumValidation)
                      .withSigningName(value: "payment-cryptography")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        let builder = ClientRuntime.OrchestratorBuilder<GenerateCardValidationDataInput, GenerateCardValidationDataOutput, SmithyHTTPAPI.HTTPRequest, SmithyHTTPAPI.HTTPResponse>()
        config.interceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        config.httpInterceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        builder.interceptors.add(ClientRuntime.URLPathMiddleware<GenerateCardValidationDataInput, GenerateCardValidationDataOutput>(GenerateCardValidationDataInput.urlPathProvider(_:)))
        builder.interceptors.add(ClientRuntime.URLHostMiddleware<GenerateCardValidationDataInput, GenerateCardValidationDataOutput>())
        builder.interceptors.add(ClientRuntime.ContentTypeMiddleware<GenerateCardValidationDataInput, GenerateCardValidationDataOutput>(contentType: "application/json"))
        builder.serialize(ClientRuntime.BodyMiddleware<GenerateCardValidationDataInput, GenerateCardValidationDataOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: GenerateCardValidationDataInput.write(value:to:)))
        builder.interceptors.add(ClientRuntime.ContentLengthMiddleware<GenerateCardValidationDataInput, GenerateCardValidationDataOutput>())
        builder.deserialize(ClientRuntime.DeserializeMiddleware<GenerateCardValidationDataOutput>(GenerateCardValidationDataOutput.httpOutput(from:), GenerateCardValidationDataOutputError.httpError(from:)))
        builder.interceptors.add(ClientRuntime.LoggerMiddleware<GenerateCardValidationDataInput, GenerateCardValidationDataOutput>(clientLogMode: config.clientLogMode))
        builder.clockSkewProvider(AWSClientRuntime.AWSClockSkewProvider.provider())
        builder.retryStrategy(SmithyRetries.DefaultRetryStrategy(options: config.retryStrategyOptions))
        builder.retryErrorInfoProvider(AWSClientRuntime.AWSRetryErrorInfoProvider.errorInfo(for:))
        builder.applySigner(ClientRuntime.SignerMiddleware<GenerateCardValidationDataOutput>())
        let configuredEndpoint = try config.endpoint ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.configuredEndpoint("Payment Cryptography Data", config.ignoreConfiguredEndpointURLs)
        let endpointParamsBlock = { [config] (context: Smithy.Context) in
            EndpointParams(endpoint: configuredEndpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        }
        builder.applyEndpoint(AWSClientRuntime.AWSEndpointResolverMiddleware<GenerateCardValidationDataOutput, EndpointParams>(paramsBlock: endpointParamsBlock, resolverBlock: { [config] in try config.endpointResolver.resolve(params: $0) }))
        builder.selectAuthScheme(ClientRuntime.AuthSchemeMiddleware<GenerateCardValidationDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkInvocationIdMiddleware<GenerateCardValidationDataInput, GenerateCardValidationDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkRequestMiddleware<GenerateCardValidationDataInput, GenerateCardValidationDataOutput>(maxRetries: config.retryStrategyOptions.maxRetriesBase))
        builder.interceptors.add(AWSClientRuntime.UserAgentMiddleware<GenerateCardValidationDataInput, GenerateCardValidationDataOutput>(serviceID: serviceName, version: PaymentCryptographyDataClient.version, config: config))
        var metricsAttributes = Smithy.Attributes()
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.service, value: "PaymentCryptographyData")
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.method, value: "GenerateCardValidationData")
        let op = builder.attributes(context)
            .telemetry(ClientRuntime.OrchestratorTelemetry(
                telemetryProvider: config.telemetryProvider,
                metricsAttributes: metricsAttributes,
                meterScope: serviceName,
                tracerScope: serviceName
            ))
            .executeRequest(client)
            .build()
        return try await op.execute(input: input)
    }

    /// Performs the `GenerateMac` operation on the `PaymentCryptographyData` service.
    ///
    /// Generates a Message Authentication Code (MAC) cryptogram within Amazon Web Services Payment Cryptography. You can use this operation to authenticate card-related data by using known data values to generate MAC for data validation between the sending and receiving parties. This operation uses message data, a secret encryption key and MAC algorithm to generate a unique MAC value for transmission. The receiving party of the MAC must use the same message data, secret encryption key and MAC algorithm to reproduce another MAC value for comparision. You can use this operation to generate a DUPKT, CMAC, HMAC or EMV MAC by setting generation attributes and algorithm to the associated values. The MAC generation encryption key must have valid values for KeyUsage such as TR31_M7_HMAC_KEY for HMAC generation, and the key must have KeyModesOfUse set to Generate. For information about valid keys for this operation, see [Understanding key attributes](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/keys-validattributes.html) and [Key types for specific data operations](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/crypto-ops-validkeys-ops.html) in the Amazon Web Services Payment Cryptography User Guide. Cross-account use: This operation can't be used across different Amazon Web Services accounts. Related operations:
    ///
    /// * [VerifyMac]
    ///
    /// - Parameter input: [no documentation found] (Type: `GenerateMacInput`)
    ///
    /// - Returns: [no documentation found] (Type: `GenerateMacOutput`)
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You do not have sufficient access to perform this action.
    /// - `InternalServerException` : The request processing has failed because of an unknown error, exception, or failure.
    /// - `ResourceNotFoundException` : The request was denied due to an invalid resource error.
    /// - `ThrottlingException` : The request was denied due to request throttling.
    /// - `ValidationException` : The request was denied due to an invalid request error.
    public func generateMac(input: GenerateMacInput) async throws -> GenerateMacOutput {
        let context = Smithy.ContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "generateMac")
                      .withUnsignedPayloadTrait(value: false)
                      .withSmithyDefaultConfig(config)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withRequestChecksumCalculation(value: config.requestChecksumCalculation)
                      .withResponseChecksumValidation(value: config.responseChecksumValidation)
                      .withSigningName(value: "payment-cryptography")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        let builder = ClientRuntime.OrchestratorBuilder<GenerateMacInput, GenerateMacOutput, SmithyHTTPAPI.HTTPRequest, SmithyHTTPAPI.HTTPResponse>()
        config.interceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        config.httpInterceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        builder.interceptors.add(ClientRuntime.URLPathMiddleware<GenerateMacInput, GenerateMacOutput>(GenerateMacInput.urlPathProvider(_:)))
        builder.interceptors.add(ClientRuntime.URLHostMiddleware<GenerateMacInput, GenerateMacOutput>())
        builder.interceptors.add(ClientRuntime.ContentTypeMiddleware<GenerateMacInput, GenerateMacOutput>(contentType: "application/json"))
        builder.serialize(ClientRuntime.BodyMiddleware<GenerateMacInput, GenerateMacOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: GenerateMacInput.write(value:to:)))
        builder.interceptors.add(ClientRuntime.ContentLengthMiddleware<GenerateMacInput, GenerateMacOutput>())
        builder.deserialize(ClientRuntime.DeserializeMiddleware<GenerateMacOutput>(GenerateMacOutput.httpOutput(from:), GenerateMacOutputError.httpError(from:)))
        builder.interceptors.add(ClientRuntime.LoggerMiddleware<GenerateMacInput, GenerateMacOutput>(clientLogMode: config.clientLogMode))
        builder.clockSkewProvider(AWSClientRuntime.AWSClockSkewProvider.provider())
        builder.retryStrategy(SmithyRetries.DefaultRetryStrategy(options: config.retryStrategyOptions))
        builder.retryErrorInfoProvider(AWSClientRuntime.AWSRetryErrorInfoProvider.errorInfo(for:))
        builder.applySigner(ClientRuntime.SignerMiddleware<GenerateMacOutput>())
        let configuredEndpoint = try config.endpoint ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.configuredEndpoint("Payment Cryptography Data", config.ignoreConfiguredEndpointURLs)
        let endpointParamsBlock = { [config] (context: Smithy.Context) in
            EndpointParams(endpoint: configuredEndpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        }
        builder.applyEndpoint(AWSClientRuntime.AWSEndpointResolverMiddleware<GenerateMacOutput, EndpointParams>(paramsBlock: endpointParamsBlock, resolverBlock: { [config] in try config.endpointResolver.resolve(params: $0) }))
        builder.selectAuthScheme(ClientRuntime.AuthSchemeMiddleware<GenerateMacOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkInvocationIdMiddleware<GenerateMacInput, GenerateMacOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkRequestMiddleware<GenerateMacInput, GenerateMacOutput>(maxRetries: config.retryStrategyOptions.maxRetriesBase))
        builder.interceptors.add(AWSClientRuntime.UserAgentMiddleware<GenerateMacInput, GenerateMacOutput>(serviceID: serviceName, version: PaymentCryptographyDataClient.version, config: config))
        var metricsAttributes = Smithy.Attributes()
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.service, value: "PaymentCryptographyData")
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.method, value: "GenerateMac")
        let op = builder.attributes(context)
            .telemetry(ClientRuntime.OrchestratorTelemetry(
                telemetryProvider: config.telemetryProvider,
                metricsAttributes: metricsAttributes,
                meterScope: serviceName,
                tracerScope: serviceName
            ))
            .executeRequest(client)
            .build()
        return try await op.execute(input: input)
    }

    /// Performs the `GenerateMacEmvPinChange` operation on the `PaymentCryptographyData` service.
    ///
    /// Generates an issuer script mac for EMV payment cards that use offline PINs as the cardholder verification method (CVM). This operation generates an authenticated issuer script response by appending the incoming message data (APDU command) with the target encrypted PIN block in ISO2 format. The command structure and method to send the issuer script update to the card is not defined by this operation and is typically determined by the applicable payment card scheme. The primary inputs to this operation include the incoming new encrypted pinblock, PIN encryption key (PEK), issuer master key (IMK), primary account number (PAN), and the payment card derivation method. The operation uses two issuer master keys - secure messaging for confidentiality (IMK-SMC) and secure messaging for integrity (IMK-SMI). The SMC key is used to internally derive a key to secure the pin, while SMI key is used to internally derive a key to authenticate the script reponse as per the [EMV 4.4 - Book 2 - Security and Key Management](https://www.emvco.com/specifications/) specification. This operation supports Amex, EMV2000, EMVCommon, Mastercard and Visa derivation methods, each requiring specific input parameters. Users must follow the specific derivation method and input parameters defined by the respective payment card scheme. Use [GenerateMac] operation when sending a script update to an EMV card that does not involve PIN change. When assigning IAM permissions, it is important to understand that [EncryptData] using EMV keys and [GenerateMac] perform similar functions to this command. Cross-account use: This operation can't be used across different Amazon Web Services accounts. Related operations:
    ///
    /// * [EncryptData]
    ///
    /// * [GenerateMac]
    ///
    /// - Parameter input: [no documentation found] (Type: `GenerateMacEmvPinChangeInput`)
    ///
    /// - Returns: [no documentation found] (Type: `GenerateMacEmvPinChangeOutput`)
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You do not have sufficient access to perform this action.
    /// - `InternalServerException` : The request processing has failed because of an unknown error, exception, or failure.
    /// - `ResourceNotFoundException` : The request was denied due to an invalid resource error.
    /// - `ThrottlingException` : The request was denied due to request throttling.
    /// - `ValidationException` : The request was denied due to an invalid request error.
    public func generateMacEmvPinChange(input: GenerateMacEmvPinChangeInput) async throws -> GenerateMacEmvPinChangeOutput {
        let context = Smithy.ContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "generateMacEmvPinChange")
                      .withUnsignedPayloadTrait(value: false)
                      .withSmithyDefaultConfig(config)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withRequestChecksumCalculation(value: config.requestChecksumCalculation)
                      .withResponseChecksumValidation(value: config.responseChecksumValidation)
                      .withSigningName(value: "payment-cryptography")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        let builder = ClientRuntime.OrchestratorBuilder<GenerateMacEmvPinChangeInput, GenerateMacEmvPinChangeOutput, SmithyHTTPAPI.HTTPRequest, SmithyHTTPAPI.HTTPResponse>()
        config.interceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        config.httpInterceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        builder.interceptors.add(ClientRuntime.URLPathMiddleware<GenerateMacEmvPinChangeInput, GenerateMacEmvPinChangeOutput>(GenerateMacEmvPinChangeInput.urlPathProvider(_:)))
        builder.interceptors.add(ClientRuntime.URLHostMiddleware<GenerateMacEmvPinChangeInput, GenerateMacEmvPinChangeOutput>())
        builder.interceptors.add(ClientRuntime.ContentTypeMiddleware<GenerateMacEmvPinChangeInput, GenerateMacEmvPinChangeOutput>(contentType: "application/json"))
        builder.serialize(ClientRuntime.BodyMiddleware<GenerateMacEmvPinChangeInput, GenerateMacEmvPinChangeOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: GenerateMacEmvPinChangeInput.write(value:to:)))
        builder.interceptors.add(ClientRuntime.ContentLengthMiddleware<GenerateMacEmvPinChangeInput, GenerateMacEmvPinChangeOutput>())
        builder.deserialize(ClientRuntime.DeserializeMiddleware<GenerateMacEmvPinChangeOutput>(GenerateMacEmvPinChangeOutput.httpOutput(from:), GenerateMacEmvPinChangeOutputError.httpError(from:)))
        builder.interceptors.add(ClientRuntime.LoggerMiddleware<GenerateMacEmvPinChangeInput, GenerateMacEmvPinChangeOutput>(clientLogMode: config.clientLogMode))
        builder.clockSkewProvider(AWSClientRuntime.AWSClockSkewProvider.provider())
        builder.retryStrategy(SmithyRetries.DefaultRetryStrategy(options: config.retryStrategyOptions))
        builder.retryErrorInfoProvider(AWSClientRuntime.AWSRetryErrorInfoProvider.errorInfo(for:))
        builder.applySigner(ClientRuntime.SignerMiddleware<GenerateMacEmvPinChangeOutput>())
        let configuredEndpoint = try config.endpoint ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.configuredEndpoint("Payment Cryptography Data", config.ignoreConfiguredEndpointURLs)
        let endpointParamsBlock = { [config] (context: Smithy.Context) in
            EndpointParams(endpoint: configuredEndpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        }
        builder.applyEndpoint(AWSClientRuntime.AWSEndpointResolverMiddleware<GenerateMacEmvPinChangeOutput, EndpointParams>(paramsBlock: endpointParamsBlock, resolverBlock: { [config] in try config.endpointResolver.resolve(params: $0) }))
        builder.selectAuthScheme(ClientRuntime.AuthSchemeMiddleware<GenerateMacEmvPinChangeOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkInvocationIdMiddleware<GenerateMacEmvPinChangeInput, GenerateMacEmvPinChangeOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkRequestMiddleware<GenerateMacEmvPinChangeInput, GenerateMacEmvPinChangeOutput>(maxRetries: config.retryStrategyOptions.maxRetriesBase))
        builder.interceptors.add(AWSClientRuntime.UserAgentMiddleware<GenerateMacEmvPinChangeInput, GenerateMacEmvPinChangeOutput>(serviceID: serviceName, version: PaymentCryptographyDataClient.version, config: config))
        var metricsAttributes = Smithy.Attributes()
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.service, value: "PaymentCryptographyData")
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.method, value: "GenerateMacEmvPinChange")
        let op = builder.attributes(context)
            .telemetry(ClientRuntime.OrchestratorTelemetry(
                telemetryProvider: config.telemetryProvider,
                metricsAttributes: metricsAttributes,
                meterScope: serviceName,
                tracerScope: serviceName
            ))
            .executeRequest(client)
            .build()
        return try await op.execute(input: input)
    }

    /// Performs the `GeneratePinData` operation on the `PaymentCryptographyData` service.
    ///
    /// Generates pin-related data such as PIN, PIN Verification Value (PVV), PIN Block, and PIN Offset during new card issuance or reissuance. For more information, see [Generate PIN data](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/generate-pin-data.html) in the Amazon Web Services Payment Cryptography User Guide. PIN data is never transmitted in clear to or from Amazon Web Services Payment Cryptography. This operation generates PIN, PVV, or PIN Offset and then encrypts it using Pin Encryption Key (PEK) to create an EncryptedPinBlock for transmission from Amazon Web Services Payment Cryptography. This operation uses a separate Pin Verification Key (PVK) for VISA PVV generation. Using ECDH key exchange, you can receive cardholder selectable PINs into Amazon Web Services Payment Cryptography. The ECDH derived key protects the incoming PIN block. You can also use it for reveal PIN, wherein the generated PIN block is protected by the ECDH derived key before transmission from Amazon Web Services Payment Cryptography. For more information on establishing ECDH derived keys, see the [Generating keys](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/create-keys.html) in the Amazon Web Services Payment Cryptography User Guide. For information about valid keys for this operation, see [Understanding key attributes](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/keys-validattributes.html) and [Key types for specific data operations](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/crypto-ops-validkeys-ops.html) in the Amazon Web Services Payment Cryptography User Guide. Cross-account use: This operation can't be used across different Amazon Web Services accounts. Related operations:
    ///
    /// * [GenerateCardValidationData]
    ///
    /// * [TranslatePinData]
    ///
    /// * [VerifyPinData]
    ///
    /// - Parameter input: [no documentation found] (Type: `GeneratePinDataInput`)
    ///
    /// - Returns: [no documentation found] (Type: `GeneratePinDataOutput`)
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You do not have sufficient access to perform this action.
    /// - `InternalServerException` : The request processing has failed because of an unknown error, exception, or failure.
    /// - `ResourceNotFoundException` : The request was denied due to an invalid resource error.
    /// - `ThrottlingException` : The request was denied due to request throttling.
    /// - `ValidationException` : The request was denied due to an invalid request error.
    public func generatePinData(input: GeneratePinDataInput) async throws -> GeneratePinDataOutput {
        let context = Smithy.ContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "generatePinData")
                      .withUnsignedPayloadTrait(value: false)
                      .withSmithyDefaultConfig(config)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withRequestChecksumCalculation(value: config.requestChecksumCalculation)
                      .withResponseChecksumValidation(value: config.responseChecksumValidation)
                      .withSigningName(value: "payment-cryptography")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        let builder = ClientRuntime.OrchestratorBuilder<GeneratePinDataInput, GeneratePinDataOutput, SmithyHTTPAPI.HTTPRequest, SmithyHTTPAPI.HTTPResponse>()
        config.interceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        config.httpInterceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        builder.interceptors.add(ClientRuntime.URLPathMiddleware<GeneratePinDataInput, GeneratePinDataOutput>(GeneratePinDataInput.urlPathProvider(_:)))
        builder.interceptors.add(ClientRuntime.URLHostMiddleware<GeneratePinDataInput, GeneratePinDataOutput>())
        builder.interceptors.add(ClientRuntime.ContentTypeMiddleware<GeneratePinDataInput, GeneratePinDataOutput>(contentType: "application/json"))
        builder.serialize(ClientRuntime.BodyMiddleware<GeneratePinDataInput, GeneratePinDataOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: GeneratePinDataInput.write(value:to:)))
        builder.interceptors.add(ClientRuntime.ContentLengthMiddleware<GeneratePinDataInput, GeneratePinDataOutput>())
        builder.deserialize(ClientRuntime.DeserializeMiddleware<GeneratePinDataOutput>(GeneratePinDataOutput.httpOutput(from:), GeneratePinDataOutputError.httpError(from:)))
        builder.interceptors.add(ClientRuntime.LoggerMiddleware<GeneratePinDataInput, GeneratePinDataOutput>(clientLogMode: config.clientLogMode))
        builder.clockSkewProvider(AWSClientRuntime.AWSClockSkewProvider.provider())
        builder.retryStrategy(SmithyRetries.DefaultRetryStrategy(options: config.retryStrategyOptions))
        builder.retryErrorInfoProvider(AWSClientRuntime.AWSRetryErrorInfoProvider.errorInfo(for:))
        builder.applySigner(ClientRuntime.SignerMiddleware<GeneratePinDataOutput>())
        let configuredEndpoint = try config.endpoint ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.configuredEndpoint("Payment Cryptography Data", config.ignoreConfiguredEndpointURLs)
        let endpointParamsBlock = { [config] (context: Smithy.Context) in
            EndpointParams(endpoint: configuredEndpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        }
        builder.applyEndpoint(AWSClientRuntime.AWSEndpointResolverMiddleware<GeneratePinDataOutput, EndpointParams>(paramsBlock: endpointParamsBlock, resolverBlock: { [config] in try config.endpointResolver.resolve(params: $0) }))
        builder.selectAuthScheme(ClientRuntime.AuthSchemeMiddleware<GeneratePinDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkInvocationIdMiddleware<GeneratePinDataInput, GeneratePinDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkRequestMiddleware<GeneratePinDataInput, GeneratePinDataOutput>(maxRetries: config.retryStrategyOptions.maxRetriesBase))
        builder.interceptors.add(AWSClientRuntime.UserAgentMiddleware<GeneratePinDataInput, GeneratePinDataOutput>(serviceID: serviceName, version: PaymentCryptographyDataClient.version, config: config))
        var metricsAttributes = Smithy.Attributes()
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.service, value: "PaymentCryptographyData")
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.method, value: "GeneratePinData")
        let op = builder.attributes(context)
            .telemetry(ClientRuntime.OrchestratorTelemetry(
                telemetryProvider: config.telemetryProvider,
                metricsAttributes: metricsAttributes,
                meterScope: serviceName,
                tracerScope: serviceName
            ))
            .executeRequest(client)
            .build()
        return try await op.execute(input: input)
    }

    /// Performs the `ReEncryptData` operation on the `PaymentCryptographyData` service.
    ///
    /// Re-encrypt ciphertext using DUKPT or Symmetric data encryption keys. You can either generate an encryption key within Amazon Web Services Payment Cryptography by calling [CreateKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_CreateKey.html) or import your own encryption key by calling [ImportKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_ImportKey.html). The KeyArn for use with this operation must be in a compatible key state with KeyModesOfUse set to Encrypt. This operation also supports dynamic keys, allowing you to pass a dynamic encryption key as a TR-31 WrappedKeyBlock. This can be used when key material is frequently rotated, such as during every card transaction, and there is need to avoid importing short-lived keys into Amazon Web Services Payment Cryptography. To re-encrypt using dynamic keys, the keyARN is the Key Encryption Key (KEK) of the TR-31 wrapped encryption key material. The incoming wrapped key shall have a key purpose of D0 with a mode of use of B or D. For more information, see [Using Dynamic Keys](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/use-cases-acquirers-dynamickeys.html) in the Amazon Web Services Payment Cryptography User Guide. For symmetric and DUKPT encryption, Amazon Web Services Payment Cryptography supports TDES and AES algorithms. To encrypt using DUKPT, a DUKPT key must already exist within your account with KeyModesOfUse set to DeriveKey or a new DUKPT can be generated by calling [CreateKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_CreateKey.html). For information about valid keys for this operation, see [Understanding key attributes](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/keys-validattributes.html) and [Key types for specific data operations](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/crypto-ops-validkeys-ops.html) in the Amazon Web Services Payment Cryptography User Guide. Cross-account use: This operation can't be used across different Amazon Web Services accounts. Related operations:
    ///
    /// * [DecryptData]
    ///
    /// * [EncryptData]
    ///
    /// * [GetPublicCertificate](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_GetPublicKeyCertificate.html)
    ///
    /// * [ImportKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_ImportKey.html)
    ///
    /// - Parameter input: [no documentation found] (Type: `ReEncryptDataInput`)
    ///
    /// - Returns: [no documentation found] (Type: `ReEncryptDataOutput`)
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You do not have sufficient access to perform this action.
    /// - `InternalServerException` : The request processing has failed because of an unknown error, exception, or failure.
    /// - `ResourceNotFoundException` : The request was denied due to an invalid resource error.
    /// - `ThrottlingException` : The request was denied due to request throttling.
    /// - `ValidationException` : The request was denied due to an invalid request error.
    public func reEncryptData(input: ReEncryptDataInput) async throws -> ReEncryptDataOutput {
        let context = Smithy.ContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "reEncryptData")
                      .withUnsignedPayloadTrait(value: false)
                      .withSmithyDefaultConfig(config)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withRequestChecksumCalculation(value: config.requestChecksumCalculation)
                      .withResponseChecksumValidation(value: config.responseChecksumValidation)
                      .withSigningName(value: "payment-cryptography")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        let builder = ClientRuntime.OrchestratorBuilder<ReEncryptDataInput, ReEncryptDataOutput, SmithyHTTPAPI.HTTPRequest, SmithyHTTPAPI.HTTPResponse>()
        config.interceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        config.httpInterceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        builder.interceptors.add(ClientRuntime.URLPathMiddleware<ReEncryptDataInput, ReEncryptDataOutput>(ReEncryptDataInput.urlPathProvider(_:)))
        builder.interceptors.add(ClientRuntime.URLHostMiddleware<ReEncryptDataInput, ReEncryptDataOutput>())
        builder.interceptors.add(ClientRuntime.ContentTypeMiddleware<ReEncryptDataInput, ReEncryptDataOutput>(contentType: "application/json"))
        builder.serialize(ClientRuntime.BodyMiddleware<ReEncryptDataInput, ReEncryptDataOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: ReEncryptDataInput.write(value:to:)))
        builder.interceptors.add(ClientRuntime.ContentLengthMiddleware<ReEncryptDataInput, ReEncryptDataOutput>())
        builder.deserialize(ClientRuntime.DeserializeMiddleware<ReEncryptDataOutput>(ReEncryptDataOutput.httpOutput(from:), ReEncryptDataOutputError.httpError(from:)))
        builder.interceptors.add(ClientRuntime.LoggerMiddleware<ReEncryptDataInput, ReEncryptDataOutput>(clientLogMode: config.clientLogMode))
        builder.clockSkewProvider(AWSClientRuntime.AWSClockSkewProvider.provider())
        builder.retryStrategy(SmithyRetries.DefaultRetryStrategy(options: config.retryStrategyOptions))
        builder.retryErrorInfoProvider(AWSClientRuntime.AWSRetryErrorInfoProvider.errorInfo(for:))
        builder.applySigner(ClientRuntime.SignerMiddleware<ReEncryptDataOutput>())
        let configuredEndpoint = try config.endpoint ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.configuredEndpoint("Payment Cryptography Data", config.ignoreConfiguredEndpointURLs)
        let endpointParamsBlock = { [config] (context: Smithy.Context) in
            EndpointParams(endpoint: configuredEndpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        }
        builder.applyEndpoint(AWSClientRuntime.AWSEndpointResolverMiddleware<ReEncryptDataOutput, EndpointParams>(paramsBlock: endpointParamsBlock, resolverBlock: { [config] in try config.endpointResolver.resolve(params: $0) }))
        builder.selectAuthScheme(ClientRuntime.AuthSchemeMiddleware<ReEncryptDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkInvocationIdMiddleware<ReEncryptDataInput, ReEncryptDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkRequestMiddleware<ReEncryptDataInput, ReEncryptDataOutput>(maxRetries: config.retryStrategyOptions.maxRetriesBase))
        builder.interceptors.add(AWSClientRuntime.UserAgentMiddleware<ReEncryptDataInput, ReEncryptDataOutput>(serviceID: serviceName, version: PaymentCryptographyDataClient.version, config: config))
        var metricsAttributes = Smithy.Attributes()
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.service, value: "PaymentCryptographyData")
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.method, value: "ReEncryptData")
        let op = builder.attributes(context)
            .telemetry(ClientRuntime.OrchestratorTelemetry(
                telemetryProvider: config.telemetryProvider,
                metricsAttributes: metricsAttributes,
                meterScope: serviceName,
                tracerScope: serviceName
            ))
            .executeRequest(client)
            .build()
        return try await op.execute(input: input)
    }

    /// Performs the `TranslateKeyMaterial` operation on the `PaymentCryptographyData` service.
    ///
    /// Translates an cryptographic key between different wrapping keys without importing the key into Amazon Web Services Payment Cryptography. This operation can be used when key material is frequently rotated, such as during every card transaction, and there is a need to avoid importing short-lived keys into Amazon Web Services Payment Cryptography. It translates short-lived transaction keys such as [PEK](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/terminology.html#terms.pek) generated for each transaction and wrapped with an [ECDH](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/terminology.html#terms.ecdh) derived wrapping key to another [KEK](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/terminology.html#terms.kek) wrapping key. Before using this operation, you must first request the public key certificate of the ECC key pair generated within Amazon Web Services Payment Cryptography to establish an ECDH key agreement. In TranslateKeyData, the service uses its own ECC key pair, public certificate of receiving ECC key pair, and the key derivation parameters to generate a derived key. The service uses this derived key to unwrap the incoming transaction key received as a TR31WrappedKeyBlock and re-wrap using a user provided KEK to generate an outgoing Tr31WrappedKeyBlock. For information about valid keys for this operation, see [Understanding key attributes](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/keys-validattributes.html) and [Key types for specific data operations](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/crypto-ops-validkeys-ops.html) in the Amazon Web Services Payment Cryptography User Guide. Cross-account use: This operation can't be used across different Amazon Web Services accounts. Related operations:
    ///
    /// * [CreateKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_CreateKey.html)
    ///
    /// * [GetPublicCertificate](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_GetPublicKeyCertificate.html)
    ///
    /// * [ImportKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_ImportKey.html)
    ///
    /// - Parameter input: [no documentation found] (Type: `TranslateKeyMaterialInput`)
    ///
    /// - Returns: [no documentation found] (Type: `TranslateKeyMaterialOutput`)
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You do not have sufficient access to perform this action.
    /// - `InternalServerException` : The request processing has failed because of an unknown error, exception, or failure.
    /// - `ResourceNotFoundException` : The request was denied due to an invalid resource error.
    /// - `ThrottlingException` : The request was denied due to request throttling.
    /// - `ValidationException` : The request was denied due to an invalid request error.
    public func translateKeyMaterial(input: TranslateKeyMaterialInput) async throws -> TranslateKeyMaterialOutput {
        let context = Smithy.ContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "translateKeyMaterial")
                      .withUnsignedPayloadTrait(value: false)
                      .withSmithyDefaultConfig(config)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withRequestChecksumCalculation(value: config.requestChecksumCalculation)
                      .withResponseChecksumValidation(value: config.responseChecksumValidation)
                      .withSigningName(value: "payment-cryptography")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        let builder = ClientRuntime.OrchestratorBuilder<TranslateKeyMaterialInput, TranslateKeyMaterialOutput, SmithyHTTPAPI.HTTPRequest, SmithyHTTPAPI.HTTPResponse>()
        config.interceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        config.httpInterceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        builder.interceptors.add(ClientRuntime.URLPathMiddleware<TranslateKeyMaterialInput, TranslateKeyMaterialOutput>(TranslateKeyMaterialInput.urlPathProvider(_:)))
        builder.interceptors.add(ClientRuntime.URLHostMiddleware<TranslateKeyMaterialInput, TranslateKeyMaterialOutput>())
        builder.interceptors.add(ClientRuntime.ContentTypeMiddleware<TranslateKeyMaterialInput, TranslateKeyMaterialOutput>(contentType: "application/json"))
        builder.serialize(ClientRuntime.BodyMiddleware<TranslateKeyMaterialInput, TranslateKeyMaterialOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: TranslateKeyMaterialInput.write(value:to:)))
        builder.interceptors.add(ClientRuntime.ContentLengthMiddleware<TranslateKeyMaterialInput, TranslateKeyMaterialOutput>())
        builder.deserialize(ClientRuntime.DeserializeMiddleware<TranslateKeyMaterialOutput>(TranslateKeyMaterialOutput.httpOutput(from:), TranslateKeyMaterialOutputError.httpError(from:)))
        builder.interceptors.add(ClientRuntime.LoggerMiddleware<TranslateKeyMaterialInput, TranslateKeyMaterialOutput>(clientLogMode: config.clientLogMode))
        builder.clockSkewProvider(AWSClientRuntime.AWSClockSkewProvider.provider())
        builder.retryStrategy(SmithyRetries.DefaultRetryStrategy(options: config.retryStrategyOptions))
        builder.retryErrorInfoProvider(AWSClientRuntime.AWSRetryErrorInfoProvider.errorInfo(for:))
        builder.applySigner(ClientRuntime.SignerMiddleware<TranslateKeyMaterialOutput>())
        let configuredEndpoint = try config.endpoint ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.configuredEndpoint("Payment Cryptography Data", config.ignoreConfiguredEndpointURLs)
        let endpointParamsBlock = { [config] (context: Smithy.Context) in
            EndpointParams(endpoint: configuredEndpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        }
        builder.applyEndpoint(AWSClientRuntime.AWSEndpointResolverMiddleware<TranslateKeyMaterialOutput, EndpointParams>(paramsBlock: endpointParamsBlock, resolverBlock: { [config] in try config.endpointResolver.resolve(params: $0) }))
        builder.selectAuthScheme(ClientRuntime.AuthSchemeMiddleware<TranslateKeyMaterialOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkInvocationIdMiddleware<TranslateKeyMaterialInput, TranslateKeyMaterialOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkRequestMiddleware<TranslateKeyMaterialInput, TranslateKeyMaterialOutput>(maxRetries: config.retryStrategyOptions.maxRetriesBase))
        builder.interceptors.add(AWSClientRuntime.UserAgentMiddleware<TranslateKeyMaterialInput, TranslateKeyMaterialOutput>(serviceID: serviceName, version: PaymentCryptographyDataClient.version, config: config))
        var metricsAttributes = Smithy.Attributes()
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.service, value: "PaymentCryptographyData")
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.method, value: "TranslateKeyMaterial")
        let op = builder.attributes(context)
            .telemetry(ClientRuntime.OrchestratorTelemetry(
                telemetryProvider: config.telemetryProvider,
                metricsAttributes: metricsAttributes,
                meterScope: serviceName,
                tracerScope: serviceName
            ))
            .executeRequest(client)
            .build()
        return try await op.execute(input: input)
    }

    /// Performs the `TranslatePinData` operation on the `PaymentCryptographyData` service.
    ///
    /// Translates encrypted PIN block from and to ISO 9564 formats 0,1,3,4. For more information, see [Translate PIN data](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/translate-pin-data.html) in the Amazon Web Services Payment Cryptography User Guide. PIN block translation involves changing a PIN block from one encryption key to another and optionally change its format. PIN block translation occurs entirely within the HSM boundary and PIN data never enters or leaves Amazon Web Services Payment Cryptography in clear text. The encryption key transformation can be from PEK (Pin Encryption Key) to BDK (Base Derivation Key) for DUKPT or from BDK for DUKPT to PEK. Amazon Web Services Payment Cryptography also supports use of dynamic keys and ECDH (Elliptic Curve Diffie-Hellman) based key exchange for this operation. Dynamic keys allow you to pass a PEK as a TR-31 WrappedKeyBlock. They can be used when key material is frequently rotated, such as during every card transaction, and there is need to avoid importing short-lived keys into Amazon Web Services Payment Cryptography. To translate PIN block using dynamic keys, the keyARN is the Key Encryption Key (KEK) of the TR-31 wrapped PEK. The incoming wrapped key shall have a key purpose of P0 with a mode of use of B or D. For more information, see [Using Dynamic Keys](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/use-cases-acquirers-dynamickeys.html) in the Amazon Web Services Payment Cryptography User Guide. Using ECDH key exchange, you can receive cardholder selectable PINs into Amazon Web Services Payment Cryptography. The ECDH derived key protects the incoming PIN block, which is translated to a PEK encrypted PIN block for use within the service. You can also use ECDH for reveal PIN, wherein the service translates the PIN block from PEK to a ECDH derived encryption key. For more information on establishing ECDH derived keys, see the [Creating keys](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/create-keys.html) in the Amazon Web Services Payment Cryptography User Guide. The allowed combinations of PIN block format translations are guided by PCI. It is important to note that not all encrypted PIN block formats (example, format 1) require PAN (Primary Account Number) as input. And as such, PIN block format that requires PAN (example, formats 0,3,4) cannot be translated to a format (format 1) that does not require a PAN for generation. For information about valid keys for this operation, see [Understanding key attributes](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/keys-validattributes.html) and [Key types for specific data operations](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/crypto-ops-validkeys-ops.html) in the Amazon Web Services Payment Cryptography User Guide. Amazon Web Services Payment Cryptography currently supports ISO PIN block 4 translation for PIN block built using legacy PAN length. That is, PAN is the right most 12 digits excluding the check digits. Cross-account use: This operation can't be used across different Amazon Web Services accounts. Related operations:
    ///
    /// * [GeneratePinData]
    ///
    /// * [VerifyPinData]
    ///
    /// - Parameter input: [no documentation found] (Type: `TranslatePinDataInput`)
    ///
    /// - Returns: [no documentation found] (Type: `TranslatePinDataOutput`)
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You do not have sufficient access to perform this action.
    /// - `InternalServerException` : The request processing has failed because of an unknown error, exception, or failure.
    /// - `ResourceNotFoundException` : The request was denied due to an invalid resource error.
    /// - `ThrottlingException` : The request was denied due to request throttling.
    /// - `ValidationException` : The request was denied due to an invalid request error.
    public func translatePinData(input: TranslatePinDataInput) async throws -> TranslatePinDataOutput {
        let context = Smithy.ContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "translatePinData")
                      .withUnsignedPayloadTrait(value: false)
                      .withSmithyDefaultConfig(config)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withRequestChecksumCalculation(value: config.requestChecksumCalculation)
                      .withResponseChecksumValidation(value: config.responseChecksumValidation)
                      .withSigningName(value: "payment-cryptography")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        let builder = ClientRuntime.OrchestratorBuilder<TranslatePinDataInput, TranslatePinDataOutput, SmithyHTTPAPI.HTTPRequest, SmithyHTTPAPI.HTTPResponse>()
        config.interceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        config.httpInterceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        builder.interceptors.add(ClientRuntime.URLPathMiddleware<TranslatePinDataInput, TranslatePinDataOutput>(TranslatePinDataInput.urlPathProvider(_:)))
        builder.interceptors.add(ClientRuntime.URLHostMiddleware<TranslatePinDataInput, TranslatePinDataOutput>())
        builder.interceptors.add(ClientRuntime.ContentTypeMiddleware<TranslatePinDataInput, TranslatePinDataOutput>(contentType: "application/json"))
        builder.serialize(ClientRuntime.BodyMiddleware<TranslatePinDataInput, TranslatePinDataOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: TranslatePinDataInput.write(value:to:)))
        builder.interceptors.add(ClientRuntime.ContentLengthMiddleware<TranslatePinDataInput, TranslatePinDataOutput>())
        builder.deserialize(ClientRuntime.DeserializeMiddleware<TranslatePinDataOutput>(TranslatePinDataOutput.httpOutput(from:), TranslatePinDataOutputError.httpError(from:)))
        builder.interceptors.add(ClientRuntime.LoggerMiddleware<TranslatePinDataInput, TranslatePinDataOutput>(clientLogMode: config.clientLogMode))
        builder.clockSkewProvider(AWSClientRuntime.AWSClockSkewProvider.provider())
        builder.retryStrategy(SmithyRetries.DefaultRetryStrategy(options: config.retryStrategyOptions))
        builder.retryErrorInfoProvider(AWSClientRuntime.AWSRetryErrorInfoProvider.errorInfo(for:))
        builder.applySigner(ClientRuntime.SignerMiddleware<TranslatePinDataOutput>())
        let configuredEndpoint = try config.endpoint ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.configuredEndpoint("Payment Cryptography Data", config.ignoreConfiguredEndpointURLs)
        let endpointParamsBlock = { [config] (context: Smithy.Context) in
            EndpointParams(endpoint: configuredEndpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        }
        builder.applyEndpoint(AWSClientRuntime.AWSEndpointResolverMiddleware<TranslatePinDataOutput, EndpointParams>(paramsBlock: endpointParamsBlock, resolverBlock: { [config] in try config.endpointResolver.resolve(params: $0) }))
        builder.selectAuthScheme(ClientRuntime.AuthSchemeMiddleware<TranslatePinDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkInvocationIdMiddleware<TranslatePinDataInput, TranslatePinDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkRequestMiddleware<TranslatePinDataInput, TranslatePinDataOutput>(maxRetries: config.retryStrategyOptions.maxRetriesBase))
        builder.interceptors.add(AWSClientRuntime.UserAgentMiddleware<TranslatePinDataInput, TranslatePinDataOutput>(serviceID: serviceName, version: PaymentCryptographyDataClient.version, config: config))
        var metricsAttributes = Smithy.Attributes()
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.service, value: "PaymentCryptographyData")
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.method, value: "TranslatePinData")
        let op = builder.attributes(context)
            .telemetry(ClientRuntime.OrchestratorTelemetry(
                telemetryProvider: config.telemetryProvider,
                metricsAttributes: metricsAttributes,
                meterScope: serviceName,
                tracerScope: serviceName
            ))
            .executeRequest(client)
            .build()
        return try await op.execute(input: input)
    }

    /// Performs the `VerifyAuthRequestCryptogram` operation on the `PaymentCryptographyData` service.
    ///
    /// Verifies Authorization Request Cryptogram (ARQC) for a EMV chip payment card authorization. For more information, see [Verify auth request cryptogram](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/data-operations.verifyauthrequestcryptogram.html) in the Amazon Web Services Payment Cryptography User Guide. ARQC generation is done outside of Amazon Web Services Payment Cryptography and is typically generated on a point of sale terminal for an EMV chip card to obtain payment authorization during transaction time. For ARQC verification, you must first import the ARQC generated outside of Amazon Web Services Payment Cryptography by calling [ImportKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_ImportKey.html). This operation uses the imported ARQC and an major encryption key (DUKPT) created by calling [CreateKey](https://docs.aws.amazon.com/payment-cryptography/latest/APIReference/API_CreateKey.html) to either provide a boolean ARQC verification result or provide an APRC (Authorization Response Cryptogram) response using Method 1 or Method 2. The ARPC_METHOD_1 uses AuthResponseCode to generate ARPC and ARPC_METHOD_2 uses CardStatusUpdate to generate ARPC. For information about valid keys for this operation, see [Understanding key attributes](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/keys-validattributes.html) and [Key types for specific data operations](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/crypto-ops-validkeys-ops.html) in the Amazon Web Services Payment Cryptography User Guide. Cross-account use: This operation can't be used across different Amazon Web Services accounts. Related operations:
    ///
    /// * [VerifyCardValidationData]
    ///
    /// * [VerifyPinData]
    ///
    /// - Parameter input: [no documentation found] (Type: `VerifyAuthRequestCryptogramInput`)
    ///
    /// - Returns: [no documentation found] (Type: `VerifyAuthRequestCryptogramOutput`)
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You do not have sufficient access to perform this action.
    /// - `InternalServerException` : The request processing has failed because of an unknown error, exception, or failure.
    /// - `ResourceNotFoundException` : The request was denied due to an invalid resource error.
    /// - `ThrottlingException` : The request was denied due to request throttling.
    /// - `ValidationException` : The request was denied due to an invalid request error.
    /// - `VerificationFailedException` : This request failed verification.
    public func verifyAuthRequestCryptogram(input: VerifyAuthRequestCryptogramInput) async throws -> VerifyAuthRequestCryptogramOutput {
        let context = Smithy.ContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "verifyAuthRequestCryptogram")
                      .withUnsignedPayloadTrait(value: false)
                      .withSmithyDefaultConfig(config)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withRequestChecksumCalculation(value: config.requestChecksumCalculation)
                      .withResponseChecksumValidation(value: config.responseChecksumValidation)
                      .withSigningName(value: "payment-cryptography")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        let builder = ClientRuntime.OrchestratorBuilder<VerifyAuthRequestCryptogramInput, VerifyAuthRequestCryptogramOutput, SmithyHTTPAPI.HTTPRequest, SmithyHTTPAPI.HTTPResponse>()
        config.interceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        config.httpInterceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        builder.interceptors.add(ClientRuntime.URLPathMiddleware<VerifyAuthRequestCryptogramInput, VerifyAuthRequestCryptogramOutput>(VerifyAuthRequestCryptogramInput.urlPathProvider(_:)))
        builder.interceptors.add(ClientRuntime.URLHostMiddleware<VerifyAuthRequestCryptogramInput, VerifyAuthRequestCryptogramOutput>())
        builder.interceptors.add(ClientRuntime.ContentTypeMiddleware<VerifyAuthRequestCryptogramInput, VerifyAuthRequestCryptogramOutput>(contentType: "application/json"))
        builder.serialize(ClientRuntime.BodyMiddleware<VerifyAuthRequestCryptogramInput, VerifyAuthRequestCryptogramOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: VerifyAuthRequestCryptogramInput.write(value:to:)))
        builder.interceptors.add(ClientRuntime.ContentLengthMiddleware<VerifyAuthRequestCryptogramInput, VerifyAuthRequestCryptogramOutput>())
        builder.deserialize(ClientRuntime.DeserializeMiddleware<VerifyAuthRequestCryptogramOutput>(VerifyAuthRequestCryptogramOutput.httpOutput(from:), VerifyAuthRequestCryptogramOutputError.httpError(from:)))
        builder.interceptors.add(ClientRuntime.LoggerMiddleware<VerifyAuthRequestCryptogramInput, VerifyAuthRequestCryptogramOutput>(clientLogMode: config.clientLogMode))
        builder.clockSkewProvider(AWSClientRuntime.AWSClockSkewProvider.provider())
        builder.retryStrategy(SmithyRetries.DefaultRetryStrategy(options: config.retryStrategyOptions))
        builder.retryErrorInfoProvider(AWSClientRuntime.AWSRetryErrorInfoProvider.errorInfo(for:))
        builder.applySigner(ClientRuntime.SignerMiddleware<VerifyAuthRequestCryptogramOutput>())
        let configuredEndpoint = try config.endpoint ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.configuredEndpoint("Payment Cryptography Data", config.ignoreConfiguredEndpointURLs)
        let endpointParamsBlock = { [config] (context: Smithy.Context) in
            EndpointParams(endpoint: configuredEndpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        }
        builder.applyEndpoint(AWSClientRuntime.AWSEndpointResolverMiddleware<VerifyAuthRequestCryptogramOutput, EndpointParams>(paramsBlock: endpointParamsBlock, resolverBlock: { [config] in try config.endpointResolver.resolve(params: $0) }))
        builder.selectAuthScheme(ClientRuntime.AuthSchemeMiddleware<VerifyAuthRequestCryptogramOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkInvocationIdMiddleware<VerifyAuthRequestCryptogramInput, VerifyAuthRequestCryptogramOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkRequestMiddleware<VerifyAuthRequestCryptogramInput, VerifyAuthRequestCryptogramOutput>(maxRetries: config.retryStrategyOptions.maxRetriesBase))
        builder.interceptors.add(AWSClientRuntime.UserAgentMiddleware<VerifyAuthRequestCryptogramInput, VerifyAuthRequestCryptogramOutput>(serviceID: serviceName, version: PaymentCryptographyDataClient.version, config: config))
        var metricsAttributes = Smithy.Attributes()
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.service, value: "PaymentCryptographyData")
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.method, value: "VerifyAuthRequestCryptogram")
        let op = builder.attributes(context)
            .telemetry(ClientRuntime.OrchestratorTelemetry(
                telemetryProvider: config.telemetryProvider,
                metricsAttributes: metricsAttributes,
                meterScope: serviceName,
                tracerScope: serviceName
            ))
            .executeRequest(client)
            .build()
        return try await op.execute(input: input)
    }

    /// Performs the `VerifyCardValidationData` operation on the `PaymentCryptographyData` service.
    ///
    /// Verifies card-related validation data using algorithms such as Card Verification Values (CVV/CVV2), Dynamic Card Verification Values (dCVV/dCVV2) and Card Security Codes (CSC). For more information, see [Verify card data](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/verify-card-data.html) in the Amazon Web Services Payment Cryptography User Guide. This operation validates the CVV or CSC codes that is printed on a payment credit or debit card during card payment transaction. The input values are typically provided as part of an inbound transaction to an issuer or supporting platform partner. Amazon Web Services Payment Cryptography uses CVV or CSC, PAN (Primary Account Number) and expiration date of the card to check its validity during transaction processing. In this operation, the CVK (Card Verification Key) encryption key for use with card data verification is same as the one in used for [GenerateCardValidationData]. For information about valid keys for this operation, see [Understanding key attributes](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/keys-validattributes.html) and [Key types for specific data operations](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/crypto-ops-validkeys-ops.html) in the Amazon Web Services Payment Cryptography User Guide. Cross-account use: This operation can't be used across different Amazon Web Services accounts. Related operations:
    ///
    /// * [GenerateCardValidationData]
    ///
    /// * [VerifyAuthRequestCryptogram]
    ///
    /// * [VerifyPinData]
    ///
    /// - Parameter input: [no documentation found] (Type: `VerifyCardValidationDataInput`)
    ///
    /// - Returns: [no documentation found] (Type: `VerifyCardValidationDataOutput`)
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You do not have sufficient access to perform this action.
    /// - `InternalServerException` : The request processing has failed because of an unknown error, exception, or failure.
    /// - `ResourceNotFoundException` : The request was denied due to an invalid resource error.
    /// - `ThrottlingException` : The request was denied due to request throttling.
    /// - `ValidationException` : The request was denied due to an invalid request error.
    /// - `VerificationFailedException` : This request failed verification.
    public func verifyCardValidationData(input: VerifyCardValidationDataInput) async throws -> VerifyCardValidationDataOutput {
        let context = Smithy.ContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "verifyCardValidationData")
                      .withUnsignedPayloadTrait(value: false)
                      .withSmithyDefaultConfig(config)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withRequestChecksumCalculation(value: config.requestChecksumCalculation)
                      .withResponseChecksumValidation(value: config.responseChecksumValidation)
                      .withSigningName(value: "payment-cryptography")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        let builder = ClientRuntime.OrchestratorBuilder<VerifyCardValidationDataInput, VerifyCardValidationDataOutput, SmithyHTTPAPI.HTTPRequest, SmithyHTTPAPI.HTTPResponse>()
        config.interceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        config.httpInterceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        builder.interceptors.add(ClientRuntime.URLPathMiddleware<VerifyCardValidationDataInput, VerifyCardValidationDataOutput>(VerifyCardValidationDataInput.urlPathProvider(_:)))
        builder.interceptors.add(ClientRuntime.URLHostMiddleware<VerifyCardValidationDataInput, VerifyCardValidationDataOutput>())
        builder.interceptors.add(ClientRuntime.ContentTypeMiddleware<VerifyCardValidationDataInput, VerifyCardValidationDataOutput>(contentType: "application/json"))
        builder.serialize(ClientRuntime.BodyMiddleware<VerifyCardValidationDataInput, VerifyCardValidationDataOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: VerifyCardValidationDataInput.write(value:to:)))
        builder.interceptors.add(ClientRuntime.ContentLengthMiddleware<VerifyCardValidationDataInput, VerifyCardValidationDataOutput>())
        builder.deserialize(ClientRuntime.DeserializeMiddleware<VerifyCardValidationDataOutput>(VerifyCardValidationDataOutput.httpOutput(from:), VerifyCardValidationDataOutputError.httpError(from:)))
        builder.interceptors.add(ClientRuntime.LoggerMiddleware<VerifyCardValidationDataInput, VerifyCardValidationDataOutput>(clientLogMode: config.clientLogMode))
        builder.clockSkewProvider(AWSClientRuntime.AWSClockSkewProvider.provider())
        builder.retryStrategy(SmithyRetries.DefaultRetryStrategy(options: config.retryStrategyOptions))
        builder.retryErrorInfoProvider(AWSClientRuntime.AWSRetryErrorInfoProvider.errorInfo(for:))
        builder.applySigner(ClientRuntime.SignerMiddleware<VerifyCardValidationDataOutput>())
        let configuredEndpoint = try config.endpoint ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.configuredEndpoint("Payment Cryptography Data", config.ignoreConfiguredEndpointURLs)
        let endpointParamsBlock = { [config] (context: Smithy.Context) in
            EndpointParams(endpoint: configuredEndpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        }
        builder.applyEndpoint(AWSClientRuntime.AWSEndpointResolverMiddleware<VerifyCardValidationDataOutput, EndpointParams>(paramsBlock: endpointParamsBlock, resolverBlock: { [config] in try config.endpointResolver.resolve(params: $0) }))
        builder.selectAuthScheme(ClientRuntime.AuthSchemeMiddleware<VerifyCardValidationDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkInvocationIdMiddleware<VerifyCardValidationDataInput, VerifyCardValidationDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkRequestMiddleware<VerifyCardValidationDataInput, VerifyCardValidationDataOutput>(maxRetries: config.retryStrategyOptions.maxRetriesBase))
        builder.interceptors.add(AWSClientRuntime.UserAgentMiddleware<VerifyCardValidationDataInput, VerifyCardValidationDataOutput>(serviceID: serviceName, version: PaymentCryptographyDataClient.version, config: config))
        var metricsAttributes = Smithy.Attributes()
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.service, value: "PaymentCryptographyData")
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.method, value: "VerifyCardValidationData")
        let op = builder.attributes(context)
            .telemetry(ClientRuntime.OrchestratorTelemetry(
                telemetryProvider: config.telemetryProvider,
                metricsAttributes: metricsAttributes,
                meterScope: serviceName,
                tracerScope: serviceName
            ))
            .executeRequest(client)
            .build()
        return try await op.execute(input: input)
    }

    /// Performs the `VerifyMac` operation on the `PaymentCryptographyData` service.
    ///
    /// Verifies a Message Authentication Code (MAC). You can use this operation to verify MAC for message data authentication such as . In this operation, you must use the same message data, secret encryption key and MAC algorithm that was used to generate MAC. You can use this operation to verify a DUPKT, CMAC, HMAC or EMV MAC by setting generation attributes and algorithm to the associated values. For information about valid keys for this operation, see [Understanding key attributes](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/keys-validattributes.html) and [Key types for specific data operations](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/crypto-ops-validkeys-ops.html) in the Amazon Web Services Payment Cryptography User Guide. Cross-account use: This operation can't be used across different Amazon Web Services accounts. Related operations:
    ///
    /// * [GenerateMac]
    ///
    /// - Parameter input: [no documentation found] (Type: `VerifyMacInput`)
    ///
    /// - Returns: [no documentation found] (Type: `VerifyMacOutput`)
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You do not have sufficient access to perform this action.
    /// - `InternalServerException` : The request processing has failed because of an unknown error, exception, or failure.
    /// - `ResourceNotFoundException` : The request was denied due to an invalid resource error.
    /// - `ThrottlingException` : The request was denied due to request throttling.
    /// - `ValidationException` : The request was denied due to an invalid request error.
    /// - `VerificationFailedException` : This request failed verification.
    public func verifyMac(input: VerifyMacInput) async throws -> VerifyMacOutput {
        let context = Smithy.ContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "verifyMac")
                      .withUnsignedPayloadTrait(value: false)
                      .withSmithyDefaultConfig(config)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withRequestChecksumCalculation(value: config.requestChecksumCalculation)
                      .withResponseChecksumValidation(value: config.responseChecksumValidation)
                      .withSigningName(value: "payment-cryptography")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        let builder = ClientRuntime.OrchestratorBuilder<VerifyMacInput, VerifyMacOutput, SmithyHTTPAPI.HTTPRequest, SmithyHTTPAPI.HTTPResponse>()
        config.interceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        config.httpInterceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        builder.interceptors.add(ClientRuntime.URLPathMiddleware<VerifyMacInput, VerifyMacOutput>(VerifyMacInput.urlPathProvider(_:)))
        builder.interceptors.add(ClientRuntime.URLHostMiddleware<VerifyMacInput, VerifyMacOutput>())
        builder.interceptors.add(ClientRuntime.ContentTypeMiddleware<VerifyMacInput, VerifyMacOutput>(contentType: "application/json"))
        builder.serialize(ClientRuntime.BodyMiddleware<VerifyMacInput, VerifyMacOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: VerifyMacInput.write(value:to:)))
        builder.interceptors.add(ClientRuntime.ContentLengthMiddleware<VerifyMacInput, VerifyMacOutput>())
        builder.deserialize(ClientRuntime.DeserializeMiddleware<VerifyMacOutput>(VerifyMacOutput.httpOutput(from:), VerifyMacOutputError.httpError(from:)))
        builder.interceptors.add(ClientRuntime.LoggerMiddleware<VerifyMacInput, VerifyMacOutput>(clientLogMode: config.clientLogMode))
        builder.clockSkewProvider(AWSClientRuntime.AWSClockSkewProvider.provider())
        builder.retryStrategy(SmithyRetries.DefaultRetryStrategy(options: config.retryStrategyOptions))
        builder.retryErrorInfoProvider(AWSClientRuntime.AWSRetryErrorInfoProvider.errorInfo(for:))
        builder.applySigner(ClientRuntime.SignerMiddleware<VerifyMacOutput>())
        let configuredEndpoint = try config.endpoint ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.configuredEndpoint("Payment Cryptography Data", config.ignoreConfiguredEndpointURLs)
        let endpointParamsBlock = { [config] (context: Smithy.Context) in
            EndpointParams(endpoint: configuredEndpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        }
        builder.applyEndpoint(AWSClientRuntime.AWSEndpointResolverMiddleware<VerifyMacOutput, EndpointParams>(paramsBlock: endpointParamsBlock, resolverBlock: { [config] in try config.endpointResolver.resolve(params: $0) }))
        builder.selectAuthScheme(ClientRuntime.AuthSchemeMiddleware<VerifyMacOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkInvocationIdMiddleware<VerifyMacInput, VerifyMacOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkRequestMiddleware<VerifyMacInput, VerifyMacOutput>(maxRetries: config.retryStrategyOptions.maxRetriesBase))
        builder.interceptors.add(AWSClientRuntime.UserAgentMiddleware<VerifyMacInput, VerifyMacOutput>(serviceID: serviceName, version: PaymentCryptographyDataClient.version, config: config))
        var metricsAttributes = Smithy.Attributes()
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.service, value: "PaymentCryptographyData")
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.method, value: "VerifyMac")
        let op = builder.attributes(context)
            .telemetry(ClientRuntime.OrchestratorTelemetry(
                telemetryProvider: config.telemetryProvider,
                metricsAttributes: metricsAttributes,
                meterScope: serviceName,
                tracerScope: serviceName
            ))
            .executeRequest(client)
            .build()
        return try await op.execute(input: input)
    }

    /// Performs the `VerifyPinData` operation on the `PaymentCryptographyData` service.
    ///
    /// Verifies pin-related data such as PIN and PIN Offset using algorithms including VISA PVV and IBM3624. For more information, see [Verify PIN data](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/verify-pin-data.html) in the Amazon Web Services Payment Cryptography User Guide. This operation verifies PIN data for user payment card. A card holder PIN data is never transmitted in clear to or from Amazon Web Services Payment Cryptography. This operation uses PIN Verification Key (PVK) for PIN or PIN Offset generation and then encrypts it using PIN Encryption Key (PEK) to create an EncryptedPinBlock for transmission from Amazon Web Services Payment Cryptography. For information about valid keys for this operation, see [Understanding key attributes](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/keys-validattributes.html) and [Key types for specific data operations](https://docs.aws.amazon.com/payment-cryptography/latest/userguide/crypto-ops-validkeys-ops.html) in the Amazon Web Services Payment Cryptography User Guide. Cross-account use: This operation can't be used across different Amazon Web Services accounts. Related operations:
    ///
    /// * [GeneratePinData]
    ///
    /// * [TranslatePinData]
    ///
    /// - Parameter input: [no documentation found] (Type: `VerifyPinDataInput`)
    ///
    /// - Returns: [no documentation found] (Type: `VerifyPinDataOutput`)
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You do not have sufficient access to perform this action.
    /// - `InternalServerException` : The request processing has failed because of an unknown error, exception, or failure.
    /// - `ResourceNotFoundException` : The request was denied due to an invalid resource error.
    /// - `ThrottlingException` : The request was denied due to request throttling.
    /// - `ValidationException` : The request was denied due to an invalid request error.
    /// - `VerificationFailedException` : This request failed verification.
    public func verifyPinData(input: VerifyPinDataInput) async throws -> VerifyPinDataOutput {
        let context = Smithy.ContextBuilder()
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "verifyPinData")
                      .withUnsignedPayloadTrait(value: false)
                      .withSmithyDefaultConfig(config)
                      .withIdentityResolver(value: config.awsCredentialIdentityResolver, schemeID: "aws.auth#sigv4a")
                      .withRegion(value: config.region)
                      .withRequestChecksumCalculation(value: config.requestChecksumCalculation)
                      .withResponseChecksumValidation(value: config.responseChecksumValidation)
                      .withSigningName(value: "payment-cryptography")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        let builder = ClientRuntime.OrchestratorBuilder<VerifyPinDataInput, VerifyPinDataOutput, SmithyHTTPAPI.HTTPRequest, SmithyHTTPAPI.HTTPResponse>()
        config.interceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        config.httpInterceptorProviders.forEach { provider in
            builder.interceptors.add(provider.create())
        }
        builder.interceptors.add(ClientRuntime.URLPathMiddleware<VerifyPinDataInput, VerifyPinDataOutput>(VerifyPinDataInput.urlPathProvider(_:)))
        builder.interceptors.add(ClientRuntime.URLHostMiddleware<VerifyPinDataInput, VerifyPinDataOutput>())
        builder.interceptors.add(ClientRuntime.ContentTypeMiddleware<VerifyPinDataInput, VerifyPinDataOutput>(contentType: "application/json"))
        builder.serialize(ClientRuntime.BodyMiddleware<VerifyPinDataInput, VerifyPinDataOutput, SmithyJSON.Writer>(rootNodeInfo: "", inputWritingClosure: VerifyPinDataInput.write(value:to:)))
        builder.interceptors.add(ClientRuntime.ContentLengthMiddleware<VerifyPinDataInput, VerifyPinDataOutput>())
        builder.deserialize(ClientRuntime.DeserializeMiddleware<VerifyPinDataOutput>(VerifyPinDataOutput.httpOutput(from:), VerifyPinDataOutputError.httpError(from:)))
        builder.interceptors.add(ClientRuntime.LoggerMiddleware<VerifyPinDataInput, VerifyPinDataOutput>(clientLogMode: config.clientLogMode))
        builder.clockSkewProvider(AWSClientRuntime.AWSClockSkewProvider.provider())
        builder.retryStrategy(SmithyRetries.DefaultRetryStrategy(options: config.retryStrategyOptions))
        builder.retryErrorInfoProvider(AWSClientRuntime.AWSRetryErrorInfoProvider.errorInfo(for:))
        builder.applySigner(ClientRuntime.SignerMiddleware<VerifyPinDataOutput>())
        let configuredEndpoint = try config.endpoint ?? AWSClientRuntime.AWSClientConfigDefaultsProvider.configuredEndpoint("Payment Cryptography Data", config.ignoreConfiguredEndpointURLs)
        let endpointParamsBlock = { [config] (context: Smithy.Context) in
            EndpointParams(endpoint: configuredEndpoint, region: config.region, useDualStack: config.useDualStack ?? false, useFIPS: config.useFIPS ?? false)
        }
        builder.applyEndpoint(AWSClientRuntime.AWSEndpointResolverMiddleware<VerifyPinDataOutput, EndpointParams>(paramsBlock: endpointParamsBlock, resolverBlock: { [config] in try config.endpointResolver.resolve(params: $0) }))
        builder.selectAuthScheme(ClientRuntime.AuthSchemeMiddleware<VerifyPinDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkInvocationIdMiddleware<VerifyPinDataInput, VerifyPinDataOutput>())
        builder.interceptors.add(AWSClientRuntime.AmzSdkRequestMiddleware<VerifyPinDataInput, VerifyPinDataOutput>(maxRetries: config.retryStrategyOptions.maxRetriesBase))
        builder.interceptors.add(AWSClientRuntime.UserAgentMiddleware<VerifyPinDataInput, VerifyPinDataOutput>(serviceID: serviceName, version: PaymentCryptographyDataClient.version, config: config))
        var metricsAttributes = Smithy.Attributes()
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.service, value: "PaymentCryptographyData")
        metricsAttributes.set(key: ClientRuntime.OrchestratorMetricsAttributesKeys.method, value: "VerifyPinData")
        let op = builder.attributes(context)
            .telemetry(ClientRuntime.OrchestratorTelemetry(
                telemetryProvider: config.telemetryProvider,
                metricsAttributes: metricsAttributes,
                meterScope: serviceName,
                tracerScope: serviceName
            ))
            .executeRequest(client)
            .build()
        return try await op.execute(input: input)
    }
}
