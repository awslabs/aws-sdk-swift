// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cardExpiryDate = "CardExpiryDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cardExpiryDate = self.cardExpiryDate {
            try encodeContainer.encode(cardExpiryDate, forKey: .cardExpiryDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cardExpiryDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cardExpiryDate)
        cardExpiryDate = cardExpiryDateDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.
    public struct AmexCardSecurityCodeVersion1: Swift.Equatable {
        /// The expiry date of a payment card.
        /// This member is required.
        public var cardExpiryDate: Swift.String?

        public init(
            cardExpiryDate: Swift.String? = nil
        )
        {
            self.cardExpiryDate = cardExpiryDate
        }
    }

}

extension PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cardExpiryDate = "CardExpiryDate"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cardExpiryDate = self.cardExpiryDate {
            try encodeContainer.encode(cardExpiryDate, forKey: .cardExpiryDate)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cardExpiryDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cardExpiryDate)
        cardExpiryDate = cardExpiryDateDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.
    public struct AmexCardSecurityCodeVersion2: Swift.Equatable {
        /// The expiry date of a payment card.
        /// This member is required.
        public var cardExpiryDate: Swift.String?
        /// The service code of the AMEX payment card. This is different from the Card Security Code (CSC).
        /// This member is required.
        public var serviceCode: Swift.String?

        public init(
            cardExpiryDate: Swift.String? = nil,
            serviceCode: Swift.String? = nil
        )
        {
            self.cardExpiryDate = cardExpiryDate
            self.serviceCode = serviceCode
        }
    }

}

extension PaymentCryptographyDataClientTypes.AsymmetricEncryptionAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case paddingType = "PaddingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let paddingType = self.paddingType {
            try encodeContainer.encode(paddingType.rawValue, forKey: .paddingType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let paddingTypeDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.PaddingType.self, forKey: .paddingType)
        paddingType = paddingTypeDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters for plaintext encryption using asymmetric keys.
    public struct AsymmetricEncryptionAttributes: Swift.Equatable {
        /// The padding to be included with the data.
        public var paddingType: PaymentCryptographyDataClientTypes.PaddingType?

        public init(
            paddingType: PaymentCryptographyDataClientTypes.PaddingType? = nil
        )
        {
            self.paddingType = paddingType
        }
    }

}

extension PaymentCryptographyDataClientTypes.CardGenerationAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amexcardsecuritycodeversion1 = "AmexCardSecurityCodeVersion1"
        case amexcardsecuritycodeversion2 = "AmexCardSecurityCodeVersion2"
        case cardholderverificationvalue = "CardHolderVerificationValue"
        case cardverificationvalue1 = "CardVerificationValue1"
        case cardverificationvalue2 = "CardVerificationValue2"
        case dynamiccardverificationcode = "DynamicCardVerificationCode"
        case dynamiccardverificationvalue = "DynamicCardVerificationValue"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .amexcardsecuritycodeversion1(amexcardsecuritycodeversion1):
                try container.encode(amexcardsecuritycodeversion1, forKey: .amexcardsecuritycodeversion1)
            case let .amexcardsecuritycodeversion2(amexcardsecuritycodeversion2):
                try container.encode(amexcardsecuritycodeversion2, forKey: .amexcardsecuritycodeversion2)
            case let .cardholderverificationvalue(cardholderverificationvalue):
                try container.encode(cardholderverificationvalue, forKey: .cardholderverificationvalue)
            case let .cardverificationvalue1(cardverificationvalue1):
                try container.encode(cardverificationvalue1, forKey: .cardverificationvalue1)
            case let .cardverificationvalue2(cardverificationvalue2):
                try container.encode(cardverificationvalue2, forKey: .cardverificationvalue2)
            case let .dynamiccardverificationcode(dynamiccardverificationcode):
                try container.encode(dynamiccardverificationcode, forKey: .dynamiccardverificationcode)
            case let .dynamiccardverificationvalue(dynamiccardverificationvalue):
                try container.encode(dynamiccardverificationvalue, forKey: .dynamiccardverificationvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let amexcardsecuritycodeversion1Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion1.self, forKey: .amexcardsecuritycodeversion1)
        if let amexcardsecuritycodeversion1 = amexcardsecuritycodeversion1Decoded {
            self = .amexcardsecuritycodeversion1(amexcardsecuritycodeversion1)
            return
        }
        let amexcardsecuritycodeversion2Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion2.self, forKey: .amexcardsecuritycodeversion2)
        if let amexcardsecuritycodeversion2 = amexcardsecuritycodeversion2Decoded {
            self = .amexcardsecuritycodeversion2(amexcardsecuritycodeversion2)
            return
        }
        let cardverificationvalue1Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.CardVerificationValue1.self, forKey: .cardverificationvalue1)
        if let cardverificationvalue1 = cardverificationvalue1Decoded {
            self = .cardverificationvalue1(cardverificationvalue1)
            return
        }
        let cardverificationvalue2Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.CardVerificationValue2.self, forKey: .cardverificationvalue2)
        if let cardverificationvalue2 = cardverificationvalue2Decoded {
            self = .cardverificationvalue2(cardverificationvalue2)
            return
        }
        let cardholderverificationvalueDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.CardHolderVerificationValue.self, forKey: .cardholderverificationvalue)
        if let cardholderverificationvalue = cardholderverificationvalueDecoded {
            self = .cardholderverificationvalue(cardholderverificationvalue)
            return
        }
        let dynamiccardverificationcodeDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.DynamicCardVerificationCode.self, forKey: .dynamiccardverificationcode)
        if let dynamiccardverificationcode = dynamiccardverificationcodeDecoded {
            self = .dynamiccardverificationcode(dynamiccardverificationcode)
            return
        }
        let dynamiccardverificationvalueDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.DynamicCardVerificationValue.self, forKey: .dynamiccardverificationvalue)
        if let dynamiccardverificationvalue = dynamiccardverificationvalueDecoded {
            self = .dynamiccardverificationvalue(dynamiccardverificationvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Card data parameters that are required to generate Card Verification Values (CVV/CVV2), Dynamic Card Verification Values (dCVV/dCVV2), or Card Security Codes (CSC).
    public enum CardGenerationAttributes: Swift.Equatable {
        /// Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.
        case amexcardsecuritycodeversion1(PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion1)
        /// Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.
        case amexcardsecuritycodeversion2(PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion2)
        /// Card data parameters that are required to generate Card Verification Value (CVV) for the payment card.
        case cardverificationvalue1(PaymentCryptographyDataClientTypes.CardVerificationValue1)
        /// Card data parameters that are required to generate Card Verification Value (CVV2) for the payment card.
        case cardverificationvalue2(PaymentCryptographyDataClientTypes.CardVerificationValue2)
        /// Card data parameters that are required to generate a cardholder verification value for the payment card.
        case cardholderverificationvalue(PaymentCryptographyDataClientTypes.CardHolderVerificationValue)
        /// Card data parameters that are required to generate CDynamic Card Verification Code (dCVC) for the payment card.
        case dynamiccardverificationcode(PaymentCryptographyDataClientTypes.DynamicCardVerificationCode)
        /// Card data parameters that are required to generate CDynamic Card Verification Value (dCVV) for the payment card.
        case dynamiccardverificationvalue(PaymentCryptographyDataClientTypes.DynamicCardVerificationValue)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes.CardHolderVerificationValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationTransactionCounter = "ApplicationTransactionCounter"
        case panSequenceNumber = "PanSequenceNumber"
        case unpredictableNumber = "UnpredictableNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationTransactionCounter = self.applicationTransactionCounter {
            try encodeContainer.encode(applicationTransactionCounter, forKey: .applicationTransactionCounter)
        }
        if let panSequenceNumber = self.panSequenceNumber {
            try encodeContainer.encode(panSequenceNumber, forKey: .panSequenceNumber)
        }
        if let unpredictableNumber = self.unpredictableNumber {
            try encodeContainer.encode(unpredictableNumber, forKey: .unpredictableNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unpredictableNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unpredictableNumber)
        unpredictableNumber = unpredictableNumberDecoded
        let panSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .panSequenceNumber)
        panSequenceNumber = panSequenceNumberDecoded
        let applicationTransactionCounterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationTransactionCounter)
        applicationTransactionCounter = applicationTransactionCounterDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Card data parameters that are required to generate a cardholder verification value for the payment card.
    public struct CardHolderVerificationValue: Swift.Equatable {
        /// The transaction counter value that comes from a point of sale terminal.
        /// This member is required.
        public var applicationTransactionCounter: Swift.String?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// A random number generated by the issuer.
        /// This member is required.
        public var unpredictableNumber: Swift.String?

        public init(
            applicationTransactionCounter: Swift.String? = nil,
            panSequenceNumber: Swift.String? = nil,
            unpredictableNumber: Swift.String? = nil
        )
        {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.unpredictableNumber = unpredictableNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.CardVerificationAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amexcardsecuritycodeversion1 = "AmexCardSecurityCodeVersion1"
        case amexcardsecuritycodeversion2 = "AmexCardSecurityCodeVersion2"
        case cardholderverificationvalue = "CardHolderVerificationValue"
        case cardverificationvalue1 = "CardVerificationValue1"
        case cardverificationvalue2 = "CardVerificationValue2"
        case discoverdynamiccardverificationcode = "DiscoverDynamicCardVerificationCode"
        case dynamiccardverificationcode = "DynamicCardVerificationCode"
        case dynamiccardverificationvalue = "DynamicCardVerificationValue"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .amexcardsecuritycodeversion1(amexcardsecuritycodeversion1):
                try container.encode(amexcardsecuritycodeversion1, forKey: .amexcardsecuritycodeversion1)
            case let .amexcardsecuritycodeversion2(amexcardsecuritycodeversion2):
                try container.encode(amexcardsecuritycodeversion2, forKey: .amexcardsecuritycodeversion2)
            case let .cardholderverificationvalue(cardholderverificationvalue):
                try container.encode(cardholderverificationvalue, forKey: .cardholderverificationvalue)
            case let .cardverificationvalue1(cardverificationvalue1):
                try container.encode(cardverificationvalue1, forKey: .cardverificationvalue1)
            case let .cardverificationvalue2(cardverificationvalue2):
                try container.encode(cardverificationvalue2, forKey: .cardverificationvalue2)
            case let .discoverdynamiccardverificationcode(discoverdynamiccardverificationcode):
                try container.encode(discoverdynamiccardverificationcode, forKey: .discoverdynamiccardverificationcode)
            case let .dynamiccardverificationcode(dynamiccardverificationcode):
                try container.encode(dynamiccardverificationcode, forKey: .dynamiccardverificationcode)
            case let .dynamiccardverificationvalue(dynamiccardverificationvalue):
                try container.encode(dynamiccardverificationvalue, forKey: .dynamiccardverificationvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let amexcardsecuritycodeversion1Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion1.self, forKey: .amexcardsecuritycodeversion1)
        if let amexcardsecuritycodeversion1 = amexcardsecuritycodeversion1Decoded {
            self = .amexcardsecuritycodeversion1(amexcardsecuritycodeversion1)
            return
        }
        let amexcardsecuritycodeversion2Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion2.self, forKey: .amexcardsecuritycodeversion2)
        if let amexcardsecuritycodeversion2 = amexcardsecuritycodeversion2Decoded {
            self = .amexcardsecuritycodeversion2(amexcardsecuritycodeversion2)
            return
        }
        let cardverificationvalue1Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.CardVerificationValue1.self, forKey: .cardverificationvalue1)
        if let cardverificationvalue1 = cardverificationvalue1Decoded {
            self = .cardverificationvalue1(cardverificationvalue1)
            return
        }
        let cardverificationvalue2Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.CardVerificationValue2.self, forKey: .cardverificationvalue2)
        if let cardverificationvalue2 = cardverificationvalue2Decoded {
            self = .cardverificationvalue2(cardverificationvalue2)
            return
        }
        let cardholderverificationvalueDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.CardHolderVerificationValue.self, forKey: .cardholderverificationvalue)
        if let cardholderverificationvalue = cardholderverificationvalueDecoded {
            self = .cardholderverificationvalue(cardholderverificationvalue)
            return
        }
        let dynamiccardverificationcodeDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.DynamicCardVerificationCode.self, forKey: .dynamiccardverificationcode)
        if let dynamiccardverificationcode = dynamiccardverificationcodeDecoded {
            self = .dynamiccardverificationcode(dynamiccardverificationcode)
            return
        }
        let dynamiccardverificationvalueDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.DynamicCardVerificationValue.self, forKey: .dynamiccardverificationvalue)
        if let dynamiccardverificationvalue = dynamiccardverificationvalueDecoded {
            self = .dynamiccardverificationvalue(dynamiccardverificationvalue)
            return
        }
        let discoverdynamiccardverificationcodeDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.DiscoverDynamicCardVerificationCode.self, forKey: .discoverdynamiccardverificationcode)
        if let discoverdynamiccardverificationcode = discoverdynamiccardverificationcodeDecoded {
            self = .discoverdynamiccardverificationcode(discoverdynamiccardverificationcode)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Card data parameters that are requried to verify Card Verification Values (CVV/CVV2), Dynamic Card Verification Values (dCVV/dCVV2), or Card Security Codes (CSC).
    public enum CardVerificationAttributes: Swift.Equatable {
        /// Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.
        case amexcardsecuritycodeversion1(PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion1)
        /// Card data parameters that are required to verify a Card Security Code (CSC2) for an AMEX payment card.
        case amexcardsecuritycodeversion2(PaymentCryptographyDataClientTypes.AmexCardSecurityCodeVersion2)
        /// Card data parameters that are required to verify Card Verification Value (CVV) for the payment card.
        case cardverificationvalue1(PaymentCryptographyDataClientTypes.CardVerificationValue1)
        /// Card data parameters that are required to verify Card Verification Value (CVV2) for the payment card.
        case cardverificationvalue2(PaymentCryptographyDataClientTypes.CardVerificationValue2)
        /// Card data parameters that are required to verify a cardholder verification value for the payment card.
        case cardholderverificationvalue(PaymentCryptographyDataClientTypes.CardHolderVerificationValue)
        /// Card data parameters that are required to verify CDynamic Card Verification Code (dCVC) for the payment card.
        case dynamiccardverificationcode(PaymentCryptographyDataClientTypes.DynamicCardVerificationCode)
        /// Card data parameters that are required to verify CDynamic Card Verification Value (dCVV) for the payment card.
        case dynamiccardverificationvalue(PaymentCryptographyDataClientTypes.DynamicCardVerificationValue)
        /// Card data parameters that are required to verify CDynamic Card Verification Code (dCVC) for the payment card.
        case discoverdynamiccardverificationcode(PaymentCryptographyDataClientTypes.DiscoverDynamicCardVerificationCode)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes.CardVerificationValue1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cardExpiryDate = "CardExpiryDate"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cardExpiryDate = self.cardExpiryDate {
            try encodeContainer.encode(cardExpiryDate, forKey: .cardExpiryDate)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cardExpiryDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cardExpiryDate)
        cardExpiryDate = cardExpiryDateDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Card data parameters that are required to verify CVV (Card Verification Value) for the payment card.
    public struct CardVerificationValue1: Swift.Equatable {
        /// The expiry date of a payment card.
        /// This member is required.
        public var cardExpiryDate: Swift.String?
        /// The service code of the payment card. This is different from Card Security Code (CSC).
        /// This member is required.
        public var serviceCode: Swift.String?

        public init(
            cardExpiryDate: Swift.String? = nil,
            serviceCode: Swift.String? = nil
        )
        {
            self.cardExpiryDate = cardExpiryDate
            self.serviceCode = serviceCode
        }
    }

}

extension PaymentCryptographyDataClientTypes.CardVerificationValue2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cardExpiryDate = "CardExpiryDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cardExpiryDate = self.cardExpiryDate {
            try encodeContainer.encode(cardExpiryDate, forKey: .cardExpiryDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cardExpiryDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cardExpiryDate)
        cardExpiryDate = cardExpiryDateDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Card data parameters that are required to verify Card Verification Value (CVV2) for the payment card.
    public struct CardVerificationValue2: Swift.Equatable {
        /// The expiry date of a payment card.
        /// This member is required.
        public var cardExpiryDate: Swift.String?

        public init(
            cardExpiryDate: Swift.String? = nil
        )
        {
            self.cardExpiryDate = cardExpiryDate
        }
    }

}

extension PaymentCryptographyDataClientTypes.CryptogramAuthResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arpcmethod1 = "ArpcMethod1"
        case arpcmethod2 = "ArpcMethod2"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arpcmethod1(arpcmethod1):
                try container.encode(arpcmethod1, forKey: .arpcmethod1)
            case let .arpcmethod2(arpcmethod2):
                try container.encode(arpcmethod2, forKey: .arpcmethod2)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let arpcmethod1Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod1.self, forKey: .arpcmethod1)
        if let arpcmethod1 = arpcmethod1Decoded {
            self = .arpcmethod1(arpcmethod1)
            return
        }
        let arpcmethod2Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod2.self, forKey: .arpcmethod2)
        if let arpcmethod2 = arpcmethod2Decoded {
            self = .arpcmethod2(arpcmethod2)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for Authorization Response Cryptogram (ARPC) generation after Authorization Request Cryptogram (ARQC) verification is successful.
    public enum CryptogramAuthResponse: Swift.Equatable {
        /// Parameters that are required for ARPC response generation using method1 after ARQC verification is successful.
        case arpcmethod1(PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod1)
        /// Parameters that are required for ARPC response generation using method2 after ARQC verification is successful.
        case arpcmethod2(PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod2)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authResponseCode = "AuthResponseCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authResponseCode = self.authResponseCode {
            try encodeContainer.encode(authResponseCode, forKey: .authResponseCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authResponseCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authResponseCode)
        authResponseCode = authResponseCodeDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for ARPC response generation using method1 after ARQC verification is successful.
    public struct CryptogramVerificationArpcMethod1: Swift.Equatable {
        /// The auth code used to calculate APRC after ARQC verification is successful. This is the same auth code used for ARQC generation outside of Amazon Web Services Payment Cryptography.
        /// This member is required.
        public var authResponseCode: Swift.String?

        public init(
            authResponseCode: Swift.String? = nil
        )
        {
            self.authResponseCode = authResponseCode
        }
    }

}

extension PaymentCryptographyDataClientTypes.CryptogramVerificationArpcMethod2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cardStatusUpdate = "CardStatusUpdate"
        case proprietaryAuthenticationData = "ProprietaryAuthenticationData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cardStatusUpdate = self.cardStatusUpdate {
            try encodeContainer.encode(cardStatusUpdate, forKey: .cardStatusUpdate)
        }
        if let proprietaryAuthenticationData = self.proprietaryAuthenticationData {
            try encodeContainer.encode(proprietaryAuthenticationData, forKey: .proprietaryAuthenticationData)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cardStatusUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cardStatusUpdate)
        cardStatusUpdate = cardStatusUpdateDecoded
        let proprietaryAuthenticationDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proprietaryAuthenticationData)
        proprietaryAuthenticationData = proprietaryAuthenticationDataDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for ARPC response generation using method2 after ARQC verification is successful.
    public struct CryptogramVerificationArpcMethod2: Swift.Equatable {
        /// The data indicating whether the issuer approves or declines an online transaction using an EMV chip card.
        /// This member is required.
        public var cardStatusUpdate: Swift.String?
        /// The proprietary authentication data used by issuer for communication during online transaction using an EMV chip card.
        public var proprietaryAuthenticationData: Swift.String?

        public init(
            cardStatusUpdate: Swift.String? = nil,
            proprietaryAuthenticationData: Swift.String? = nil
        )
        {
            self.cardStatusUpdate = cardStatusUpdate
            self.proprietaryAuthenticationData = proprietaryAuthenticationData
        }
    }

}

extension DecryptDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecryptDataInput(decryptionAttributes: \(Swift.String(describing: decryptionAttributes)), keyIdentifier: \(Swift.String(describing: keyIdentifier)), cipherText: \"CONTENT_REDACTED\")"}
}

extension DecryptDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cipherText = "CipherText"
        case decryptionAttributes = "DecryptionAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cipherText = self.cipherText {
            try encodeContainer.encode(cipherText, forKey: .cipherText)
        }
        if let decryptionAttributes = self.decryptionAttributes {
            try encodeContainer.encode(decryptionAttributes, forKey: .decryptionAttributes)
        }
    }
}

extension DecryptDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let keyIdentifier = keyIdentifier else {
            return nil
        }
        return "/keys/\(keyIdentifier.urlPercentEncoding())/decrypt"
    }
}

public struct DecryptDataInput: Swift.Equatable {
    /// The ciphertext to decrypt.
    /// This member is required.
    public var cipherText: Swift.String?
    /// The encryption key type and attributes for ciphertext decryption.
    /// This member is required.
    public var decryptionAttributes: PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes?
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for ciphertext decryption.
    /// This member is required.
    public var keyIdentifier: Swift.String?

    public init(
        cipherText: Swift.String? = nil,
        decryptionAttributes: PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes? = nil,
        keyIdentifier: Swift.String? = nil
    )
    {
        self.cipherText = cipherText
        self.decryptionAttributes = decryptionAttributes
        self.keyIdentifier = keyIdentifier
    }
}

struct DecryptDataInputBody: Swift.Equatable {
    let cipherText: Swift.String?
    let decryptionAttributes: PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes?
}

extension DecryptDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cipherText = "CipherText"
        case decryptionAttributes = "DecryptionAttributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cipherTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cipherText)
        cipherText = cipherTextDecoded
        let decryptionAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes.self, forKey: .decryptionAttributes)
        decryptionAttributes = decryptionAttributesDecoded
    }
}

extension DecryptDataOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecryptDataOutput(keyArn: \(Swift.String(describing: keyArn)), keyCheckValue: \(Swift.String(describing: keyCheckValue)), plainText: \"CONTENT_REDACTED\")"}
}

extension DecryptDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DecryptDataOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyArn = output.keyArn
            self.keyCheckValue = output.keyCheckValue
            self.plainText = output.plainText
        } else {
            self.keyArn = nil
            self.keyCheckValue = nil
            self.plainText = nil
        }
    }
}

public struct DecryptDataOutput: Swift.Equatable {
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for ciphertext decryption.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography calculates the KCV by using standard algorithms, typically by encrypting 8 or 16 bytes or "00" or "01" and then truncating the result to the first 3 bytes, or 6 hex digits, of the resulting cryptogram.
    /// This member is required.
    public var keyCheckValue: Swift.String?
    /// The decrypted plaintext data.
    /// This member is required.
    public var plainText: Swift.String?

    public init(
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil,
        plainText: Swift.String? = nil
    )
    {
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
        self.plainText = plainText
    }
}

struct DecryptDataOutputBody: Swift.Equatable {
    let keyArn: Swift.String?
    let keyCheckValue: Swift.String?
    let plainText: Swift.String?
}

extension DecryptDataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn = "KeyArn"
        case keyCheckValue = "KeyCheckValue"
        case plainText = "PlainText"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyCheckValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyCheckValue)
        keyCheckValue = keyCheckValueDecoded
        let plainTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .plainText)
        plainText = plainTextDecoded
    }
}

enum DecryptDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PaymentCryptographyDataClientTypes.DiscoverDynamicCardVerificationCode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationTransactionCounter = "ApplicationTransactionCounter"
        case cardExpiryDate = "CardExpiryDate"
        case unpredictableNumber = "UnpredictableNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationTransactionCounter = self.applicationTransactionCounter {
            try encodeContainer.encode(applicationTransactionCounter, forKey: .applicationTransactionCounter)
        }
        if let cardExpiryDate = self.cardExpiryDate {
            try encodeContainer.encode(cardExpiryDate, forKey: .cardExpiryDate)
        }
        if let unpredictableNumber = self.unpredictableNumber {
            try encodeContainer.encode(unpredictableNumber, forKey: .unpredictableNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cardExpiryDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cardExpiryDate)
        cardExpiryDate = cardExpiryDateDecoded
        let unpredictableNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unpredictableNumber)
        unpredictableNumber = unpredictableNumberDecoded
        let applicationTransactionCounterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationTransactionCounter)
        applicationTransactionCounter = applicationTransactionCounterDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify dCVC (Dynamic Card Verification Code).
    public struct DiscoverDynamicCardVerificationCode: Swift.Equatable {
        /// The transaction counter value that comes from the terminal.
        /// This member is required.
        public var applicationTransactionCounter: Swift.String?
        /// The expiry date of a payment card.
        /// This member is required.
        public var cardExpiryDate: Swift.String?
        /// A random number that is generated by the issuer.
        /// This member is required.
        public var unpredictableNumber: Swift.String?

        public init(
            applicationTransactionCounter: Swift.String? = nil,
            cardExpiryDate: Swift.String? = nil,
            unpredictableNumber: Swift.String? = nil
        )
        {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.cardExpiryDate = cardExpiryDate
            self.unpredictableNumber = unpredictableNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.DukptAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dukptDerivationType = "DukptDerivationType"
        case keySerialNumber = "KeySerialNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dukptDerivationType = self.dukptDerivationType {
            try encodeContainer.encode(dukptDerivationType.rawValue, forKey: .dukptDerivationType)
        }
        if let keySerialNumber = self.keySerialNumber {
            try encodeContainer.encode(keySerialNumber, forKey: .keySerialNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keySerialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keySerialNumber)
        keySerialNumber = keySerialNumberDecoded
        let dukptDerivationTypeDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.DukptDerivationType.self, forKey: .dukptDerivationType)
        dukptDerivationType = dukptDerivationTypeDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are used for Derived Unique Key Per Transaction (DUKPT) derivation algorithm.
    public struct DukptAttributes: Swift.Equatable {
        /// The key type derived using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use AES_128 as a derivation type for a BDK of AES_128 or TDES_2KEY.
        /// This member is required.
        public var dukptDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType?
        /// The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.
        /// This member is required.
        public var keySerialNumber: Swift.String?

        public init(
            dukptDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType? = nil,
            keySerialNumber: Swift.String? = nil
        )
        {
            self.dukptDerivationType = dukptDerivationType
            self.keySerialNumber = keySerialNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.DukptDerivationAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dukptKeyDerivationType = "DukptKeyDerivationType"
        case dukptKeyVariant = "DukptKeyVariant"
        case keySerialNumber = "KeySerialNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dukptKeyDerivationType = self.dukptKeyDerivationType {
            try encodeContainer.encode(dukptKeyDerivationType.rawValue, forKey: .dukptKeyDerivationType)
        }
        if let dukptKeyVariant = self.dukptKeyVariant {
            try encodeContainer.encode(dukptKeyVariant.rawValue, forKey: .dukptKeyVariant)
        }
        if let keySerialNumber = self.keySerialNumber {
            try encodeContainer.encode(keySerialNumber, forKey: .keySerialNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keySerialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keySerialNumber)
        keySerialNumber = keySerialNumberDecoded
        let dukptKeyDerivationTypeDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.DukptDerivationType.self, forKey: .dukptKeyDerivationType)
        dukptKeyDerivationType = dukptKeyDerivationTypeDecoded
        let dukptKeyVariantDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.DukptKeyVariant.self, forKey: .dukptKeyVariant)
        dukptKeyVariant = dukptKeyVariantDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters required for encryption or decryption of data using DUKPT.
    public struct DukptDerivationAttributes: Swift.Equatable {
        /// The key type derived using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use AES_128 as a derivation type for a BDK of AES_128 or TDES_2KEY
        public var dukptKeyDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType?
        /// The type of use of DUKPT, which can be for incoming data decryption, outgoing data encryption, or both.
        public var dukptKeyVariant: PaymentCryptographyDataClientTypes.DukptKeyVariant?
        /// The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.
        /// This member is required.
        public var keySerialNumber: Swift.String?

        public init(
            dukptKeyDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType? = nil,
            dukptKeyVariant: PaymentCryptographyDataClientTypes.DukptKeyVariant? = nil,
            keySerialNumber: Swift.String? = nil
        )
        {
            self.dukptKeyDerivationType = dukptKeyDerivationType
            self.dukptKeyVariant = dukptKeyVariant
            self.keySerialNumber = keySerialNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes {
    public enum DukptDerivationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes128
        case aes192
        case aes256
        case tdes2key
        case tdes3key
        case sdkUnknown(Swift.String)

        public static var allCases: [DukptDerivationType] {
            return [
                .aes128,
                .aes192,
                .aes256,
                .tdes2key,
                .tdes3key,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes128: return "AES_128"
            case .aes192: return "AES_192"
            case .aes256: return "AES_256"
            case .tdes2key: return "TDES_2KEY"
            case .tdes3key: return "TDES_3KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DukptDerivationType(rawValue: rawValue) ?? DukptDerivationType.sdkUnknown(rawValue)
        }
    }
}

extension PaymentCryptographyDataClientTypes.DukptEncryptionAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dukptKeyDerivationType = "DukptKeyDerivationType"
        case dukptKeyVariant = "DukptKeyVariant"
        case initializationVector = "InitializationVector"
        case keySerialNumber = "KeySerialNumber"
        case mode = "Mode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dukptKeyDerivationType = self.dukptKeyDerivationType {
            try encodeContainer.encode(dukptKeyDerivationType.rawValue, forKey: .dukptKeyDerivationType)
        }
        if let dukptKeyVariant = self.dukptKeyVariant {
            try encodeContainer.encode(dukptKeyVariant.rawValue, forKey: .dukptKeyVariant)
        }
        if let initializationVector = self.initializationVector {
            try encodeContainer.encode(initializationVector, forKey: .initializationVector)
        }
        if let keySerialNumber = self.keySerialNumber {
            try encodeContainer.encode(keySerialNumber, forKey: .keySerialNumber)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keySerialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keySerialNumber)
        keySerialNumber = keySerialNumberDecoded
        let modeDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.DukptEncryptionMode.self, forKey: .mode)
        mode = modeDecoded
        let dukptKeyDerivationTypeDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.DukptDerivationType.self, forKey: .dukptKeyDerivationType)
        dukptKeyDerivationType = dukptKeyDerivationTypeDecoded
        let dukptKeyVariantDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.DukptKeyVariant.self, forKey: .dukptKeyVariant)
        dukptKeyVariant = dukptKeyVariantDecoded
        let initializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initializationVector)
        initializationVector = initializationVectorDecoded
    }
}

extension PaymentCryptographyDataClientTypes.DukptEncryptionAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DukptEncryptionAttributes(dukptKeyDerivationType: \(Swift.String(describing: dukptKeyDerivationType)), dukptKeyVariant: \(Swift.String(describing: dukptKeyVariant)), keySerialNumber: \(Swift.String(describing: keySerialNumber)), mode: \(Swift.String(describing: mode)), initializationVector: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to encrypt plaintext data using DUKPT.
    public struct DukptEncryptionAttributes: Swift.Equatable {
        /// The key type encrypted using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use AES_128 as a derivation type for a BDK of AES_128 or TDES_2KEY
        public var dukptKeyDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType?
        /// The type of use of DUKPT, which can be incoming data decryption, outgoing data encryption, or both.
        public var dukptKeyVariant: PaymentCryptographyDataClientTypes.DukptKeyVariant?
        /// An input to cryptographic primitive used to provide the intial state. Typically the InitializationVector must have a random or psuedo-random value, but sometimes it only needs to be unpredictable or unique. If you don't provide a value, Amazon Web Services Payment Cryptography generates a random value.
        public var initializationVector: Swift.String?
        /// The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.
        /// This member is required.
        public var keySerialNumber: Swift.String?
        /// The block cipher mode of operation. Block ciphers are designed to encrypt a block of data of fixed size, for example, 128 bits. The size of the input block is usually same as the size of the encrypted output block, while the key length can be different. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block. The default is CBC.
        public var mode: PaymentCryptographyDataClientTypes.DukptEncryptionMode?

        public init(
            dukptKeyDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType? = nil,
            dukptKeyVariant: PaymentCryptographyDataClientTypes.DukptKeyVariant? = nil,
            initializationVector: Swift.String? = nil,
            keySerialNumber: Swift.String? = nil,
            mode: PaymentCryptographyDataClientTypes.DukptEncryptionMode? = nil
        )
        {
            self.dukptKeyDerivationType = dukptKeyDerivationType
            self.dukptKeyVariant = dukptKeyVariant
            self.initializationVector = initializationVector
            self.keySerialNumber = keySerialNumber
            self.mode = mode
        }
    }

}

extension PaymentCryptographyDataClientTypes {
    public enum DukptEncryptionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cbc
        case ecb
        case sdkUnknown(Swift.String)

        public static var allCases: [DukptEncryptionMode] {
            return [
                .cbc,
                .ecb,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cbc: return "CBC"
            case .ecb: return "ECB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DukptEncryptionMode(rawValue: rawValue) ?? DukptEncryptionMode.sdkUnknown(rawValue)
        }
    }
}

extension PaymentCryptographyDataClientTypes {
    public enum DukptKeyVariant: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bidirectional
        case request
        case response
        case sdkUnknown(Swift.String)

        public static var allCases: [DukptKeyVariant] {
            return [
                .bidirectional,
                .request,
                .response,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bidirectional: return "BIDIRECTIONAL"
            case .request: return "REQUEST"
            case .response: return "RESPONSE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DukptKeyVariant(rawValue: rawValue) ?? DukptKeyVariant.sdkUnknown(rawValue)
        }
    }
}

extension PaymentCryptographyDataClientTypes.DynamicCardVerificationCode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationTransactionCounter = "ApplicationTransactionCounter"
        case panSequenceNumber = "PanSequenceNumber"
        case trackData = "TrackData"
        case unpredictableNumber = "UnpredictableNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationTransactionCounter = self.applicationTransactionCounter {
            try encodeContainer.encode(applicationTransactionCounter, forKey: .applicationTransactionCounter)
        }
        if let panSequenceNumber = self.panSequenceNumber {
            try encodeContainer.encode(panSequenceNumber, forKey: .panSequenceNumber)
        }
        if let trackData = self.trackData {
            try encodeContainer.encode(trackData, forKey: .trackData)
        }
        if let unpredictableNumber = self.unpredictableNumber {
            try encodeContainer.encode(unpredictableNumber, forKey: .unpredictableNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unpredictableNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unpredictableNumber)
        unpredictableNumber = unpredictableNumberDecoded
        let panSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .panSequenceNumber)
        panSequenceNumber = panSequenceNumberDecoded
        let applicationTransactionCounterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationTransactionCounter)
        applicationTransactionCounter = applicationTransactionCounterDecoded
        let trackDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackData)
        trackData = trackDataDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Dynamic Card Verification Value (dCVV).
    public struct DynamicCardVerificationCode: Swift.Equatable {
        /// The transaction counter value that comes from the terminal.
        /// This member is required.
        public var applicationTransactionCounter: Swift.String?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The data on the two tracks of magnetic cards used for financial transactions. This includes the cardholder name, PAN, expiration date, bank ID (BIN) and several other numbers the issuing bank uses to validate the data received.
        /// This member is required.
        public var trackData: Swift.String?
        /// A random number generated by the issuer.
        /// This member is required.
        public var unpredictableNumber: Swift.String?

        public init(
            applicationTransactionCounter: Swift.String? = nil,
            panSequenceNumber: Swift.String? = nil,
            trackData: Swift.String? = nil,
            unpredictableNumber: Swift.String? = nil
        )
        {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.trackData = trackData
            self.unpredictableNumber = unpredictableNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.DynamicCardVerificationValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationTransactionCounter = "ApplicationTransactionCounter"
        case cardExpiryDate = "CardExpiryDate"
        case panSequenceNumber = "PanSequenceNumber"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationTransactionCounter = self.applicationTransactionCounter {
            try encodeContainer.encode(applicationTransactionCounter, forKey: .applicationTransactionCounter)
        }
        if let cardExpiryDate = self.cardExpiryDate {
            try encodeContainer.encode(cardExpiryDate, forKey: .cardExpiryDate)
        }
        if let panSequenceNumber = self.panSequenceNumber {
            try encodeContainer.encode(panSequenceNumber, forKey: .panSequenceNumber)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let panSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .panSequenceNumber)
        panSequenceNumber = panSequenceNumberDecoded
        let cardExpiryDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cardExpiryDate)
        cardExpiryDate = cardExpiryDateDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let applicationTransactionCounterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationTransactionCounter)
        applicationTransactionCounter = applicationTransactionCounterDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Dynamic Card Verification Value (dCVV).
    public struct DynamicCardVerificationValue: Swift.Equatable {
        /// The transaction counter value that comes from the terminal.
        /// This member is required.
        public var applicationTransactionCounter: Swift.String?
        /// The expiry date of a payment card.
        /// This member is required.
        public var cardExpiryDate: Swift.String?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The service code of the payment card. This is different from Card Security Code (CSC).
        /// This member is required.
        public var serviceCode: Swift.String?

        public init(
            applicationTransactionCounter: Swift.String? = nil,
            cardExpiryDate: Swift.String? = nil,
            panSequenceNumber: Swift.String? = nil,
            serviceCode: Swift.String? = nil
        )
        {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.cardExpiryDate = cardExpiryDate
            self.panSequenceNumber = panSequenceNumber
            self.serviceCode = serviceCode
        }
    }

}

extension EncryptDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptDataInput(encryptionAttributes: \(Swift.String(describing: encryptionAttributes)), keyIdentifier: \(Swift.String(describing: keyIdentifier)), plainText: \"CONTENT_REDACTED\")"}
}

extension EncryptDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionAttributes = "EncryptionAttributes"
        case plainText = "PlainText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionAttributes = self.encryptionAttributes {
            try encodeContainer.encode(encryptionAttributes, forKey: .encryptionAttributes)
        }
        if let plainText = self.plainText {
            try encodeContainer.encode(plainText, forKey: .plainText)
        }
    }
}

extension EncryptDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let keyIdentifier = keyIdentifier else {
            return nil
        }
        return "/keys/\(keyIdentifier.urlPercentEncoding())/encrypt"
    }
}

public struct EncryptDataInput: Swift.Equatable {
    /// The encryption key type and attributes for plaintext encryption.
    /// This member is required.
    public var encryptionAttributes: PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes?
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for plaintext encryption.
    /// This member is required.
    public var keyIdentifier: Swift.String?
    /// The plaintext to be encrypted.
    /// This member is required.
    public var plainText: Swift.String?

    public init(
        encryptionAttributes: PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes? = nil,
        keyIdentifier: Swift.String? = nil,
        plainText: Swift.String? = nil
    )
    {
        self.encryptionAttributes = encryptionAttributes
        self.keyIdentifier = keyIdentifier
        self.plainText = plainText
    }
}

struct EncryptDataInputBody: Swift.Equatable {
    let plainText: Swift.String?
    let encryptionAttributes: PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes?
}

extension EncryptDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionAttributes = "EncryptionAttributes"
        case plainText = "PlainText"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let plainTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .plainText)
        plainText = plainTextDecoded
        let encryptionAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes.self, forKey: .encryptionAttributes)
        encryptionAttributes = encryptionAttributesDecoded
    }
}

extension EncryptDataOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptDataOutput(keyArn: \(Swift.String(describing: keyArn)), keyCheckValue: \(Swift.String(describing: keyCheckValue)), cipherText: \"CONTENT_REDACTED\")"}
}

extension EncryptDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EncryptDataOutputBody = try responseDecoder.decode(responseBody: data)
            self.cipherText = output.cipherText
            self.keyArn = output.keyArn
            self.keyCheckValue = output.keyCheckValue
        } else {
            self.cipherText = nil
            self.keyArn = nil
            self.keyCheckValue = nil
        }
    }
}

public struct EncryptDataOutput: Swift.Equatable {
    /// The encrypted ciphertext.
    /// This member is required.
    public var cipherText: Swift.String?
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for plaintext encryption.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography calculates the KCV by using standard algorithms, typically by encrypting 8 or 16 bytes or "00" or "01" and then truncating the result to the first 3 bytes, or 6 hex digits, of the resulting cryptogram.
    public var keyCheckValue: Swift.String?

    public init(
        cipherText: Swift.String? = nil,
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil
    )
    {
        self.cipherText = cipherText
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
    }
}

struct EncryptDataOutputBody: Swift.Equatable {
    let keyArn: Swift.String?
    let keyCheckValue: Swift.String?
    let cipherText: Swift.String?
}

extension EncryptDataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cipherText = "CipherText"
        case keyArn = "KeyArn"
        case keyCheckValue = "KeyCheckValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyCheckValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyCheckValue)
        keyCheckValue = keyCheckValueDecoded
        let cipherTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cipherText)
        cipherText = cipherTextDecoded
    }
}

enum EncryptDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PaymentCryptographyDataClientTypes.EncryptionDecryptionAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asymmetric = "Asymmetric"
        case dukpt = "Dukpt"
        case symmetric = "Symmetric"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .asymmetric(asymmetric):
                try container.encode(asymmetric, forKey: .asymmetric)
            case let .dukpt(dukpt):
                try container.encode(dukpt, forKey: .dukpt)
            case let .symmetric(symmetric):
                try container.encode(symmetric, forKey: .symmetric)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let symmetricDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.SymmetricEncryptionAttributes.self, forKey: .symmetric)
        if let symmetric = symmetricDecoded {
            self = .symmetric(symmetric)
            return
        }
        let asymmetricDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.AsymmetricEncryptionAttributes.self, forKey: .asymmetric)
        if let asymmetric = asymmetricDecoded {
            self = .asymmetric(asymmetric)
            return
        }
        let dukptDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.DukptEncryptionAttributes.self, forKey: .dukpt)
        if let dukpt = dukptDecoded {
            self = .dukpt(dukpt)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to perform encryption and decryption operations.
    public enum EncryptionDecryptionAttributes: Swift.Equatable {
        /// Parameters that are required to perform encryption and decryption using symmetric keys.
        case symmetric(PaymentCryptographyDataClientTypes.SymmetricEncryptionAttributes)
        /// Parameters for plaintext encryption using asymmetric keys.
        case asymmetric(PaymentCryptographyDataClientTypes.AsymmetricEncryptionAttributes)
        /// Parameters that are required to encrypt plaintext data using DUKPT.
        case dukpt(PaymentCryptographyDataClientTypes.DukptEncryptionAttributes)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes {
    public enum EncryptionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cbc
        case cfb
        case cfb1
        case cfb128
        case cfb64
        case cfb8
        case ecb
        case ofb
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionMode] {
            return [
                .cbc,
                .cfb,
                .cfb1,
                .cfb128,
                .cfb64,
                .cfb8,
                .ecb,
                .ofb,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cbc: return "CBC"
            case .cfb: return "CFB"
            case .cfb1: return "CFB1"
            case .cfb128: return "CFB128"
            case .cfb64: return "CFB64"
            case .cfb8: return "CFB8"
            case .ecb: return "ECB"
            case .ofb: return "OFB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionMode(rawValue: rawValue) ?? EncryptionMode.sdkUnknown(rawValue)
        }
    }
}

extension GenerateCardValidationDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerateCardValidationDataInput(generationAttributes: \(Swift.String(describing: generationAttributes)), keyIdentifier: \(Swift.String(describing: keyIdentifier)), validationDataLength: \(Swift.String(describing: validationDataLength)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension GenerateCardValidationDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationAttributes = "GenerationAttributes"
        case keyIdentifier = "KeyIdentifier"
        case primaryAccountNumber = "PrimaryAccountNumber"
        case validationDataLength = "ValidationDataLength"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generationAttributes = self.generationAttributes {
            try encodeContainer.encode(generationAttributes, forKey: .generationAttributes)
        }
        if let keyIdentifier = self.keyIdentifier {
            try encodeContainer.encode(keyIdentifier, forKey: .keyIdentifier)
        }
        if let primaryAccountNumber = self.primaryAccountNumber {
            try encodeContainer.encode(primaryAccountNumber, forKey: .primaryAccountNumber)
        }
        if let validationDataLength = self.validationDataLength {
            try encodeContainer.encode(validationDataLength, forKey: .validationDataLength)
        }
    }
}

extension GenerateCardValidationDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cardvalidationdata/generate"
    }
}

public struct GenerateCardValidationDataInput: Swift.Equatable {
    /// The algorithm for generating CVV or CSC values for the card within Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var generationAttributes: PaymentCryptographyDataClientTypes.CardGenerationAttributes?
    /// The keyARN of the CVK encryption key that Amazon Web Services Payment Cryptography uses to generate card data.
    /// This member is required.
    public var keyIdentifier: Swift.String?
    /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.
    /// This member is required.
    public var primaryAccountNumber: Swift.String?
    /// The length of the CVV or CSC to be generated. The default value is 3.
    public var validationDataLength: Swift.Int?

    public init(
        generationAttributes: PaymentCryptographyDataClientTypes.CardGenerationAttributes? = nil,
        keyIdentifier: Swift.String? = nil,
        primaryAccountNumber: Swift.String? = nil,
        validationDataLength: Swift.Int? = nil
    )
    {
        self.generationAttributes = generationAttributes
        self.keyIdentifier = keyIdentifier
        self.primaryAccountNumber = primaryAccountNumber
        self.validationDataLength = validationDataLength
    }
}

struct GenerateCardValidationDataInputBody: Swift.Equatable {
    let keyIdentifier: Swift.String?
    let primaryAccountNumber: Swift.String?
    let generationAttributes: PaymentCryptographyDataClientTypes.CardGenerationAttributes?
    let validationDataLength: Swift.Int?
}

extension GenerateCardValidationDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationAttributes = "GenerationAttributes"
        case keyIdentifier = "KeyIdentifier"
        case primaryAccountNumber = "PrimaryAccountNumber"
        case validationDataLength = "ValidationDataLength"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyIdentifier)
        keyIdentifier = keyIdentifierDecoded
        let primaryAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountNumber)
        primaryAccountNumber = primaryAccountNumberDecoded
        let generationAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.CardGenerationAttributes.self, forKey: .generationAttributes)
        generationAttributes = generationAttributesDecoded
        let validationDataLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validationDataLength)
        validationDataLength = validationDataLengthDecoded
    }
}

extension GenerateCardValidationDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GenerateCardValidationDataOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyArn = output.keyArn
            self.keyCheckValue = output.keyCheckValue
            self.validationData = output.validationData
        } else {
            self.keyArn = nil
            self.keyCheckValue = nil
            self.validationData = nil
        }
    }
}

public struct GenerateCardValidationDataOutput: Swift.Equatable {
    /// The keyARN of the CVK encryption key that Amazon Web Services Payment Cryptography uses to generate CVV or CSC.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography calculates the KCV by using standard algorithms, typically by encrypting 8 or 16 bytes or "00" or "01" and then truncating the result to the first 3 bytes, or 6 hex digits, of the resulting cryptogram.
    /// This member is required.
    public var keyCheckValue: Swift.String?
    /// The CVV or CSC value that Amazon Web Services Payment Cryptography generates for the card.
    /// This member is required.
    public var validationData: Swift.String?

    public init(
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil,
        validationData: Swift.String? = nil
    )
    {
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
        self.validationData = validationData
    }
}

struct GenerateCardValidationDataOutputBody: Swift.Equatable {
    let keyArn: Swift.String?
    let keyCheckValue: Swift.String?
    let validationData: Swift.String?
}

extension GenerateCardValidationDataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn = "KeyArn"
        case keyCheckValue = "KeyCheckValue"
        case validationData = "ValidationData"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyCheckValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyCheckValue)
        keyCheckValue = keyCheckValueDecoded
        let validationDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationData)
        validationData = validationDataDecoded
    }
}

enum GenerateCardValidationDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GenerateMacInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerateMacInput(generationAttributes: \(Swift.String(describing: generationAttributes)), keyIdentifier: \(Swift.String(describing: keyIdentifier)), macLength: \(Swift.String(describing: macLength)), messageData: \"CONTENT_REDACTED\")"}
}

extension GenerateMacInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationAttributes = "GenerationAttributes"
        case keyIdentifier = "KeyIdentifier"
        case macLength = "MacLength"
        case messageData = "MessageData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generationAttributes = self.generationAttributes {
            try encodeContainer.encode(generationAttributes, forKey: .generationAttributes)
        }
        if let keyIdentifier = self.keyIdentifier {
            try encodeContainer.encode(keyIdentifier, forKey: .keyIdentifier)
        }
        if let macLength = self.macLength {
            try encodeContainer.encode(macLength, forKey: .macLength)
        }
        if let messageData = self.messageData {
            try encodeContainer.encode(messageData, forKey: .messageData)
        }
    }
}

extension GenerateMacInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/mac/generate"
    }
}

public struct GenerateMacInput: Swift.Equatable {
    /// The attributes and data values to use for MAC generation within Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var generationAttributes: PaymentCryptographyDataClientTypes.MacAttributes?
    /// The keyARN of the MAC generation encryption key.
    /// This member is required.
    public var keyIdentifier: Swift.String?
    /// The length of a MAC under generation.
    public var macLength: Swift.Int?
    /// The data for which a MAC is under generation.
    /// This member is required.
    public var messageData: Swift.String?

    public init(
        generationAttributes: PaymentCryptographyDataClientTypes.MacAttributes? = nil,
        keyIdentifier: Swift.String? = nil,
        macLength: Swift.Int? = nil,
        messageData: Swift.String? = nil
    )
    {
        self.generationAttributes = generationAttributes
        self.keyIdentifier = keyIdentifier
        self.macLength = macLength
        self.messageData = messageData
    }
}

struct GenerateMacInputBody: Swift.Equatable {
    let keyIdentifier: Swift.String?
    let messageData: Swift.String?
    let generationAttributes: PaymentCryptographyDataClientTypes.MacAttributes?
    let macLength: Swift.Int?
}

extension GenerateMacInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationAttributes = "GenerationAttributes"
        case keyIdentifier = "KeyIdentifier"
        case macLength = "MacLength"
        case messageData = "MessageData"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyIdentifier)
        keyIdentifier = keyIdentifierDecoded
        let messageDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageData)
        messageData = messageDataDecoded
        let generationAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.MacAttributes.self, forKey: .generationAttributes)
        generationAttributes = generationAttributesDecoded
        let macLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .macLength)
        macLength = macLengthDecoded
    }
}

extension GenerateMacOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GenerateMacOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyArn = output.keyArn
            self.keyCheckValue = output.keyCheckValue
            self.mac = output.mac
        } else {
            self.keyArn = nil
            self.keyCheckValue = nil
            self.mac = nil
        }
    }
}

public struct GenerateMacOutput: Swift.Equatable {
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for MAC generation.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography calculates the KCV by using standard algorithms, typically by encrypting 8 or 16 bytes or "00" or "01" and then truncating the result to the first 3 bytes, or 6 hex digits, of the resulting cryptogram.
    /// This member is required.
    public var keyCheckValue: Swift.String?
    /// The MAC cryptogram generated within Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var mac: Swift.String?

    public init(
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil,
        mac: Swift.String? = nil
    )
    {
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
        self.mac = mac
    }
}

struct GenerateMacOutputBody: Swift.Equatable {
    let keyArn: Swift.String?
    let keyCheckValue: Swift.String?
    let mac: Swift.String?
}

extension GenerateMacOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn = "KeyArn"
        case keyCheckValue = "KeyCheckValue"
        case mac = "Mac"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyCheckValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyCheckValue)
        keyCheckValue = keyCheckValueDecoded
        let macDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mac)
        mac = macDecoded
    }
}

enum GenerateMacOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GeneratePinDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeneratePinDataInput(encryptionKeyIdentifier: \(Swift.String(describing: encryptionKeyIdentifier)), generationAttributes: \(Swift.String(describing: generationAttributes)), generationKeyIdentifier: \(Swift.String(describing: generationKeyIdentifier)), pinBlockFormat: \(Swift.String(describing: pinBlockFormat)), pinDataLength: \(Swift.String(describing: pinDataLength)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension GeneratePinDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionKeyIdentifier = "EncryptionKeyIdentifier"
        case generationAttributes = "GenerationAttributes"
        case generationKeyIdentifier = "GenerationKeyIdentifier"
        case pinBlockFormat = "PinBlockFormat"
        case pinDataLength = "PinDataLength"
        case primaryAccountNumber = "PrimaryAccountNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionKeyIdentifier = self.encryptionKeyIdentifier {
            try encodeContainer.encode(encryptionKeyIdentifier, forKey: .encryptionKeyIdentifier)
        }
        if let generationAttributes = self.generationAttributes {
            try encodeContainer.encode(generationAttributes, forKey: .generationAttributes)
        }
        if let generationKeyIdentifier = self.generationKeyIdentifier {
            try encodeContainer.encode(generationKeyIdentifier, forKey: .generationKeyIdentifier)
        }
        if let pinBlockFormat = self.pinBlockFormat {
            try encodeContainer.encode(pinBlockFormat.rawValue, forKey: .pinBlockFormat)
        }
        if let pinDataLength = self.pinDataLength {
            try encodeContainer.encode(pinDataLength, forKey: .pinDataLength)
        }
        if let primaryAccountNumber = self.primaryAccountNumber {
            try encodeContainer.encode(primaryAccountNumber, forKey: .primaryAccountNumber)
        }
    }
}

extension GeneratePinDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/pindata/generate"
    }
}

public struct GeneratePinDataInput: Swift.Equatable {
    /// The keyARN of the PEK that Amazon Web Services Payment Cryptography uses to encrypt the PIN Block.
    /// This member is required.
    public var encryptionKeyIdentifier: Swift.String?
    /// The attributes and values to use for PIN, PVV, or PIN Offset generation.
    /// This member is required.
    public var generationAttributes: PaymentCryptographyDataClientTypes.PinGenerationAttributes?
    /// The keyARN of the PEK that Amazon Web Services Payment Cryptography uses for pin data generation.
    /// This member is required.
    public var generationKeyIdentifier: Swift.String?
    /// The PIN encoding format for pin data generation as specified in ISO 9564. Amazon Web Services Payment Cryptography supports ISO_Format_0 and ISO_Format_3. The ISO_Format_0 PIN block format is equivalent to the ANSI X9.8, VISA-1, and ECI-1 PIN block formats. It is similar to a VISA-4 PIN block format. It supports a PIN from 4 to 12 digits in length. The ISO_Format_3 PIN block format is the same as ISO_Format_0 except that the fill digits are random values from 10 to 15.
    /// This member is required.
    public var pinBlockFormat: PaymentCryptographyDataClientTypes.PinBlockFormatForPinData?
    /// The length of PIN under generation.
    public var pinDataLength: Swift.Int?
    /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.
    /// This member is required.
    public var primaryAccountNumber: Swift.String?

    public init(
        encryptionKeyIdentifier: Swift.String? = nil,
        generationAttributes: PaymentCryptographyDataClientTypes.PinGenerationAttributes? = nil,
        generationKeyIdentifier: Swift.String? = nil,
        pinBlockFormat: PaymentCryptographyDataClientTypes.PinBlockFormatForPinData? = nil,
        pinDataLength: Swift.Int? = nil,
        primaryAccountNumber: Swift.String? = nil
    )
    {
        self.encryptionKeyIdentifier = encryptionKeyIdentifier
        self.generationAttributes = generationAttributes
        self.generationKeyIdentifier = generationKeyIdentifier
        self.pinBlockFormat = pinBlockFormat
        self.pinDataLength = pinDataLength
        self.primaryAccountNumber = primaryAccountNumber
    }
}

struct GeneratePinDataInputBody: Swift.Equatable {
    let generationKeyIdentifier: Swift.String?
    let encryptionKeyIdentifier: Swift.String?
    let generationAttributes: PaymentCryptographyDataClientTypes.PinGenerationAttributes?
    let pinDataLength: Swift.Int?
    let primaryAccountNumber: Swift.String?
    let pinBlockFormat: PaymentCryptographyDataClientTypes.PinBlockFormatForPinData?
}

extension GeneratePinDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionKeyIdentifier = "EncryptionKeyIdentifier"
        case generationAttributes = "GenerationAttributes"
        case generationKeyIdentifier = "GenerationKeyIdentifier"
        case pinBlockFormat = "PinBlockFormat"
        case pinDataLength = "PinDataLength"
        case primaryAccountNumber = "PrimaryAccountNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generationKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationKeyIdentifier)
        generationKeyIdentifier = generationKeyIdentifierDecoded
        let encryptionKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyIdentifier)
        encryptionKeyIdentifier = encryptionKeyIdentifierDecoded
        let generationAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.PinGenerationAttributes.self, forKey: .generationAttributes)
        generationAttributes = generationAttributesDecoded
        let pinDataLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pinDataLength)
        pinDataLength = pinDataLengthDecoded
        let primaryAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountNumber)
        primaryAccountNumber = primaryAccountNumberDecoded
        let pinBlockFormatDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.PinBlockFormatForPinData.self, forKey: .pinBlockFormat)
        pinBlockFormat = pinBlockFormatDecoded
    }
}

extension GeneratePinDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GeneratePinDataOutputBody = try responseDecoder.decode(responseBody: data)
            self.encryptedPinBlock = output.encryptedPinBlock
            self.encryptionKeyArn = output.encryptionKeyArn
            self.encryptionKeyCheckValue = output.encryptionKeyCheckValue
            self.generationKeyArn = output.generationKeyArn
            self.generationKeyCheckValue = output.generationKeyCheckValue
            self.pinData = output.pinData
        } else {
            self.encryptedPinBlock = nil
            self.encryptionKeyArn = nil
            self.encryptionKeyCheckValue = nil
            self.generationKeyArn = nil
            self.generationKeyCheckValue = nil
            self.pinData = nil
        }
    }
}

public struct GeneratePinDataOutput: Swift.Equatable {
    /// The PIN block encrypted under PEK from Amazon Web Services Payment Cryptography. The encrypted PIN block is a composite of PAN (Primary Account Number) and PIN (Personal Identification Number), generated in accordance with ISO 9564 standard.
    /// This member is required.
    public var encryptedPinBlock: Swift.String?
    /// The keyARN of the PEK that Amazon Web Services Payment Cryptography uses for encrypted pin block generation.
    /// This member is required.
    public var encryptionKeyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography calculates the KCV by using standard algorithms, typically by encrypting 8 or 16 bytes or "00" or "01" and then truncating the result to the first 3 bytes, or 6 hex digits, of the resulting cryptogram.
    /// This member is required.
    public var encryptionKeyCheckValue: Swift.String?
    /// The keyARN of the pin data generation key that Amazon Web Services Payment Cryptography uses for PIN, PVV or PIN Offset generation.
    /// This member is required.
    public var generationKeyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography calculates the KCV by using standard algorithms, typically by encrypting 8 or 16 bytes or "00" or "01" and then truncating the result to the first 3 bytes, or 6 hex digits, of the resulting cryptogram.
    /// This member is required.
    public var generationKeyCheckValue: Swift.String?
    /// The attributes and values Amazon Web Services Payment Cryptography uses for pin data generation.
    /// This member is required.
    public var pinData: PaymentCryptographyDataClientTypes.PinData?

    public init(
        encryptedPinBlock: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil,
        encryptionKeyCheckValue: Swift.String? = nil,
        generationKeyArn: Swift.String? = nil,
        generationKeyCheckValue: Swift.String? = nil,
        pinData: PaymentCryptographyDataClientTypes.PinData? = nil
    )
    {
        self.encryptedPinBlock = encryptedPinBlock
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionKeyCheckValue = encryptionKeyCheckValue
        self.generationKeyArn = generationKeyArn
        self.generationKeyCheckValue = generationKeyCheckValue
        self.pinData = pinData
    }
}

struct GeneratePinDataOutputBody: Swift.Equatable {
    let generationKeyArn: Swift.String?
    let generationKeyCheckValue: Swift.String?
    let encryptionKeyArn: Swift.String?
    let encryptionKeyCheckValue: Swift.String?
    let encryptedPinBlock: Swift.String?
    let pinData: PaymentCryptographyDataClientTypes.PinData?
}

extension GeneratePinDataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptedPinBlock = "EncryptedPinBlock"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionKeyCheckValue = "EncryptionKeyCheckValue"
        case generationKeyArn = "GenerationKeyArn"
        case generationKeyCheckValue = "GenerationKeyCheckValue"
        case pinData = "PinData"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generationKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationKeyArn)
        generationKeyArn = generationKeyArnDecoded
        let generationKeyCheckValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationKeyCheckValue)
        generationKeyCheckValue = generationKeyCheckValueDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let encryptionKeyCheckValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyCheckValue)
        encryptionKeyCheckValue = encryptionKeyCheckValueDecoded
        let encryptedPinBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptedPinBlock)
        encryptedPinBlock = encryptedPinBlockDecoded
        let pinDataDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.PinData.self, forKey: .pinData)
        pinData = pinDataDecoded
    }
}

enum GeneratePinDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PaymentCryptographyDataClientTypes.Ibm3624NaturalPin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decimalizationTable = "DecimalizationTable"
        case pinValidationData = "PinValidationData"
        case pinValidationDataPadCharacter = "PinValidationDataPadCharacter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decimalizationTable = self.decimalizationTable {
            try encodeContainer.encode(decimalizationTable, forKey: .decimalizationTable)
        }
        if let pinValidationData = self.pinValidationData {
            try encodeContainer.encode(pinValidationData, forKey: .pinValidationData)
        }
        if let pinValidationDataPadCharacter = self.pinValidationDataPadCharacter {
            try encodeContainer.encode(pinValidationDataPadCharacter, forKey: .pinValidationDataPadCharacter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decimalizationTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decimalizationTable)
        decimalizationTable = decimalizationTableDecoded
        let pinValidationDataPadCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pinValidationDataPadCharacter)
        pinValidationDataPadCharacter = pinValidationDataPadCharacterDecoded
        let pinValidationDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pinValidationData)
        pinValidationData = pinValidationDataDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Ibm3624 natural PIN.
    public struct Ibm3624NaturalPin: Swift.Equatable {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        /// This member is required.
        public var decimalizationTable: Swift.String?
        /// The unique data for cardholder identification.
        /// This member is required.
        public var pinValidationData: Swift.String?
        /// The padding character for validation data.
        /// This member is required.
        public var pinValidationDataPadCharacter: Swift.String?

        public init(
            decimalizationTable: Swift.String? = nil,
            pinValidationData: Swift.String? = nil,
            pinValidationDataPadCharacter: Swift.String? = nil
        )
        {
            self.decimalizationTable = decimalizationTable
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }
    }

}

extension PaymentCryptographyDataClientTypes.Ibm3624PinFromOffset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decimalizationTable = "DecimalizationTable"
        case pinOffset = "PinOffset"
        case pinValidationData = "PinValidationData"
        case pinValidationDataPadCharacter = "PinValidationDataPadCharacter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decimalizationTable = self.decimalizationTable {
            try encodeContainer.encode(decimalizationTable, forKey: .decimalizationTable)
        }
        if let pinOffset = self.pinOffset {
            try encodeContainer.encode(pinOffset, forKey: .pinOffset)
        }
        if let pinValidationData = self.pinValidationData {
            try encodeContainer.encode(pinValidationData, forKey: .pinValidationData)
        }
        if let pinValidationDataPadCharacter = self.pinValidationDataPadCharacter {
            try encodeContainer.encode(pinValidationDataPadCharacter, forKey: .pinValidationDataPadCharacter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decimalizationTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decimalizationTable)
        decimalizationTable = decimalizationTableDecoded
        let pinValidationDataPadCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pinValidationDataPadCharacter)
        pinValidationDataPadCharacter = pinValidationDataPadCharacterDecoded
        let pinValidationDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pinValidationData)
        pinValidationData = pinValidationDataDecoded
        let pinOffsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pinOffset)
        pinOffset = pinOffsetDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Ibm3624 PIN from offset PIN.
    public struct Ibm3624PinFromOffset: Swift.Equatable {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        /// This member is required.
        public var decimalizationTable: Swift.String?
        /// The PIN offset value.
        /// This member is required.
        public var pinOffset: Swift.String?
        /// The unique data for cardholder identification.
        /// This member is required.
        public var pinValidationData: Swift.String?
        /// The padding character for validation data.
        /// This member is required.
        public var pinValidationDataPadCharacter: Swift.String?

        public init(
            decimalizationTable: Swift.String? = nil,
            pinOffset: Swift.String? = nil,
            pinValidationData: Swift.String? = nil,
            pinValidationDataPadCharacter: Swift.String? = nil
        )
        {
            self.decimalizationTable = decimalizationTable
            self.pinOffset = pinOffset
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }
    }

}

extension PaymentCryptographyDataClientTypes.Ibm3624PinOffset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decimalizationTable = "DecimalizationTable"
        case encryptedPinBlock = "EncryptedPinBlock"
        case pinValidationData = "PinValidationData"
        case pinValidationDataPadCharacter = "PinValidationDataPadCharacter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decimalizationTable = self.decimalizationTable {
            try encodeContainer.encode(decimalizationTable, forKey: .decimalizationTable)
        }
        if let encryptedPinBlock = self.encryptedPinBlock {
            try encodeContainer.encode(encryptedPinBlock, forKey: .encryptedPinBlock)
        }
        if let pinValidationData = self.pinValidationData {
            try encodeContainer.encode(pinValidationData, forKey: .pinValidationData)
        }
        if let pinValidationDataPadCharacter = self.pinValidationDataPadCharacter {
            try encodeContainer.encode(pinValidationDataPadCharacter, forKey: .pinValidationDataPadCharacter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptedPinBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptedPinBlock)
        encryptedPinBlock = encryptedPinBlockDecoded
        let decimalizationTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decimalizationTable)
        decimalizationTable = decimalizationTableDecoded
        let pinValidationDataPadCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pinValidationDataPadCharacter)
        pinValidationDataPadCharacter = pinValidationDataPadCharacterDecoded
        let pinValidationDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pinValidationData)
        pinValidationData = pinValidationDataDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Pparameters that are required to generate or verify Ibm3624 PIN offset PIN.
    public struct Ibm3624PinOffset: Swift.Equatable {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        /// This member is required.
        public var decimalizationTable: Swift.String?
        /// The encrypted PIN block data. According to ISO 9564 standard, a PIN Block is an encoded representation of a payment card Personal Account Number (PAN) and the cardholder Personal Identification Number (PIN).
        /// This member is required.
        public var encryptedPinBlock: Swift.String?
        /// The unique data for cardholder identification.
        /// This member is required.
        public var pinValidationData: Swift.String?
        /// The padding character for validation data.
        /// This member is required.
        public var pinValidationDataPadCharacter: Swift.String?

        public init(
            decimalizationTable: Swift.String? = nil,
            encryptedPinBlock: Swift.String? = nil,
            pinValidationData: Swift.String? = nil,
            pinValidationDataPadCharacter: Swift.String? = nil
        )
        {
            self.decimalizationTable = decimalizationTable
            self.encryptedPinBlock = encryptedPinBlock
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }
    }

}

extension PaymentCryptographyDataClientTypes.Ibm3624PinVerification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decimalizationTable = "DecimalizationTable"
        case pinOffset = "PinOffset"
        case pinValidationData = "PinValidationData"
        case pinValidationDataPadCharacter = "PinValidationDataPadCharacter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decimalizationTable = self.decimalizationTable {
            try encodeContainer.encode(decimalizationTable, forKey: .decimalizationTable)
        }
        if let pinOffset = self.pinOffset {
            try encodeContainer.encode(pinOffset, forKey: .pinOffset)
        }
        if let pinValidationData = self.pinValidationData {
            try encodeContainer.encode(pinValidationData, forKey: .pinValidationData)
        }
        if let pinValidationDataPadCharacter = self.pinValidationDataPadCharacter {
            try encodeContainer.encode(pinValidationDataPadCharacter, forKey: .pinValidationDataPadCharacter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decimalizationTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decimalizationTable)
        decimalizationTable = decimalizationTableDecoded
        let pinValidationDataPadCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pinValidationDataPadCharacter)
        pinValidationDataPadCharacter = pinValidationDataPadCharacterDecoded
        let pinValidationDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pinValidationData)
        pinValidationData = pinValidationDataDecoded
        let pinOffsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pinOffset)
        pinOffset = pinOffsetDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Ibm3624 PIN verification PIN.
    public struct Ibm3624PinVerification: Swift.Equatable {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        /// This member is required.
        public var decimalizationTable: Swift.String?
        /// The PIN offset value.
        /// This member is required.
        public var pinOffset: Swift.String?
        /// The unique data for cardholder identification.
        /// This member is required.
        public var pinValidationData: Swift.String?
        /// The padding character for validation data.
        /// This member is required.
        public var pinValidationDataPadCharacter: Swift.String?

        public init(
            decimalizationTable: Swift.String? = nil,
            pinOffset: Swift.String? = nil,
            pinValidationData: Swift.String? = nil,
            pinValidationDataPadCharacter: Swift.String? = nil
        )
        {
            self.decimalizationTable = decimalizationTable
            self.pinOffset = pinOffset
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }
    }

}

extension PaymentCryptographyDataClientTypes.Ibm3624RandomPin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decimalizationTable = "DecimalizationTable"
        case pinValidationData = "PinValidationData"
        case pinValidationDataPadCharacter = "PinValidationDataPadCharacter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decimalizationTable = self.decimalizationTable {
            try encodeContainer.encode(decimalizationTable, forKey: .decimalizationTable)
        }
        if let pinValidationData = self.pinValidationData {
            try encodeContainer.encode(pinValidationData, forKey: .pinValidationData)
        }
        if let pinValidationDataPadCharacter = self.pinValidationDataPadCharacter {
            try encodeContainer.encode(pinValidationDataPadCharacter, forKey: .pinValidationDataPadCharacter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decimalizationTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decimalizationTable)
        decimalizationTable = decimalizationTableDecoded
        let pinValidationDataPadCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pinValidationDataPadCharacter)
        pinValidationDataPadCharacter = pinValidationDataPadCharacterDecoded
        let pinValidationDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pinValidationData)
        pinValidationData = pinValidationDataDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Ibm3624 random PIN.
    public struct Ibm3624RandomPin: Swift.Equatable {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        /// This member is required.
        public var decimalizationTable: Swift.String?
        /// The unique data for cardholder identification.
        /// This member is required.
        public var pinValidationData: Swift.String?
        /// The padding character for validation data.
        /// This member is required.
        public var pinValidationDataPadCharacter: Swift.String?

        public init(
            decimalizationTable: Swift.String? = nil,
            pinValidationData: Swift.String? = nil,
            pinValidationDataPadCharacter: Swift.String? = nil
        )
        {
            self.decimalizationTable = decimalizationTable
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception, or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    public enum MacAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cmac
        case hmacSha224
        case hmacSha256
        case hmacSha384
        case hmacSha512
        case iso9797Algorithm1
        case iso9797Algorithm3
        case sdkUnknown(Swift.String)

        public static var allCases: [MacAlgorithm] {
            return [
                .cmac,
                .hmacSha224,
                .hmacSha256,
                .hmacSha384,
                .hmacSha512,
                .iso9797Algorithm1,
                .iso9797Algorithm3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cmac: return "CMAC"
            case .hmacSha224: return "HMAC_SHA224"
            case .hmacSha256: return "HMAC_SHA256"
            case .hmacSha384: return "HMAC_SHA384"
            case .hmacSha512: return "HMAC_SHA512"
            case .iso9797Algorithm1: return "ISO9797_ALGORITHM1"
            case .iso9797Algorithm3: return "ISO9797_ALGORITHM3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MacAlgorithm(rawValue: rawValue) ?? MacAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension PaymentCryptographyDataClientTypes.MacAlgorithmDukpt: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dukptDerivationType = "DukptDerivationType"
        case dukptKeyVariant = "DukptKeyVariant"
        case keySerialNumber = "KeySerialNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dukptDerivationType = self.dukptDerivationType {
            try encodeContainer.encode(dukptDerivationType.rawValue, forKey: .dukptDerivationType)
        }
        if let dukptKeyVariant = self.dukptKeyVariant {
            try encodeContainer.encode(dukptKeyVariant.rawValue, forKey: .dukptKeyVariant)
        }
        if let keySerialNumber = self.keySerialNumber {
            try encodeContainer.encode(keySerialNumber, forKey: .keySerialNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keySerialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keySerialNumber)
        keySerialNumber = keySerialNumberDecoded
        let dukptKeyVariantDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.DukptKeyVariant.self, forKey: .dukptKeyVariant)
        dukptKeyVariant = dukptKeyVariantDecoded
        let dukptDerivationTypeDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.DukptDerivationType.self, forKey: .dukptDerivationType)
        dukptDerivationType = dukptDerivationTypeDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters required for DUKPT MAC generation and verification.
    public struct MacAlgorithmDukpt: Swift.Equatable {
        /// The key type derived using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use AES_128 as a derivation type for a BDK of AES_128 or TDES_2KEY.
        public var dukptDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType?
        /// The type of use of DUKPT, which can be MAC generation, MAC verification, or both.
        /// This member is required.
        public var dukptKeyVariant: PaymentCryptographyDataClientTypes.DukptKeyVariant?
        /// The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.
        /// This member is required.
        public var keySerialNumber: Swift.String?

        public init(
            dukptDerivationType: PaymentCryptographyDataClientTypes.DukptDerivationType? = nil,
            dukptKeyVariant: PaymentCryptographyDataClientTypes.DukptKeyVariant? = nil,
            keySerialNumber: Swift.String? = nil
        )
        {
            self.dukptDerivationType = dukptDerivationType
            self.dukptKeyVariant = dukptKeyVariant
            self.keySerialNumber = keySerialNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.MacAlgorithmEmv: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorKeyDerivationMode = "MajorKeyDerivationMode"
        case panSequenceNumber = "PanSequenceNumber"
        case primaryAccountNumber = "PrimaryAccountNumber"
        case sessionKeyDerivationMode = "SessionKeyDerivationMode"
        case sessionKeyDerivationValue = "SessionKeyDerivationValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorKeyDerivationMode = self.majorKeyDerivationMode {
            try encodeContainer.encode(majorKeyDerivationMode.rawValue, forKey: .majorKeyDerivationMode)
        }
        if let panSequenceNumber = self.panSequenceNumber {
            try encodeContainer.encode(panSequenceNumber, forKey: .panSequenceNumber)
        }
        if let primaryAccountNumber = self.primaryAccountNumber {
            try encodeContainer.encode(primaryAccountNumber, forKey: .primaryAccountNumber)
        }
        if let sessionKeyDerivationMode = self.sessionKeyDerivationMode {
            try encodeContainer.encode(sessionKeyDerivationMode.rawValue, forKey: .sessionKeyDerivationMode)
        }
        if let sessionKeyDerivationValue = self.sessionKeyDerivationValue {
            try encodeContainer.encode(sessionKeyDerivationValue, forKey: .sessionKeyDerivationValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let majorKeyDerivationModeDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.MajorKeyDerivationMode.self, forKey: .majorKeyDerivationMode)
        majorKeyDerivationMode = majorKeyDerivationModeDecoded
        let primaryAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountNumber)
        primaryAccountNumber = primaryAccountNumberDecoded
        let panSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .panSequenceNumber)
        panSequenceNumber = panSequenceNumberDecoded
        let sessionKeyDerivationModeDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.SessionKeyDerivationMode.self, forKey: .sessionKeyDerivationMode)
        sessionKeyDerivationMode = sessionKeyDerivationModeDecoded
        let sessionKeyDerivationValueDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.SessionKeyDerivationValue.self, forKey: .sessionKeyDerivationValue)
        sessionKeyDerivationValue = sessionKeyDerivationValueDecoded
    }
}

extension PaymentCryptographyDataClientTypes.MacAlgorithmEmv: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MacAlgorithmEmv(majorKeyDerivationMode: \(Swift.String(describing: majorKeyDerivationMode)), panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), sessionKeyDerivationMode: \(Swift.String(describing: sessionKeyDerivationMode)), sessionKeyDerivationValue: \(Swift.String(describing: sessionKeyDerivationValue)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for EMV MAC generation and verification.
    public struct MacAlgorithmEmv: Swift.Equatable {
        /// The method to use when deriving the master key for EMV MAC generation or verification.
        /// This member is required.
        public var majorKeyDerivationMode: PaymentCryptographyDataClientTypes.MajorKeyDerivationMode?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?
        /// The method of deriving a session key for EMV MAC generation or verification.
        /// This member is required.
        public var sessionKeyDerivationMode: PaymentCryptographyDataClientTypes.SessionKeyDerivationMode?
        /// Parameters that are required to generate session key for EMV generation and verification.
        /// This member is required.
        public var sessionKeyDerivationValue: PaymentCryptographyDataClientTypes.SessionKeyDerivationValue?

        public init(
            majorKeyDerivationMode: PaymentCryptographyDataClientTypes.MajorKeyDerivationMode? = nil,
            panSequenceNumber: Swift.String? = nil,
            primaryAccountNumber: Swift.String? = nil,
            sessionKeyDerivationMode: PaymentCryptographyDataClientTypes.SessionKeyDerivationMode? = nil,
            sessionKeyDerivationValue: PaymentCryptographyDataClientTypes.SessionKeyDerivationValue? = nil
        )
        {
            self.majorKeyDerivationMode = majorKeyDerivationMode
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
            self.sessionKeyDerivationMode = sessionKeyDerivationMode
            self.sessionKeyDerivationValue = sessionKeyDerivationValue
        }
    }

}

extension PaymentCryptographyDataClientTypes.MacAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithm = "Algorithm"
        case dukptcmac = "DukptCmac"
        case dukptiso9797algorithm1 = "DukptIso9797Algorithm1"
        case dukptiso9797algorithm3 = "DukptIso9797Algorithm3"
        case emvmac = "EmvMac"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .algorithm(algorithm):
                try container.encode(algorithm.rawValue, forKey: .algorithm)
            case let .dukptcmac(dukptcmac):
                try container.encode(dukptcmac, forKey: .dukptcmac)
            case let .dukptiso9797algorithm1(dukptiso9797algorithm1):
                try container.encode(dukptiso9797algorithm1, forKey: .dukptiso9797algorithm1)
            case let .dukptiso9797algorithm3(dukptiso9797algorithm3):
                try container.encode(dukptiso9797algorithm3, forKey: .dukptiso9797algorithm3)
            case let .emvmac(emvmac):
                try container.encode(emvmac, forKey: .emvmac)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.MacAlgorithm.self, forKey: .algorithm)
        if let algorithm = algorithmDecoded {
            self = .algorithm(algorithm)
            return
        }
        let emvmacDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.MacAlgorithmEmv.self, forKey: .emvmac)
        if let emvmac = emvmacDecoded {
            self = .emvmac(emvmac)
            return
        }
        let dukptiso9797algorithm1Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.MacAlgorithmDukpt.self, forKey: .dukptiso9797algorithm1)
        if let dukptiso9797algorithm1 = dukptiso9797algorithm1Decoded {
            self = .dukptiso9797algorithm1(dukptiso9797algorithm1)
            return
        }
        let dukptiso9797algorithm3Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.MacAlgorithmDukpt.self, forKey: .dukptiso9797algorithm3)
        if let dukptiso9797algorithm3 = dukptiso9797algorithm3Decoded {
            self = .dukptiso9797algorithm3(dukptiso9797algorithm3)
            return
        }
        let dukptcmacDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.MacAlgorithmDukpt.self, forKey: .dukptcmac)
        if let dukptcmac = dukptcmacDecoded {
            self = .dukptcmac(dukptcmac)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for DUKPT, HMAC, or EMV MAC generation or verification.
    public enum MacAttributes: Swift.Equatable {
        /// The encryption algorithm for MAC generation or verification.
        case algorithm(PaymentCryptographyDataClientTypes.MacAlgorithm)
        /// Parameters that are required for MAC generation or verification using EMV MAC algorithm.
        case emvmac(PaymentCryptographyDataClientTypes.MacAlgorithmEmv)
        /// Parameters that are required for MAC generation or verification using DUKPT ISO 9797 algorithm1.
        case dukptiso9797algorithm1(PaymentCryptographyDataClientTypes.MacAlgorithmDukpt)
        /// Parameters that are required for MAC generation or verification using DUKPT ISO 9797 algorithm2.
        case dukptiso9797algorithm3(PaymentCryptographyDataClientTypes.MacAlgorithmDukpt)
        /// Parameters that are required for MAC generation or verification using DUKPT CMAC algorithm.
        case dukptcmac(PaymentCryptographyDataClientTypes.MacAlgorithmDukpt)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes {
    public enum MajorKeyDerivationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case emvOptionA
        case emvOptionB
        case sdkUnknown(Swift.String)

        public static var allCases: [MajorKeyDerivationMode] {
            return [
                .emvOptionA,
                .emvOptionB,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .emvOptionA: return "EMV_OPTION_A"
            case .emvOptionB: return "EMV_OPTION_B"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MajorKeyDerivationMode(rawValue: rawValue) ?? MajorKeyDerivationMode.sdkUnknown(rawValue)
        }
    }
}

extension PaymentCryptographyDataClientTypes {
    public enum PaddingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oaepSha1
        case oaepSha256
        case oaepSha512
        case pkcs1
        case sdkUnknown(Swift.String)

        public static var allCases: [PaddingType] {
            return [
                .oaepSha1,
                .oaepSha256,
                .oaepSha512,
                .pkcs1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oaepSha1: return "OAEP_SHA1"
            case .oaepSha256: return "OAEP_SHA256"
            case .oaepSha512: return "OAEP_SHA512"
            case .pkcs1: return "PKCS1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PaddingType(rawValue: rawValue) ?? PaddingType.sdkUnknown(rawValue)
        }
    }
}

extension PaymentCryptographyDataClientTypes {
    public enum PinBlockFormatForPinData: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case isoFormat0
        case isoFormat3
        case sdkUnknown(Swift.String)

        public static var allCases: [PinBlockFormatForPinData] {
            return [
                .isoFormat0,
                .isoFormat3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .isoFormat0: return "ISO_FORMAT_0"
            case .isoFormat3: return "ISO_FORMAT_3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PinBlockFormatForPinData(rawValue: rawValue) ?? PinBlockFormatForPinData.sdkUnknown(rawValue)
        }
    }
}

extension PaymentCryptographyDataClientTypes.PinData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pinoffset = "PinOffset"
        case verificationvalue = "VerificationValue"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .pinoffset(pinoffset):
                try container.encode(pinoffset, forKey: .pinoffset)
            case let .verificationvalue(verificationvalue):
                try container.encode(verificationvalue, forKey: .verificationvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let pinoffsetDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .pinoffset)
        if let pinoffset = pinoffsetDecoded {
            self = .pinoffset(pinoffset)
            return
        }
        let verificationvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .verificationvalue)
        if let verificationvalue = verificationvalueDecoded {
            self = .verificationvalue(verificationvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate, translate, or verify PIN data.
    public enum PinData: Swift.Equatable {
        /// The PIN offset value.
        case pinoffset(Swift.String)
        /// The unique data to identify a cardholder. In most cases, this is the same as cardholder's Primary Account Number (PAN). If a value is not provided, it defaults to PAN.
        case verificationvalue(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes.PinGenerationAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ibm3624naturalpin = "Ibm3624NaturalPin"
        case ibm3624pinfromoffset = "Ibm3624PinFromOffset"
        case ibm3624pinoffset = "Ibm3624PinOffset"
        case ibm3624randompin = "Ibm3624RandomPin"
        case visapin = "VisaPin"
        case visapinverificationvalue = "VisaPinVerificationValue"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .ibm3624naturalpin(ibm3624naturalpin):
                try container.encode(ibm3624naturalpin, forKey: .ibm3624naturalpin)
            case let .ibm3624pinfromoffset(ibm3624pinfromoffset):
                try container.encode(ibm3624pinfromoffset, forKey: .ibm3624pinfromoffset)
            case let .ibm3624pinoffset(ibm3624pinoffset):
                try container.encode(ibm3624pinoffset, forKey: .ibm3624pinoffset)
            case let .ibm3624randompin(ibm3624randompin):
                try container.encode(ibm3624randompin, forKey: .ibm3624randompin)
            case let .visapin(visapin):
                try container.encode(visapin, forKey: .visapin)
            case let .visapinverificationvalue(visapinverificationvalue):
                try container.encode(visapinverificationvalue, forKey: .visapinverificationvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let visapinDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.VisaPin.self, forKey: .visapin)
        if let visapin = visapinDecoded {
            self = .visapin(visapin)
            return
        }
        let visapinverificationvalueDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.VisaPinVerificationValue.self, forKey: .visapinverificationvalue)
        if let visapinverificationvalue = visapinverificationvalueDecoded {
            self = .visapinverificationvalue(visapinverificationvalue)
            return
        }
        let ibm3624pinoffsetDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.Ibm3624PinOffset.self, forKey: .ibm3624pinoffset)
        if let ibm3624pinoffset = ibm3624pinoffsetDecoded {
            self = .ibm3624pinoffset(ibm3624pinoffset)
            return
        }
        let ibm3624naturalpinDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.Ibm3624NaturalPin.self, forKey: .ibm3624naturalpin)
        if let ibm3624naturalpin = ibm3624naturalpinDecoded {
            self = .ibm3624naturalpin(ibm3624naturalpin)
            return
        }
        let ibm3624randompinDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.Ibm3624RandomPin.self, forKey: .ibm3624randompin)
        if let ibm3624randompin = ibm3624randompinDecoded {
            self = .ibm3624randompin(ibm3624randompin)
            return
        }
        let ibm3624pinfromoffsetDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.Ibm3624PinFromOffset.self, forKey: .ibm3624pinfromoffset)
        if let ibm3624pinfromoffset = ibm3624pinfromoffsetDecoded {
            self = .ibm3624pinfromoffset(ibm3624pinfromoffset)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for PIN data generation.
    public enum PinGenerationAttributes: Swift.Equatable {
        /// Parameters that are required to generate or verify Visa PIN.
        case visapin(PaymentCryptographyDataClientTypes.VisaPin)
        /// Parameters that are required to generate or verify Visa PIN Verification Value (PVV).
        case visapinverificationvalue(PaymentCryptographyDataClientTypes.VisaPinVerificationValue)
        /// Parameters that are required to generate or verify Ibm3624 PIN offset PIN.
        case ibm3624pinoffset(PaymentCryptographyDataClientTypes.Ibm3624PinOffset)
        /// Parameters that are required to generate or verify Ibm3624 natural PIN.
        case ibm3624naturalpin(PaymentCryptographyDataClientTypes.Ibm3624NaturalPin)
        /// Parameters that are required to generate or verify Ibm3624 random PIN.
        case ibm3624randompin(PaymentCryptographyDataClientTypes.Ibm3624RandomPin)
        /// Parameters that are required to generate or verify Ibm3624 PIN from offset PIN.
        case ibm3624pinfromoffset(PaymentCryptographyDataClientTypes.Ibm3624PinFromOffset)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes.PinVerificationAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ibm3624pin = "Ibm3624Pin"
        case visapin = "VisaPin"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .ibm3624pin(ibm3624pin):
                try container.encode(ibm3624pin, forKey: .ibm3624pin)
            case let .visapin(visapin):
                try container.encode(visapin, forKey: .visapin)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let visapinDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.VisaPinVerification.self, forKey: .visapin)
        if let visapin = visapinDecoded {
            self = .visapin(visapin)
            return
        }
        let ibm3624pinDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.Ibm3624PinVerification.self, forKey: .ibm3624pin)
        if let ibm3624pin = ibm3624pinDecoded {
            self = .ibm3624pin(ibm3624pin)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for PIN data verification.
    public enum PinVerificationAttributes: Swift.Equatable {
        /// Parameters that are required to generate or verify Visa PIN.
        case visapin(PaymentCryptographyDataClientTypes.VisaPinVerification)
        /// Parameters that are required to generate or verify Ibm3624 PIN.
        case ibm3624pin(PaymentCryptographyDataClientTypes.Ibm3624PinVerification)
        case sdkUnknown(Swift.String)
    }

}

extension ReEncryptDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReEncryptDataInput(incomingEncryptionAttributes: \(Swift.String(describing: incomingEncryptionAttributes)), incomingKeyIdentifier: \(Swift.String(describing: incomingKeyIdentifier)), outgoingEncryptionAttributes: \(Swift.String(describing: outgoingEncryptionAttributes)), outgoingKeyIdentifier: \(Swift.String(describing: outgoingKeyIdentifier)), cipherText: \"CONTENT_REDACTED\")"}
}

extension ReEncryptDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cipherText = "CipherText"
        case incomingEncryptionAttributes = "IncomingEncryptionAttributes"
        case outgoingEncryptionAttributes = "OutgoingEncryptionAttributes"
        case outgoingKeyIdentifier = "OutgoingKeyIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cipherText = self.cipherText {
            try encodeContainer.encode(cipherText, forKey: .cipherText)
        }
        if let incomingEncryptionAttributes = self.incomingEncryptionAttributes {
            try encodeContainer.encode(incomingEncryptionAttributes, forKey: .incomingEncryptionAttributes)
        }
        if let outgoingEncryptionAttributes = self.outgoingEncryptionAttributes {
            try encodeContainer.encode(outgoingEncryptionAttributes, forKey: .outgoingEncryptionAttributes)
        }
        if let outgoingKeyIdentifier = self.outgoingKeyIdentifier {
            try encodeContainer.encode(outgoingKeyIdentifier, forKey: .outgoingKeyIdentifier)
        }
    }
}

extension ReEncryptDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let incomingKeyIdentifier = incomingKeyIdentifier else {
            return nil
        }
        return "/keys/\(incomingKeyIdentifier.urlPercentEncoding())/reencrypt"
    }
}

public struct ReEncryptDataInput: Swift.Equatable {
    /// Ciphertext to be encrypted. The minimum allowed length is 16 bytes and maximum allowed length is 4096 bytes.
    /// This member is required.
    public var cipherText: Swift.String?
    /// The attributes and values for incoming ciphertext.
    /// This member is required.
    public var incomingEncryptionAttributes: PaymentCryptographyDataClientTypes.ReEncryptionAttributes?
    /// The keyARN of the encryption key of incoming ciphertext data.
    /// This member is required.
    public var incomingKeyIdentifier: Swift.String?
    /// The attributes and values for outgoing ciphertext data after encryption by Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var outgoingEncryptionAttributes: PaymentCryptographyDataClientTypes.ReEncryptionAttributes?
    /// The keyARN of the encryption key of outgoing ciphertext data after encryption by Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var outgoingKeyIdentifier: Swift.String?

    public init(
        cipherText: Swift.String? = nil,
        incomingEncryptionAttributes: PaymentCryptographyDataClientTypes.ReEncryptionAttributes? = nil,
        incomingKeyIdentifier: Swift.String? = nil,
        outgoingEncryptionAttributes: PaymentCryptographyDataClientTypes.ReEncryptionAttributes? = nil,
        outgoingKeyIdentifier: Swift.String? = nil
    )
    {
        self.cipherText = cipherText
        self.incomingEncryptionAttributes = incomingEncryptionAttributes
        self.incomingKeyIdentifier = incomingKeyIdentifier
        self.outgoingEncryptionAttributes = outgoingEncryptionAttributes
        self.outgoingKeyIdentifier = outgoingKeyIdentifier
    }
}

struct ReEncryptDataInputBody: Swift.Equatable {
    let outgoingKeyIdentifier: Swift.String?
    let cipherText: Swift.String?
    let incomingEncryptionAttributes: PaymentCryptographyDataClientTypes.ReEncryptionAttributes?
    let outgoingEncryptionAttributes: PaymentCryptographyDataClientTypes.ReEncryptionAttributes?
}

extension ReEncryptDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cipherText = "CipherText"
        case incomingEncryptionAttributes = "IncomingEncryptionAttributes"
        case outgoingEncryptionAttributes = "OutgoingEncryptionAttributes"
        case outgoingKeyIdentifier = "OutgoingKeyIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outgoingKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outgoingKeyIdentifier)
        outgoingKeyIdentifier = outgoingKeyIdentifierDecoded
        let cipherTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cipherText)
        cipherText = cipherTextDecoded
        let incomingEncryptionAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.ReEncryptionAttributes.self, forKey: .incomingEncryptionAttributes)
        incomingEncryptionAttributes = incomingEncryptionAttributesDecoded
        let outgoingEncryptionAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.ReEncryptionAttributes.self, forKey: .outgoingEncryptionAttributes)
        outgoingEncryptionAttributes = outgoingEncryptionAttributesDecoded
    }
}

extension ReEncryptDataOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReEncryptDataOutput(keyArn: \(Swift.String(describing: keyArn)), keyCheckValue: \(Swift.String(describing: keyCheckValue)), cipherText: \"CONTENT_REDACTED\")"}
}

extension ReEncryptDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReEncryptDataOutputBody = try responseDecoder.decode(responseBody: data)
            self.cipherText = output.cipherText
            self.keyArn = output.keyArn
            self.keyCheckValue = output.keyCheckValue
        } else {
            self.cipherText = nil
            self.keyArn = nil
            self.keyCheckValue = nil
        }
    }
}

public struct ReEncryptDataOutput: Swift.Equatable {
    /// The encrypted ciphertext.
    /// This member is required.
    public var cipherText: Swift.String?
    /// The keyARN (Amazon Resource Name) of the encryption key that Amazon Web Services Payment Cryptography uses for plaintext encryption.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography calculates the KCV by using standard algorithms, typically by encrypting 8 or 16 bytes or "00" or "01" and then truncating the result to the first 3 bytes, or 6 hex digits, of the resulting cryptogram.
    /// This member is required.
    public var keyCheckValue: Swift.String?

    public init(
        cipherText: Swift.String? = nil,
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil
    )
    {
        self.cipherText = cipherText
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
    }
}

struct ReEncryptDataOutputBody: Swift.Equatable {
    let keyArn: Swift.String?
    let keyCheckValue: Swift.String?
    let cipherText: Swift.String?
}

extension ReEncryptDataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cipherText = "CipherText"
        case keyArn = "KeyArn"
        case keyCheckValue = "KeyCheckValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyCheckValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyCheckValue)
        keyCheckValue = keyCheckValueDecoded
        let cipherTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cipherText)
        cipherText = cipherTextDecoded
    }
}

enum ReEncryptDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PaymentCryptographyDataClientTypes.ReEncryptionAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dukpt = "Dukpt"
        case symmetric = "Symmetric"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .dukpt(dukpt):
                try container.encode(dukpt, forKey: .dukpt)
            case let .symmetric(symmetric):
                try container.encode(symmetric, forKey: .symmetric)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let symmetricDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.SymmetricEncryptionAttributes.self, forKey: .symmetric)
        if let symmetric = symmetricDecoded {
            self = .symmetric(symmetric)
            return
        }
        let dukptDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.DukptEncryptionAttributes.self, forKey: .dukpt)
        if let dukpt = dukptDecoded {
            self = .dukpt(dukpt)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to perform reencryption operation.
    public enum ReEncryptionAttributes: Swift.Equatable {
        /// Parameters that are required to encrypt data using symmetric keys.
        case symmetric(PaymentCryptographyDataClientTypes.SymmetricEncryptionAttributes)
        /// Parameters that are required to encrypt plaintext data using DUKPT.
        case dukpt(PaymentCryptographyDataClientTypes.DukptEncryptionAttributes)
        case sdkUnknown(Swift.String)
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.resourceId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to an invalid resource error.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The resource that is missing.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        resourceId: Swift.String? = nil
    )
    {
        self.properties.resourceId = resourceId
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let resourceId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension PaymentCryptographyDataClientTypes.SessionKeyAmex: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case panSequenceNumber = "PanSequenceNumber"
        case primaryAccountNumber = "PrimaryAccountNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let panSequenceNumber = self.panSequenceNumber {
            try encodeContainer.encode(panSequenceNumber, forKey: .panSequenceNumber)
        }
        if let primaryAccountNumber = self.primaryAccountNumber {
            try encodeContainer.encode(primaryAccountNumber, forKey: .primaryAccountNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountNumber)
        primaryAccountNumber = primaryAccountNumberDecoded
        let panSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .panSequenceNumber)
        panSequenceNumber = panSequenceNumberDecoded
    }
}

extension PaymentCryptographyDataClientTypes.SessionKeyAmex: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionKeyAmex(panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters to derive session key for an Amex payment card.
    public struct SessionKeyAmex: Swift.Equatable {
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?

        public init(
            panSequenceNumber: Swift.String? = nil,
            primaryAccountNumber: Swift.String? = nil
        )
        {
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.SessionKeyDerivation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amex = "Amex"
        case emv2000 = "Emv2000"
        case emvcommon = "EmvCommon"
        case mastercard = "Mastercard"
        case visa = "Visa"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .amex(amex):
                try container.encode(amex, forKey: .amex)
            case let .emv2000(emv2000):
                try container.encode(emv2000, forKey: .emv2000)
            case let .emvcommon(emvcommon):
                try container.encode(emvcommon, forKey: .emvcommon)
            case let .mastercard(mastercard):
                try container.encode(mastercard, forKey: .mastercard)
            case let .visa(visa):
                try container.encode(visa, forKey: .visa)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let emvcommonDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.SessionKeyEmvCommon.self, forKey: .emvcommon)
        if let emvcommon = emvcommonDecoded {
            self = .emvcommon(emvcommon)
            return
        }
        let mastercardDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.SessionKeyMastercard.self, forKey: .mastercard)
        if let mastercard = mastercardDecoded {
            self = .mastercard(mastercard)
            return
        }
        let emv2000Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.SessionKeyEmv2000.self, forKey: .emv2000)
        if let emv2000 = emv2000Decoded {
            self = .emv2000(emv2000)
            return
        }
        let amexDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.SessionKeyAmex.self, forKey: .amex)
        if let amex = amexDecoded {
            self = .amex(amex)
            return
        }
        let visaDecoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.SessionKeyVisa.self, forKey: .visa)
        if let visa = visaDecoded {
            self = .visa(visa)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters to derive a session key for Authorization Response Cryptogram (ARQC) verification.
    public enum SessionKeyDerivation: Swift.Equatable {
        /// Parameters to derive session key for an Emv common payment card for ARQC verification.
        case emvcommon(PaymentCryptographyDataClientTypes.SessionKeyEmvCommon)
        /// Parameters to derive session key for a Mastercard payment card for ARQC verification.
        case mastercard(PaymentCryptographyDataClientTypes.SessionKeyMastercard)
        /// Parameters to derive session key for an Emv2000 payment card for ARQC verification.
        case emv2000(PaymentCryptographyDataClientTypes.SessionKeyEmv2000)
        /// Parameters to derive session key for an Amex payment card for ARQC verification.
        case amex(PaymentCryptographyDataClientTypes.SessionKeyAmex)
        /// Parameters to derive session key for a Visa payment cardfor ARQC verification.
        case visa(PaymentCryptographyDataClientTypes.SessionKeyVisa)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes {
    public enum SessionKeyDerivationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amex
        case emv2000
        case emvCommonSessionKey
        case mastercardSessionKey
        case visa
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionKeyDerivationMode] {
            return [
                .amex,
                .emv2000,
                .emvCommonSessionKey,
                .mastercardSessionKey,
                .visa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amex: return "AMEX"
            case .emv2000: return "EMV2000"
            case .emvCommonSessionKey: return "EMV_COMMON_SESSION_KEY"
            case .mastercardSessionKey: return "MASTERCARD_SESSION_KEY"
            case .visa: return "VISA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionKeyDerivationMode(rawValue: rawValue) ?? SessionKeyDerivationMode.sdkUnknown(rawValue)
        }
    }
}

extension PaymentCryptographyDataClientTypes.SessionKeyDerivationValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationcryptogram = "ApplicationCryptogram"
        case applicationtransactioncounter = "ApplicationTransactionCounter"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .applicationcryptogram(applicationcryptogram):
                try container.encode(applicationcryptogram, forKey: .applicationcryptogram)
            case let .applicationtransactioncounter(applicationtransactioncounter):
                try container.encode(applicationtransactioncounter, forKey: .applicationtransactioncounter)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let applicationcryptogramDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .applicationcryptogram)
        if let applicationcryptogram = applicationcryptogramDecoded {
            self = .applicationcryptogram(applicationcryptogram)
            return
        }
        let applicationtransactioncounterDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .applicationtransactioncounter)
        if let applicationtransactioncounter = applicationtransactioncounterDecoded {
            self = .applicationtransactioncounter(applicationtransactioncounter)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters to derive session key value using a MAC EMV algorithm.
    public enum SessionKeyDerivationValue: Swift.Equatable {
        /// The cryptogram provided by the terminal during transaction processing.
        case applicationcryptogram(Swift.String)
        /// The transaction counter that is provided by the terminal during transaction processing.
        case applicationtransactioncounter(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes.SessionKeyEmv2000: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationTransactionCounter = "ApplicationTransactionCounter"
        case panSequenceNumber = "PanSequenceNumber"
        case primaryAccountNumber = "PrimaryAccountNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationTransactionCounter = self.applicationTransactionCounter {
            try encodeContainer.encode(applicationTransactionCounter, forKey: .applicationTransactionCounter)
        }
        if let panSequenceNumber = self.panSequenceNumber {
            try encodeContainer.encode(panSequenceNumber, forKey: .panSequenceNumber)
        }
        if let primaryAccountNumber = self.primaryAccountNumber {
            try encodeContainer.encode(primaryAccountNumber, forKey: .primaryAccountNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountNumber)
        primaryAccountNumber = primaryAccountNumberDecoded
        let panSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .panSequenceNumber)
        panSequenceNumber = panSequenceNumberDecoded
        let applicationTransactionCounterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationTransactionCounter)
        applicationTransactionCounter = applicationTransactionCounterDecoded
    }
}

extension PaymentCryptographyDataClientTypes.SessionKeyEmv2000: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionKeyEmv2000(applicationTransactionCounter: \(Swift.String(describing: applicationTransactionCounter)), panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters to derive session key for an Emv2000 payment card for ARQC verification.
    public struct SessionKeyEmv2000: Swift.Equatable {
        /// The transaction counter that is provided by the terminal during transaction processing.
        /// This member is required.
        public var applicationTransactionCounter: Swift.String?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?

        public init(
            applicationTransactionCounter: Swift.String? = nil,
            panSequenceNumber: Swift.String? = nil,
            primaryAccountNumber: Swift.String? = nil
        )
        {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.SessionKeyEmvCommon: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationTransactionCounter = "ApplicationTransactionCounter"
        case panSequenceNumber = "PanSequenceNumber"
        case primaryAccountNumber = "PrimaryAccountNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationTransactionCounter = self.applicationTransactionCounter {
            try encodeContainer.encode(applicationTransactionCounter, forKey: .applicationTransactionCounter)
        }
        if let panSequenceNumber = self.panSequenceNumber {
            try encodeContainer.encode(panSequenceNumber, forKey: .panSequenceNumber)
        }
        if let primaryAccountNumber = self.primaryAccountNumber {
            try encodeContainer.encode(primaryAccountNumber, forKey: .primaryAccountNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountNumber)
        primaryAccountNumber = primaryAccountNumberDecoded
        let panSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .panSequenceNumber)
        panSequenceNumber = panSequenceNumberDecoded
        let applicationTransactionCounterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationTransactionCounter)
        applicationTransactionCounter = applicationTransactionCounterDecoded
    }
}

extension PaymentCryptographyDataClientTypes.SessionKeyEmvCommon: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionKeyEmvCommon(applicationTransactionCounter: \(Swift.String(describing: applicationTransactionCounter)), panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters to derive session key for an Emv common payment card for ARQC verification.
    public struct SessionKeyEmvCommon: Swift.Equatable {
        /// The transaction counter that is provided by the terminal during transaction processing.
        /// This member is required.
        public var applicationTransactionCounter: Swift.String?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?

        public init(
            applicationTransactionCounter: Swift.String? = nil,
            panSequenceNumber: Swift.String? = nil,
            primaryAccountNumber: Swift.String? = nil
        )
        {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.SessionKeyMastercard: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationTransactionCounter = "ApplicationTransactionCounter"
        case panSequenceNumber = "PanSequenceNumber"
        case primaryAccountNumber = "PrimaryAccountNumber"
        case unpredictableNumber = "UnpredictableNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationTransactionCounter = self.applicationTransactionCounter {
            try encodeContainer.encode(applicationTransactionCounter, forKey: .applicationTransactionCounter)
        }
        if let panSequenceNumber = self.panSequenceNumber {
            try encodeContainer.encode(panSequenceNumber, forKey: .panSequenceNumber)
        }
        if let primaryAccountNumber = self.primaryAccountNumber {
            try encodeContainer.encode(primaryAccountNumber, forKey: .primaryAccountNumber)
        }
        if let unpredictableNumber = self.unpredictableNumber {
            try encodeContainer.encode(unpredictableNumber, forKey: .unpredictableNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountNumber)
        primaryAccountNumber = primaryAccountNumberDecoded
        let panSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .panSequenceNumber)
        panSequenceNumber = panSequenceNumberDecoded
        let applicationTransactionCounterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationTransactionCounter)
        applicationTransactionCounter = applicationTransactionCounterDecoded
        let unpredictableNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unpredictableNumber)
        unpredictableNumber = unpredictableNumberDecoded
    }
}

extension PaymentCryptographyDataClientTypes.SessionKeyMastercard: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionKeyMastercard(applicationTransactionCounter: \(Swift.String(describing: applicationTransactionCounter)), panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), unpredictableNumber: \(Swift.String(describing: unpredictableNumber)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters to derive session key for Mastercard payment card for ARQC verification.
    public struct SessionKeyMastercard: Swift.Equatable {
        /// The transaction counter that is provided by the terminal during transaction processing.
        /// This member is required.
        public var applicationTransactionCounter: Swift.String?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?
        /// A random number generated by the issuer.
        /// This member is required.
        public var unpredictableNumber: Swift.String?

        public init(
            applicationTransactionCounter: Swift.String? = nil,
            panSequenceNumber: Swift.String? = nil,
            primaryAccountNumber: Swift.String? = nil,
            unpredictableNumber: Swift.String? = nil
        )
        {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
            self.unpredictableNumber = unpredictableNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.SessionKeyVisa: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case panSequenceNumber = "PanSequenceNumber"
        case primaryAccountNumber = "PrimaryAccountNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let panSequenceNumber = self.panSequenceNumber {
            try encodeContainer.encode(panSequenceNumber, forKey: .panSequenceNumber)
        }
        if let primaryAccountNumber = self.primaryAccountNumber {
            try encodeContainer.encode(primaryAccountNumber, forKey: .primaryAccountNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountNumber)
        primaryAccountNumber = primaryAccountNumberDecoded
        let panSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .panSequenceNumber)
        panSequenceNumber = panSequenceNumberDecoded
    }
}

extension PaymentCryptographyDataClientTypes.SessionKeyVisa: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionKeyVisa(panSequenceNumber: \(Swift.String(describing: panSequenceNumber)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters to derive session key for Visa payment card for ARQC verification.
    public struct SessionKeyVisa: Swift.Equatable {
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        /// This member is required.
        public var panSequenceNumber: Swift.String?
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?

        public init(
            panSequenceNumber: Swift.String? = nil,
            primaryAccountNumber: Swift.String? = nil
        )
        {
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.SymmetricEncryptionAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initializationVector = "InitializationVector"
        case mode = "Mode"
        case paddingType = "PaddingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initializationVector = self.initializationVector {
            try encodeContainer.encode(initializationVector, forKey: .initializationVector)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let paddingType = self.paddingType {
            try encodeContainer.encode(paddingType.rawValue, forKey: .paddingType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.EncryptionMode.self, forKey: .mode)
        mode = modeDecoded
        let initializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initializationVector)
        initializationVector = initializationVectorDecoded
        let paddingTypeDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.PaddingType.self, forKey: .paddingType)
        paddingType = paddingTypeDecoded
    }
}

extension PaymentCryptographyDataClientTypes.SymmetricEncryptionAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SymmetricEncryptionAttributes(mode: \(Swift.String(describing: mode)), paddingType: \(Swift.String(describing: paddingType)), initializationVector: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters requried to encrypt plaintext data using symmetric keys.
    public struct SymmetricEncryptionAttributes: Swift.Equatable {
        /// An input to cryptographic primitive used to provide the intial state. The InitializationVector is typically required have a random or psuedo-random value, but sometimes it only needs to be unpredictable or unique. If a value is not provided, Amazon Web Services Payment Cryptography generates a random value.
        public var initializationVector: Swift.String?
        /// The block cipher mode of operation. Block ciphers are designed to encrypt a block of data of fixed size (for example, 128 bits). The size of the input block is usually same as the size of the encrypted output block, while the key length can be different. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block.
        /// This member is required.
        public var mode: PaymentCryptographyDataClientTypes.EncryptionMode?
        /// The padding to be included with the data.
        public var paddingType: PaymentCryptographyDataClientTypes.PaddingType?

        public init(
            initializationVector: Swift.String? = nil,
            mode: PaymentCryptographyDataClientTypes.EncryptionMode? = nil,
            paddingType: PaymentCryptographyDataClientTypes.PaddingType? = nil
        )
        {
            self.initializationVector = initializationVector
            self.mode = mode
            self.paddingType = paddingType
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TranslatePinDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TranslatePinDataInput(incomingDukptAttributes: \(Swift.String(describing: incomingDukptAttributes)), incomingKeyIdentifier: \(Swift.String(describing: incomingKeyIdentifier)), incomingTranslationAttributes: \(Swift.String(describing: incomingTranslationAttributes)), outgoingDukptAttributes: \(Swift.String(describing: outgoingDukptAttributes)), outgoingKeyIdentifier: \(Swift.String(describing: outgoingKeyIdentifier)), outgoingTranslationAttributes: \(Swift.String(describing: outgoingTranslationAttributes)), encryptedPinBlock: \"CONTENT_REDACTED\")"}
}

extension TranslatePinDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptedPinBlock = "EncryptedPinBlock"
        case incomingDukptAttributes = "IncomingDukptAttributes"
        case incomingKeyIdentifier = "IncomingKeyIdentifier"
        case incomingTranslationAttributes = "IncomingTranslationAttributes"
        case outgoingDukptAttributes = "OutgoingDukptAttributes"
        case outgoingKeyIdentifier = "OutgoingKeyIdentifier"
        case outgoingTranslationAttributes = "OutgoingTranslationAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptedPinBlock = self.encryptedPinBlock {
            try encodeContainer.encode(encryptedPinBlock, forKey: .encryptedPinBlock)
        }
        if let incomingDukptAttributes = self.incomingDukptAttributes {
            try encodeContainer.encode(incomingDukptAttributes, forKey: .incomingDukptAttributes)
        }
        if let incomingKeyIdentifier = self.incomingKeyIdentifier {
            try encodeContainer.encode(incomingKeyIdentifier, forKey: .incomingKeyIdentifier)
        }
        if let incomingTranslationAttributes = self.incomingTranslationAttributes {
            try encodeContainer.encode(incomingTranslationAttributes, forKey: .incomingTranslationAttributes)
        }
        if let outgoingDukptAttributes = self.outgoingDukptAttributes {
            try encodeContainer.encode(outgoingDukptAttributes, forKey: .outgoingDukptAttributes)
        }
        if let outgoingKeyIdentifier = self.outgoingKeyIdentifier {
            try encodeContainer.encode(outgoingKeyIdentifier, forKey: .outgoingKeyIdentifier)
        }
        if let outgoingTranslationAttributes = self.outgoingTranslationAttributes {
            try encodeContainer.encode(outgoingTranslationAttributes, forKey: .outgoingTranslationAttributes)
        }
    }
}

extension TranslatePinDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/pindata/translate"
    }
}

public struct TranslatePinDataInput: Swift.Equatable {
    /// The encrypted PIN block data that Amazon Web Services Payment Cryptography translates.
    /// This member is required.
    public var encryptedPinBlock: Swift.String?
    /// The attributes and values to use for incoming DUKPT encryption key for PIN block tranlation.
    public var incomingDukptAttributes: PaymentCryptographyDataClientTypes.DukptDerivationAttributes?
    /// The keyARN of the encryption key under which incoming PIN block data is encrypted. This key type can be PEK or BDK.
    /// This member is required.
    public var incomingKeyIdentifier: Swift.String?
    /// The format of the incoming PIN block data for tranlation within Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var incomingTranslationAttributes: PaymentCryptographyDataClientTypes.TranslationIsoFormats?
    /// The attributes and values to use for outgoing DUKPT encryption key after PIN block translation.
    public var outgoingDukptAttributes: PaymentCryptographyDataClientTypes.DukptDerivationAttributes?
    /// The keyARN of the encryption key for encrypting outgoing PIN block data. This key type can be PEK or BDK.
    /// This member is required.
    public var outgoingKeyIdentifier: Swift.String?
    /// The format of the outgoing PIN block data after tranlation by Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var outgoingTranslationAttributes: PaymentCryptographyDataClientTypes.TranslationIsoFormats?

    public init(
        encryptedPinBlock: Swift.String? = nil,
        incomingDukptAttributes: PaymentCryptographyDataClientTypes.DukptDerivationAttributes? = nil,
        incomingKeyIdentifier: Swift.String? = nil,
        incomingTranslationAttributes: PaymentCryptographyDataClientTypes.TranslationIsoFormats? = nil,
        outgoingDukptAttributes: PaymentCryptographyDataClientTypes.DukptDerivationAttributes? = nil,
        outgoingKeyIdentifier: Swift.String? = nil,
        outgoingTranslationAttributes: PaymentCryptographyDataClientTypes.TranslationIsoFormats? = nil
    )
    {
        self.encryptedPinBlock = encryptedPinBlock
        self.incomingDukptAttributes = incomingDukptAttributes
        self.incomingKeyIdentifier = incomingKeyIdentifier
        self.incomingTranslationAttributes = incomingTranslationAttributes
        self.outgoingDukptAttributes = outgoingDukptAttributes
        self.outgoingKeyIdentifier = outgoingKeyIdentifier
        self.outgoingTranslationAttributes = outgoingTranslationAttributes
    }
}

struct TranslatePinDataInputBody: Swift.Equatable {
    let incomingKeyIdentifier: Swift.String?
    let outgoingKeyIdentifier: Swift.String?
    let incomingTranslationAttributes: PaymentCryptographyDataClientTypes.TranslationIsoFormats?
    let outgoingTranslationAttributes: PaymentCryptographyDataClientTypes.TranslationIsoFormats?
    let encryptedPinBlock: Swift.String?
    let incomingDukptAttributes: PaymentCryptographyDataClientTypes.DukptDerivationAttributes?
    let outgoingDukptAttributes: PaymentCryptographyDataClientTypes.DukptDerivationAttributes?
}

extension TranslatePinDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptedPinBlock = "EncryptedPinBlock"
        case incomingDukptAttributes = "IncomingDukptAttributes"
        case incomingKeyIdentifier = "IncomingKeyIdentifier"
        case incomingTranslationAttributes = "IncomingTranslationAttributes"
        case outgoingDukptAttributes = "OutgoingDukptAttributes"
        case outgoingKeyIdentifier = "OutgoingKeyIdentifier"
        case outgoingTranslationAttributes = "OutgoingTranslationAttributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incomingKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incomingKeyIdentifier)
        incomingKeyIdentifier = incomingKeyIdentifierDecoded
        let outgoingKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outgoingKeyIdentifier)
        outgoingKeyIdentifier = outgoingKeyIdentifierDecoded
        let incomingTranslationAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.TranslationIsoFormats.self, forKey: .incomingTranslationAttributes)
        incomingTranslationAttributes = incomingTranslationAttributesDecoded
        let outgoingTranslationAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.TranslationIsoFormats.self, forKey: .outgoingTranslationAttributes)
        outgoingTranslationAttributes = outgoingTranslationAttributesDecoded
        let encryptedPinBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptedPinBlock)
        encryptedPinBlock = encryptedPinBlockDecoded
        let incomingDukptAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.DukptDerivationAttributes.self, forKey: .incomingDukptAttributes)
        incomingDukptAttributes = incomingDukptAttributesDecoded
        let outgoingDukptAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.DukptDerivationAttributes.self, forKey: .outgoingDukptAttributes)
        outgoingDukptAttributes = outgoingDukptAttributesDecoded
    }
}

extension TranslatePinDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TranslatePinDataOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyArn = output.keyArn
            self.keyCheckValue = output.keyCheckValue
            self.pinBlock = output.pinBlock
        } else {
            self.keyArn = nil
            self.keyCheckValue = nil
            self.pinBlock = nil
        }
    }
}

public struct TranslatePinDataOutput: Swift.Equatable {
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses to encrypt outgoing PIN block data after translation.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography calculates the KCV by using standard algorithms, typically by encrypting 8 or 16 bytes or "00" or "01" and then truncating the result to the first 3 bytes, or 6 hex digits, of the resulting cryptogram.
    /// This member is required.
    public var keyCheckValue: Swift.String?
    /// The ougoing encrypted PIN block data after tranlation.
    /// This member is required.
    public var pinBlock: Swift.String?

    public init(
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil,
        pinBlock: Swift.String? = nil
    )
    {
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
        self.pinBlock = pinBlock
    }
}

struct TranslatePinDataOutputBody: Swift.Equatable {
    let pinBlock: Swift.String?
    let keyArn: Swift.String?
    let keyCheckValue: Swift.String?
}

extension TranslatePinDataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn = "KeyArn"
        case keyCheckValue = "KeyCheckValue"
        case pinBlock = "PinBlock"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pinBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pinBlock)
        pinBlock = pinBlockDecoded
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyCheckValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyCheckValue)
        keyCheckValue = keyCheckValueDecoded
    }
}

enum TranslatePinDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PaymentCryptographyDataClientTypes.TranslationIsoFormats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoformat0 = "IsoFormat0"
        case isoformat1 = "IsoFormat1"
        case isoformat3 = "IsoFormat3"
        case isoformat4 = "IsoFormat4"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .isoformat0(isoformat0):
                try container.encode(isoformat0, forKey: .isoformat0)
            case let .isoformat1(isoformat1):
                try container.encode(isoformat1, forKey: .isoformat1)
            case let .isoformat3(isoformat3):
                try container.encode(isoformat3, forKey: .isoformat3)
            case let .isoformat4(isoformat4):
                try container.encode(isoformat4, forKey: .isoformat4)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let isoformat0Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034.self, forKey: .isoformat0)
        if let isoformat0 = isoformat0Decoded {
            self = .isoformat0(isoformat0)
            return
        }
        let isoformat1Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat1.self, forKey: .isoformat1)
        if let isoformat1 = isoformat1Decoded {
            self = .isoformat1(isoformat1)
            return
        }
        let isoformat3Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034.self, forKey: .isoformat3)
        if let isoformat3 = isoformat3Decoded {
            self = .isoformat3(isoformat3)
            return
        }
        let isoformat4Decoded = try values.decodeIfPresent(PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034.self, forKey: .isoformat4)
        if let isoformat4 = isoformat4Decoded {
            self = .isoformat4(isoformat4)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for translation between ISO9564 PIN block formats 0,1,3,4.
    public enum TranslationIsoFormats: Swift.Equatable {
        /// Parameters that are required for ISO9564 PIN format 0 tranlation.
        case isoformat0(PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034)
        /// Parameters that are required for ISO9564 PIN format 1 tranlation.
        case isoformat1(PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat1)
        /// Parameters that are required for ISO9564 PIN format 3 tranlation.
        case isoformat3(PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034)
        /// Parameters that are required for ISO9564 PIN format 4 tranlation.
        case isoformat4(PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034)
        case sdkUnknown(Swift.String)
    }

}

extension PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case primaryAccountNumber = "PrimaryAccountNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let primaryAccountNumber = self.primaryAccountNumber {
            try encodeContainer.encode(primaryAccountNumber, forKey: .primaryAccountNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountNumber)
        primaryAccountNumber = primaryAccountNumberDecoded
    }
}

extension PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat034: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TranslationPinDataIsoFormat034(primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for tranlation between ISO9564 PIN format 0,3,4 tranlation.
    public struct TranslationPinDataIsoFormat034: Swift.Equatable {
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        /// This member is required.
        public var primaryAccountNumber: Swift.String?

        public init(
            primaryAccountNumber: Swift.String? = nil
        )
        {
            self.primaryAccountNumber = primaryAccountNumber
        }
    }

}

extension PaymentCryptographyDataClientTypes.TranslationPinDataIsoFormat1: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required for ISO9564 PIN format 1 tranlation.
    public struct TranslationPinDataIsoFormat1: Swift.Equatable {

        public init() { }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to an invalid request error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The request was denied due to an invalid request error.
        public internal(set) var fieldList: [PaymentCryptographyDataClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [PaymentCryptographyDataClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let fieldList: [PaymentCryptographyDataClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([PaymentCryptographyDataClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[PaymentCryptographyDataClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [PaymentCryptographyDataClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension PaymentCryptographyDataClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// The request was denied due to an invalid request error.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The request was denied due to an invalid request error.
        /// This member is required.
        public var message: Swift.String?
        /// The request was denied due to an invalid request error.
        /// This member is required.
        public var path: Swift.String?

        public init(
            message: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.message = message
            self.path = path
        }
    }

}

extension VerificationFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: VerificationFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This request failed verification.
public struct VerificationFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        /// This member is required.
        public internal(set) var reason: PaymentCryptographyDataClientTypes.VerificationFailedReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "VerificationFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PaymentCryptographyDataClientTypes.VerificationFailedReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct VerificationFailedExceptionBody: Swift.Equatable {
    let reason: PaymentCryptographyDataClientTypes.VerificationFailedReason?
    let message: Swift.String?
}

extension VerificationFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.VerificationFailedReason.self, forKey: .reason)
        reason = reasonDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    public enum VerificationFailedReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidAuthRequestCryptogram
        case invalidMac
        case invalidPin
        case invalidValidationData
        case sdkUnknown(Swift.String)

        public static var allCases: [VerificationFailedReason] {
            return [
                .invalidAuthRequestCryptogram,
                .invalidMac,
                .invalidPin,
                .invalidValidationData,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidAuthRequestCryptogram: return "INVALID_AUTH_REQUEST_CRYPTOGRAM"
            case .invalidMac: return "INVALID_MAC"
            case .invalidPin: return "INVALID_PIN"
            case .invalidValidationData: return "INVALID_VALIDATION_DATA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VerificationFailedReason(rawValue: rawValue) ?? VerificationFailedReason.sdkUnknown(rawValue)
        }
    }
}

extension VerifyAuthRequestCryptogramInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authRequestCryptogram = "AuthRequestCryptogram"
        case authResponseAttributes = "AuthResponseAttributes"
        case keyIdentifier = "KeyIdentifier"
        case majorKeyDerivationMode = "MajorKeyDerivationMode"
        case sessionKeyDerivationAttributes = "SessionKeyDerivationAttributes"
        case transactionData = "TransactionData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authRequestCryptogram = self.authRequestCryptogram {
            try encodeContainer.encode(authRequestCryptogram, forKey: .authRequestCryptogram)
        }
        if let authResponseAttributes = self.authResponseAttributes {
            try encodeContainer.encode(authResponseAttributes, forKey: .authResponseAttributes)
        }
        if let keyIdentifier = self.keyIdentifier {
            try encodeContainer.encode(keyIdentifier, forKey: .keyIdentifier)
        }
        if let majorKeyDerivationMode = self.majorKeyDerivationMode {
            try encodeContainer.encode(majorKeyDerivationMode.rawValue, forKey: .majorKeyDerivationMode)
        }
        if let sessionKeyDerivationAttributes = self.sessionKeyDerivationAttributes {
            try encodeContainer.encode(sessionKeyDerivationAttributes, forKey: .sessionKeyDerivationAttributes)
        }
        if let transactionData = self.transactionData {
            try encodeContainer.encode(transactionData, forKey: .transactionData)
        }
    }
}

extension VerifyAuthRequestCryptogramInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cryptogram/verify"
    }
}

public struct VerifyAuthRequestCryptogramInput: Swift.Equatable {
    /// The auth request cryptogram imported into Amazon Web Services Payment Cryptography for ARQC verification using a major encryption key and transaction data.
    /// This member is required.
    public var authRequestCryptogram: Swift.String?
    /// The attributes and values for auth request cryptogram verification. These parameters are required in case using ARPC Method 1 or Method 2 for ARQC verification.
    public var authResponseAttributes: PaymentCryptographyDataClientTypes.CryptogramAuthResponse?
    /// The keyARN of the major encryption key that Amazon Web Services Payment Cryptography uses for ARQC verification.
    /// This member is required.
    public var keyIdentifier: Swift.String?
    /// The method to use when deriving the major encryption key for ARQC verification within Amazon Web Services Payment Cryptography. The same key derivation mode was used for ARQC generation outside of Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var majorKeyDerivationMode: PaymentCryptographyDataClientTypes.MajorKeyDerivationMode?
    /// The attributes and values to use for deriving a session key for ARQC verification within Amazon Web Services Payment Cryptography. The same attributes were used for ARQC generation outside of Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var sessionKeyDerivationAttributes: PaymentCryptographyDataClientTypes.SessionKeyDerivation?
    /// The transaction data that Amazon Web Services Payment Cryptography uses for ARQC verification. The same transaction is used for ARQC generation outside of Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var transactionData: Swift.String?

    public init(
        authRequestCryptogram: Swift.String? = nil,
        authResponseAttributes: PaymentCryptographyDataClientTypes.CryptogramAuthResponse? = nil,
        keyIdentifier: Swift.String? = nil,
        majorKeyDerivationMode: PaymentCryptographyDataClientTypes.MajorKeyDerivationMode? = nil,
        sessionKeyDerivationAttributes: PaymentCryptographyDataClientTypes.SessionKeyDerivation? = nil,
        transactionData: Swift.String? = nil
    )
    {
        self.authRequestCryptogram = authRequestCryptogram
        self.authResponseAttributes = authResponseAttributes
        self.keyIdentifier = keyIdentifier
        self.majorKeyDerivationMode = majorKeyDerivationMode
        self.sessionKeyDerivationAttributes = sessionKeyDerivationAttributes
        self.transactionData = transactionData
    }
}

struct VerifyAuthRequestCryptogramInputBody: Swift.Equatable {
    let keyIdentifier: Swift.String?
    let transactionData: Swift.String?
    let authRequestCryptogram: Swift.String?
    let majorKeyDerivationMode: PaymentCryptographyDataClientTypes.MajorKeyDerivationMode?
    let sessionKeyDerivationAttributes: PaymentCryptographyDataClientTypes.SessionKeyDerivation?
    let authResponseAttributes: PaymentCryptographyDataClientTypes.CryptogramAuthResponse?
}

extension VerifyAuthRequestCryptogramInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authRequestCryptogram = "AuthRequestCryptogram"
        case authResponseAttributes = "AuthResponseAttributes"
        case keyIdentifier = "KeyIdentifier"
        case majorKeyDerivationMode = "MajorKeyDerivationMode"
        case sessionKeyDerivationAttributes = "SessionKeyDerivationAttributes"
        case transactionData = "TransactionData"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyIdentifier)
        keyIdentifier = keyIdentifierDecoded
        let transactionDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionData)
        transactionData = transactionDataDecoded
        let authRequestCryptogramDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authRequestCryptogram)
        authRequestCryptogram = authRequestCryptogramDecoded
        let majorKeyDerivationModeDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.MajorKeyDerivationMode.self, forKey: .majorKeyDerivationMode)
        majorKeyDerivationMode = majorKeyDerivationModeDecoded
        let sessionKeyDerivationAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.SessionKeyDerivation.self, forKey: .sessionKeyDerivationAttributes)
        sessionKeyDerivationAttributes = sessionKeyDerivationAttributesDecoded
        let authResponseAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.CryptogramAuthResponse.self, forKey: .authResponseAttributes)
        authResponseAttributes = authResponseAttributesDecoded
    }
}

extension VerifyAuthRequestCryptogramOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: VerifyAuthRequestCryptogramOutputBody = try responseDecoder.decode(responseBody: data)
            self.authResponseValue = output.authResponseValue
            self.keyArn = output.keyArn
            self.keyCheckValue = output.keyCheckValue
        } else {
            self.authResponseValue = nil
            self.keyArn = nil
            self.keyCheckValue = nil
        }
    }
}

public struct VerifyAuthRequestCryptogramOutput: Swift.Equatable {
    /// The result for ARQC verification or ARPC generation within Amazon Web Services Payment Cryptography.
    public var authResponseValue: Swift.String?
    /// The keyARN of the major encryption key that Amazon Web Services Payment Cryptography uses for ARQC verification.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography calculates the KCV by using standard algorithms, typically by encrypting 8 or 16 bytes or "00" or "01" and then truncating the result to the first 3 bytes, or 6 hex digits, of the resulting cryptogram.
    /// This member is required.
    public var keyCheckValue: Swift.String?

    public init(
        authResponseValue: Swift.String? = nil,
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil
    )
    {
        self.authResponseValue = authResponseValue
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
    }
}

struct VerifyAuthRequestCryptogramOutputBody: Swift.Equatable {
    let keyArn: Swift.String?
    let keyCheckValue: Swift.String?
    let authResponseValue: Swift.String?
}

extension VerifyAuthRequestCryptogramOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authResponseValue = "AuthResponseValue"
        case keyArn = "KeyArn"
        case keyCheckValue = "KeyCheckValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyCheckValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyCheckValue)
        keyCheckValue = keyCheckValueDecoded
        let authResponseValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authResponseValue)
        authResponseValue = authResponseValueDecoded
    }
}

enum VerifyAuthRequestCryptogramOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VerificationFailedException": return try await VerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VerifyCardValidationDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VerifyCardValidationDataInput(keyIdentifier: \(Swift.String(describing: keyIdentifier)), validationData: \(Swift.String(describing: validationData)), verificationAttributes: \(Swift.String(describing: verificationAttributes)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension VerifyCardValidationDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyIdentifier = "KeyIdentifier"
        case primaryAccountNumber = "PrimaryAccountNumber"
        case validationData = "ValidationData"
        case verificationAttributes = "VerificationAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyIdentifier = self.keyIdentifier {
            try encodeContainer.encode(keyIdentifier, forKey: .keyIdentifier)
        }
        if let primaryAccountNumber = self.primaryAccountNumber {
            try encodeContainer.encode(primaryAccountNumber, forKey: .primaryAccountNumber)
        }
        if let validationData = self.validationData {
            try encodeContainer.encode(validationData, forKey: .validationData)
        }
        if let verificationAttributes = self.verificationAttributes {
            try encodeContainer.encode(verificationAttributes, forKey: .verificationAttributes)
        }
    }
}

extension VerifyCardValidationDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cardvalidationdata/verify"
    }
}

public struct VerifyCardValidationDataInput: Swift.Equatable {
    /// The keyARN of the CVK encryption key that Amazon Web Services Payment Cryptography uses to verify card data.
    /// This member is required.
    public var keyIdentifier: Swift.String?
    /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.
    /// This member is required.
    public var primaryAccountNumber: Swift.String?
    /// The CVV or CSC value for use for card data verification within Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var validationData: Swift.String?
    /// The algorithm to use for verification of card data within Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var verificationAttributes: PaymentCryptographyDataClientTypes.CardVerificationAttributes?

    public init(
        keyIdentifier: Swift.String? = nil,
        primaryAccountNumber: Swift.String? = nil,
        validationData: Swift.String? = nil,
        verificationAttributes: PaymentCryptographyDataClientTypes.CardVerificationAttributes? = nil
    )
    {
        self.keyIdentifier = keyIdentifier
        self.primaryAccountNumber = primaryAccountNumber
        self.validationData = validationData
        self.verificationAttributes = verificationAttributes
    }
}

struct VerifyCardValidationDataInputBody: Swift.Equatable {
    let keyIdentifier: Swift.String?
    let primaryAccountNumber: Swift.String?
    let verificationAttributes: PaymentCryptographyDataClientTypes.CardVerificationAttributes?
    let validationData: Swift.String?
}

extension VerifyCardValidationDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyIdentifier = "KeyIdentifier"
        case primaryAccountNumber = "PrimaryAccountNumber"
        case validationData = "ValidationData"
        case verificationAttributes = "VerificationAttributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyIdentifier)
        keyIdentifier = keyIdentifierDecoded
        let primaryAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountNumber)
        primaryAccountNumber = primaryAccountNumberDecoded
        let verificationAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.CardVerificationAttributes.self, forKey: .verificationAttributes)
        verificationAttributes = verificationAttributesDecoded
        let validationDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationData)
        validationData = validationDataDecoded
    }
}

extension VerifyCardValidationDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: VerifyCardValidationDataOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyArn = output.keyArn
            self.keyCheckValue = output.keyCheckValue
        } else {
            self.keyArn = nil
            self.keyCheckValue = nil
        }
    }
}

public struct VerifyCardValidationDataOutput: Swift.Equatable {
    /// The keyARN of the CVK encryption key that Amazon Web Services Payment Cryptography uses to verify CVV or CSC.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography calculates the KCV by using standard algorithms, typically by encrypting 8 or 16 bytes or "00" or "01" and then truncating the result to the first 3 bytes, or 6 hex digits, of the resulting cryptogram.
    /// This member is required.
    public var keyCheckValue: Swift.String?

    public init(
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil
    )
    {
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
    }
}

struct VerifyCardValidationDataOutputBody: Swift.Equatable {
    let keyArn: Swift.String?
    let keyCheckValue: Swift.String?
}

extension VerifyCardValidationDataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn = "KeyArn"
        case keyCheckValue = "KeyCheckValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyCheckValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyCheckValue)
        keyCheckValue = keyCheckValueDecoded
    }
}

enum VerifyCardValidationDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VerificationFailedException": return try await VerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VerifyMacInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VerifyMacInput(keyIdentifier: \(Swift.String(describing: keyIdentifier)), macLength: \(Swift.String(describing: macLength)), verificationAttributes: \(Swift.String(describing: verificationAttributes)), mac: \"CONTENT_REDACTED\", messageData: \"CONTENT_REDACTED\")"}
}

extension VerifyMacInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyIdentifier = "KeyIdentifier"
        case mac = "Mac"
        case macLength = "MacLength"
        case messageData = "MessageData"
        case verificationAttributes = "VerificationAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyIdentifier = self.keyIdentifier {
            try encodeContainer.encode(keyIdentifier, forKey: .keyIdentifier)
        }
        if let mac = self.mac {
            try encodeContainer.encode(mac, forKey: .mac)
        }
        if let macLength = self.macLength {
            try encodeContainer.encode(macLength, forKey: .macLength)
        }
        if let messageData = self.messageData {
            try encodeContainer.encode(messageData, forKey: .messageData)
        }
        if let verificationAttributes = self.verificationAttributes {
            try encodeContainer.encode(verificationAttributes, forKey: .verificationAttributes)
        }
    }
}

extension VerifyMacInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/mac/verify"
    }
}

public struct VerifyMacInput: Swift.Equatable {
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses to verify MAC data.
    /// This member is required.
    public var keyIdentifier: Swift.String?
    /// The MAC being verified.
    /// This member is required.
    public var mac: Swift.String?
    /// The length of the MAC.
    public var macLength: Swift.Int?
    /// The data on for which MAC is under verification.
    /// This member is required.
    public var messageData: Swift.String?
    /// The attributes and data values to use for MAC verification within Amazon Web Services Payment Cryptography.
    /// This member is required.
    public var verificationAttributes: PaymentCryptographyDataClientTypes.MacAttributes?

    public init(
        keyIdentifier: Swift.String? = nil,
        mac: Swift.String? = nil,
        macLength: Swift.Int? = nil,
        messageData: Swift.String? = nil,
        verificationAttributes: PaymentCryptographyDataClientTypes.MacAttributes? = nil
    )
    {
        self.keyIdentifier = keyIdentifier
        self.mac = mac
        self.macLength = macLength
        self.messageData = messageData
        self.verificationAttributes = verificationAttributes
    }
}

struct VerifyMacInputBody: Swift.Equatable {
    let keyIdentifier: Swift.String?
    let messageData: Swift.String?
    let mac: Swift.String?
    let verificationAttributes: PaymentCryptographyDataClientTypes.MacAttributes?
    let macLength: Swift.Int?
}

extension VerifyMacInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyIdentifier = "KeyIdentifier"
        case mac = "Mac"
        case macLength = "MacLength"
        case messageData = "MessageData"
        case verificationAttributes = "VerificationAttributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyIdentifier)
        keyIdentifier = keyIdentifierDecoded
        let messageDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageData)
        messageData = messageDataDecoded
        let macDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mac)
        mac = macDecoded
        let verificationAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.MacAttributes.self, forKey: .verificationAttributes)
        verificationAttributes = verificationAttributesDecoded
        let macLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .macLength)
        macLength = macLengthDecoded
    }
}

extension VerifyMacOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: VerifyMacOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyArn = output.keyArn
            self.keyCheckValue = output.keyCheckValue
        } else {
            self.keyArn = nil
            self.keyCheckValue = nil
        }
    }
}

public struct VerifyMacOutput: Swift.Equatable {
    /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for MAC verification.
    /// This member is required.
    public var keyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography calculates the KCV by using standard algorithms, typically by encrypting 8 or 16 bytes or "00" or "01" and then truncating the result to the first 3 bytes, or 6 hex digits, of the resulting cryptogram.
    /// This member is required.
    public var keyCheckValue: Swift.String?

    public init(
        keyArn: Swift.String? = nil,
        keyCheckValue: Swift.String? = nil
    )
    {
        self.keyArn = keyArn
        self.keyCheckValue = keyCheckValue
    }
}

struct VerifyMacOutputBody: Swift.Equatable {
    let keyArn: Swift.String?
    let keyCheckValue: Swift.String?
}

extension VerifyMacOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn = "KeyArn"
        case keyCheckValue = "KeyCheckValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyCheckValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyCheckValue)
        keyCheckValue = keyCheckValueDecoded
    }
}

enum VerifyMacOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VerificationFailedException": return try await VerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VerifyPinDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VerifyPinDataInput(dukptAttributes: \(Swift.String(describing: dukptAttributes)), encryptedPinBlock: \(Swift.String(describing: encryptedPinBlock)), encryptionKeyIdentifier: \(Swift.String(describing: encryptionKeyIdentifier)), pinBlockFormat: \(Swift.String(describing: pinBlockFormat)), pinDataLength: \(Swift.String(describing: pinDataLength)), verificationAttributes: \(Swift.String(describing: verificationAttributes)), verificationKeyIdentifier: \(Swift.String(describing: verificationKeyIdentifier)), primaryAccountNumber: \"CONTENT_REDACTED\")"}
}

extension VerifyPinDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dukptAttributes = "DukptAttributes"
        case encryptedPinBlock = "EncryptedPinBlock"
        case encryptionKeyIdentifier = "EncryptionKeyIdentifier"
        case pinBlockFormat = "PinBlockFormat"
        case pinDataLength = "PinDataLength"
        case primaryAccountNumber = "PrimaryAccountNumber"
        case verificationAttributes = "VerificationAttributes"
        case verificationKeyIdentifier = "VerificationKeyIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dukptAttributes = self.dukptAttributes {
            try encodeContainer.encode(dukptAttributes, forKey: .dukptAttributes)
        }
        if let encryptedPinBlock = self.encryptedPinBlock {
            try encodeContainer.encode(encryptedPinBlock, forKey: .encryptedPinBlock)
        }
        if let encryptionKeyIdentifier = self.encryptionKeyIdentifier {
            try encodeContainer.encode(encryptionKeyIdentifier, forKey: .encryptionKeyIdentifier)
        }
        if let pinBlockFormat = self.pinBlockFormat {
            try encodeContainer.encode(pinBlockFormat.rawValue, forKey: .pinBlockFormat)
        }
        if let pinDataLength = self.pinDataLength {
            try encodeContainer.encode(pinDataLength, forKey: .pinDataLength)
        }
        if let primaryAccountNumber = self.primaryAccountNumber {
            try encodeContainer.encode(primaryAccountNumber, forKey: .primaryAccountNumber)
        }
        if let verificationAttributes = self.verificationAttributes {
            try encodeContainer.encode(verificationAttributes, forKey: .verificationAttributes)
        }
        if let verificationKeyIdentifier = self.verificationKeyIdentifier {
            try encodeContainer.encode(verificationKeyIdentifier, forKey: .verificationKeyIdentifier)
        }
    }
}

extension VerifyPinDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/pindata/verify"
    }
}

public struct VerifyPinDataInput: Swift.Equatable {
    /// The attributes and values for the DUKPT encrypted PIN block data.
    public var dukptAttributes: PaymentCryptographyDataClientTypes.DukptAttributes?
    /// The encrypted PIN block data that Amazon Web Services Payment Cryptography verifies.
    /// This member is required.
    public var encryptedPinBlock: Swift.String?
    /// The keyARN of the encryption key under which the PIN block data is encrypted. This key type can be PEK or BDK.
    /// This member is required.
    public var encryptionKeyIdentifier: Swift.String?
    /// The PIN encoding format for pin data generation as specified in ISO 9564. Amazon Web Services Payment Cryptography supports ISO_Format_0 and ISO_Format_3. The ISO_Format_0 PIN block format is equivalent to the ANSI X9.8, VISA-1, and ECI-1 PIN block formats. It is similar to a VISA-4 PIN block format. It supports a PIN from 4 to 12 digits in length. The ISO_Format_3 PIN block format is the same as ISO_Format_0 except that the fill digits are random values from 10 to 15.
    /// This member is required.
    public var pinBlockFormat: PaymentCryptographyDataClientTypes.PinBlockFormatForPinData?
    /// The length of PIN being verified.
    public var pinDataLength: Swift.Int?
    /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.
    /// This member is required.
    public var primaryAccountNumber: Swift.String?
    /// The attributes and values for PIN data verification.
    /// This member is required.
    public var verificationAttributes: PaymentCryptographyDataClientTypes.PinVerificationAttributes?
    /// The keyARN of the PIN verification key.
    /// This member is required.
    public var verificationKeyIdentifier: Swift.String?

    public init(
        dukptAttributes: PaymentCryptographyDataClientTypes.DukptAttributes? = nil,
        encryptedPinBlock: Swift.String? = nil,
        encryptionKeyIdentifier: Swift.String? = nil,
        pinBlockFormat: PaymentCryptographyDataClientTypes.PinBlockFormatForPinData? = nil,
        pinDataLength: Swift.Int? = nil,
        primaryAccountNumber: Swift.String? = nil,
        verificationAttributes: PaymentCryptographyDataClientTypes.PinVerificationAttributes? = nil,
        verificationKeyIdentifier: Swift.String? = nil
    )
    {
        self.dukptAttributes = dukptAttributes
        self.encryptedPinBlock = encryptedPinBlock
        self.encryptionKeyIdentifier = encryptionKeyIdentifier
        self.pinBlockFormat = pinBlockFormat
        self.pinDataLength = pinDataLength
        self.primaryAccountNumber = primaryAccountNumber
        self.verificationAttributes = verificationAttributes
        self.verificationKeyIdentifier = verificationKeyIdentifier
    }
}

struct VerifyPinDataInputBody: Swift.Equatable {
    let verificationKeyIdentifier: Swift.String?
    let encryptionKeyIdentifier: Swift.String?
    let verificationAttributes: PaymentCryptographyDataClientTypes.PinVerificationAttributes?
    let encryptedPinBlock: Swift.String?
    let primaryAccountNumber: Swift.String?
    let pinBlockFormat: PaymentCryptographyDataClientTypes.PinBlockFormatForPinData?
    let pinDataLength: Swift.Int?
    let dukptAttributes: PaymentCryptographyDataClientTypes.DukptAttributes?
}

extension VerifyPinDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dukptAttributes = "DukptAttributes"
        case encryptedPinBlock = "EncryptedPinBlock"
        case encryptionKeyIdentifier = "EncryptionKeyIdentifier"
        case pinBlockFormat = "PinBlockFormat"
        case pinDataLength = "PinDataLength"
        case primaryAccountNumber = "PrimaryAccountNumber"
        case verificationAttributes = "VerificationAttributes"
        case verificationKeyIdentifier = "VerificationKeyIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verificationKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationKeyIdentifier)
        verificationKeyIdentifier = verificationKeyIdentifierDecoded
        let encryptionKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyIdentifier)
        encryptionKeyIdentifier = encryptionKeyIdentifierDecoded
        let verificationAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.PinVerificationAttributes.self, forKey: .verificationAttributes)
        verificationAttributes = verificationAttributesDecoded
        let encryptedPinBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptedPinBlock)
        encryptedPinBlock = encryptedPinBlockDecoded
        let primaryAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountNumber)
        primaryAccountNumber = primaryAccountNumberDecoded
        let pinBlockFormatDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.PinBlockFormatForPinData.self, forKey: .pinBlockFormat)
        pinBlockFormat = pinBlockFormatDecoded
        let pinDataLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pinDataLength)
        pinDataLength = pinDataLengthDecoded
        let dukptAttributesDecoded = try containerValues.decodeIfPresent(PaymentCryptographyDataClientTypes.DukptAttributes.self, forKey: .dukptAttributes)
        dukptAttributes = dukptAttributesDecoded
    }
}

extension VerifyPinDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: VerifyPinDataOutputBody = try responseDecoder.decode(responseBody: data)
            self.encryptionKeyArn = output.encryptionKeyArn
            self.encryptionKeyCheckValue = output.encryptionKeyCheckValue
            self.verificationKeyArn = output.verificationKeyArn
            self.verificationKeyCheckValue = output.verificationKeyCheckValue
        } else {
            self.encryptionKeyArn = nil
            self.encryptionKeyCheckValue = nil
            self.verificationKeyArn = nil
            self.verificationKeyCheckValue = nil
        }
    }
}

public struct VerifyPinDataOutput: Swift.Equatable {
    /// The keyARN of the PEK that Amazon Web Services Payment Cryptography uses for encrypted pin block generation.
    /// This member is required.
    public var encryptionKeyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography calculates the KCV by using standard algorithms, typically by encrypting 8 or 16 bytes or "00" or "01" and then truncating the result to the first 3 bytes, or 6 hex digits, of the resulting cryptogram.
    /// This member is required.
    public var encryptionKeyCheckValue: Swift.String?
    /// The keyARN of the PIN encryption key that Amazon Web Services Payment Cryptography uses for PIN or PIN Offset verification.
    /// This member is required.
    public var verificationKeyArn: Swift.String?
    /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography calculates the KCV by using standard algorithms, typically by encrypting 8 or 16 bytes or "00" or "01" and then truncating the result to the first 3 bytes, or 6 hex digits, of the resulting cryptogram.
    /// This member is required.
    public var verificationKeyCheckValue: Swift.String?

    public init(
        encryptionKeyArn: Swift.String? = nil,
        encryptionKeyCheckValue: Swift.String? = nil,
        verificationKeyArn: Swift.String? = nil,
        verificationKeyCheckValue: Swift.String? = nil
    )
    {
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionKeyCheckValue = encryptionKeyCheckValue
        self.verificationKeyArn = verificationKeyArn
        self.verificationKeyCheckValue = verificationKeyCheckValue
    }
}

struct VerifyPinDataOutputBody: Swift.Equatable {
    let verificationKeyArn: Swift.String?
    let verificationKeyCheckValue: Swift.String?
    let encryptionKeyArn: Swift.String?
    let encryptionKeyCheckValue: Swift.String?
}

extension VerifyPinDataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionKeyCheckValue = "EncryptionKeyCheckValue"
        case verificationKeyArn = "VerificationKeyArn"
        case verificationKeyCheckValue = "VerificationKeyCheckValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verificationKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationKeyArn)
        verificationKeyArn = verificationKeyArnDecoded
        let verificationKeyCheckValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationKeyCheckValue)
        verificationKeyCheckValue = verificationKeyCheckValueDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let encryptionKeyCheckValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyCheckValue)
        encryptionKeyCheckValue = encryptionKeyCheckValueDecoded
    }
}

enum VerifyPinDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VerificationFailedException": return try await VerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PaymentCryptographyDataClientTypes.VisaPin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pinVerificationKeyIndex = "PinVerificationKeyIndex"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pinVerificationKeyIndex = self.pinVerificationKeyIndex {
            try encodeContainer.encode(pinVerificationKeyIndex, forKey: .pinVerificationKeyIndex)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pinVerificationKeyIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pinVerificationKeyIndex)
        pinVerificationKeyIndex = pinVerificationKeyIndexDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Visa PIN.
    public struct VisaPin: Swift.Equatable {
        /// The value for PIN verification index. It is used in the Visa PIN algorithm to calculate the PVV (PIN Verification Value).
        /// This member is required.
        public var pinVerificationKeyIndex: Swift.Int?

        public init(
            pinVerificationKeyIndex: Swift.Int? = nil
        )
        {
            self.pinVerificationKeyIndex = pinVerificationKeyIndex
        }
    }

}

extension PaymentCryptographyDataClientTypes.VisaPinVerification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pinVerificationKeyIndex = "PinVerificationKeyIndex"
        case verificationValue = "VerificationValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pinVerificationKeyIndex = self.pinVerificationKeyIndex {
            try encodeContainer.encode(pinVerificationKeyIndex, forKey: .pinVerificationKeyIndex)
        }
        if let verificationValue = self.verificationValue {
            try encodeContainer.encode(verificationValue, forKey: .verificationValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pinVerificationKeyIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pinVerificationKeyIndex)
        pinVerificationKeyIndex = pinVerificationKeyIndexDecoded
        let verificationValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationValue)
        verificationValue = verificationValueDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Visa PIN.
    public struct VisaPinVerification: Swift.Equatable {
        /// The value for PIN verification index. It is used in the Visa PIN algorithm to calculate the PVV (PIN Verification Value).
        /// This member is required.
        public var pinVerificationKeyIndex: Swift.Int?
        /// Parameters that are required to generate or verify Visa PVV (PIN Verification Value).
        /// This member is required.
        public var verificationValue: Swift.String?

        public init(
            pinVerificationKeyIndex: Swift.Int? = nil,
            verificationValue: Swift.String? = nil
        )
        {
            self.pinVerificationKeyIndex = pinVerificationKeyIndex
            self.verificationValue = verificationValue
        }
    }

}

extension PaymentCryptographyDataClientTypes.VisaPinVerificationValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptedPinBlock = "EncryptedPinBlock"
        case pinVerificationKeyIndex = "PinVerificationKeyIndex"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptedPinBlock = self.encryptedPinBlock {
            try encodeContainer.encode(encryptedPinBlock, forKey: .encryptedPinBlock)
        }
        if let pinVerificationKeyIndex = self.pinVerificationKeyIndex {
            try encodeContainer.encode(pinVerificationKeyIndex, forKey: .pinVerificationKeyIndex)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptedPinBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptedPinBlock)
        encryptedPinBlock = encryptedPinBlockDecoded
        let pinVerificationKeyIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pinVerificationKeyIndex)
        pinVerificationKeyIndex = pinVerificationKeyIndexDecoded
    }
}

extension PaymentCryptographyDataClientTypes {
    /// Parameters that are required to generate or verify Visa PVV (PIN Verification Value).
    public struct VisaPinVerificationValue: Swift.Equatable {
        /// The encrypted PIN block data to verify.
        /// This member is required.
        public var encryptedPinBlock: Swift.String?
        /// The value for PIN verification index. It is used in the Visa PIN algorithm to calculate the PVV (PIN Verification Value).
        /// This member is required.
        public var pinVerificationKeyIndex: Swift.Int?

        public init(
            encryptedPinBlock: Swift.String? = nil,
            pinVerificationKeyIndex: Swift.Int? = nil
        )
        {
            self.encryptedPinBlock = encryptedPinBlock
            self.pinVerificationKeyIndex = pinVerificationKeyIndex
        }
    }

}
