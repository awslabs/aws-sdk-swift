// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension WorkMailClientTypes.AccessControlRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case effect = "Effect"
        case impersonationRoleIds = "ImpersonationRoleIds"
        case ipRanges = "IpRanges"
        case name = "Name"
        case notActions = "NotActions"
        case notImpersonationRoleIds = "NotImpersonationRoleIds"
        case notIpRanges = "NotIpRanges"
        case notUserIds = "NotUserIds"
        case userIds = "UserIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for accesscontrolruleaction0 in actions {
                try actionsContainer.encode(accesscontrolruleaction0)
            }
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encodeTimestamp(dateCreated, format: .epochSeconds, forKey: .dateCreated)
        }
        if let dateModified = self.dateModified {
            try encodeContainer.encodeTimestamp(dateModified, format: .epochSeconds, forKey: .dateModified)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let impersonationRoleIds = impersonationRoleIds {
            var impersonationRoleIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .impersonationRoleIds)
            for impersonationroleid0 in impersonationRoleIds {
                try impersonationRoleIdsContainer.encode(impersonationroleid0)
            }
        }
        if let ipRanges = ipRanges {
            var ipRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRanges)
            for iprange0 in ipRanges {
                try ipRangesContainer.encode(iprange0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notActions = notActions {
            var notActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notActions)
            for accesscontrolruleaction0 in notActions {
                try notActionsContainer.encode(accesscontrolruleaction0)
            }
        }
        if let notImpersonationRoleIds = notImpersonationRoleIds {
            var notImpersonationRoleIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notImpersonationRoleIds)
            for impersonationroleid0 in notImpersonationRoleIds {
                try notImpersonationRoleIdsContainer.encode(impersonationroleid0)
            }
        }
        if let notIpRanges = notIpRanges {
            var notIpRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notIpRanges)
            for iprange0 in notIpRanges {
                try notIpRangesContainer.encode(iprange0)
            }
        }
        if let notUserIds = notUserIds {
            var notUserIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notUserIds)
            for workmailidentifier0 in notUserIds {
                try notUserIdsContainer.encode(workmailidentifier0)
            }
        }
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for workmailidentifier0 in userIds {
                try userIdsContainer.encode(workmailidentifier0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AccessControlRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ipRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipRanges)
        var ipRangesDecoded0:[Swift.String]? = nil
        if let ipRangesContainer = ipRangesContainer {
            ipRangesDecoded0 = [Swift.String]()
            for string0 in ipRangesContainer {
                if let string0 = string0 {
                    ipRangesDecoded0?.append(string0)
                }
            }
        }
        ipRanges = ipRangesDecoded0
        let notIpRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notIpRanges)
        var notIpRangesDecoded0:[Swift.String]? = nil
        if let notIpRangesContainer = notIpRangesContainer {
            notIpRangesDecoded0 = [Swift.String]()
            for string0 in notIpRangesContainer {
                if let string0 = string0 {
                    notIpRangesDecoded0?.append(string0)
                }
            }
        }
        notIpRanges = notIpRangesDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let notActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notActions)
        var notActionsDecoded0:[Swift.String]? = nil
        if let notActionsContainer = notActionsContainer {
            notActionsDecoded0 = [Swift.String]()
            for string0 in notActionsContainer {
                if let string0 = string0 {
                    notActionsDecoded0?.append(string0)
                }
            }
        }
        notActions = notActionsDecoded0
        let userIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIds)
        var userIdsDecoded0:[Swift.String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [Swift.String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
        let notUserIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notUserIds)
        var notUserIdsDecoded0:[Swift.String]? = nil
        if let notUserIdsContainer = notUserIdsContainer {
            notUserIdsDecoded0 = [Swift.String]()
            for string0 in notUserIdsContainer {
                if let string0 = string0 {
                    notUserIdsDecoded0?.append(string0)
                }
            }
        }
        notUserIds = notUserIdsDecoded0
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateModified)
        dateModified = dateModifiedDecoded
        let impersonationRoleIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .impersonationRoleIds)
        var impersonationRoleIdsDecoded0:[Swift.String]? = nil
        if let impersonationRoleIdsContainer = impersonationRoleIdsContainer {
            impersonationRoleIdsDecoded0 = [Swift.String]()
            for string0 in impersonationRoleIdsContainer {
                if let string0 = string0 {
                    impersonationRoleIdsDecoded0?.append(string0)
                }
            }
        }
        impersonationRoleIds = impersonationRoleIdsDecoded0
        let notImpersonationRoleIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notImpersonationRoleIds)
        var notImpersonationRoleIdsDecoded0:[Swift.String]? = nil
        if let notImpersonationRoleIdsContainer = notImpersonationRoleIdsContainer {
            notImpersonationRoleIdsDecoded0 = [Swift.String]()
            for string0 in notImpersonationRoleIdsContainer {
                if let string0 = string0 {
                    notImpersonationRoleIdsDecoded0?.append(string0)
                }
            }
        }
        notImpersonationRoleIds = notImpersonationRoleIdsDecoded0
    }
}

extension WorkMailClientTypes {
    /// A rule that controls access to an WorkMail organization.
    public struct AccessControlRule: Swift.Equatable {
        /// Access protocol actions to include in the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
        public var actions: [Swift.String]?
        /// The date that the rule was created.
        public var dateCreated: ClientRuntime.Date?
        /// The date that the rule was modified.
        public var dateModified: ClientRuntime.Date?
        /// The rule description.
        public var description: Swift.String?
        /// The rule effect.
        public var effect: WorkMailClientTypes.AccessControlRuleEffect?
        /// Impersonation role IDs to include in the rule.
        public var impersonationRoleIds: [Swift.String]?
        /// IPv4 CIDR ranges to include in the rule.
        public var ipRanges: [Swift.String]?
        /// The rule name.
        public var name: Swift.String?
        /// Access protocol actions to exclude from the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
        public var notActions: [Swift.String]?
        /// Impersonation role IDs to exclude from the rule.
        public var notImpersonationRoleIds: [Swift.String]?
        /// IPv4 CIDR ranges to exclude from the rule.
        public var notIpRanges: [Swift.String]?
        /// User IDs to exclude from the rule.
        public var notUserIds: [Swift.String]?
        /// User IDs to include in the rule.
        public var userIds: [Swift.String]?

        public init(
            actions: [Swift.String]? = nil,
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            effect: WorkMailClientTypes.AccessControlRuleEffect? = nil,
            impersonationRoleIds: [Swift.String]? = nil,
            ipRanges: [Swift.String]? = nil,
            name: Swift.String? = nil,
            notActions: [Swift.String]? = nil,
            notImpersonationRoleIds: [Swift.String]? = nil,
            notIpRanges: [Swift.String]? = nil,
            notUserIds: [Swift.String]? = nil,
            userIds: [Swift.String]? = nil
        )
        {
            self.actions = actions
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.effect = effect
            self.impersonationRoleIds = impersonationRoleIds
            self.ipRanges = ipRanges
            self.name = name
            self.notActions = notActions
            self.notImpersonationRoleIds = notImpersonationRoleIds
            self.notIpRanges = notIpRanges
            self.notUserIds = notUserIds
            self.userIds = userIds
        }
    }

}

extension WorkMailClientTypes {
    public enum AccessControlRuleEffect: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessControlRuleEffect] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessControlRuleEffect(rawValue: rawValue) ?? AccessControlRuleEffect.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes {
    public enum AccessEffect: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessEffect] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessEffect(rawValue: rawValue) ?? AccessEffect.sdkUnknown(rawValue)
        }
    }
}

extension AssociateDelegateToResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension AssociateDelegateToResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateDelegateToResourceInput: Swift.Equatable {
    /// The member (user or group) to associate to the resource. The entity ID can accept UserId or GroupID, Username or Groupname, or email.
    ///
    /// * Entity: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The organization under which the resource exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The resource for which members (users or groups) are associated. The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:
    ///
    /// * Resource ID: r-0123456789a0123456789b0123456789
    ///
    /// * Email address: resource@domain.tld
    ///
    /// * Resource name: resource
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct AssociateDelegateToResourceInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let resourceId: Swift.String?
    let entityId: Swift.String?
}

extension AssociateDelegateToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension AssociateDelegateToResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateDelegateToResourceOutput: Swift.Equatable {

    public init() { }
}

enum AssociateDelegateToResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateMemberToGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension AssociateMemberToGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateMemberToGroupInput: Swift.Equatable {
    /// The group to which the member (user or group) is associated. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:
    ///
    /// * Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: group@domain.tld
    ///
    /// * Group name: group
    /// This member is required.
    public var groupId: Swift.String?
    /// The member (user or group) to associate to the group. The member ID can accept UserID or GroupId, Username or Groupname, or email.
    ///
    /// * Member: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: member@domain.tld
    ///
    /// * Member name: member
    /// This member is required.
    public var memberId: Swift.String?
    /// The organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.memberId = memberId
        self.organizationId = organizationId
    }
}

struct AssociateMemberToGroupInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let groupId: Swift.String?
    let memberId: Swift.String?
}

extension AssociateMemberToGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension AssociateMemberToGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateMemberToGroupOutput: Swift.Equatable {

    public init() { }
}

enum AssociateMemberToGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DirectoryServiceAuthenticationFailedException": return try await DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssumeImpersonationRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let impersonationRoleId = self.impersonationRoleId {
            try encodeContainer.encode(impersonationRoleId, forKey: .impersonationRoleId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension AssumeImpersonationRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssumeImpersonationRoleInput: Swift.Equatable {
    /// The impersonation role ID to assume.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The WorkMail organization under which the impersonation role will be assumed.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        impersonationRoleId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
        self.organizationId = organizationId
    }
}

struct AssumeImpersonationRoleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let impersonationRoleId: Swift.String?
}

extension AssumeImpersonationRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
    }
}

extension AssumeImpersonationRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssumeImpersonationRoleOutputBody = try responseDecoder.decode(responseBody: data)
            self.expiresIn = output.expiresIn
            self.token = output.token
        } else {
            self.expiresIn = nil
            self.token = nil
        }
    }
}

public struct AssumeImpersonationRoleOutput: Swift.Equatable {
    /// The authentication token's validity, in seconds.
    public var expiresIn: Swift.Int?
    /// The authentication token for the impersonation role.
    public var token: Swift.String?

    public init(
        expiresIn: Swift.Int? = nil,
        token: Swift.String? = nil
    )
    {
        self.expiresIn = expiresIn
        self.token = token
    }
}

struct AssumeImpersonationRoleOutputBody: Swift.Equatable {
    let token: Swift.String?
    let expiresIn: Swift.Int?
}

extension AssumeImpersonationRoleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresIn = "ExpiresIn"
        case token = "Token"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
    }
}

enum AssumeImpersonationRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkMailClientTypes.AvailabilityConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case domainName = "DomainName"
        case ewsProvider = "EwsProvider"
        case lambdaProvider = "LambdaProvider"
        case providerType = "ProviderType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateCreated = self.dateCreated {
            try encodeContainer.encodeTimestamp(dateCreated, format: .epochSeconds, forKey: .dateCreated)
        }
        if let dateModified = self.dateModified {
            try encodeContainer.encodeTimestamp(dateModified, format: .epochSeconds, forKey: .dateModified)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let ewsProvider = self.ewsProvider {
            try encodeContainer.encode(ewsProvider, forKey: .ewsProvider)
        }
        if let lambdaProvider = self.lambdaProvider {
            try encodeContainer.encode(lambdaProvider, forKey: .lambdaProvider)
        }
        if let providerType = self.providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AvailabilityProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let ewsProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.RedactedEwsAvailabilityProvider.self, forKey: .ewsProvider)
        ewsProvider = ewsProviderDecoded
        let lambdaProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.LambdaAvailabilityProvider.self, forKey: .lambdaProvider)
        lambdaProvider = lambdaProviderDecoded
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension WorkMailClientTypes {
    /// List all the AvailabilityConfiguration's for the given WorkMail organization.
    public struct AvailabilityConfiguration: Swift.Equatable {
        /// The date and time at which the availability configuration was created.
        public var dateCreated: ClientRuntime.Date?
        /// The date and time at which the availability configuration was last modified.
        public var dateModified: ClientRuntime.Date?
        /// Displays the domain to which the provider applies.
        public var domainName: Swift.String?
        /// If ProviderType is EWS, then this field contains RedactedEwsAvailabilityProvider. Otherwise, it is not required.
        public var ewsProvider: WorkMailClientTypes.RedactedEwsAvailabilityProvider?
        /// If ProviderType is LAMBDA then this field contains LambdaAvailabilityProvider. Otherwise, it is not required.
        public var lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
        /// Displays the provider type that applies to this domain.
        public var providerType: WorkMailClientTypes.AvailabilityProviderType?

        public init(
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            domainName: Swift.String? = nil,
            ewsProvider: WorkMailClientTypes.RedactedEwsAvailabilityProvider? = nil,
            lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider? = nil,
            providerType: WorkMailClientTypes.AvailabilityProviderType? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.domainName = domainName
            self.ewsProvider = ewsProvider
            self.lambdaProvider = lambdaProvider
            self.providerType = providerType
        }
    }

}

extension WorkMailClientTypes {
    public enum AvailabilityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ews
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [AvailabilityProviderType] {
            return [
                .ews,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ews: return "EWS"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AvailabilityProviderType(rawValue: rawValue) ?? AvailabilityProviderType.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes.BookingOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoAcceptRequests = "AutoAcceptRequests"
        case autoDeclineConflictingRequests = "AutoDeclineConflictingRequests"
        case autoDeclineRecurringRequests = "AutoDeclineRecurringRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoAcceptRequests != false {
            try encodeContainer.encode(autoAcceptRequests, forKey: .autoAcceptRequests)
        }
        if autoDeclineConflictingRequests != false {
            try encodeContainer.encode(autoDeclineConflictingRequests, forKey: .autoDeclineConflictingRequests)
        }
        if autoDeclineRecurringRequests != false {
            try encodeContainer.encode(autoDeclineRecurringRequests, forKey: .autoDeclineRecurringRequests)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoAcceptRequestsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAcceptRequests) ?? false
        autoAcceptRequests = autoAcceptRequestsDecoded
        let autoDeclineRecurringRequestsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeclineRecurringRequests) ?? false
        autoDeclineRecurringRequests = autoDeclineRecurringRequestsDecoded
        let autoDeclineConflictingRequestsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeclineConflictingRequests) ?? false
        autoDeclineConflictingRequests = autoDeclineConflictingRequestsDecoded
    }
}

extension WorkMailClientTypes {
    /// At least one delegate must be associated to the resource to disable automatic replies from the resource.
    public struct BookingOptions: Swift.Equatable {
        /// The resource's ability to automatically reply to requests. If disabled, delegates must be associated to the resource.
        public var autoAcceptRequests: Swift.Bool
        /// The resource's ability to automatically decline any conflicting requests.
        public var autoDeclineConflictingRequests: Swift.Bool
        /// The resource's ability to automatically decline any recurring requests.
        public var autoDeclineRecurringRequests: Swift.Bool

        public init(
            autoAcceptRequests: Swift.Bool = false,
            autoDeclineConflictingRequests: Swift.Bool = false,
            autoDeclineRecurringRequests: Swift.Bool = false
        )
        {
            self.autoAcceptRequests = autoAcceptRequests
            self.autoDeclineConflictingRequests = autoDeclineConflictingRequests
            self.autoDeclineRecurringRequests = autoDeclineRecurringRequests
        }
    }

}

extension CancelMailboxExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension CancelMailboxExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelMailboxExportJobInput: Swift.Equatable {
    /// The idempotency token for the client request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        jobId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.jobId = jobId
        self.organizationId = organizationId
    }
}

struct CancelMailboxExportJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let jobId: Swift.String?
    let organizationId: Swift.String?
}

extension CancelMailboxExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension CancelMailboxExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelMailboxExportJobOutput: Swift.Equatable {

    public init() { }
}

enum CancelMailboxExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension CreateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAliasInput: Swift.Equatable {
    /// The alias to add to the member set.
    /// This member is required.
    public var alias: Swift.String?
    /// The member (user or group) to which this alias is added.
    /// This member is required.
    public var entityId: Swift.String?
    /// The organization under which the member (user or group) exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct CreateAliasInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let alias: Swift.String?
}

extension CreateAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension CreateAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateAliasOutput: Swift.Equatable {

    public init() { }
}

enum CreateAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EmailAddressInUseException": return try await EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MailDomainNotFoundException": return try await MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MailDomainStateException": return try await MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAvailabilityConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case domainName = "DomainName"
        case ewsProvider = "EwsProvider"
        case lambdaProvider = "LambdaProvider"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let ewsProvider = self.ewsProvider {
            try encodeContainer.encode(ewsProvider, forKey: .ewsProvider)
        }
        if let lambdaProvider = self.lambdaProvider {
            try encodeContainer.encode(lambdaProvider, forKey: .lambdaProvider)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension CreateAvailabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAvailabilityConfigurationInput: Swift.Equatable {
    /// An idempotent token that ensures that an API request is executed only once.
    public var clientToken: Swift.String?
    /// The domain to which the provider applies.
    /// This member is required.
    public var domainName: Swift.String?
    /// Exchange Web Services (EWS) availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider.
    public var ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    /// Lambda availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider.
    public var lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
    /// The WorkMail organization for which the AvailabilityConfiguration will be created.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainName: Swift.String? = nil,
        ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider? = nil,
        lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainName = domainName
        self.ewsProvider = ewsProvider
        self.lambdaProvider = lambdaProvider
        self.organizationId = organizationId
    }
}

struct CreateAvailabilityConfigurationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let organizationId: Swift.String?
    let domainName: Swift.String?
    let ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    let lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
}

extension CreateAvailabilityConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case domainName = "DomainName"
        case ewsProvider = "EwsProvider"
        case lambdaProvider = "LambdaProvider"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let ewsProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EwsAvailabilityProvider.self, forKey: .ewsProvider)
        ewsProvider = ewsProviderDecoded
        let lambdaProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.LambdaAvailabilityProvider.self, forKey: .lambdaProvider)
        lambdaProvider = lambdaProviderDecoded
    }
}

extension CreateAvailabilityConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateAvailabilityConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum CreateAvailabilityConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameAvailabilityException": return try await NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hiddenFromGlobalAddressList = self.hiddenFromGlobalAddressList {
            try encodeContainer.encode(hiddenFromGlobalAddressList, forKey: .hiddenFromGlobalAddressList)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension CreateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGroupInput: Swift.Equatable {
    /// If this parameter is enabled, the group will be hidden from the address book.
    public var hiddenFromGlobalAddressList: Swift.Bool?
    /// The name of the group.
    /// This member is required.
    public var name: Swift.String?
    /// The organization under which the group is to be created.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        hiddenFromGlobalAddressList: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.name = name
        self.organizationId = organizationId
    }
}

struct CreateGroupInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let name: Swift.String?
    let hiddenFromGlobalAddressList: Swift.Bool?
}

extension CreateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let hiddenFromGlobalAddressListDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hiddenFromGlobalAddressList)
        hiddenFromGlobalAddressList = hiddenFromGlobalAddressListDecoded
    }
}

extension CreateGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.groupId = output.groupId
        } else {
            self.groupId = nil
        }
    }
}

public struct CreateGroupOutput: Swift.Equatable {
    /// The identifier of the group.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct CreateGroupOutputBody: Swift.Equatable {
    let groupId: Swift.String?
}

extension CreateGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

enum CreateGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DirectoryServiceAuthenticationFailedException": return try await DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameAvailabilityException": return try await NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReservedNameException": return try await ReservedNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateImpersonationRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case organizationId = "OrganizationId"
        case rules = "Rules"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for impersonationrule0 in rules {
                try rulesContainer.encode(impersonationrule0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateImpersonationRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateImpersonationRoleInput: Swift.Equatable {
    /// The idempotency token for the client request.
    public var clientToken: Swift.String?
    /// The description of the new impersonation role.
    public var description: Swift.String?
    /// The name of the new impersonation role.
    /// This member is required.
    public var name: Swift.String?
    /// The WorkMail organization to create the new impersonation role within.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The list of rules for the impersonation role.
    /// This member is required.
    public var rules: [WorkMailClientTypes.ImpersonationRule]?
    /// The impersonation role's type. The available impersonation role types are READ_ONLY or FULL_ACCESS.
    /// This member is required.
    public var type: WorkMailClientTypes.ImpersonationRoleType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        rules: [WorkMailClientTypes.ImpersonationRule]? = nil,
        type: WorkMailClientTypes.ImpersonationRoleType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.organizationId = organizationId
        self.rules = rules
        self.type = type
    }
}

struct CreateImpersonationRoleInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let organizationId: Swift.String?
    let name: Swift.String?
    let type: WorkMailClientTypes.ImpersonationRoleType?
    let description: Swift.String?
    let rules: [WorkMailClientTypes.ImpersonationRule]?
}

extension CreateImpersonationRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case organizationId = "OrganizationId"
        case rules = "Rules"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ImpersonationRoleType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.ImpersonationRule?].self, forKey: .rules)
        var rulesDecoded0:[WorkMailClientTypes.ImpersonationRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [WorkMailClientTypes.ImpersonationRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension CreateImpersonationRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateImpersonationRoleOutputBody = try responseDecoder.decode(responseBody: data)
            self.impersonationRoleId = output.impersonationRoleId
        } else {
            self.impersonationRoleId = nil
        }
    }
}

public struct CreateImpersonationRoleOutput: Swift.Equatable {
    /// The new impersonation role ID.
    public var impersonationRoleId: Swift.String?

    public init(
        impersonationRoleId: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
    }
}

struct CreateImpersonationRoleOutputBody: Swift.Equatable {
    let impersonationRoleId: Swift.String?
}

extension CreateImpersonationRoleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
    }
}

enum CreateImpersonationRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMobileDeviceAccessRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceModels = deviceModels {
            var deviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceModels)
            for devicemodel0 in deviceModels {
                try deviceModelsContainer.encode(devicemodel0)
            }
        }
        if let deviceOperatingSystems = deviceOperatingSystems {
            var deviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceOperatingSystems)
            for deviceoperatingsystem0 in deviceOperatingSystems {
                try deviceOperatingSystemsContainer.encode(deviceoperatingsystem0)
            }
        }
        if let deviceTypes = deviceTypes {
            var deviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceTypes)
            for devicetype0 in deviceTypes {
                try deviceTypesContainer.encode(devicetype0)
            }
        }
        if let deviceUserAgents = deviceUserAgents {
            var deviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceUserAgents)
            for deviceuseragent0 in deviceUserAgents {
                try deviceUserAgentsContainer.encode(deviceuseragent0)
            }
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notDeviceModels = notDeviceModels {
            var notDeviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceModels)
            for devicemodel0 in notDeviceModels {
                try notDeviceModelsContainer.encode(devicemodel0)
            }
        }
        if let notDeviceOperatingSystems = notDeviceOperatingSystems {
            var notDeviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceOperatingSystems)
            for deviceoperatingsystem0 in notDeviceOperatingSystems {
                try notDeviceOperatingSystemsContainer.encode(deviceoperatingsystem0)
            }
        }
        if let notDeviceTypes = notDeviceTypes {
            var notDeviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceTypes)
            for devicetype0 in notDeviceTypes {
                try notDeviceTypesContainer.encode(devicetype0)
            }
        }
        if let notDeviceUserAgents = notDeviceUserAgents {
            var notDeviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceUserAgents)
            for deviceuseragent0 in notDeviceUserAgents {
                try notDeviceUserAgentsContainer.encode(deviceuseragent0)
            }
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension CreateMobileDeviceAccessRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateMobileDeviceAccessRuleInput: Swift.Equatable {
    /// The idempotency token for the client request.
    public var clientToken: Swift.String?
    /// The rule description.
    public var description: Swift.String?
    /// Device models that the rule will match.
    public var deviceModels: [Swift.String]?
    /// Device operating systems that the rule will match.
    public var deviceOperatingSystems: [Swift.String]?
    /// Device types that the rule will match.
    public var deviceTypes: [Swift.String]?
    /// Device user agents that the rule will match.
    public var deviceUserAgents: [Swift.String]?
    /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
    /// This member is required.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// The rule name.
    /// This member is required.
    public var name: Swift.String?
    /// Device models that the rule will not match. All other device models will match.
    public var notDeviceModels: [Swift.String]?
    /// Device operating systems that the rule will not match. All other device operating systems will match.
    public var notDeviceOperatingSystems: [Swift.String]?
    /// Device types that the rule will not match. All other device types will match.
    public var notDeviceTypes: [Swift.String]?
    /// Device user agents that the rule will not match. All other device user agents will match.
    public var notDeviceUserAgents: [Swift.String]?
    /// The WorkMail organization under which the rule will be created.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceModels: [Swift.String]? = nil,
        deviceOperatingSystems: [Swift.String]? = nil,
        deviceTypes: [Swift.String]? = nil,
        deviceUserAgents: [Swift.String]? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        name: Swift.String? = nil,
        notDeviceModels: [Swift.String]? = nil,
        notDeviceOperatingSystems: [Swift.String]? = nil,
        notDeviceTypes: [Swift.String]? = nil,
        notDeviceUserAgents: [Swift.String]? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.deviceModels = deviceModels
        self.deviceOperatingSystems = deviceOperatingSystems
        self.deviceTypes = deviceTypes
        self.deviceUserAgents = deviceUserAgents
        self.effect = effect
        self.name = name
        self.notDeviceModels = notDeviceModels
        self.notDeviceOperatingSystems = notDeviceOperatingSystems
        self.notDeviceTypes = notDeviceTypes
        self.notDeviceUserAgents = notDeviceUserAgents
        self.organizationId = organizationId
    }
}

struct CreateMobileDeviceAccessRuleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let clientToken: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    let deviceTypes: [Swift.String]?
    let notDeviceTypes: [Swift.String]?
    let deviceModels: [Swift.String]?
    let notDeviceModels: [Swift.String]?
    let deviceOperatingSystems: [Swift.String]?
    let notDeviceOperatingSystems: [Swift.String]?
    let deviceUserAgents: [Swift.String]?
    let notDeviceUserAgents: [Swift.String]?
}

extension CreateMobileDeviceAccessRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let deviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceTypes)
        var deviceTypesDecoded0:[Swift.String]? = nil
        if let deviceTypesContainer = deviceTypesContainer {
            deviceTypesDecoded0 = [Swift.String]()
            for string0 in deviceTypesContainer {
                if let string0 = string0 {
                    deviceTypesDecoded0?.append(string0)
                }
            }
        }
        deviceTypes = deviceTypesDecoded0
        let notDeviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceTypes)
        var notDeviceTypesDecoded0:[Swift.String]? = nil
        if let notDeviceTypesContainer = notDeviceTypesContainer {
            notDeviceTypesDecoded0 = [Swift.String]()
            for string0 in notDeviceTypesContainer {
                if let string0 = string0 {
                    notDeviceTypesDecoded0?.append(string0)
                }
            }
        }
        notDeviceTypes = notDeviceTypesDecoded0
        let deviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceModels)
        var deviceModelsDecoded0:[Swift.String]? = nil
        if let deviceModelsContainer = deviceModelsContainer {
            deviceModelsDecoded0 = [Swift.String]()
            for string0 in deviceModelsContainer {
                if let string0 = string0 {
                    deviceModelsDecoded0?.append(string0)
                }
            }
        }
        deviceModels = deviceModelsDecoded0
        let notDeviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceModels)
        var notDeviceModelsDecoded0:[Swift.String]? = nil
        if let notDeviceModelsContainer = notDeviceModelsContainer {
            notDeviceModelsDecoded0 = [Swift.String]()
            for string0 in notDeviceModelsContainer {
                if let string0 = string0 {
                    notDeviceModelsDecoded0?.append(string0)
                }
            }
        }
        notDeviceModels = notDeviceModelsDecoded0
        let deviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceOperatingSystems)
        var deviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let deviceOperatingSystemsContainer = deviceOperatingSystemsContainer {
            deviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in deviceOperatingSystemsContainer {
                if let string0 = string0 {
                    deviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        deviceOperatingSystems = deviceOperatingSystemsDecoded0
        let notDeviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceOperatingSystems)
        var notDeviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let notDeviceOperatingSystemsContainer = notDeviceOperatingSystemsContainer {
            notDeviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in notDeviceOperatingSystemsContainer {
                if let string0 = string0 {
                    notDeviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        notDeviceOperatingSystems = notDeviceOperatingSystemsDecoded0
        let deviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceUserAgents)
        var deviceUserAgentsDecoded0:[Swift.String]? = nil
        if let deviceUserAgentsContainer = deviceUserAgentsContainer {
            deviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in deviceUserAgentsContainer {
                if let string0 = string0 {
                    deviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        deviceUserAgents = deviceUserAgentsDecoded0
        let notDeviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceUserAgents)
        var notDeviceUserAgentsDecoded0:[Swift.String]? = nil
        if let notDeviceUserAgentsContainer = notDeviceUserAgentsContainer {
            notDeviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in notDeviceUserAgentsContainer {
                if let string0 = string0 {
                    notDeviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        notDeviceUserAgents = notDeviceUserAgentsDecoded0
    }
}

extension CreateMobileDeviceAccessRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMobileDeviceAccessRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.mobileDeviceAccessRuleId = output.mobileDeviceAccessRuleId
        } else {
            self.mobileDeviceAccessRuleId = nil
        }
    }
}

public struct CreateMobileDeviceAccessRuleOutput: Swift.Equatable {
    /// The identifier for the newly created mobile device access rule.
    public var mobileDeviceAccessRuleId: Swift.String?

    public init(
        mobileDeviceAccessRuleId: Swift.String? = nil
    )
    {
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
    }
}

struct CreateMobileDeviceAccessRuleOutputBody: Swift.Equatable {
    let mobileDeviceAccessRuleId: Swift.String?
}

extension CreateMobileDeviceAccessRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
    }
}

enum CreateMobileDeviceAccessRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case clientToken = "ClientToken"
        case directoryId = "DirectoryId"
        case domains = "Domains"
        case enableInteroperability = "EnableInteroperability"
        case kmsKeyArn = "KmsKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for domain0 in domains {
                try domainsContainer.encode(domain0)
            }
        }
        if let enableInteroperability = self.enableInteroperability {
            try encodeContainer.encode(enableInteroperability, forKey: .enableInteroperability)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }
}

extension CreateOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateOrganizationInput: Swift.Equatable {
    /// The organization alias.
    /// This member is required.
    public var alias: Swift.String?
    /// The idempotency token associated with the request.
    public var clientToken: Swift.String?
    /// The AWS Directory Service directory ID.
    public var directoryId: Swift.String?
    /// The email domains to associate with the organization.
    public var domains: [WorkMailClientTypes.Domain]?
    /// When true, allows organization interoperability between WorkMail and Microsoft Exchange. If true, you must include a AD Connector directory ID in the request.
    public var enableInteroperability: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a customer managed key from AWS KMS.
    public var kmsKeyArn: Swift.String?

    public init(
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        domains: [WorkMailClientTypes.Domain]? = nil,
        enableInteroperability: Swift.Bool? = nil,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.directoryId = directoryId
        self.domains = domains
        self.enableInteroperability = enableInteroperability
        self.kmsKeyArn = kmsKeyArn
    }
}

struct CreateOrganizationInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let alias: Swift.String?
    let clientToken: Swift.String?
    let domains: [WorkMailClientTypes.Domain]?
    let kmsKeyArn: Swift.String?
    let enableInteroperability: Swift.Bool?
}

extension CreateOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case clientToken = "ClientToken"
        case directoryId = "DirectoryId"
        case domains = "Domains"
        case enableInteroperability = "EnableInteroperability"
        case kmsKeyArn = "KmsKeyArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let domainsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Domain?].self, forKey: .domains)
        var domainsDecoded0:[WorkMailClientTypes.Domain]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [WorkMailClientTypes.Domain]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let enableInteroperabilityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableInteroperability)
        enableInteroperability = enableInteroperabilityDecoded
    }
}

extension CreateOrganizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateOrganizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.organizationId = output.organizationId
        } else {
            self.organizationId = nil
        }
    }
}

public struct CreateOrganizationOutput: Swift.Equatable {
    /// The organization ID.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct CreateOrganizationOutputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension CreateOrganizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

enum CreateOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DirectoryInUseException": return try await DirectoryInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameAvailabilityException": return try await NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case name = "Name"
        case organizationId = "OrganizationId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hiddenFromGlobalAddressList = self.hiddenFromGlobalAddressList {
            try encodeContainer.encode(hiddenFromGlobalAddressList, forKey: .hiddenFromGlobalAddressList)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateResourceInput: Swift.Equatable {
    /// Resource description.
    public var description: Swift.String?
    /// If this parameter is enabled, the resource will be hidden from the address book.
    public var hiddenFromGlobalAddressList: Swift.Bool?
    /// The name of the new resource.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier associated with the organization for which the resource is created.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The type of the new resource. The available types are equipment and room.
    /// This member is required.
    public var type: WorkMailClientTypes.ResourceType?

    public init(
        description: Swift.String? = nil,
        hiddenFromGlobalAddressList: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        type: WorkMailClientTypes.ResourceType? = nil
    )
    {
        self.description = description
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.name = name
        self.organizationId = organizationId
        self.type = type
    }
}

struct CreateResourceInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let name: Swift.String?
    let type: WorkMailClientTypes.ResourceType?
    let description: Swift.String?
    let hiddenFromGlobalAddressList: Swift.Bool?
}

extension CreateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case name = "Name"
        case organizationId = "OrganizationId"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ResourceType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hiddenFromGlobalAddressListDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hiddenFromGlobalAddressList)
        hiddenFromGlobalAddressList = hiddenFromGlobalAddressListDecoded
    }
}

extension CreateResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceId = output.resourceId
        } else {
            self.resourceId = nil
        }
    }
}

public struct CreateResourceOutput: Swift.Equatable {
    /// The identifier of the new resource.
    public var resourceId: Swift.String?

    public init(
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct CreateResourceOutputBody: Swift.Equatable {
    let resourceId: Swift.String?
}

extension CreateResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

enum CreateResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DirectoryServiceAuthenticationFailedException": return try await DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameAvailabilityException": return try await NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReservedNameException": return try await ReservedNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(hiddenFromGlobalAddressList: \(Swift.String(describing: hiddenFromGlobalAddressList)), name: \(Swift.String(describing: name)), organizationId: \(Swift.String(describing: organizationId)), role: \(Swift.String(describing: role)), displayName: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", password: \"CONTENT_REDACTED\")"}
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case lastName = "LastName"
        case name = "Name"
        case organizationId = "OrganizationId"
        case password = "Password"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let hiddenFromGlobalAddressList = self.hiddenFromGlobalAddressList {
            try encodeContainer.encode(hiddenFromGlobalAddressList, forKey: .hiddenFromGlobalAddressList)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The display name for the new user.
    /// This member is required.
    public var displayName: Swift.String?
    /// The first name of the new user.
    public var firstName: Swift.String?
    /// If this parameter is enabled, the user will be hidden from the address book.
    public var hiddenFromGlobalAddressList: Swift.Bool?
    /// The last name of the new user.
    public var lastName: Swift.String?
    /// The name for the new user. WorkMail directory user names have a maximum length of 64. All others have a maximum length of 20.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the organization for which the user is created.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The password for the new user.
    public var password: Swift.String?
    /// The role of the new user. You cannot pass SYSTEM_USER or RESOURCE role in a single request. When a user role is not selected, the default role of USER is selected.
    public var role: WorkMailClientTypes.UserRole?

    public init(
        displayName: Swift.String? = nil,
        firstName: Swift.String? = nil,
        hiddenFromGlobalAddressList: Swift.Bool? = nil,
        lastName: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        password: Swift.String? = nil,
        role: WorkMailClientTypes.UserRole? = nil
    )
    {
        self.displayName = displayName
        self.firstName = firstName
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.lastName = lastName
        self.name = name
        self.organizationId = organizationId
        self.password = password
        self.role = role
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let name: Swift.String?
    let displayName: Swift.String?
    let password: Swift.String?
    let role: WorkMailClientTypes.UserRole?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let hiddenFromGlobalAddressList: Swift.Bool?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case lastName = "LastName"
        case name = "Name"
        case organizationId = "OrganizationId"
        case password = "Password"
        case role = "Role"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let roleDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.UserRole.self, forKey: .role)
        role = roleDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let hiddenFromGlobalAddressListDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hiddenFromGlobalAddressList)
        hiddenFromGlobalAddressList = hiddenFromGlobalAddressListDecoded
    }
}

extension CreateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.userId = output.userId
        } else {
            self.userId = nil
        }
    }
}

public struct CreateUserOutput: Swift.Equatable {
    /// The identifier for the new user.
    public var userId: Swift.String?

    public init(
        userId: Swift.String? = nil
    )
    {
        self.userId = userId
    }
}

struct CreateUserOutputBody: Swift.Equatable {
    let userId: Swift.String?
}

extension CreateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

enum CreateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DirectoryServiceAuthenticationFailedException": return try await DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPasswordException": return try await InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameAvailabilityException": return try await NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReservedNameException": return try await ReservedNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkMailClientTypes.Delegate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MemberType.self, forKey: .type)
        type = typeDecoded
    }
}

extension WorkMailClientTypes {
    /// The name of the attribute, which is one of the values defined in the UserAttribute enumeration.
    public struct Delegate: Swift.Equatable {
        /// The identifier for the user or group associated as the resource's delegate.
        /// This member is required.
        public var id: Swift.String?
        /// The type of the delegate: user or group.
        /// This member is required.
        public var type: WorkMailClientTypes.MemberType?

        public init(
            id: Swift.String? = nil,
            type: WorkMailClientTypes.MemberType? = nil
        )
        {
            self.id = id
            self.type = type
        }
    }

}

extension DeleteAccessControlRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteAccessControlRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAccessControlRuleInput: Swift.Equatable {
    /// The name of the access control rule.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier for the organization.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.name = name
        self.organizationId = organizationId
    }
}

struct DeleteAccessControlRuleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let name: Swift.String?
}

extension DeleteAccessControlRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteAccessControlRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessControlRuleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessControlRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAliasInput: Swift.Equatable {
    /// The aliases to be removed from the user's set of aliases. Duplicate entries in the list are collapsed into single entries (the list is transformed into a set).
    /// This member is required.
    public var alias: Swift.String?
    /// The identifier for the member (user or group) from which to have the aliases removed.
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the user exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct DeleteAliasInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let alias: Swift.String?
}

extension DeleteAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension DeleteAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAliasOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAvailabilityConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteAvailabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAvailabilityConfigurationInput: Swift.Equatable {
    /// The domain for which the AvailabilityConfiguration will be deleted.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization for which the AvailabilityConfiguration will be deleted.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

struct DeleteAvailabilityConfigurationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let domainName: Swift.String?
}

extension DeleteAvailabilityConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DeleteAvailabilityConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAvailabilityConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAvailabilityConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEmailMonitoringConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteEmailMonitoringConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEmailMonitoringConfigurationInput: Swift.Equatable {
    /// The ID of the organization from which the email monitoring configuration is deleted.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct DeleteEmailMonitoringConfigurationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension DeleteEmailMonitoringConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension DeleteEmailMonitoringConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEmailMonitoringConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEmailMonitoringConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGroupInput: Swift.Equatable {
    /// The identifier of the group to be deleted. The identifier can be the GroupId, or Groupname. The following identity formats are available:
    ///
    /// * Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Group name: group
    /// This member is required.
    public var groupId: Swift.String?
    /// The organization that contains the group.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.organizationId = organizationId
    }
}

struct DeleteGroupInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let groupId: Swift.String?
}

extension DeleteGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DeleteGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DirectoryServiceAuthenticationFailedException": return try await DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteImpersonationRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let impersonationRoleId = self.impersonationRoleId {
            try encodeContainer.encode(impersonationRoleId, forKey: .impersonationRoleId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteImpersonationRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteImpersonationRoleInput: Swift.Equatable {
    /// The ID of the impersonation role to delete.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The WorkMail organization from which to delete the impersonation role.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        impersonationRoleId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
        self.organizationId = organizationId
    }
}

struct DeleteImpersonationRoleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let impersonationRoleId: Swift.String?
}

extension DeleteImpersonationRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
    }
}

extension DeleteImpersonationRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteImpersonationRoleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteImpersonationRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMailboxPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let granteeId = self.granteeId {
            try encodeContainer.encode(granteeId, forKey: .granteeId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteMailboxPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMailboxPermissionsInput: Swift.Equatable {
    /// The identifier of the entity that owns the mailbox. The identifier can be UserId or Group Id, Username or Groupname, or email.
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier of the entity for which to delete granted permissions. The identifier can be UserId, ResourceID, or Group Id, Username or Groupname, or email.
    ///
    /// * Grantee ID: 12345678-1234-1234-1234-123456789012,r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: grantee@domain.tld
    ///
    /// * Grantee name: grantee
    /// This member is required.
    public var granteeId: Swift.String?
    /// The identifier of the organization under which the member (user or group) exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        granteeId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.granteeId = granteeId
        self.organizationId = organizationId
    }
}

struct DeleteMailboxPermissionsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let granteeId: Swift.String?
}

extension DeleteMailboxPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let granteeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteeId)
        granteeId = granteeIdDecoded
    }
}

extension DeleteMailboxPermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMailboxPermissionsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMailboxPermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMobileDeviceAccessOverrideInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DeleteMobileDeviceAccessOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMobileDeviceAccessOverrideInput: Swift.Equatable {
    /// The mobile device for which you delete the override. DeviceId is case insensitive.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The WorkMail organization for which the access override will be deleted.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail user for which you want to delete the override. Accepts the following types of user identities:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct DeleteMobileDeviceAccessOverrideInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
    let deviceId: Swift.String?
}

extension DeleteMobileDeviceAccessOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension DeleteMobileDeviceAccessOverrideOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMobileDeviceAccessOverrideOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMobileDeviceAccessOverrideOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMobileDeviceAccessRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mobileDeviceAccessRuleId = self.mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteMobileDeviceAccessRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMobileDeviceAccessRuleInput: Swift.Equatable {
    /// The identifier of the rule to be deleted.
    /// This member is required.
    public var mobileDeviceAccessRuleId: Swift.String?
    /// The WorkMail organization under which the rule will be deleted.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        mobileDeviceAccessRuleId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
        self.organizationId = organizationId
    }
}

struct DeleteMobileDeviceAccessRuleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let mobileDeviceAccessRuleId: Swift.String?
}

extension DeleteMobileDeviceAccessRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
    }
}

extension DeleteMobileDeviceAccessRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMobileDeviceAccessRuleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMobileDeviceAccessRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deleteDirectory = "DeleteDirectory"
        case forceDelete = "ForceDelete"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deleteDirectory = self.deleteDirectory {
            try encodeContainer.encode(deleteDirectory, forKey: .deleteDirectory)
        }
        if let forceDelete = self.forceDelete {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteOrganizationInput: Swift.Equatable {
    /// The idempotency token associated with the request.
    public var clientToken: Swift.String?
    /// If true, deletes the AWS Directory Service directory associated with the organization.
    /// This member is required.
    public var deleteDirectory: Swift.Bool?
    /// Deletes a WorkMail organization even if the organization has enabled users.
    public var forceDelete: Swift.Bool?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        deleteDirectory: Swift.Bool? = nil,
        forceDelete: Swift.Bool? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.deleteDirectory = deleteDirectory
        self.forceDelete = forceDelete
        self.organizationId = organizationId
    }
}

struct DeleteOrganizationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let organizationId: Swift.String?
    let deleteDirectory: Swift.Bool?
    let forceDelete: Swift.Bool?
}

extension DeleteOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deleteDirectory = "DeleteDirectory"
        case forceDelete = "ForceDelete"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let deleteDirectoryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteDirectory)
        deleteDirectory = deleteDirectoryDecoded
        let forceDeleteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
    }
}

extension DeleteOrganizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteOrganizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.organizationId = output.organizationId
            self.state = output.state
        } else {
            self.organizationId = nil
            self.state = nil
        }
    }
}

public struct DeleteOrganizationOutput: Swift.Equatable {
    /// The organization ID.
    public var organizationId: Swift.String?
    /// The state of the organization.
    public var state: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        state: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.state = state
    }
}

struct DeleteOrganizationOutputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let state: Swift.String?
}

extension DeleteOrganizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
    }
}

enum DeleteOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DeleteResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResourceInput: Swift.Equatable {
    /// The identifier associated with the organization from which the resource is deleted.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource to be deleted. The identifier can accept ResourceId, or Resourcename. The following identity formats are available:
    ///
    /// * Resource ID: r-0123456789a0123456789b0123456789
    ///
    /// * Resource name: resource
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct DeleteResourceInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let resourceId: Swift.String?
}

extension DeleteResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DeleteResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResourceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRetentionPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeleteRetentionPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRetentionPolicyInput: Swift.Equatable {
    /// The retention policy ID.
    /// This member is required.
    public var id: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        id: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.id = id
        self.organizationId = organizationId
    }
}

struct DeleteRetentionPolicyInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let id: Swift.String?
}

extension DeleteRetentionPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteRetentionPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRetentionPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRetentionPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The organization that contains the user to be deleted.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the user to be deleted. The identifier can be the UserId or Username. The following identity formats are available:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DeleteUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DirectoryServiceAuthenticationFailedException": return try await DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterFromWorkMailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeregisterFromWorkMailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterFromWorkMailInput: Swift.Equatable {
    /// The identifier for the member to be updated. The identifier can be UserId, ResourceId, or Group Id, Username, Resourcename, or Groupname, or email.
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the WorkMail entity exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct DeregisterFromWorkMailInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
}

extension DeregisterFromWorkMailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension DeregisterFromWorkMailOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterFromWorkMailOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterFromWorkMailOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterMailDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DeregisterMailDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterMailDomainInput: Swift.Equatable {
    /// The domain to deregister in WorkMail and SES.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization for which the domain will be deregistered.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

struct DeregisterMailDomainInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let domainName: Swift.String?
}

extension DeregisterMailDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DeregisterMailDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterMailDomainOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterMailDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidCustomSesConfigurationException": return try await InvalidCustomSesConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MailDomainInUseException": return try await MailDomainInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEmailMonitoringConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DescribeEmailMonitoringConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEmailMonitoringConfigurationInput: Swift.Equatable {
    /// The ID of the organization for which the email monitoring configuration is described.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct DescribeEmailMonitoringConfigurationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension DescribeEmailMonitoringConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension DescribeEmailMonitoringConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEmailMonitoringConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.logGroupArn = output.logGroupArn
            self.roleArn = output.roleArn
        } else {
            self.logGroupArn = nil
            self.roleArn = nil
        }
    }
}

public struct DescribeEmailMonitoringConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the CloudWatch Log group associated with the email monitoring configuration.
    public var logGroupArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM Role associated with the email monitoring configuration.
    public var roleArn: Swift.String?

    public init(
        logGroupArn: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.logGroupArn = logGroupArn
        self.roleArn = roleArn
    }
}

struct DescribeEmailMonitoringConfigurationOutputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let logGroupArn: Swift.String?
}

extension DescribeEmailMonitoringConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupArn = "LogGroupArn"
        case roleArn = "RoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

enum DescribeEmailMonitoringConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEntityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DescribeEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEntityInput: Swift.Equatable {
    /// The email under which the entity exists.
    /// This member is required.
    public var email: Swift.String?
    /// The identifier for the organization under which the entity exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        email: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.email = email
        self.organizationId = organizationId
    }
}

struct DescribeEntityInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let email: Swift.String?
}

extension DescribeEntityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension DescribeEntityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEntityOutputBody = try responseDecoder.decode(responseBody: data)
            self.entityId = output.entityId
            self.name = output.name
            self.type = output.type
        } else {
            self.entityId = nil
            self.name = nil
            self.type = nil
        }
    }
}

public struct DescribeEntityOutput: Swift.Equatable {
    /// The entity ID under which the entity exists.
    public var entityId: Swift.String?
    /// Username, GroupName, or ResourceName based on entity type.
    public var name: Swift.String?
    /// Entity type.
    public var type: WorkMailClientTypes.EntityType?

    public init(
        entityId: Swift.String? = nil,
        name: Swift.String? = nil,
        type: WorkMailClientTypes.EntityType? = nil
    )
    {
        self.entityId = entityId
        self.name = name
        self.type = type
    }
}

struct DescribeEntityOutputBody: Swift.Equatable {
    let entityId: Swift.String?
    let name: Swift.String?
    let type: WorkMailClientTypes.EntityType?
}

extension DescribeEntityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case name = "Name"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityType.self, forKey: .type)
        type = typeDecoded
    }
}

enum DescribeEntityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DescribeGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeGroupInput: Swift.Equatable {
    /// The identifier for the group to be described. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:
    ///
    /// * Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: group@domain.tld
    ///
    /// * Group name: group
    /// This member is required.
    public var groupId: Swift.String?
    /// The identifier for the organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.organizationId = organizationId
    }
}

struct DescribeGroupInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let groupId: Swift.String?
}

extension DescribeGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DescribeGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.disabledDate = output.disabledDate
            self.email = output.email
            self.enabledDate = output.enabledDate
            self.groupId = output.groupId
            self.hiddenFromGlobalAddressList = output.hiddenFromGlobalAddressList
            self.name = output.name
            self.state = output.state
        } else {
            self.disabledDate = nil
            self.email = nil
            self.enabledDate = nil
            self.groupId = nil
            self.hiddenFromGlobalAddressList = false
            self.name = nil
            self.state = nil
        }
    }
}

public struct DescribeGroupOutput: Swift.Equatable {
    /// The date and time when a user was deregistered from WorkMail, in UNIX epoch time format.
    public var disabledDate: ClientRuntime.Date?
    /// The email of the described group.
    public var email: Swift.String?
    /// The date and time when a user was registered to WorkMail, in UNIX epoch time format.
    public var enabledDate: ClientRuntime.Date?
    /// The identifier of the described group.
    public var groupId: Swift.String?
    /// If the value is set to true, the group is hidden from the address book.
    public var hiddenFromGlobalAddressList: Swift.Bool
    /// The name of the described group.
    public var name: Swift.String?
    /// The state of the user: enabled (registered to WorkMail) or disabled (deregistered or never registered to WorkMail).
    public var state: WorkMailClientTypes.EntityState?

    public init(
        disabledDate: ClientRuntime.Date? = nil,
        email: Swift.String? = nil,
        enabledDate: ClientRuntime.Date? = nil,
        groupId: Swift.String? = nil,
        hiddenFromGlobalAddressList: Swift.Bool = false,
        name: Swift.String? = nil,
        state: WorkMailClientTypes.EntityState? = nil
    )
    {
        self.disabledDate = disabledDate
        self.email = email
        self.enabledDate = enabledDate
        self.groupId = groupId
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.name = name
        self.state = state
    }
}

struct DescribeGroupOutputBody: Swift.Equatable {
    let groupId: Swift.String?
    let name: Swift.String?
    let email: Swift.String?
    let state: WorkMailClientTypes.EntityState?
    let enabledDate: ClientRuntime.Date?
    let disabledDate: ClientRuntime.Date?
    let hiddenFromGlobalAddressList: Swift.Bool
}

extension DescribeGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case groupId = "GroupId"
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case name = "Name"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
        let hiddenFromGlobalAddressListDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hiddenFromGlobalAddressList) ?? false
        hiddenFromGlobalAddressList = hiddenFromGlobalAddressListDecoded
    }
}

enum DescribeGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeInboundDmarcSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DescribeInboundDmarcSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInboundDmarcSettingsInput: Swift.Equatable {
    /// Lists the ID of the given organization.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct DescribeInboundDmarcSettingsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension DescribeInboundDmarcSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension DescribeInboundDmarcSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeInboundDmarcSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.enforced = output.enforced
        } else {
            self.enforced = false
        }
    }
}

public struct DescribeInboundDmarcSettingsOutput: Swift.Equatable {
    /// Lists the enforcement setting of the applied policy.
    public var enforced: Swift.Bool

    public init(
        enforced: Swift.Bool = false
    )
    {
        self.enforced = enforced
    }
}

struct DescribeInboundDmarcSettingsOutputBody: Swift.Equatable {
    let enforced: Swift.Bool
}

extension DescribeInboundDmarcSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enforced = "Enforced"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforcedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforced) ?? false
        enforced = enforcedDecoded
    }
}

enum DescribeInboundDmarcSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMailboxExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DescribeMailboxExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMailboxExportJobInput: Swift.Equatable {
    /// The mailbox export job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.organizationId = organizationId
    }
}

struct DescribeMailboxExportJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let organizationId: Swift.String?
}

extension DescribeMailboxExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension DescribeMailboxExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMailboxExportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.endTime = output.endTime
            self.entityId = output.entityId
            self.errorInfo = output.errorInfo
            self.estimatedProgress = output.estimatedProgress
            self.kmsKeyArn = output.kmsKeyArn
            self.roleArn = output.roleArn
            self.s3BucketName = output.s3BucketName
            self.s3Path = output.s3Path
            self.s3Prefix = output.s3Prefix
            self.startTime = output.startTime
            self.state = output.state
        } else {
            self.description = nil
            self.endTime = nil
            self.entityId = nil
            self.errorInfo = nil
            self.estimatedProgress = 0
            self.kmsKeyArn = nil
            self.roleArn = nil
            self.s3BucketName = nil
            self.s3Path = nil
            self.s3Prefix = nil
            self.startTime = nil
            self.state = nil
        }
    }
}

public struct DescribeMailboxExportJobOutput: Swift.Equatable {
    /// The mailbox export job description.
    public var description: Swift.String?
    /// The mailbox export job end timestamp.
    public var endTime: ClientRuntime.Date?
    /// The identifier of the user or resource associated with the mailbox.
    public var entityId: Swift.String?
    /// Error information for failed mailbox export jobs.
    public var errorInfo: Swift.String?
    /// The estimated progress of the mailbox export job, in percentage points.
    public var estimatedProgress: Swift.Int
    /// The Amazon Resource Name (ARN) of the symmetric AWS Key Management Service (AWS KMS) key that encrypts the exported mailbox content.
    public var kmsKeyArn: Swift.String?
    /// The ARN of the AWS Identity and Access Management (IAM) role that grants write permission to the Amazon Simple Storage Service (Amazon S3) bucket.
    public var roleArn: Swift.String?
    /// The name of the S3 bucket.
    public var s3BucketName: Swift.String?
    /// The path to the S3 bucket and file that the mailbox export job is exporting to.
    public var s3Path: Swift.String?
    /// The S3 bucket prefix.
    public var s3Prefix: Swift.String?
    /// The mailbox export job start timestamp.
    public var startTime: ClientRuntime.Date?
    /// The state of the mailbox export job.
    public var state: WorkMailClientTypes.MailboxExportJobState?

    public init(
        description: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        entityId: Swift.String? = nil,
        errorInfo: Swift.String? = nil,
        estimatedProgress: Swift.Int = 0,
        kmsKeyArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3Path: Swift.String? = nil,
        s3Prefix: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        state: WorkMailClientTypes.MailboxExportJobState? = nil
    )
    {
        self.description = description
        self.endTime = endTime
        self.entityId = entityId
        self.errorInfo = errorInfo
        self.estimatedProgress = estimatedProgress
        self.kmsKeyArn = kmsKeyArn
        self.roleArn = roleArn
        self.s3BucketName = s3BucketName
        self.s3Path = s3Path
        self.s3Prefix = s3Prefix
        self.startTime = startTime
        self.state = state
    }
}

struct DescribeMailboxExportJobOutputBody: Swift.Equatable {
    let entityId: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let kmsKeyArn: Swift.String?
    let s3BucketName: Swift.String?
    let s3Prefix: Swift.String?
    let s3Path: Swift.String?
    let estimatedProgress: Swift.Int
    let state: WorkMailClientTypes.MailboxExportJobState?
    let errorInfo: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
}

extension DescribeMailboxExportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case endTime = "EndTime"
        case entityId = "EntityId"
        case errorInfo = "ErrorInfo"
        case estimatedProgress = "EstimatedProgress"
        case kmsKeyArn = "KmsKeyArn"
        case roleArn = "RoleArn"
        case s3BucketName = "S3BucketName"
        case s3Path = "S3Path"
        case s3Prefix = "S3Prefix"
        case startTime = "StartTime"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let estimatedProgressDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedProgress) ?? 0
        estimatedProgress = estimatedProgressDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MailboxExportJobState.self, forKey: .state)
        state = stateDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

enum DescribeMailboxExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DescribeOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeOrganizationInput: Swift.Equatable {
    /// The identifier for the organization to be described.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct DescribeOrganizationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension DescribeOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension DescribeOrganizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOrganizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.arn = output.arn
            self.completedDate = output.completedDate
            self.defaultMailDomain = output.defaultMailDomain
            self.directoryId = output.directoryId
            self.directoryType = output.directoryType
            self.errorMessage = output.errorMessage
            self.interoperabilityEnabled = output.interoperabilityEnabled
            self.migrationAdmin = output.migrationAdmin
            self.organizationId = output.organizationId
            self.state = output.state
        } else {
            self.arn = nil
            self.alias = nil
            self.completedDate = nil
            self.defaultMailDomain = nil
            self.directoryId = nil
            self.directoryType = nil
            self.errorMessage = nil
            self.interoperabilityEnabled = false
            self.migrationAdmin = nil
            self.organizationId = nil
            self.state = nil
        }
    }
}

public struct DescribeOrganizationOutput: Swift.Equatable {
    /// The alias for an organization.
    public var alias: Swift.String?
    /// The Amazon Resource Name (ARN) of the organization.
    public var arn: Swift.String?
    /// The date at which the organization became usable in the WorkMail context, in UNIX epoch time format.
    public var completedDate: ClientRuntime.Date?
    /// The default mail domain associated with the organization.
    public var defaultMailDomain: Swift.String?
    /// The identifier for the directory associated with an WorkMail organization.
    public var directoryId: Swift.String?
    /// The type of directory associated with the WorkMail organization.
    public var directoryType: Swift.String?
    /// (Optional) The error message indicating if unexpected behavior was encountered with regards to the organization.
    public var errorMessage: Swift.String?
    /// Indicates if interoperability is enabled for this organization.
    public var interoperabilityEnabled: Swift.Bool
    /// The user ID of the migration admin if migration is enabled for the organization.
    public var migrationAdmin: Swift.String?
    /// The identifier of an organization.
    public var organizationId: Swift.String?
    /// The state of an organization.
    public var state: Swift.String?

    public init(
        alias: Swift.String? = nil,
        arn: Swift.String? = nil,
        completedDate: ClientRuntime.Date? = nil,
        defaultMailDomain: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        directoryType: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        interoperabilityEnabled: Swift.Bool = false,
        migrationAdmin: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        state: Swift.String? = nil
    )
    {
        self.alias = alias
        self.arn = arn
        self.completedDate = completedDate
        self.defaultMailDomain = defaultMailDomain
        self.directoryId = directoryId
        self.directoryType = directoryType
        self.errorMessage = errorMessage
        self.interoperabilityEnabled = interoperabilityEnabled
        self.migrationAdmin = migrationAdmin
        self.organizationId = organizationId
        self.state = state
    }
}

struct DescribeOrganizationOutputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let alias: Swift.String?
    let state: Swift.String?
    let directoryId: Swift.String?
    let directoryType: Swift.String?
    let defaultMailDomain: Swift.String?
    let completedDate: ClientRuntime.Date?
    let errorMessage: Swift.String?
    let arn: Swift.String?
    let migrationAdmin: Swift.String?
    let interoperabilityEnabled: Swift.Bool
}

extension DescribeOrganizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case alias = "Alias"
        case completedDate = "CompletedDate"
        case defaultMailDomain = "DefaultMailDomain"
        case directoryId = "DirectoryId"
        case directoryType = "DirectoryType"
        case errorMessage = "ErrorMessage"
        case interoperabilityEnabled = "InteroperabilityEnabled"
        case migrationAdmin = "MigrationAdmin"
        case organizationId = "OrganizationId"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let directoryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryType)
        directoryType = directoryTypeDecoded
        let defaultMailDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultMailDomain)
        defaultMailDomain = defaultMailDomainDecoded
        let completedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completedDate)
        completedDate = completedDateDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let migrationAdminDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationAdmin)
        migrationAdmin = migrationAdminDecoded
        let interoperabilityEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .interoperabilityEnabled) ?? false
        interoperabilityEnabled = interoperabilityEnabledDecoded
    }
}

enum DescribeOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DescribeResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeResourceInput: Swift.Equatable {
    /// The identifier associated with the organization for which the resource is described.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource to be described. The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:
    ///
    /// * Resource ID: r-0123456789a0123456789b0123456789
    ///
    /// * Email address: resource@domain.tld
    ///
    /// * Resource name: resource
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct DescribeResourceInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let resourceId: Swift.String?
}

extension DescribeResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DescribeResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.bookingOptions = output.bookingOptions
            self.description = output.description
            self.disabledDate = output.disabledDate
            self.email = output.email
            self.enabledDate = output.enabledDate
            self.hiddenFromGlobalAddressList = output.hiddenFromGlobalAddressList
            self.name = output.name
            self.resourceId = output.resourceId
            self.state = output.state
            self.type = output.type
        } else {
            self.bookingOptions = nil
            self.description = nil
            self.disabledDate = nil
            self.email = nil
            self.enabledDate = nil
            self.hiddenFromGlobalAddressList = false
            self.name = nil
            self.resourceId = nil
            self.state = nil
            self.type = nil
        }
    }
}

public struct DescribeResourceOutput: Swift.Equatable {
    /// The booking options for the described resource.
    public var bookingOptions: WorkMailClientTypes.BookingOptions?
    /// Description of the resource.
    public var description: Swift.String?
    /// The date and time when a resource was disabled from WorkMail, in UNIX epoch time format.
    public var disabledDate: ClientRuntime.Date?
    /// The email of the described resource.
    public var email: Swift.String?
    /// The date and time when a resource was enabled for WorkMail, in UNIX epoch time format.
    public var enabledDate: ClientRuntime.Date?
    /// If enabled, the resource is hidden from the global address list.
    public var hiddenFromGlobalAddressList: Swift.Bool
    /// The name of the described resource.
    public var name: Swift.String?
    /// The identifier of the described resource.
    public var resourceId: Swift.String?
    /// The state of the resource: enabled (registered to WorkMail), disabled (deregistered or never registered to WorkMail), or deleted.
    public var state: WorkMailClientTypes.EntityState?
    /// The type of the described resource.
    public var type: WorkMailClientTypes.ResourceType?

    public init(
        bookingOptions: WorkMailClientTypes.BookingOptions? = nil,
        description: Swift.String? = nil,
        disabledDate: ClientRuntime.Date? = nil,
        email: Swift.String? = nil,
        enabledDate: ClientRuntime.Date? = nil,
        hiddenFromGlobalAddressList: Swift.Bool = false,
        name: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        state: WorkMailClientTypes.EntityState? = nil,
        type: WorkMailClientTypes.ResourceType? = nil
    )
    {
        self.bookingOptions = bookingOptions
        self.description = description
        self.disabledDate = disabledDate
        self.email = email
        self.enabledDate = enabledDate
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.name = name
        self.resourceId = resourceId
        self.state = state
        self.type = type
    }
}

struct DescribeResourceOutputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let email: Swift.String?
    let name: Swift.String?
    let type: WorkMailClientTypes.ResourceType?
    let bookingOptions: WorkMailClientTypes.BookingOptions?
    let state: WorkMailClientTypes.EntityState?
    let enabledDate: ClientRuntime.Date?
    let disabledDate: ClientRuntime.Date?
    let description: Swift.String?
    let hiddenFromGlobalAddressList: Swift.Bool
}

extension DescribeResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bookingOptions = "BookingOptions"
        case description = "Description"
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case name = "Name"
        case resourceId = "ResourceId"
        case state = "State"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ResourceType.self, forKey: .type)
        type = typeDecoded
        let bookingOptionsDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.BookingOptions.self, forKey: .bookingOptions)
        bookingOptions = bookingOptionsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hiddenFromGlobalAddressListDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hiddenFromGlobalAddressList) ?? false
        hiddenFromGlobalAddressList = hiddenFromGlobalAddressListDecoded
    }
}

enum DescribeResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DescribeUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUserInput: Swift.Equatable {
    /// The identifier for the organization under which the user exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier for the user to be described. The identifier can be the UserId, Username, or email. The following identity formats are available:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct DescribeUserInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
}

extension DescribeUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DescribeUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserOutput(disabledDate: \(Swift.String(describing: disabledDate)), email: \(Swift.String(describing: email)), enabledDate: \(Swift.String(describing: enabledDate)), hiddenFromGlobalAddressList: \(Swift.String(describing: hiddenFromGlobalAddressList)), mailboxDeprovisionedDate: \(Swift.String(describing: mailboxDeprovisionedDate)), mailboxProvisionedDate: \(Swift.String(describing: mailboxProvisionedDate)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)), userId: \(Swift.String(describing: userId)), userRole: \(Swift.String(describing: userRole)), city: \"CONTENT_REDACTED\", company: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", department: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", initials: \"CONTENT_REDACTED\", jobTitle: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", office: \"CONTENT_REDACTED\", street: \"CONTENT_REDACTED\", telephone: \"CONTENT_REDACTED\", zipCode: \"CONTENT_REDACTED\")"}
}

extension DescribeUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.city = output.city
            self.company = output.company
            self.country = output.country
            self.department = output.department
            self.disabledDate = output.disabledDate
            self.displayName = output.displayName
            self.email = output.email
            self.enabledDate = output.enabledDate
            self.firstName = output.firstName
            self.hiddenFromGlobalAddressList = output.hiddenFromGlobalAddressList
            self.initials = output.initials
            self.jobTitle = output.jobTitle
            self.lastName = output.lastName
            self.mailboxDeprovisionedDate = output.mailboxDeprovisionedDate
            self.mailboxProvisionedDate = output.mailboxProvisionedDate
            self.name = output.name
            self.office = output.office
            self.state = output.state
            self.street = output.street
            self.telephone = output.telephone
            self.userId = output.userId
            self.userRole = output.userRole
            self.zipCode = output.zipCode
        } else {
            self.city = nil
            self.company = nil
            self.country = nil
            self.department = nil
            self.disabledDate = nil
            self.displayName = nil
            self.email = nil
            self.enabledDate = nil
            self.firstName = nil
            self.hiddenFromGlobalAddressList = false
            self.initials = nil
            self.jobTitle = nil
            self.lastName = nil
            self.mailboxDeprovisionedDate = nil
            self.mailboxProvisionedDate = nil
            self.name = nil
            self.office = nil
            self.state = nil
            self.street = nil
            self.telephone = nil
            self.userId = nil
            self.userRole = nil
            self.zipCode = nil
        }
    }
}

public struct DescribeUserOutput: Swift.Equatable {
    /// City where the user is located.
    public var city: Swift.String?
    /// Company of the user.
    public var company: Swift.String?
    /// Country where the user is located.
    public var country: Swift.String?
    /// Department of the user.
    public var department: Swift.String?
    /// The date and time at which the user was disabled for WorkMail usage, in UNIX epoch time format.
    public var disabledDate: ClientRuntime.Date?
    /// The display name of the user.
    public var displayName: Swift.String?
    /// The email of the user.
    public var email: Swift.String?
    /// The date and time at which the user was enabled for WorkMailusage, in UNIX epoch time format.
    public var enabledDate: ClientRuntime.Date?
    /// First name of the user.
    public var firstName: Swift.String?
    /// If enabled, the user is hidden from the global address list.
    public var hiddenFromGlobalAddressList: Swift.Bool
    /// Initials of the user.
    public var initials: Swift.String?
    /// Job title of the user.
    public var jobTitle: Swift.String?
    /// Last name of the user.
    public var lastName: Swift.String?
    /// The date when the mailbox was removed for the user.
    public var mailboxDeprovisionedDate: ClientRuntime.Date?
    /// The date when the mailbox was created for the user.
    public var mailboxProvisionedDate: ClientRuntime.Date?
    /// The name for the user.
    public var name: Swift.String?
    /// Office where the user is located.
    public var office: Swift.String?
    /// The state of a user: enabled (registered to WorkMail) or disabled (deregistered or never registered to WorkMail).
    public var state: WorkMailClientTypes.EntityState?
    /// Street where the user is located.
    public var street: Swift.String?
    /// User's contact number.
    public var telephone: Swift.String?
    /// The identifier for the described user.
    public var userId: Swift.String?
    /// In certain cases, other entities are modeled as users. If interoperability is enabled, resources are imported into WorkMail as users. Because different WorkMail organizations rely on different directory types, administrators can distinguish between an unregistered user (account is disabled and has a user role) and the directory administrators. The values are USER, RESOURCE, SYSTEM_USER, and REMOTE_USER.
    public var userRole: WorkMailClientTypes.UserRole?
    /// Zip code of the user.
    public var zipCode: Swift.String?

    public init(
        city: Swift.String? = nil,
        company: Swift.String? = nil,
        country: Swift.String? = nil,
        department: Swift.String? = nil,
        disabledDate: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        email: Swift.String? = nil,
        enabledDate: ClientRuntime.Date? = nil,
        firstName: Swift.String? = nil,
        hiddenFromGlobalAddressList: Swift.Bool = false,
        initials: Swift.String? = nil,
        jobTitle: Swift.String? = nil,
        lastName: Swift.String? = nil,
        mailboxDeprovisionedDate: ClientRuntime.Date? = nil,
        mailboxProvisionedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        office: Swift.String? = nil,
        state: WorkMailClientTypes.EntityState? = nil,
        street: Swift.String? = nil,
        telephone: Swift.String? = nil,
        userId: Swift.String? = nil,
        userRole: WorkMailClientTypes.UserRole? = nil,
        zipCode: Swift.String? = nil
    )
    {
        self.city = city
        self.company = company
        self.country = country
        self.department = department
        self.disabledDate = disabledDate
        self.displayName = displayName
        self.email = email
        self.enabledDate = enabledDate
        self.firstName = firstName
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.initials = initials
        self.jobTitle = jobTitle
        self.lastName = lastName
        self.mailboxDeprovisionedDate = mailboxDeprovisionedDate
        self.mailboxProvisionedDate = mailboxProvisionedDate
        self.name = name
        self.office = office
        self.state = state
        self.street = street
        self.telephone = telephone
        self.userId = userId
        self.userRole = userRole
        self.zipCode = zipCode
    }
}

struct DescribeUserOutputBody: Swift.Equatable {
    let userId: Swift.String?
    let name: Swift.String?
    let email: Swift.String?
    let displayName: Swift.String?
    let state: WorkMailClientTypes.EntityState?
    let userRole: WorkMailClientTypes.UserRole?
    let enabledDate: ClientRuntime.Date?
    let disabledDate: ClientRuntime.Date?
    let mailboxProvisionedDate: ClientRuntime.Date?
    let mailboxDeprovisionedDate: ClientRuntime.Date?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let hiddenFromGlobalAddressList: Swift.Bool
    let initials: Swift.String?
    let telephone: Swift.String?
    let street: Swift.String?
    let jobTitle: Swift.String?
    let city: Swift.String?
    let company: Swift.String?
    let zipCode: Swift.String?
    let department: Swift.String?
    let country: Swift.String?
    let office: Swift.String?
}

extension DescribeUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city = "City"
        case company = "Company"
        case country = "Country"
        case department = "Department"
        case disabledDate = "DisabledDate"
        case displayName = "DisplayName"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case firstName = "FirstName"
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case initials = "Initials"
        case jobTitle = "JobTitle"
        case lastName = "LastName"
        case mailboxDeprovisionedDate = "MailboxDeprovisionedDate"
        case mailboxProvisionedDate = "MailboxProvisionedDate"
        case name = "Name"
        case office = "Office"
        case state = "State"
        case street = "Street"
        case telephone = "Telephone"
        case userId = "UserId"
        case userRole = "UserRole"
        case zipCode = "ZipCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let userRoleDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.UserRole.self, forKey: .userRole)
        userRole = userRoleDecoded
        let enabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
        let mailboxProvisionedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .mailboxProvisionedDate)
        mailboxProvisionedDate = mailboxProvisionedDateDecoded
        let mailboxDeprovisionedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .mailboxDeprovisionedDate)
        mailboxDeprovisionedDate = mailboxDeprovisionedDateDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let hiddenFromGlobalAddressListDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hiddenFromGlobalAddressList) ?? false
        hiddenFromGlobalAddressList = hiddenFromGlobalAddressListDecoded
        let initialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initials)
        initials = initialsDecoded
        let telephoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .telephone)
        telephone = telephoneDecoded
        let streetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street)
        street = streetDecoded
        let jobTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobTitle)
        jobTitle = jobTitleDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let companyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .company)
        company = companyDecoded
        let zipCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zipCode)
        zipCode = zipCodeDecoded
        let departmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .department)
        department = departmentDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let officeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .office)
        office = officeDecoded
    }
}

enum DescribeUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DirectoryInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The directory is already in use by another WorkMail organization in the same account and Region.
public struct DirectoryInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DirectoryInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DirectoryInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryServiceAuthenticationFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryServiceAuthenticationFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The directory service doesn't recognize the credentials supplied by WorkMail.
public struct DirectoryServiceAuthenticationFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryServiceAuthenticationFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DirectoryServiceAuthenticationFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DirectoryServiceAuthenticationFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The directory is unavailable. It might be located in another Region or deleted.
public struct DirectoryUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryUnavailableException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DirectoryUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DirectoryUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DisassociateDelegateFromResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DisassociateDelegateFromResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateDelegateFromResourceInput: Swift.Equatable {
    /// The identifier for the member (user, group) to be removed from the resource's delegates. The entity ID can accept UserId or GroupID, Username or Groupname, or email.
    ///
    /// * Entity: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the resource exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource from which delegates' set members are removed. The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:
    ///
    /// * Resource ID: r-0123456789a0123456789b0123456789
    ///
    /// * Email address: resource@domain.tld
    ///
    /// * Resource name: resource
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct DisassociateDelegateFromResourceInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let resourceId: Swift.String?
    let entityId: Swift.String?
}

extension DisassociateDelegateFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension DisassociateDelegateFromResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateDelegateFromResourceOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateDelegateFromResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateMemberFromGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension DisassociateMemberFromGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateMemberFromGroupInput: Swift.Equatable {
    /// The identifier for the group from which members are removed. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:
    ///
    /// * Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: group@domain.tld
    ///
    /// * Group name: group
    /// This member is required.
    public var groupId: Swift.String?
    /// The identifier for the member to be removed from the group. The member ID can accept UserID or GroupId, Username or Groupname, or email.
    ///
    /// * Member ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: member@domain.tld
    ///
    /// * Member name: member
    /// This member is required.
    public var memberId: Swift.String?
    /// The identifier for the organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.memberId = memberId
        self.organizationId = organizationId
    }
}

struct DisassociateMemberFromGroupInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let groupId: Swift.String?
    let memberId: Swift.String?
}

extension DisassociateMemberFromGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension DisassociateMemberFromGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateMemberFromGroupOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateMemberFromGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DirectoryServiceAuthenticationFailedException": return try await DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkMailClientTypes.DnsRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname = "Hostname"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension WorkMailClientTypes {
    /// A DNS record uploaded to your DNS provider.
    public struct DnsRecord: Swift.Equatable {
        /// The DNS hostname.- For example, domain.example.com.
        public var hostname: Swift.String?
        /// The RFC 1035 record type. Possible values: CNAME, A, MX.
        public var type: Swift.String?
        /// The value returned by the DNS for a query to that hostname and record type.
        public var value: Swift.String?

        public init(
            hostname: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.hostname = hostname
            self.type = type
            self.value = value
        }
    }

}

extension WorkMailClientTypes {
    public enum DnsRecordVerificationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case verified
        case sdkUnknown(Swift.String)

        public static var allCases: [DnsRecordVerificationStatus] {
            return [
                .failed,
                .pending,
                .verified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .verified: return "VERIFIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DnsRecordVerificationStatus(rawValue: rawValue) ?? DnsRecordVerificationStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes.Domain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case hostedZoneId = "HostedZoneId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let hostedZoneId = self.hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension WorkMailClientTypes {
    /// The domain to associate with an WorkMail organization. When you configure a domain hosted in Amazon Route 53 (Route 53), all recommended DNS records are added to the organization when you create it. For more information, see [Adding a domain](https://docs.aws.amazon.com/workmail/latest/adminguide/add_domain.html) in the WorkMail Administrator Guide.
    public struct Domain: Swift.Equatable {
        /// The fully qualified domain name.
        /// This member is required.
        public var domainName: Swift.String?
        /// The hosted zone ID for a domain hosted in Route 53. Required when configuring a domain hosted in Route 53.
        public var hostedZoneId: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }
    }

}

extension EmailAddressInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EmailAddressInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The email address that you're trying to assign is already created for a different user, group, or resource.
public struct EmailAddressInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EmailAddressInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EmailAddressInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EmailAddressInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityAlreadyRegisteredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EntityAlreadyRegisteredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user, group, or resource that you're trying to register is already registered.
public struct EntityAlreadyRegisteredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityAlreadyRegisteredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EntityAlreadyRegisteredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntityAlreadyRegisteredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EntityNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The identifier supplied for the user, group, or resource does not exist in your organization.
public struct EntityNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EntityNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntityNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes {
    public enum EntityState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityState] {
            return [
                .deleted,
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityState(rawValue: rawValue) ?? EntityState.sdkUnknown(rawValue)
        }
    }
}

extension EntityStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EntityStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You are performing an operation on a user, group, or resource that isn't in the expected state, such as trying to delete an active user.
public struct EntityStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EntityStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntityStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes {
    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case resource
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .group,
                .resource,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .resource: return "RESOURCE"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes.EwsAvailabilityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ewsEndpoint = "EwsEndpoint"
        case ewsPassword = "EwsPassword"
        case ewsUsername = "EwsUsername"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ewsEndpoint = self.ewsEndpoint {
            try encodeContainer.encode(ewsEndpoint, forKey: .ewsEndpoint)
        }
        if let ewsPassword = self.ewsPassword {
            try encodeContainer.encode(ewsPassword, forKey: .ewsPassword)
        }
        if let ewsUsername = self.ewsUsername {
            try encodeContainer.encode(ewsUsername, forKey: .ewsUsername)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ewsEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ewsEndpoint)
        ewsEndpoint = ewsEndpointDecoded
        let ewsUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ewsUsername)
        ewsUsername = ewsUsernameDecoded
        let ewsPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ewsPassword)
        ewsPassword = ewsPasswordDecoded
    }
}

extension WorkMailClientTypes.EwsAvailabilityProvider: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EwsAvailabilityProvider(ewsEndpoint: \(Swift.String(describing: ewsEndpoint)), ewsUsername: \(Swift.String(describing: ewsUsername)), ewsPassword: \"CONTENT_REDACTED\")"}
}

extension WorkMailClientTypes {
    /// Describes an EWS based availability provider. This is only used as input to the service.
    public struct EwsAvailabilityProvider: Swift.Equatable {
        /// The endpoint of the remote EWS server.
        /// This member is required.
        public var ewsEndpoint: Swift.String?
        /// The password used to authenticate the remote EWS server.
        /// This member is required.
        public var ewsPassword: Swift.String?
        /// The username used to authenticate the remote EWS server.
        /// This member is required.
        public var ewsUsername: Swift.String?

        public init(
            ewsEndpoint: Swift.String? = nil,
            ewsPassword: Swift.String? = nil,
            ewsUsername: Swift.String? = nil
        )
        {
            self.ewsEndpoint = ewsEndpoint
            self.ewsPassword = ewsPassword
            self.ewsUsername = ewsUsername
        }
    }

}

extension WorkMailClientTypes.FolderConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case name = "Name"
        case period = "Period"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let period = self.period {
            try encodeContainer.encode(period, forKey: .period)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.FolderName.self, forKey: .name)
        name = nameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.RetentionAction.self, forKey: .action)
        action = actionDecoded
        let periodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .period)
        period = periodDecoded
    }
}

extension WorkMailClientTypes {
    /// The configuration applied to an organization's folders by its retention policy.
    public struct FolderConfiguration: Swift.Equatable {
        /// The action to take on the folder contents at the end of the folder configuration period.
        /// This member is required.
        public var action: WorkMailClientTypes.RetentionAction?
        /// The folder name.
        /// This member is required.
        public var name: WorkMailClientTypes.FolderName?
        /// The number of days for which the folder-configuration action applies.
        public var period: Swift.Int?

        public init(
            action: WorkMailClientTypes.RetentionAction? = nil,
            name: WorkMailClientTypes.FolderName? = nil,
            period: Swift.Int? = nil
        )
        {
            self.action = action
            self.name = name
            self.period = period
        }
    }

}

extension WorkMailClientTypes {
    public enum FolderName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deletedItems
        case drafts
        case inbox
        case junkEmail
        case sentItems
        case sdkUnknown(Swift.String)

        public static var allCases: [FolderName] {
            return [
                .deletedItems,
                .drafts,
                .inbox,
                .junkEmail,
                .sentItems,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deletedItems: return "DELETED_ITEMS"
            case .drafts: return "DRAFTS"
            case .inbox: return "INBOX"
            case .junkEmail: return "JUNK_EMAIL"
            case .sentItems: return "SENT_ITEMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FolderName(rawValue: rawValue) ?? FolderName.sdkUnknown(rawValue)
        }
    }
}

extension GetAccessControlEffectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case impersonationRoleId = "ImpersonationRoleId"
        case ipAddress = "IpAddress"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let impersonationRoleId = self.impersonationRoleId {
            try encodeContainer.encode(impersonationRoleId, forKey: .impersonationRoleId)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension GetAccessControlEffectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccessControlEffectInput: Swift.Equatable {
    /// The access protocol action. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
    /// This member is required.
    public var action: Swift.String?
    /// The impersonation role ID.
    public var impersonationRoleId: Swift.String?
    /// The IPv4 address.
    /// This member is required.
    public var ipAddress: Swift.String?
    /// The identifier for the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The user ID.
    public var userId: Swift.String?

    public init(
        action: Swift.String? = nil,
        impersonationRoleId: Swift.String? = nil,
        ipAddress: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.action = action
        self.impersonationRoleId = impersonationRoleId
        self.ipAddress = ipAddress
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct GetAccessControlEffectInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let ipAddress: Swift.String?
    let action: Swift.String?
    let userId: Swift.String?
    let impersonationRoleId: Swift.String?
}

extension GetAccessControlEffectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case impersonationRoleId = "ImpersonationRoleId"
        case ipAddress = "IpAddress"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
    }
}

extension GetAccessControlEffectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessControlEffectOutputBody = try responseDecoder.decode(responseBody: data)
            self.effect = output.effect
            self.matchedRules = output.matchedRules
        } else {
            self.effect = nil
            self.matchedRules = nil
        }
    }
}

public struct GetAccessControlEffectOutput: Swift.Equatable {
    /// The rule effect.
    public var effect: WorkMailClientTypes.AccessControlRuleEffect?
    /// The rules that match the given parameters, resulting in an effect.
    public var matchedRules: [Swift.String]?

    public init(
        effect: WorkMailClientTypes.AccessControlRuleEffect? = nil,
        matchedRules: [Swift.String]? = nil
    )
    {
        self.effect = effect
        self.matchedRules = matchedRules
    }
}

struct GetAccessControlEffectOutputBody: Swift.Equatable {
    let effect: WorkMailClientTypes.AccessControlRuleEffect?
    let matchedRules: [Swift.String]?
}

extension GetAccessControlEffectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effect = "Effect"
        case matchedRules = "MatchedRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AccessControlRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let matchedRulesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .matchedRules)
        var matchedRulesDecoded0:[Swift.String]? = nil
        if let matchedRulesContainer = matchedRulesContainer {
            matchedRulesDecoded0 = [Swift.String]()
            for string0 in matchedRulesContainer {
                if let string0 = string0 {
                    matchedRulesDecoded0?.append(string0)
                }
            }
        }
        matchedRules = matchedRulesDecoded0
    }
}

enum GetAccessControlEffectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDefaultRetentionPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension GetDefaultRetentionPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDefaultRetentionPolicyInput: Swift.Equatable {
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct GetDefaultRetentionPolicyInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension GetDefaultRetentionPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension GetDefaultRetentionPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDefaultRetentionPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.folderConfigurations = output.folderConfigurations
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.folderConfigurations = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct GetDefaultRetentionPolicyOutput: Swift.Equatable {
    /// The retention policy description.
    public var description: Swift.String?
    /// The retention policy folder configurations.
    public var folderConfigurations: [WorkMailClientTypes.FolderConfiguration]?
    /// The retention policy ID.
    public var id: Swift.String?
    /// The retention policy name.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        folderConfigurations: [WorkMailClientTypes.FolderConfiguration]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.folderConfigurations = folderConfigurations
        self.id = id
        self.name = name
    }
}

struct GetDefaultRetentionPolicyOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let folderConfigurations: [WorkMailClientTypes.FolderConfiguration]?
}

extension GetDefaultRetentionPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case folderConfigurations = "FolderConfigurations"
        case id = "Id"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let folderConfigurationsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.FolderConfiguration?].self, forKey: .folderConfigurations)
        var folderConfigurationsDecoded0:[WorkMailClientTypes.FolderConfiguration]? = nil
        if let folderConfigurationsContainer = folderConfigurationsContainer {
            folderConfigurationsDecoded0 = [WorkMailClientTypes.FolderConfiguration]()
            for structure0 in folderConfigurationsContainer {
                if let structure0 = structure0 {
                    folderConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        folderConfigurations = folderConfigurationsDecoded0
    }
}

enum GetDefaultRetentionPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetImpersonationRoleEffectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
        case targetUser = "TargetUser"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let impersonationRoleId = self.impersonationRoleId {
            try encodeContainer.encode(impersonationRoleId, forKey: .impersonationRoleId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let targetUser = self.targetUser {
            try encodeContainer.encode(targetUser, forKey: .targetUser)
        }
    }
}

extension GetImpersonationRoleEffectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetImpersonationRoleEffectInput: Swift.Equatable {
    /// The impersonation role ID to test.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The WorkMail organization where the impersonation role is defined.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail organization user chosen to test the impersonation role. The following identity formats are available:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var targetUser: Swift.String?

    public init(
        impersonationRoleId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        targetUser: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
        self.organizationId = organizationId
        self.targetUser = targetUser
    }
}

struct GetImpersonationRoleEffectInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let impersonationRoleId: Swift.String?
    let targetUser: Swift.String?
}

extension GetImpersonationRoleEffectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
        case targetUser = "TargetUser"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
        let targetUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetUser)
        targetUser = targetUserDecoded
    }
}

extension GetImpersonationRoleEffectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetImpersonationRoleEffectOutputBody = try responseDecoder.decode(responseBody: data)
            self.effect = output.effect
            self.matchedRules = output.matchedRules
            self.type = output.type
        } else {
            self.effect = nil
            self.matchedRules = nil
            self.type = nil
        }
    }
}

public struct GetImpersonationRoleEffectOutput: Swift.Equatable {
    /// Effect of the impersonation role on the target user based on its rules. Available effects are ALLOW or DENY.
    public var effect: WorkMailClientTypes.AccessEffect?
    /// A list of the rules that match the input and produce the configured effect.
    public var matchedRules: [WorkMailClientTypes.ImpersonationMatchedRule]?
    /// The impersonation role type.
    public var type: WorkMailClientTypes.ImpersonationRoleType?

    public init(
        effect: WorkMailClientTypes.AccessEffect? = nil,
        matchedRules: [WorkMailClientTypes.ImpersonationMatchedRule]? = nil,
        type: WorkMailClientTypes.ImpersonationRoleType? = nil
    )
    {
        self.effect = effect
        self.matchedRules = matchedRules
        self.type = type
    }
}

struct GetImpersonationRoleEffectOutputBody: Swift.Equatable {
    let type: WorkMailClientTypes.ImpersonationRoleType?
    let effect: WorkMailClientTypes.AccessEffect?
    let matchedRules: [WorkMailClientTypes.ImpersonationMatchedRule]?
}

extension GetImpersonationRoleEffectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effect = "Effect"
        case matchedRules = "MatchedRules"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ImpersonationRoleType.self, forKey: .type)
        type = typeDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AccessEffect.self, forKey: .effect)
        effect = effectDecoded
        let matchedRulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.ImpersonationMatchedRule?].self, forKey: .matchedRules)
        var matchedRulesDecoded0:[WorkMailClientTypes.ImpersonationMatchedRule]? = nil
        if let matchedRulesContainer = matchedRulesContainer {
            matchedRulesDecoded0 = [WorkMailClientTypes.ImpersonationMatchedRule]()
            for structure0 in matchedRulesContainer {
                if let structure0 = structure0 {
                    matchedRulesDecoded0?.append(structure0)
                }
            }
        }
        matchedRules = matchedRulesDecoded0
    }
}

enum GetImpersonationRoleEffectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetImpersonationRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let impersonationRoleId = self.impersonationRoleId {
            try encodeContainer.encode(impersonationRoleId, forKey: .impersonationRoleId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension GetImpersonationRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetImpersonationRoleInput: Swift.Equatable {
    /// The impersonation role ID to retrieve.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The WorkMail organization from which to retrieve the impersonation role.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        impersonationRoleId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
        self.organizationId = organizationId
    }
}

struct GetImpersonationRoleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let impersonationRoleId: Swift.String?
}

extension GetImpersonationRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRoleId = "ImpersonationRoleId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
    }
}

extension GetImpersonationRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetImpersonationRoleOutputBody = try responseDecoder.decode(responseBody: data)
            self.dateCreated = output.dateCreated
            self.dateModified = output.dateModified
            self.description = output.description
            self.impersonationRoleId = output.impersonationRoleId
            self.name = output.name
            self.rules = output.rules
            self.type = output.type
        } else {
            self.dateCreated = nil
            self.dateModified = nil
            self.description = nil
            self.impersonationRoleId = nil
            self.name = nil
            self.rules = nil
            self.type = nil
        }
    }
}

public struct GetImpersonationRoleOutput: Swift.Equatable {
    /// The date when the impersonation role was created.
    public var dateCreated: ClientRuntime.Date?
    /// The date when the impersonation role was last modified.
    public var dateModified: ClientRuntime.Date?
    /// The impersonation role description.
    public var description: Swift.String?
    /// The impersonation role ID.
    public var impersonationRoleId: Swift.String?
    /// The impersonation role name.
    public var name: Swift.String?
    /// The list of rules for the given impersonation role.
    public var rules: [WorkMailClientTypes.ImpersonationRule]?
    /// The impersonation role type.
    public var type: WorkMailClientTypes.ImpersonationRoleType?

    public init(
        dateCreated: ClientRuntime.Date? = nil,
        dateModified: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        impersonationRoleId: Swift.String? = nil,
        name: Swift.String? = nil,
        rules: [WorkMailClientTypes.ImpersonationRule]? = nil,
        type: WorkMailClientTypes.ImpersonationRoleType? = nil
    )
    {
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.description = description
        self.impersonationRoleId = impersonationRoleId
        self.name = name
        self.rules = rules
        self.type = type
    }
}

struct GetImpersonationRoleOutputBody: Swift.Equatable {
    let impersonationRoleId: Swift.String?
    let name: Swift.String?
    let type: WorkMailClientTypes.ImpersonationRoleType?
    let description: Swift.String?
    let rules: [WorkMailClientTypes.ImpersonationRule]?
    let dateCreated: ClientRuntime.Date?
    let dateModified: ClientRuntime.Date?
}

extension GetImpersonationRoleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case impersonationRoleId = "ImpersonationRoleId"
        case name = "Name"
        case rules = "Rules"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ImpersonationRoleType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.ImpersonationRule?].self, forKey: .rules)
        var rulesDecoded0:[WorkMailClientTypes.ImpersonationRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [WorkMailClientTypes.ImpersonationRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

enum GetImpersonationRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMailDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension GetMailDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMailDomainInput: Swift.Equatable {
    /// The domain from which you want to retrieve details.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization for which the domain is retrieved.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

struct GetMailDomainInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let domainName: Swift.String?
}

extension GetMailDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension GetMailDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMailDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.dkimVerificationStatus = output.dkimVerificationStatus
            self.isDefault = output.isDefault
            self.isTestDomain = output.isTestDomain
            self.ownershipVerificationStatus = output.ownershipVerificationStatus
            self.records = output.records
        } else {
            self.dkimVerificationStatus = nil
            self.isDefault = false
            self.isTestDomain = false
            self.ownershipVerificationStatus = nil
            self.records = nil
        }
    }
}

public struct GetMailDomainOutput: Swift.Equatable {
    /// Indicates the status of a DKIM verification.
    public var dkimVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus?
    /// Specifies whether the domain is the default domain for your organization.
    public var isDefault: Swift.Bool
    /// Specifies whether the domain is a test domain provided by WorkMail, or a custom domain.
    public var isTestDomain: Swift.Bool
    /// Indicates the status of the domain ownership verification.
    public var ownershipVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus?
    /// A list of the DNS records that WorkMail recommends adding in your DNS provider for the best user experience. The records configure your domain with DMARC, SPF, DKIM, and direct incoming email traffic to SES. See admin guide for more details.
    public var records: [WorkMailClientTypes.DnsRecord]?

    public init(
        dkimVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus? = nil,
        isDefault: Swift.Bool = false,
        isTestDomain: Swift.Bool = false,
        ownershipVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus? = nil,
        records: [WorkMailClientTypes.DnsRecord]? = nil
    )
    {
        self.dkimVerificationStatus = dkimVerificationStatus
        self.isDefault = isDefault
        self.isTestDomain = isTestDomain
        self.ownershipVerificationStatus = ownershipVerificationStatus
        self.records = records
    }
}

struct GetMailDomainOutputBody: Swift.Equatable {
    let records: [WorkMailClientTypes.DnsRecord]?
    let isTestDomain: Swift.Bool
    let isDefault: Swift.Bool
    let ownershipVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus?
    let dkimVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus?
}

extension GetMailDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dkimVerificationStatus = "DkimVerificationStatus"
        case isDefault = "IsDefault"
        case isTestDomain = "IsTestDomain"
        case ownershipVerificationStatus = "OwnershipVerificationStatus"
        case records = "Records"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.DnsRecord?].self, forKey: .records)
        var recordsDecoded0:[WorkMailClientTypes.DnsRecord]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [WorkMailClientTypes.DnsRecord]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let isTestDomainDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTestDomain) ?? false
        isTestDomain = isTestDomainDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault) ?? false
        isDefault = isDefaultDecoded
        let ownershipVerificationStatusDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.DnsRecordVerificationStatus.self, forKey: .ownershipVerificationStatus)
        ownershipVerificationStatus = ownershipVerificationStatusDecoded
        let dkimVerificationStatusDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.DnsRecordVerificationStatus.self, forKey: .dkimVerificationStatus)
        dkimVerificationStatus = dkimVerificationStatusDecoded
    }
}

enum GetMailDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MailDomainNotFoundException": return try await MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMailboxDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension GetMailboxDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMailboxDetailsInput: Swift.Equatable {
    /// The identifier for the organization that contains the user whose mailbox details are being requested.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier for the user whose mailbox details are being requested. The identifier can be the UserId, Username, or email. The following identity formats are available:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct GetMailboxDetailsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
}

extension GetMailboxDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension GetMailboxDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMailboxDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.mailboxQuota = output.mailboxQuota
            self.mailboxSize = output.mailboxSize
        } else {
            self.mailboxQuota = nil
            self.mailboxSize = 0.0
        }
    }
}

public struct GetMailboxDetailsOutput: Swift.Equatable {
    /// The maximum allowed mailbox size, in MB, for the specified user.
    public var mailboxQuota: Swift.Int?
    /// The current mailbox size, in MB, for the specified user.
    public var mailboxSize: Swift.Double

    public init(
        mailboxQuota: Swift.Int? = nil,
        mailboxSize: Swift.Double = 0.0
    )
    {
        self.mailboxQuota = mailboxQuota
        self.mailboxSize = mailboxSize
    }
}

struct GetMailboxDetailsOutputBody: Swift.Equatable {
    let mailboxQuota: Swift.Int?
    let mailboxSize: Swift.Double
}

extension GetMailboxDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mailboxQuota = "MailboxQuota"
        case mailboxSize = "MailboxSize"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailboxQuotaDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mailboxQuota)
        mailboxQuota = mailboxQuotaDecoded
        let mailboxSizeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .mailboxSize) ?? 0.0
        mailboxSize = mailboxSizeDecoded
    }
}

enum GetMailboxDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMobileDeviceAccessEffectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceModel = "DeviceModel"
        case deviceOperatingSystem = "DeviceOperatingSystem"
        case deviceType = "DeviceType"
        case deviceUserAgent = "DeviceUserAgent"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceModel = self.deviceModel {
            try encodeContainer.encode(deviceModel, forKey: .deviceModel)
        }
        if let deviceOperatingSystem = self.deviceOperatingSystem {
            try encodeContainer.encode(deviceOperatingSystem, forKey: .deviceOperatingSystem)
        }
        if let deviceType = self.deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let deviceUserAgent = self.deviceUserAgent {
            try encodeContainer.encode(deviceUserAgent, forKey: .deviceUserAgent)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension GetMobileDeviceAccessEffectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMobileDeviceAccessEffectInput: Swift.Equatable {
    /// Device model the simulated user will report.
    public var deviceModel: Swift.String?
    /// Device operating system the simulated user will report.
    public var deviceOperatingSystem: Swift.String?
    /// Device type the simulated user will report.
    public var deviceType: Swift.String?
    /// Device user agent the simulated user will report.
    public var deviceUserAgent: Swift.String?
    /// The WorkMail organization to simulate the access effect for.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        deviceModel: Swift.String? = nil,
        deviceOperatingSystem: Swift.String? = nil,
        deviceType: Swift.String? = nil,
        deviceUserAgent: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.deviceModel = deviceModel
        self.deviceOperatingSystem = deviceOperatingSystem
        self.deviceType = deviceType
        self.deviceUserAgent = deviceUserAgent
        self.organizationId = organizationId
    }
}

struct GetMobileDeviceAccessEffectInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let deviceType: Swift.String?
    let deviceModel: Swift.String?
    let deviceOperatingSystem: Swift.String?
    let deviceUserAgent: Swift.String?
}

extension GetMobileDeviceAccessEffectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceModel = "DeviceModel"
        case deviceOperatingSystem = "DeviceOperatingSystem"
        case deviceType = "DeviceType"
        case deviceUserAgent = "DeviceUserAgent"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceModel)
        deviceModel = deviceModelDecoded
        let deviceOperatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceOperatingSystem)
        deviceOperatingSystem = deviceOperatingSystemDecoded
        let deviceUserAgentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceUserAgent)
        deviceUserAgent = deviceUserAgentDecoded
    }
}

extension GetMobileDeviceAccessEffectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMobileDeviceAccessEffectOutputBody = try responseDecoder.decode(responseBody: data)
            self.effect = output.effect
            self.matchedRules = output.matchedRules
        } else {
            self.effect = nil
            self.matchedRules = nil
        }
    }
}

public struct GetMobileDeviceAccessEffectOutput: Swift.Equatable {
    /// The effect of the simulated access, ALLOW or DENY, after evaluating mobile device access rules in the WorkMail organization for the simulated user parameters.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// A list of the rules which matched the simulated user input and produced the effect.
    public var matchedRules: [WorkMailClientTypes.MobileDeviceAccessMatchedRule]?

    public init(
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        matchedRules: [WorkMailClientTypes.MobileDeviceAccessMatchedRule]? = nil
    )
    {
        self.effect = effect
        self.matchedRules = matchedRules
    }
}

struct GetMobileDeviceAccessEffectOutputBody: Swift.Equatable {
    let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    let matchedRules: [WorkMailClientTypes.MobileDeviceAccessMatchedRule]?
}

extension GetMobileDeviceAccessEffectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effect = "Effect"
        case matchedRules = "MatchedRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let matchedRulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.MobileDeviceAccessMatchedRule?].self, forKey: .matchedRules)
        var matchedRulesDecoded0:[WorkMailClientTypes.MobileDeviceAccessMatchedRule]? = nil
        if let matchedRulesContainer = matchedRulesContainer {
            matchedRulesDecoded0 = [WorkMailClientTypes.MobileDeviceAccessMatchedRule]()
            for structure0 in matchedRulesContainer {
                if let structure0 = structure0 {
                    matchedRulesDecoded0?.append(structure0)
                }
            }
        }
        matchedRules = matchedRulesDecoded0
    }
}

enum GetMobileDeviceAccessEffectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMobileDeviceAccessOverrideInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension GetMobileDeviceAccessOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMobileDeviceAccessOverrideInput: Swift.Equatable {
    /// The mobile device to which the override applies. DeviceId is case insensitive.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The WorkMail organization to which you want to apply the override.
    /// This member is required.
    public var organizationId: Swift.String?
    /// Identifies the WorkMail user for the override. Accepts the following types of user identities:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct GetMobileDeviceAccessOverrideInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
    let deviceId: Swift.String?
}

extension GetMobileDeviceAccessOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension GetMobileDeviceAccessOverrideOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMobileDeviceAccessOverrideOutputBody = try responseDecoder.decode(responseBody: data)
            self.dateCreated = output.dateCreated
            self.dateModified = output.dateModified
            self.description = output.description
            self.deviceId = output.deviceId
            self.effect = output.effect
            self.userId = output.userId
        } else {
            self.dateCreated = nil
            self.dateModified = nil
            self.description = nil
            self.deviceId = nil
            self.effect = nil
            self.userId = nil
        }
    }
}

public struct GetMobileDeviceAccessOverrideOutput: Swift.Equatable {
    /// The date the override was first created.
    public var dateCreated: ClientRuntime.Date?
    /// The date the description was last modified.
    public var dateModified: ClientRuntime.Date?
    /// A description of the override.
    public var description: Swift.String?
    /// The device to which the access override applies.
    public var deviceId: Swift.String?
    /// The effect of the override, ALLOW or DENY.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// The WorkMail user to which the access override applies.
    public var userId: Swift.String?

    public init(
        dateCreated: ClientRuntime.Date? = nil,
        dateModified: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        userId: Swift.String? = nil
    )
    {
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.description = description
        self.deviceId = deviceId
        self.effect = effect
        self.userId = userId
    }
}

struct GetMobileDeviceAccessOverrideOutputBody: Swift.Equatable {
    let userId: Swift.String?
    let deviceId: Swift.String?
    let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    let description: Swift.String?
    let dateCreated: ClientRuntime.Date?
    let dateModified: ClientRuntime.Date?
}

extension GetMobileDeviceAccessOverrideOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case deviceId = "DeviceId"
        case effect = "Effect"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

enum GetMobileDeviceAccessOverrideOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkMailClientTypes.Group: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = self.disabledDate {
            try encodeContainer.encodeTimestamp(disabledDate, format: .epochSeconds, forKey: .disabledDate)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enabledDate = self.enabledDate {
            try encodeContainer.encodeTimestamp(enabledDate, format: .epochSeconds, forKey: .enabledDate)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension WorkMailClientTypes {
    /// The representation of an WorkMail group.
    public struct Group: Swift.Equatable {
        /// The date indicating when the group was disabled from WorkMail use.
        public var disabledDate: ClientRuntime.Date?
        /// The email of the group.
        public var email: Swift.String?
        /// The date indicating when the group was enabled for WorkMail use.
        public var enabledDate: ClientRuntime.Date?
        /// The identifier of the group.
        public var id: Swift.String?
        /// The name of the group.
        public var name: Swift.String?
        /// The state of the group, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?

        public init(
            disabledDate: ClientRuntime.Date? = nil,
            email: Swift.String? = nil,
            enabledDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil
        )
        {
            self.disabledDate = disabledDate
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
        }
    }

}

extension WorkMailClientTypes.GroupIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension WorkMailClientTypes {
    /// The identifier that contains the Group ID and name of a group.
    public struct GroupIdentifier: Swift.Equatable {
        /// Group ID that matched the group.
        public var groupId: Swift.String?
        /// Group name that matched the group.
        public var groupName: Swift.String?

        public init(
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }

}

extension WorkMailClientTypes.ImpersonationMatchedRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impersonationRuleId = "ImpersonationRuleId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let impersonationRuleId = self.impersonationRuleId {
            try encodeContainer.encode(impersonationRuleId, forKey: .impersonationRuleId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let impersonationRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRuleId)
        impersonationRuleId = impersonationRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension WorkMailClientTypes {
    /// The impersonation rule that matched the input.
    public struct ImpersonationMatchedRule: Swift.Equatable {
        /// The ID of the rule that matched the input
        public var impersonationRuleId: Swift.String?
        /// The name of the rule that matched the input.
        public var name: Swift.String?

        public init(
            impersonationRuleId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.impersonationRuleId = impersonationRuleId
            self.name = name
        }
    }

}

extension WorkMailClientTypes.ImpersonationRole: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case impersonationRoleId = "ImpersonationRoleId"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateCreated = self.dateCreated {
            try encodeContainer.encodeTimestamp(dateCreated, format: .epochSeconds, forKey: .dateCreated)
        }
        if let dateModified = self.dateModified {
            try encodeContainer.encodeTimestamp(dateModified, format: .epochSeconds, forKey: .dateModified)
        }
        if let impersonationRoleId = self.impersonationRoleId {
            try encodeContainer.encode(impersonationRoleId, forKey: .impersonationRoleId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ImpersonationRoleType.self, forKey: .type)
        type = typeDecoded
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension WorkMailClientTypes {
    /// An impersonation role for the given WorkMail organization.
    public struct ImpersonationRole: Swift.Equatable {
        /// The date when the impersonation role was created.
        public var dateCreated: ClientRuntime.Date?
        /// The date when the impersonation role was last modified.
        public var dateModified: ClientRuntime.Date?
        /// The identifier of the impersonation role.
        public var impersonationRoleId: Swift.String?
        /// The impersonation role name.
        public var name: Swift.String?
        /// The impersonation role type.
        public var type: WorkMailClientTypes.ImpersonationRoleType?

        public init(
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            impersonationRoleId: Swift.String? = nil,
            name: Swift.String? = nil,
            type: WorkMailClientTypes.ImpersonationRoleType? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.impersonationRoleId = impersonationRoleId
            self.name = name
            self.type = type
        }
    }

}

extension WorkMailClientTypes {
    public enum ImpersonationRoleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullAccess
        case readOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ImpersonationRoleType] {
            return [
                .fullAccess,
                .readOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullAccess: return "FULL_ACCESS"
            case .readOnly: return "READ_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImpersonationRoleType(rawValue: rawValue) ?? ImpersonationRoleType.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes.ImpersonationRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case effect = "Effect"
        case impersonationRuleId = "ImpersonationRuleId"
        case name = "Name"
        case notTargetUsers = "NotTargetUsers"
        case targetUsers = "TargetUsers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let impersonationRuleId = self.impersonationRuleId {
            try encodeContainer.encode(impersonationRuleId, forKey: .impersonationRuleId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notTargetUsers = notTargetUsers {
            var notTargetUsersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notTargetUsers)
            for entityidentifier0 in notTargetUsers {
                try notTargetUsersContainer.encode(entityidentifier0)
            }
        }
        if let targetUsers = targetUsers {
            var targetUsersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetUsers)
            for entityidentifier0 in targetUsers {
                try targetUsersContainer.encode(entityidentifier0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let impersonationRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRuleId)
        impersonationRuleId = impersonationRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AccessEffect.self, forKey: .effect)
        effect = effectDecoded
        let targetUsersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetUsers)
        var targetUsersDecoded0:[Swift.String]? = nil
        if let targetUsersContainer = targetUsersContainer {
            targetUsersDecoded0 = [Swift.String]()
            for string0 in targetUsersContainer {
                if let string0 = string0 {
                    targetUsersDecoded0?.append(string0)
                }
            }
        }
        targetUsers = targetUsersDecoded0
        let notTargetUsersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notTargetUsers)
        var notTargetUsersDecoded0:[Swift.String]? = nil
        if let notTargetUsersContainer = notTargetUsersContainer {
            notTargetUsersDecoded0 = [Swift.String]()
            for string0 in notTargetUsersContainer {
                if let string0 = string0 {
                    notTargetUsersDecoded0?.append(string0)
                }
            }
        }
        notTargetUsers = notTargetUsersDecoded0
    }
}

extension WorkMailClientTypes {
    /// The rules for the given impersonation role.
    public struct ImpersonationRule: Swift.Equatable {
        /// The rule description.
        public var description: Swift.String?
        /// The effect of the rule when it matches the input. Allowed effect values are ALLOW or DENY.
        /// This member is required.
        public var effect: WorkMailClientTypes.AccessEffect?
        /// The identifier of the rule.
        /// This member is required.
        public var impersonationRuleId: Swift.String?
        /// The rule name.
        public var name: Swift.String?
        /// A list of user IDs that don't match the rule.
        public var notTargetUsers: [Swift.String]?
        /// A list of user IDs that match the rule.
        public var targetUsers: [Swift.String]?

        public init(
            description: Swift.String? = nil,
            effect: WorkMailClientTypes.AccessEffect? = nil,
            impersonationRuleId: Swift.String? = nil,
            name: Swift.String? = nil,
            notTargetUsers: [Swift.String]? = nil,
            targetUsers: [Swift.String]? = nil
        )
        {
            self.description = description
            self.effect = effect
            self.impersonationRuleId = impersonationRuleId
            self.name = name
            self.notTargetUsers = notTargetUsers
            self.targetUsers = targetUsers
        }
    }

}

extension InvalidConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The configuration for a resource isn't valid. A resource must either be able to auto-respond to requests or have at least one delegate associated that can do so on its behalf.
public struct InvalidConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidConfigurationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCustomSesConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCustomSesConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You SES configuration has customizations that WorkMail cannot save. The error message lists the invalid setting. For examples of invalid settings, refer to [CreateReceiptRule](https://docs.aws.amazon.com/ses/latest/APIReference/API_CreateReceiptRule.html).
public struct InvalidCustomSesConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCustomSesConfigurationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidCustomSesConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCustomSesConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more of the input parameters don't match the service's restrictions.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPasswordException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPasswordExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The supplied password doesn't match the minimum security constraints, such as length or use of special characters.
public struct InvalidPasswordException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPasswordException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPasswordExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPasswordExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes.LambdaAvailabilityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaArn = "LambdaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaArn = self.lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
    }
}

extension WorkMailClientTypes {
    /// Describes a Lambda based availability provider.
    public struct LambdaAvailabilityProvider: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Lambda that acts as the availability provider.
        /// This member is required.
        public var lambdaArn: Swift.String?

        public init(
            lambdaArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeds the limit of the resource.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccessControlRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListAccessControlRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccessControlRulesInput: Swift.Equatable {
    /// The identifier for the organization.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct ListAccessControlRulesInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension ListAccessControlRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension ListAccessControlRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccessControlRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct ListAccessControlRulesOutput: Swift.Equatable {
    /// The access control rules.
    public var rules: [WorkMailClientTypes.AccessControlRule]?

    public init(
        rules: [WorkMailClientTypes.AccessControlRule]? = nil
    )
    {
        self.rules = rules
    }
}

struct ListAccessControlRulesOutputBody: Swift.Equatable {
    let rules: [WorkMailClientTypes.AccessControlRule]?
}

extension ListAccessControlRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.AccessControlRule?].self, forKey: .rules)
        var rulesDecoded0:[WorkMailClientTypes.AccessControlRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [WorkMailClientTypes.AccessControlRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

enum ListAccessControlRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAliasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAliasesInput: Swift.Equatable {
    /// The identifier for the entity for which to list the aliases.
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the entity exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListAliasesInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAliasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAliasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAliasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.aliases = output.aliases
            self.nextToken = output.nextToken
        } else {
            self.aliases = nil
            self.nextToken = nil
        }
    }
}

public struct ListAliasesOutput: Swift.Equatable {
    /// The entity's paginated aliases.
    public var aliases: [Swift.String]?
    /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        aliases: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aliases = aliases
        self.nextToken = nextToken
    }
}

struct ListAliasesOutputBody: Swift.Equatable {
    let aliases: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAliasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .aliases)
        var aliasesDecoded0:[Swift.String]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [Swift.String]()
            for string0 in aliasesContainer {
                if let string0 = string0 {
                    aliasesDecoded0?.append(string0)
                }
            }
        }
        aliases = aliasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAliasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAvailabilityConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListAvailabilityConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAvailabilityConfigurationsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not require a token.
    public var nextToken: Swift.String?
    /// The WorkMail organization for which the AvailabilityConfiguration's will be listed.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListAvailabilityConfigurationsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAvailabilityConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAvailabilityConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAvailabilityConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.availabilityConfigurations = output.availabilityConfigurations
            self.nextToken = output.nextToken
        } else {
            self.availabilityConfigurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListAvailabilityConfigurationsOutput: Swift.Equatable {
    /// The list of AvailabilityConfiguration's that exist for the specified WorkMail organization.
    public var availabilityConfigurations: [WorkMailClientTypes.AvailabilityConfiguration]?
    /// The token to use to retrieve the next page of results. The value is null when there are no further results to return.
    public var nextToken: Swift.String?

    public init(
        availabilityConfigurations: [WorkMailClientTypes.AvailabilityConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.availabilityConfigurations = availabilityConfigurations
        self.nextToken = nextToken
    }
}

struct ListAvailabilityConfigurationsOutputBody: Swift.Equatable {
    let availabilityConfigurations: [WorkMailClientTypes.AvailabilityConfiguration]?
    let nextToken: Swift.String?
}

extension ListAvailabilityConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityConfigurations = "AvailabilityConfigurations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityConfigurationsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.AvailabilityConfiguration?].self, forKey: .availabilityConfigurations)
        var availabilityConfigurationsDecoded0:[WorkMailClientTypes.AvailabilityConfiguration]? = nil
        if let availabilityConfigurationsContainer = availabilityConfigurationsContainer {
            availabilityConfigurationsDecoded0 = [WorkMailClientTypes.AvailabilityConfiguration]()
            for structure0 in availabilityConfigurationsContainer {
                if let structure0 = structure0 {
                    availabilityConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        availabilityConfigurations = availabilityConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAvailabilityConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGroupMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListGroupMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupMembersInput: Swift.Equatable {
    /// The identifier for the group to which the members (users or groups) are associated. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:
    ///
    /// * Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: group@domain.tld
    ///
    /// * Group name: group
    /// This member is required.
    public var groupId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListGroupMembersInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let groupId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListGroupMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGroupMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGroupMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupMembersOutput: Swift.Equatable {
    /// The members associated to the group.
    public var members: [WorkMailClientTypes.Member]?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?

    public init(
        members: [WorkMailClientTypes.Member]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListGroupMembersOutputBody: Swift.Equatable {
    let members: [WorkMailClientTypes.Member]?
    let nextToken: Swift.String?
}

extension ListGroupMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "Members"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Member?].self, forKey: .members)
        var membersDecoded0:[WorkMailClientTypes.Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [WorkMailClientTypes.Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGroupMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkMailClientTypes.ListGroupsFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namePrefix = "NamePrefix"
        case primaryEmailPrefix = "PrimaryEmailPrefix"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let primaryEmailPrefix = self.primaryEmailPrefix {
            try encodeContainer.encode(primaryEmailPrefix, forKey: .primaryEmailPrefix)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let primaryEmailPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryEmailPrefix)
        primaryEmailPrefix = primaryEmailPrefixDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
    }
}

extension WorkMailClientTypes {
    /// Filtering options for ListGroups operation. This is only used as input to Operation.
    public struct ListGroupsFilters: Swift.Equatable {
        /// Filters only groups with the provided name prefix.
        public var namePrefix: Swift.String?
        /// Filters only groups with the provided primary email prefix.
        public var primaryEmailPrefix: Swift.String?
        /// Filters only groups with the provided state.
        public var state: WorkMailClientTypes.EntityState?

        public init(
            namePrefix: Swift.String? = nil,
            primaryEmailPrefix: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil
        )
        {
            self.namePrefix = namePrefix
            self.primaryEmailPrefix = primaryEmailPrefix
            self.state = state
        }
    }

}

extension WorkMailClientTypes.ListGroupsForEntityFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupNamePrefix = "GroupNamePrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupNamePrefix = self.groupNamePrefix {
            try encodeContainer.encode(groupNamePrefix, forKey: .groupNamePrefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNamePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupNamePrefix)
        groupNamePrefix = groupNamePrefixDecoded
    }
}

extension WorkMailClientTypes {
    /// Filtering options for ListGroupsForEntity operation. This is only used as input to Operation.
    public struct ListGroupsForEntityFilters: Swift.Equatable {
        /// Filters only group names that start with the provided name prefix.
        public var groupNamePrefix: Swift.String?

        public init(
            groupNamePrefix: Swift.String? = nil
        )
        {
            self.groupNamePrefix = groupNamePrefix
        }
    }

}

extension ListGroupsForEntityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListGroupsForEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupsForEntityInput: Swift.Equatable {
    /// The identifier for the entity. The entity ID can accept UserId or GroupID, Username or Groupname, or email.
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// Limit the search results based on the filter criteria.
    public var filters: WorkMailClientTypes.ListGroupsForEntityFilters?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the entity exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        filters: WorkMailClientTypes.ListGroupsForEntityFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListGroupsForEntityInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let filters: WorkMailClientTypes.ListGroupsForEntityFilters?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListGroupsForEntityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ListGroupsForEntityFilters.self, forKey: .filters)
        filters = filtersDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGroupsForEntityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGroupsForEntityOutputBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupsForEntityOutput: Swift.Equatable {
    /// The overview of groups in an organization.
    public var groups: [WorkMailClientTypes.GroupIdentifier]?
    /// The token to use to retrieve the next page of results. This value is `null` when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        groups: [WorkMailClientTypes.GroupIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct ListGroupsForEntityOutputBody: Swift.Equatable {
    let groups: [WorkMailClientTypes.GroupIdentifier]?
    let nextToken: Swift.String?
}

extension ListGroupsForEntityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.GroupIdentifier?].self, forKey: .groups)
        var groupsDecoded0:[WorkMailClientTypes.GroupIdentifier]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [WorkMailClientTypes.GroupIdentifier]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGroupsForEntityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupsInput: Swift.Equatable {
    /// Limit the search results based on the filter criteria. Only one filter per request is supported.
    public var filters: WorkMailClientTypes.ListGroupsFilters?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the groups exist.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        filters: WorkMailClientTypes.ListGroupsFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListGroupsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: WorkMailClientTypes.ListGroupsFilters?
}

extension ListGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ListGroupsFilters.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupsOutput: Swift.Equatable {
    /// The overview of groups for an organization.
    public var groups: [WorkMailClientTypes.Group]?
    /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        groups: [WorkMailClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct ListGroupsOutputBody: Swift.Equatable {
    let groups: [WorkMailClientTypes.Group]?
    let nextToken: Swift.String?
}

extension ListGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Group?].self, forKey: .groups)
        var groupsDecoded0:[WorkMailClientTypes.Group]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [WorkMailClientTypes.Group]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImpersonationRolesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListImpersonationRolesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListImpersonationRolesInput: Swift.Equatable {
    /// The maximum number of results returned in a single call.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results. The first call doesn't require a token.
    public var nextToken: Swift.String?
    /// The WorkMail organization to which the listed impersonation roles belong.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListImpersonationRolesInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListImpersonationRolesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListImpersonationRolesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImpersonationRolesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.roles = output.roles
        } else {
            self.nextToken = nil
            self.roles = nil
        }
    }
}

public struct ListImpersonationRolesOutput: Swift.Equatable {
    /// The token to retrieve the next page of results. The value is null when there are no results to return.
    public var nextToken: Swift.String?
    /// The list of impersonation roles under the given WorkMail organization.
    public var roles: [WorkMailClientTypes.ImpersonationRole]?

    public init(
        nextToken: Swift.String? = nil,
        roles: [WorkMailClientTypes.ImpersonationRole]? = nil
    )
    {
        self.nextToken = nextToken
        self.roles = roles
    }
}

struct ListImpersonationRolesOutputBody: Swift.Equatable {
    let roles: [WorkMailClientTypes.ImpersonationRole]?
    let nextToken: Swift.String?
}

extension ListImpersonationRolesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case roles = "Roles"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rolesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.ImpersonationRole?].self, forKey: .roles)
        var rolesDecoded0:[WorkMailClientTypes.ImpersonationRole]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [WorkMailClientTypes.ImpersonationRole]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImpersonationRolesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMailDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListMailDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMailDomainsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not require a token.
    public var nextToken: Swift.String?
    /// The WorkMail organization for which to list domains.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListMailDomainsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListMailDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMailDomainsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMailDomainsOutputBody = try responseDecoder.decode(responseBody: data)
            self.mailDomains = output.mailDomains
            self.nextToken = output.nextToken
        } else {
            self.mailDomains = nil
            self.nextToken = nil
        }
    }
}

public struct ListMailDomainsOutput: Swift.Equatable {
    /// The list of mail domain summaries, specifying domains that exist in the specified WorkMail organization, along with the information about whether the domain is or isn't the default.
    public var mailDomains: [WorkMailClientTypes.MailDomainSummary]?
    /// The token to use to retrieve the next page of results. The value becomes null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        mailDomains: [WorkMailClientTypes.MailDomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mailDomains = mailDomains
        self.nextToken = nextToken
    }
}

struct ListMailDomainsOutputBody: Swift.Equatable {
    let mailDomains: [WorkMailClientTypes.MailDomainSummary]?
    let nextToken: Swift.String?
}

extension ListMailDomainsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mailDomains = "MailDomains"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailDomainsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.MailDomainSummary?].self, forKey: .mailDomains)
        var mailDomainsDecoded0:[WorkMailClientTypes.MailDomainSummary]? = nil
        if let mailDomainsContainer = mailDomainsContainer {
            mailDomainsDecoded0 = [WorkMailClientTypes.MailDomainSummary]()
            for structure0 in mailDomainsContainer {
                if let structure0 = structure0 {
                    mailDomainsDecoded0?.append(structure0)
                }
            }
        }
        mailDomains = mailDomainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMailDomainsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMailboxExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListMailboxExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMailboxExportJobsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListMailboxExportJobsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMailboxExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMailboxExportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMailboxExportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListMailboxExportJobsOutput: Swift.Equatable {
    /// The mailbox export job details.
    public var jobs: [WorkMailClientTypes.MailboxExportJob]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        jobs: [WorkMailClientTypes.MailboxExportJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListMailboxExportJobsOutputBody: Swift.Equatable {
    let jobs: [WorkMailClientTypes.MailboxExportJob]?
    let nextToken: Swift.String?
}

extension ListMailboxExportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "Jobs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.MailboxExportJob?].self, forKey: .jobs)
        var jobsDecoded0:[WorkMailClientTypes.MailboxExportJob]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [WorkMailClientTypes.MailboxExportJob]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMailboxExportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMailboxPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListMailboxPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMailboxPermissionsInput: Swift.Equatable {
    /// The identifier of the user, or resource for which to list mailbox permissions. The entity ID can accept UserId or ResourceId, Username or Resourcename, or email.
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012, or r-0123456789a0123456789b0123456789
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier of the organization under which the user, group, or resource exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListMailboxPermissionsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMailboxPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMailboxPermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMailboxPermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListMailboxPermissionsOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
    public var nextToken: Swift.String?
    /// One page of the user, group, or resource mailbox permissions.
    public var permissions: [WorkMailClientTypes.Permission]?

    public init(
        nextToken: Swift.String? = nil,
        permissions: [WorkMailClientTypes.Permission]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListMailboxPermissionsOutputBody: Swift.Equatable {
    let permissions: [WorkMailClientTypes.Permission]?
    let nextToken: Swift.String?
}

extension ListMailboxPermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissions = "Permissions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[WorkMailClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [WorkMailClientTypes.Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMailboxPermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMobileDeviceAccessOverridesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension ListMobileDeviceAccessOverridesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMobileDeviceAccessOverridesInput: Swift.Equatable {
    /// The mobile device to which the access override applies.
    public var deviceId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not require a token.
    public var nextToken: Swift.String?
    /// The WorkMail organization under which to list mobile device access overrides.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail user under which you list the mobile device access overrides. Accepts the following types of user identities:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    public var userId: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct ListMobileDeviceAccessOverridesInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
    let deviceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMobileDeviceAccessOverridesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMobileDeviceAccessOverridesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMobileDeviceAccessOverridesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.overrides = output.overrides
        } else {
            self.nextToken = nil
            self.overrides = nil
        }
    }
}

public struct ListMobileDeviceAccessOverridesOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results. The value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of mobile device access overrides that exist for the specified WorkMail organization and user.
    public var overrides: [WorkMailClientTypes.MobileDeviceAccessOverride]?

    public init(
        nextToken: Swift.String? = nil,
        overrides: [WorkMailClientTypes.MobileDeviceAccessOverride]? = nil
    )
    {
        self.nextToken = nextToken
        self.overrides = overrides
    }
}

struct ListMobileDeviceAccessOverridesOutputBody: Swift.Equatable {
    let overrides: [WorkMailClientTypes.MobileDeviceAccessOverride]?
    let nextToken: Swift.String?
}

extension ListMobileDeviceAccessOverridesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case overrides = "Overrides"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overridesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.MobileDeviceAccessOverride?].self, forKey: .overrides)
        var overridesDecoded0:[WorkMailClientTypes.MobileDeviceAccessOverride]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [WorkMailClientTypes.MobileDeviceAccessOverride]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMobileDeviceAccessOverridesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMobileDeviceAccessRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListMobileDeviceAccessRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMobileDeviceAccessRulesInput: Swift.Equatable {
    /// The WorkMail organization for which to list the rules.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct ListMobileDeviceAccessRulesInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension ListMobileDeviceAccessRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension ListMobileDeviceAccessRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMobileDeviceAccessRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct ListMobileDeviceAccessRulesOutput: Swift.Equatable {
    /// The list of mobile device access rules that exist under the specified WorkMail organization.
    public var rules: [WorkMailClientTypes.MobileDeviceAccessRule]?

    public init(
        rules: [WorkMailClientTypes.MobileDeviceAccessRule]? = nil
    )
    {
        self.rules = rules
    }
}

struct ListMobileDeviceAccessRulesOutputBody: Swift.Equatable {
    let rules: [WorkMailClientTypes.MobileDeviceAccessRule]?
}

extension ListMobileDeviceAccessRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.MobileDeviceAccessRule?].self, forKey: .rules)
        var rulesDecoded0:[WorkMailClientTypes.MobileDeviceAccessRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [WorkMailClientTypes.MobileDeviceAccessRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

enum ListMobileDeviceAccessRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOrganizationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListOrganizationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOrganizationsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOrganizationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListOrganizationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListOrganizationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOrganizationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.organizationSummaries = output.organizationSummaries
        } else {
            self.nextToken = nil
            self.organizationSummaries = nil
        }
    }
}

public struct ListOrganizationsOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
    public var nextToken: Swift.String?
    /// The overview of owned organizations presented as a list of organization summaries.
    public var organizationSummaries: [WorkMailClientTypes.OrganizationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        organizationSummaries: [WorkMailClientTypes.OrganizationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationSummaries = organizationSummaries
    }
}

struct ListOrganizationsOutputBody: Swift.Equatable {
    let organizationSummaries: [WorkMailClientTypes.OrganizationSummary]?
    let nextToken: Swift.String?
}

extension ListOrganizationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case organizationSummaries = "OrganizationSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationSummariesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.OrganizationSummary?].self, forKey: .organizationSummaries)
        var organizationSummariesDecoded0:[WorkMailClientTypes.OrganizationSummary]? = nil
        if let organizationSummariesContainer = organizationSummariesContainer {
            organizationSummariesDecoded0 = [WorkMailClientTypes.OrganizationSummary]()
            for structure0 in organizationSummariesContainer {
                if let structure0 = structure0 {
                    organizationSummariesDecoded0?.append(structure0)
                }
            }
        }
        organizationSummaries = organizationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListOrganizationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResourceDelegatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension ListResourceDelegatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourceDelegatesInput: Swift.Equatable {
    /// The number of maximum results in a page.
    public var maxResults: Swift.Int?
    /// The token used to paginate through the delegates associated with a resource.
    public var nextToken: Swift.String?
    /// The identifier for the organization that contains the resource for which delegates are listed.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier for the resource whose delegates are listed. The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:
    ///
    /// * Resource ID: r-0123456789a0123456789b0123456789
    ///
    /// * Email address: resource@domain.tld
    ///
    /// * Resource name: resource
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct ListResourceDelegatesInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let resourceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListResourceDelegatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceDelegatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourceDelegatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.delegates = output.delegates
            self.nextToken = output.nextToken
        } else {
            self.delegates = nil
            self.nextToken = nil
        }
    }
}

public struct ListResourceDelegatesOutput: Swift.Equatable {
    /// One page of the resource's delegates.
    public var delegates: [WorkMailClientTypes.Delegate]?
    /// The token used to paginate through the delegates associated with a resource. While results are still available, it has an associated value. When the last page is reached, the token is empty.
    public var nextToken: Swift.String?

    public init(
        delegates: [WorkMailClientTypes.Delegate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.delegates = delegates
        self.nextToken = nextToken
    }
}

struct ListResourceDelegatesOutputBody: Swift.Equatable {
    let delegates: [WorkMailClientTypes.Delegate]?
    let nextToken: Swift.String?
}

extension ListResourceDelegatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegates = "Delegates"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Delegate?].self, forKey: .delegates)
        var delegatesDecoded0:[WorkMailClientTypes.Delegate]? = nil
        if let delegatesContainer = delegatesContainer {
            delegatesDecoded0 = [WorkMailClientTypes.Delegate]()
            for structure0 in delegatesContainer {
                if let structure0 = structure0 {
                    delegatesDecoded0?.append(structure0)
                }
            }
        }
        delegates = delegatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListResourceDelegatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkMailClientTypes.ListResourcesFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namePrefix = "NamePrefix"
        case primaryEmailPrefix = "PrimaryEmailPrefix"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let primaryEmailPrefix = self.primaryEmailPrefix {
            try encodeContainer.encode(primaryEmailPrefix, forKey: .primaryEmailPrefix)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let primaryEmailPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryEmailPrefix)
        primaryEmailPrefix = primaryEmailPrefixDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
    }
}

extension WorkMailClientTypes {
    /// Filtering options for ListResources operation. This is only used as input to Operation.
    public struct ListResourcesFilters: Swift.Equatable {
        /// Filters only resource that start with the entered name prefix .
        public var namePrefix: Swift.String?
        /// Filters only resource with the provided primary email prefix.
        public var primaryEmailPrefix: Swift.String?
        /// Filters only resource with the provided state.
        public var state: WorkMailClientTypes.EntityState?

        public init(
            namePrefix: Swift.String? = nil,
            primaryEmailPrefix: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil
        )
        {
            self.namePrefix = namePrefix
            self.primaryEmailPrefix = primaryEmailPrefix
            self.state = state
        }
    }

}

extension ListResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourcesInput: Swift.Equatable {
    /// Limit the resource search results based on the filter criteria. You can only use one filter per request.
    public var filters: WorkMailClientTypes.ListResourcesFilters?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the resources exist.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        filters: WorkMailClientTypes.ListResourcesFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListResourcesInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: WorkMailClientTypes.ListResourcesFilters?
}

extension ListResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ListResourcesFilters.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListResourcesOutput: Swift.Equatable {
    /// The token used to paginate through all the organization's resources. While results are still available, it has an associated value. When the last page is reached, the token is empty.
    public var nextToken: Swift.String?
    /// One page of the organization's resource representation.
    public var resources: [WorkMailClientTypes.Resource]?

    public init(
        nextToken: Swift.String? = nil,
        resources: [WorkMailClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListResourcesOutputBody: Swift.Equatable {
    let resources: [WorkMailClientTypes.Resource]?
    let nextToken: Swift.String?
}

extension ListResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resources = "Resources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[WorkMailClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [WorkMailClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tag key-value pairs.
    public var tags: [WorkMailClientTypes.Tag]?

    public init(
        tags: [WorkMailClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [WorkMailClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkMailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkMailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkMailClientTypes.ListUsersFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayNamePrefix = "DisplayNamePrefix"
        case primaryEmailPrefix = "PrimaryEmailPrefix"
        case state = "State"
        case usernamePrefix = "UsernamePrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayNamePrefix = self.displayNamePrefix {
            try encodeContainer.encode(displayNamePrefix, forKey: .displayNamePrefix)
        }
        if let primaryEmailPrefix = self.primaryEmailPrefix {
            try encodeContainer.encode(primaryEmailPrefix, forKey: .primaryEmailPrefix)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let usernamePrefix = self.usernamePrefix {
            try encodeContainer.encode(usernamePrefix, forKey: .usernamePrefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernamePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usernamePrefix)
        usernamePrefix = usernamePrefixDecoded
        let displayNamePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayNamePrefix)
        displayNamePrefix = displayNamePrefixDecoded
        let primaryEmailPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryEmailPrefix)
        primaryEmailPrefix = primaryEmailPrefixDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
    }
}

extension WorkMailClientTypes.ListUsersFilters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersFilters(primaryEmailPrefix: \(Swift.String(describing: primaryEmailPrefix)), state: \(Swift.String(describing: state)), usernamePrefix: \(Swift.String(describing: usernamePrefix)), displayNamePrefix: \"CONTENT_REDACTED\")"}
}

extension WorkMailClientTypes {
    /// Filtering options for ListUsers operation. This is only used as input to Operation.
    public struct ListUsersFilters: Swift.Equatable {
        /// Filters only users with the provided display name prefix.
        public var displayNamePrefix: Swift.String?
        /// Filters only users with the provided email prefix.
        public var primaryEmailPrefix: Swift.String?
        /// Filters only users with the provided state.
        public var state: WorkMailClientTypes.EntityState?
        /// Filters only users with the provided username prefix.
        public var usernamePrefix: Swift.String?

        public init(
            displayNamePrefix: Swift.String? = nil,
            primaryEmailPrefix: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil,
            usernamePrefix: Swift.String? = nil
        )
        {
            self.displayNamePrefix = displayNamePrefix
            self.primaryEmailPrefix = primaryEmailPrefix
            self.state = state
            self.usernamePrefix = usernamePrefix
        }
    }

}

extension ListUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// Limit the user search results based on the filter criteria. You can only use one filter per request.
    public var filters: WorkMailClientTypes.ListUsersFilters?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the users exist.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        filters: WorkMailClientTypes.ListUsersFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListUsersInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: WorkMailClientTypes.ListUsersFilters?
}

extension ListUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ListUsersFilters.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is `null` when there are no more results to return.
    public var nextToken: Swift.String?
    /// The overview of users for an organization.
    public var users: [WorkMailClientTypes.User]?

    public init(
        nextToken: Swift.String? = nil,
        users: [WorkMailClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputBody: Swift.Equatable {
    let users: [WorkMailClientTypes.User]?
    let nextToken: Swift.String?
}

extension ListUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[WorkMailClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [WorkMailClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MailDomainInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MailDomainInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The domain you're trying to change is in use by another user or organization in your account. See the error message for details.
public struct MailDomainInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MailDomainInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MailDomainInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MailDomainInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MailDomainNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MailDomainNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The domain specified is not found in your organization.
public struct MailDomainNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MailDomainNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MailDomainNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MailDomainNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MailDomainStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MailDomainStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// After a domain has been added to the organization, it must be verified. The domain is not yet verified.
public struct MailDomainStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MailDomainStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MailDomainStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MailDomainStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes.MailDomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultDomain = "DefaultDomain"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultDomain != false {
            try encodeContainer.encode(defaultDomain, forKey: .defaultDomain)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let defaultDomainDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultDomain) ?? false
        defaultDomain = defaultDomainDecoded
    }
}

extension WorkMailClientTypes {
    /// The data for a given domain.
    public struct MailDomainSummary: Swift.Equatable {
        /// Whether the domain is default or not.
        public var defaultDomain: Swift.Bool
        /// The domain name.
        public var domainName: Swift.String?

        public init(
            defaultDomain: Swift.Bool = false,
            domainName: Swift.String? = nil
        )
        {
            self.defaultDomain = defaultDomain
            self.domainName = domainName
        }
    }

}

extension WorkMailClientTypes.MailboxExportJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case endTime = "EndTime"
        case entityId = "EntityId"
        case estimatedProgress = "EstimatedProgress"
        case jobId = "JobId"
        case s3BucketName = "S3BucketName"
        case s3Path = "S3Path"
        case startTime = "StartTime"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if estimatedProgress != 0 {
            try encodeContainer.encode(estimatedProgress, forKey: .estimatedProgress)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3Path = self.s3Path {
            try encodeContainer.encode(s3Path, forKey: .s3Path)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let estimatedProgressDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedProgress) ?? 0
        estimatedProgress = estimatedProgressDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MailboxExportJobState.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension WorkMailClientTypes {
    /// The details of a mailbox export job, including the user or resource ID associated with the mailbox and the S3 bucket that the mailbox contents are exported to.
    public struct MailboxExportJob: Swift.Equatable {
        /// The mailbox export job description.
        public var description: Swift.String?
        /// The mailbox export job end timestamp.
        public var endTime: ClientRuntime.Date?
        /// The identifier of the user or resource associated with the mailbox.
        public var entityId: Swift.String?
        /// The estimated progress of the mailbox export job, in percentage points.
        public var estimatedProgress: Swift.Int
        /// The identifier of the mailbox export job.
        public var jobId: Swift.String?
        /// The name of the S3 bucket.
        public var s3BucketName: Swift.String?
        /// The path to the S3 bucket and file that the mailbox export job exports to.
        public var s3Path: Swift.String?
        /// The mailbox export job start timestamp.
        public var startTime: ClientRuntime.Date?
        /// The state of the mailbox export job.
        public var state: WorkMailClientTypes.MailboxExportJobState?

        public init(
            description: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            entityId: Swift.String? = nil,
            estimatedProgress: Swift.Int = 0,
            jobId: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3Path: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: WorkMailClientTypes.MailboxExportJobState? = nil
        )
        {
            self.description = description
            self.endTime = endTime
            self.entityId = entityId
            self.estimatedProgress = estimatedProgress
            self.jobId = jobId
            self.s3BucketName = s3BucketName
            self.s3Path = s3Path
            self.startTime = startTime
            self.state = state
        }
    }

}

extension WorkMailClientTypes {
    public enum MailboxExportJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [MailboxExportJobState] {
            return [
                .cancelled,
                .completed,
                .failed,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MailboxExportJobState(rawValue: rawValue) ?? MailboxExportJobState.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes.Member: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = self.disabledDate {
            try encodeContainer.encodeTimestamp(disabledDate, format: .epochSeconds, forKey: .disabledDate)
        }
        if let enabledDate = self.enabledDate {
            try encodeContainer.encodeTimestamp(enabledDate, format: .epochSeconds, forKey: .enabledDate)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MemberType.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension WorkMailClientTypes {
    /// The representation of a user or group.
    public struct Member: Swift.Equatable {
        /// The date indicating when the member was disabled from WorkMail use.
        public var disabledDate: ClientRuntime.Date?
        /// The date indicating when the member was enabled for WorkMail use.
        public var enabledDate: ClientRuntime.Date?
        /// The identifier of the member.
        public var id: Swift.String?
        /// The name of the member.
        public var name: Swift.String?
        /// The state of the member, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?
        /// A member can be a user or group.
        public var type: WorkMailClientTypes.MemberType?

        public init(
            disabledDate: ClientRuntime.Date? = nil,
            enabledDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil,
            type: WorkMailClientTypes.MemberType? = nil
        )
        {
            self.disabledDate = disabledDate
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.type = type
        }
    }

}

extension WorkMailClientTypes {
    public enum MemberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberType] {
            return [
                .group,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberType(rawValue: rawValue) ?? MemberType.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes.MobileDeviceAccessMatchedRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mobileDeviceAccessRuleId = self.mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension WorkMailClientTypes {
    /// The rule that a simulated user matches.
    public struct MobileDeviceAccessMatchedRule: Swift.Equatable {
        /// Identifier of the rule that a simulated user matches.
        public var mobileDeviceAccessRuleId: Swift.String?
        /// Name of a rule that a simulated user matches.
        public var name: Swift.String?

        public init(
            mobileDeviceAccessRuleId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
            self.name = name
        }
    }

}

extension WorkMailClientTypes.MobileDeviceAccessOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case deviceId = "DeviceId"
        case effect = "Effect"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateCreated = self.dateCreated {
            try encodeContainer.encodeTimestamp(dateCreated, format: .epochSeconds, forKey: .dateCreated)
        }
        if let dateModified = self.dateModified {
            try encodeContainer.encodeTimestamp(dateModified, format: .epochSeconds, forKey: .dateModified)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension WorkMailClientTypes {
    /// The override object.
    public struct MobileDeviceAccessOverride: Swift.Equatable {
        /// The date the override was first created.
        public var dateCreated: ClientRuntime.Date?
        /// The date the override was last modified.
        public var dateModified: ClientRuntime.Date?
        /// A description of the override.
        public var description: Swift.String?
        /// The device to which the override applies.
        public var deviceId: Swift.String?
        /// The effect of the override, ALLOW or DENY.
        public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
        /// The WorkMail user to which the access override applies.
        public var userId: Swift.String?

        public init(
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
            userId: Swift.String? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.deviceId = deviceId
            self.effect = effect
            self.userId = userId
        }
    }

}

extension WorkMailClientTypes.MobileDeviceAccessRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateCreated = self.dateCreated {
            try encodeContainer.encodeTimestamp(dateCreated, format: .epochSeconds, forKey: .dateCreated)
        }
        if let dateModified = self.dateModified {
            try encodeContainer.encodeTimestamp(dateModified, format: .epochSeconds, forKey: .dateModified)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceModels = deviceModels {
            var deviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceModels)
            for devicemodel0 in deviceModels {
                try deviceModelsContainer.encode(devicemodel0)
            }
        }
        if let deviceOperatingSystems = deviceOperatingSystems {
            var deviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceOperatingSystems)
            for deviceoperatingsystem0 in deviceOperatingSystems {
                try deviceOperatingSystemsContainer.encode(deviceoperatingsystem0)
            }
        }
        if let deviceTypes = deviceTypes {
            var deviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceTypes)
            for devicetype0 in deviceTypes {
                try deviceTypesContainer.encode(devicetype0)
            }
        }
        if let deviceUserAgents = deviceUserAgents {
            var deviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceUserAgents)
            for deviceuseragent0 in deviceUserAgents {
                try deviceUserAgentsContainer.encode(deviceuseragent0)
            }
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let mobileDeviceAccessRuleId = self.mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notDeviceModels = notDeviceModels {
            var notDeviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceModels)
            for devicemodel0 in notDeviceModels {
                try notDeviceModelsContainer.encode(devicemodel0)
            }
        }
        if let notDeviceOperatingSystems = notDeviceOperatingSystems {
            var notDeviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceOperatingSystems)
            for deviceoperatingsystem0 in notDeviceOperatingSystems {
                try notDeviceOperatingSystemsContainer.encode(deviceoperatingsystem0)
            }
        }
        if let notDeviceTypes = notDeviceTypes {
            var notDeviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceTypes)
            for devicetype0 in notDeviceTypes {
                try notDeviceTypesContainer.encode(devicetype0)
            }
        }
        if let notDeviceUserAgents = notDeviceUserAgents {
            var notDeviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceUserAgents)
            for deviceuseragent0 in notDeviceUserAgents {
                try notDeviceUserAgentsContainer.encode(deviceuseragent0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let deviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceTypes)
        var deviceTypesDecoded0:[Swift.String]? = nil
        if let deviceTypesContainer = deviceTypesContainer {
            deviceTypesDecoded0 = [Swift.String]()
            for string0 in deviceTypesContainer {
                if let string0 = string0 {
                    deviceTypesDecoded0?.append(string0)
                }
            }
        }
        deviceTypes = deviceTypesDecoded0
        let notDeviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceTypes)
        var notDeviceTypesDecoded0:[Swift.String]? = nil
        if let notDeviceTypesContainer = notDeviceTypesContainer {
            notDeviceTypesDecoded0 = [Swift.String]()
            for string0 in notDeviceTypesContainer {
                if let string0 = string0 {
                    notDeviceTypesDecoded0?.append(string0)
                }
            }
        }
        notDeviceTypes = notDeviceTypesDecoded0
        let deviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceModels)
        var deviceModelsDecoded0:[Swift.String]? = nil
        if let deviceModelsContainer = deviceModelsContainer {
            deviceModelsDecoded0 = [Swift.String]()
            for string0 in deviceModelsContainer {
                if let string0 = string0 {
                    deviceModelsDecoded0?.append(string0)
                }
            }
        }
        deviceModels = deviceModelsDecoded0
        let notDeviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceModels)
        var notDeviceModelsDecoded0:[Swift.String]? = nil
        if let notDeviceModelsContainer = notDeviceModelsContainer {
            notDeviceModelsDecoded0 = [Swift.String]()
            for string0 in notDeviceModelsContainer {
                if let string0 = string0 {
                    notDeviceModelsDecoded0?.append(string0)
                }
            }
        }
        notDeviceModels = notDeviceModelsDecoded0
        let deviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceOperatingSystems)
        var deviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let deviceOperatingSystemsContainer = deviceOperatingSystemsContainer {
            deviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in deviceOperatingSystemsContainer {
                if let string0 = string0 {
                    deviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        deviceOperatingSystems = deviceOperatingSystemsDecoded0
        let notDeviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceOperatingSystems)
        var notDeviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let notDeviceOperatingSystemsContainer = notDeviceOperatingSystemsContainer {
            notDeviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in notDeviceOperatingSystemsContainer {
                if let string0 = string0 {
                    notDeviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        notDeviceOperatingSystems = notDeviceOperatingSystemsDecoded0
        let deviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceUserAgents)
        var deviceUserAgentsDecoded0:[Swift.String]? = nil
        if let deviceUserAgentsContainer = deviceUserAgentsContainer {
            deviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in deviceUserAgentsContainer {
                if let string0 = string0 {
                    deviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        deviceUserAgents = deviceUserAgentsDecoded0
        let notDeviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceUserAgents)
        var notDeviceUserAgentsDecoded0:[Swift.String]? = nil
        if let notDeviceUserAgentsContainer = notDeviceUserAgentsContainer {
            notDeviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in notDeviceUserAgentsContainer {
                if let string0 = string0 {
                    notDeviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        notDeviceUserAgents = notDeviceUserAgentsDecoded0
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension WorkMailClientTypes {
    /// A rule that controls access to mobile devices for an WorkMail group.
    public struct MobileDeviceAccessRule: Swift.Equatable {
        /// The date and time at which an access rule was created.
        public var dateCreated: ClientRuntime.Date?
        /// The date and time at which an access rule was modified.
        public var dateModified: ClientRuntime.Date?
        /// The description of a mobile access rule.
        public var description: Swift.String?
        /// Device models that a rule will match.
        public var deviceModels: [Swift.String]?
        /// Device operating systems that a rule will match.
        public var deviceOperatingSystems: [Swift.String]?
        /// Device types that a rule will match.
        public var deviceTypes: [Swift.String]?
        /// Device user agents that a rule will match.
        public var deviceUserAgents: [Swift.String]?
        /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
        public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
        /// The ID assigned to a mobile access rule.
        public var mobileDeviceAccessRuleId: Swift.String?
        /// The name of a mobile access rule.
        public var name: Swift.String?
        /// Device models that a rule will not match. All other device models will match.
        public var notDeviceModels: [Swift.String]?
        /// Device operating systems that a rule will not match. All other device types will match.
        public var notDeviceOperatingSystems: [Swift.String]?
        /// Device types that a rule will not match. All other device types will match.
        public var notDeviceTypes: [Swift.String]?
        /// Device user agents that a rule will not match. All other device user agents will match.
        public var notDeviceUserAgents: [Swift.String]?

        public init(
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            deviceModels: [Swift.String]? = nil,
            deviceOperatingSystems: [Swift.String]? = nil,
            deviceTypes: [Swift.String]? = nil,
            deviceUserAgents: [Swift.String]? = nil,
            effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
            mobileDeviceAccessRuleId: Swift.String? = nil,
            name: Swift.String? = nil,
            notDeviceModels: [Swift.String]? = nil,
            notDeviceOperatingSystems: [Swift.String]? = nil,
            notDeviceTypes: [Swift.String]? = nil,
            notDeviceUserAgents: [Swift.String]? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.deviceModels = deviceModels
            self.deviceOperatingSystems = deviceOperatingSystems
            self.deviceTypes = deviceTypes
            self.deviceUserAgents = deviceUserAgents
            self.effect = effect
            self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
            self.name = name
            self.notDeviceModels = notDeviceModels
            self.notDeviceOperatingSystems = notDeviceOperatingSystems
            self.notDeviceTypes = notDeviceTypes
            self.notDeviceUserAgents = notDeviceUserAgents
        }
    }

}

extension WorkMailClientTypes {
    public enum MobileDeviceAccessRuleEffect: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [MobileDeviceAccessRuleEffect] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MobileDeviceAccessRuleEffect(rawValue: rawValue) ?? MobileDeviceAccessRuleEffect.sdkUnknown(rawValue)
        }
    }
}

extension NameAvailabilityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NameAvailabilityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user, group, or resource name isn't unique in WorkMail.
public struct NameAvailabilityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NameAvailabilityException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NameAvailabilityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NameAvailabilityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OrganizationNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An operation received a valid organization identifier that either doesn't belong or exist in the system.
public struct OrganizationNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OrganizationNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OrganizationStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The organization must have a valid state to perform certain operations on the organization or its members.
public struct OrganizationStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OrganizationStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes.OrganizationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case defaultMailDomain = "DefaultMailDomain"
        case errorMessage = "ErrorMessage"
        case organizationId = "OrganizationId"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let defaultMailDomain = self.defaultMailDomain {
            try encodeContainer.encode(defaultMailDomain, forKey: .defaultMailDomain)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let defaultMailDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultMailDomain)
        defaultMailDomain = defaultMailDomainDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
    }
}

extension WorkMailClientTypes {
    /// The representation of an organization.
    public struct OrganizationSummary: Swift.Equatable {
        /// The alias associated with the organization.
        public var alias: Swift.String?
        /// The default email domain associated with the organization.
        public var defaultMailDomain: Swift.String?
        /// The error message associated with the organization. It is only present if unexpected behavior has occurred with regards to the organization. It provides insight or solutions regarding unexpected behavior.
        public var errorMessage: Swift.String?
        /// The identifier associated with the organization.
        public var organizationId: Swift.String?
        /// The state associated with the organization.
        public var state: Swift.String?

        public init(
            alias: Swift.String? = nil,
            defaultMailDomain: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            organizationId: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.alias = alias
            self.defaultMailDomain = defaultMailDomain
            self.errorMessage = errorMessage
            self.organizationId = organizationId
            self.state = state
        }
    }

}

extension WorkMailClientTypes.Permission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case granteeId = "GranteeId"
        case granteeType = "GranteeType"
        case permissionValues = "PermissionValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let granteeId = self.granteeId {
            try encodeContainer.encode(granteeId, forKey: .granteeId)
        }
        if let granteeType = self.granteeType {
            try encodeContainer.encode(granteeType.rawValue, forKey: .granteeType)
        }
        if let permissionValues = permissionValues {
            var permissionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionValues)
            for permissiontype0 in permissionValues {
                try permissionValuesContainer.encode(permissiontype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteeId)
        granteeId = granteeIdDecoded
        let granteeTypeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MemberType.self, forKey: .granteeType)
        granteeType = granteeTypeDecoded
        let permissionValuesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.PermissionType?].self, forKey: .permissionValues)
        var permissionValuesDecoded0:[WorkMailClientTypes.PermissionType]? = nil
        if let permissionValuesContainer = permissionValuesContainer {
            permissionValuesDecoded0 = [WorkMailClientTypes.PermissionType]()
            for enum0 in permissionValuesContainer {
                if let enum0 = enum0 {
                    permissionValuesDecoded0?.append(enum0)
                }
            }
        }
        permissionValues = permissionValuesDecoded0
    }
}

extension WorkMailClientTypes {
    /// Permission granted to a user, group, or resource to access a certain aspect of another user, group, or resource mailbox.
    public struct Permission: Swift.Equatable {
        /// The identifier of the user, group, or resource to which the permissions are granted.
        /// This member is required.
        public var granteeId: Swift.String?
        /// The type of user, group, or resource referred to in GranteeId.
        /// This member is required.
        public var granteeType: WorkMailClientTypes.MemberType?
        /// The permissions granted to the grantee. SEND_AS allows the grantee to send email as the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full access to the mailbox, irrespective of other folder-level permissions set on the mailbox.
        /// This member is required.
        public var permissionValues: [WorkMailClientTypes.PermissionType]?

        public init(
            granteeId: Swift.String? = nil,
            granteeType: WorkMailClientTypes.MemberType? = nil,
            permissionValues: [WorkMailClientTypes.PermissionType]? = nil
        )
        {
            self.granteeId = granteeId
            self.granteeType = granteeType
            self.permissionValues = permissionValues
        }
    }

}

extension WorkMailClientTypes {
    public enum PermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullAccess
        case sendAs
        case sendOnBehalf
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .fullAccess,
                .sendAs,
                .sendOnBehalf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullAccess: return "FULL_ACCESS"
            case .sendAs: return "SEND_AS"
            case .sendOnBehalf: return "SEND_ON_BEHALF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionType(rawValue: rawValue) ?? PermissionType.sdkUnknown(rawValue)
        }
    }
}

extension PutAccessControlRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case description = "Description"
        case effect = "Effect"
        case impersonationRoleIds = "ImpersonationRoleIds"
        case ipRanges = "IpRanges"
        case name = "Name"
        case notActions = "NotActions"
        case notImpersonationRoleIds = "NotImpersonationRoleIds"
        case notIpRanges = "NotIpRanges"
        case notUserIds = "NotUserIds"
        case organizationId = "OrganizationId"
        case userIds = "UserIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for accesscontrolruleaction0 in actions {
                try actionsContainer.encode(accesscontrolruleaction0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let impersonationRoleIds = impersonationRoleIds {
            var impersonationRoleIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .impersonationRoleIds)
            for impersonationroleid0 in impersonationRoleIds {
                try impersonationRoleIdsContainer.encode(impersonationroleid0)
            }
        }
        if let ipRanges = ipRanges {
            var ipRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRanges)
            for iprange0 in ipRanges {
                try ipRangesContainer.encode(iprange0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notActions = notActions {
            var notActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notActions)
            for accesscontrolruleaction0 in notActions {
                try notActionsContainer.encode(accesscontrolruleaction0)
            }
        }
        if let notImpersonationRoleIds = notImpersonationRoleIds {
            var notImpersonationRoleIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notImpersonationRoleIds)
            for impersonationroleid0 in notImpersonationRoleIds {
                try notImpersonationRoleIdsContainer.encode(impersonationroleid0)
            }
        }
        if let notIpRanges = notIpRanges {
            var notIpRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notIpRanges)
            for iprange0 in notIpRanges {
                try notIpRangesContainer.encode(iprange0)
            }
        }
        if let notUserIds = notUserIds {
            var notUserIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notUserIds)
            for workmailidentifier0 in notUserIds {
                try notUserIdsContainer.encode(workmailidentifier0)
            }
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for workmailidentifier0 in userIds {
                try userIdsContainer.encode(workmailidentifier0)
            }
        }
    }
}

extension PutAccessControlRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutAccessControlRuleInput: Swift.Equatable {
    /// Access protocol actions to include in the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
    public var actions: [Swift.String]?
    /// The rule description.
    /// This member is required.
    public var description: Swift.String?
    /// The rule effect.
    /// This member is required.
    public var effect: WorkMailClientTypes.AccessControlRuleEffect?
    /// Impersonation role IDs to include in the rule.
    public var impersonationRoleIds: [Swift.String]?
    /// IPv4 CIDR ranges to include in the rule.
    public var ipRanges: [Swift.String]?
    /// The rule name.
    /// This member is required.
    public var name: Swift.String?
    /// Access protocol actions to exclude from the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
    public var notActions: [Swift.String]?
    /// Impersonation role IDs to exclude from the rule.
    public var notImpersonationRoleIds: [Swift.String]?
    /// IPv4 CIDR ranges to exclude from the rule.
    public var notIpRanges: [Swift.String]?
    /// User IDs to exclude from the rule.
    public var notUserIds: [Swift.String]?
    /// The identifier of the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// User IDs to include in the rule.
    public var userIds: [Swift.String]?

    public init(
        actions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        effect: WorkMailClientTypes.AccessControlRuleEffect? = nil,
        impersonationRoleIds: [Swift.String]? = nil,
        ipRanges: [Swift.String]? = nil,
        name: Swift.String? = nil,
        notActions: [Swift.String]? = nil,
        notImpersonationRoleIds: [Swift.String]? = nil,
        notIpRanges: [Swift.String]? = nil,
        notUserIds: [Swift.String]? = nil,
        organizationId: Swift.String? = nil,
        userIds: [Swift.String]? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.effect = effect
        self.impersonationRoleIds = impersonationRoleIds
        self.ipRanges = ipRanges
        self.name = name
        self.notActions = notActions
        self.notImpersonationRoleIds = notImpersonationRoleIds
        self.notIpRanges = notIpRanges
        self.notUserIds = notUserIds
        self.organizationId = organizationId
        self.userIds = userIds
    }
}

struct PutAccessControlRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let effect: WorkMailClientTypes.AccessControlRuleEffect?
    let description: Swift.String?
    let ipRanges: [Swift.String]?
    let notIpRanges: [Swift.String]?
    let actions: [Swift.String]?
    let notActions: [Swift.String]?
    let userIds: [Swift.String]?
    let notUserIds: [Swift.String]?
    let organizationId: Swift.String?
    let impersonationRoleIds: [Swift.String]?
    let notImpersonationRoleIds: [Swift.String]?
}

extension PutAccessControlRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case description = "Description"
        case effect = "Effect"
        case impersonationRoleIds = "ImpersonationRoleIds"
        case ipRanges = "IpRanges"
        case name = "Name"
        case notActions = "NotActions"
        case notImpersonationRoleIds = "NotImpersonationRoleIds"
        case notIpRanges = "NotIpRanges"
        case notUserIds = "NotUserIds"
        case organizationId = "OrganizationId"
        case userIds = "UserIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AccessControlRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ipRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipRanges)
        var ipRangesDecoded0:[Swift.String]? = nil
        if let ipRangesContainer = ipRangesContainer {
            ipRangesDecoded0 = [Swift.String]()
            for string0 in ipRangesContainer {
                if let string0 = string0 {
                    ipRangesDecoded0?.append(string0)
                }
            }
        }
        ipRanges = ipRangesDecoded0
        let notIpRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notIpRanges)
        var notIpRangesDecoded0:[Swift.String]? = nil
        if let notIpRangesContainer = notIpRangesContainer {
            notIpRangesDecoded0 = [Swift.String]()
            for string0 in notIpRangesContainer {
                if let string0 = string0 {
                    notIpRangesDecoded0?.append(string0)
                }
            }
        }
        notIpRanges = notIpRangesDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let notActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notActions)
        var notActionsDecoded0:[Swift.String]? = nil
        if let notActionsContainer = notActionsContainer {
            notActionsDecoded0 = [Swift.String]()
            for string0 in notActionsContainer {
                if let string0 = string0 {
                    notActionsDecoded0?.append(string0)
                }
            }
        }
        notActions = notActionsDecoded0
        let userIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIds)
        var userIdsDecoded0:[Swift.String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [Swift.String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
        let notUserIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notUserIds)
        var notUserIdsDecoded0:[Swift.String]? = nil
        if let notUserIdsContainer = notUserIdsContainer {
            notUserIdsDecoded0 = [Swift.String]()
            for string0 in notUserIdsContainer {
                if let string0 = string0 {
                    notUserIdsDecoded0?.append(string0)
                }
            }
        }
        notUserIds = notUserIdsDecoded0
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let impersonationRoleIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .impersonationRoleIds)
        var impersonationRoleIdsDecoded0:[Swift.String]? = nil
        if let impersonationRoleIdsContainer = impersonationRoleIdsContainer {
            impersonationRoleIdsDecoded0 = [Swift.String]()
            for string0 in impersonationRoleIdsContainer {
                if let string0 = string0 {
                    impersonationRoleIdsDecoded0?.append(string0)
                }
            }
        }
        impersonationRoleIds = impersonationRoleIdsDecoded0
        let notImpersonationRoleIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notImpersonationRoleIds)
        var notImpersonationRoleIdsDecoded0:[Swift.String]? = nil
        if let notImpersonationRoleIdsContainer = notImpersonationRoleIdsContainer {
            notImpersonationRoleIdsDecoded0 = [Swift.String]()
            for string0 in notImpersonationRoleIdsContainer {
                if let string0 = string0 {
                    notImpersonationRoleIdsDecoded0?.append(string0)
                }
            }
        }
        notImpersonationRoleIds = notImpersonationRoleIdsDecoded0
    }
}

extension PutAccessControlRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutAccessControlRuleOutput: Swift.Equatable {

    public init() { }
}

enum PutAccessControlRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutEmailMonitoringConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupArn = "LogGroupArn"
        case organizationId = "OrganizationId"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension PutEmailMonitoringConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutEmailMonitoringConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the CloudWatch Log group associated with the email monitoring configuration.
    /// This member is required.
    public var logGroupArn: Swift.String?
    /// The ID of the organization for which the email monitoring configuration is set.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM Role associated with the email monitoring configuration.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        logGroupArn: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.logGroupArn = logGroupArn
        self.organizationId = organizationId
        self.roleArn = roleArn
    }
}

struct PutEmailMonitoringConfigurationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let roleArn: Swift.String?
    let logGroupArn: Swift.String?
}

extension PutEmailMonitoringConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupArn = "LogGroupArn"
        case organizationId = "OrganizationId"
        case roleArn = "RoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension PutEmailMonitoringConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutEmailMonitoringConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutEmailMonitoringConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutInboundDmarcSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enforced = "Enforced"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enforced = self.enforced {
            try encodeContainer.encode(enforced, forKey: .enforced)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension PutInboundDmarcSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutInboundDmarcSettingsInput: Swift.Equatable {
    /// Enforces or suspends a policy after it's applied.
    /// This member is required.
    public var enforced: Swift.Bool?
    /// The ID of the organization that you are applying the DMARC policy to.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        enforced: Swift.Bool? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.enforced = enforced
        self.organizationId = organizationId
    }
}

struct PutInboundDmarcSettingsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let enforced: Swift.Bool?
}

extension PutInboundDmarcSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enforced = "Enforced"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let enforcedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforced)
        enforced = enforcedDecoded
    }
}

extension PutInboundDmarcSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutInboundDmarcSettingsOutput: Swift.Equatable {

    public init() { }
}

enum PutInboundDmarcSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutMailboxPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
        case permissionValues = "PermissionValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let granteeId = self.granteeId {
            try encodeContainer.encode(granteeId, forKey: .granteeId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let permissionValues = permissionValues {
            var permissionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionValues)
            for permissiontype0 in permissionValues {
                try permissionValuesContainer.encode(permissiontype0.rawValue)
            }
        }
    }
}

extension PutMailboxPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutMailboxPermissionsInput: Swift.Equatable {
    /// The identifier of the user or resource for which to update mailbox permissions. The identifier can be UserId, ResourceID, or Group Id, Username, Resourcename, or Groupname, or email.
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier of the user, group, or resource to which to grant the permissions. The identifier can be UserId, ResourceID, or Group Id, Username, Resourcename, or Groupname, or email.
    ///
    /// * Grantee ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: grantee@domain.tld
    ///
    /// * Grantee name: grantee
    /// This member is required.
    public var granteeId: Swift.String?
    /// The identifier of the organization under which the user, group, or resource exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The permissions granted to the grantee. SEND_AS allows the grantee to send email as the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full access to the mailbox, irrespective of other folder-level permissions set on the mailbox.
    /// This member is required.
    public var permissionValues: [WorkMailClientTypes.PermissionType]?

    public init(
        entityId: Swift.String? = nil,
        granteeId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        permissionValues: [WorkMailClientTypes.PermissionType]? = nil
    )
    {
        self.entityId = entityId
        self.granteeId = granteeId
        self.organizationId = organizationId
        self.permissionValues = permissionValues
    }
}

struct PutMailboxPermissionsInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let granteeId: Swift.String?
    let permissionValues: [WorkMailClientTypes.PermissionType]?
}

extension PutMailboxPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
        case permissionValues = "PermissionValues"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let granteeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteeId)
        granteeId = granteeIdDecoded
        let permissionValuesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.PermissionType?].self, forKey: .permissionValues)
        var permissionValuesDecoded0:[WorkMailClientTypes.PermissionType]? = nil
        if let permissionValuesContainer = permissionValuesContainer {
            permissionValuesDecoded0 = [WorkMailClientTypes.PermissionType]()
            for enum0 in permissionValuesContainer {
                if let enum0 = enum0 {
                    permissionValuesDecoded0?.append(enum0)
                }
            }
        }
        permissionValues = permissionValuesDecoded0
    }
}

extension PutMailboxPermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutMailboxPermissionsOutput: Swift.Equatable {

    public init() { }
}

enum PutMailboxPermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutMobileDeviceAccessOverrideInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case deviceId = "DeviceId"
        case effect = "Effect"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension PutMobileDeviceAccessOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutMobileDeviceAccessOverrideInput: Swift.Equatable {
    /// A description of the override.
    public var description: Swift.String?
    /// The mobile device for which you create the override. DeviceId is case insensitive.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The effect of the override, ALLOW or DENY.
    /// This member is required.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// Identifies the WorkMail organization for which you create the override.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail user for which you create the override. Accepts the following types of user identities:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init(
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.description = description
        self.deviceId = deviceId
        self.effect = effect
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct PutMobileDeviceAccessOverrideInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
    let deviceId: Swift.String?
    let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    let description: Swift.String?
}

extension PutMobileDeviceAccessOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case deviceId = "DeviceId"
        case effect = "Effect"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension PutMobileDeviceAccessOverrideOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutMobileDeviceAccessOverrideOutput: Swift.Equatable {

    public init() { }
}

enum PutMobileDeviceAccessOverrideOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutRetentionPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRetentionPolicyInput(folderConfigurations: \(Swift.String(describing: folderConfigurations)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), organizationId: \(Swift.String(describing: organizationId)), description: \"CONTENT_REDACTED\")"}
}

extension PutRetentionPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case folderConfigurations = "FolderConfigurations"
        case id = "Id"
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let folderConfigurations = folderConfigurations {
            var folderConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .folderConfigurations)
            for folderconfiguration0 in folderConfigurations {
                try folderConfigurationsContainer.encode(folderconfiguration0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension PutRetentionPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRetentionPolicyInput: Swift.Equatable {
    /// The retention policy description.
    public var description: Swift.String?
    /// The retention policy folder configurations.
    /// This member is required.
    public var folderConfigurations: [WorkMailClientTypes.FolderConfiguration]?
    /// The retention policy ID.
    public var id: Swift.String?
    /// The retention policy name.
    /// This member is required.
    public var name: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        description: Swift.String? = nil,
        folderConfigurations: [WorkMailClientTypes.FolderConfiguration]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.description = description
        self.folderConfigurations = folderConfigurations
        self.id = id
        self.name = name
        self.organizationId = organizationId
    }
}

struct PutRetentionPolicyInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let folderConfigurations: [WorkMailClientTypes.FolderConfiguration]?
}

extension PutRetentionPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case folderConfigurations = "FolderConfigurations"
        case id = "Id"
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let folderConfigurationsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.FolderConfiguration?].self, forKey: .folderConfigurations)
        var folderConfigurationsDecoded0:[WorkMailClientTypes.FolderConfiguration]? = nil
        if let folderConfigurationsContainer = folderConfigurationsContainer {
            folderConfigurationsDecoded0 = [WorkMailClientTypes.FolderConfiguration]()
            for structure0 in folderConfigurationsContainer {
                if let structure0 = structure0 {
                    folderConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        folderConfigurations = folderConfigurationsDecoded0
    }
}

extension PutRetentionPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutRetentionPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutRetentionPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkMailClientTypes.RedactedEwsAvailabilityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ewsEndpoint = "EwsEndpoint"
        case ewsUsername = "EwsUsername"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ewsEndpoint = self.ewsEndpoint {
            try encodeContainer.encode(ewsEndpoint, forKey: .ewsEndpoint)
        }
        if let ewsUsername = self.ewsUsername {
            try encodeContainer.encode(ewsUsername, forKey: .ewsUsername)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ewsEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ewsEndpoint)
        ewsEndpoint = ewsEndpointDecoded
        let ewsUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ewsUsername)
        ewsUsername = ewsUsernameDecoded
    }
}

extension WorkMailClientTypes {
    /// Describes an EWS based availability provider when returned from the service. It does not contain the password of the endpoint.
    public struct RedactedEwsAvailabilityProvider: Swift.Equatable {
        /// The endpoint of the remote EWS server.
        public var ewsEndpoint: Swift.String?
        /// The username used to authenticate the remote EWS server.
        public var ewsUsername: Swift.String?

        public init(
            ewsEndpoint: Swift.String? = nil,
            ewsUsername: Swift.String? = nil
        )
        {
            self.ewsEndpoint = ewsEndpoint
            self.ewsUsername = ewsUsername
        }
    }

}

extension RegisterMailDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension RegisterMailDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterMailDomainInput: Swift.Equatable {
    /// Idempotency token used when retrying requests.
    public var clientToken: Swift.String?
    /// The name of the mail domain to create in WorkMail and SES.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization under which you're creating the domain.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

struct RegisterMailDomainInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let organizationId: Swift.String?
    let domainName: Swift.String?
}

extension RegisterMailDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension RegisterMailDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RegisterMailDomainOutput: Swift.Equatable {

    public init() { }
}

enum RegisterMailDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MailDomainInUseException": return try await MailDomainInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterToWorkMailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension RegisterToWorkMailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterToWorkMailInput: Swift.Equatable {
    /// The email for the user, group, or resource to be updated.
    /// This member is required.
    public var email: Swift.String?
    /// The identifier for the user, group, or resource to be updated. The identifier can accept UserId, ResourceId, or GroupId, or Username, Resourcename, or Groupname. The following identity formats are available:
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the user, group, or resource exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        email: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.email = email
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct RegisterToWorkMailInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let email: Swift.String?
}

extension RegisterToWorkMailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension RegisterToWorkMailOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RegisterToWorkMailOutput: Swift.Equatable {

    public init() { }
}

enum RegisterToWorkMailOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DirectoryServiceAuthenticationFailedException": return try await DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EmailAddressInUseException": return try await EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityAlreadyRegisteredException": return try await EntityAlreadyRegisteredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MailDomainNotFoundException": return try await MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MailDomainStateException": return try await MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ReservedNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReservedNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This user, group, or resource name is not allowed in WorkMail.
public struct ReservedNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReservedNameException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReservedNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReservedNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResetPasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetPasswordInput(organizationId: \(Swift.String(describing: organizationId)), userId: \(Swift.String(describing: userId)), password: \"CONTENT_REDACTED\")"}
}

extension ResetPasswordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case password = "Password"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension ResetPasswordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResetPasswordInput: Swift.Equatable {
    /// The identifier of the organization that contains the user for which the password is reset.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The new password for the user.
    /// This member is required.
    public var password: Swift.String?
    /// The identifier of the user for whom the password is reset.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        password: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.password = password
        self.userId = userId
    }
}

struct ResetPasswordInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
    let password: Swift.String?
}

extension ResetPasswordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case password = "Password"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension ResetPasswordOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ResetPasswordOutput: Swift.Equatable {

    public init() { }
}

enum ResetPasswordOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DirectoryServiceAuthenticationFailedException": return try await DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPasswordException": return try await InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkMailClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disabledDate = self.disabledDate {
            try encodeContainer.encodeTimestamp(disabledDate, format: .epochSeconds, forKey: .disabledDate)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enabledDate = self.enabledDate {
            try encodeContainer.encodeTimestamp(enabledDate, format: .epochSeconds, forKey: .enabledDate)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ResourceType.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension WorkMailClientTypes {
    /// The representation of a resource.
    public struct Resource: Swift.Equatable {
        /// Resource description.
        public var description: Swift.String?
        /// The date indicating when the resource was disabled from WorkMail use.
        public var disabledDate: ClientRuntime.Date?
        /// The email of the resource.
        public var email: Swift.String?
        /// The date indicating when the resource was enabled for WorkMail use.
        public var enabledDate: ClientRuntime.Date?
        /// The identifier of the resource.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?
        /// The state of the resource, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?
        /// The type of the resource: equipment or room.
        public var type: WorkMailClientTypes.ResourceType?

        public init(
            description: Swift.String? = nil,
            disabledDate: ClientRuntime.Date? = nil,
            email: Swift.String? = nil,
            enabledDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil,
            type: WorkMailClientTypes.ResourceType? = nil
        )
        {
            self.description = description
            self.disabledDate = disabledDate
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.type = type
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equipment
        case room
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .equipment,
                .room,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equipment: return "EQUIPMENT"
            case .room: return "ROOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes {
    public enum RetentionAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case `none`
        case permanentlyDelete
        case sdkUnknown(Swift.String)

        public static var allCases: [RetentionAction] {
            return [
                .delete,
                .none,
                .permanentlyDelete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .none: return "NONE"
            case .permanentlyDelete: return "PERMANENTLY_DELETE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetentionAction(rawValue: rawValue) ?? RetentionAction.sdkUnknown(rawValue)
        }
    }
}

extension StartMailboxExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case entityId = "EntityId"
        case kmsKeyArn = "KmsKeyArn"
        case organizationId = "OrganizationId"
        case roleArn = "RoleArn"
        case s3BucketName = "S3BucketName"
        case s3Prefix = "S3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3Prefix = self.s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
    }
}

extension StartMailboxExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartMailboxExportJobInput: Swift.Equatable {
    /// The idempotency token for the client request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The mailbox export job description.
    public var description: Swift.String?
    /// The identifier of the user or resource associated with the mailbox. The identifier can accept UserId or ResourceId, Username or Resourcename, or email. The following identity formats are available:
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789 , or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The Amazon Resource Name (ARN) of the symmetric AWS Key Management Service (AWS KMS) key that encrypts the exported mailbox content.
    /// This member is required.
    public var kmsKeyArn: Swift.String?
    /// The identifier associated with the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The ARN of the AWS Identity and Access Management (IAM) role that grants write permission to the S3 bucket.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the S3 bucket.
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// The S3 bucket prefix.
    /// This member is required.
    public var s3Prefix: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3Prefix: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.entityId = entityId
        self.kmsKeyArn = kmsKeyArn
        self.organizationId = organizationId
        self.roleArn = roleArn
        self.s3BucketName = s3BucketName
        self.s3Prefix = s3Prefix
    }
}

struct StartMailboxExportJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let kmsKeyArn: Swift.String?
    let s3BucketName: Swift.String?
    let s3Prefix: Swift.String?
}

extension StartMailboxExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case entityId = "EntityId"
        case kmsKeyArn = "KmsKeyArn"
        case organizationId = "OrganizationId"
        case roleArn = "RoleArn"
        case s3BucketName = "S3BucketName"
        case s3Prefix = "S3Prefix"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
    }
}

extension StartMailboxExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMailboxExportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartMailboxExportJobOutput: Swift.Equatable {
    /// The job ID.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartMailboxExportJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartMailboxExportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StartMailboxExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkMailClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension WorkMailClientTypes {
    /// Describes a tag applied to a resource.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [WorkMailClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [WorkMailClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [WorkMailClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkMailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkMailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TestAvailabilityConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case ewsProvider = "EwsProvider"
        case lambdaProvider = "LambdaProvider"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let ewsProvider = self.ewsProvider {
            try encodeContainer.encode(ewsProvider, forKey: .ewsProvider)
        }
        if let lambdaProvider = self.lambdaProvider {
            try encodeContainer.encode(lambdaProvider, forKey: .lambdaProvider)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension TestAvailabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TestAvailabilityConfigurationInput: Swift.Equatable {
    /// The domain to which the provider applies. If this field is provided, a stored availability provider associated to this domain name will be tested.
    public var domainName: Swift.String?
    /// Describes an EWS based availability provider. This is only used as input to the service.
    public var ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    /// Describes a Lambda based availability provider.
    public var lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
    /// The WorkMail organization where the availability provider will be tested.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider? = nil,
        lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.ewsProvider = ewsProvider
        self.lambdaProvider = lambdaProvider
        self.organizationId = organizationId
    }
}

struct TestAvailabilityConfigurationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let domainName: Swift.String?
    let ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    let lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
}

extension TestAvailabilityConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case ewsProvider = "EwsProvider"
        case lambdaProvider = "LambdaProvider"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let ewsProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EwsAvailabilityProvider.self, forKey: .ewsProvider)
        ewsProvider = ewsProviderDecoded
        let lambdaProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.LambdaAvailabilityProvider.self, forKey: .lambdaProvider)
        lambdaProvider = lambdaProviderDecoded
    }
}

extension TestAvailabilityConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestAvailabilityConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.failureReason = output.failureReason
            self.testPassed = output.testPassed
        } else {
            self.failureReason = nil
            self.testPassed = false
        }
    }
}

public struct TestAvailabilityConfigurationOutput: Swift.Equatable {
    /// String containing the reason for a failed test if TestPassed is false.
    public var failureReason: Swift.String?
    /// Boolean indicating whether the test passed or failed.
    public var testPassed: Swift.Bool

    public init(
        failureReason: Swift.String? = nil,
        testPassed: Swift.Bool = false
    )
    {
        self.failureReason = failureReason
        self.testPassed = testPassed
    }
}

struct TestAvailabilityConfigurationOutputBody: Swift.Equatable {
    let testPassed: Swift.Bool
    let failureReason: Swift.String?
}

extension TestAvailabilityConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason = "FailureReason"
        case testPassed = "TestPassed"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testPassedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .testPassed) ?? false
        testPassed = testPassedDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

enum TestAvailabilityConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource can have up to 50 user-applied tags.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOperationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You can't perform a write operation against a read-only directory.
public struct UnsupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAvailabilityConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case ewsProvider = "EwsProvider"
        case lambdaProvider = "LambdaProvider"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let ewsProvider = self.ewsProvider {
            try encodeContainer.encode(ewsProvider, forKey: .ewsProvider)
        }
        if let lambdaProvider = self.lambdaProvider {
            try encodeContainer.encode(lambdaProvider, forKey: .lambdaProvider)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension UpdateAvailabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAvailabilityConfigurationInput: Swift.Equatable {
    /// The domain to which the provider applies the availability configuration.
    /// This member is required.
    public var domainName: Swift.String?
    /// The EWS availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider. The previously stored provider will be overridden by the one provided.
    public var ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    /// The Lambda availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider. The previously stored provider will be overridden by the one provided.
    public var lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
    /// The WorkMail organization for which the AvailabilityConfiguration will be updated.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider? = nil,
        lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.ewsProvider = ewsProvider
        self.lambdaProvider = lambdaProvider
        self.organizationId = organizationId
    }
}

struct UpdateAvailabilityConfigurationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let domainName: Swift.String?
    let ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    let lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
}

extension UpdateAvailabilityConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case ewsProvider = "EwsProvider"
        case lambdaProvider = "LambdaProvider"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let ewsProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EwsAvailabilityProvider.self, forKey: .ewsProvider)
        ewsProvider = ewsProviderDecoded
        let lambdaProviderDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.LambdaAvailabilityProvider.self, forKey: .lambdaProvider)
        lambdaProvider = lambdaProviderDecoded
    }
}

extension UpdateAvailabilityConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAvailabilityConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAvailabilityConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDefaultMailDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension UpdateDefaultMailDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDefaultMailDomainInput: Swift.Equatable {
    /// The domain name that will become the default domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization for which to list domains.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

struct UpdateDefaultMailDomainInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let domainName: Swift.String?
}

extension UpdateDefaultMailDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension UpdateDefaultMailDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDefaultMailDomainOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDefaultMailDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MailDomainNotFoundException": return try await MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MailDomainStateException": return try await MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let hiddenFromGlobalAddressList = self.hiddenFromGlobalAddressList {
            try encodeContainer.encode(hiddenFromGlobalAddressList, forKey: .hiddenFromGlobalAddressList)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension UpdateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateGroupInput: Swift.Equatable {
    /// The identifier for the group to be updated. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:
    ///
    /// * Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: group@domain.tld
    ///
    /// * Group name: group
    /// This member is required.
    public var groupId: Swift.String?
    /// If enabled, the group is hidden from the global address list.
    public var hiddenFromGlobalAddressList: Swift.Bool?
    /// The identifier for the organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        hiddenFromGlobalAddressList: Swift.Bool? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.organizationId = organizationId
    }
}

struct UpdateGroupInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let groupId: Swift.String?
    let hiddenFromGlobalAddressList: Swift.Bool?
}

extension UpdateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let hiddenFromGlobalAddressListDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hiddenFromGlobalAddressList)
        hiddenFromGlobalAddressList = hiddenFromGlobalAddressListDecoded
    }
}

extension UpdateGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateImpersonationRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case impersonationRoleId = "ImpersonationRoleId"
        case name = "Name"
        case organizationId = "OrganizationId"
        case rules = "Rules"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let impersonationRoleId = self.impersonationRoleId {
            try encodeContainer.encode(impersonationRoleId, forKey: .impersonationRoleId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for impersonationrule0 in rules {
                try rulesContainer.encode(impersonationrule0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateImpersonationRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateImpersonationRoleInput: Swift.Equatable {
    /// The updated impersonation role description.
    public var description: Swift.String?
    /// The ID of the impersonation role to update.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The updated impersonation role name.
    /// This member is required.
    public var name: Swift.String?
    /// The WorkMail organization that contains the impersonation role to update.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The updated list of rules.
    /// This member is required.
    public var rules: [WorkMailClientTypes.ImpersonationRule]?
    /// The updated impersonation role type.
    /// This member is required.
    public var type: WorkMailClientTypes.ImpersonationRoleType?

    public init(
        description: Swift.String? = nil,
        impersonationRoleId: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        rules: [WorkMailClientTypes.ImpersonationRule]? = nil,
        type: WorkMailClientTypes.ImpersonationRoleType? = nil
    )
    {
        self.description = description
        self.impersonationRoleId = impersonationRoleId
        self.name = name
        self.organizationId = organizationId
        self.rules = rules
        self.type = type
    }
}

struct UpdateImpersonationRoleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let impersonationRoleId: Swift.String?
    let name: Swift.String?
    let type: WorkMailClientTypes.ImpersonationRoleType?
    let description: Swift.String?
    let rules: [WorkMailClientTypes.ImpersonationRule]?
}

extension UpdateImpersonationRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case impersonationRoleId = "ImpersonationRoleId"
        case name = "Name"
        case organizationId = "OrganizationId"
        case rules = "Rules"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let impersonationRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impersonationRoleId)
        impersonationRoleId = impersonationRoleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ImpersonationRoleType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.ImpersonationRule?].self, forKey: .rules)
        var rulesDecoded0:[WorkMailClientTypes.ImpersonationRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [WorkMailClientTypes.ImpersonationRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension UpdateImpersonationRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateImpersonationRoleOutput: Swift.Equatable {

    public init() { }
}

enum UpdateImpersonationRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMailboxQuotaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mailboxQuota = "MailboxQuota"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mailboxQuota = self.mailboxQuota {
            try encodeContainer.encode(mailboxQuota, forKey: .mailboxQuota)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension UpdateMailboxQuotaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateMailboxQuotaInput: Swift.Equatable {
    /// The updated mailbox quota, in MB, for the specified user.
    /// This member is required.
    public var mailboxQuota: Swift.Int?
    /// The identifier for the organization that contains the user for whom to update the mailbox quota.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifer for the user for whom to update the mailbox quota. The identifier can be the UserId, Username, or email. The following identity formats are available:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init(
        mailboxQuota: Swift.Int? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.mailboxQuota = mailboxQuota
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct UpdateMailboxQuotaInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
    let mailboxQuota: Swift.Int?
}

extension UpdateMailboxQuotaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mailboxQuota = "MailboxQuota"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let mailboxQuotaDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mailboxQuota)
        mailboxQuota = mailboxQuotaDecoded
    }
}

extension UpdateMailboxQuotaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateMailboxQuotaOutput: Swift.Equatable {

    public init() { }
}

enum UpdateMailboxQuotaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMobileDeviceAccessRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceModels = deviceModels {
            var deviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceModels)
            for devicemodel0 in deviceModels {
                try deviceModelsContainer.encode(devicemodel0)
            }
        }
        if let deviceOperatingSystems = deviceOperatingSystems {
            var deviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceOperatingSystems)
            for deviceoperatingsystem0 in deviceOperatingSystems {
                try deviceOperatingSystemsContainer.encode(deviceoperatingsystem0)
            }
        }
        if let deviceTypes = deviceTypes {
            var deviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceTypes)
            for devicetype0 in deviceTypes {
                try deviceTypesContainer.encode(devicetype0)
            }
        }
        if let deviceUserAgents = deviceUserAgents {
            var deviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceUserAgents)
            for deviceuseragent0 in deviceUserAgents {
                try deviceUserAgentsContainer.encode(deviceuseragent0)
            }
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let mobileDeviceAccessRuleId = self.mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notDeviceModels = notDeviceModels {
            var notDeviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceModels)
            for devicemodel0 in notDeviceModels {
                try notDeviceModelsContainer.encode(devicemodel0)
            }
        }
        if let notDeviceOperatingSystems = notDeviceOperatingSystems {
            var notDeviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceOperatingSystems)
            for deviceoperatingsystem0 in notDeviceOperatingSystems {
                try notDeviceOperatingSystemsContainer.encode(deviceoperatingsystem0)
            }
        }
        if let notDeviceTypes = notDeviceTypes {
            var notDeviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceTypes)
            for devicetype0 in notDeviceTypes {
                try notDeviceTypesContainer.encode(devicetype0)
            }
        }
        if let notDeviceUserAgents = notDeviceUserAgents {
            var notDeviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceUserAgents)
            for deviceuseragent0 in notDeviceUserAgents {
                try notDeviceUserAgentsContainer.encode(deviceuseragent0)
            }
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension UpdateMobileDeviceAccessRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateMobileDeviceAccessRuleInput: Swift.Equatable {
    /// The updated rule description.
    public var description: Swift.String?
    /// Device models that the updated rule will match.
    public var deviceModels: [Swift.String]?
    /// Device operating systems that the updated rule will match.
    public var deviceOperatingSystems: [Swift.String]?
    /// Device types that the updated rule will match.
    public var deviceTypes: [Swift.String]?
    /// User agents that the updated rule will match.
    public var deviceUserAgents: [Swift.String]?
    /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
    /// This member is required.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// The identifier of the rule to be updated.
    /// This member is required.
    public var mobileDeviceAccessRuleId: Swift.String?
    /// The updated rule name.
    /// This member is required.
    public var name: Swift.String?
    /// Device models that the updated rule will not match. All other device models will match.
    public var notDeviceModels: [Swift.String]?
    /// Device operating systems that the updated rule will not match. All other device operating systems will match.
    public var notDeviceOperatingSystems: [Swift.String]?
    /// Device types that the updated rule will not match. All other device types will match.
    public var notDeviceTypes: [Swift.String]?
    /// User agents that the updated rule will not match. All other user agents will match.
    public var notDeviceUserAgents: [Swift.String]?
    /// The WorkMail organization under which the rule will be updated.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        description: Swift.String? = nil,
        deviceModels: [Swift.String]? = nil,
        deviceOperatingSystems: [Swift.String]? = nil,
        deviceTypes: [Swift.String]? = nil,
        deviceUserAgents: [Swift.String]? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        mobileDeviceAccessRuleId: Swift.String? = nil,
        name: Swift.String? = nil,
        notDeviceModels: [Swift.String]? = nil,
        notDeviceOperatingSystems: [Swift.String]? = nil,
        notDeviceTypes: [Swift.String]? = nil,
        notDeviceUserAgents: [Swift.String]? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.description = description
        self.deviceModels = deviceModels
        self.deviceOperatingSystems = deviceOperatingSystems
        self.deviceTypes = deviceTypes
        self.deviceUserAgents = deviceUserAgents
        self.effect = effect
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
        self.name = name
        self.notDeviceModels = notDeviceModels
        self.notDeviceOperatingSystems = notDeviceOperatingSystems
        self.notDeviceTypes = notDeviceTypes
        self.notDeviceUserAgents = notDeviceUserAgents
        self.organizationId = organizationId
    }
}

struct UpdateMobileDeviceAccessRuleInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let mobileDeviceAccessRuleId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    let deviceTypes: [Swift.String]?
    let notDeviceTypes: [Swift.String]?
    let deviceModels: [Swift.String]?
    let notDeviceModels: [Swift.String]?
    let deviceOperatingSystems: [Swift.String]?
    let notDeviceOperatingSystems: [Swift.String]?
    let deviceUserAgents: [Swift.String]?
    let notDeviceUserAgents: [Swift.String]?
}

extension UpdateMobileDeviceAccessRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let deviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceTypes)
        var deviceTypesDecoded0:[Swift.String]? = nil
        if let deviceTypesContainer = deviceTypesContainer {
            deviceTypesDecoded0 = [Swift.String]()
            for string0 in deviceTypesContainer {
                if let string0 = string0 {
                    deviceTypesDecoded0?.append(string0)
                }
            }
        }
        deviceTypes = deviceTypesDecoded0
        let notDeviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceTypes)
        var notDeviceTypesDecoded0:[Swift.String]? = nil
        if let notDeviceTypesContainer = notDeviceTypesContainer {
            notDeviceTypesDecoded0 = [Swift.String]()
            for string0 in notDeviceTypesContainer {
                if let string0 = string0 {
                    notDeviceTypesDecoded0?.append(string0)
                }
            }
        }
        notDeviceTypes = notDeviceTypesDecoded0
        let deviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceModels)
        var deviceModelsDecoded0:[Swift.String]? = nil
        if let deviceModelsContainer = deviceModelsContainer {
            deviceModelsDecoded0 = [Swift.String]()
            for string0 in deviceModelsContainer {
                if let string0 = string0 {
                    deviceModelsDecoded0?.append(string0)
                }
            }
        }
        deviceModels = deviceModelsDecoded0
        let notDeviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceModels)
        var notDeviceModelsDecoded0:[Swift.String]? = nil
        if let notDeviceModelsContainer = notDeviceModelsContainer {
            notDeviceModelsDecoded0 = [Swift.String]()
            for string0 in notDeviceModelsContainer {
                if let string0 = string0 {
                    notDeviceModelsDecoded0?.append(string0)
                }
            }
        }
        notDeviceModels = notDeviceModelsDecoded0
        let deviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceOperatingSystems)
        var deviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let deviceOperatingSystemsContainer = deviceOperatingSystemsContainer {
            deviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in deviceOperatingSystemsContainer {
                if let string0 = string0 {
                    deviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        deviceOperatingSystems = deviceOperatingSystemsDecoded0
        let notDeviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceOperatingSystems)
        var notDeviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let notDeviceOperatingSystemsContainer = notDeviceOperatingSystemsContainer {
            notDeviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in notDeviceOperatingSystemsContainer {
                if let string0 = string0 {
                    notDeviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        notDeviceOperatingSystems = notDeviceOperatingSystemsDecoded0
        let deviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceUserAgents)
        var deviceUserAgentsDecoded0:[Swift.String]? = nil
        if let deviceUserAgentsContainer = deviceUserAgentsContainer {
            deviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in deviceUserAgentsContainer {
                if let string0 = string0 {
                    deviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        deviceUserAgents = deviceUserAgentsDecoded0
        let notDeviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceUserAgents)
        var notDeviceUserAgentsDecoded0:[Swift.String]? = nil
        if let notDeviceUserAgentsContainer = notDeviceUserAgentsContainer {
            notDeviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in notDeviceUserAgentsContainer {
                if let string0 = string0 {
                    notDeviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        notDeviceUserAgents = notDeviceUserAgentsDecoded0
    }
}

extension UpdateMobileDeviceAccessRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateMobileDeviceAccessRuleOutput: Swift.Equatable {

    public init() { }
}

enum UpdateMobileDeviceAccessRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePrimaryEmailAddressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension UpdatePrimaryEmailAddressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePrimaryEmailAddressInput: Swift.Equatable {
    /// The value of the email to be updated as primary.
    /// This member is required.
    public var email: Swift.String?
    /// The user, group, or resource to update. The identifier can accept UseriD, ResourceId, or GroupId, Username, Resourcename, or Groupname, or email. The following identity formats are available:
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The organization that contains the user, group, or resource to update.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        email: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.email = email
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct UpdatePrimaryEmailAddressInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let entityId: Swift.String?
    let email: Swift.String?
}

extension UpdatePrimaryEmailAddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension UpdatePrimaryEmailAddressOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePrimaryEmailAddressOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePrimaryEmailAddressOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DirectoryServiceAuthenticationFailedException": return try await DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EmailAddressInUseException": return try await EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MailDomainNotFoundException": return try await MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MailDomainStateException": return try await MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bookingOptions = "BookingOptions"
        case description = "Description"
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case name = "Name"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bookingOptions = self.bookingOptions {
            try encodeContainer.encode(bookingOptions, forKey: .bookingOptions)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hiddenFromGlobalAddressList = self.hiddenFromGlobalAddressList {
            try encodeContainer.encode(hiddenFromGlobalAddressList, forKey: .hiddenFromGlobalAddressList)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateResourceInput: Swift.Equatable {
    /// The resource's booking options to be updated.
    public var bookingOptions: WorkMailClientTypes.BookingOptions?
    /// Updates the resource description.
    public var description: Swift.String?
    /// If enabled, the resource is hidden from the global address list.
    public var hiddenFromGlobalAddressList: Swift.Bool?
    /// The name of the resource to be updated.
    public var name: Swift.String?
    /// The identifier associated with the organization for which the resource is updated.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource to be updated. The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:
    ///
    /// * Resource ID: r-0123456789a0123456789b0123456789
    ///
    /// * Email address: resource@domain.tld
    ///
    /// * Resource name: resource
    /// This member is required.
    public var resourceId: Swift.String?
    /// Updates the resource type.
    public var type: WorkMailClientTypes.ResourceType?

    public init(
        bookingOptions: WorkMailClientTypes.BookingOptions? = nil,
        description: Swift.String? = nil,
        hiddenFromGlobalAddressList: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        type: WorkMailClientTypes.ResourceType? = nil
    )
    {
        self.bookingOptions = bookingOptions
        self.description = description
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.name = name
        self.organizationId = organizationId
        self.resourceId = resourceId
        self.type = type
    }
}

struct UpdateResourceInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let resourceId: Swift.String?
    let name: Swift.String?
    let bookingOptions: WorkMailClientTypes.BookingOptions?
    let description: Swift.String?
    let type: WorkMailClientTypes.ResourceType?
    let hiddenFromGlobalAddressList: Swift.Bool?
}

extension UpdateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bookingOptions = "BookingOptions"
        case description = "Description"
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case name = "Name"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let bookingOptionsDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.BookingOptions.self, forKey: .bookingOptions)
        bookingOptions = bookingOptionsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ResourceType.self, forKey: .type)
        type = typeDecoded
        let hiddenFromGlobalAddressListDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hiddenFromGlobalAddressList)
        hiddenFromGlobalAddressList = hiddenFromGlobalAddressListDecoded
    }
}

extension UpdateResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateResourceOutput: Swift.Equatable {

    public init() { }
}

enum UpdateResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EmailAddressInUseException": return try await EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConfigurationException": return try await InvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MailDomainNotFoundException": return try await MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MailDomainStateException": return try await MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameAvailabilityException": return try await NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserInput(hiddenFromGlobalAddressList: \(Swift.String(describing: hiddenFromGlobalAddressList)), organizationId: \(Swift.String(describing: organizationId)), role: \(Swift.String(describing: role)), userId: \(Swift.String(describing: userId)), city: \"CONTENT_REDACTED\", company: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", department: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", initials: \"CONTENT_REDACTED\", jobTitle: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", office: \"CONTENT_REDACTED\", street: \"CONTENT_REDACTED\", telephone: \"CONTENT_REDACTED\", zipCode: \"CONTENT_REDACTED\")"}
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city = "City"
        case company = "Company"
        case country = "Country"
        case department = "Department"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case initials = "Initials"
        case jobTitle = "JobTitle"
        case lastName = "LastName"
        case office = "Office"
        case organizationId = "OrganizationId"
        case role = "Role"
        case street = "Street"
        case telephone = "Telephone"
        case userId = "UserId"
        case zipCode = "ZipCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let company = self.company {
            try encodeContainer.encode(company, forKey: .company)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let department = self.department {
            try encodeContainer.encode(department, forKey: .department)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let hiddenFromGlobalAddressList = self.hiddenFromGlobalAddressList {
            try encodeContainer.encode(hiddenFromGlobalAddressList, forKey: .hiddenFromGlobalAddressList)
        }
        if let initials = self.initials {
            try encodeContainer.encode(initials, forKey: .initials)
        }
        if let jobTitle = self.jobTitle {
            try encodeContainer.encode(jobTitle, forKey: .jobTitle)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let office = self.office {
            try encodeContainer.encode(office, forKey: .office)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let street = self.street {
            try encodeContainer.encode(street, forKey: .street)
        }
        if let telephone = self.telephone {
            try encodeContainer.encode(telephone, forKey: .telephone)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let zipCode = self.zipCode {
            try encodeContainer.encode(zipCode, forKey: .zipCode)
        }
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// Updates the user's city.
    public var city: Swift.String?
    /// Updates the user's company.
    public var company: Swift.String?
    /// Updates the user's country.
    public var country: Swift.String?
    /// Updates the user's department.
    public var department: Swift.String?
    /// Updates the display name of the user.
    public var displayName: Swift.String?
    /// Updates the user's first name.
    public var firstName: Swift.String?
    /// If enabled, the user is hidden from the global address list.
    public var hiddenFromGlobalAddressList: Swift.Bool?
    /// Updates the user's initials.
    public var initials: Swift.String?
    /// Updates the user's job title.
    public var jobTitle: Swift.String?
    /// Updates the user's last name.
    public var lastName: Swift.String?
    /// Updates the user's office.
    public var office: Swift.String?
    /// The identifier for the organization under which the user exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// Updates the user role. You cannot pass SYSTEM_USER or RESOURCE.
    public var role: WorkMailClientTypes.UserRole?
    /// Updates the user's street address.
    public var street: Swift.String?
    /// Updates the user's contact details.
    public var telephone: Swift.String?
    /// The identifier for the user to be updated. The identifier can be the UserId, Username, or email. The following identity formats are available:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?
    /// Updates the user's zipcode.
    public var zipCode: Swift.String?

    public init(
        city: Swift.String? = nil,
        company: Swift.String? = nil,
        country: Swift.String? = nil,
        department: Swift.String? = nil,
        displayName: Swift.String? = nil,
        firstName: Swift.String? = nil,
        hiddenFromGlobalAddressList: Swift.Bool? = nil,
        initials: Swift.String? = nil,
        jobTitle: Swift.String? = nil,
        lastName: Swift.String? = nil,
        office: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        role: WorkMailClientTypes.UserRole? = nil,
        street: Swift.String? = nil,
        telephone: Swift.String? = nil,
        userId: Swift.String? = nil,
        zipCode: Swift.String? = nil
    )
    {
        self.city = city
        self.company = company
        self.country = country
        self.department = department
        self.displayName = displayName
        self.firstName = firstName
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.initials = initials
        self.jobTitle = jobTitle
        self.lastName = lastName
        self.office = office
        self.organizationId = organizationId
        self.role = role
        self.street = street
        self.telephone = telephone
        self.userId = userId
        self.zipCode = zipCode
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let userId: Swift.String?
    let role: WorkMailClientTypes.UserRole?
    let displayName: Swift.String?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let hiddenFromGlobalAddressList: Swift.Bool?
    let initials: Swift.String?
    let telephone: Swift.String?
    let street: Swift.String?
    let jobTitle: Swift.String?
    let city: Swift.String?
    let company: Swift.String?
    let zipCode: Swift.String?
    let department: Swift.String?
    let country: Swift.String?
    let office: Swift.String?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city = "City"
        case company = "Company"
        case country = "Country"
        case department = "Department"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case hiddenFromGlobalAddressList = "HiddenFromGlobalAddressList"
        case initials = "Initials"
        case jobTitle = "JobTitle"
        case lastName = "LastName"
        case office = "Office"
        case organizationId = "OrganizationId"
        case role = "Role"
        case street = "Street"
        case telephone = "Telephone"
        case userId = "UserId"
        case zipCode = "ZipCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let roleDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.UserRole.self, forKey: .role)
        role = roleDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let hiddenFromGlobalAddressListDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hiddenFromGlobalAddressList)
        hiddenFromGlobalAddressList = hiddenFromGlobalAddressListDecoded
        let initialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initials)
        initials = initialsDecoded
        let telephoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .telephone)
        telephone = telephoneDecoded
        let streetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street)
        street = streetDecoded
        let jobTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobTitle)
        jobTitle = jobTitleDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let companyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .company)
        company = companyDecoded
        let zipCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zipCode)
        zipCode = zipCodeDecoded
        let departmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .department)
        department = departmentDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let officeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .office)
        office = officeDecoded
    }
}

extension UpdateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateUserOutput: Swift.Equatable {

    public init() { }
}

enum UpdateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DirectoryServiceAuthenticationFailedException": return try await DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityStateException": return try await EntityStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotFoundException": return try await OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationStateException": return try await OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkMailClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case displayName = "DisplayName"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case userRole = "UserRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = self.disabledDate {
            try encodeContainer.encodeTimestamp(disabledDate, format: .epochSeconds, forKey: .disabledDate)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enabledDate = self.enabledDate {
            try encodeContainer.encodeTimestamp(enabledDate, format: .epochSeconds, forKey: .enabledDate)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userRole = self.userRole {
            try encodeContainer.encode(userRole.rawValue, forKey: .userRole)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let userRoleDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.UserRole.self, forKey: .userRole)
        userRole = userRoleDecoded
        let enabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension WorkMailClientTypes {
    /// The representation of an WorkMail user.
    public struct User: Swift.Equatable {
        /// The date indicating when the user was disabled from WorkMail use.
        public var disabledDate: ClientRuntime.Date?
        /// The display name of the user.
        public var displayName: Swift.String?
        /// The email of the user.
        public var email: Swift.String?
        /// The date indicating when the user was enabled for WorkMail use.
        public var enabledDate: ClientRuntime.Date?
        /// The identifier of the user.
        public var id: Swift.String?
        /// The name of the user.
        public var name: Swift.String?
        /// The state of the user, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?
        /// The role of the user.
        public var userRole: WorkMailClientTypes.UserRole?

        public init(
            disabledDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            email: Swift.String? = nil,
            enabledDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil,
            userRole: WorkMailClientTypes.UserRole? = nil
        )
        {
            self.disabledDate = disabledDate
            self.displayName = displayName
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.userRole = userRole
        }
    }

}

extension WorkMailClientTypes {
    public enum UserRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case remoteUser
        case resource
        case systemUser
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [UserRole] {
            return [
                .remoteUser,
                .resource,
                .systemUser,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .remoteUser: return "REMOTE_USER"
            case .resource: return "RESOURCE"
            case .systemUser: return "SYSTEM_USER"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserRole(rawValue: rawValue) ?? UserRole.sdkUnknown(rawValue)
        }
    }
}
