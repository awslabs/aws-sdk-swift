// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension DataSyncClient {
    /// Paginate over `[ListAgentsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAgentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAgentsOutputResponse`
    public func listAgentsPaginated(input: ListAgentsInput) -> ClientRuntime.PaginatorSequence<ListAgentsInput, ListAgentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAgentsInput, ListAgentsOutputResponse>(input: input, inputKey: \ListAgentsInput.nextToken, outputKey: \ListAgentsOutputResponse.nextToken, paginationFunction: self.listAgents(input:))
    }
}

extension ListAgentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAgentsInput {
        return ListAgentsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListAgentsInput, Output == ListAgentsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listAgentsPaginated`
    /// to access the nested member `[DataSyncClientTypes.AgentListEntry]`
    /// - Returns: `[DataSyncClientTypes.AgentListEntry]`
    public func agents() async throws -> [DataSyncClientTypes.AgentListEntry] {
        return try await self.asyncCompactMap { item in item.agents }
    }
}
extension DataSyncClient {
    /// Paginate over `[ListLocationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLocationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLocationsOutputResponse`
    public func listLocationsPaginated(input: ListLocationsInput) -> ClientRuntime.PaginatorSequence<ListLocationsInput, ListLocationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLocationsInput, ListLocationsOutputResponse>(input: input, inputKey: \ListLocationsInput.nextToken, outputKey: \ListLocationsOutputResponse.nextToken, paginationFunction: self.listLocations(input:))
    }
}

extension ListLocationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLocationsInput {
        return ListLocationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListLocationsInput, Output == ListLocationsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listLocationsPaginated`
    /// to access the nested member `[DataSyncClientTypes.LocationListEntry]`
    /// - Returns: `[DataSyncClientTypes.LocationListEntry]`
    public func locations() async throws -> [DataSyncClientTypes.LocationListEntry] {
        return try await self.asyncCompactMap { item in item.locations }
    }
}
extension DataSyncClient {
    /// Paginate over `[ListTagsForResourceOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsForResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsForResourceOutputResponse`
    public func listTagsForResourcePaginated(input: ListTagsForResourceInput) -> ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutputResponse>(input: input, inputKey: \ListTagsForResourceInput.nextToken, outputKey: \ListTagsForResourceOutputResponse.nextToken, paginationFunction: self.listTagsForResource(input:))
    }
}

extension ListTagsForResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsForResourceInput {
        return ListTagsForResourceInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

extension PaginatorSequence where Input == ListTagsForResourceInput, Output == ListTagsForResourceOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listTagsForResourcePaginated`
    /// to access the nested member `[DataSyncClientTypes.TagListEntry]`
    /// - Returns: `[DataSyncClientTypes.TagListEntry]`
    public func tags() async throws -> [DataSyncClientTypes.TagListEntry] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
extension DataSyncClient {
    /// Paginate over `[ListTaskExecutionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTaskExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTaskExecutionsOutputResponse`
    public func listTaskExecutionsPaginated(input: ListTaskExecutionsInput) -> ClientRuntime.PaginatorSequence<ListTaskExecutionsInput, ListTaskExecutionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTaskExecutionsInput, ListTaskExecutionsOutputResponse>(input: input, inputKey: \ListTaskExecutionsInput.nextToken, outputKey: \ListTaskExecutionsOutputResponse.nextToken, paginationFunction: self.listTaskExecutions(input:))
    }
}

extension ListTaskExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTaskExecutionsInput {
        return ListTaskExecutionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            taskArn: self.taskArn
        )}
}

extension PaginatorSequence where Input == ListTaskExecutionsInput, Output == ListTaskExecutionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listTaskExecutionsPaginated`
    /// to access the nested member `[DataSyncClientTypes.TaskExecutionListEntry]`
    /// - Returns: `[DataSyncClientTypes.TaskExecutionListEntry]`
    public func taskExecutions() async throws -> [DataSyncClientTypes.TaskExecutionListEntry] {
        return try await self.asyncCompactMap { item in item.taskExecutions }
    }
}
extension DataSyncClient {
    /// Paginate over `[ListTasksOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTasksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTasksOutputResponse`
    public func listTasksPaginated(input: ListTasksInput) -> ClientRuntime.PaginatorSequence<ListTasksInput, ListTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTasksInput, ListTasksOutputResponse>(input: input, inputKey: \ListTasksInput.nextToken, outputKey: \ListTasksOutputResponse.nextToken, paginationFunction: self.listTasks(input:))
    }
}

extension ListTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTasksInput {
        return ListTasksInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListTasksInput, Output == ListTasksOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listTasksPaginated`
    /// to access the nested member `[DataSyncClientTypes.TaskListEntry]`
    /// - Returns: `[DataSyncClientTypes.TaskListEntry]`
    public func tasks() async throws -> [DataSyncClientTypes.TaskListEntry] {
        return try await self.asyncCompactMap { item in item.tasks }
    }
}
