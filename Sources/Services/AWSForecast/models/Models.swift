// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ForecastClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case operation = "Operation"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let operationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Operation.self, forKey: .operation)
        operation = operationDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension ForecastClientTypes {
    /// Defines the modifications that you are making to an attribute for a what-if forecast. For example, you can use this operation to create a what-if forecast that investigates a 10% off sale on all shoes. To do this, you specify "AttributeName": "shoes", "Operation": "MULTIPLY", and "Value": "0.90". Pair this operation with the [TimeSeriesCondition] operation within the [CreateWhatIfForecastRequest$TimeSeriesTransformations] operation to define a subset of attribute items that are modified.
    public struct Action: Swift.Equatable {
        /// The related time series that you are modifying. This value is case insensitive.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The operation that is applied to the provided attribute. Operations include:
        ///
        /// * ADD - adds Value to all rows of AttributeName.
        ///
        /// * SUBTRACT - subtracts Value from all rows of AttributeName.
        ///
        /// * MULTIPLY - multiplies all rows of AttributeName by Value.
        ///
        /// * DIVIDE - divides all rows of AttributeName by Value.
        /// This member is required.
        public var operation: ForecastClientTypes.Operation?
        /// The value that is applied for the chosen Operation.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            attributeName: Swift.String? = nil,
            operation: ForecastClientTypes.Operation? = nil,
            value: Swift.Double? = nil
        )
        {
            self.attributeName = attributeName
            self.operation = operation
            self.value = value
        }
    }

}

extension ForecastClientTypes.AdditionalDataset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configuration)
            for (dictKey0, configuration0) in configuration {
                var configuration0Container = configurationContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for value1 in configuration0 {
                    try configuration0Container.encode(value1)
                }
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configurationContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .configuration)
        var configurationDecoded0: [Swift.String:[Swift.String]]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, values0) in configurationContainer {
                var values0Decoded0: [Swift.String]? = nil
                if let values0 = values0 {
                    values0Decoded0 = [Swift.String]()
                    for string1 in values0 {
                        if let string1 = string1 {
                            values0Decoded0?.append(string1)
                        }
                    }
                }
                configurationDecoded0?[key0] = values0Decoded0
            }
        }
        configuration = configurationDecoded0
    }
}

extension ForecastClientTypes {
    /// Describes an additional dataset. This object is part of the [DataConfig] object. Forecast supports the Weather Index and Holidays additional datasets. Weather Index The Amazon Forecast Weather Index is a built-in dataset that incorporates historical and projected weather information into your model. The Weather Index supplements your datasets with over two years of historical weather data and up to 14 days of projected weather data. For more information, see [Amazon Forecast Weather Index](https://docs.aws.amazon.com/forecast/latest/dg/weather.html). Holidays Holidays is a built-in dataset that incorporates national holiday information into your model. It provides native support for the holiday calendars of 66 countries. To view the holiday calendars, refer to the [Jollyday](http://jollyday.sourceforge.net/data.html) library. For more information, see [Holidays Featurization](https://docs.aws.amazon.com/forecast/latest/dg/holidays.html).
    public struct AdditionalDataset: Swift.Equatable {
        /// Weather Index To enable the Weather Index, do not specify a value for Configuration. Holidays Holidays To enable Holidays, set CountryCode to one of the following two-letter country codes:
        ///
        /// * "AL" - ALBANIA
        ///
        /// * "AR" - ARGENTINA
        ///
        /// * "AT" - AUSTRIA
        ///
        /// * "AU" - AUSTRALIA
        ///
        /// * "BA" - BOSNIA HERZEGOVINA
        ///
        /// * "BE" - BELGIUM
        ///
        /// * "BG" - BULGARIA
        ///
        /// * "BO" - BOLIVIA
        ///
        /// * "BR" - BRAZIL
        ///
        /// * "BY" - BELARUS
        ///
        /// * "CA" - CANADA
        ///
        /// * "CL" - CHILE
        ///
        /// * "CO" - COLOMBIA
        ///
        /// * "CR" - COSTA RICA
        ///
        /// * "HR" - CROATIA
        ///
        /// * "CZ" - CZECH REPUBLIC
        ///
        /// * "DK" - DENMARK
        ///
        /// * "EC" - ECUADOR
        ///
        /// * "EE" - ESTONIA
        ///
        /// * "ET" - ETHIOPIA
        ///
        /// * "FI" - FINLAND
        ///
        /// * "FR" - FRANCE
        ///
        /// * "DE" - GERMANY
        ///
        /// * "GR" - GREECE
        ///
        /// * "HU" - HUNGARY
        ///
        /// * "IS" - ICELAND
        ///
        /// * "IN" - INDIA
        ///
        /// * "IE" - IRELAND
        ///
        /// * "IT" - ITALY
        ///
        /// * "JP" - JAPAN
        ///
        /// * "KZ" - KAZAKHSTAN
        ///
        /// * "KR" - KOREA
        ///
        /// * "LV" - LATVIA
        ///
        /// * "LI" - LIECHTENSTEIN
        ///
        /// * "LT" - LITHUANIA
        ///
        /// * "LU" - LUXEMBOURG
        ///
        /// * "MK" - MACEDONIA
        ///
        /// * "MT" - MALTA
        ///
        /// * "MX" - MEXICO
        ///
        /// * "MD" - MOLDOVA
        ///
        /// * "ME" - MONTENEGRO
        ///
        /// * "NL" - NETHERLANDS
        ///
        /// * "NZ" - NEW ZEALAND
        ///
        /// * "NI" - NICARAGUA
        ///
        /// * "NG" - NIGERIA
        ///
        /// * "NO" - NORWAY
        ///
        /// * "PA" - PANAMA
        ///
        /// * "PY" - PARAGUAY
        ///
        /// * "PE" - PERU
        ///
        /// * "PL" - POLAND
        ///
        /// * "PT" - PORTUGAL
        ///
        /// * "RO" - ROMANIA
        ///
        /// * "RU" - RUSSIA
        ///
        /// * "RS" - SERBIA
        ///
        /// * "SK" - SLOVAKIA
        ///
        /// * "SI" - SLOVENIA
        ///
        /// * "ZA" - SOUTH AFRICA
        ///
        /// * "ES" - SPAIN
        ///
        /// * "SE" - SWEDEN
        ///
        /// * "CH" - SWITZERLAND
        ///
        /// * "UA" - UKRAINE
        ///
        /// * "AE" - UNITED ARAB EMIRATES
        ///
        /// * "US" - UNITED STATES
        ///
        /// * "UK" - UNITED KINGDOM
        ///
        /// * "UY" - URUGUAY
        ///
        /// * "VE" - VENEZUELA
        public var configuration: [Swift.String:[Swift.String]]?
        /// The name of the additional dataset. Valid names: "holiday" and "weather".
        /// This member is required.
        public var name: Swift.String?

        public init(
            configuration: [Swift.String:[Swift.String]]? = nil,
            name: Swift.String? = nil
        )
        {
            self.configuration = configuration
            self.name = name
        }
    }

}

extension ForecastClientTypes.AttributeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case transformations = "Transformations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let transformations = transformations {
            var transformationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .transformations)
            for (dictKey0, transformations0) in transformations {
                try transformationsContainer.encode(transformations0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let transformationsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .transformations)
        var transformationsDecoded0: [Swift.String:Swift.String]? = nil
        if let transformationsContainer = transformationsContainer {
            transformationsDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in transformationsContainer {
                if let value0 = value0 {
                    transformationsDecoded0?[key0] = value0
                }
            }
        }
        transformations = transformationsDecoded0
    }
}

extension ForecastClientTypes {
    /// Provides information about the method used to transform attributes. The following is an example using the RETAIL domain: {
    ///     "AttributeName": "demand",
    ///
    ///
    ///     "Transformations": {"aggregation": "sum", "middlefill": "zero", "backfill": "zero"}
    ///
    ///
    ///     }
    public struct AttributeConfig: Swift.Equatable {
        /// The name of the attribute as specified in the schema. Amazon Forecast supports the target field of the target time series and the related time series datasets. For example, for the RETAIL domain, the target is demand.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters. The following list shows the parameters and their valid values for the "filling" featurization method for a Target Time Series dataset. Default values are bolded.
        ///
        /// * aggregation: sum, avg, first, min, max
        ///
        /// * frontfill: none
        ///
        /// * middlefill: zero, nan (not a number), value, median, mean, min, max
        ///
        /// * backfill: zero, nan, value, median, mean, min, max
        ///
        ///
        /// The following list shows the parameters and their valid values for a Related Time Series featurization method (there are no defaults):
        ///
        /// * middlefill: zero, value, median, mean, min, max
        ///
        /// * backfill: zero, value, median, mean, min, max
        ///
        /// * futurefill: zero, value, median, mean, min, max
        ///
        ///
        /// To set a filling method to a specific value, set the fill parameter to value and define the value in a corresponding _value parameter. For example, to set backfilling to a value of 2, include the following: "backfill": "value" and "backfill_value":"2".
        /// This member is required.
        public var transformations: [Swift.String:Swift.String]?

        public init(
            attributeName: Swift.String? = nil,
            transformations: [Swift.String:Swift.String]? = nil
        )
        {
            self.attributeName = attributeName
            self.transformations = transformations
        }
    }

}

extension ForecastClientTypes {
    public enum AttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case float
        case geolocation
        case integer
        case string
        case timestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeType] {
            return [
                .float,
                .geolocation,
                .integer,
                .string,
                .timestamp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .float: return "float"
            case .geolocation: return "geolocation"
            case .integer: return "integer"
            case .string: return "string"
            case .timestamp: return "timestamp"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttributeType(rawValue: rawValue) ?? AttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes {
    public enum AutoMLOverrideStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accuracyoptimized
        case latencyoptimized
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoMLOverrideStrategy] {
            return [
                .accuracyoptimized,
                .latencyoptimized,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accuracyoptimized: return "AccuracyOptimized"
            case .latencyoptimized: return "LatencyOptimized"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoMLOverrideStrategy(rawValue: rawValue) ?? AutoMLOverrideStrategy.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.Baseline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBaseline = "PredictorBaseline"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorBaseline = self.predictorBaseline {
            try encodeContainer.encode(predictorBaseline, forKey: .predictorBaseline)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBaselineDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.PredictorBaseline.self, forKey: .predictorBaseline)
        predictorBaseline = predictorBaselineDecoded
    }
}

extension ForecastClientTypes {
    /// Metrics you can use as a baseline for comparison purposes. Use these metrics when you interpret monitoring results for an auto predictor.
    public struct Baseline: Swift.Equatable {
        /// The initial [accuracy metrics](https://docs.aws.amazon.com/forecast/latest/dg/metrics.html) for the predictor you are monitoring. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.
        public var predictorBaseline: ForecastClientTypes.PredictorBaseline?

        public init(
            predictorBaseline: ForecastClientTypes.PredictorBaseline? = nil
        )
        {
            self.predictorBaseline = predictorBaseline
        }
    }

}

extension ForecastClientTypes.BaselineMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension ForecastClientTypes {
    /// An individual metric that you can use for comparison as you evaluate your monitoring results.
    public struct BaselineMetric: Swift.Equatable {
        /// The name of the metric.
        public var name: Swift.String?
        /// The value for the metric.
        public var value: Swift.Double?

        public init(
            name: Swift.String? = nil,
            value: Swift.Double? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ForecastClientTypes.CategoricalParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for value0 in values {
                try valuesContainer.encode(value0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ForecastClientTypes {
    /// Specifies a categorical hyperparameter and it's range of tunable values. This object is part of the [ParameterRanges] object.
    public struct CategoricalParameterRange: Swift.Equatable {
        /// The name of the categorical hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// A list of the tunable categories for the hyperparameter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension ForecastClientTypes {
    public enum Condition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case greaterThan
        case lessThan
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [Condition] {
            return [
                .equals,
                .greaterThan,
                .lessThan,
                .notEquals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Condition(rawValue: rawValue) ?? Condition.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.ContinuousParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxValue = "MaxValue"
        case minValue = "MinValue"
        case name = "Name"
        case scalingType = "ScalingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxValue = self.maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minValue = self.minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scalingType = self.scalingType {
            try encodeContainer.encode(scalingType.rawValue, forKey: .scalingType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minValue)
        minValue = minValueDecoded
        let scalingTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ScalingType.self, forKey: .scalingType)
        scalingType = scalingTypeDecoded
    }
}

extension ForecastClientTypes {
    /// Specifies a continuous hyperparameter and it's range of tunable values. This object is part of the [ParameterRanges] object.
    public struct ContinuousParameterRange: Swift.Equatable {
        /// The maximum tunable value of the hyperparameter.
        /// This member is required.
        public var maxValue: Swift.Double?
        /// The minimum tunable value of the hyperparameter.
        /// This member is required.
        public var minValue: Swift.Double?
        /// The name of the hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values: Auto Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter. Linear Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale. Logarithmic Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have values greater than 0. ReverseLogarithmic hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale. Reverse logarithmic scaling works only for ranges that are entirely within the range 0 <= x < 1.0. For information about choosing a hyperparameter scale, see [Hyperparameter Scaling](http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type). One of the following values:
        public var scalingType: ForecastClientTypes.ScalingType?

        public init(
            maxValue: Swift.Double? = nil,
            minValue: Swift.Double? = nil,
            name: Swift.String? = nil,
            scalingType: ForecastClientTypes.ScalingType? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }
    }

}

extension CreateAutoPredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataConfig = "DataConfig"
        case encryptionConfig = "EncryptionConfig"
        case explainPredictor = "ExplainPredictor"
        case forecastDimensions = "ForecastDimensions"
        case forecastFrequency = "ForecastFrequency"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case monitorConfig = "MonitorConfig"
        case optimizationMetric = "OptimizationMetric"
        case predictorName = "PredictorName"
        case referencePredictorArn = "ReferencePredictorArn"
        case tags = "Tags"
        case timeAlignmentBoundary = "TimeAlignmentBoundary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataConfig = self.dataConfig {
            try encodeContainer.encode(dataConfig, forKey: .dataConfig)
        }
        if let encryptionConfig = self.encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let explainPredictor = self.explainPredictor {
            try encodeContainer.encode(explainPredictor, forKey: .explainPredictor)
        }
        if let forecastDimensions = forecastDimensions {
            var forecastDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastDimensions)
            for name0 in forecastDimensions {
                try forecastDimensionsContainer.encode(name0)
            }
        }
        if let forecastFrequency = self.forecastFrequency {
            try encodeContainer.encode(forecastFrequency, forKey: .forecastFrequency)
        }
        if let forecastHorizon = self.forecastHorizon {
            try encodeContainer.encode(forecastHorizon, forKey: .forecastHorizon)
        }
        if let forecastTypes = forecastTypes {
            var forecastTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastTypes)
            for forecasttype0 in forecastTypes {
                try forecastTypesContainer.encode(forecasttype0)
            }
        }
        if let monitorConfig = self.monitorConfig {
            try encodeContainer.encode(monitorConfig, forKey: .monitorConfig)
        }
        if let optimizationMetric = self.optimizationMetric {
            try encodeContainer.encode(optimizationMetric.rawValue, forKey: .optimizationMetric)
        }
        if let predictorName = self.predictorName {
            try encodeContainer.encode(predictorName, forKey: .predictorName)
        }
        if let referencePredictorArn = self.referencePredictorArn {
            try encodeContainer.encode(referencePredictorArn, forKey: .referencePredictorArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeAlignmentBoundary = self.timeAlignmentBoundary {
            try encodeContainer.encode(timeAlignmentBoundary, forKey: .timeAlignmentBoundary)
        }
    }
}

extension CreateAutoPredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAutoPredictorInput: Swift.Equatable {
    /// The data configuration for your dataset group and any additional datasets.
    public var dataConfig: ForecastClientTypes.DataConfig?
    /// An Key Management Service (KMS) key and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key. You can specify this optional object in the [CreateDataset] and [CreatePredictor] requests.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// Create an Explainability resource for the predictor.
    public var explainPredictor: Swift.Bool?
    /// An array of dimension (field) names that specify how to group the generated forecast. For example, if you are generating forecasts for item sales across all your stores, and your dataset contains a store_id field, you would specify store_id as a dimension to group sales forecasts for each store.
    public var forecastDimensions: [Swift.String]?
    /// The frequency of predictions in a forecast. Valid intervals are an integer followed by Y (Year), M (Month), W (Week), D (Day), H (Hour), and min (Minute). For example, "1D" indicates every day and "15min" indicates every 15 minutes. You cannot specify a value that would overlap with the next larger frequency. That means, for example, you cannot specify a frequency of 60 minutes, because that is equivalent to 1 hour. The valid values for each frequency are the following:
    ///
    /// * Minute - 1-59
    ///
    /// * Hour - 1-23
    ///
    /// * Day - 1-6
    ///
    /// * Week - 1-4
    ///
    /// * Month - 1-11
    ///
    /// * Year - 1
    ///
    ///
    /// Thus, if you want every other week forecasts, specify "2W". Or, if you want quarterly forecasts, you specify "3M". The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency. When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the RELATED_TIME_SERIES dataset frequency.
    public var forecastFrequency: Swift.String?
    /// The number of time-steps that the model predicts. The forecast horizon is also called the prediction length. The maximum forecast horizon is the lesser of 500 time-steps or 1/4 of the TARGET_TIME_SERIES dataset length. If you are retraining an existing AutoPredictor, then the maximum forecast horizon is the lesser of 500 time-steps or 1/3 of the TARGET_TIME_SERIES dataset length. If you are upgrading to an AutoPredictor or retraining an existing AutoPredictor, you cannot update the forecast horizon parameter. You can meet this requirement by providing longer time-series in the dataset.
    public var forecastHorizon: Swift.Int?
    /// The forecast types used to train a predictor. You can specify up to five forecast types. Forecast types can be quantiles from 0.01 to 0.99, by increments of 0.01 or higher. You can also specify the mean forecast with mean.
    public var forecastTypes: [Swift.String]?
    /// The configuration details for predictor monitoring. Provide a name for the monitor resource to enable predictor monitoring. Predictor monitoring allows you to see how your predictor's performance changes over time. For more information, see [Predictor Monitoring](https://docs.aws.amazon.com/forecast/latest/dg/predictor-monitoring.html).
    public var monitorConfig: ForecastClientTypes.MonitorConfig?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// A unique name for the predictor
    /// This member is required.
    public var predictorName: Swift.String?
    /// The ARN of the predictor to retrain or upgrade. This parameter is only used when retraining or upgrading a predictor. When creating a new predictor, do not specify a value for this parameter. When upgrading or retraining a predictor, only specify values for the ReferencePredictorArn and PredictorName. The value for PredictorName must be a unique predictor name.
    public var referencePredictorArn: Swift.String?
    /// Optional metadata to help you categorize and organize your predictors. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?
    /// The time boundary Forecast uses to align and aggregate any data that doesn't align with your forecast frequency. Provide the unit of time and the time boundary as a key value pair. For more information on specifying a time boundary, see [Specifying a Time Boundary](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html#specifying-time-boundary). If you don't provide a time boundary, Forecast uses a set of [Default Time Boundaries](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html#default-time-boundaries).
    public var timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary?

    public init(
        dataConfig: ForecastClientTypes.DataConfig? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        explainPredictor: Swift.Bool? = nil,
        forecastDimensions: [Swift.String]? = nil,
        forecastFrequency: Swift.String? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        monitorConfig: ForecastClientTypes.MonitorConfig? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        predictorName: Swift.String? = nil,
        referencePredictorArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary? = nil
    )
    {
        self.dataConfig = dataConfig
        self.encryptionConfig = encryptionConfig
        self.explainPredictor = explainPredictor
        self.forecastDimensions = forecastDimensions
        self.forecastFrequency = forecastFrequency
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.monitorConfig = monitorConfig
        self.optimizationMetric = optimizationMetric
        self.predictorName = predictorName
        self.referencePredictorArn = referencePredictorArn
        self.tags = tags
        self.timeAlignmentBoundary = timeAlignmentBoundary
    }
}

struct CreateAutoPredictorInputBody: Swift.Equatable {
    let predictorName: Swift.String?
    let forecastHorizon: Swift.Int?
    let forecastTypes: [Swift.String]?
    let forecastDimensions: [Swift.String]?
    let forecastFrequency: Swift.String?
    let dataConfig: ForecastClientTypes.DataConfig?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let referencePredictorArn: Swift.String?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
    let explainPredictor: Swift.Bool?
    let tags: [ForecastClientTypes.Tag]?
    let monitorConfig: ForecastClientTypes.MonitorConfig?
    let timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary?
}

extension CreateAutoPredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataConfig = "DataConfig"
        case encryptionConfig = "EncryptionConfig"
        case explainPredictor = "ExplainPredictor"
        case forecastDimensions = "ForecastDimensions"
        case forecastFrequency = "ForecastFrequency"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case monitorConfig = "MonitorConfig"
        case optimizationMetric = "OptimizationMetric"
        case predictorName = "PredictorName"
        case referencePredictorArn = "ReferencePredictorArn"
        case tags = "Tags"
        case timeAlignmentBoundary = "TimeAlignmentBoundary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let forecastDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastDimensions)
        var forecastDimensionsDecoded0:[Swift.String]? = nil
        if let forecastDimensionsContainer = forecastDimensionsContainer {
            forecastDimensionsDecoded0 = [Swift.String]()
            for string0 in forecastDimensionsContainer {
                if let string0 = string0 {
                    forecastDimensionsDecoded0?.append(string0)
                }
            }
        }
        forecastDimensions = forecastDimensionsDecoded0
        let forecastFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastFrequency)
        forecastFrequency = forecastFrequencyDecoded
        let dataConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataConfig.self, forKey: .dataConfig)
        dataConfig = dataConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let referencePredictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referencePredictorArn)
        referencePredictorArn = referencePredictorArnDecoded
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
        let explainPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .explainPredictor)
        explainPredictor = explainPredictorDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let monitorConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.MonitorConfig.self, forKey: .monitorConfig)
        monitorConfig = monitorConfigDecoded
        let timeAlignmentBoundaryDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeAlignmentBoundary.self, forKey: .timeAlignmentBoundary)
        timeAlignmentBoundary = timeAlignmentBoundaryDecoded
    }
}

extension CreateAutoPredictorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAutoPredictorOutputBody = try responseDecoder.decode(responseBody: data)
            self.predictorArn = output.predictorArn
        } else {
            self.predictorArn = nil
        }
    }
}

public struct CreateAutoPredictorOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor.
    public var predictorArn: Swift.String?

    public init(
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct CreateAutoPredictorOutputBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension CreateAutoPredictorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

enum CreateAutoPredictorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArns = datasetArns {
            var datasetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasetArns)
            for arn0 in datasetArns {
                try datasetArnsContainer.encode(arn0)
            }
        }
        if let datasetGroupName = self.datasetGroupName {
            try encodeContainer.encode(datasetGroupName, forKey: .datasetGroupName)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetGroupInput: Swift.Equatable {
    /// An array of Amazon Resource Names (ARNs) of the datasets that you want to include in the dataset group.
    public var datasetArns: [Swift.String]?
    /// A name for the dataset group.
    /// This member is required.
    public var datasetGroupName: Swift.String?
    /// The domain associated with the dataset group. When you add a dataset to a dataset group, this value and the value specified for the Domain parameter of the [CreateDataset](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDataset.html) operation must match. The Domain and DatasetType that you choose determine the fields that must be present in training data that you import to a dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires that item_id, timestamp, and demand fields are present in your data. For more information, see [Dataset groups](https://docs.aws.amazon.com/forecast/latest/dg/howitworks-datasets-groups.html).
    /// This member is required.
    public var domain: ForecastClientTypes.Domain?
    /// The optional metadata that you apply to the dataset group to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        datasetArns: [Swift.String]? = nil,
        datasetGroupName: Swift.String? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.datasetArns = datasetArns
        self.datasetGroupName = datasetGroupName
        self.domain = domain
        self.tags = tags
    }
}

struct CreateDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupName: Swift.String?
    let domain: ForecastClientTypes.Domain?
    let datasetArns: [Swift.String]?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[Swift.String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [Swift.String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDatasetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroupArn = output.datasetGroupArn
        } else {
            self.datasetGroupArn = nil
        }
    }
}

public struct CreateDatasetGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group.
    public var datasetGroupArn: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct CreateDatasetGroupOutputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
}

extension CreateDatasetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

enum CreateDatasetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDatasetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobName = "DatasetImportJobName"
        case format = "Format"
        case geolocationFormat = "GeolocationFormat"
        case importMode = "ImportMode"
        case tags = "Tags"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetImportJobName = self.datasetImportJobName {
            try encodeContainer.encode(datasetImportJobName, forKey: .datasetImportJobName)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let geolocationFormat = self.geolocationFormat {
            try encodeContainer.encode(geolocationFormat, forKey: .geolocationFormat)
        }
        if let importMode = self.importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeZone = self.timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
        if let timestampFormat = self.timestampFormat {
            try encodeContainer.encode(timestampFormat, forKey: .timestampFormat)
        }
        if let useGeolocationForTimeZone = self.useGeolocationForTimeZone {
            try encodeContainer.encode(useGeolocationForTimeZone, forKey: .useGeolocationForTimeZone)
        }
    }
}

extension CreateDatasetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetImportJobInput: Swift.Equatable {
    /// The location of the training data to import and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket. If encryption is used, DataSource must include an Key Management Service (KMS) key and the IAM role must allow Amazon Forecast permission to access the key. The KMS key and IAM role must match those specified in the EncryptionConfig parameter of the [CreateDataset](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDataset.html) operation.
    /// This member is required.
    public var dataSource: ForecastClientTypes.DataSource?
    /// The Amazon Resource Name (ARN) of the Amazon Forecast dataset that you want to import data to.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// The name for the dataset import job. We recommend including the current timestamp in the name, for example, 20190721DatasetImport. This can help you avoid getting a ResourceAlreadyExistsException exception.
    /// This member is required.
    public var datasetImportJobName: Swift.String?
    /// The format of the imported data, CSV or PARQUET. The default value is CSV.
    public var format: Swift.String?
    /// The format of the geolocation attribute. The geolocation attribute can be formatted in one of two ways:
    ///
    /// * LAT_LONG - the latitude and longitude in decimal format (Example: 47.61_-122.33).
    ///
    /// * CC_POSTALCODE (US Only) - the country code (US), followed by the 5-digit ZIP code (Example: US_98121).
    public var geolocationFormat: Swift.String?
    /// Specifies whether the dataset import job is a FULL or INCREMENTAL import. A FULL dataset import replaces all of the existing data with the newly imported data. An INCREMENTAL import appends the imported data to the existing data.
    public var importMode: ForecastClientTypes.ImportMode?
    /// The optional metadata that you apply to the dataset import job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?
    /// A single time zone for every item in your dataset. This option is ideal for datasets with all timestamps within a single time zone, or if all timestamps are normalized to a single time zone. Refer to the [Joda-Time API](http://joda-time.sourceforge.net/timezones.html) for a complete list of valid time zone names.
    public var timeZone: Swift.String?
    /// The format of timestamps in the dataset. The format that you specify depends on the DataFrequency specified when the dataset was created. The following formats are supported
    ///
    /// * "yyyy-MM-dd" For the following data frequencies: Y, M, W, and D
    ///
    /// * "yyyy-MM-dd HH:mm:ss" For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y, M, W, and D
    ///
    ///
    /// If the format isn't specified, Amazon Forecast expects the format to be "yyyy-MM-dd HH:mm:ss".
    public var timestampFormat: Swift.String?
    /// Automatically derive time zone information from the geolocation attribute. This option is ideal for datasets that contain timestamps in multiple time zones and those timestamps are expressed in local time.
    public var useGeolocationForTimeZone: Swift.Bool?

    public init(
        dataSource: ForecastClientTypes.DataSource? = nil,
        datasetArn: Swift.String? = nil,
        datasetImportJobName: Swift.String? = nil,
        format: Swift.String? = nil,
        geolocationFormat: Swift.String? = nil,
        importMode: ForecastClientTypes.ImportMode? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        timeZone: Swift.String? = nil,
        timestampFormat: Swift.String? = nil,
        useGeolocationForTimeZone: Swift.Bool? = nil
    )
    {
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.datasetImportJobName = datasetImportJobName
        self.format = format
        self.geolocationFormat = geolocationFormat
        self.importMode = importMode
        self.tags = tags
        self.timeZone = timeZone
        self.timestampFormat = timestampFormat
        self.useGeolocationForTimeZone = useGeolocationForTimeZone
    }
}

struct CreateDatasetImportJobInputBody: Swift.Equatable {
    let datasetImportJobName: Swift.String?
    let datasetArn: Swift.String?
    let dataSource: ForecastClientTypes.DataSource?
    let timestampFormat: Swift.String?
    let timeZone: Swift.String?
    let useGeolocationForTimeZone: Swift.Bool?
    let geolocationFormat: Swift.String?
    let tags: [ForecastClientTypes.Tag]?
    let format: Swift.String?
    let importMode: ForecastClientTypes.ImportMode?
}

extension CreateDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobName = "DatasetImportJobName"
        case format = "Format"
        case geolocationFormat = "GeolocationFormat"
        case importMode = "ImportMode"
        case tags = "Tags"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let timestampFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampFormat)
        timestampFormat = timestampFormatDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let useGeolocationForTimeZoneDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useGeolocationForTimeZone)
        useGeolocationForTimeZone = useGeolocationForTimeZoneDecoded
        let geolocationFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geolocationFormat)
        geolocationFormat = geolocationFormatDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let importModeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
    }
}

extension CreateDatasetImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDatasetImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJobArn = output.datasetImportJobArn
        } else {
            self.datasetImportJobArn = nil
        }
    }
}

public struct CreateDatasetImportJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job.
    public var datasetImportJobArn: Swift.String?

    public init(
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct CreateDatasetImportJobOutputBody: Swift.Equatable {
    let datasetImportJobArn: Swift.String?
}

extension CreateDatasetImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

enum CreateDatasetImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataFrequency = "DataFrequency"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case schema = "Schema"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataFrequency = self.dataFrequency {
            try encodeContainer.encode(dataFrequency, forKey: .dataFrequency)
        }
        if let datasetName = self.datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let datasetType = self.datasetType {
            try encodeContainer.encode(datasetType.rawValue, forKey: .datasetType)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let encryptionConfig = self.encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetInput: Swift.Equatable {
    /// The frequency of data collection. This parameter is required for RELATED_TIME_SERIES datasets. Valid intervals are an integer followed by Y (Year), M (Month), W (Week), D (Day), H (Hour), and min (Minute). For example, "1D" indicates every day and "15min" indicates every 15 minutes. You cannot specify a value that would overlap with the next larger frequency. That means, for example, you cannot specify a frequency of 60 minutes, because that is equivalent to 1 hour. The valid values for each frequency are the following:
    ///
    /// * Minute - 1-59
    ///
    /// * Hour - 1-23
    ///
    /// * Day - 1-6
    ///
    /// * Week - 1-4
    ///
    /// * Month - 1-11
    ///
    /// * Year - 1
    ///
    ///
    /// Thus, if you want every other week forecasts, specify "2W". Or, if you want quarterly forecasts, you specify "3M".
    public var dataFrequency: Swift.String?
    /// A name for the dataset.
    /// This member is required.
    public var datasetName: Swift.String?
    /// The dataset type. Valid values depend on the chosen Domain.
    /// This member is required.
    public var datasetType: ForecastClientTypes.DatasetType?
    /// The domain associated with the dataset. When you add a dataset to a dataset group, this value and the value specified for the Domain parameter of the [CreateDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetGroup.html) operation must match. The Domain and DatasetType that you choose determine the fields that must be present in the training data that you import to the dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires item_id, timestamp, and demand fields to be present in your data. For more information, see [Importing datasets](https://docs.aws.amazon.com/forecast/latest/dg/howitworks-datasets-groups.html).
    /// This member is required.
    public var domain: ForecastClientTypes.Domain?
    /// An Key Management Service (KMS) key and the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// The schema for the dataset. The schema attributes and their order must match the fields in your data. The dataset Domain and DatasetType that you choose determine the minimum required fields in your training data. For information about the required fields for a specific dataset domain and type, see [Dataset Domains and Dataset Types](https://docs.aws.amazon.com/forecast/latest/dg/howitworks-domains-ds-types.html).
    /// This member is required.
    public var schema: ForecastClientTypes.Schema?
    /// The optional metadata that you apply to the dataset to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        dataFrequency: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        datasetType: ForecastClientTypes.DatasetType? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.dataFrequency = dataFrequency
        self.datasetName = datasetName
        self.datasetType = datasetType
        self.domain = domain
        self.encryptionConfig = encryptionConfig
        self.schema = schema
        self.tags = tags
    }
}

struct CreateDatasetInputBody: Swift.Equatable {
    let datasetName: Swift.String?
    let domain: ForecastClientTypes.Domain?
    let datasetType: ForecastClientTypes.DatasetType?
    let dataFrequency: Swift.String?
    let schema: ForecastClientTypes.Schema?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataFrequency = "DataFrequency"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case schema = "Schema"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let dataFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataFrequency)
        dataFrequency = dataFrequencyDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetArn = output.datasetArn
        } else {
            self.datasetArn = nil
        }
    }
}

public struct CreateDatasetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var datasetArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct CreateDatasetOutputBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension CreateDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

enum CreateDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateExplainabilityExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityExportName = "ExplainabilityExportName"
        case format = "Format"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let explainabilityArn = self.explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
        if let explainabilityExportName = self.explainabilityExportName {
            try encodeContainer.encode(explainabilityExportName, forKey: .explainabilityExportName)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateExplainabilityExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateExplainabilityExportInput: Swift.Equatable {
    /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the Explainability to export.
    /// This member is required.
    public var explainabilityArn: Swift.String?
    /// A unique name for the Explainability export.
    /// This member is required.
    public var explainabilityExportName: Swift.String?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// Optional metadata to help you categorize and organize your resources. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        destination: ForecastClientTypes.DataDestination? = nil,
        explainabilityArn: Swift.String? = nil,
        explainabilityExportName: Swift.String? = nil,
        format: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.destination = destination
        self.explainabilityArn = explainabilityArn
        self.explainabilityExportName = explainabilityExportName
        self.format = format
        self.tags = tags
    }
}

struct CreateExplainabilityExportInputBody: Swift.Equatable {
    let explainabilityExportName: Swift.String?
    let explainabilityArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let tags: [ForecastClientTypes.Tag]?
    let format: Swift.String?
}

extension CreateExplainabilityExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityExportName = "ExplainabilityExportName"
        case format = "Format"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportName)
        explainabilityExportName = explainabilityExportNameDecoded
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension CreateExplainabilityExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateExplainabilityExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.explainabilityExportArn = output.explainabilityExportArn
        } else {
            self.explainabilityExportArn = nil
        }
    }
}

public struct CreateExplainabilityExportOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the export.
    public var explainabilityExportArn: Swift.String?

    public init(
        explainabilityExportArn: Swift.String? = nil
    )
    {
        self.explainabilityExportArn = explainabilityExportArn
    }
}

struct CreateExplainabilityExportOutputBody: Swift.Equatable {
    let explainabilityExportArn: Swift.String?
}

extension CreateExplainabilityExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
    }
}

enum CreateExplainabilityExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateExplainabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case enableVisualization = "EnableVisualization"
        case endDateTime = "EndDateTime"
        case explainabilityConfig = "ExplainabilityConfig"
        case explainabilityName = "ExplainabilityName"
        case resourceArn = "ResourceArn"
        case schema = "Schema"
        case startDateTime = "StartDateTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let enableVisualization = self.enableVisualization {
            try encodeContainer.encode(enableVisualization, forKey: .enableVisualization)
        }
        if let endDateTime = self.endDateTime {
            try encodeContainer.encode(endDateTime, forKey: .endDateTime)
        }
        if let explainabilityConfig = self.explainabilityConfig {
            try encodeContainer.encode(explainabilityConfig, forKey: .explainabilityConfig)
        }
        if let explainabilityName = self.explainabilityName {
            try encodeContainer.encode(explainabilityName, forKey: .explainabilityName)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encode(startDateTime, forKey: .startDateTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateExplainabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateExplainabilityInput: Swift.Equatable {
    /// The source of your data, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an Key Management Service (KMS) key.
    public var dataSource: ForecastClientTypes.DataSource?
    /// Create an Explainability visualization that is viewable within the Amazon Web Services console.
    public var enableVisualization: Swift.Bool?
    /// If TimePointGranularity is set to SPECIFIC, define the last time point for the Explainability. Use the following timestamp format: yyyy-MM-ddTHH:mm:ss (example: 2015-01-01T20:00:00)
    public var endDateTime: Swift.String?
    /// The configuration settings that define the granularity of time series and time points for the Explainability.
    /// This member is required.
    public var explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
    /// A unique name for the Explainability.
    /// This member is required.
    public var explainabilityName: Swift.String?
    /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Defines the fields of a dataset.
    public var schema: ForecastClientTypes.Schema?
    /// If TimePointGranularity is set to SPECIFIC, define the first point for the Explainability. Use the following timestamp format: yyyy-MM-ddTHH:mm:ss (example: 2015-01-01T20:00:00)
    public var startDateTime: Swift.String?
    /// Optional metadata to help you categorize and organize your resources. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        dataSource: ForecastClientTypes.DataSource? = nil,
        enableVisualization: Swift.Bool? = nil,
        endDateTime: Swift.String? = nil,
        explainabilityConfig: ForecastClientTypes.ExplainabilityConfig? = nil,
        explainabilityName: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        startDateTime: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.dataSource = dataSource
        self.enableVisualization = enableVisualization
        self.endDateTime = endDateTime
        self.explainabilityConfig = explainabilityConfig
        self.explainabilityName = explainabilityName
        self.resourceArn = resourceArn
        self.schema = schema
        self.startDateTime = startDateTime
        self.tags = tags
    }
}

struct CreateExplainabilityInputBody: Swift.Equatable {
    let explainabilityName: Swift.String?
    let resourceArn: Swift.String?
    let explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
    let dataSource: ForecastClientTypes.DataSource?
    let schema: ForecastClientTypes.Schema?
    let enableVisualization: Swift.Bool?
    let startDateTime: Swift.String?
    let endDateTime: Swift.String?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateExplainabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case enableVisualization = "EnableVisualization"
        case endDateTime = "EndDateTime"
        case explainabilityConfig = "ExplainabilityConfig"
        case explainabilityName = "ExplainabilityName"
        case resourceArn = "ResourceArn"
        case schema = "Schema"
        case startDateTime = "StartDateTime"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityName)
        explainabilityName = explainabilityNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let explainabilityConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ExplainabilityConfig.self, forKey: .explainabilityConfig)
        explainabilityConfig = explainabilityConfigDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let enableVisualizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableVisualization)
        enableVisualization = enableVisualizationDecoded
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateExplainabilityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateExplainabilityOutputBody = try responseDecoder.decode(responseBody: data)
            self.explainabilityArn = output.explainabilityArn
        } else {
            self.explainabilityArn = nil
        }
    }
}

public struct CreateExplainabilityOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explainability.
    public var explainabilityArn: Swift.String?

    public init(
        explainabilityArn: Swift.String? = nil
    )
    {
        self.explainabilityArn = explainabilityArn
    }
}

struct CreateExplainabilityOutputBody: Swift.Equatable {
    let explainabilityArn: Swift.String?
}

extension CreateExplainabilityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
    }
}

enum CreateExplainabilityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateForecastExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobName = "ForecastExportJobName"
        case format = "Format"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let forecastArn = self.forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let forecastExportJobName = self.forecastExportJobName {
            try encodeContainer.encode(forecastExportJobName, forKey: .forecastExportJobName)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateForecastExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateForecastExportJobInput: Swift.Equatable {
    /// The location where you want to save the forecast and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the location. The forecast must be exported to an Amazon S3 bucket. If encryption is used, Destination must include an Key Management Service (KMS) key. The IAM role must allow Amazon Forecast permission to access the key.
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the forecast that you want to export.
    /// This member is required.
    public var forecastArn: Swift.String?
    /// The name for the forecast export job.
    /// This member is required.
    public var forecastExportJobName: Swift.String?
    /// The format of the exported data, CSV or PARQUET. The default value is CSV.
    public var format: Swift.String?
    /// The optional metadata that you apply to the forecast export job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        destination: ForecastClientTypes.DataDestination? = nil,
        forecastArn: Swift.String? = nil,
        forecastExportJobName: Swift.String? = nil,
        format: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.destination = destination
        self.forecastArn = forecastArn
        self.forecastExportJobName = forecastExportJobName
        self.format = format
        self.tags = tags
    }
}

struct CreateForecastExportJobInputBody: Swift.Equatable {
    let forecastExportJobName: Swift.String?
    let forecastArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let tags: [ForecastClientTypes.Tag]?
    let format: Swift.String?
}

extension CreateForecastExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobName = "ForecastExportJobName"
        case format = "Format"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension CreateForecastExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateForecastExportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.forecastExportJobArn = output.forecastExportJobArn
        } else {
            self.forecastExportJobArn = nil
        }
    }
}

public struct CreateForecastExportJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the export job.
    public var forecastExportJobArn: Swift.String?

    public init(
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct CreateForecastExportJobOutputBody: Swift.Equatable {
    let forecastExportJobArn: Swift.String?
}

extension CreateForecastExportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

enum CreateForecastExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case predictorArn = "PredictorArn"
        case tags = "Tags"
        case timeSeriesSelector = "TimeSeriesSelector"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastName = self.forecastName {
            try encodeContainer.encode(forecastName, forKey: .forecastName)
        }
        if let forecastTypes = forecastTypes {
            var forecastTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastTypes)
            for forecasttype0 in forecastTypes {
                try forecastTypesContainer.encode(forecasttype0)
            }
        }
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeSeriesSelector = self.timeSeriesSelector {
            try encodeContainer.encode(timeSeriesSelector, forKey: .timeSeriesSelector)
        }
    }
}

extension CreateForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateForecastInput: Swift.Equatable {
    /// A name for the forecast.
    /// This member is required.
    public var forecastName: Swift.String?
    /// The quantiles at which probabilistic forecasts are generated. You can currently specify up to 5 quantiles per forecast. Accepted values include 0.01 to 0.99 (increments of .01 only) and mean. The mean forecast is different from the median (0.50) when the distribution is not symmetric (for example, Beta and Negative Binomial). The default quantiles are the quantiles you specified during predictor creation. If you didn't specify quantiles, the default values are ["0.1", "0.5", "0.9"].
    public var forecastTypes: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the predictor to use to generate the forecast.
    /// This member is required.
    public var predictorArn: Swift.String?
    /// The optional metadata that you apply to the forecast to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?
    /// Defines the set of time series that are used to create the forecasts in a TimeSeriesIdentifiers object. The TimeSeriesIdentifiers object needs the following information:
    ///
    /// * DataSource
    ///
    /// * Format
    ///
    /// * Schema
    public var timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?

    public init(
        forecastName: Swift.String? = nil,
        forecastTypes: [Swift.String]? = nil,
        predictorArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector? = nil
    )
    {
        self.forecastName = forecastName
        self.forecastTypes = forecastTypes
        self.predictorArn = predictorArn
        self.tags = tags
        self.timeSeriesSelector = timeSeriesSelector
    }
}

struct CreateForecastInputBody: Swift.Equatable {
    let forecastName: Swift.String?
    let predictorArn: Swift.String?
    let forecastTypes: [Swift.String]?
    let tags: [ForecastClientTypes.Tag]?
    let timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?
}

extension CreateForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case predictorArn = "PredictorArn"
        case tags = "Tags"
        case timeSeriesSelector = "TimeSeriesSelector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let timeSeriesSelectorDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesSelector.self, forKey: .timeSeriesSelector)
        timeSeriesSelector = timeSeriesSelectorDecoded
    }
}

extension CreateForecastOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateForecastOutputBody = try responseDecoder.decode(responseBody: data)
            self.forecastArn = output.forecastArn
        } else {
            self.forecastArn = nil
        }
    }
}

public struct CreateForecastOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast.
    public var forecastArn: Swift.String?

    public init(
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct CreateForecastOutputBody: Swift.Equatable {
    let forecastArn: Swift.String?
}

extension CreateForecastOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

enum CreateForecastOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorName = "MonitorName"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorName = self.monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateMonitorInput: Swift.Equatable {
    /// The name of the monitor resource.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor to monitor.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/forecast/latest/dg/tagging-forecast-resources.html) to apply to the monitor resource.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        monitorName: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.monitorName = monitorName
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct CreateMonitorInputBody: Swift.Equatable {
    let monitorName: Swift.String?
    let resourceArn: Swift.String?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorName = "MonitorName"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMonitorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMonitorOutputBody = try responseDecoder.decode(responseBody: data)
            self.monitorArn = output.monitorArn
        } else {
            self.monitorArn = nil
        }
    }
}

public struct CreateMonitorOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the monitor resource.
    public var monitorArn: Swift.String?

    public init(
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct CreateMonitorOutputBody: Swift.Equatable {
    let monitorArn: Swift.String?
}

extension CreateMonitorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

enum CreateMonitorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePredictorBacktestExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case format = "Format"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let predictorBacktestExportJobName = self.predictorBacktestExportJobName {
            try encodeContainer.encode(predictorBacktestExportJobName, forKey: .predictorBacktestExportJobName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreatePredictorBacktestExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePredictorBacktestExportJobInput: Swift.Equatable {
    /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The format of the exported data, CSV or PARQUET. The default value is CSV.
    public var format: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor that you want to export.
    /// This member is required.
    public var predictorArn: Swift.String?
    /// The name for the backtest export job.
    /// This member is required.
    public var predictorBacktestExportJobName: Swift.String?
    /// Optional metadata to help you categorize and organize your backtests. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        destination: ForecastClientTypes.DataDestination? = nil,
        format: Swift.String? = nil,
        predictorArn: Swift.String? = nil,
        predictorBacktestExportJobName: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.destination = destination
        self.format = format
        self.predictorArn = predictorArn
        self.predictorBacktestExportJobName = predictorBacktestExportJobName
        self.tags = tags
    }
}

struct CreatePredictorBacktestExportJobInputBody: Swift.Equatable {
    let predictorBacktestExportJobName: Swift.String?
    let predictorArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let tags: [ForecastClientTypes.Tag]?
    let format: Swift.String?
}

extension CreatePredictorBacktestExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case format = "Format"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension CreatePredictorBacktestExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePredictorBacktestExportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.predictorBacktestExportJobArn = output.predictorBacktestExportJobArn
        } else {
            self.predictorBacktestExportJobArn = nil
        }
    }
}

public struct CreatePredictorBacktestExportJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job that you want to export.
    public var predictorBacktestExportJobArn: Swift.String?

    public init(
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct CreatePredictorBacktestExportJobOutputBody: Swift.Equatable {
    let predictorBacktestExportJobArn: Swift.String?
}

extension CreatePredictorBacktestExportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

enum CreatePredictorBacktestExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case encryptionConfig = "EncryptionConfig"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hpoConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case optimizationMetric = "OptimizationMetric"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorName = "PredictorName"
        case tags = "Tags"
        case trainingParameters = "TrainingParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = self.algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let autoMLOverrideStrategy = self.autoMLOverrideStrategy {
            try encodeContainer.encode(autoMLOverrideStrategy.rawValue, forKey: .autoMLOverrideStrategy)
        }
        if let encryptionConfig = self.encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let evaluationParameters = self.evaluationParameters {
            try encodeContainer.encode(evaluationParameters, forKey: .evaluationParameters)
        }
        if let featurizationConfig = self.featurizationConfig {
            try encodeContainer.encode(featurizationConfig, forKey: .featurizationConfig)
        }
        if let forecastHorizon = self.forecastHorizon {
            try encodeContainer.encode(forecastHorizon, forKey: .forecastHorizon)
        }
        if let forecastTypes = forecastTypes {
            var forecastTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastTypes)
            for forecasttype0 in forecastTypes {
                try forecastTypesContainer.encode(forecasttype0)
            }
        }
        if let hpoConfig = self.hpoConfig {
            try encodeContainer.encode(hpoConfig, forKey: .hpoConfig)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let optimizationMetric = self.optimizationMetric {
            try encodeContainer.encode(optimizationMetric.rawValue, forKey: .optimizationMetric)
        }
        if let performAutoML = self.performAutoML {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if let performHPO = self.performHPO {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let predictorName = self.predictorName {
            try encodeContainer.encode(predictorName, forKey: .predictorName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let trainingParameters = trainingParameters {
            var trainingParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .trainingParameters)
            for (dictKey0, trainingParameters0) in trainingParameters {
                try trainingParametersContainer.encode(trainingParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the algorithm to use for model training. Required if PerformAutoML is not set to true. Supported algorithms:
    ///
    /// * arn:aws:forecast:::algorithm/ARIMA
    ///
    /// * arn:aws:forecast:::algorithm/CNN-QR
    ///
    /// * arn:aws:forecast:::algorithm/Deep_AR_Plus
    ///
    /// * arn:aws:forecast:::algorithm/ETS
    ///
    /// * arn:aws:forecast:::algorithm/NPTS
    ///
    /// * arn:aws:forecast:::algorithm/Prophet
    public var algorithmArn: Swift.String?
    /// The LatencyOptimized AutoML override strategy is only available in private beta. Contact Amazon Web Services Support or your account manager to learn more about access privileges. Used to overide the default AutoML strategy, which is to optimize predictor accuracy. To apply an AutoML strategy that minimizes training time, use LatencyOptimized. This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// An Key Management Service (KMS) key and the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast evaluates a predictor by splitting a dataset into training data and testing data. The evaluation parameters define how to perform the split and the number of iterations.
    public var evaluationParameters: ForecastClientTypes.EvaluationParameters?
    /// The featurization configuration.
    /// This member is required.
    public var featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    /// Specifies the number of time-steps that the model is trained to predict. The forecast horizon is also called the prediction length. For example, if you configure a dataset for daily data collection (using the DataFrequency parameter of the [CreateDataset] operation) and set the forecast horizon to 10, the model returns predictions for 10 days. The maximum forecast horizon is the lesser of 500 time-steps or 1/3 of the TARGET_TIME_SERIES dataset length.
    /// This member is required.
    public var forecastHorizon: Swift.Int?
    /// Specifies the forecast types used to train a predictor. You can specify up to five forecast types. Forecast types can be quantiles from 0.01 to 0.99, by increments of 0.01 or higher. You can also specify the mean forecast with mean. The default value is ["0.10", "0.50", "0.9"].
    public var forecastTypes: [Swift.String]?
    /// Provides hyperparameter override values for the algorithm. If you don't provide this parameter, Amazon Forecast uses default values. The individual algorithms specify which hyperparameters support hyperparameter optimization (HPO). For more information, see [aws-forecast-choosing-recipes]. If you included the HPOConfig object, you must set PerformHPO to true.
    public var hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    /// Describes the dataset group that contains the data to use to train the predictor.
    /// This member is required.
    public var inputDataConfig: ForecastClientTypes.InputDataConfig?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// Whether to perform AutoML. When Amazon Forecast performs AutoML, it evaluates the algorithms it provides and chooses the best algorithm and configuration for your training dataset. The default value is false. In this case, you are required to specify an algorithm. Set PerformAutoML to true to have Amazon Forecast perform AutoML. This is a good option if you aren't sure which algorithm is suitable for your training data. In this case, PerformHPO must be false.
    public var performAutoML: Swift.Bool?
    /// Whether to perform hyperparameter optimization (HPO). HPO finds optimal hyperparameter values for your training data. The process of performing HPO is known as running a hyperparameter tuning job. The default value is false. In this case, Amazon Forecast uses default hyperparameter values from the chosen algorithm. To override the default values, set PerformHPO to true and, optionally, supply the [HyperParameterTuningJobConfig] object. The tuning job specifies a metric to optimize, which hyperparameters participate in tuning, and the valid range for each tunable hyperparameter. In this case, you are required to specify an algorithm and PerformAutoML must be false. The following algorithms support HPO:
    ///
    /// * DeepAR+
    ///
    /// * CNN-QR
    public var performHPO: Swift.Bool?
    /// A name for the predictor.
    /// This member is required.
    public var predictorName: Swift.String?
    /// The optional metadata that you apply to the predictor to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?
    /// The hyperparameters to override for model training. The hyperparameters that you can override are listed in the individual algorithms. For the list of supported algorithms, see [aws-forecast-choosing-recipes].
    public var trainingParameters: [Swift.String:Swift.String]?

    public init(
        algorithmArn: Swift.String? = nil,
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        evaluationParameters: ForecastClientTypes.EvaluationParameters? = nil,
        featurizationConfig: ForecastClientTypes.FeaturizationConfig? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig? = nil,
        inputDataConfig: ForecastClientTypes.InputDataConfig? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        performAutoML: Swift.Bool? = nil,
        performHPO: Swift.Bool? = nil,
        predictorName: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        trainingParameters: [Swift.String:Swift.String]? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.encryptionConfig = encryptionConfig
        self.evaluationParameters = evaluationParameters
        self.featurizationConfig = featurizationConfig
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.hpoConfig = hpoConfig
        self.inputDataConfig = inputDataConfig
        self.optimizationMetric = optimizationMetric
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.predictorName = predictorName
        self.tags = tags
        self.trainingParameters = trainingParameters
    }
}

struct CreatePredictorInputBody: Swift.Equatable {
    let predictorName: Swift.String?
    let algorithmArn: Swift.String?
    let forecastHorizon: Swift.Int?
    let forecastTypes: [Swift.String]?
    let performAutoML: Swift.Bool?
    let autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    let performHPO: Swift.Bool?
    let trainingParameters: [Swift.String:Swift.String]?
    let evaluationParameters: ForecastClientTypes.EvaluationParameters?
    let hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    let inputDataConfig: ForecastClientTypes.InputDataConfig?
    let featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let tags: [ForecastClientTypes.Tag]?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
}

extension CreatePredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case encryptionConfig = "EncryptionConfig"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hpoConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case optimizationMetric = "OptimizationMetric"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorName = "PredictorName"
        case tags = "Tags"
        case trainingParameters = "TrainingParameters"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let trainingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .trainingParameters)
        var trainingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let trainingParametersContainer = trainingParametersContainer {
            trainingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in trainingParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    trainingParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        trainingParameters = trainingParametersDecoded0
        let evaluationParametersDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EvaluationParameters.self, forKey: .evaluationParameters)
        evaluationParameters = evaluationParametersDecoded
        let hpoConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.HyperParameterTuningJobConfig.self, forKey: .hpoConfig)
        hpoConfig = hpoConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let featurizationConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FeaturizationConfig.self, forKey: .featurizationConfig)
        featurizationConfig = featurizationConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
    }
}

extension CreatePredictorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePredictorOutputBody = try responseDecoder.decode(responseBody: data)
            self.predictorArn = output.predictorArn
        } else {
            self.predictorArn = nil
        }
    }
}

public struct CreatePredictorOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor.
    public var predictorArn: Swift.String?

    public init(
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct CreatePredictorOutputBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension CreatePredictorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

enum CreatePredictorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWhatIfAnalysisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
        case tags = "Tags"
        case timeSeriesSelector = "TimeSeriesSelector"
        case whatIfAnalysisName = "WhatIfAnalysisName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastArn = self.forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeSeriesSelector = self.timeSeriesSelector {
            try encodeContainer.encode(timeSeriesSelector, forKey: .timeSeriesSelector)
        }
        if let whatIfAnalysisName = self.whatIfAnalysisName {
            try encodeContainer.encode(whatIfAnalysisName, forKey: .whatIfAnalysisName)
        }
    }
}

extension CreateWhatIfAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWhatIfAnalysisInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the baseline forecast.
    /// This member is required.
    public var forecastArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/forecast/latest/dg/tagging-forecast-resources.html) to apply to the what if forecast.
    public var tags: [ForecastClientTypes.Tag]?
    /// Defines the set of time series that are used in the what-if analysis with a TimeSeriesIdentifiers object. What-if analyses are performed only for the time series in this object. The TimeSeriesIdentifiers object needs the following information:
    ///
    /// * DataSource
    ///
    /// * Format
    ///
    /// * Schema
    public var timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?
    /// The name of the what-if analysis. Each name must be unique.
    /// This member is required.
    public var whatIfAnalysisName: Swift.String?

    public init(
        forecastArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector? = nil,
        whatIfAnalysisName: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
        self.tags = tags
        self.timeSeriesSelector = timeSeriesSelector
        self.whatIfAnalysisName = whatIfAnalysisName
    }
}

struct CreateWhatIfAnalysisInputBody: Swift.Equatable {
    let whatIfAnalysisName: Swift.String?
    let forecastArn: Swift.String?
    let timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateWhatIfAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
        case tags = "Tags"
        case timeSeriesSelector = "TimeSeriesSelector"
        case whatIfAnalysisName = "WhatIfAnalysisName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfAnalysisNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisName)
        whatIfAnalysisName = whatIfAnalysisNameDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let timeSeriesSelectorDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesSelector.self, forKey: .timeSeriesSelector)
        timeSeriesSelector = timeSeriesSelectorDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWhatIfAnalysisOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWhatIfAnalysisOutputBody = try responseDecoder.decode(responseBody: data)
            self.whatIfAnalysisArn = output.whatIfAnalysisArn
        } else {
            self.whatIfAnalysisArn = nil
        }
    }
}

public struct CreateWhatIfAnalysisOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if analysis.
    public var whatIfAnalysisArn: Swift.String?

    public init(
        whatIfAnalysisArn: Swift.String? = nil
    )
    {
        self.whatIfAnalysisArn = whatIfAnalysisArn
    }
}

struct CreateWhatIfAnalysisOutputBody: Swift.Equatable {
    let whatIfAnalysisArn: Swift.String?
}

extension CreateWhatIfAnalysisOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
    }
}

enum CreateWhatIfAnalysisOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWhatIfForecastExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case format = "Format"
        case tags = "Tags"
        case whatIfForecastArns = "WhatIfForecastArns"
        case whatIfForecastExportName = "WhatIfForecastExportName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let whatIfForecastArns = whatIfForecastArns {
            var whatIfForecastArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .whatIfForecastArns)
            for longarn0 in whatIfForecastArns {
                try whatIfForecastArnsContainer.encode(longarn0)
            }
        }
        if let whatIfForecastExportName = self.whatIfForecastExportName {
            try encodeContainer.encode(whatIfForecastExportName, forKey: .whatIfForecastExportName)
        }
    }
}

extension CreateWhatIfForecastExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWhatIfForecastExportInput: Swift.Equatable {
    /// The location where you want to save the forecast and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the location. The forecast must be exported to an Amazon S3 bucket. If encryption is used, Destination must include an Key Management Service (KMS) key. The IAM role must allow Amazon Forecast permission to access the key.
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/forecast/latest/dg/tagging-forecast-resources.html) to apply to the what if forecast.
    public var tags: [ForecastClientTypes.Tag]?
    /// The list of what-if forecast Amazon Resource Names (ARNs) to export.
    /// This member is required.
    public var whatIfForecastArns: [Swift.String]?
    /// The name of the what-if forecast to export.
    /// This member is required.
    public var whatIfForecastExportName: Swift.String?

    public init(
        destination: ForecastClientTypes.DataDestination? = nil,
        format: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        whatIfForecastArns: [Swift.String]? = nil,
        whatIfForecastExportName: Swift.String? = nil
    )
    {
        self.destination = destination
        self.format = format
        self.tags = tags
        self.whatIfForecastArns = whatIfForecastArns
        self.whatIfForecastExportName = whatIfForecastExportName
    }
}

struct CreateWhatIfForecastExportInputBody: Swift.Equatable {
    let whatIfForecastExportName: Swift.String?
    let whatIfForecastArns: [Swift.String]?
    let destination: ForecastClientTypes.DataDestination?
    let tags: [ForecastClientTypes.Tag]?
    let format: Swift.String?
}

extension CreateWhatIfForecastExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case format = "Format"
        case tags = "Tags"
        case whatIfForecastArns = "WhatIfForecastArns"
        case whatIfForecastExportName = "WhatIfForecastExportName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportName)
        whatIfForecastExportName = whatIfForecastExportNameDecoded
        let whatIfForecastArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whatIfForecastArns)
        var whatIfForecastArnsDecoded0:[Swift.String]? = nil
        if let whatIfForecastArnsContainer = whatIfForecastArnsContainer {
            whatIfForecastArnsDecoded0 = [Swift.String]()
            for string0 in whatIfForecastArnsContainer {
                if let string0 = string0 {
                    whatIfForecastArnsDecoded0?.append(string0)
                }
            }
        }
        whatIfForecastArns = whatIfForecastArnsDecoded0
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension CreateWhatIfForecastExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWhatIfForecastExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.whatIfForecastExportArn = output.whatIfForecastExportArn
        } else {
            self.whatIfForecastExportArn = nil
        }
    }
}

public struct CreateWhatIfForecastExportOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if forecast.
    public var whatIfForecastExportArn: Swift.String?

    public init(
        whatIfForecastExportArn: Swift.String? = nil
    )
    {
        self.whatIfForecastExportArn = whatIfForecastExportArn
    }
}

struct CreateWhatIfForecastExportOutputBody: Swift.Equatable {
    let whatIfForecastExportArn: Swift.String?
}

extension CreateWhatIfForecastExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastExportArn = "WhatIfForecastExportArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportArn)
        whatIfForecastExportArn = whatIfForecastExportArnDecoded
    }
}

enum CreateWhatIfForecastExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWhatIfForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
        case timeSeriesReplacementsDataSource = "TimeSeriesReplacementsDataSource"
        case timeSeriesTransformations = "TimeSeriesTransformations"
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
        case whatIfForecastName = "WhatIfForecastName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeSeriesReplacementsDataSource = self.timeSeriesReplacementsDataSource {
            try encodeContainer.encode(timeSeriesReplacementsDataSource, forKey: .timeSeriesReplacementsDataSource)
        }
        if let timeSeriesTransformations = timeSeriesTransformations {
            var timeSeriesTransformationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timeSeriesTransformations)
            for timeseriestransformation0 in timeSeriesTransformations {
                try timeSeriesTransformationsContainer.encode(timeseriestransformation0)
            }
        }
        if let whatIfAnalysisArn = self.whatIfAnalysisArn {
            try encodeContainer.encode(whatIfAnalysisArn, forKey: .whatIfAnalysisArn)
        }
        if let whatIfForecastName = self.whatIfForecastName {
            try encodeContainer.encode(whatIfForecastName, forKey: .whatIfForecastName)
        }
    }
}

extension CreateWhatIfForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWhatIfForecastInput: Swift.Equatable {
    /// A list of [tags](https://docs.aws.amazon.com/forecast/latest/dg/tagging-forecast-resources.html) to apply to the what if forecast.
    public var tags: [ForecastClientTypes.Tag]?
    /// The replacement time series dataset, which contains the rows that you want to change in the related time series dataset. A replacement time series does not need to contain all rows that are in the baseline related time series. Include only the rows (measure-dimension combinations) that you want to include in the what-if forecast. This dataset is merged with the original time series to create a transformed dataset that is used for the what-if analysis. This dataset should contain the items to modify (such as item_id or workforce_type), any relevant dimensions, the timestamp column, and at least one of the related time series columns. This file should not contain duplicate timestamps for the same time series. Timestamps and item_ids not included in this dataset are not included in the what-if analysis.
    public var timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource?
    /// The transformations that are applied to the baseline time series. Each transformation contains an action and a set of conditions. An action is applied only when all conditions are met. If no conditions are provided, the action is applied to all items.
    public var timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]?
    /// The Amazon Resource Name (ARN) of the what-if analysis.
    /// This member is required.
    public var whatIfAnalysisArn: Swift.String?
    /// The name of the what-if forecast. Names must be unique within each what-if analysis.
    /// This member is required.
    public var whatIfForecastName: Swift.String?

    public init(
        tags: [ForecastClientTypes.Tag]? = nil,
        timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource? = nil,
        timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]? = nil,
        whatIfAnalysisArn: Swift.String? = nil,
        whatIfForecastName: Swift.String? = nil
    )
    {
        self.tags = tags
        self.timeSeriesReplacementsDataSource = timeSeriesReplacementsDataSource
        self.timeSeriesTransformations = timeSeriesTransformations
        self.whatIfAnalysisArn = whatIfAnalysisArn
        self.whatIfForecastName = whatIfForecastName
    }
}

struct CreateWhatIfForecastInputBody: Swift.Equatable {
    let whatIfForecastName: Swift.String?
    let whatIfAnalysisArn: Swift.String?
    let timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]?
    let timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateWhatIfForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
        case timeSeriesReplacementsDataSource = "TimeSeriesReplacementsDataSource"
        case timeSeriesTransformations = "TimeSeriesTransformations"
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
        case whatIfForecastName = "WhatIfForecastName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastName)
        whatIfForecastName = whatIfForecastNameDecoded
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
        let timeSeriesTransformationsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.TimeSeriesTransformation?].self, forKey: .timeSeriesTransformations)
        var timeSeriesTransformationsDecoded0:[ForecastClientTypes.TimeSeriesTransformation]? = nil
        if let timeSeriesTransformationsContainer = timeSeriesTransformationsContainer {
            timeSeriesTransformationsDecoded0 = [ForecastClientTypes.TimeSeriesTransformation]()
            for structure0 in timeSeriesTransformationsContainer {
                if let structure0 = structure0 {
                    timeSeriesTransformationsDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesTransformations = timeSeriesTransformationsDecoded0
        let timeSeriesReplacementsDataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesReplacementsDataSource.self, forKey: .timeSeriesReplacementsDataSource)
        timeSeriesReplacementsDataSource = timeSeriesReplacementsDataSourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWhatIfForecastOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWhatIfForecastOutputBody = try responseDecoder.decode(responseBody: data)
            self.whatIfForecastArn = output.whatIfForecastArn
        } else {
            self.whatIfForecastArn = nil
        }
    }
}

public struct CreateWhatIfForecastOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if forecast.
    public var whatIfForecastArn: Swift.String?

    public init(
        whatIfForecastArn: Swift.String? = nil
    )
    {
        self.whatIfForecastArn = whatIfForecastArn
    }
}

struct CreateWhatIfForecastOutputBody: Swift.Equatable {
    let whatIfForecastArn: Swift.String?
}

extension CreateWhatIfForecastOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastArn = "WhatIfForecastArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastArn)
        whatIfForecastArn = whatIfForecastArnDecoded
    }
}

enum CreateWhatIfForecastOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ForecastClientTypes.DataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalDatasets = "AdditionalDatasets"
        case attributeConfigs = "AttributeConfigs"
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalDatasets = additionalDatasets {
            var additionalDatasetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalDatasets)
            for additionaldataset0 in additionalDatasets {
                try additionalDatasetsContainer.encode(additionaldataset0)
            }
        }
        if let attributeConfigs = attributeConfigs {
            var attributeConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeConfigs)
            for attributeconfig0 in attributeConfigs {
                try attributeConfigsContainer.encode(attributeconfig0)
            }
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let attributeConfigsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.AttributeConfig?].self, forKey: .attributeConfigs)
        var attributeConfigsDecoded0:[ForecastClientTypes.AttributeConfig]? = nil
        if let attributeConfigsContainer = attributeConfigsContainer {
            attributeConfigsDecoded0 = [ForecastClientTypes.AttributeConfig]()
            for structure0 in attributeConfigsContainer {
                if let structure0 = structure0 {
                    attributeConfigsDecoded0?.append(structure0)
                }
            }
        }
        attributeConfigs = attributeConfigsDecoded0
        let additionalDatasetsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.AdditionalDataset?].self, forKey: .additionalDatasets)
        var additionalDatasetsDecoded0:[ForecastClientTypes.AdditionalDataset]? = nil
        if let additionalDatasetsContainer = additionalDatasetsContainer {
            additionalDatasetsDecoded0 = [ForecastClientTypes.AdditionalDataset]()
            for structure0 in additionalDatasetsContainer {
                if let structure0 = structure0 {
                    additionalDatasetsDecoded0?.append(structure0)
                }
            }
        }
        additionalDatasets = additionalDatasetsDecoded0
    }
}

extension ForecastClientTypes {
    /// The data configuration for your dataset group and any additional datasets.
    public struct DataConfig: Swift.Equatable {
        /// Additional built-in datasets like Holidays and the Weather Index.
        public var additionalDatasets: [ForecastClientTypes.AdditionalDataset]?
        /// Aggregation and filling options for attributes in your dataset group.
        public var attributeConfigs: [ForecastClientTypes.AttributeConfig]?
        /// The ARN of the dataset group used to train the predictor.
        /// This member is required.
        public var datasetGroupArn: Swift.String?

        public init(
            additionalDatasets: [ForecastClientTypes.AdditionalDataset]? = nil,
            attributeConfigs: [ForecastClientTypes.AttributeConfig]? = nil,
            datasetGroupArn: Swift.String? = nil
        )
        {
            self.additionalDatasets = additionalDatasets
            self.attributeConfigs = attributeConfigs
            self.datasetGroupArn = datasetGroupArn
        }
    }

}

extension ForecastClientTypes.DataDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Config = "S3Config"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Config = self.s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
    }
}

extension ForecastClientTypes {
    /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
    public struct DataDestination: Swift.Equatable {
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the bucket.
        /// This member is required.
        public var s3Config: ForecastClientTypes.S3Config?

        public init(
            s3Config: ForecastClientTypes.S3Config? = nil
        )
        {
            self.s3Config = s3Config
        }
    }

}

extension ForecastClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Config = "S3Config"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Config = self.s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
    }
}

extension ForecastClientTypes {
    /// The source of your data, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an Key Management Service (KMS) key.
    public struct DataSource: Swift.Equatable {
        /// The path to the data stored in an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the data.
        /// This member is required.
        public var s3Config: ForecastClientTypes.S3Config?

        public init(
            s3Config: ForecastClientTypes.S3Config? = nil
        )
        {
            self.s3Config = s3Config
        }
    }

}

extension ForecastClientTypes.DatasetGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case datasetGroupName = "DatasetGroupName"
        case lastModificationTime = "LastModificationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let datasetGroupName = self.datasetGroupName {
            try encodeContainer.encode(datasetGroupName, forKey: .datasetGroupName)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset group properties used in the [ListDatasetGroups](https://docs.aws.amazon.com/forecast/latest/dg/API_ListDatasetGroups.html) operation. To get the complete set of properties, call the [DescribeDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_DescribeDatasetGroup.html) operation, and provide the DatasetGroupArn.
    public struct DatasetGroupSummary: Swift.Equatable {
        /// When the dataset group was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// The name of the dataset group.
        public var datasetGroupName: Swift.String?
        /// When the dataset group was created or last updated from a call to the [UpdateDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_UpdateDatasetGroup.html) operation. While the dataset group is being updated, LastModificationTime is the current time of the ListDatasetGroups call.
        public var lastModificationTime: ClientRuntime.Date?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            datasetGroupName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.datasetGroupName = datasetGroupName
            self.lastModificationTime = lastModificationTime
        }
    }

}

extension ForecastClientTypes.DatasetImportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataSource = "DataSource"
        case datasetImportJobArn = "DatasetImportJobArn"
        case datasetImportJobName = "DatasetImportJobName"
        case importMode = "ImportMode"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetImportJobArn = self.datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let datasetImportJobName = self.datasetImportJobName {
            try encodeContainer.encode(datasetImportJobName, forKey: .datasetImportJobName)
        }
        if let importMode = self.importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let importModeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset import job properties used in the [ListDatasetImportJobs](https://docs.aws.amazon.com/forecast/latest/dg/API_ListDatasetImportJobs.html) operation. To get the complete set of properties, call the [DescribeDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_DescribeDatasetImportJob.html) operation, and provide the DatasetImportJobArn.
    public struct DatasetImportJobSummary: Swift.Equatable {
        /// When the dataset import job was created.
        public var creationTime: ClientRuntime.Date?
        /// The location of the training data to import and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket. If encryption is used, DataSource includes an Key Management Service (KMS) key.
        public var dataSource: ForecastClientTypes.DataSource?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public var datasetImportJobArn: Swift.String?
        /// The name of the dataset import job.
        public var datasetImportJobName: Swift.String?
        /// The import mode of the dataset import job, FULL or INCREMENTAL.
        public var importMode: ForecastClientTypes.ImportMode?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the dataset import job. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        public var status: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            dataSource: ForecastClientTypes.DataSource? = nil,
            datasetImportJobArn: Swift.String? = nil,
            datasetImportJobName: Swift.String? = nil,
            importMode: ForecastClientTypes.ImportMode? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.dataSource = dataSource
            self.datasetImportJobArn = datasetImportJobArn
            self.datasetImportJobName = datasetImportJobName
            self.importMode = importMode
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }
    }

}

extension ForecastClientTypes.DatasetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case lastModificationTime = "LastModificationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetName = self.datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let datasetType = self.datasetType {
            try encodeContainer.encode(datasetType.rawValue, forKey: .datasetType)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset properties used in the [ListDatasets](https://docs.aws.amazon.com/forecast/latest/dg/API_ListDatasets.html) operation. To get the complete set of properties, call the [DescribeDataset](https://docs.aws.amazon.com/forecast/latest/dg/API_DescribeDataset.html) operation, and provide the DatasetArn.
    public struct DatasetSummary: Swift.Equatable {
        /// When the dataset was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset.
        public var datasetArn: Swift.String?
        /// The name of the dataset.
        public var datasetName: Swift.String?
        /// The dataset type.
        public var datasetType: ForecastClientTypes.DatasetType?
        /// The domain associated with the dataset.
        public var domain: ForecastClientTypes.Domain?
        /// When you create a dataset, LastModificationTime is the same as CreationTime. While data is being imported to the dataset, LastModificationTime is the current time of the ListDatasets call. After a [CreateDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html) operation has finished, LastModificationTime is when the import job completed or failed.
        public var lastModificationTime: ClientRuntime.Date?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetName: Swift.String? = nil,
            datasetType: ForecastClientTypes.DatasetType? = nil,
            domain: ForecastClientTypes.Domain? = nil,
            lastModificationTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetArn = datasetArn
            self.datasetName = datasetName
            self.datasetType = datasetType
            self.domain = domain
            self.lastModificationTime = lastModificationTime
        }
    }

}

extension ForecastClientTypes {
    public enum DatasetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case itemMetadata
        case relatedTimeSeries
        case targetTimeSeries
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetType] {
            return [
                .itemMetadata,
                .relatedTimeSeries,
                .targetTimeSeries,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .itemMetadata: return "ITEM_METADATA"
            case .relatedTimeSeries: return "RELATED_TIME_SERIES"
            case .targetTimeSeries: return "TARGET_TIME_SERIES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetType(rawValue: rawValue) ?? DatasetType.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes {
    public enum DayOfWeek: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DayOfWeek(rawValue: rawValue) ?? DayOfWeek.sdkUnknown(rawValue)
        }
    }
}

extension DeleteDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

extension DeleteDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDatasetGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group to delete.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DeleteDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
}

extension DeleteDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DeleteDatasetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDatasetGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDatasetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDatasetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = self.datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
    }
}

extension DeleteDatasetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDatasetImportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job to delete.
    /// This member is required.
    public var datasetImportJobArn: Swift.String?

    public init(
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct DeleteDatasetImportJobInputBody: Swift.Equatable {
    let datasetImportJobArn: Swift.String?
}

extension DeleteDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension DeleteDatasetImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDatasetImportJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDatasetImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

extension DeleteDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to delete.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension DeleteDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DeleteDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDatasetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteExplainabilityExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityExportArn = self.explainabilityExportArn {
            try encodeContainer.encode(explainabilityExportArn, forKey: .explainabilityExportArn)
        }
    }
}

extension DeleteExplainabilityExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteExplainabilityExportInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explainability export to delete.
    /// This member is required.
    public var explainabilityExportArn: Swift.String?

    public init(
        explainabilityExportArn: Swift.String? = nil
    )
    {
        self.explainabilityExportArn = explainabilityExportArn
    }
}

struct DeleteExplainabilityExportInputBody: Swift.Equatable {
    let explainabilityExportArn: Swift.String?
}

extension DeleteExplainabilityExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
    }
}

extension DeleteExplainabilityExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteExplainabilityExportOutput: Swift.Equatable {

    public init() { }
}

enum DeleteExplainabilityExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteExplainabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityArn = self.explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
    }
}

extension DeleteExplainabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteExplainabilityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explainability resource to delete.
    /// This member is required.
    public var explainabilityArn: Swift.String?

    public init(
        explainabilityArn: Swift.String? = nil
    )
    {
        self.explainabilityArn = explainabilityArn
    }
}

struct DeleteExplainabilityInputBody: Swift.Equatable {
    let explainabilityArn: Swift.String?
}

extension DeleteExplainabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
    }
}

extension DeleteExplainabilityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteExplainabilityOutput: Swift.Equatable {

    public init() { }
}

enum DeleteExplainabilityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteForecastExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastExportJobArn = self.forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
    }
}

extension DeleteForecastExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteForecastExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast export job to delete.
    /// This member is required.
    public var forecastExportJobArn: Swift.String?

    public init(
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct DeleteForecastExportJobInputBody: Swift.Equatable {
    let forecastExportJobArn: Swift.String?
}

extension DeleteForecastExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

extension DeleteForecastExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteForecastExportJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteForecastExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastArn = self.forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
    }
}

extension DeleteForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteForecastInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast to delete.
    /// This member is required.
    public var forecastArn: Swift.String?

    public init(
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct DeleteForecastInputBody: Swift.Equatable {
    let forecastArn: Swift.String?
}

extension DeleteForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

extension DeleteForecastOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteForecastOutput: Swift.Equatable {

    public init() { }
}

enum DeleteForecastOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
    }
}

extension DeleteMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMonitorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the monitor resource to delete.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init(
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct DeleteMonitorInputBody: Swift.Equatable {
    let monitorArn: Swift.String?
}

extension DeleteMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

extension DeleteMonitorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMonitorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMonitorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePredictorBacktestExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorBacktestExportJobArn = self.predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
    }
}

extension DeletePredictorBacktestExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePredictorBacktestExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job to delete.
    /// This member is required.
    public var predictorBacktestExportJobArn: Swift.String?

    public init(
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct DeletePredictorBacktestExportJobInputBody: Swift.Equatable {
    let predictorBacktestExportJobArn: Swift.String?
}

extension DeletePredictorBacktestExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

extension DeletePredictorBacktestExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePredictorBacktestExportJobOutput: Swift.Equatable {

    public init() { }
}

enum DeletePredictorBacktestExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

extension DeletePredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor to delete.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init(
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct DeletePredictorInputBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension DeletePredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension DeletePredictorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePredictorOutput: Swift.Equatable {

    public init() { }
}

enum DeletePredictorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourceTreeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension DeleteResourceTreeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResourceTreeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the parent resource to delete. All child resources of the parent resource will also be deleted.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourceTreeInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension DeleteResourceTreeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteResourceTreeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResourceTreeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResourceTreeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWhatIfAnalysisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let whatIfAnalysisArn = self.whatIfAnalysisArn {
            try encodeContainer.encode(whatIfAnalysisArn, forKey: .whatIfAnalysisArn)
        }
    }
}

extension DeleteWhatIfAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWhatIfAnalysisInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if analysis that you want to delete.
    /// This member is required.
    public var whatIfAnalysisArn: Swift.String?

    public init(
        whatIfAnalysisArn: Swift.String? = nil
    )
    {
        self.whatIfAnalysisArn = whatIfAnalysisArn
    }
}

struct DeleteWhatIfAnalysisInputBody: Swift.Equatable {
    let whatIfAnalysisArn: Swift.String?
}

extension DeleteWhatIfAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
    }
}

extension DeleteWhatIfAnalysisOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWhatIfAnalysisOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWhatIfAnalysisOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWhatIfForecastExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastExportArn = "WhatIfForecastExportArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let whatIfForecastExportArn = self.whatIfForecastExportArn {
            try encodeContainer.encode(whatIfForecastExportArn, forKey: .whatIfForecastExportArn)
        }
    }
}

extension DeleteWhatIfForecastExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWhatIfForecastExportInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if forecast export that you want to delete.
    /// This member is required.
    public var whatIfForecastExportArn: Swift.String?

    public init(
        whatIfForecastExportArn: Swift.String? = nil
    )
    {
        self.whatIfForecastExportArn = whatIfForecastExportArn
    }
}

struct DeleteWhatIfForecastExportInputBody: Swift.Equatable {
    let whatIfForecastExportArn: Swift.String?
}

extension DeleteWhatIfForecastExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastExportArn = "WhatIfForecastExportArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportArn)
        whatIfForecastExportArn = whatIfForecastExportArnDecoded
    }
}

extension DeleteWhatIfForecastExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWhatIfForecastExportOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWhatIfForecastExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWhatIfForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastArn = "WhatIfForecastArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let whatIfForecastArn = self.whatIfForecastArn {
            try encodeContainer.encode(whatIfForecastArn, forKey: .whatIfForecastArn)
        }
    }
}

extension DeleteWhatIfForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWhatIfForecastInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if forecast that you want to delete.
    /// This member is required.
    public var whatIfForecastArn: Swift.String?

    public init(
        whatIfForecastArn: Swift.String? = nil
    )
    {
        self.whatIfForecastArn = whatIfForecastArn
    }
}

struct DeleteWhatIfForecastInputBody: Swift.Equatable {
    let whatIfForecastArn: Swift.String?
}

extension DeleteWhatIfForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastArn = "WhatIfForecastArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastArn)
        whatIfForecastArn = whatIfForecastArnDecoded
    }
}

extension DeleteWhatIfForecastOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWhatIfForecastOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWhatIfForecastOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAutoPredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

extension DescribeAutoPredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAutoPredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init(
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct DescribeAutoPredictorInputBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension DescribeAutoPredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension DescribeAutoPredictorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAutoPredictorOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.dataConfig = output.dataConfig
            self.datasetImportJobArns = output.datasetImportJobArns
            self.encryptionConfig = output.encryptionConfig
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.explainabilityInfo = output.explainabilityInfo
            self.forecastDimensions = output.forecastDimensions
            self.forecastFrequency = output.forecastFrequency
            self.forecastHorizon = output.forecastHorizon
            self.forecastTypes = output.forecastTypes
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.monitorInfo = output.monitorInfo
            self.optimizationMetric = output.optimizationMetric
            self.predictorArn = output.predictorArn
            self.predictorName = output.predictorName
            self.referencePredictorSummary = output.referencePredictorSummary
            self.status = output.status
            self.timeAlignmentBoundary = output.timeAlignmentBoundary
        } else {
            self.creationTime = nil
            self.dataConfig = nil
            self.datasetImportJobArns = nil
            self.encryptionConfig = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.explainabilityInfo = nil
            self.forecastDimensions = nil
            self.forecastFrequency = nil
            self.forecastHorizon = nil
            self.forecastTypes = nil
            self.lastModificationTime = nil
            self.message = nil
            self.monitorInfo = nil
            self.optimizationMetric = nil
            self.predictorArn = nil
            self.predictorName = nil
            self.referencePredictorSummary = nil
            self.status = nil
            self.timeAlignmentBoundary = nil
        }
    }
}

public struct DescribeAutoPredictorOutput: Swift.Equatable {
    /// The timestamp of the CreateAutoPredictor request.
    public var creationTime: ClientRuntime.Date?
    /// The data configuration for your dataset group and any additional datasets.
    public var dataConfig: ForecastClientTypes.DataConfig?
    /// An array of the ARNs of the dataset import jobs used to import training data for the predictor.
    public var datasetImportJobArns: [Swift.String]?
    /// An Key Management Service (KMS) key and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key. You can specify this optional object in the [CreateDataset] and [CreatePredictor] requests.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// The estimated time remaining in minutes for the predictor training job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// Provides the status and ARN of the Predictor Explainability.
    public var explainabilityInfo: ForecastClientTypes.ExplainabilityInfo?
    /// An array of dimension (field) names that specify the attributes used to group your time series.
    public var forecastDimensions: [Swift.String]?
    /// The frequency of predictions in a forecast. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes.
    public var forecastFrequency: Swift.String?
    /// The number of time-steps that the model predicts. The forecast horizon is also called the prediction length.
    public var forecastHorizon: Swift.Int?
    /// The forecast types used during predictor training. Default value is ["0.1","0.5","0.9"].
    public var forecastTypes: [Swift.String]?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// In the event of an error, a message detailing the cause of the error.
    public var message: Swift.String?
    /// A object with the Amazon Resource Name (ARN) and status of the monitor resource.
    public var monitorInfo: ForecastClientTypes.MonitorInfo?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// The Amazon Resource Name (ARN) of the predictor
    public var predictorArn: Swift.String?
    /// The name of the predictor.
    public var predictorName: Swift.String?
    /// The ARN and state of the reference predictor. This parameter is only valid for retrained or upgraded predictors.
    public var referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary?
    /// The status of the predictor. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?
    /// The time boundary Forecast uses when aggregating data.
    public var timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        dataConfig: ForecastClientTypes.DataConfig? = nil,
        datasetImportJobArns: [Swift.String]? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        explainabilityInfo: ForecastClientTypes.ExplainabilityInfo? = nil,
        forecastDimensions: [Swift.String]? = nil,
        forecastFrequency: Swift.String? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        monitorInfo: ForecastClientTypes.MonitorInfo? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        predictorArn: Swift.String? = nil,
        predictorName: Swift.String? = nil,
        referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary? = nil,
        status: Swift.String? = nil,
        timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary? = nil
    )
    {
        self.creationTime = creationTime
        self.dataConfig = dataConfig
        self.datasetImportJobArns = datasetImportJobArns
        self.encryptionConfig = encryptionConfig
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.explainabilityInfo = explainabilityInfo
        self.forecastDimensions = forecastDimensions
        self.forecastFrequency = forecastFrequency
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.monitorInfo = monitorInfo
        self.optimizationMetric = optimizationMetric
        self.predictorArn = predictorArn
        self.predictorName = predictorName
        self.referencePredictorSummary = referencePredictorSummary
        self.status = status
        self.timeAlignmentBoundary = timeAlignmentBoundary
    }
}

struct DescribeAutoPredictorOutputBody: Swift.Equatable {
    let predictorArn: Swift.String?
    let predictorName: Swift.String?
    let forecastHorizon: Swift.Int?
    let forecastTypes: [Swift.String]?
    let forecastFrequency: Swift.String?
    let forecastDimensions: [Swift.String]?
    let datasetImportJobArns: [Swift.String]?
    let dataConfig: ForecastClientTypes.DataConfig?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
    let explainabilityInfo: ForecastClientTypes.ExplainabilityInfo?
    let monitorInfo: ForecastClientTypes.MonitorInfo?
    let timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary?
}

extension DescribeAutoPredictorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataConfig = "DataConfig"
        case datasetImportJobArns = "DatasetImportJobArns"
        case encryptionConfig = "EncryptionConfig"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case explainabilityInfo = "ExplainabilityInfo"
        case forecastDimensions = "ForecastDimensions"
        case forecastFrequency = "ForecastFrequency"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case monitorInfo = "MonitorInfo"
        case optimizationMetric = "OptimizationMetric"
        case predictorArn = "PredictorArn"
        case predictorName = "PredictorName"
        case referencePredictorSummary = "ReferencePredictorSummary"
        case status = "Status"
        case timeAlignmentBoundary = "TimeAlignmentBoundary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let forecastFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastFrequency)
        forecastFrequency = forecastFrequencyDecoded
        let forecastDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastDimensions)
        var forecastDimensionsDecoded0:[Swift.String]? = nil
        if let forecastDimensionsContainer = forecastDimensionsContainer {
            forecastDimensionsDecoded0 = [Swift.String]()
            for string0 in forecastDimensionsContainer {
                if let string0 = string0 {
                    forecastDimensionsDecoded0?.append(string0)
                }
            }
        }
        forecastDimensions = forecastDimensionsDecoded0
        let datasetImportJobArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetImportJobArns)
        var datasetImportJobArnsDecoded0:[Swift.String]? = nil
        if let datasetImportJobArnsContainer = datasetImportJobArnsContainer {
            datasetImportJobArnsDecoded0 = [Swift.String]()
            for string0 in datasetImportJobArnsContainer {
                if let string0 = string0 {
                    datasetImportJobArnsDecoded0?.append(string0)
                }
            }
        }
        datasetImportJobArns = datasetImportJobArnsDecoded0
        let dataConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataConfig.self, forKey: .dataConfig)
        dataConfig = dataConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let referencePredictorSummaryDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ReferencePredictorSummary.self, forKey: .referencePredictorSummary)
        referencePredictorSummary = referencePredictorSummaryDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
        let explainabilityInfoDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ExplainabilityInfo.self, forKey: .explainabilityInfo)
        explainabilityInfo = explainabilityInfoDecoded
        let monitorInfoDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.MonitorInfo.self, forKey: .monitorInfo)
        monitorInfo = monitorInfoDecoded
        let timeAlignmentBoundaryDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeAlignmentBoundary.self, forKey: .timeAlignmentBoundary)
        timeAlignmentBoundary = timeAlignmentBoundaryDecoded
    }
}

enum DescribeAutoPredictorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

extension DescribeDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DescribeDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
}

extension DescribeDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DescribeDatasetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDatasetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.datasetArns = output.datasetArns
            self.datasetGroupArn = output.datasetGroupArn
            self.datasetGroupName = output.datasetGroupName
            self.domain = output.domain
            self.lastModificationTime = output.lastModificationTime
            self.status = output.status
        } else {
            self.creationTime = nil
            self.datasetArns = nil
            self.datasetGroupArn = nil
            self.datasetGroupName = nil
            self.domain = nil
            self.lastModificationTime = nil
            self.status = nil
        }
    }
}

public struct DescribeDatasetGroupOutput: Swift.Equatable {
    /// When the dataset group was created.
    public var creationTime: ClientRuntime.Date?
    /// An array of Amazon Resource Names (ARNs) of the datasets contained in the dataset group.
    public var datasetArns: [Swift.String]?
    /// The ARN of the dataset group.
    public var datasetGroupArn: Swift.String?
    /// The name of the dataset group.
    public var datasetGroupName: Swift.String?
    /// The domain associated with the dataset group.
    public var domain: ForecastClientTypes.Domain?
    /// When the dataset group was created or last updated from a call to the [UpdateDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_UpdateDatasetGroup.html) operation. While the dataset group is being updated, LastModificationTime is the current time of the DescribeDatasetGroup call.
    public var lastModificationTime: ClientRuntime.Date?
    /// The status of the dataset group. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED
    ///
    ///
    /// The UPDATE states apply when you call the [UpdateDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_UpdateDatasetGroup.html) operation. The Status of the dataset group must be ACTIVE before you can use the dataset group to create a predictor.
    public var status: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        datasetArns: [Swift.String]? = nil,
        datasetGroupArn: Swift.String? = nil,
        datasetGroupName: Swift.String? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetArns = datasetArns
        self.datasetGroupArn = datasetGroupArn
        self.datasetGroupName = datasetGroupName
        self.domain = domain
        self.lastModificationTime = lastModificationTime
        self.status = status
    }
}

struct DescribeDatasetGroupOutputBody: Swift.Equatable {
    let datasetGroupName: Swift.String?
    let datasetGroupArn: Swift.String?
    let datasetArns: [Swift.String]?
    let domain: ForecastClientTypes.Domain?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension DescribeDatasetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case lastModificationTime = "LastModificationTime"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[Swift.String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [Swift.String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

enum DescribeDatasetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDatasetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = self.datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
    }
}

extension DescribeDatasetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetImportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job.
    /// This member is required.
    public var datasetImportJobArn: Swift.String?

    public init(
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct DescribeDatasetImportJobInputBody: Swift.Equatable {
    let datasetImportJobArn: Swift.String?
}

extension DescribeDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension DescribeDatasetImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDatasetImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.dataSize = output.dataSize
            self.dataSource = output.dataSource
            self.datasetArn = output.datasetArn
            self.datasetImportJobArn = output.datasetImportJobArn
            self.datasetImportJobName = output.datasetImportJobName
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.fieldStatistics = output.fieldStatistics
            self.format = output.format
            self.geolocationFormat = output.geolocationFormat
            self.importMode = output.importMode
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
            self.timeZone = output.timeZone
            self.timestampFormat = output.timestampFormat
            self.useGeolocationForTimeZone = output.useGeolocationForTimeZone
        } else {
            self.creationTime = nil
            self.dataSize = nil
            self.dataSource = nil
            self.datasetArn = nil
            self.datasetImportJobArn = nil
            self.datasetImportJobName = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.fieldStatistics = nil
            self.format = nil
            self.geolocationFormat = nil
            self.importMode = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
            self.timeZone = nil
            self.timestampFormat = nil
            self.useGeolocationForTimeZone = false
        }
    }
}

public struct DescribeDatasetImportJobOutput: Swift.Equatable {
    /// When the dataset import job was created.
    public var creationTime: ClientRuntime.Date?
    /// The size of the dataset in gigabytes (GB) after the import job has finished.
    public var dataSize: Swift.Double?
    /// The location of the training data to import and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. If encryption is used, DataSource includes an Key Management Service (KMS) key.
    public var dataSource: ForecastClientTypes.DataSource?
    /// The Amazon Resource Name (ARN) of the dataset that the training data was imported to.
    public var datasetArn: Swift.String?
    /// The ARN of the dataset import job.
    public var datasetImportJobArn: Swift.String?
    /// The name of the dataset import job.
    public var datasetImportJobName: Swift.String?
    /// The estimated time remaining in minutes for the dataset import job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// Statistical information about each field in the input data.
    public var fieldStatistics: [Swift.String:ForecastClientTypes.Statistics]?
    /// The format of the imported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The format of the geolocation attribute. Valid Values:"LAT_LONG" and "CC_POSTALCODE".
    public var geolocationFormat: Swift.String?
    /// The import mode of the dataset import job, FULL or INCREMENTAL.
    public var importMode: ForecastClientTypes.ImportMode?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the dataset import job. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    public var status: Swift.String?
    /// The single time zone applied to every item in the dataset
    public var timeZone: Swift.String?
    /// The format of timestamps in the dataset. The format that you specify depends on the DataFrequency specified when the dataset was created. The following formats are supported
    ///
    /// * "yyyy-MM-dd" For the following data frequencies: Y, M, W, and D
    ///
    /// * "yyyy-MM-dd HH:mm:ss" For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y, M, W, and D
    public var timestampFormat: Swift.String?
    /// Whether TimeZone is automatically derived from the geolocation attribute.
    public var useGeolocationForTimeZone: Swift.Bool

    public init(
        creationTime: ClientRuntime.Date? = nil,
        dataSize: Swift.Double? = nil,
        dataSource: ForecastClientTypes.DataSource? = nil,
        datasetArn: Swift.String? = nil,
        datasetImportJobArn: Swift.String? = nil,
        datasetImportJobName: Swift.String? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        fieldStatistics: [Swift.String:ForecastClientTypes.Statistics]? = nil,
        format: Swift.String? = nil,
        geolocationFormat: Swift.String? = nil,
        importMode: ForecastClientTypes.ImportMode? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil,
        timeZone: Swift.String? = nil,
        timestampFormat: Swift.String? = nil,
        useGeolocationForTimeZone: Swift.Bool = false
    )
    {
        self.creationTime = creationTime
        self.dataSize = dataSize
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.datasetImportJobArn = datasetImportJobArn
        self.datasetImportJobName = datasetImportJobName
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.fieldStatistics = fieldStatistics
        self.format = format
        self.geolocationFormat = geolocationFormat
        self.importMode = importMode
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.timeZone = timeZone
        self.timestampFormat = timestampFormat
        self.useGeolocationForTimeZone = useGeolocationForTimeZone
    }
}

struct DescribeDatasetImportJobOutputBody: Swift.Equatable {
    let datasetImportJobName: Swift.String?
    let datasetImportJobArn: Swift.String?
    let datasetArn: Swift.String?
    let timestampFormat: Swift.String?
    let timeZone: Swift.String?
    let useGeolocationForTimeZone: Swift.Bool
    let geolocationFormat: Swift.String?
    let dataSource: ForecastClientTypes.DataSource?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let fieldStatistics: [Swift.String:ForecastClientTypes.Statistics]?
    let dataSize: Swift.Double?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let format: Swift.String?
    let importMode: ForecastClientTypes.ImportMode?
}

extension DescribeDatasetImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataSize = "DataSize"
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobArn = "DatasetImportJobArn"
        case datasetImportJobName = "DatasetImportJobName"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case fieldStatistics = "FieldStatistics"
        case format = "Format"
        case geolocationFormat = "GeolocationFormat"
        case importMode = "ImportMode"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let timestampFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampFormat)
        timestampFormat = timestampFormatDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let useGeolocationForTimeZoneDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useGeolocationForTimeZone) ?? false
        useGeolocationForTimeZone = useGeolocationForTimeZoneDecoded
        let geolocationFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geolocationFormat)
        geolocationFormat = geolocationFormatDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let fieldStatisticsContainer = try containerValues.decodeIfPresent([Swift.String: ForecastClientTypes.Statistics?].self, forKey: .fieldStatistics)
        var fieldStatisticsDecoded0: [Swift.String:ForecastClientTypes.Statistics]? = nil
        if let fieldStatisticsContainer = fieldStatisticsContainer {
            fieldStatisticsDecoded0 = [Swift.String:ForecastClientTypes.Statistics]()
            for (key0, statistics0) in fieldStatisticsContainer {
                if let statistics0 = statistics0 {
                    fieldStatisticsDecoded0?[key0] = statistics0
                }
            }
        }
        fieldStatistics = fieldStatisticsDecoded0
        let dataSizeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .dataSize)
        dataSize = dataSizeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let importModeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
    }
}

enum DescribeDatasetImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

extension DescribeDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DescribeDatasetInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension DescribeDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DescribeDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.dataFrequency = output.dataFrequency
            self.datasetArn = output.datasetArn
            self.datasetName = output.datasetName
            self.datasetType = output.datasetType
            self.domain = output.domain
            self.encryptionConfig = output.encryptionConfig
            self.lastModificationTime = output.lastModificationTime
            self.schema = output.schema
            self.status = output.status
        } else {
            self.creationTime = nil
            self.dataFrequency = nil
            self.datasetArn = nil
            self.datasetName = nil
            self.datasetType = nil
            self.domain = nil
            self.encryptionConfig = nil
            self.lastModificationTime = nil
            self.schema = nil
            self.status = nil
        }
    }
}

public struct DescribeDatasetOutput: Swift.Equatable {
    /// When the dataset was created.
    public var creationTime: ClientRuntime.Date?
    /// The frequency of data collection. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "M" indicates every month and "30min" indicates every 30 minutes.
    public var dataFrequency: Swift.String?
    /// The Amazon Resource Name (ARN) of the dataset.
    public var datasetArn: Swift.String?
    /// The name of the dataset.
    public var datasetName: Swift.String?
    /// The dataset type.
    public var datasetType: ForecastClientTypes.DatasetType?
    /// The domain associated with the dataset.
    public var domain: ForecastClientTypes.Domain?
    /// The Key Management Service (KMS) key and the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// When you create a dataset, LastModificationTime is the same as CreationTime. While data is being imported to the dataset, LastModificationTime is the current time of the DescribeDataset call. After a [CreateDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html) operation has finished, LastModificationTime is when the import job completed or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// An array of SchemaAttribute objects that specify the dataset fields. Each SchemaAttribute specifies the name and data type of a field.
    public var schema: ForecastClientTypes.Schema?
    /// The status of the dataset. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED
    ///
    ///
    /// The UPDATE states apply while data is imported to the dataset from a call to the [CreateDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html) operation and reflect the status of the dataset import job. For example, when the import job status is CREATE_IN_PROGRESS, the status of the dataset is UPDATE_IN_PROGRESS. The Status of the dataset must be ACTIVE before you can import training data.
    public var status: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        dataFrequency: Swift.String? = nil,
        datasetArn: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        datasetType: ForecastClientTypes.DatasetType? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.dataFrequency = dataFrequency
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.datasetType = datasetType
        self.domain = domain
        self.encryptionConfig = encryptionConfig
        self.lastModificationTime = lastModificationTime
        self.schema = schema
        self.status = status
    }
}

struct DescribeDatasetOutputBody: Swift.Equatable {
    let datasetArn: Swift.String?
    let datasetName: Swift.String?
    let domain: ForecastClientTypes.Domain?
    let datasetType: ForecastClientTypes.DatasetType?
    let dataFrequency: Swift.String?
    let schema: ForecastClientTypes.Schema?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension DescribeDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataFrequency = "DataFrequency"
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case lastModificationTime = "LastModificationTime"
        case schema = "Schema"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let dataFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataFrequency)
        dataFrequency = dataFrequencyDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

enum DescribeDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeExplainabilityExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityExportArn = self.explainabilityExportArn {
            try encodeContainer.encode(explainabilityExportArn, forKey: .explainabilityExportArn)
        }
    }
}

extension DescribeExplainabilityExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExplainabilityExportInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explainability export.
    /// This member is required.
    public var explainabilityExportArn: Swift.String?

    public init(
        explainabilityExportArn: Swift.String? = nil
    )
    {
        self.explainabilityExportArn = explainabilityExportArn
    }
}

struct DescribeExplainabilityExportInputBody: Swift.Equatable {
    let explainabilityExportArn: Swift.String?
}

extension DescribeExplainabilityExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
    }
}

extension DescribeExplainabilityExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeExplainabilityExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.explainabilityArn = output.explainabilityArn
            self.explainabilityExportArn = output.explainabilityExportArn
            self.explainabilityExportName = output.explainabilityExportName
            self.format = output.format
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.explainabilityArn = nil
            self.explainabilityExportArn = nil
            self.explainabilityExportName = nil
            self.format = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
        }
    }
}

public struct DescribeExplainabilityExportOutput: Swift.Equatable {
    /// When the Explainability export was created.
    public var creationTime: ClientRuntime.Date?
    /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the Explainability export.
    public var explainabilityArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the Explainability export.
    public var explainabilityExportArn: Swift.String?
    /// The name of the Explainability export.
    public var explainabilityExportName: Swift.String?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// Information about any errors that occurred during the export.
    public var message: Swift.String?
    /// The status of the Explainability export. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        explainabilityArn: Swift.String? = nil,
        explainabilityExportArn: Swift.String? = nil,
        explainabilityExportName: Swift.String? = nil,
        format: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.explainabilityArn = explainabilityArn
        self.explainabilityExportArn = explainabilityExportArn
        self.explainabilityExportName = explainabilityExportName
        self.format = format
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
    }
}

struct DescribeExplainabilityExportOutputBody: Swift.Equatable {
    let explainabilityExportArn: Swift.String?
    let explainabilityExportName: Swift.String?
    let explainabilityArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let message: Swift.String?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let format: Swift.String?
}

extension DescribeExplainabilityExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityExportArn = "ExplainabilityExportArn"
        case explainabilityExportName = "ExplainabilityExportName"
        case format = "Format"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
        let explainabilityExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportName)
        explainabilityExportName = explainabilityExportNameDecoded
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

enum DescribeExplainabilityExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeExplainabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityArn = self.explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
    }
}

extension DescribeExplainabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExplainabilityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explaianability to describe.
    /// This member is required.
    public var explainabilityArn: Swift.String?

    public init(
        explainabilityArn: Swift.String? = nil
    )
    {
        self.explainabilityArn = explainabilityArn
    }
}

struct DescribeExplainabilityInputBody: Swift.Equatable {
    let explainabilityArn: Swift.String?
}

extension DescribeExplainabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
    }
}

extension DescribeExplainabilityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeExplainabilityOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.dataSource = output.dataSource
            self.enableVisualization = output.enableVisualization
            self.endDateTime = output.endDateTime
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.explainabilityArn = output.explainabilityArn
            self.explainabilityConfig = output.explainabilityConfig
            self.explainabilityName = output.explainabilityName
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.schema = output.schema
            self.startDateTime = output.startDateTime
            self.status = output.status
        } else {
            self.creationTime = nil
            self.dataSource = nil
            self.enableVisualization = nil
            self.endDateTime = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.explainabilityArn = nil
            self.explainabilityConfig = nil
            self.explainabilityName = nil
            self.lastModificationTime = nil
            self.message = nil
            self.resourceArn = nil
            self.schema = nil
            self.startDateTime = nil
            self.status = nil
        }
    }
}

public struct DescribeExplainabilityOutput: Swift.Equatable {
    /// When the Explainability resource was created.
    public var creationTime: ClientRuntime.Date?
    /// The source of your data, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an Key Management Service (KMS) key.
    public var dataSource: ForecastClientTypes.DataSource?
    /// Whether the visualization was enabled for the Explainability resource.
    public var enableVisualization: Swift.Bool?
    /// If TimePointGranularity is set to SPECIFIC, the last time point in the Explainability.
    public var endDateTime: Swift.String?
    /// The estimated time remaining in minutes for the [CreateExplainability] job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The Amazon Resource Name (ARN) of the Explainability.
    public var explainabilityArn: Swift.String?
    /// The configuration settings that define the granularity of time series and time points for the Explainability.
    public var explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
    /// The name of the Explainability.
    public var explainabilityName: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, a message about the error.
    public var message: Swift.String?
    /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability resource.
    public var resourceArn: Swift.String?
    /// Defines the fields of a dataset.
    public var schema: ForecastClientTypes.Schema?
    /// If TimePointGranularity is set to SPECIFIC, the first time point in the Explainability.
    public var startDateTime: Swift.String?
    /// The status of the Explainability resource. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        dataSource: ForecastClientTypes.DataSource? = nil,
        enableVisualization: Swift.Bool? = nil,
        endDateTime: Swift.String? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        explainabilityArn: Swift.String? = nil,
        explainabilityConfig: ForecastClientTypes.ExplainabilityConfig? = nil,
        explainabilityName: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        startDateTime: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.dataSource = dataSource
        self.enableVisualization = enableVisualization
        self.endDateTime = endDateTime
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.explainabilityArn = explainabilityArn
        self.explainabilityConfig = explainabilityConfig
        self.explainabilityName = explainabilityName
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.resourceArn = resourceArn
        self.schema = schema
        self.startDateTime = startDateTime
        self.status = status
    }
}

struct DescribeExplainabilityOutputBody: Swift.Equatable {
    let explainabilityArn: Swift.String?
    let explainabilityName: Swift.String?
    let resourceArn: Swift.String?
    let explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
    let enableVisualization: Swift.Bool?
    let dataSource: ForecastClientTypes.DataSource?
    let schema: ForecastClientTypes.Schema?
    let startDateTime: Swift.String?
    let endDateTime: Swift.String?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let message: Swift.String?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension DescribeExplainabilityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataSource = "DataSource"
        case enableVisualization = "EnableVisualization"
        case endDateTime = "EndDateTime"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityConfig = "ExplainabilityConfig"
        case explainabilityName = "ExplainabilityName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case resourceArn = "ResourceArn"
        case schema = "Schema"
        case startDateTime = "StartDateTime"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let explainabilityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityName)
        explainabilityName = explainabilityNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let explainabilityConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ExplainabilityConfig.self, forKey: .explainabilityConfig)
        explainabilityConfig = explainabilityConfigDecoded
        let enableVisualizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableVisualization)
        enableVisualization = enableVisualizationDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

enum DescribeExplainabilityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeForecastExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastExportJobArn = self.forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
    }
}

extension DescribeForecastExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeForecastExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast export job.
    /// This member is required.
    public var forecastExportJobArn: Swift.String?

    public init(
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct DescribeForecastExportJobInputBody: Swift.Equatable {
    let forecastExportJobArn: Swift.String?
}

extension DescribeForecastExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

extension DescribeForecastExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeForecastExportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.forecastArn = output.forecastArn
            self.forecastExportJobArn = output.forecastExportJobArn
            self.forecastExportJobName = output.forecastExportJobName
            self.format = output.format
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.forecastArn = nil
            self.forecastExportJobArn = nil
            self.forecastExportJobName = nil
            self.format = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
        }
    }
}

public struct DescribeForecastExportJobOutput: Swift.Equatable {
    /// When the forecast export job was created.
    public var creationTime: ClientRuntime.Date?
    /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the exported forecast.
    public var forecastArn: Swift.String?
    /// The ARN of the forecast export job.
    public var forecastExportJobArn: Swift.String?
    /// The name of the forecast export job.
    public var forecastExportJobName: Swift.String?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the forecast export job. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the forecast export job must be ACTIVE before you can access the forecast in your S3 bucket.
    public var status: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        forecastArn: Swift.String? = nil,
        forecastExportJobArn: Swift.String? = nil,
        forecastExportJobName: Swift.String? = nil,
        format: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.forecastArn = forecastArn
        self.forecastExportJobArn = forecastExportJobArn
        self.forecastExportJobName = forecastExportJobName
        self.format = format
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
    }
}

struct DescribeForecastExportJobOutputBody: Swift.Equatable {
    let forecastExportJobArn: Swift.String?
    let forecastExportJobName: Swift.String?
    let forecastArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let message: Swift.String?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let format: Swift.String?
}

extension DescribeForecastExportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobArn = "ForecastExportJobArn"
        case forecastExportJobName = "ForecastExportJobName"
        case format = "Format"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

enum DescribeForecastExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastArn = self.forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
    }
}

extension DescribeForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeForecastInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast.
    /// This member is required.
    public var forecastArn: Swift.String?

    public init(
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct DescribeForecastInputBody: Swift.Equatable {
    let forecastArn: Swift.String?
}

extension DescribeForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

extension DescribeForecastOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeForecastOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.datasetGroupArn = output.datasetGroupArn
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.forecastArn = output.forecastArn
            self.forecastName = output.forecastName
            self.forecastTypes = output.forecastTypes
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.predictorArn = output.predictorArn
            self.status = output.status
            self.timeSeriesSelector = output.timeSeriesSelector
        } else {
            self.creationTime = nil
            self.datasetGroupArn = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.forecastArn = nil
            self.forecastName = nil
            self.forecastTypes = nil
            self.lastModificationTime = nil
            self.message = nil
            self.predictorArn = nil
            self.status = nil
            self.timeSeriesSelector = nil
        }
    }
}

public struct DescribeForecastOutput: Swift.Equatable {
    /// When the forecast creation task was created.
    public var creationTime: ClientRuntime.Date?
    /// The ARN of the dataset group that provided the data used to train the predictor.
    public var datasetGroupArn: Swift.String?
    /// The estimated time remaining in minutes for the forecast job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The forecast ARN as specified in the request.
    public var forecastArn: Swift.String?
    /// The name of the forecast.
    public var forecastName: Swift.String?
    /// The quantiles at which probabilistic forecasts were generated.
    public var forecastTypes: [Swift.String]?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The ARN of the predictor used to generate the forecast.
    public var predictorArn: Swift.String?
    /// The status of the forecast. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the forecast must be ACTIVE before you can query or export the forecast.
    public var status: Swift.String?
    /// The time series to include in the forecast.
    public var timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        datasetGroupArn: Swift.String? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        forecastArn: Swift.String? = nil,
        forecastName: Swift.String? = nil,
        forecastTypes: [Swift.String]? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        predictorArn: Swift.String? = nil,
        status: Swift.String? = nil,
        timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetGroupArn = datasetGroupArn
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.forecastArn = forecastArn
        self.forecastName = forecastName
        self.forecastTypes = forecastTypes
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorArn = predictorArn
        self.status = status
        self.timeSeriesSelector = timeSeriesSelector
    }
}

struct DescribeForecastOutputBody: Swift.Equatable {
    let forecastArn: Swift.String?
    let forecastName: Swift.String?
    let forecastTypes: [Swift.String]?
    let predictorArn: Swift.String?
    let datasetGroupArn: Swift.String?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?
}

extension DescribeForecastOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case forecastArn = "ForecastArn"
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case status = "Status"
        case timeSeriesSelector = "TimeSeriesSelector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let forecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let timeSeriesSelectorDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesSelector.self, forKey: .timeSeriesSelector)
        timeSeriesSelector = timeSeriesSelectorDecoded
    }
}

enum DescribeForecastOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
    }
}

extension DescribeMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMonitorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the monitor resource to describe.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init(
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct DescribeMonitorInputBody: Swift.Equatable {
    let monitorArn: Swift.String?
}

extension DescribeMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

extension DescribeMonitorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMonitorOutputBody = try responseDecoder.decode(responseBody: data)
            self.baseline = output.baseline
            self.creationTime = output.creationTime
            self.estimatedEvaluationTimeRemainingInMinutes = output.estimatedEvaluationTimeRemainingInMinutes
            self.lastEvaluationState = output.lastEvaluationState
            self.lastEvaluationTime = output.lastEvaluationTime
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.monitorArn = output.monitorArn
            self.monitorName = output.monitorName
            self.resourceArn = output.resourceArn
            self.status = output.status
        } else {
            self.baseline = nil
            self.creationTime = nil
            self.estimatedEvaluationTimeRemainingInMinutes = nil
            self.lastEvaluationState = nil
            self.lastEvaluationTime = nil
            self.lastModificationTime = nil
            self.message = nil
            self.monitorArn = nil
            self.monitorName = nil
            self.resourceArn = nil
            self.status = nil
        }
    }
}

public struct DescribeMonitorOutput: Swift.Equatable {
    /// Metrics you can use as a baseline for comparison purposes. Use these values you interpret monitoring results for an auto predictor.
    public var baseline: ForecastClientTypes.Baseline?
    /// The timestamp for when the monitor resource was created.
    public var creationTime: ClientRuntime.Date?
    /// The estimated number of minutes remaining before the monitor resource finishes its current evaluation.
    public var estimatedEvaluationTimeRemainingInMinutes: Swift.Int?
    /// The state of the monitor's latest evaluation.
    public var lastEvaluationState: Swift.String?
    /// The timestamp of the latest evaluation completed by the monitor.
    public var lastEvaluationTime: ClientRuntime.Date?
    /// The timestamp of the latest modification to the monitor.
    public var lastModificationTime: ClientRuntime.Date?
    /// An error message, if any, for the monitor.
    public var message: Swift.String?
    /// The Amazon Resource Name (ARN) of the monitor resource described.
    public var monitorArn: Swift.String?
    /// The name of the monitor.
    public var monitorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the auto predictor being monitored.
    public var resourceArn: Swift.String?
    /// The status of the monitor resource.
    public var status: Swift.String?

    public init(
        baseline: ForecastClientTypes.Baseline? = nil,
        creationTime: ClientRuntime.Date? = nil,
        estimatedEvaluationTimeRemainingInMinutes: Swift.Int? = nil,
        lastEvaluationState: Swift.String? = nil,
        lastEvaluationTime: ClientRuntime.Date? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.baseline = baseline
        self.creationTime = creationTime
        self.estimatedEvaluationTimeRemainingInMinutes = estimatedEvaluationTimeRemainingInMinutes
        self.lastEvaluationState = lastEvaluationState
        self.lastEvaluationTime = lastEvaluationTime
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.monitorArn = monitorArn
        self.monitorName = monitorName
        self.resourceArn = resourceArn
        self.status = status
    }
}

struct DescribeMonitorOutputBody: Swift.Equatable {
    let monitorName: Swift.String?
    let monitorArn: Swift.String?
    let resourceArn: Swift.String?
    let status: Swift.String?
    let lastEvaluationTime: ClientRuntime.Date?
    let lastEvaluationState: Swift.String?
    let baseline: ForecastClientTypes.Baseline?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let estimatedEvaluationTimeRemainingInMinutes: Swift.Int?
}

extension DescribeMonitorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseline = "Baseline"
        case creationTime = "CreationTime"
        case estimatedEvaluationTimeRemainingInMinutes = "EstimatedEvaluationTimeRemainingInMinutes"
        case lastEvaluationState = "LastEvaluationState"
        case lastEvaluationTime = "LastEvaluationTime"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case monitorArn = "MonitorArn"
        case monitorName = "MonitorName"
        case resourceArn = "ResourceArn"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastEvaluationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastEvaluationTime)
        lastEvaluationTime = lastEvaluationTimeDecoded
        let lastEvaluationStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastEvaluationState)
        lastEvaluationState = lastEvaluationStateDecoded
        let baselineDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Baseline.self, forKey: .baseline)
        baseline = baselineDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let estimatedEvaluationTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedEvaluationTimeRemainingInMinutes)
        estimatedEvaluationTimeRemainingInMinutes = estimatedEvaluationTimeRemainingInMinutesDecoded
    }
}

enum DescribeMonitorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePredictorBacktestExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorBacktestExportJobArn = self.predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
    }
}

extension DescribePredictorBacktestExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePredictorBacktestExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job.
    /// This member is required.
    public var predictorBacktestExportJobArn: Swift.String?

    public init(
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct DescribePredictorBacktestExportJobInputBody: Swift.Equatable {
    let predictorBacktestExportJobArn: Swift.String?
}

extension DescribePredictorBacktestExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

extension DescribePredictorBacktestExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePredictorBacktestExportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.format = output.format
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.predictorArn = output.predictorArn
            self.predictorBacktestExportJobArn = output.predictorBacktestExportJobArn
            self.predictorBacktestExportJobName = output.predictorBacktestExportJobName
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.format = nil
            self.lastModificationTime = nil
            self.message = nil
            self.predictorArn = nil
            self.predictorBacktestExportJobArn = nil
            self.predictorBacktestExportJobName = nil
            self.status = nil
        }
    }
}

public struct DescribePredictorBacktestExportJobOutput: Swift.Equatable {
    /// When the predictor backtest export job was created.
    public var creationTime: ClientRuntime.Date?
    /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
    public var destination: ForecastClientTypes.DataDestination?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// Information about any errors that may have occurred during the backtest export.
    public var message: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor.
    public var predictorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor backtest export job.
    public var predictorBacktestExportJobArn: Swift.String?
    /// The name of the predictor backtest export job.
    public var predictorBacktestExportJobName: Swift.String?
    /// The status of the predictor backtest export job. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        format: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        predictorArn: Swift.String? = nil,
        predictorBacktestExportJobArn: Swift.String? = nil,
        predictorBacktestExportJobName: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.format = format
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorArn = predictorArn
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
        self.predictorBacktestExportJobName = predictorBacktestExportJobName
        self.status = status
    }
}

struct DescribePredictorBacktestExportJobOutputBody: Swift.Equatable {
    let predictorBacktestExportJobArn: Swift.String?
    let predictorBacktestExportJobName: Swift.String?
    let predictorArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let message: Swift.String?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let format: Swift.String?
}

extension DescribePredictorBacktestExportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case format = "Format"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

enum DescribePredictorBacktestExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

extension DescribePredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor that you want information about.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init(
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct DescribePredictorInputBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension DescribePredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension DescribePredictorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePredictorOutputBody = try responseDecoder.decode(responseBody: data)
            self.algorithmArn = output.algorithmArn
            self.autoMLAlgorithmArns = output.autoMLAlgorithmArns
            self.autoMLOverrideStrategy = output.autoMLOverrideStrategy
            self.creationTime = output.creationTime
            self.datasetImportJobArns = output.datasetImportJobArns
            self.encryptionConfig = output.encryptionConfig
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.evaluationParameters = output.evaluationParameters
            self.featurizationConfig = output.featurizationConfig
            self.forecastHorizon = output.forecastHorizon
            self.forecastTypes = output.forecastTypes
            self.hpoConfig = output.hpoConfig
            self.inputDataConfig = output.inputDataConfig
            self.isAutoPredictor = output.isAutoPredictor
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.optimizationMetric = output.optimizationMetric
            self.performAutoML = output.performAutoML
            self.performHPO = output.performHPO
            self.predictorArn = output.predictorArn
            self.predictorExecutionDetails = output.predictorExecutionDetails
            self.predictorName = output.predictorName
            self.status = output.status
            self.trainingParameters = output.trainingParameters
        } else {
            self.algorithmArn = nil
            self.autoMLAlgorithmArns = nil
            self.autoMLOverrideStrategy = nil
            self.creationTime = nil
            self.datasetImportJobArns = nil
            self.encryptionConfig = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.evaluationParameters = nil
            self.featurizationConfig = nil
            self.forecastHorizon = nil
            self.forecastTypes = nil
            self.hpoConfig = nil
            self.inputDataConfig = nil
            self.isAutoPredictor = nil
            self.lastModificationTime = nil
            self.message = nil
            self.optimizationMetric = nil
            self.performAutoML = nil
            self.performHPO = nil
            self.predictorArn = nil
            self.predictorExecutionDetails = nil
            self.predictorName = nil
            self.status = nil
            self.trainingParameters = nil
        }
    }
}

public struct DescribePredictorOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the algorithm used for model training.
    public var algorithmArn: Swift.String?
    /// When PerformAutoML is specified, the ARN of the chosen algorithm.
    public var autoMLAlgorithmArns: [Swift.String]?
    /// The LatencyOptimized AutoML override strategy is only available in private beta. Contact Amazon Web Services Support or your account manager to learn more about access privileges. The AutoML strategy used to train the predictor. Unless LatencyOptimized is specified, the AutoML strategy optimizes predictor accuracy. This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// When the model training task was created.
    public var creationTime: ClientRuntime.Date?
    /// An array of the ARNs of the dataset import jobs used to import training data for the predictor.
    public var datasetImportJobArns: [Swift.String]?
    /// An Key Management Service (KMS) key and the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// The estimated time remaining in minutes for the predictor training job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast evaluates a predictor by splitting a dataset into training data and testing data. The evaluation parameters define how to perform the split and the number of iterations.
    public var evaluationParameters: ForecastClientTypes.EvaluationParameters?
    /// The featurization configuration.
    public var featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    /// The number of time-steps of the forecast. The forecast horizon is also called the prediction length.
    public var forecastHorizon: Swift.Int?
    /// The forecast types used during predictor training. Default value is ["0.1","0.5","0.9"]
    public var forecastTypes: [Swift.String]?
    /// The hyperparameter override values for the algorithm.
    public var hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    /// Describes the dataset group that contains the data to use to train the predictor.
    public var inputDataConfig: ForecastClientTypes.InputDataConfig?
    /// Whether the predictor was created with [CreateAutoPredictor].
    public var isAutoPredictor: Swift.Bool?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// Whether the predictor is set to perform AutoML.
    public var performAutoML: Swift.Bool?
    /// Whether the predictor is set to perform hyperparameter optimization (HPO).
    public var performHPO: Swift.Bool?
    /// The ARN of the predictor.
    public var predictorArn: Swift.String?
    /// Details on the the status and results of the backtests performed to evaluate the accuracy of the predictor. You specify the number of backtests to perform when you call the operation.
    public var predictorExecutionDetails: ForecastClientTypes.PredictorExecutionDetails?
    /// The name of the predictor.
    public var predictorName: Swift.String?
    /// The status of the predictor. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    ///
    /// The Status of the predictor must be ACTIVE before you can use the predictor to create a forecast.
    public var status: Swift.String?
    /// The default training parameters or overrides selected during model training. When running AutoML or choosing HPO with CNN-QR or DeepAR+, the optimized values for the chosen hyperparameters are returned. For more information, see [aws-forecast-choosing-recipes].
    public var trainingParameters: [Swift.String:Swift.String]?

    public init(
        algorithmArn: Swift.String? = nil,
        autoMLAlgorithmArns: [Swift.String]? = nil,
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        creationTime: ClientRuntime.Date? = nil,
        datasetImportJobArns: [Swift.String]? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        evaluationParameters: ForecastClientTypes.EvaluationParameters? = nil,
        featurizationConfig: ForecastClientTypes.FeaturizationConfig? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig? = nil,
        inputDataConfig: ForecastClientTypes.InputDataConfig? = nil,
        isAutoPredictor: Swift.Bool? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        performAutoML: Swift.Bool? = nil,
        performHPO: Swift.Bool? = nil,
        predictorArn: Swift.String? = nil,
        predictorExecutionDetails: ForecastClientTypes.PredictorExecutionDetails? = nil,
        predictorName: Swift.String? = nil,
        status: Swift.String? = nil,
        trainingParameters: [Swift.String:Swift.String]? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.autoMLAlgorithmArns = autoMLAlgorithmArns
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.creationTime = creationTime
        self.datasetImportJobArns = datasetImportJobArns
        self.encryptionConfig = encryptionConfig
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.evaluationParameters = evaluationParameters
        self.featurizationConfig = featurizationConfig
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.hpoConfig = hpoConfig
        self.inputDataConfig = inputDataConfig
        self.isAutoPredictor = isAutoPredictor
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.optimizationMetric = optimizationMetric
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.predictorArn = predictorArn
        self.predictorExecutionDetails = predictorExecutionDetails
        self.predictorName = predictorName
        self.status = status
        self.trainingParameters = trainingParameters
    }
}

struct DescribePredictorOutputBody: Swift.Equatable {
    let predictorArn: Swift.String?
    let predictorName: Swift.String?
    let algorithmArn: Swift.String?
    let autoMLAlgorithmArns: [Swift.String]?
    let forecastHorizon: Swift.Int?
    let forecastTypes: [Swift.String]?
    let performAutoML: Swift.Bool?
    let autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    let performHPO: Swift.Bool?
    let trainingParameters: [Swift.String:Swift.String]?
    let evaluationParameters: ForecastClientTypes.EvaluationParameters?
    let hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    let inputDataConfig: ForecastClientTypes.InputDataConfig?
    let featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let predictorExecutionDetails: ForecastClientTypes.PredictorExecutionDetails?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let isAutoPredictor: Swift.Bool?
    let datasetImportJobArns: [Swift.String]?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
}

extension DescribePredictorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLAlgorithmArns = "AutoMLAlgorithmArns"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case creationTime = "CreationTime"
        case datasetImportJobArns = "DatasetImportJobArns"
        case encryptionConfig = "EncryptionConfig"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hpoConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case isAutoPredictor = "IsAutoPredictor"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case optimizationMetric = "OptimizationMetric"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorArn = "PredictorArn"
        case predictorExecutionDetails = "PredictorExecutionDetails"
        case predictorName = "PredictorName"
        case status = "Status"
        case trainingParameters = "TrainingParameters"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let autoMLAlgorithmArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .autoMLAlgorithmArns)
        var autoMLAlgorithmArnsDecoded0:[Swift.String]? = nil
        if let autoMLAlgorithmArnsContainer = autoMLAlgorithmArnsContainer {
            autoMLAlgorithmArnsDecoded0 = [Swift.String]()
            for string0 in autoMLAlgorithmArnsContainer {
                if let string0 = string0 {
                    autoMLAlgorithmArnsDecoded0?.append(string0)
                }
            }
        }
        autoMLAlgorithmArns = autoMLAlgorithmArnsDecoded0
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let trainingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .trainingParameters)
        var trainingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let trainingParametersContainer = trainingParametersContainer {
            trainingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in trainingParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    trainingParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        trainingParameters = trainingParametersDecoded0
        let evaluationParametersDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EvaluationParameters.self, forKey: .evaluationParameters)
        evaluationParameters = evaluationParametersDecoded
        let hpoConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.HyperParameterTuningJobConfig.self, forKey: .hpoConfig)
        hpoConfig = hpoConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let featurizationConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FeaturizationConfig.self, forKey: .featurizationConfig)
        featurizationConfig = featurizationConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let predictorExecutionDetailsDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.PredictorExecutionDetails.self, forKey: .predictorExecutionDetails)
        predictorExecutionDetails = predictorExecutionDetailsDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let isAutoPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAutoPredictor)
        isAutoPredictor = isAutoPredictorDecoded
        let datasetImportJobArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetImportJobArns)
        var datasetImportJobArnsDecoded0:[Swift.String]? = nil
        if let datasetImportJobArnsContainer = datasetImportJobArnsContainer {
            datasetImportJobArnsDecoded0 = [Swift.String]()
            for string0 in datasetImportJobArnsContainer {
                if let string0 = string0 {
                    datasetImportJobArnsDecoded0?.append(string0)
                }
            }
        }
        datasetImportJobArns = datasetImportJobArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
    }
}

enum DescribePredictorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWhatIfAnalysisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let whatIfAnalysisArn = self.whatIfAnalysisArn {
            try encodeContainer.encode(whatIfAnalysisArn, forKey: .whatIfAnalysisArn)
        }
    }
}

extension DescribeWhatIfAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWhatIfAnalysisInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if analysis that you are interested in.
    /// This member is required.
    public var whatIfAnalysisArn: Swift.String?

    public init(
        whatIfAnalysisArn: Swift.String? = nil
    )
    {
        self.whatIfAnalysisArn = whatIfAnalysisArn
    }
}

struct DescribeWhatIfAnalysisInputBody: Swift.Equatable {
    let whatIfAnalysisArn: Swift.String?
}

extension DescribeWhatIfAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
    }
}

extension DescribeWhatIfAnalysisOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWhatIfAnalysisOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.forecastArn = output.forecastArn
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
            self.timeSeriesSelector = output.timeSeriesSelector
            self.whatIfAnalysisArn = output.whatIfAnalysisArn
            self.whatIfAnalysisName = output.whatIfAnalysisName
        } else {
            self.creationTime = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.forecastArn = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
            self.timeSeriesSelector = nil
            self.whatIfAnalysisArn = nil
            self.whatIfAnalysisName = nil
        }
    }
}

public struct DescribeWhatIfAnalysisOutput: Swift.Equatable {
    /// When the what-if analysis was created.
    public var creationTime: ClientRuntime.Date?
    /// The approximate time remaining to complete the what-if analysis, in minutes.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The Amazon Resource Name (ARN) of the what-if forecast.
    public var forecastArn: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the what-if analysis. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the what-if analysis must be ACTIVE before you can access the analysis.
    public var status: Swift.String?
    /// Defines the set of time series that are used to create the forecasts in a TimeSeriesIdentifiers object. The TimeSeriesIdentifiers object needs the following information:
    ///
    /// * DataSource
    ///
    /// * Format
    ///
    /// * Schema
    public var timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?
    /// The Amazon Resource Name (ARN) of the what-if analysis.
    public var whatIfAnalysisArn: Swift.String?
    /// The name of the what-if analysis.
    public var whatIfAnalysisName: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        forecastArn: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil,
        timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector? = nil,
        whatIfAnalysisArn: Swift.String? = nil,
        whatIfAnalysisName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.forecastArn = forecastArn
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.timeSeriesSelector = timeSeriesSelector
        self.whatIfAnalysisArn = whatIfAnalysisArn
        self.whatIfAnalysisName = whatIfAnalysisName
    }
}

struct DescribeWhatIfAnalysisOutputBody: Swift.Equatable {
    let whatIfAnalysisName: Swift.String?
    let whatIfAnalysisArn: Swift.String?
    let forecastArn: Swift.String?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?
}

extension DescribeWhatIfAnalysisOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case forecastArn = "ForecastArn"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case timeSeriesSelector = "TimeSeriesSelector"
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
        case whatIfAnalysisName = "WhatIfAnalysisName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfAnalysisNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisName)
        whatIfAnalysisName = whatIfAnalysisNameDecoded
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let timeSeriesSelectorDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesSelector.self, forKey: .timeSeriesSelector)
        timeSeriesSelector = timeSeriesSelectorDecoded
    }
}

enum DescribeWhatIfAnalysisOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWhatIfForecastExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastExportArn = "WhatIfForecastExportArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let whatIfForecastExportArn = self.whatIfForecastExportArn {
            try encodeContainer.encode(whatIfForecastExportArn, forKey: .whatIfForecastExportArn)
        }
    }
}

extension DescribeWhatIfForecastExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWhatIfForecastExportInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if forecast export that you are interested in.
    /// This member is required.
    public var whatIfForecastExportArn: Swift.String?

    public init(
        whatIfForecastExportArn: Swift.String? = nil
    )
    {
        self.whatIfForecastExportArn = whatIfForecastExportArn
    }
}

struct DescribeWhatIfForecastExportInputBody: Swift.Equatable {
    let whatIfForecastExportArn: Swift.String?
}

extension DescribeWhatIfForecastExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastExportArn = "WhatIfForecastExportArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportArn)
        whatIfForecastExportArn = whatIfForecastExportArnDecoded
    }
}

extension DescribeWhatIfForecastExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWhatIfForecastExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.format = output.format
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
            self.whatIfForecastArns = output.whatIfForecastArns
            self.whatIfForecastExportArn = output.whatIfForecastExportArn
            self.whatIfForecastExportName = output.whatIfForecastExportName
        } else {
            self.creationTime = nil
            self.destination = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.format = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
            self.whatIfForecastArns = nil
            self.whatIfForecastExportArn = nil
            self.whatIfForecastExportName = nil
        }
    }
}

public struct DescribeWhatIfForecastExportOutput: Swift.Equatable {
    /// When the what-if forecast export was created.
    public var creationTime: ClientRuntime.Date?
    /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
    public var destination: ForecastClientTypes.DataDestination?
    /// The approximate time remaining to complete the what-if forecast export, in minutes.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the what-if forecast. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the what-if forecast export must be ACTIVE before you can access the forecast export.
    public var status: Swift.String?
    /// An array of Amazon Resource Names (ARNs) that represent all of the what-if forecasts exported in this resource.
    public var whatIfForecastArns: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the what-if forecast export.
    public var whatIfForecastExportArn: Swift.String?
    /// The name of the what-if forecast export.
    public var whatIfForecastExportName: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        format: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil,
        whatIfForecastArns: [Swift.String]? = nil,
        whatIfForecastExportArn: Swift.String? = nil,
        whatIfForecastExportName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.format = format
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.whatIfForecastArns = whatIfForecastArns
        self.whatIfForecastExportArn = whatIfForecastExportArn
        self.whatIfForecastExportName = whatIfForecastExportName
    }
}

struct DescribeWhatIfForecastExportOutputBody: Swift.Equatable {
    let whatIfForecastExportArn: Swift.String?
    let whatIfForecastExportName: Swift.String?
    let whatIfForecastArns: [Swift.String]?
    let destination: ForecastClientTypes.DataDestination?
    let message: Swift.String?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let lastModificationTime: ClientRuntime.Date?
    let format: Swift.String?
}

extension DescribeWhatIfForecastExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case format = "Format"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case whatIfForecastArns = "WhatIfForecastArns"
        case whatIfForecastExportArn = "WhatIfForecastExportArn"
        case whatIfForecastExportName = "WhatIfForecastExportName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportArn)
        whatIfForecastExportArn = whatIfForecastExportArnDecoded
        let whatIfForecastExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportName)
        whatIfForecastExportName = whatIfForecastExportNameDecoded
        let whatIfForecastArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whatIfForecastArns)
        var whatIfForecastArnsDecoded0:[Swift.String]? = nil
        if let whatIfForecastArnsContainer = whatIfForecastArnsContainer {
            whatIfForecastArnsDecoded0 = [Swift.String]()
            for string0 in whatIfForecastArnsContainer {
                if let string0 = string0 {
                    whatIfForecastArnsDecoded0?.append(string0)
                }
            }
        }
        whatIfForecastArns = whatIfForecastArnsDecoded0
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

enum DescribeWhatIfForecastExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWhatIfForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastArn = "WhatIfForecastArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let whatIfForecastArn = self.whatIfForecastArn {
            try encodeContainer.encode(whatIfForecastArn, forKey: .whatIfForecastArn)
        }
    }
}

extension DescribeWhatIfForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWhatIfForecastInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if forecast that you are interested in.
    /// This member is required.
    public var whatIfForecastArn: Swift.String?

    public init(
        whatIfForecastArn: Swift.String? = nil
    )
    {
        self.whatIfForecastArn = whatIfForecastArn
    }
}

struct DescribeWhatIfForecastInputBody: Swift.Equatable {
    let whatIfForecastArn: Swift.String?
}

extension DescribeWhatIfForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastArn = "WhatIfForecastArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastArn)
        whatIfForecastArn = whatIfForecastArnDecoded
    }
}

extension DescribeWhatIfForecastOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWhatIfForecastOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.forecastTypes = output.forecastTypes
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
            self.timeSeriesReplacementsDataSource = output.timeSeriesReplacementsDataSource
            self.timeSeriesTransformations = output.timeSeriesTransformations
            self.whatIfAnalysisArn = output.whatIfAnalysisArn
            self.whatIfForecastArn = output.whatIfForecastArn
            self.whatIfForecastName = output.whatIfForecastName
        } else {
            self.creationTime = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.forecastTypes = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
            self.timeSeriesReplacementsDataSource = nil
            self.timeSeriesTransformations = nil
            self.whatIfAnalysisArn = nil
            self.whatIfForecastArn = nil
            self.whatIfForecastName = nil
        }
    }
}

public struct DescribeWhatIfForecastOutput: Swift.Equatable {
    /// When the what-if forecast was created.
    public var creationTime: ClientRuntime.Date?
    /// The approximate time remaining to complete the what-if forecast, in minutes.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The quantiles at which probabilistic forecasts are generated. You can specify up to five quantiles per what-if forecast in the [CreateWhatIfForecast] operation. If you didn't specify quantiles, the default values are ["0.1", "0.5", "0.9"].
    public var forecastTypes: [Swift.String]?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the what-if forecast. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the what-if forecast must be ACTIVE before you can access the forecast.
    public var status: Swift.String?
    /// An array of S3Config, Schema, and Format elements that describe the replacement time series.
    public var timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource?
    /// An array of Action and TimeSeriesConditions elements that describe what transformations were applied to which time series.
    public var timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]?
    /// The Amazon Resource Name (ARN) of the what-if analysis that contains this forecast.
    public var whatIfAnalysisArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the what-if forecast.
    public var whatIfForecastArn: Swift.String?
    /// The name of the what-if forecast.
    public var whatIfForecastName: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil,
        timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource? = nil,
        timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]? = nil,
        whatIfAnalysisArn: Swift.String? = nil,
        whatIfForecastArn: Swift.String? = nil,
        whatIfForecastName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.forecastTypes = forecastTypes
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.timeSeriesReplacementsDataSource = timeSeriesReplacementsDataSource
        self.timeSeriesTransformations = timeSeriesTransformations
        self.whatIfAnalysisArn = whatIfAnalysisArn
        self.whatIfForecastArn = whatIfForecastArn
        self.whatIfForecastName = whatIfForecastName
    }
}

struct DescribeWhatIfForecastOutputBody: Swift.Equatable {
    let whatIfForecastName: Swift.String?
    let whatIfForecastArn: Swift.String?
    let whatIfAnalysisArn: Swift.String?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]?
    let timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource?
    let forecastTypes: [Swift.String]?
}

extension DescribeWhatIfForecastOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case forecastTypes = "ForecastTypes"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case timeSeriesReplacementsDataSource = "TimeSeriesReplacementsDataSource"
        case timeSeriesTransformations = "TimeSeriesTransformations"
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
        case whatIfForecastArn = "WhatIfForecastArn"
        case whatIfForecastName = "WhatIfForecastName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastName)
        whatIfForecastName = whatIfForecastNameDecoded
        let whatIfForecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastArn)
        whatIfForecastArn = whatIfForecastArnDecoded
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let timeSeriesTransformationsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.TimeSeriesTransformation?].self, forKey: .timeSeriesTransformations)
        var timeSeriesTransformationsDecoded0:[ForecastClientTypes.TimeSeriesTransformation]? = nil
        if let timeSeriesTransformationsContainer = timeSeriesTransformationsContainer {
            timeSeriesTransformationsDecoded0 = [ForecastClientTypes.TimeSeriesTransformation]()
            for structure0 in timeSeriesTransformationsContainer {
                if let structure0 = structure0 {
                    timeSeriesTransformationsDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesTransformations = timeSeriesTransformationsDecoded0
        let timeSeriesReplacementsDataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesReplacementsDataSource.self, forKey: .timeSeriesReplacementsDataSource)
        timeSeriesReplacementsDataSource = timeSeriesReplacementsDataSourceDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
    }
}

enum DescribeWhatIfForecastOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ForecastClientTypes {
    public enum Domain: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case ec2Capacity
        case inventoryPlanning
        case metrics
        case retail
        case webTraffic
        case workForce
        case sdkUnknown(Swift.String)

        public static var allCases: [Domain] {
            return [
                .custom,
                .ec2Capacity,
                .inventoryPlanning,
                .metrics,
                .retail,
                .webTraffic,
                .workForce,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .ec2Capacity: return "EC2_CAPACITY"
            case .inventoryPlanning: return "INVENTORY_PLANNING"
            case .metrics: return "METRICS"
            case .retail: return "RETAIL"
            case .webTraffic: return "WEB_TRAFFIC"
            case .workForce: return "WORK_FORCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Domain(rawValue: rawValue) ?? Domain.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.EncryptionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn = "KMSKeyArn"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension ForecastClientTypes {
    /// An Key Management Service (KMS) key and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key. You can specify this optional object in the [CreateDataset] and [CreatePredictor] requests.
    public struct EncryptionConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the KMS key.
        /// This member is required.
        public var kmsKeyArn: Swift.String?
        /// The ARN of the IAM role that Amazon Forecast can assume to access the KMS key. Passing a role across Amazon Web Services accounts is not allowed. If you pass a role that isn't in your account, you get an InvalidInputException error.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.roleArn = roleArn
        }
    }

}

extension ForecastClientTypes.ErrorMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastType = "ForecastType"
        case mape = "MAPE"
        case mase = "MASE"
        case rmse = "RMSE"
        case wape = "WAPE"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastType = self.forecastType {
            try encodeContainer.encode(forecastType, forKey: .forecastType)
        }
        if let mape = self.mape {
            try encodeContainer.encode(mape, forKey: .mape)
        }
        if let mase = self.mase {
            try encodeContainer.encode(mase, forKey: .mase)
        }
        if let rmse = self.rmse {
            try encodeContainer.encode(rmse, forKey: .rmse)
        }
        if let wape = self.wape {
            try encodeContainer.encode(wape, forKey: .wape)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastType)
        forecastType = forecastTypeDecoded
        let wapeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .wape)
        wape = wapeDecoded
        let rmseDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .rmse)
        rmse = rmseDecoded
        let maseDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .mase)
        mase = maseDecoded
        let mapeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .mape)
        mape = mapeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides detailed error metrics to evaluate the performance of a predictor. This object is part of the [Metrics] object.
    public struct ErrorMetric: Swift.Equatable {
        /// The Forecast type used to compute WAPE, MAPE, MASE, and RMSE.
        public var forecastType: Swift.String?
        /// The Mean Absolute Percentage Error (MAPE)
        public var mape: Swift.Double?
        /// The Mean Absolute Scaled Error (MASE)
        public var mase: Swift.Double?
        /// The root-mean-square error (RMSE).
        public var rmse: Swift.Double?
        /// The weighted absolute percentage error (WAPE).
        public var wape: Swift.Double?

        public init(
            forecastType: Swift.String? = nil,
            mape: Swift.Double? = nil,
            mase: Swift.Double? = nil,
            rmse: Swift.Double? = nil,
            wape: Swift.Double? = nil
        )
        {
            self.forecastType = forecastType
            self.mape = mape
            self.mase = mase
            self.rmse = rmse
            self.wape = wape
        }
    }

}

extension ForecastClientTypes.EvaluationParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backTestWindowOffset = "BackTestWindowOffset"
        case numberOfBacktestWindows = "NumberOfBacktestWindows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backTestWindowOffset = self.backTestWindowOffset {
            try encodeContainer.encode(backTestWindowOffset, forKey: .backTestWindowOffset)
        }
        if let numberOfBacktestWindows = self.numberOfBacktestWindows {
            try encodeContainer.encode(numberOfBacktestWindows, forKey: .numberOfBacktestWindows)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfBacktestWindowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfBacktestWindows)
        numberOfBacktestWindows = numberOfBacktestWindowsDecoded
        let backTestWindowOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backTestWindowOffset)
        backTestWindowOffset = backTestWindowOffsetDecoded
    }
}

extension ForecastClientTypes {
    /// Parameters that define how to split a dataset into training data and testing data, and the number of iterations to perform. These parameters are specified in the predefined algorithms but you can override them in the [CreatePredictor] request.
    public struct EvaluationParameters: Swift.Equatable {
        /// The point from the end of the dataset where you want to split the data for model training and testing (evaluation). Specify the value as the number of data points. The default is the value of the forecast horizon. BackTestWindowOffset can be used to mimic a past virtual forecast start date. This value must be greater than or equal to the forecast horizon and less than half of the TARGET_TIME_SERIES dataset length. ForecastHorizon <= BackTestWindowOffset < 1/2 * TARGET_TIME_SERIES dataset length
        public var backTestWindowOffset: Swift.Int?
        /// The number of times to split the input data. The default is 1. Valid values are 1 through 5.
        public var numberOfBacktestWindows: Swift.Int?

        public init(
            backTestWindowOffset: Swift.Int? = nil,
            numberOfBacktestWindows: Swift.Int? = nil
        )
        {
            self.backTestWindowOffset = backTestWindowOffset
            self.numberOfBacktestWindows = numberOfBacktestWindows
        }
    }

}

extension ForecastClientTypes.EvaluationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case testWindows = "TestWindows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = self.algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let testWindows = testWindows {
            var testWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .testWindows)
            for windowsummary0 in testWindows {
                try testWindowsContainer.encode(windowsummary0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let testWindowsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.WindowSummary?].self, forKey: .testWindows)
        var testWindowsDecoded0:[ForecastClientTypes.WindowSummary]? = nil
        if let testWindowsContainer = testWindowsContainer {
            testWindowsDecoded0 = [ForecastClientTypes.WindowSummary]()
            for structure0 in testWindowsContainer {
                if let structure0 = structure0 {
                    testWindowsDecoded0?.append(structure0)
                }
            }
        }
        testWindows = testWindowsDecoded0
    }
}

extension ForecastClientTypes {
    /// The results of evaluating an algorithm. Returned as part of the [GetAccuracyMetrics] response.
    public struct EvaluationResult: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the algorithm that was evaluated.
        public var algorithmArn: Swift.String?
        /// The array of test windows used for evaluating the algorithm. The NumberOfBacktestWindows from the [EvaluationParameters] object determines the number of windows in the array.
        public var testWindows: [ForecastClientTypes.WindowSummary]?

        public init(
            algorithmArn: Swift.String? = nil,
            testWindows: [ForecastClientTypes.WindowSummary]? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }
    }

}

extension ForecastClientTypes {
    public enum EvaluationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case computed
        case summary
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationType] {
            return [
                .computed,
                .summary,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .computed: return "COMPUTED"
            case .summary: return "SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationType(rawValue: rawValue) ?? EvaluationType.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.ExplainabilityConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timePointGranularity = "TimePointGranularity"
        case timeSeriesGranularity = "TimeSeriesGranularity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timePointGranularity = self.timePointGranularity {
            try encodeContainer.encode(timePointGranularity.rawValue, forKey: .timePointGranularity)
        }
        if let timeSeriesGranularity = self.timeSeriesGranularity {
            try encodeContainer.encode(timeSeriesGranularity.rawValue, forKey: .timeSeriesGranularity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesGranularityDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesGranularity.self, forKey: .timeSeriesGranularity)
        timeSeriesGranularity = timeSeriesGranularityDecoded
        let timePointGranularityDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimePointGranularity.self, forKey: .timePointGranularity)
        timePointGranularity = timePointGranularityDecoded
    }
}

extension ForecastClientTypes {
    /// The ExplainabilityConfig data type defines the number of time series and time points included in [CreateExplainability]. If you provide a predictor ARN for ResourceArn, you must set both TimePointGranularity and TimeSeriesGranularity to ALL. When creating Predictor Explainability, Amazon Forecast considers all time series and time points. If you provide a forecast ARN for ResourceArn, you can set TimePointGranularity and TimeSeriesGranularity to either ALL or Specific.
    public struct ExplainabilityConfig: Swift.Equatable {
        /// To create an Explainability for all time points in your forecast horizon, use ALL. To create an Explainability for specific time points in your forecast horizon, use SPECIFIC. Specify time points with the StartDateTime and EndDateTime parameters within the [CreateExplainability] operation.
        /// This member is required.
        public var timePointGranularity: ForecastClientTypes.TimePointGranularity?
        /// To create an Explainability for all time series in your datasets, use ALL. To create an Explainability for specific time series in your datasets, use SPECIFIC. Specify time series by uploading a CSV or Parquet file to an Amazon S3 bucket and set the location within the [DataDestination] data type.
        /// This member is required.
        public var timeSeriesGranularity: ForecastClientTypes.TimeSeriesGranularity?

        public init(
            timePointGranularity: ForecastClientTypes.TimePointGranularity? = nil,
            timeSeriesGranularity: ForecastClientTypes.TimeSeriesGranularity? = nil
        )
        {
            self.timePointGranularity = timePointGranularity
            self.timeSeriesGranularity = timeSeriesGranularity
        }
    }

}

extension ForecastClientTypes.ExplainabilityExportSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case explainabilityExportArn = "ExplainabilityExportArn"
        case explainabilityExportName = "ExplainabilityExportName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let explainabilityExportArn = self.explainabilityExportArn {
            try encodeContainer.encode(explainabilityExportArn, forKey: .explainabilityExportArn)
        }
        if let explainabilityExportName = self.explainabilityExportName {
            try encodeContainer.encode(explainabilityExportName, forKey: .explainabilityExportName)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
        let explainabilityExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportName)
        explainabilityExportName = explainabilityExportNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the Explainability export properties used in the [ListExplainabilityExports] operation. To get a complete set of properties, call the [DescribeExplainabilityExport] operation, and provide the ExplainabilityExportArn.
    public struct ExplainabilityExportSummary: Swift.Equatable {
        /// When the Explainability was created.
        public var creationTime: ClientRuntime.Date?
        /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
        public var destination: ForecastClientTypes.DataDestination?
        /// The Amazon Resource Name (ARN) of the Explainability export.
        public var explainabilityExportArn: Swift.String?
        /// The name of the Explainability export
        public var explainabilityExportName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// Information about any errors that may have occurred during the Explainability export.
        public var message: Swift.String?
        /// The status of the Explainability export. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            explainabilityExportArn: Swift.String? = nil,
            explainabilityExportName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.explainabilityExportArn = explainabilityExportArn
            self.explainabilityExportName = explainabilityExportName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }
    }

}

extension ForecastClientTypes.ExplainabilityInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityArn = self.explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ForecastClientTypes {
    /// Provides information about the Explainability resource.
    public struct ExplainabilityInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Explainability.
        public var explainabilityArn: Swift.String?
        /// The status of the Explainability. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init(
            explainabilityArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.explainabilityArn = explainabilityArn
            self.status = status
        }
    }

}

extension ForecastClientTypes.ExplainabilitySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityConfig = "ExplainabilityConfig"
        case explainabilityName = "ExplainabilityName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case resourceArn = "ResourceArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let explainabilityArn = self.explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
        if let explainabilityConfig = self.explainabilityConfig {
            try encodeContainer.encode(explainabilityConfig, forKey: .explainabilityConfig)
        }
        if let explainabilityName = self.explainabilityName {
            try encodeContainer.encode(explainabilityName, forKey: .explainabilityName)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let explainabilityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityName)
        explainabilityName = explainabilityNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let explainabilityConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ExplainabilityConfig.self, forKey: .explainabilityConfig)
        explainabilityConfig = explainabilityConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the Explainability properties used in the [ListExplainabilities] operation. To get a complete set of properties, call the [DescribeExplainability] operation, and provide the listed ExplainabilityArn.
    public struct ExplainabilitySummary: Swift.Equatable {
        /// When the Explainability was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the Explainability.
        public var explainabilityArn: Swift.String?
        /// The configuration settings that define the granularity of time series and time points for the Explainability.
        public var explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
        /// The name of the Explainability.
        public var explainabilityName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// Information about any errors that may have occurred during the Explainability creation process.
        public var message: Swift.String?
        /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability.
        public var resourceArn: Swift.String?
        /// The status of the Explainability. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            explainabilityArn: Swift.String? = nil,
            explainabilityConfig: ForecastClientTypes.ExplainabilityConfig? = nil,
            explainabilityName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.explainabilityArn = explainabilityArn
            self.explainabilityConfig = explainabilityConfig
            self.explainabilityName = explainabilityName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.resourceArn = resourceArn
            self.status = status
        }
    }

}

extension ForecastClientTypes.Featurization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case featurizationPipeline = "FeaturizationPipeline"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let featurizationPipeline = featurizationPipeline {
            var featurizationPipelineContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featurizationPipeline)
            for featurizationmethod0 in featurizationPipeline {
                try featurizationPipelineContainer.encode(featurizationmethod0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let featurizationPipelineContainer = try containerValues.decodeIfPresent([ForecastClientTypes.FeaturizationMethod?].self, forKey: .featurizationPipeline)
        var featurizationPipelineDecoded0:[ForecastClientTypes.FeaturizationMethod]? = nil
        if let featurizationPipelineContainer = featurizationPipelineContainer {
            featurizationPipelineDecoded0 = [ForecastClientTypes.FeaturizationMethod]()
            for structure0 in featurizationPipelineContainer {
                if let structure0 = structure0 {
                    featurizationPipelineDecoded0?.append(structure0)
                }
            }
        }
        featurizationPipeline = featurizationPipelineDecoded0
    }
}

extension ForecastClientTypes {
    /// This object belongs to the [CreatePredictor] operation. If you created your predictor with [CreateAutoPredictor], see [AttributeConfig]. Provides featurization (transformation) information for a dataset field. This object is part of the [FeaturizationConfig] object. For example: {
    ///     "AttributeName": "demand",
    ///
    ///
    ///     FeaturizationPipeline [ {
    ///
    ///
    ///     "FeaturizationMethodName": "filling",
    ///
    ///
    ///     "FeaturizationMethodParameters": {"aggregation": "avg", "backfill": "nan"}
    ///
    ///
    ///     } ]
    ///
    ///
    ///     }
    public struct Featurization: Swift.Equatable {
        /// The name of the schema attribute that specifies the data field to be featurized. Amazon Forecast supports the target field of the TARGET_TIME_SERIES and the RELATED_TIME_SERIES datasets. For example, for the RETAIL domain, the target is demand, and for the CUSTOM domain, the target is target_value. For more information, see [howitworks-missing-values].
        /// This member is required.
        public var attributeName: Swift.String?
        /// An array of one FeaturizationMethod object that specifies the feature transformation method.
        public var featurizationPipeline: [ForecastClientTypes.FeaturizationMethod]?

        public init(
            attributeName: Swift.String? = nil,
            featurizationPipeline: [ForecastClientTypes.FeaturizationMethod]? = nil
        )
        {
            self.attributeName = attributeName
            self.featurizationPipeline = featurizationPipeline
        }
    }

}

extension ForecastClientTypes.FeaturizationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featurizations = "Featurizations"
        case forecastDimensions = "ForecastDimensions"
        case forecastFrequency = "ForecastFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featurizations = featurizations {
            var featurizationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featurizations)
            for featurization0 in featurizations {
                try featurizationsContainer.encode(featurization0)
            }
        }
        if let forecastDimensions = forecastDimensions {
            var forecastDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastDimensions)
            for name0 in forecastDimensions {
                try forecastDimensionsContainer.encode(name0)
            }
        }
        if let forecastFrequency = self.forecastFrequency {
            try encodeContainer.encode(forecastFrequency, forKey: .forecastFrequency)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastFrequency)
        forecastFrequency = forecastFrequencyDecoded
        let forecastDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastDimensions)
        var forecastDimensionsDecoded0:[Swift.String]? = nil
        if let forecastDimensionsContainer = forecastDimensionsContainer {
            forecastDimensionsDecoded0 = [Swift.String]()
            for string0 in forecastDimensionsContainer {
                if let string0 = string0 {
                    forecastDimensionsDecoded0?.append(string0)
                }
            }
        }
        forecastDimensions = forecastDimensionsDecoded0
        let featurizationsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Featurization?].self, forKey: .featurizations)
        var featurizationsDecoded0:[ForecastClientTypes.Featurization]? = nil
        if let featurizationsContainer = featurizationsContainer {
            featurizationsDecoded0 = [ForecastClientTypes.Featurization]()
            for structure0 in featurizationsContainer {
                if let structure0 = structure0 {
                    featurizationsDecoded0?.append(structure0)
                }
            }
        }
        featurizations = featurizationsDecoded0
    }
}

extension ForecastClientTypes {
    /// This object belongs to the [CreatePredictor] operation. If you created your predictor with [CreateAutoPredictor], see [AttributeConfig]. In a [CreatePredictor] operation, the specified algorithm trains a model using the specified dataset group. You can optionally tell the operation to modify data fields prior to training a model. These modifications are referred to as featurization. You define featurization using the FeaturizationConfig object. You specify an array of transformations, one for each field that you want to featurize. You then include the FeaturizationConfig object in your CreatePredictor request. Amazon Forecast applies the featurization to the TARGET_TIME_SERIES and RELATED_TIME_SERIES datasets before model training. You can create multiple featurization configurations. For example, you might call the CreatePredictor operation twice by specifying different featurization configurations.
    public struct FeaturizationConfig: Swift.Equatable {
        /// An array of featurization (transformation) information for the fields of a dataset.
        public var featurizations: [ForecastClientTypes.Featurization]?
        /// An array of dimension (field) names that specify how to group the generated forecast. For example, suppose that you are generating a forecast for item sales across all of your stores, and your dataset contains a store_id field. If you want the sales forecast for each item by store, you would specify store_id as the dimension. All forecast dimensions specified in the TARGET_TIME_SERIES dataset don't need to be specified in the CreatePredictor request. All forecast dimensions specified in the RELATED_TIME_SERIES dataset must be specified in the CreatePredictor request.
        public var forecastDimensions: [Swift.String]?
        /// The frequency of predictions in a forecast. Valid intervals are an integer followed by Y (Year), M (Month), W (Week), D (Day), H (Hour), and min (Minute). For example, "1D" indicates every day and "15min" indicates every 15 minutes. You cannot specify a value that would overlap with the next larger frequency. That means, for example, you cannot specify a frequency of 60 minutes, because that is equivalent to 1 hour. The valid values for each frequency are the following:
        ///
        /// * Minute - 1-59
        ///
        /// * Hour - 1-23
        ///
        /// * Day - 1-6
        ///
        /// * Week - 1-4
        ///
        /// * Month - 1-11
        ///
        /// * Year - 1
        ///
        ///
        /// Thus, if you want every other week forecasts, specify "2W". Or, if you want quarterly forecasts, you specify "3M". The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency. When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the TARGET_TIME_SERIES dataset frequency.
        /// This member is required.
        public var forecastFrequency: Swift.String?

        public init(
            featurizations: [ForecastClientTypes.Featurization]? = nil,
            forecastDimensions: [Swift.String]? = nil,
            forecastFrequency: Swift.String? = nil
        )
        {
            self.featurizations = featurizations
            self.forecastDimensions = forecastDimensions
            self.forecastFrequency = forecastFrequency
        }
    }

}

extension ForecastClientTypes.FeaturizationMethod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featurizationMethodName = "FeaturizationMethodName"
        case featurizationMethodParameters = "FeaturizationMethodParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featurizationMethodName = self.featurizationMethodName {
            try encodeContainer.encode(featurizationMethodName.rawValue, forKey: .featurizationMethodName)
        }
        if let featurizationMethodParameters = featurizationMethodParameters {
            var featurizationMethodParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .featurizationMethodParameters)
            for (dictKey0, featurizationMethodParameters0) in featurizationMethodParameters {
                try featurizationMethodParametersContainer.encode(featurizationMethodParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featurizationMethodNameDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FeaturizationMethodName.self, forKey: .featurizationMethodName)
        featurizationMethodName = featurizationMethodNameDecoded
        let featurizationMethodParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .featurizationMethodParameters)
        var featurizationMethodParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let featurizationMethodParametersContainer = featurizationMethodParametersContainer {
            featurizationMethodParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in featurizationMethodParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    featurizationMethodParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        featurizationMethodParameters = featurizationMethodParametersDecoded0
    }
}

extension ForecastClientTypes {
    /// Provides information about the method that featurizes (transforms) a dataset field. The method is part of the FeaturizationPipeline of the [Featurization] object. The following is an example of how you specify a FeaturizationMethod object. {
    ///     "FeaturizationMethodName": "filling",
    ///
    ///
    ///     "FeaturizationMethodParameters": {"aggregation": "sum", "middlefill": "zero", "backfill": "zero"}
    ///
    ///
    ///     }
    public struct FeaturizationMethod: Swift.Equatable {
        /// The name of the method. The "filling" method is the only supported method.
        /// This member is required.
        public var featurizationMethodName: ForecastClientTypes.FeaturizationMethodName?
        /// The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters. The following list shows the parameters and their valid values for the "filling" featurization method for a Target Time Series dataset. Bold signifies the default value.
        ///
        /// * aggregation: sum, avg, first, min, max
        ///
        /// * frontfill: none
        ///
        /// * middlefill: zero, nan (not a number), value, median, mean, min, max
        ///
        /// * backfill: zero, nan, value, median, mean, min, max
        ///
        ///
        /// The following list shows the parameters and their valid values for a Related Time Series featurization method (there are no defaults):
        ///
        /// * middlefill: zero, value, median, mean, min, max
        ///
        /// * backfill: zero, value, median, mean, min, max
        ///
        /// * futurefill: zero, value, median, mean, min, max
        ///
        ///
        /// To set a filling method to a specific value, set the fill parameter to value and define the value in a corresponding _value parameter. For example, to set backfilling to a value of 2, include the following: "backfill": "value" and "backfill_value":"2".
        public var featurizationMethodParameters: [Swift.String:Swift.String]?

        public init(
            featurizationMethodName: ForecastClientTypes.FeaturizationMethodName? = nil,
            featurizationMethodParameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.featurizationMethodName = featurizationMethodName
            self.featurizationMethodParameters = featurizationMethodParameters
        }
    }

}

extension ForecastClientTypes {
    public enum FeaturizationMethodName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case filling
        case sdkUnknown(Swift.String)

        public static var allCases: [FeaturizationMethodName] {
            return [
                .filling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .filling: return "filling"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeaturizationMethodName(rawValue: rawValue) ?? FeaturizationMethodName.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FilterConditionString.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ForecastClientTypes {
    /// Describes a filter for choosing a subset of objects. Each filter consists of a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the objects that match the statement, respectively. The match statement consists of a key and a value.
    public struct Filter: Swift.Equatable {
        /// The condition to apply. To include the objects that match the statement, specify IS. To exclude matching objects, specify IS_NOT.
        /// This member is required.
        public var condition: ForecastClientTypes.FilterConditionString?
        /// The name of the parameter to filter on.
        /// This member is required.
        public var key: Swift.String?
        /// The value to match.
        /// This member is required.
        public var value: Swift.String?

        public init(
            condition: ForecastClientTypes.FilterConditionString? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.condition = condition
            self.key = key
            self.value = value
        }
    }

}

extension ForecastClientTypes {
    public enum FilterConditionString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `is`
        case isNot
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterConditionString] {
            return [
                .is,
                .isNot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .is: return "IS"
            case .isNot: return "IS_NOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterConditionString(rawValue: rawValue) ?? FilterConditionString.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.ForecastExportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case forecastExportJobArn = "ForecastExportJobArn"
        case forecastExportJobName = "ForecastExportJobName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let forecastExportJobArn = self.forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
        if let forecastExportJobName = self.forecastExportJobName {
            try encodeContainer.encode(forecastExportJobName, forKey: .forecastExportJobName)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the forecast export job properties used in the [ListForecastExportJobs] operation. To get the complete set of properties, call the [DescribeForecastExportJob] operation, and provide the listed ForecastExportJobArn.
    public struct ForecastExportJobSummary: Swift.Equatable {
        /// When the forecast export job was created.
        public var creationTime: ClientRuntime.Date?
        /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
        public var destination: ForecastClientTypes.DataDestination?
        /// The Amazon Resource Name (ARN) of the forecast export job.
        public var forecastExportJobArn: Swift.String?
        /// The name of the forecast export job.
        public var forecastExportJobName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the forecast export job. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the forecast export job must be ACTIVE before you can access the forecast in your S3 bucket.
        public var status: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            forecastExportJobArn: Swift.String? = nil,
            forecastExportJobName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.forecastExportJobArn = forecastExportJobArn
            self.forecastExportJobName = forecastExportJobName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }
    }

}

extension ForecastClientTypes.ForecastSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdUsingAutoPredictor = "CreatedUsingAutoPredictor"
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case forecastArn = "ForecastArn"
        case forecastName = "ForecastName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdUsingAutoPredictor = self.createdUsingAutoPredictor {
            try encodeContainer.encode(createdUsingAutoPredictor, forKey: .createdUsingAutoPredictor)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let forecastArn = self.forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let forecastName = self.forecastName {
            try encodeContainer.encode(forecastName, forKey: .forecastName)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let forecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let createdUsingAutoPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createdUsingAutoPredictor)
        createdUsingAutoPredictor = createdUsingAutoPredictorDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the forecast properties used in the [ListForecasts] operation. To get the complete set of properties, call the [DescribeForecast] operation, and provide the ForecastArn that is listed in the summary.
    public struct ForecastSummary: Swift.Equatable {
        /// Whether the Forecast was created from an AutoPredictor.
        public var createdUsingAutoPredictor: Swift.Bool?
        /// When the forecast creation task was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that provided the data used to train the predictor.
        public var datasetGroupArn: Swift.String?
        /// The ARN of the forecast.
        public var forecastArn: Swift.String?
        /// The name of the forecast.
        public var forecastName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The ARN of the predictor used to generate the forecast.
        public var predictorArn: Swift.String?
        /// The status of the forecast. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the forecast must be ACTIVE before you can query or export the forecast.
        public var status: Swift.String?

        public init(
            createdUsingAutoPredictor: Swift.Bool? = nil,
            creationTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            forecastArn: Swift.String? = nil,
            forecastName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            predictorArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.createdUsingAutoPredictor = createdUsingAutoPredictor
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.forecastArn = forecastArn
            self.forecastName = forecastName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.status = status
        }
    }

}

extension GetAccuracyMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

extension GetAccuracyMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccuracyMetricsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor to get metrics for.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init(
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct GetAccuracyMetricsInputBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension GetAccuracyMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension GetAccuracyMetricsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccuracyMetricsOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoMLOverrideStrategy = output.autoMLOverrideStrategy
            self.isAutoPredictor = output.isAutoPredictor
            self.optimizationMetric = output.optimizationMetric
            self.predictorEvaluationResults = output.predictorEvaluationResults
        } else {
            self.autoMLOverrideStrategy = nil
            self.isAutoPredictor = nil
            self.optimizationMetric = nil
            self.predictorEvaluationResults = nil
        }
    }
}

public struct GetAccuracyMetricsOutput: Swift.Equatable {
    /// The LatencyOptimized AutoML override strategy is only available in private beta. Contact Amazon Web Services Support or your account manager to learn more about access privileges. The AutoML strategy used to train the predictor. Unless LatencyOptimized is specified, the AutoML strategy optimizes predictor accuracy. This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// Whether the predictor was created with [CreateAutoPredictor].
    public var isAutoPredictor: Swift.Bool?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// An array of results from evaluating the predictor.
    public var predictorEvaluationResults: [ForecastClientTypes.EvaluationResult]?

    public init(
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        isAutoPredictor: Swift.Bool? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        predictorEvaluationResults: [ForecastClientTypes.EvaluationResult]? = nil
    )
    {
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.isAutoPredictor = isAutoPredictor
        self.optimizationMetric = optimizationMetric
        self.predictorEvaluationResults = predictorEvaluationResults
    }
}

struct GetAccuracyMetricsOutputBody: Swift.Equatable {
    let predictorEvaluationResults: [ForecastClientTypes.EvaluationResult]?
    let isAutoPredictor: Swift.Bool?
    let autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
}

extension GetAccuracyMetricsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case isAutoPredictor = "IsAutoPredictor"
        case optimizationMetric = "OptimizationMetric"
        case predictorEvaluationResults = "PredictorEvaluationResults"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorEvaluationResultsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.EvaluationResult?].self, forKey: .predictorEvaluationResults)
        var predictorEvaluationResultsDecoded0:[ForecastClientTypes.EvaluationResult]? = nil
        if let predictorEvaluationResultsContainer = predictorEvaluationResultsContainer {
            predictorEvaluationResultsDecoded0 = [ForecastClientTypes.EvaluationResult]()
            for structure0 in predictorEvaluationResultsContainer {
                if let structure0 = structure0 {
                    predictorEvaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        predictorEvaluationResults = predictorEvaluationResultsDecoded0
        let isAutoPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAutoPredictor)
        isAutoPredictor = isAutoPredictorDecoded
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
    }
}

enum GetAccuracyMetricsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ForecastClientTypes.HyperParameterTuningJobConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterRanges = "ParameterRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterRanges = self.parameterRanges {
            try encodeContainer.encode(parameterRanges, forKey: .parameterRanges)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterRangesDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ParameterRanges.self, forKey: .parameterRanges)
        parameterRanges = parameterRangesDecoded
    }
}

extension ForecastClientTypes {
    /// Configuration information for a hyperparameter tuning job. You specify this object in the [CreatePredictor] request. A hyperparameter is a parameter that governs the model training process. You set hyperparameters before training starts, unlike model parameters, which are determined during training. The values of the hyperparameters effect which values are chosen for the model parameters. In a hyperparameter tuning job, Amazon Forecast chooses the set of hyperparameter values that optimize a specified metric. Forecast accomplishes this by running many training jobs over a range of hyperparameter values. The optimum set of values depends on the algorithm, the training data, and the specified metric objective.
    public struct HyperParameterTuningJobConfig: Swift.Equatable {
        /// Specifies the ranges of valid values for the hyperparameters.
        public var parameterRanges: ForecastClientTypes.ParameterRanges?

        public init(
            parameterRanges: ForecastClientTypes.ParameterRanges? = nil
        )
        {
            self.parameterRanges = parameterRanges
        }
    }

}

extension ForecastClientTypes {
    public enum ImportMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case incremental
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportMode] {
            return [
                .full,
                .incremental,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .incremental: return "INCREMENTAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportMode(rawValue: rawValue) ?? ImportMode.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.InputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
        case supplementaryFeatures = "SupplementaryFeatures"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let supplementaryFeatures = supplementaryFeatures {
            var supplementaryFeaturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supplementaryFeatures)
            for supplementaryfeature0 in supplementaryFeatures {
                try supplementaryFeaturesContainer.encode(supplementaryfeature0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let supplementaryFeaturesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.SupplementaryFeature?].self, forKey: .supplementaryFeatures)
        var supplementaryFeaturesDecoded0:[ForecastClientTypes.SupplementaryFeature]? = nil
        if let supplementaryFeaturesContainer = supplementaryFeaturesContainer {
            supplementaryFeaturesDecoded0 = [ForecastClientTypes.SupplementaryFeature]()
            for structure0 in supplementaryFeaturesContainer {
                if let structure0 = structure0 {
                    supplementaryFeaturesDecoded0?.append(structure0)
                }
            }
        }
        supplementaryFeatures = supplementaryFeaturesDecoded0
    }
}

extension ForecastClientTypes {
    /// This object belongs to the [CreatePredictor] operation. If you created your predictor with [CreateAutoPredictor], see [DataConfig]. The data used to train a predictor. The data includes a dataset group and any supplementary features. You specify this object in the [CreatePredictor] request.
    public struct InputDataConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the dataset group.
        /// This member is required.
        public var datasetGroupArn: Swift.String?
        /// An array of supplementary features. The only supported feature is a holiday calendar.
        public var supplementaryFeatures: [ForecastClientTypes.SupplementaryFeature]?

        public init(
            datasetGroupArn: Swift.String? = nil,
            supplementaryFeatures: [ForecastClientTypes.SupplementaryFeature]? = nil
        )
        {
            self.datasetGroupArn = datasetGroupArn
            self.supplementaryFeatures = supplementaryFeatures
        }
    }

}

extension ForecastClientTypes.IntegerParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxValue = "MaxValue"
        case minValue = "MinValue"
        case name = "Name"
        case scalingType = "ScalingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxValue = self.maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minValue = self.minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scalingType = self.scalingType {
            try encodeContainer.encode(scalingType.rawValue, forKey: .scalingType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minValue)
        minValue = minValueDecoded
        let scalingTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ScalingType.self, forKey: .scalingType)
        scalingType = scalingTypeDecoded
    }
}

extension ForecastClientTypes {
    /// Specifies an integer hyperparameter and it's range of tunable values. This object is part of the [ParameterRanges] object.
    public struct IntegerParameterRange: Swift.Equatable {
        /// The maximum tunable value of the hyperparameter.
        /// This member is required.
        public var maxValue: Swift.Int?
        /// The minimum tunable value of the hyperparameter.
        /// This member is required.
        public var minValue: Swift.Int?
        /// The name of the hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values: Auto Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter. Linear Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale. Logarithmic Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have values greater than 0. ReverseLogarithmic Not supported for IntegerParameterRange. Reverse logarithmic scaling works only for ranges that are entirely within the range 0 <= x < 1.0. For information about choosing a hyperparameter scale, see [Hyperparameter Scaling](http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type). One of the following values:
        public var scalingType: ForecastClientTypes.ScalingType?

        public init(
            maxValue: Swift.Int? = nil,
            minValue: Swift.Int? = nil,
            name: Swift.String? = nil,
            scalingType: ForecastClientTypes.ScalingType? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }
    }

}

extension InvalidInputException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can't process the request because it includes an invalid value or a value that exceeds the valid range.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The token is not valid. Tokens expire after 24 hours.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The limit on the number of resources per account has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDatasetGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetGroupsInput: Swift.Equatable {
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDatasetGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroups = output.datasetGroups
            self.nextToken = output.nextToken
        } else {
            self.datasetGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetGroupsOutput: Swift.Equatable {
    /// An array of objects that summarize each dataset group's properties.
    public var datasetGroups: [ForecastClientTypes.DatasetGroupSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        datasetGroups: [ForecastClientTypes.DatasetGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroups = datasetGroups
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsOutputBody: Swift.Equatable {
    let datasetGroups: [ForecastClientTypes.DatasetGroupSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroups = "DatasetGroups"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.DatasetGroupSummary?].self, forKey: .datasetGroups)
        var datasetGroupsDecoded0:[ForecastClientTypes.DatasetGroupSummary]? = nil
        if let datasetGroupsContainer = datasetGroupsContainer {
            datasetGroupsDecoded0 = [ForecastClientTypes.DatasetGroupSummary]()
            for structure0 in datasetGroupsContainer {
                if let structure0 = structure0 {
                    datasetGroupsDecoded0?.append(structure0)
                }
            }
        }
        datasetGroups = datasetGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDatasetGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDatasetImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetImportJobsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the datasets that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the datasets that match the statement, specify IS. To exclude matching datasets, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are DatasetArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all dataset import jobs whose status is ACTIVE, you specify the following filter: "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListDatasetImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListDatasetImportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDatasetImportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJobs = output.datasetImportJobs
            self.nextToken = output.nextToken
        } else {
            self.datasetImportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetImportJobsOutput: Swift.Equatable {
    /// An array of objects that summarize each dataset import job's properties.
    public var datasetImportJobs: [ForecastClientTypes.DatasetImportJobSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        datasetImportJobs: [ForecastClientTypes.DatasetImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetImportJobs = datasetImportJobs
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsOutputBody: Swift.Equatable {
    let datasetImportJobs: [ForecastClientTypes.DatasetImportJobSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetImportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobs = "DatasetImportJobs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.DatasetImportJobSummary?].self, forKey: .datasetImportJobs)
        var datasetImportJobsDecoded0:[ForecastClientTypes.DatasetImportJobSummary]? = nil
        if let datasetImportJobsContainer = datasetImportJobsContainer {
            datasetImportJobsDecoded0 = [ForecastClientTypes.DatasetImportJobSummary]()
            for structure0 in datasetImportJobsContainer {
                if let structure0 = structure0 {
                    datasetImportJobsDecoded0?.append(structure0)
                }
            }
        }
        datasetImportJobs = datasetImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDatasetImportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDatasetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetsInput: Swift.Equatable {
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDatasetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetsOutput: Swift.Equatable {
    /// An array of objects that summarize each dataset's properties.
    public var datasets: [ForecastClientTypes.DatasetSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        datasets: [ForecastClientTypes.DatasetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputBody: Swift.Equatable {
    let datasets: [ForecastClientTypes.DatasetSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasets = "Datasets"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.DatasetSummary?].self, forKey: .datasets)
        var datasetsDecoded0:[ForecastClientTypes.DatasetSummary]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [ForecastClientTypes.DatasetSummary]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDatasetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListExplainabilitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListExplainabilitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListExplainabilitiesInput: Swift.Equatable {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the resources that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are ResourceArn and Status.
    ///
    /// * Value - The value to match.
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items returned in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExplainabilitiesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListExplainabilitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListExplainabilitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExplainabilitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.explainabilities = output.explainabilities
            self.nextToken = output.nextToken
        } else {
            self.explainabilities = nil
            self.nextToken = nil
        }
    }
}

public struct ListExplainabilitiesOutput: Swift.Equatable {
    /// An array of objects that summarize the properties of each Explainability resource.
    public var explainabilities: [ForecastClientTypes.ExplainabilitySummary]?
    /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        explainabilities: [ForecastClientTypes.ExplainabilitySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.explainabilities = explainabilities
        self.nextToken = nextToken
    }
}

struct ListExplainabilitiesOutputBody: Swift.Equatable {
    let explainabilities: [ForecastClientTypes.ExplainabilitySummary]?
    let nextToken: Swift.String?
}

extension ListExplainabilitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilities = "Explainabilities"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilitiesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ExplainabilitySummary?].self, forKey: .explainabilities)
        var explainabilitiesDecoded0:[ForecastClientTypes.ExplainabilitySummary]? = nil
        if let explainabilitiesContainer = explainabilitiesContainer {
            explainabilitiesDecoded0 = [ForecastClientTypes.ExplainabilitySummary]()
            for structure0 in explainabilitiesContainer {
                if let structure0 = structure0 {
                    explainabilitiesDecoded0?.append(structure0)
                }
            }
        }
        explainabilities = explainabilitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExplainabilitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListExplainabilityExportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListExplainabilityExportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListExplainabilityExportsInput: Swift.Equatable {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude resources that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are ResourceArn and Status.
    ///
    /// * Value - The value to match.
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExplainabilityExportsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListExplainabilityExportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListExplainabilityExportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExplainabilityExportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.explainabilityExports = output.explainabilityExports
            self.nextToken = output.nextToken
        } else {
            self.explainabilityExports = nil
            self.nextToken = nil
        }
    }
}

public struct ListExplainabilityExportsOutput: Swift.Equatable {
    /// An array of objects that summarize the properties of each Explainability export.
    public var explainabilityExports: [ForecastClientTypes.ExplainabilityExportSummary]?
    /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        explainabilityExports: [ForecastClientTypes.ExplainabilityExportSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.explainabilityExports = explainabilityExports
        self.nextToken = nextToken
    }
}

struct ListExplainabilityExportsOutputBody: Swift.Equatable {
    let explainabilityExports: [ForecastClientTypes.ExplainabilityExportSummary]?
    let nextToken: Swift.String?
}

extension ListExplainabilityExportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExports = "ExplainabilityExports"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ExplainabilityExportSummary?].self, forKey: .explainabilityExports)
        var explainabilityExportsDecoded0:[ForecastClientTypes.ExplainabilityExportSummary]? = nil
        if let explainabilityExportsContainer = explainabilityExportsContainer {
            explainabilityExportsDecoded0 = [ForecastClientTypes.ExplainabilityExportSummary]()
            for structure0 in explainabilityExportsContainer {
                if let structure0 = structure0 {
                    explainabilityExportsDecoded0?.append(structure0)
                }
            }
        }
        explainabilityExports = explainabilityExportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExplainabilityExportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListForecastExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListForecastExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListForecastExportJobsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the forecast export jobs that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecast export jobs that match the statement, specify IS. To exclude matching forecast export jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are ForecastArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all jobs that export a forecast named electricityforecast, specify the following filter: "Filters": [ { "Condition": "IS", "Key": "ForecastArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityforecast" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListForecastExportJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListForecastExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListForecastExportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListForecastExportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.forecastExportJobs = output.forecastExportJobs
            self.nextToken = output.nextToken
        } else {
            self.forecastExportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListForecastExportJobsOutput: Swift.Equatable {
    /// An array of objects that summarize each export job's properties.
    public var forecastExportJobs: [ForecastClientTypes.ForecastExportJobSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        forecastExportJobs: [ForecastClientTypes.ForecastExportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.forecastExportJobs = forecastExportJobs
        self.nextToken = nextToken
    }
}

struct ListForecastExportJobsOutputBody: Swift.Equatable {
    let forecastExportJobs: [ForecastClientTypes.ForecastExportJobSummary]?
    let nextToken: Swift.String?
}

extension ListForecastExportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobs = "ForecastExportJobs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ForecastExportJobSummary?].self, forKey: .forecastExportJobs)
        var forecastExportJobsDecoded0:[ForecastClientTypes.ForecastExportJobSummary]? = nil
        if let forecastExportJobsContainer = forecastExportJobsContainer {
            forecastExportJobsDecoded0 = [ForecastClientTypes.ForecastExportJobSummary]()
            for structure0 in forecastExportJobsContainer {
                if let structure0 = structure0 {
                    forecastExportJobsDecoded0?.append(structure0)
                }
            }
        }
        forecastExportJobs = forecastExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListForecastExportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListForecastsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListForecastsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListForecastsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the forecasts that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecasts that match the statement, specify IS. To exclude matching forecasts, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are DatasetGroupArn, PredictorArn, and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all forecasts whose status is not ACTIVE, you would specify: "Filters": [ { "Condition": "IS_NOT", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListForecastsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListForecastsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListForecastsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListForecastsOutputBody = try responseDecoder.decode(responseBody: data)
            self.forecasts = output.forecasts
            self.nextToken = output.nextToken
        } else {
            self.forecasts = nil
            self.nextToken = nil
        }
    }
}

public struct ListForecastsOutput: Swift.Equatable {
    /// An array of objects that summarize each forecast's properties.
    public var forecasts: [ForecastClientTypes.ForecastSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        forecasts: [ForecastClientTypes.ForecastSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.forecasts = forecasts
        self.nextToken = nextToken
    }
}

struct ListForecastsOutputBody: Swift.Equatable {
    let forecasts: [ForecastClientTypes.ForecastSummary]?
    let nextToken: Swift.String?
}

extension ListForecastsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecasts = "Forecasts"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ForecastSummary?].self, forKey: .forecasts)
        var forecastsDecoded0:[ForecastClientTypes.ForecastSummary]? = nil
        if let forecastsContainer = forecastsContainer {
            forecastsDecoded0 = [ForecastClientTypes.ForecastSummary]()
            for structure0 in forecastsContainer {
                if let structure0 = structure0 {
                    forecastsDecoded0?.append(structure0)
                }
            }
        }
        forecasts = forecastsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListForecastsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMonitorEvaluationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMonitorEvaluationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMonitorEvaluationsInput: Swift.Equatable {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the resources that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. The only valid value is EvaluationState.
    ///
    /// * Value - The value to match. Valid values are only SUCCESS or FAILURE.
    ///
    ///
    /// For example, to list only successful monitor evaluations, you would specify: "Filters": [ { "Condition": "IS", "Key": "EvaluationState", "Value": "SUCCESS" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The maximum number of monitoring results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the monitor resource to get results from.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        monitorArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.monitorArn = monitorArn
        self.nextToken = nextToken
    }
}

struct ListMonitorEvaluationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let monitorArn: Swift.String?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListMonitorEvaluationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListMonitorEvaluationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMonitorEvaluationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.predictorMonitorEvaluations = output.predictorMonitorEvaluations
        } else {
            self.nextToken = nil
            self.predictorMonitorEvaluations = nil
        }
    }
}

public struct ListMonitorEvaluationsOutput: Swift.Equatable {
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?
    /// The monitoring results and predictor events collected by the monitor resource during different windows of time. For information about monitoring see [Viewing Monitoring Results](https://docs.aws.amazon.com/forecast/latest/dg/predictor-monitoring-results.html). For more information about retrieving monitoring results see [Viewing Monitoring Results](https://docs.aws.amazon.com/forecast/latest/dg/predictor-monitoring-results.html).
    public var predictorMonitorEvaluations: [ForecastClientTypes.PredictorMonitorEvaluation]?

    public init(
        nextToken: Swift.String? = nil,
        predictorMonitorEvaluations: [ForecastClientTypes.PredictorMonitorEvaluation]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictorMonitorEvaluations = predictorMonitorEvaluations
    }
}

struct ListMonitorEvaluationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let predictorMonitorEvaluations: [ForecastClientTypes.PredictorMonitorEvaluation]?
}

extension ListMonitorEvaluationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case predictorMonitorEvaluations = "PredictorMonitorEvaluations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let predictorMonitorEvaluationsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.PredictorMonitorEvaluation?].self, forKey: .predictorMonitorEvaluations)
        var predictorMonitorEvaluationsDecoded0:[ForecastClientTypes.PredictorMonitorEvaluation]? = nil
        if let predictorMonitorEvaluationsContainer = predictorMonitorEvaluationsContainer {
            predictorMonitorEvaluationsDecoded0 = [ForecastClientTypes.PredictorMonitorEvaluation]()
            for structure0 in predictorMonitorEvaluationsContainer {
                if let structure0 = structure0 {
                    predictorMonitorEvaluationsDecoded0?.append(structure0)
                }
            }
        }
        predictorMonitorEvaluations = predictorMonitorEvaluationsDecoded0
    }
}

enum ListMonitorEvaluationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMonitorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMonitorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMonitorsInput: Swift.Equatable {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the resources that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. The only valid value is Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all monitors who's status is ACTIVE, you would specify: "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The maximum number of monitors to include in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMonitorsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListMonitorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListMonitorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMonitorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.monitors = output.monitors
            self.nextToken = output.nextToken
        } else {
            self.monitors = nil
            self.nextToken = nil
        }
    }
}

public struct ListMonitorsOutput: Swift.Equatable {
    /// An array of objects that summarize each monitor's properties.
    public var monitors: [ForecastClientTypes.MonitorSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        monitors: [ForecastClientTypes.MonitorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.monitors = monitors
        self.nextToken = nextToken
    }
}

struct ListMonitorsOutputBody: Swift.Equatable {
    let monitors: [ForecastClientTypes.MonitorSummary]?
    let nextToken: Swift.String?
}

extension ListMonitorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitors = "Monitors"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.MonitorSummary?].self, forKey: .monitors)
        var monitorsDecoded0:[ForecastClientTypes.MonitorSummary]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [ForecastClientTypes.MonitorSummary]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMonitorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPredictorBacktestExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPredictorBacktestExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPredictorBacktestExportJobsInput: Swift.Equatable {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the predictor backtest export jobs that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the predictor backtest export jobs that match the statement, specify IS. To exclude matching predictor backtest export jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are PredictorArn and Status.
    ///
    /// * Value - The value to match.
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPredictorBacktestExportJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListPredictorBacktestExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListPredictorBacktestExportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPredictorBacktestExportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.predictorBacktestExportJobs = output.predictorBacktestExportJobs
        } else {
            self.nextToken = nil
            self.predictorBacktestExportJobs = nil
        }
    }
}

public struct ListPredictorBacktestExportJobsOutput: Swift.Equatable {
    /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of objects that summarize the properties of each predictor backtest export job.
    public var predictorBacktestExportJobs: [ForecastClientTypes.PredictorBacktestExportJobSummary]?

    public init(
        nextToken: Swift.String? = nil,
        predictorBacktestExportJobs: [ForecastClientTypes.PredictorBacktestExportJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictorBacktestExportJobs = predictorBacktestExportJobs
    }
}

struct ListPredictorBacktestExportJobsOutputBody: Swift.Equatable {
    let predictorBacktestExportJobs: [ForecastClientTypes.PredictorBacktestExportJobSummary]?
    let nextToken: Swift.String?
}

extension ListPredictorBacktestExportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case predictorBacktestExportJobs = "PredictorBacktestExportJobs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.PredictorBacktestExportJobSummary?].self, forKey: .predictorBacktestExportJobs)
        var predictorBacktestExportJobsDecoded0:[ForecastClientTypes.PredictorBacktestExportJobSummary]? = nil
        if let predictorBacktestExportJobsContainer = predictorBacktestExportJobsContainer {
            predictorBacktestExportJobsDecoded0 = [ForecastClientTypes.PredictorBacktestExportJobSummary]()
            for structure0 in predictorBacktestExportJobsContainer {
                if let structure0 = structure0 {
                    predictorBacktestExportJobsDecoded0?.append(structure0)
                }
            }
        }
        predictorBacktestExportJobs = predictorBacktestExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPredictorBacktestExportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPredictorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPredictorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPredictorsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the predictors that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the predictors that match the statement, specify IS. To exclude matching predictors, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are DatasetGroupArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all predictors whose status is ACTIVE, you would specify: "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPredictorsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListPredictorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListPredictorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPredictorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.predictors = output.predictors
        } else {
            self.nextToken = nil
            self.predictors = nil
        }
    }
}

public struct ListPredictorsOutput: Swift.Equatable {
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of objects that summarize each predictor's properties.
    public var predictors: [ForecastClientTypes.PredictorSummary]?

    public init(
        nextToken: Swift.String? = nil,
        predictors: [ForecastClientTypes.PredictorSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictors = predictors
    }
}

struct ListPredictorsOutputBody: Swift.Equatable {
    let predictors: [ForecastClientTypes.PredictorSummary]?
    let nextToken: Swift.String?
}

extension ListPredictorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case predictors = "Predictors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.PredictorSummary?].self, forKey: .predictors)
        var predictorsDecoded0:[ForecastClientTypes.PredictorSummary]? = nil
        if let predictorsContainer = predictorsContainer {
            predictorsDecoded0 = [ForecastClientTypes.PredictorSummary]()
            for structure0 in predictorsContainer {
                if let structure0 = structure0 {
                    predictorsDecoded0?.append(structure0)
                }
            }
        }
        predictors = predictorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPredictorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [ForecastClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWhatIfAnalysesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWhatIfAnalysesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWhatIfAnalysesInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the what-if analysis jobs that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the what-if analysis jobs that match the statement, specify IS. To exclude matching what-if analysis jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are WhatIfAnalysisArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all jobs that export a forecast named electricityWhatIf, specify the following filter: "Filters": [ { "Condition": "IS", "Key": "WhatIfAnalysisArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityWhatIf" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWhatIfAnalysesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListWhatIfAnalysesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWhatIfAnalysesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWhatIfAnalysesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.whatIfAnalyses = output.whatIfAnalyses
        } else {
            self.nextToken = nil
            self.whatIfAnalyses = nil
        }
    }
}

public struct ListWhatIfAnalysesOutput: Swift.Equatable {
    /// If the response is truncated, Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of WhatIfAnalysisSummary objects that describe the matched analyses.
    public var whatIfAnalyses: [ForecastClientTypes.WhatIfAnalysisSummary]?

    public init(
        nextToken: Swift.String? = nil,
        whatIfAnalyses: [ForecastClientTypes.WhatIfAnalysisSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.whatIfAnalyses = whatIfAnalyses
    }
}

struct ListWhatIfAnalysesOutputBody: Swift.Equatable {
    let whatIfAnalyses: [ForecastClientTypes.WhatIfAnalysisSummary]?
    let nextToken: Swift.String?
}

extension ListWhatIfAnalysesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case whatIfAnalyses = "WhatIfAnalyses"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfAnalysesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.WhatIfAnalysisSummary?].self, forKey: .whatIfAnalyses)
        var whatIfAnalysesDecoded0:[ForecastClientTypes.WhatIfAnalysisSummary]? = nil
        if let whatIfAnalysesContainer = whatIfAnalysesContainer {
            whatIfAnalysesDecoded0 = [ForecastClientTypes.WhatIfAnalysisSummary]()
            for structure0 in whatIfAnalysesContainer {
                if let structure0 = structure0 {
                    whatIfAnalysesDecoded0?.append(structure0)
                }
            }
        }
        whatIfAnalyses = whatIfAnalysesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWhatIfAnalysesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWhatIfForecastExportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWhatIfForecastExportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWhatIfForecastExportsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the what-if forecast export jobs that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecast export jobs that match the statement, specify IS. To exclude matching forecast export jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are WhatIfForecastExportArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all jobs that export a forecast named electricityWIFExport, specify the following filter: "Filters": [ { "Condition": "IS", "Key": "WhatIfForecastExportArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityWIFExport" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWhatIfForecastExportsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListWhatIfForecastExportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWhatIfForecastExportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWhatIfForecastExportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.whatIfForecastExports = output.whatIfForecastExports
        } else {
            self.nextToken = nil
            self.whatIfForecastExports = nil
        }
    }
}

public struct ListWhatIfForecastExportsOutput: Swift.Equatable {
    /// If the response is truncated, Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of WhatIfForecastExports objects that describe the matched forecast exports.
    public var whatIfForecastExports: [ForecastClientTypes.WhatIfForecastExportSummary]?

    public init(
        nextToken: Swift.String? = nil,
        whatIfForecastExports: [ForecastClientTypes.WhatIfForecastExportSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.whatIfForecastExports = whatIfForecastExports
    }
}

struct ListWhatIfForecastExportsOutputBody: Swift.Equatable {
    let whatIfForecastExports: [ForecastClientTypes.WhatIfForecastExportSummary]?
    let nextToken: Swift.String?
}

extension ListWhatIfForecastExportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case whatIfForecastExports = "WhatIfForecastExports"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastExportsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.WhatIfForecastExportSummary?].self, forKey: .whatIfForecastExports)
        var whatIfForecastExportsDecoded0:[ForecastClientTypes.WhatIfForecastExportSummary]? = nil
        if let whatIfForecastExportsContainer = whatIfForecastExportsContainer {
            whatIfForecastExportsDecoded0 = [ForecastClientTypes.WhatIfForecastExportSummary]()
            for structure0 in whatIfForecastExportsContainer {
                if let structure0 = structure0 {
                    whatIfForecastExportsDecoded0?.append(structure0)
                }
            }
        }
        whatIfForecastExports = whatIfForecastExportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWhatIfForecastExportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWhatIfForecastsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWhatIfForecastsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWhatIfForecastsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the what-if forecast export jobs that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecast export jobs that match the statement, specify IS. To exclude matching forecast export jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are WhatIfForecastArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all jobs that export a forecast named electricityWhatIfForecast, specify the following filter: "Filters": [ { "Condition": "IS", "Key": "WhatIfForecastArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityWhatIfForecast" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWhatIfForecastsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListWhatIfForecastsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWhatIfForecastsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWhatIfForecastsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.whatIfForecasts = output.whatIfForecasts
        } else {
            self.nextToken = nil
            self.whatIfForecasts = nil
        }
    }
}

public struct ListWhatIfForecastsOutput: Swift.Equatable {
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?
    /// An array of WhatIfForecasts objects that describe the matched forecasts.
    public var whatIfForecasts: [ForecastClientTypes.WhatIfForecastSummary]?

    public init(
        nextToken: Swift.String? = nil,
        whatIfForecasts: [ForecastClientTypes.WhatIfForecastSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.whatIfForecasts = whatIfForecasts
    }
}

struct ListWhatIfForecastsOutputBody: Swift.Equatable {
    let whatIfForecasts: [ForecastClientTypes.WhatIfForecastSummary]?
    let nextToken: Swift.String?
}

extension ListWhatIfForecastsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case whatIfForecasts = "WhatIfForecasts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.WhatIfForecastSummary?].self, forKey: .whatIfForecasts)
        var whatIfForecastsDecoded0:[ForecastClientTypes.WhatIfForecastSummary]? = nil
        if let whatIfForecastsContainer = whatIfForecastsContainer {
            whatIfForecastsDecoded0 = [ForecastClientTypes.WhatIfForecastSummary]()
            for structure0 in whatIfForecastsContainer {
                if let structure0 = structure0 {
                    whatIfForecastsDecoded0?.append(structure0)
                }
            }
        }
        whatIfForecasts = whatIfForecastsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWhatIfForecastsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ForecastClientTypes.MetricResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName = "MetricName"
        case metricValue = "MetricValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricValue = self.metricValue {
            try encodeContainer.encode(metricValue, forKey: .metricValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .metricValue)
        metricValue = metricValueDecoded
    }
}

extension ForecastClientTypes {
    /// An individual metric Forecast calculated when monitoring predictor usage. You can compare the value for this metric to the metric's value in the [Baseline] to see how your predictor's performance is changing. For more information about metrics generated by Forecast see [Evaluating Predictor Accuracy](https://docs.aws.amazon.com/forecast/latest/dg/metrics.html)
    public struct MetricResult: Swift.Equatable {
        /// The name of the metric.
        public var metricName: Swift.String?
        /// The value for the metric.
        public var metricValue: Swift.Double?

        public init(
            metricName: Swift.String? = nil,
            metricValue: Swift.Double? = nil
        )
        {
            self.metricName = metricName
            self.metricValue = metricValue
        }
    }

}

extension ForecastClientTypes.Metrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageWeightedQuantileLoss = "AverageWeightedQuantileLoss"
        case errorMetrics = "ErrorMetrics"
        case rmse = "RMSE"
        case weightedQuantileLosses = "WeightedQuantileLosses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let averageWeightedQuantileLoss = self.averageWeightedQuantileLoss {
            try encodeContainer.encode(averageWeightedQuantileLoss, forKey: .averageWeightedQuantileLoss)
        }
        if let errorMetrics = errorMetrics {
            var errorMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorMetrics)
            for errormetric0 in errorMetrics {
                try errorMetricsContainer.encode(errormetric0)
            }
        }
        if let rmse = self.rmse {
            try encodeContainer.encode(rmse, forKey: .rmse)
        }
        if let weightedQuantileLosses = weightedQuantileLosses {
            var weightedQuantileLossesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .weightedQuantileLosses)
            for weightedquantileloss0 in weightedQuantileLosses {
                try weightedQuantileLossesContainer.encode(weightedquantileloss0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rmseDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .rmse)
        rmse = rmseDecoded
        let weightedQuantileLossesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.WeightedQuantileLoss?].self, forKey: .weightedQuantileLosses)
        var weightedQuantileLossesDecoded0:[ForecastClientTypes.WeightedQuantileLoss]? = nil
        if let weightedQuantileLossesContainer = weightedQuantileLossesContainer {
            weightedQuantileLossesDecoded0 = [ForecastClientTypes.WeightedQuantileLoss]()
            for structure0 in weightedQuantileLossesContainer {
                if let structure0 = structure0 {
                    weightedQuantileLossesDecoded0?.append(structure0)
                }
            }
        }
        weightedQuantileLosses = weightedQuantileLossesDecoded0
        let errorMetricsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ErrorMetric?].self, forKey: .errorMetrics)
        var errorMetricsDecoded0:[ForecastClientTypes.ErrorMetric]? = nil
        if let errorMetricsContainer = errorMetricsContainer {
            errorMetricsDecoded0 = [ForecastClientTypes.ErrorMetric]()
            for structure0 in errorMetricsContainer {
                if let structure0 = structure0 {
                    errorMetricsDecoded0?.append(structure0)
                }
            }
        }
        errorMetrics = errorMetricsDecoded0
        let averageWeightedQuantileLossDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .averageWeightedQuantileLoss)
        averageWeightedQuantileLoss = averageWeightedQuantileLossDecoded
    }
}

extension ForecastClientTypes {
    /// Provides metrics that are used to evaluate the performance of a predictor. This object is part of the [WindowSummary] object.
    public struct Metrics: Swift.Equatable {
        /// The average value of all weighted quantile losses.
        public var averageWeightedQuantileLoss: Swift.Double?
        /// Provides detailed error metrics for each forecast type. Metrics include root-mean square-error (RMSE), mean absolute percentage error (MAPE), mean absolute scaled error (MASE), and weighted average percentage error (WAPE).
        public var errorMetrics: [ForecastClientTypes.ErrorMetric]?
        /// The root-mean-square error (RMSE).
        @available(*, deprecated, message: "This property is deprecated, please refer to ErrorMetrics for both RMSE and WAPE")
        public var rmse: Swift.Double?
        /// An array of weighted quantile losses. Quantiles divide a probability distribution into regions of equal probability. The distribution in this case is the loss function.
        public var weightedQuantileLosses: [ForecastClientTypes.WeightedQuantileLoss]?

        public init(
            averageWeightedQuantileLoss: Swift.Double? = nil,
            errorMetrics: [ForecastClientTypes.ErrorMetric]? = nil,
            rmse: Swift.Double? = nil,
            weightedQuantileLosses: [ForecastClientTypes.WeightedQuantileLoss]? = nil
        )
        {
            self.averageWeightedQuantileLoss = averageWeightedQuantileLoss
            self.errorMetrics = errorMetrics
            self.rmse = rmse
            self.weightedQuantileLosses = weightedQuantileLosses
        }
    }

}

extension ForecastClientTypes.MonitorConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorName = "MonitorName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorName = self.monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
    }
}

extension ForecastClientTypes {
    /// The configuration details for the predictor monitor.
    public struct MonitorConfig: Swift.Equatable {
        /// The name of the monitor resource.
        /// This member is required.
        public var monitorName: Swift.String?

        public init(
            monitorName: Swift.String? = nil
        )
        {
            self.monitorName = monitorName
        }
    }

}

extension ForecastClientTypes.MonitorDataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
        case forecastArn = "ForecastArn"
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = self.datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let forecastArn = self.forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension ForecastClientTypes {
    /// The source of the data the monitor used during the evaluation.
    public struct MonitorDataSource: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the dataset import job used to import the data that initiated the monitor evaluation.
        public var datasetImportJobArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the forecast the monitor used during the evaluation.
        public var forecastArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the predictor resource you are monitoring.
        public var predictorArn: Swift.String?

        public init(
            datasetImportJobArn: Swift.String? = nil,
            forecastArn: Swift.String? = nil,
            predictorArn: Swift.String? = nil
        )
        {
            self.datasetImportJobArn = datasetImportJobArn
            self.forecastArn = forecastArn
            self.predictorArn = predictorArn
        }
    }

}

extension ForecastClientTypes.MonitorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ForecastClientTypes {
    /// Provides information about the monitor resource.
    public struct MonitorInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the monitor resource.
        public var monitorArn: Swift.String?
        /// The status of the monitor. States include:
        ///
        /// * ACTIVE
        ///
        /// * ACTIVE_STOPPING, ACTIVE_STOPPED
        ///
        /// * UPDATE_IN_PROGRESS
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init(
            monitorArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.monitorArn = monitorArn
            self.status = status
        }
    }

}

extension ForecastClientTypes.MonitorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
        case monitorArn = "MonitorArn"
        case monitorName = "MonitorName"
        case resourceArn = "ResourceArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let monitorName = self.monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the monitor properties used in the [ListMonitors] operation. To get a complete set of properties, call the [DescribeMonitor] operation, and provide the listed MonitorArn.
    public struct MonitorSummary: Swift.Equatable {
        /// When the monitor resource was created.
        public var creationTime: ClientRuntime.Date?
        /// The last time the monitor resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * STOPPED - When the resource stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the monitor creation finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the monitor resource.
        public var monitorArn: Swift.String?
        /// The name of the monitor resource.
        public var monitorName: Swift.String?
        /// The Amazon Resource Name (ARN) of the predictor being monitored.
        public var resourceArn: Swift.String?
        /// The status of the monitor. States include:
        ///
        /// * ACTIVE
        ///
        /// * ACTIVE_STOPPING, ACTIVE_STOPPED
        ///
        /// * UPDATE_IN_PROGRESS
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            monitorArn: Swift.String? = nil,
            monitorName: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.resourceArn = resourceArn
            self.status = status
        }
    }

}

extension ForecastClientTypes {
    public enum Month: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case april
        case august
        case december
        case february
        case january
        case july
        case june
        case march
        case may
        case november
        case october
        case september
        case sdkUnknown(Swift.String)

        public static var allCases: [Month] {
            return [
                .april,
                .august,
                .december,
                .february,
                .january,
                .july,
                .june,
                .march,
                .may,
                .november,
                .october,
                .september,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .april: return "APRIL"
            case .august: return "AUGUST"
            case .december: return "DECEMBER"
            case .february: return "FEBRUARY"
            case .january: return "JANUARY"
            case .july: return "JULY"
            case .june: return "JUNE"
            case .march: return "MARCH"
            case .may: return "MAY"
            case .november: return "NOVEMBER"
            case .october: return "OCTOBER"
            case .september: return "SEPTEMBER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Month(rawValue: rawValue) ?? Month.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes {
    public enum Operation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case divide
        case multiply
        case subtract
        case sdkUnknown(Swift.String)

        public static var allCases: [Operation] {
            return [
                .add,
                .divide,
                .multiply,
                .subtract,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .divide: return "DIVIDE"
            case .multiply: return "MULTIPLY"
            case .subtract: return "SUBTRACT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operation(rawValue: rawValue) ?? Operation.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes {
    public enum OptimizationMetric: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case averageweightedquantileloss
        case mape
        case mase
        case rmse
        case wape
        case sdkUnknown(Swift.String)

        public static var allCases: [OptimizationMetric] {
            return [
                .averageweightedquantileloss,
                .mape,
                .mase,
                .rmse,
                .wape,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .averageweightedquantileloss: return "AverageWeightedQuantileLoss"
            case .mape: return "MAPE"
            case .mase: return "MASE"
            case .rmse: return "RMSE"
            case .wape: return "WAPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OptimizationMetric(rawValue: rawValue) ?? OptimizationMetric.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.ParameterRanges: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoricalParameterRanges = "CategoricalParameterRanges"
        case continuousParameterRanges = "ContinuousParameterRanges"
        case integerParameterRanges = "IntegerParameterRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalParameterRanges = categoricalParameterRanges {
            var categoricalParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoricalParameterRanges)
            for categoricalparameterrange0 in categoricalParameterRanges {
                try categoricalParameterRangesContainer.encode(categoricalparameterrange0)
            }
        }
        if let continuousParameterRanges = continuousParameterRanges {
            var continuousParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .continuousParameterRanges)
            for continuousparameterrange0 in continuousParameterRanges {
                try continuousParameterRangesContainer.encode(continuousparameterrange0)
            }
        }
        if let integerParameterRanges = integerParameterRanges {
            var integerParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerParameterRanges)
            for integerparameterrange0 in integerParameterRanges {
                try integerParameterRangesContainer.encode(integerparameterrange0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoricalParameterRangesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.CategoricalParameterRange?].self, forKey: .categoricalParameterRanges)
        var categoricalParameterRangesDecoded0:[ForecastClientTypes.CategoricalParameterRange]? = nil
        if let categoricalParameterRangesContainer = categoricalParameterRangesContainer {
            categoricalParameterRangesDecoded0 = [ForecastClientTypes.CategoricalParameterRange]()
            for structure0 in categoricalParameterRangesContainer {
                if let structure0 = structure0 {
                    categoricalParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        categoricalParameterRanges = categoricalParameterRangesDecoded0
        let continuousParameterRangesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ContinuousParameterRange?].self, forKey: .continuousParameterRanges)
        var continuousParameterRangesDecoded0:[ForecastClientTypes.ContinuousParameterRange]? = nil
        if let continuousParameterRangesContainer = continuousParameterRangesContainer {
            continuousParameterRangesDecoded0 = [ForecastClientTypes.ContinuousParameterRange]()
            for structure0 in continuousParameterRangesContainer {
                if let structure0 = structure0 {
                    continuousParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        continuousParameterRanges = continuousParameterRangesDecoded0
        let integerParameterRangesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.IntegerParameterRange?].self, forKey: .integerParameterRanges)
        var integerParameterRangesDecoded0:[ForecastClientTypes.IntegerParameterRange]? = nil
        if let integerParameterRangesContainer = integerParameterRangesContainer {
            integerParameterRangesDecoded0 = [ForecastClientTypes.IntegerParameterRange]()
            for structure0 in integerParameterRangesContainer {
                if let structure0 = structure0 {
                    integerParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        integerParameterRanges = integerParameterRangesDecoded0
    }
}

extension ForecastClientTypes {
    /// Specifies the categorical, continuous, and integer hyperparameters, and their ranges of tunable values. The range of tunable values determines which values that a hyperparameter tuning job can choose for the specified hyperparameter. This object is part of the [HyperParameterTuningJobConfig] object.
    public struct ParameterRanges: Swift.Equatable {
        /// Specifies the tunable range for each categorical hyperparameter.
        public var categoricalParameterRanges: [ForecastClientTypes.CategoricalParameterRange]?
        /// Specifies the tunable range for each continuous hyperparameter.
        public var continuousParameterRanges: [ForecastClientTypes.ContinuousParameterRange]?
        /// Specifies the tunable range for each integer hyperparameter.
        public var integerParameterRanges: [ForecastClientTypes.IntegerParameterRange]?

        public init(
            categoricalParameterRanges: [ForecastClientTypes.CategoricalParameterRange]? = nil,
            continuousParameterRanges: [ForecastClientTypes.ContinuousParameterRange]? = nil,
            integerParameterRanges: [ForecastClientTypes.IntegerParameterRange]? = nil
        )
        {
            self.categoricalParameterRanges = categoricalParameterRanges
            self.continuousParameterRanges = continuousParameterRanges
            self.integerParameterRanges = integerParameterRanges
        }
    }

}

extension ForecastClientTypes.PredictorBacktestExportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorBacktestExportJobArn = self.predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
        if let predictorBacktestExportJobName = self.predictorBacktestExportJobName {
            try encodeContainer.encode(predictorBacktestExportJobName, forKey: .predictorBacktestExportJobName)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the predictor backtest export job properties used in the [ListPredictorBacktestExportJobs] operation. To get a complete set of properties, call the [DescribePredictorBacktestExportJob] operation, and provide the listed PredictorBacktestExportJobArn.
    public struct PredictorBacktestExportJobSummary: Swift.Equatable {
        /// When the predictor backtest export job was created.
        public var creationTime: ClientRuntime.Date?
        /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
        public var destination: ForecastClientTypes.DataDestination?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// Information about any errors that may have occurred during the backtest export.
        public var message: Swift.String?
        /// The Amazon Resource Name (ARN) of the predictor backtest export job.
        public var predictorBacktestExportJobArn: Swift.String?
        /// The name of the predictor backtest export job.
        public var predictorBacktestExportJobName: Swift.String?
        /// The status of the predictor backtest export job. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            predictorBacktestExportJobArn: Swift.String? = nil,
            predictorBacktestExportJobName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
            self.predictorBacktestExportJobName = predictorBacktestExportJobName
            self.status = status
        }
    }

}

extension ForecastClientTypes.PredictorBaseline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineMetrics = "BaselineMetrics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineMetrics = baselineMetrics {
            var baselineMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .baselineMetrics)
            for baselinemetric0 in baselineMetrics {
                try baselineMetricsContainer.encode(baselinemetric0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineMetricsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.BaselineMetric?].self, forKey: .baselineMetrics)
        var baselineMetricsDecoded0:[ForecastClientTypes.BaselineMetric]? = nil
        if let baselineMetricsContainer = baselineMetricsContainer {
            baselineMetricsDecoded0 = [ForecastClientTypes.BaselineMetric]()
            for structure0 in baselineMetricsContainer {
                if let structure0 = structure0 {
                    baselineMetricsDecoded0?.append(structure0)
                }
            }
        }
        baselineMetrics = baselineMetricsDecoded0
    }
}

extension ForecastClientTypes {
    /// Metrics you can use as a baseline for comparison purposes. Use these metrics when you interpret monitoring results for an auto predictor.
    public struct PredictorBaseline: Swift.Equatable {
        /// The initial [accuracy metrics](https://docs.aws.amazon.com/forecast/latest/dg/metrics.html) for the predictor. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.
        public var baselineMetrics: [ForecastClientTypes.BaselineMetric]?

        public init(
            baselineMetrics: [ForecastClientTypes.BaselineMetric]? = nil
        )
        {
            self.baselineMetrics = baselineMetrics
        }
    }

}

extension ForecastClientTypes.PredictorEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datetime = "Datetime"
        case detail = "Detail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datetime = self.datetime {
            try encodeContainer.encodeTimestamp(datetime, format: .epochSeconds, forKey: .datetime)
        }
        if let detail = self.detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detail)
        detail = detailDecoded
        let datetimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .datetime)
        datetime = datetimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides details about a predictor event, such as a retraining.
    public struct PredictorEvent: Swift.Equatable {
        /// The timestamp for when the event occurred.
        public var datetime: ClientRuntime.Date?
        /// The type of event. For example, Retrain. A retraining event denotes the timepoint when a predictor was retrained. Any monitor results from before the Datetime are from the previous predictor. Any new metrics are for the newly retrained predictor.
        public var detail: Swift.String?

        public init(
            datetime: ClientRuntime.Date? = nil,
            detail: Swift.String? = nil
        )
        {
            self.datetime = datetime
            self.detail = detail
        }
    }

}

extension ForecastClientTypes.PredictorExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case testWindows = "TestWindows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = self.algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let testWindows = testWindows {
            var testWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .testWindows)
            for testwindowsummary0 in testWindows {
                try testWindowsContainer.encode(testwindowsummary0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let testWindowsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.TestWindowSummary?].self, forKey: .testWindows)
        var testWindowsDecoded0:[ForecastClientTypes.TestWindowSummary]? = nil
        if let testWindowsContainer = testWindowsContainer {
            testWindowsDecoded0 = [ForecastClientTypes.TestWindowSummary]()
            for structure0 in testWindowsContainer {
                if let structure0 = structure0 {
                    testWindowsDecoded0?.append(structure0)
                }
            }
        }
        testWindows = testWindowsDecoded0
    }
}

extension ForecastClientTypes {
    /// The algorithm used to perform a backtest and the status of those tests.
    public struct PredictorExecution: Swift.Equatable {
        /// The ARN of the algorithm used to test the predictor.
        public var algorithmArn: Swift.String?
        /// An array of test windows used to evaluate the algorithm. The NumberOfBacktestWindows from the object determines the number of windows in the array.
        public var testWindows: [ForecastClientTypes.TestWindowSummary]?

        public init(
            algorithmArn: Swift.String? = nil,
            testWindows: [ForecastClientTypes.TestWindowSummary]? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }
    }

}

extension ForecastClientTypes.PredictorExecutionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorExecutions = "PredictorExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorExecutions = predictorExecutions {
            var predictorExecutionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predictorExecutions)
            for predictorexecution0 in predictorExecutions {
                try predictorExecutionsContainer.encode(predictorexecution0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorExecutionsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.PredictorExecution?].self, forKey: .predictorExecutions)
        var predictorExecutionsDecoded0:[ForecastClientTypes.PredictorExecution]? = nil
        if let predictorExecutionsContainer = predictorExecutionsContainer {
            predictorExecutionsDecoded0 = [ForecastClientTypes.PredictorExecution]()
            for structure0 in predictorExecutionsContainer {
                if let structure0 = structure0 {
                    predictorExecutionsDecoded0?.append(structure0)
                }
            }
        }
        predictorExecutions = predictorExecutionsDecoded0
    }
}

extension ForecastClientTypes {
    /// Contains details on the backtests performed to evaluate the accuracy of the predictor. The tests are returned in descending order of accuracy, with the most accurate backtest appearing first. You specify the number of backtests to perform when you call the operation.
    public struct PredictorExecutionDetails: Swift.Equatable {
        /// An array of the backtests performed to evaluate the accuracy of the predictor against a particular algorithm. The NumberOfBacktestWindows from the object determines the number of windows in the array.
        public var predictorExecutions: [ForecastClientTypes.PredictorExecution]?

        public init(
            predictorExecutions: [ForecastClientTypes.PredictorExecution]? = nil
        )
        {
            self.predictorExecutions = predictorExecutions
        }
    }

}

extension ForecastClientTypes.PredictorMonitorEvaluation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationState = "EvaluationState"
        case evaluationTime = "EvaluationTime"
        case message = "Message"
        case metricResults = "MetricResults"
        case monitorArn = "MonitorArn"
        case monitorDataSource = "MonitorDataSource"
        case numItemsEvaluated = "NumItemsEvaluated"
        case predictorEvent = "PredictorEvent"
        case resourceArn = "ResourceArn"
        case windowEndDatetime = "WindowEndDatetime"
        case windowStartDatetime = "WindowStartDatetime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationState = self.evaluationState {
            try encodeContainer.encode(evaluationState, forKey: .evaluationState)
        }
        if let evaluationTime = self.evaluationTime {
            try encodeContainer.encodeTimestamp(evaluationTime, format: .epochSeconds, forKey: .evaluationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let metricResults = metricResults {
            var metricResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricResults)
            for metricresult0 in metricResults {
                try metricResultsContainer.encode(metricresult0)
            }
        }
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let monitorDataSource = self.monitorDataSource {
            try encodeContainer.encode(monitorDataSource, forKey: .monitorDataSource)
        }
        if let numItemsEvaluated = self.numItemsEvaluated {
            try encodeContainer.encode(numItemsEvaluated, forKey: .numItemsEvaluated)
        }
        if let predictorEvent = self.predictorEvent {
            try encodeContainer.encode(predictorEvent, forKey: .predictorEvent)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let windowEndDatetime = self.windowEndDatetime {
            try encodeContainer.encodeTimestamp(windowEndDatetime, format: .epochSeconds, forKey: .windowEndDatetime)
        }
        if let windowStartDatetime = self.windowStartDatetime {
            try encodeContainer.encodeTimestamp(windowStartDatetime, format: .epochSeconds, forKey: .windowStartDatetime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let evaluationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .evaluationTime)
        evaluationTime = evaluationTimeDecoded
        let evaluationStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationState)
        evaluationState = evaluationStateDecoded
        let windowStartDatetimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .windowStartDatetime)
        windowStartDatetime = windowStartDatetimeDecoded
        let windowEndDatetimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .windowEndDatetime)
        windowEndDatetime = windowEndDatetimeDecoded
        let predictorEventDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.PredictorEvent.self, forKey: .predictorEvent)
        predictorEvent = predictorEventDecoded
        let monitorDataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.MonitorDataSource.self, forKey: .monitorDataSource)
        monitorDataSource = monitorDataSourceDecoded
        let metricResultsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.MetricResult?].self, forKey: .metricResults)
        var metricResultsDecoded0:[ForecastClientTypes.MetricResult]? = nil
        if let metricResultsContainer = metricResultsContainer {
            metricResultsDecoded0 = [ForecastClientTypes.MetricResult]()
            for structure0 in metricResultsContainer {
                if let structure0 = structure0 {
                    metricResultsDecoded0?.append(structure0)
                }
            }
        }
        metricResults = metricResultsDecoded0
        let numItemsEvaluatedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numItemsEvaluated)
        numItemsEvaluated = numItemsEvaluatedDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ForecastClientTypes {
    /// Describes the results of a monitor evaluation.
    public struct PredictorMonitorEvaluation: Swift.Equatable {
        /// The status of the monitor evaluation. The state can be SUCCESS or FAILURE.
        public var evaluationState: Swift.String?
        /// The timestamp that indicates when the monitor evaluation was started.
        public var evaluationTime: ClientRuntime.Date?
        /// Information about any errors that may have occurred during the monitor evaluation.
        public var message: Swift.String?
        /// A list of metrics Forecast calculated when monitoring a predictor. You can compare the value for each metric in the list to the metric's value in the [Baseline] to see how your predictor's performance is changing.
        public var metricResults: [ForecastClientTypes.MetricResult]?
        /// The Amazon Resource Name (ARN) of the monitor resource.
        public var monitorArn: Swift.String?
        /// The source of the data the monitor resource used during the evaluation.
        public var monitorDataSource: ForecastClientTypes.MonitorDataSource?
        /// The number of items considered during the evaluation.
        public var numItemsEvaluated: Swift.Int?
        /// Provides details about a predictor event, such as a retraining.
        public var predictorEvent: ForecastClientTypes.PredictorEvent?
        /// The Amazon Resource Name (ARN) of the resource to monitor.
        public var resourceArn: Swift.String?
        /// The timestamp that indicates the end of the window that is used for monitor evaluation.
        public var windowEndDatetime: ClientRuntime.Date?
        /// The timestamp that indicates the start of the window that is used for monitor evaluation.
        public var windowStartDatetime: ClientRuntime.Date?

        public init(
            evaluationState: Swift.String? = nil,
            evaluationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            metricResults: [ForecastClientTypes.MetricResult]? = nil,
            monitorArn: Swift.String? = nil,
            monitorDataSource: ForecastClientTypes.MonitorDataSource? = nil,
            numItemsEvaluated: Swift.Int? = nil,
            predictorEvent: ForecastClientTypes.PredictorEvent? = nil,
            resourceArn: Swift.String? = nil,
            windowEndDatetime: ClientRuntime.Date? = nil,
            windowStartDatetime: ClientRuntime.Date? = nil
        )
        {
            self.evaluationState = evaluationState
            self.evaluationTime = evaluationTime
            self.message = message
            self.metricResults = metricResults
            self.monitorArn = monitorArn
            self.monitorDataSource = monitorDataSource
            self.numItemsEvaluated = numItemsEvaluated
            self.predictorEvent = predictorEvent
            self.resourceArn = resourceArn
            self.windowEndDatetime = windowEndDatetime
            self.windowStartDatetime = windowStartDatetime
        }
    }

}

extension ForecastClientTypes.PredictorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case isAutoPredictor = "IsAutoPredictor"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case predictorName = "PredictorName"
        case referencePredictorSummary = "ReferencePredictorSummary"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let isAutoPredictor = self.isAutoPredictor {
            try encodeContainer.encode(isAutoPredictor, forKey: .isAutoPredictor)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let predictorName = self.predictorName {
            try encodeContainer.encode(predictorName, forKey: .predictorName)
        }
        if let referencePredictorSummary = self.referencePredictorSummary {
            try encodeContainer.encode(referencePredictorSummary, forKey: .referencePredictorSummary)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let isAutoPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAutoPredictor)
        isAutoPredictor = isAutoPredictorDecoded
        let referencePredictorSummaryDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ReferencePredictorSummary.self, forKey: .referencePredictorSummary)
        referencePredictorSummary = referencePredictorSummaryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the predictor properties that are used in the [ListPredictors] operation. To get the complete set of properties, call the [DescribePredictor] operation, and provide the listed PredictorArn.
    public struct PredictorSummary: Swift.Equatable {
        /// When the model training task was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that contains the data used to train the predictor.
        public var datasetGroupArn: Swift.String?
        /// Whether AutoPredictor was used to create the predictor.
        public var isAutoPredictor: Swift.Bool?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The ARN of the predictor.
        public var predictorArn: Swift.String?
        /// The name of the predictor.
        public var predictorName: Swift.String?
        /// A summary of the reference predictor used if the predictor was retrained or upgraded.
        public var referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary?
        /// The status of the predictor. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        ///
        /// The Status of the predictor must be ACTIVE before you can use the predictor to create a forecast.
        public var status: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            isAutoPredictor: Swift.Bool? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            predictorArn: Swift.String? = nil,
            predictorName: Swift.String? = nil,
            referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.isAutoPredictor = isAutoPredictor
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.predictorName = predictorName
            self.referencePredictorSummary = referencePredictorSummary
            self.status = status
        }
    }

}

extension ForecastClientTypes.ReferencePredictorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the reference predictor used when retraining or upgrading a predictor.
    public struct ReferencePredictorSummary: Swift.Equatable {
        /// The ARN of the reference predictor.
        public var arn: Swift.String?
        /// Whether the reference predictor is Active or Deleted.
        public var state: ForecastClientTypes.State?

        public init(
            arn: Swift.String? = nil,
            state: ForecastClientTypes.State? = nil
        )
        {
            self.arn = arn
            self.state = state
        }
    }

}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is already a resource with this name. Try again with a different name.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource is in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can't find a resource with that Amazon Resource Name (ARN). Check the ARN and try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResumeResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ResumeResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResumeResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the monitor resource to resume.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ResumeResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ResumeResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResumeResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ResumeResourceOutput: Swift.Equatable {

    public init() { }
}

enum ResumeResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ForecastClientTypes.S3Config: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn = "KMSKeyArn"
        case path = "Path"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension ForecastClientTypes {
    /// The path to the file(s) in an Amazon Simple Storage Service (Amazon S3) bucket, and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the file(s). Optionally, includes an Key Management Service (KMS) key. This object is part of the [DataSource] object that is submitted in the [CreateDatasetImportJob] request, and part of the [DataDestination] object.
    public struct S3Config: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Key Management Service (KMS) key.
        public var kmsKeyArn: Swift.String?
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket or file(s) in an Amazon S3 bucket.
        /// This member is required.
        public var path: Swift.String?
        /// The ARN of the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the Amazon S3 bucket or files. If you provide a value for the KMSKeyArn key, the role must allow access to the key. Passing a role across Amazon Web Services accounts is not allowed. If you pass a role that isn't in your account, you get an InvalidInputException error.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil,
            path: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.path = path
            self.roleArn = roleArn
        }
    }

}

extension ForecastClientTypes {
    public enum ScalingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case linear
        case logarithmic
        case reverselogarithmic
        case sdkUnknown(Swift.String)

        public static var allCases: [ScalingType] {
            return [
                .auto,
                .linear,
                .logarithmic,
                .reverselogarithmic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "Auto"
            case .linear: return "Linear"
            case .logarithmic: return "Logarithmic"
            case .reverselogarithmic: return "ReverseLogarithmic"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScalingType(rawValue: rawValue) ?? ScalingType.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.Schema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for schemaattribute0 in attributes {
                try attributesContainer.encode(schemaattribute0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.SchemaAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[ForecastClientTypes.SchemaAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ForecastClientTypes.SchemaAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ForecastClientTypes {
    /// Defines the fields of a dataset.
    public struct Schema: Swift.Equatable {
        /// An array of attributes specifying the name and type of each field in a dataset.
        public var attributes: [ForecastClientTypes.SchemaAttribute]?

        public init(
            attributes: [ForecastClientTypes.SchemaAttribute]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

extension ForecastClientTypes.SchemaAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeType = "AttributeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let attributeType = self.attributeType {
            try encodeContainer.encode(attributeType.rawValue, forKey: .attributeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AttributeType.self, forKey: .attributeType)
        attributeType = attributeTypeDecoded
    }
}

extension ForecastClientTypes {
    /// An attribute of a schema, which defines a dataset field. A schema attribute is required for every field in a dataset. The [Schema](https://docs.aws.amazon.com/forecast/latest/dg/API_Schema.html) object contains an array of SchemaAttribute objects.
    public struct SchemaAttribute: Swift.Equatable {
        /// The name of the dataset field.
        public var attributeName: Swift.String?
        /// The data type of the field. For a related time series dataset, other than date, item_id, and forecast dimensions attributes, all attributes should be of numerical type (integer/float).
        public var attributeType: ForecastClientTypes.AttributeType?

        public init(
            attributeName: Swift.String? = nil,
            attributeType: ForecastClientTypes.AttributeType? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeType = attributeType
        }
    }

}

extension ForecastClientTypes {
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .deleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleted: return "Deleted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.Statistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avg = "Avg"
        case count = "Count"
        case countDistinct = "CountDistinct"
        case countDistinctLong = "CountDistinctLong"
        case countLong = "CountLong"
        case countNan = "CountNan"
        case countNanLong = "CountNanLong"
        case countNull = "CountNull"
        case countNullLong = "CountNullLong"
        case max = "Max"
        case min = "Min"
        case stddev = "Stddev"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let avg = self.avg {
            try encodeContainer.encode(avg, forKey: .avg)
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let countDistinct = self.countDistinct {
            try encodeContainer.encode(countDistinct, forKey: .countDistinct)
        }
        if let countDistinctLong = self.countDistinctLong {
            try encodeContainer.encode(countDistinctLong, forKey: .countDistinctLong)
        }
        if let countLong = self.countLong {
            try encodeContainer.encode(countLong, forKey: .countLong)
        }
        if let countNan = self.countNan {
            try encodeContainer.encode(countNan, forKey: .countNan)
        }
        if let countNanLong = self.countNanLong {
            try encodeContainer.encode(countNanLong, forKey: .countNanLong)
        }
        if let countNull = self.countNull {
            try encodeContainer.encode(countNull, forKey: .countNull)
        }
        if let countNullLong = self.countNullLong {
            try encodeContainer.encode(countNullLong, forKey: .countNullLong)
        }
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
        if let stddev = self.stddev {
            try encodeContainer.encode(stddev, forKey: .stddev)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let countDistinctDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countDistinct)
        countDistinct = countDistinctDecoded
        let countNullDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNull)
        countNull = countNullDecoded
        let countNanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNan)
        countNan = countNanDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .max)
        max = maxDecoded
        let avgDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .avg)
        avg = avgDecoded
        let stddevDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .stddev)
        stddev = stddevDecoded
        let countLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countLong)
        countLong = countLongDecoded
        let countDistinctLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countDistinctLong)
        countDistinctLong = countDistinctLongDecoded
        let countNullLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNullLong)
        countNullLong = countNullLongDecoded
        let countNanLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNanLong)
        countNanLong = countNanLongDecoded
    }
}

extension ForecastClientTypes {
    /// Provides statistics for each data field imported into to an Amazon Forecast dataset with the [CreateDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html) operation.
    public struct Statistics: Swift.Equatable {
        /// For a numeric field, the average value in the field.
        public var avg: Swift.Double?
        /// The number of values in the field. If the response value is -1, refer to CountLong.
        public var count: Swift.Int?
        /// The number of distinct values in the field. If the response value is -1, refer to CountDistinctLong.
        public var countDistinct: Swift.Int?
        /// The number of distinct values in the field. CountDistinctLong is used instead of CountDistinct if the value is greater than 2,147,483,647.
        public var countDistinctLong: Swift.Int?
        /// The number of values in the field. CountLong is used instead of Count if the value is greater than 2,147,483,647.
        public var countLong: Swift.Int?
        /// The number of NAN (not a number) values in the field. If the response value is -1, refer to CountNanLong.
        public var countNan: Swift.Int?
        /// The number of NAN (not a number) values in the field. CountNanLong is used instead of CountNan if the value is greater than 2,147,483,647.
        public var countNanLong: Swift.Int?
        /// The number of null values in the field. If the response value is -1, refer to CountNullLong.
        public var countNull: Swift.Int?
        /// The number of null values in the field. CountNullLong is used instead of CountNull if the value is greater than 2,147,483,647.
        public var countNullLong: Swift.Int?
        /// For a numeric field, the maximum value in the field.
        public var max: Swift.String?
        /// For a numeric field, the minimum value in the field.
        public var min: Swift.String?
        /// For a numeric field, the standard deviation.
        public var stddev: Swift.Double?

        public init(
            avg: Swift.Double? = nil,
            count: Swift.Int? = nil,
            countDistinct: Swift.Int? = nil,
            countDistinctLong: Swift.Int? = nil,
            countLong: Swift.Int? = nil,
            countNan: Swift.Int? = nil,
            countNanLong: Swift.Int? = nil,
            countNull: Swift.Int? = nil,
            countNullLong: Swift.Int? = nil,
            max: Swift.String? = nil,
            min: Swift.String? = nil,
            stddev: Swift.Double? = nil
        )
        {
            self.avg = avg
            self.count = count
            self.countDistinct = countDistinct
            self.countDistinctLong = countDistinctLong
            self.countLong = countLong
            self.countNan = countNan
            self.countNanLong = countNanLong
            self.countNull = countNull
            self.countNullLong = countNullLong
            self.max = max
            self.min = min
            self.stddev = stddev
        }
    }

}

extension StopResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension StopResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource to stop. The supported ARNs are DatasetImportJobArn, PredictorArn, PredictorBacktestExportJobArn, ForecastArn, ForecastExportJobArn, ExplainabilityArn, and ExplainabilityExportArn.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct StopResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension StopResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension StopResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopResourceOutput: Swift.Equatable {

    public init() { }
}

enum StopResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ForecastClientTypes.SupplementaryFeature: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ForecastClientTypes {
    /// This object belongs to the [CreatePredictor] operation. If you created your predictor with [CreateAutoPredictor], see [AdditionalDataset]. Describes a supplementary feature of a dataset group. This object is part of the [InputDataConfig] object. Forecast supports the Weather Index and Holidays built-in featurizations. Weather Index The Amazon Forecast Weather Index is a built-in featurization that incorporates historical and projected weather information into your model. The Weather Index supplements your datasets with over two years of historical weather data and up to 14 days of projected weather data. For more information, see [Amazon Forecast Weather Index](https://docs.aws.amazon.com/forecast/latest/dg/weather.html). Holidays Holidays is a built-in featurization that incorporates a feature-engineered dataset of national holiday information into your model. It provides native support for the holiday calendars of 66 countries. To view the holiday calendars, refer to the [Jollyday](http://jollyday.sourceforge.net/data.html) library. For more information, see [Holidays Featurization](https://docs.aws.amazon.com/forecast/latest/dg/holidays.html).
    public struct SupplementaryFeature: Swift.Equatable {
        /// The name of the feature. Valid values: "holiday" and "weather".
        /// This member is required.
        public var name: Swift.String?
        /// Weather Index To enable the Weather Index, set the value to "true" Holidays To enable Holidays, specify a country with one of the following two-letter country codes:
        ///
        /// * "AL" - ALBANIA
        ///
        /// * "AR" - ARGENTINA
        ///
        /// * "AT" - AUSTRIA
        ///
        /// * "AU" - AUSTRALIA
        ///
        /// * "BA" - BOSNIA HERZEGOVINA
        ///
        /// * "BE" - BELGIUM
        ///
        /// * "BG" - BULGARIA
        ///
        /// * "BO" - BOLIVIA
        ///
        /// * "BR" - BRAZIL
        ///
        /// * "BY" - BELARUS
        ///
        /// * "CA" - CANADA
        ///
        /// * "CL" - CHILE
        ///
        /// * "CO" - COLOMBIA
        ///
        /// * "CR" - COSTA RICA
        ///
        /// * "HR" - CROATIA
        ///
        /// * "CZ" - CZECH REPUBLIC
        ///
        /// * "DK" - DENMARK
        ///
        /// * "EC" - ECUADOR
        ///
        /// * "EE" - ESTONIA
        ///
        /// * "ET" - ETHIOPIA
        ///
        /// * "FI" - FINLAND
        ///
        /// * "FR" - FRANCE
        ///
        /// * "DE" - GERMANY
        ///
        /// * "GR" - GREECE
        ///
        /// * "HU" - HUNGARY
        ///
        /// * "IS" - ICELAND
        ///
        /// * "IN" - INDIA
        ///
        /// * "IE" - IRELAND
        ///
        /// * "IT" - ITALY
        ///
        /// * "JP" - JAPAN
        ///
        /// * "KZ" - KAZAKHSTAN
        ///
        /// * "KR" - KOREA
        ///
        /// * "LV" - LATVIA
        ///
        /// * "LI" - LIECHTENSTEIN
        ///
        /// * "LT" - LITHUANIA
        ///
        /// * "LU" - LUXEMBOURG
        ///
        /// * "MK" - MACEDONIA
        ///
        /// * "MT" - MALTA
        ///
        /// * "MX" - MEXICO
        ///
        /// * "MD" - MOLDOVA
        ///
        /// * "ME" - MONTENEGRO
        ///
        /// * "NL" - NETHERLANDS
        ///
        /// * "NZ" - NEW ZEALAND
        ///
        /// * "NI" - NICARAGUA
        ///
        /// * "NG" - NIGERIA
        ///
        /// * "NO" - NORWAY
        ///
        /// * "PA" - PANAMA
        ///
        /// * "PY" - PARAGUAY
        ///
        /// * "PE" - PERU
        ///
        /// * "PL" - POLAND
        ///
        /// * "PT" - PORTUGAL
        ///
        /// * "RO" - ROMANIA
        ///
        /// * "RU" - RUSSIA
        ///
        /// * "RS" - SERBIA
        ///
        /// * "SK" - SLOVAKIA
        ///
        /// * "SI" - SLOVENIA
        ///
        /// * "ZA" - SOUTH AFRICA
        ///
        /// * "ES" - SPAIN
        ///
        /// * "SE" - SWEDEN
        ///
        /// * "CH" - SWITZERLAND
        ///
        /// * "UA" - UKRAINE
        ///
        /// * "AE" - UNITED ARAB EMIRATES
        ///
        /// * "US" - UNITED STATES
        ///
        /// * "UK" - UNITED KINGDOM
        ///
        /// * "UY" - URUGUAY
        ///
        /// * "VE" - VENEZUELA
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ForecastClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ForecastClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension ForecastClientTypes {
    /// The optional metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.
        /// This member is required.
        public var key: Swift.String?
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor within a tag category (key).
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    /// This member is required.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [ForecastClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ForecastClientTypes.TestWindowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case status = "Status"
        case testWindowEnd = "TestWindowEnd"
        case testWindowStart = "TestWindowStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let testWindowEnd = self.testWindowEnd {
            try encodeContainer.encodeTimestamp(testWindowEnd, format: .epochSeconds, forKey: .testWindowEnd)
        }
        if let testWindowStart = self.testWindowStart {
            try encodeContainer.encodeTimestamp(testWindowStart, format: .epochSeconds, forKey: .testWindowStart)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testWindowStartDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .testWindowStart)
        testWindowStart = testWindowStartDecoded
        let testWindowEndDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .testWindowEnd)
        testWindowEnd = testWindowEndDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ForecastClientTypes {
    /// The status, start time, and end time of a backtest, as well as a failure reason if applicable.
    public struct TestWindowSummary: Swift.Equatable {
        /// If the test failed, the reason why it failed.
        public var message: Swift.String?
        /// The status of the test. Possible status values are:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_IN_PROGRESS
        ///
        /// * CREATE_FAILED
        public var status: Swift.String?
        /// The time at which the test ended.
        public var testWindowEnd: ClientRuntime.Date?
        /// The time at which the test began.
        public var testWindowStart: ClientRuntime.Date?

        public init(
            message: Swift.String? = nil,
            status: Swift.String? = nil,
            testWindowEnd: ClientRuntime.Date? = nil,
            testWindowStart: ClientRuntime.Date? = nil
        )
        {
            self.message = message
            self.status = status
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }
    }

}

extension ForecastClientTypes.TimeAlignmentBoundary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case hour = "Hour"
        case month = "Month"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = self.dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = self.dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
        if let hour = self.hour {
            try encodeContainer.encode(hour, forKey: .hour)
        }
        if let month = self.month {
            try encodeContainer.encode(month.rawValue, forKey: .month)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Month.self, forKey: .month)
        month = monthDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let hourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hour)
        hour = hourDecoded
    }
}

extension ForecastClientTypes {
    /// The time boundary Forecast uses to align and aggregate your data to match your forecast frequency. Provide the unit of time and the time boundary as a key value pair. If you don't provide a time boundary, Forecast uses a set of [Default Time Boundaries](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html#default-time-boundaries). For more information about aggregation, see [Data Aggregation for Different Forecast Frequencies](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html). For more information setting a custom time boundary, see [Specifying a Time Boundary](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html#specifying-time-boundary).
    public struct TimeAlignmentBoundary: Swift.Equatable {
        /// The day of the month to use for time alignment during aggregation.
        public var dayOfMonth: Swift.Int?
        /// The day of week to use for time alignment during aggregation. The day must be in uppercase.
        public var dayOfWeek: ForecastClientTypes.DayOfWeek?
        /// The hour of day to use for time alignment during aggregation.
        public var hour: Swift.Int?
        /// The month to use for time alignment during aggregation. The month must be in uppercase.
        public var month: ForecastClientTypes.Month?

        public init(
            dayOfMonth: Swift.Int? = nil,
            dayOfWeek: ForecastClientTypes.DayOfWeek? = nil,
            hour: Swift.Int? = nil,
            month: ForecastClientTypes.Month? = nil
        )
        {
            self.dayOfMonth = dayOfMonth
            self.dayOfWeek = dayOfWeek
            self.hour = hour
            self.month = month
        }
    }

}

extension ForecastClientTypes {
    public enum TimePointGranularity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case specific
        case sdkUnknown(Swift.String)

        public static var allCases: [TimePointGranularity] {
            return [
                .all,
                .specific,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .specific: return "SPECIFIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimePointGranularity(rawValue: rawValue) ?? TimePointGranularity.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.TimeSeriesCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
        case condition = "Condition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let attributeValue = self.attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
        if let condition = self.condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Condition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ForecastClientTypes {
    /// Creates a subset of items within an attribute that are modified. For example, you can use this operation to create a subset of items that cost $5 or less. To do this, you specify "AttributeName": "price", "AttributeValue": "5", and "Condition": "LESS_THAN". Pair this operation with the [Action] operation within the [CreateWhatIfForecastRequest$TimeSeriesTransformations] operation to define how the attribute is modified.
    public struct TimeSeriesCondition: Swift.Equatable {
        /// The item_id, dimension name, IM name, or timestamp that you are modifying.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The value that is applied for the chosen Condition.
        /// This member is required.
        public var attributeValue: Swift.String?
        /// The condition to apply. Valid values are EQUALS, NOT_EQUALS, LESS_THAN and GREATER_THAN.
        /// This member is required.
        public var condition: ForecastClientTypes.Condition?

        public init(
            attributeName: Swift.String? = nil,
            attributeValue: Swift.String? = nil,
            condition: ForecastClientTypes.Condition? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
            self.condition = condition
        }
    }

}

extension ForecastClientTypes {
    public enum TimeSeriesGranularity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case specific
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeSeriesGranularity] {
            return [
                .all,
                .specific,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .specific: return "SPECIFIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeSeriesGranularity(rawValue: rawValue) ?? TimeSeriesGranularity.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.TimeSeriesIdentifiers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case format = "Format"
        case schema = "Schema"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension ForecastClientTypes {
    /// Details about the import file that contains the time series for which you want to create forecasts.
    public struct TimeSeriesIdentifiers: Swift.Equatable {
        /// The source of your data, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an Key Management Service (KMS) key.
        public var dataSource: ForecastClientTypes.DataSource?
        /// The format of the data, either CSV or PARQUET.
        public var format: Swift.String?
        /// Defines the fields of a dataset.
        public var schema: ForecastClientTypes.Schema?

        public init(
            dataSource: ForecastClientTypes.DataSource? = nil,
            format: Swift.String? = nil,
            schema: ForecastClientTypes.Schema? = nil
        )
        {
            self.dataSource = dataSource
            self.format = format
            self.schema = schema
        }
    }

}

extension ForecastClientTypes.TimeSeriesReplacementsDataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case s3Config = "S3Config"
        case schema = "Schema"
        case timestampFormat = "TimestampFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let s3Config = self.s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let timestampFormat = self.timestampFormat {
            try encodeContainer.encode(timestampFormat, forKey: .timestampFormat)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let timestampFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampFormat)
        timestampFormat = timestampFormatDecoded
    }
}

extension ForecastClientTypes {
    /// A replacement dataset is a modified version of the baseline related time series that contains only the values that you want to include in a what-if forecast. The replacement dataset must contain the forecast dimensions and item identifiers in the baseline related time series as well as at least 1 changed time series. This dataset is merged with the baseline related time series to create a transformed dataset that is used for the what-if forecast.
    public struct TimeSeriesReplacementsDataSource: Swift.Equatable {
        /// The format of the replacement data, CSV or PARQUET.
        public var format: Swift.String?
        /// The path to the file(s) in an Amazon Simple Storage Service (Amazon S3) bucket, and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the file(s). Optionally, includes an Key Management Service (KMS) key. This object is part of the [DataSource] object that is submitted in the [CreateDatasetImportJob] request, and part of the [DataDestination] object.
        /// This member is required.
        public var s3Config: ForecastClientTypes.S3Config?
        /// Defines the fields of a dataset.
        /// This member is required.
        public var schema: ForecastClientTypes.Schema?
        /// The timestamp format of the replacement data.
        public var timestampFormat: Swift.String?

        public init(
            format: Swift.String? = nil,
            s3Config: ForecastClientTypes.S3Config? = nil,
            schema: ForecastClientTypes.Schema? = nil,
            timestampFormat: Swift.String? = nil
        )
        {
            self.format = format
            self.s3Config = s3Config
            self.schema = schema
            self.timestampFormat = timestampFormat
        }
    }

}

extension ForecastClientTypes.TimeSeriesSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeSeriesIdentifiers = "TimeSeriesIdentifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeSeriesIdentifiers = self.timeSeriesIdentifiers {
            try encodeContainer.encode(timeSeriesIdentifiers, forKey: .timeSeriesIdentifiers)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesIdentifiersDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesIdentifiers.self, forKey: .timeSeriesIdentifiers)
        timeSeriesIdentifiers = timeSeriesIdentifiersDecoded
    }
}

extension ForecastClientTypes {
    /// Defines the set of time series that are used to create the forecasts in a TimeSeriesIdentifiers object. The TimeSeriesIdentifiers object needs the following information:
    ///
    /// * DataSource
    ///
    /// * Format
    ///
    /// * Schema
    public struct TimeSeriesSelector: Swift.Equatable {
        /// Details about the import file that contains the time series for which you want to create forecasts.
        public var timeSeriesIdentifiers: ForecastClientTypes.TimeSeriesIdentifiers?

        public init(
            timeSeriesIdentifiers: ForecastClientTypes.TimeSeriesIdentifiers? = nil
        )
        {
            self.timeSeriesIdentifiers = timeSeriesIdentifiers
        }
    }

}

extension ForecastClientTypes.TimeSeriesTransformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case timeSeriesConditions = "TimeSeriesConditions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let timeSeriesConditions = timeSeriesConditions {
            var timeSeriesConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timeSeriesConditions)
            for timeseriescondition0 in timeSeriesConditions {
                try timeSeriesConditionsContainer.encode(timeseriescondition0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let timeSeriesConditionsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.TimeSeriesCondition?].self, forKey: .timeSeriesConditions)
        var timeSeriesConditionsDecoded0:[ForecastClientTypes.TimeSeriesCondition]? = nil
        if let timeSeriesConditionsContainer = timeSeriesConditionsContainer {
            timeSeriesConditionsDecoded0 = [ForecastClientTypes.TimeSeriesCondition]()
            for structure0 in timeSeriesConditionsContainer {
                if let structure0 = structure0 {
                    timeSeriesConditionsDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesConditions = timeSeriesConditionsDecoded0
    }
}

extension ForecastClientTypes {
    /// A transformation function is a pair of operations that select and modify the rows in a related time series. You select the rows that you want with a condition operation and you modify the rows with a transformation operation. All conditions are joined with an AND operation, meaning that all conditions must be true for the transformation to be applied. Transformations are applied in the order that they are listed.
    public struct TimeSeriesTransformation: Swift.Equatable {
        /// An array of actions that define a time series and how it is transformed. These transformations create a new time series that is used for the what-if analysis.
        public var action: ForecastClientTypes.Action?
        /// An array of conditions that define which members of the related time series are transformed.
        public var timeSeriesConditions: [ForecastClientTypes.TimeSeriesCondition]?

        public init(
            action: ForecastClientTypes.Action? = nil,
            timeSeriesConditions: [ForecastClientTypes.TimeSeriesCondition]? = nil
        )
        {
            self.action = action
            self.timeSeriesConditions = timeSeriesConditions
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArns = datasetArns {
            var datasetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasetArns)
            for arn0 in datasetArns {
                try datasetArnsContainer.encode(arn0)
            }
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

extension UpdateDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDatasetGroupInput: Swift.Equatable {
    /// An array of the Amazon Resource Names (ARNs) of the datasets to add to the dataset group.
    /// This member is required.
    public var datasetArns: [Swift.String]?
    /// The ARN of the dataset group.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init(
        datasetArns: [Swift.String]? = nil,
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetArns = datasetArns
        self.datasetGroupArn = datasetGroupArn
    }
}

struct UpdateDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let datasetArns: [Swift.String]?
}

extension UpdateDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[Swift.String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [Swift.String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
    }
}

extension UpdateDatasetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDatasetGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDatasetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ForecastClientTypes.WeightedQuantileLoss: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lossValue = "LossValue"
        case quantile = "Quantile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lossValue = self.lossValue {
            try encodeContainer.encode(lossValue, forKey: .lossValue)
        }
        if let quantile = self.quantile {
            try encodeContainer.encode(quantile, forKey: .quantile)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantileDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .quantile)
        quantile = quantileDecoded
        let lossValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lossValue)
        lossValue = lossValueDecoded
    }
}

extension ForecastClientTypes {
    /// The weighted loss value for a quantile. This object is part of the [Metrics] object.
    public struct WeightedQuantileLoss: Swift.Equatable {
        /// The difference between the predicted value and the actual value over the quantile, weighted (normalized) by dividing by the sum over all quantiles.
        public var lossValue: Swift.Double?
        /// The quantile. Quantiles divide a probability distribution into regions of equal probability. For example, if the distribution was divided into 5 regions of equal probability, the quantiles would be 0.2, 0.4, 0.6, and 0.8.
        public var quantile: Swift.Double?

        public init(
            lossValue: Swift.Double? = nil,
            quantile: Swift.Double? = nil
        )
        {
            self.lossValue = lossValue
            self.quantile = quantile
        }
    }

}

extension ForecastClientTypes.WhatIfAnalysisSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case forecastArn = "ForecastArn"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
        case whatIfAnalysisName = "WhatIfAnalysisName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let forecastArn = self.forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let whatIfAnalysisArn = self.whatIfAnalysisArn {
            try encodeContainer.encode(whatIfAnalysisArn, forKey: .whatIfAnalysisArn)
        }
        if let whatIfAnalysisName = self.whatIfAnalysisName {
            try encodeContainer.encode(whatIfAnalysisName, forKey: .whatIfAnalysisName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
        let whatIfAnalysisNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisName)
        whatIfAnalysisName = whatIfAnalysisNameDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the what-if analysis properties used in the [ListWhatIfAnalyses] operation. To get the complete set of properties, call the [DescribeWhatIfAnalysis] operation, and provide the WhatIfAnalysisArn that is listed in the summary.
    public struct WhatIfAnalysisSummary: Swift.Equatable {
        /// When the what-if analysis was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the baseline forecast that is being used in this what-if analysis.
        public var forecastArn: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the what-if analysis. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the what-if analysis must be ACTIVE before you can access the analysis.
        public var status: Swift.String?
        /// The Amazon Resource Name (ARN) of the what-if analysis.
        public var whatIfAnalysisArn: Swift.String?
        /// The name of the what-if analysis.
        public var whatIfAnalysisName: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            forecastArn: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil,
            whatIfAnalysisArn: Swift.String? = nil,
            whatIfAnalysisName: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.forecastArn = forecastArn
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.whatIfAnalysisArn = whatIfAnalysisArn
            self.whatIfAnalysisName = whatIfAnalysisName
        }
    }

}

extension ForecastClientTypes.WhatIfForecastExportSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case whatIfForecastArns = "WhatIfForecastArns"
        case whatIfForecastExportArn = "WhatIfForecastExportArn"
        case whatIfForecastExportName = "WhatIfForecastExportName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let whatIfForecastArns = whatIfForecastArns {
            var whatIfForecastArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .whatIfForecastArns)
            for longarn0 in whatIfForecastArns {
                try whatIfForecastArnsContainer.encode(longarn0)
            }
        }
        if let whatIfForecastExportArn = self.whatIfForecastExportArn {
            try encodeContainer.encode(whatIfForecastExportArn, forKey: .whatIfForecastExportArn)
        }
        if let whatIfForecastExportName = self.whatIfForecastExportName {
            try encodeContainer.encode(whatIfForecastExportName, forKey: .whatIfForecastExportName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportArn)
        whatIfForecastExportArn = whatIfForecastExportArnDecoded
        let whatIfForecastArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whatIfForecastArns)
        var whatIfForecastArnsDecoded0:[Swift.String]? = nil
        if let whatIfForecastArnsContainer = whatIfForecastArnsContainer {
            whatIfForecastArnsDecoded0 = [Swift.String]()
            for string0 in whatIfForecastArnsContainer {
                if let string0 = string0 {
                    whatIfForecastArnsDecoded0?.append(string0)
                }
            }
        }
        whatIfForecastArns = whatIfForecastArnsDecoded0
        let whatIfForecastExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportName)
        whatIfForecastExportName = whatIfForecastExportNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the what-if forecast export properties used in the [ListWhatIfForecastExports] operation. To get the complete set of properties, call the [DescribeWhatIfForecastExport] operation, and provide the WhatIfForecastExportArn that is listed in the summary.
    public struct WhatIfForecastExportSummary: Swift.Equatable {
        /// When the what-if forecast export was created.
        public var creationTime: ClientRuntime.Date?
        /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
        public var destination: ForecastClientTypes.DataDestination?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the what-if forecast export. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the what-if analysis must be ACTIVE before you can access the analysis.
        public var status: Swift.String?
        /// An array of Amazon Resource Names (ARNs) that define the what-if forecasts included in the export.
        public var whatIfForecastArns: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the what-if forecast export.
        public var whatIfForecastExportArn: Swift.String?
        /// The what-if forecast export name.
        public var whatIfForecastExportName: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil,
            whatIfForecastArns: [Swift.String]? = nil,
            whatIfForecastExportArn: Swift.String? = nil,
            whatIfForecastExportName: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.whatIfForecastArns = whatIfForecastArns
            self.whatIfForecastExportArn = whatIfForecastExportArn
            self.whatIfForecastExportName = whatIfForecastExportName
        }
    }

}

extension ForecastClientTypes.WhatIfForecastSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
        case whatIfForecastArn = "WhatIfForecastArn"
        case whatIfForecastName = "WhatIfForecastName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let whatIfAnalysisArn = self.whatIfAnalysisArn {
            try encodeContainer.encode(whatIfAnalysisArn, forKey: .whatIfAnalysisArn)
        }
        if let whatIfForecastArn = self.whatIfForecastArn {
            try encodeContainer.encode(whatIfForecastArn, forKey: .whatIfForecastArn)
        }
        if let whatIfForecastName = self.whatIfForecastName {
            try encodeContainer.encode(whatIfForecastName, forKey: .whatIfForecastName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastArn)
        whatIfForecastArn = whatIfForecastArnDecoded
        let whatIfForecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastName)
        whatIfForecastName = whatIfForecastNameDecoded
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the what-if forecast properties used in the [ListWhatIfForecasts] operation. To get the complete set of properties, call the [DescribeWhatIfForecast] operation, and provide the WhatIfForecastArn that is listed in the summary.
    public struct WhatIfForecastSummary: Swift.Equatable {
        /// When the what-if forecast was created.
        public var creationTime: ClientRuntime.Date?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the what-if forecast. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the what-if analysis must be ACTIVE before you can access the analysis.
        public var status: Swift.String?
        /// The Amazon Resource Name (ARN) of the what-if analysis that contains this what-if forecast.
        public var whatIfAnalysisArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the what-if forecast.
        public var whatIfForecastArn: Swift.String?
        /// The name of the what-if forecast.
        public var whatIfForecastName: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil,
            whatIfAnalysisArn: Swift.String? = nil,
            whatIfForecastArn: Swift.String? = nil,
            whatIfForecastName: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.whatIfAnalysisArn = whatIfAnalysisArn
            self.whatIfForecastArn = whatIfForecastArn
            self.whatIfForecastName = whatIfForecastName
        }
    }

}

extension ForecastClientTypes.WindowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationType = "EvaluationType"
        case itemCount = "ItemCount"
        case metrics = "Metrics"
        case testWindowEnd = "TestWindowEnd"
        case testWindowStart = "TestWindowStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationType = self.evaluationType {
            try encodeContainer.encode(evaluationType.rawValue, forKey: .evaluationType)
        }
        if let itemCount = self.itemCount {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let metrics = self.metrics {
            try encodeContainer.encode(metrics, forKey: .metrics)
        }
        if let testWindowEnd = self.testWindowEnd {
            try encodeContainer.encodeTimestamp(testWindowEnd, format: .epochSeconds, forKey: .testWindowEnd)
        }
        if let testWindowStart = self.testWindowStart {
            try encodeContainer.encodeTimestamp(testWindowStart, format: .epochSeconds, forKey: .testWindowStart)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testWindowStartDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .testWindowStart)
        testWindowStart = testWindowStartDecoded
        let testWindowEndDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .testWindowEnd)
        testWindowEnd = testWindowEndDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let evaluationTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EvaluationType.self, forKey: .evaluationType)
        evaluationType = evaluationTypeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Metrics.self, forKey: .metrics)
        metrics = metricsDecoded
    }
}

extension ForecastClientTypes {
    /// The metrics for a time range within the evaluation portion of a dataset. This object is part of the [EvaluationResult] object. The TestWindowStart and TestWindowEnd parameters are determined by the BackTestWindowOffset parameter of the [EvaluationParameters] object.
    public struct WindowSummary: Swift.Equatable {
        /// The type of evaluation.
        ///
        /// * SUMMARY - The average metrics across all windows.
        ///
        /// * COMPUTED - The metrics for the specified window.
        public var evaluationType: ForecastClientTypes.EvaluationType?
        /// The number of data points within the window.
        public var itemCount: Swift.Int?
        /// Provides metrics used to evaluate the performance of a predictor.
        public var metrics: ForecastClientTypes.Metrics?
        /// The timestamp that defines the end of the window.
        public var testWindowEnd: ClientRuntime.Date?
        /// The timestamp that defines the start of the window.
        public var testWindowStart: ClientRuntime.Date?

        public init(
            evaluationType: ForecastClientTypes.EvaluationType? = nil,
            itemCount: Swift.Int? = nil,
            metrics: ForecastClientTypes.Metrics? = nil,
            testWindowEnd: ClientRuntime.Date? = nil,
            testWindowStart: ClientRuntime.Date? = nil
        )
        {
            self.evaluationType = evaluationType
            self.itemCount = itemCount
            self.metrics = metrics
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }
    }

}
