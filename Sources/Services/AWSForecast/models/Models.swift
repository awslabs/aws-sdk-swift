// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ForecastClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case operation = "Operation"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let operationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Operation.self, forKey: .operation)
        operation = operationDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension ForecastClientTypes {
    /// Defines the modifications that you are making to an attribute for a what-if forecast. For example, you can use this operation to create a what-if forecast that investigates a 10% off sale on all shoes. To do this, you specify "AttributeName": "shoes", "Operation": "MULTIPLY", and "Value": "0.90". Pair this operation with the [TimeSeriesCondition] operation within the [CreateWhatIfForecastRequest$TimeSeriesTransformations] operation to define a subset of attribute items that are modified.
    public struct Action: Swift.Equatable {
        /// The related time series that you are modifying. This value is case insensitive.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The operation that is applied to the provided attribute. Operations include:
        ///
        /// * ADD - adds Value to all rows of AttributeName.
        ///
        /// * SUBTRACT - subtracts Value from all rows of AttributeName.
        ///
        /// * MULTIPLY - multiplies all rows of AttributeName by Value.
        ///
        /// * DIVIDE - divides all rows of AttributeName by Value.
        /// This member is required.
        public var operation: ForecastClientTypes.Operation?
        /// The value that is applied for the chosen Operation.
        /// This member is required.
        public var value: Swift.Double?

        public init (
            attributeName: Swift.String? = nil,
            operation: ForecastClientTypes.Operation? = nil,
            value: Swift.Double? = nil
        )
        {
            self.attributeName = attributeName
            self.operation = operation
            self.value = value
        }
    }

}

extension ForecastClientTypes.AdditionalDataset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configuration)
            for (dictKey0, configuration0) in configuration {
                var configuration0Container = configurationContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for value1 in configuration0 {
                    try configuration0Container.encode(value1)
                }
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configurationContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .configuration)
        var configurationDecoded0: [Swift.String:[Swift.String]]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, values0) in configurationContainer {
                var values0Decoded0: [Swift.String]? = nil
                if let values0 = values0 {
                    values0Decoded0 = [Swift.String]()
                    for string1 in values0 {
                        if let string1 = string1 {
                            values0Decoded0?.append(string1)
                        }
                    }
                }
                configurationDecoded0?[key0] = values0Decoded0
            }
        }
        configuration = configurationDecoded0
    }
}

extension ForecastClientTypes {
    /// Describes an additional dataset. This object is part of the [DataConfig] object. Forecast supports the Weather Index and Holidays additional datasets. Weather Index The Amazon Forecast Weather Index is a built-in dataset that incorporates historical and projected weather information into your model. The Weather Index supplements your datasets with over two years of historical weather data and up to 14 days of projected weather data. For more information, see [Amazon Forecast Weather Index](https://docs.aws.amazon.com/forecast/latest/dg/weather.html). Holidays Holidays is a built-in dataset that incorporates national holiday information into your model. It provides native support for the holiday calendars of 66 countries. To view the holiday calendars, refer to the [Jollyday](http://jollyday.sourceforge.net/data.html) library. For more information, see [Holidays Featurization](https://docs.aws.amazon.com/forecast/latest/dg/holidays.html).
    public struct AdditionalDataset: Swift.Equatable {
        /// Weather Index To enable the Weather Index, do not specify a value for Configuration. Holidays Holidays To enable Holidays, set CountryCode to one of the following two-letter country codes:
        ///
        /// * "AL" - ALBANIA
        ///
        /// * "AR" - ARGENTINA
        ///
        /// * "AT" - AUSTRIA
        ///
        /// * "AU" - AUSTRALIA
        ///
        /// * "BA" - BOSNIA HERZEGOVINA
        ///
        /// * "BE" - BELGIUM
        ///
        /// * "BG" - BULGARIA
        ///
        /// * "BO" - BOLIVIA
        ///
        /// * "BR" - BRAZIL
        ///
        /// * "BY" - BELARUS
        ///
        /// * "CA" - CANADA
        ///
        /// * "CL" - CHILE
        ///
        /// * "CO" - COLOMBIA
        ///
        /// * "CR" - COSTA RICA
        ///
        /// * "HR" - CROATIA
        ///
        /// * "CZ" - CZECH REPUBLIC
        ///
        /// * "DK" - DENMARK
        ///
        /// * "EC" - ECUADOR
        ///
        /// * "EE" - ESTONIA
        ///
        /// * "ET" - ETHIOPIA
        ///
        /// * "FI" - FINLAND
        ///
        /// * "FR" - FRANCE
        ///
        /// * "DE" - GERMANY
        ///
        /// * "GR" - GREECE
        ///
        /// * "HU" - HUNGARY
        ///
        /// * "IS" - ICELAND
        ///
        /// * "IN" - INDIA
        ///
        /// * "IE" - IRELAND
        ///
        /// * "IT" - ITALY
        ///
        /// * "JP" - JAPAN
        ///
        /// * "KZ" - KAZAKHSTAN
        ///
        /// * "KR" - KOREA
        ///
        /// * "LV" - LATVIA
        ///
        /// * "LI" - LIECHTENSTEIN
        ///
        /// * "LT" - LITHUANIA
        ///
        /// * "LU" - LUXEMBOURG
        ///
        /// * "MK" - MACEDONIA
        ///
        /// * "MT" - MALTA
        ///
        /// * "MX" - MEXICO
        ///
        /// * "MD" - MOLDOVA
        ///
        /// * "ME" - MONTENEGRO
        ///
        /// * "NL" - NETHERLANDS
        ///
        /// * "NZ" - NEW ZEALAND
        ///
        /// * "NI" - NICARAGUA
        ///
        /// * "NG" - NIGERIA
        ///
        /// * "NO" - NORWAY
        ///
        /// * "PA" - PANAMA
        ///
        /// * "PY" - PARAGUAY
        ///
        /// * "PE" - PERU
        ///
        /// * "PL" - POLAND
        ///
        /// * "PT" - PORTUGAL
        ///
        /// * "RO" - ROMANIA
        ///
        /// * "RU" - RUSSIA
        ///
        /// * "RS" - SERBIA
        ///
        /// * "SK" - SLOVAKIA
        ///
        /// * "SI" - SLOVENIA
        ///
        /// * "ZA" - SOUTH AFRICA
        ///
        /// * "ES" - SPAIN
        ///
        /// * "SE" - SWEDEN
        ///
        /// * "CH" - SWITZERLAND
        ///
        /// * "UA" - UKRAINE
        ///
        /// * "AE" - UNITED ARAB EMIRATES
        ///
        /// * "US" - UNITED STATES
        ///
        /// * "UK" - UNITED KINGDOM
        ///
        /// * "UY" - URUGUAY
        ///
        /// * "VE" - VENEZUELA
        public var configuration: [Swift.String:[Swift.String]]?
        /// The name of the additional dataset. Valid names: "holiday" and "weather".
        /// This member is required.
        public var name: Swift.String?

        public init (
            configuration: [Swift.String:[Swift.String]]? = nil,
            name: Swift.String? = nil
        )
        {
            self.configuration = configuration
            self.name = name
        }
    }

}

extension ForecastClientTypes.AttributeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case transformations = "Transformations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let transformations = transformations {
            var transformationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .transformations)
            for (dictKey0, transformations0) in transformations {
                try transformationsContainer.encode(transformations0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let transformationsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .transformations)
        var transformationsDecoded0: [Swift.String:Swift.String]? = nil
        if let transformationsContainer = transformationsContainer {
            transformationsDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in transformationsContainer {
                if let value0 = value0 {
                    transformationsDecoded0?[key0] = value0
                }
            }
        }
        transformations = transformationsDecoded0
    }
}

extension ForecastClientTypes {
    /// Provides information about the method used to transform attributes. The following is an example using the RETAIL domain: {
    ///     "AttributeName": "demand",
    ///
    ///
    ///     "Transformations": {"aggregation": "sum", "middlefill": "zero", "backfill": "zero"}
    ///
    ///
    ///     }
    public struct AttributeConfig: Swift.Equatable {
        /// The name of the attribute as specified in the schema. Amazon Forecast supports the target field of the target time series and the related time series datasets. For example, for the RETAIL domain, the target is demand.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters. The following list shows the parameters and their valid values for the "filling" featurization method for a Target Time Series dataset. Default values are bolded.
        ///
        /// * aggregation: sum, avg, first, min, max
        ///
        /// * frontfill: none
        ///
        /// * middlefill: zero, nan (not a number), value, median, mean, min, max
        ///
        /// * backfill: zero, nan, value, median, mean, min, max
        ///
        ///
        /// The following list shows the parameters and their valid values for a Related Time Series featurization method (there are no defaults):
        ///
        /// * middlefill: zero, value, median, mean, min, max
        ///
        /// * backfill: zero, value, median, mean, min, max
        ///
        /// * futurefill: zero, value, median, mean, min, max
        ///
        ///
        /// To set a filling method to a specific value, set the fill parameter to value and define the value in a corresponding _value parameter. For example, to set backfilling to a value of 2, include the following: "backfill": "value" and "backfill_value":"2".
        /// This member is required.
        public var transformations: [Swift.String:Swift.String]?

        public init (
            attributeName: Swift.String? = nil,
            transformations: [Swift.String:Swift.String]? = nil
        )
        {
            self.attributeName = attributeName
            self.transformations = transformations
        }
    }

}

extension ForecastClientTypes {
    public enum AttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case float
        case geolocation
        case integer
        case string
        case timestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeType] {
            return [
                .float,
                .geolocation,
                .integer,
                .string,
                .timestamp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .float: return "float"
            case .geolocation: return "geolocation"
            case .integer: return "integer"
            case .string: return "string"
            case .timestamp: return "timestamp"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttributeType(rawValue: rawValue) ?? AttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes {
    public enum AutoMLOverrideStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accuracyoptimized
        case latencyoptimized
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoMLOverrideStrategy] {
            return [
                .accuracyoptimized,
                .latencyoptimized,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accuracyoptimized: return "AccuracyOptimized"
            case .latencyoptimized: return "LatencyOptimized"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoMLOverrideStrategy(rawValue: rawValue) ?? AutoMLOverrideStrategy.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.Baseline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBaseline = "PredictorBaseline"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorBaseline = self.predictorBaseline {
            try encodeContainer.encode(predictorBaseline, forKey: .predictorBaseline)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBaselineDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.PredictorBaseline.self, forKey: .predictorBaseline)
        predictorBaseline = predictorBaselineDecoded
    }
}

extension ForecastClientTypes {
    /// Metrics you can use as a baseline for comparison purposes. Use these metrics when you interpret monitoring results for an auto predictor.
    public struct Baseline: Swift.Equatable {
        /// The initial [accuracy metrics](https://docs.aws.amazon.com/forecast/latest/dg/metrics.html) for the predictor you are monitoring. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.
        public var predictorBaseline: ForecastClientTypes.PredictorBaseline?

        public init (
            predictorBaseline: ForecastClientTypes.PredictorBaseline? = nil
        )
        {
            self.predictorBaseline = predictorBaseline
        }
    }

}

extension ForecastClientTypes.BaselineMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension ForecastClientTypes {
    /// An individual metric that you can use for comparison as you evaluate your monitoring results.
    public struct BaselineMetric: Swift.Equatable {
        /// The name of the metric.
        public var name: Swift.String?
        /// The value for the metric.
        public var value: Swift.Double?

        public init (
            name: Swift.String? = nil,
            value: Swift.Double? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ForecastClientTypes.CategoricalParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for value0 in values {
                try valuesContainer.encode(value0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ForecastClientTypes {
    /// Specifies a categorical hyperparameter and it's range of tunable values. This object is part of the [ParameterRanges] object.
    public struct CategoricalParameterRange: Swift.Equatable {
        /// The name of the categorical hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// A list of the tunable categories for the hyperparameter.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension ForecastClientTypes {
    public enum Condition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case greaterThan
        case lessThan
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [Condition] {
            return [
                .equals,
                .greaterThan,
                .lessThan,
                .notEquals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Condition(rawValue: rawValue) ?? Condition.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.ContinuousParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxValue = "MaxValue"
        case minValue = "MinValue"
        case name = "Name"
        case scalingType = "ScalingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxValue = self.maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minValue = self.minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scalingType = self.scalingType {
            try encodeContainer.encode(scalingType.rawValue, forKey: .scalingType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minValue)
        minValue = minValueDecoded
        let scalingTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ScalingType.self, forKey: .scalingType)
        scalingType = scalingTypeDecoded
    }
}

extension ForecastClientTypes {
    /// Specifies a continuous hyperparameter and it's range of tunable values. This object is part of the [ParameterRanges] object.
    public struct ContinuousParameterRange: Swift.Equatable {
        /// The maximum tunable value of the hyperparameter.
        /// This member is required.
        public var maxValue: Swift.Double?
        /// The minimum tunable value of the hyperparameter.
        /// This member is required.
        public var minValue: Swift.Double?
        /// The name of the hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values: Auto Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter. Linear Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale. Logarithmic Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have values greater than 0. ReverseLogarithmic hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale. Reverse logarithmic scaling works only for ranges that are entirely within the range 0 <= x < 1.0. For information about choosing a hyperparameter scale, see [Hyperparameter Scaling](http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type). One of the following values:
        public var scalingType: ForecastClientTypes.ScalingType?

        public init (
            maxValue: Swift.Double? = nil,
            minValue: Swift.Double? = nil,
            name: Swift.String? = nil,
            scalingType: ForecastClientTypes.ScalingType? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }
    }

}

extension CreateAutoPredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataConfig = "DataConfig"
        case encryptionConfig = "EncryptionConfig"
        case explainPredictor = "ExplainPredictor"
        case forecastDimensions = "ForecastDimensions"
        case forecastFrequency = "ForecastFrequency"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case monitorConfig = "MonitorConfig"
        case optimizationMetric = "OptimizationMetric"
        case predictorName = "PredictorName"
        case referencePredictorArn = "ReferencePredictorArn"
        case tags = "Tags"
        case timeAlignmentBoundary = "TimeAlignmentBoundary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataConfig = self.dataConfig {
            try encodeContainer.encode(dataConfig, forKey: .dataConfig)
        }
        if let encryptionConfig = self.encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let explainPredictor = self.explainPredictor {
            try encodeContainer.encode(explainPredictor, forKey: .explainPredictor)
        }
        if let forecastDimensions = forecastDimensions {
            var forecastDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastDimensions)
            for name0 in forecastDimensions {
                try forecastDimensionsContainer.encode(name0)
            }
        }
        if let forecastFrequency = self.forecastFrequency {
            try encodeContainer.encode(forecastFrequency, forKey: .forecastFrequency)
        }
        if let forecastHorizon = self.forecastHorizon {
            try encodeContainer.encode(forecastHorizon, forKey: .forecastHorizon)
        }
        if let forecastTypes = forecastTypes {
            var forecastTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastTypes)
            for forecasttype0 in forecastTypes {
                try forecastTypesContainer.encode(forecasttype0)
            }
        }
        if let monitorConfig = self.monitorConfig {
            try encodeContainer.encode(monitorConfig, forKey: .monitorConfig)
        }
        if let optimizationMetric = self.optimizationMetric {
            try encodeContainer.encode(optimizationMetric.rawValue, forKey: .optimizationMetric)
        }
        if let predictorName = self.predictorName {
            try encodeContainer.encode(predictorName, forKey: .predictorName)
        }
        if let referencePredictorArn = self.referencePredictorArn {
            try encodeContainer.encode(referencePredictorArn, forKey: .referencePredictorArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeAlignmentBoundary = self.timeAlignmentBoundary {
            try encodeContainer.encode(timeAlignmentBoundary, forKey: .timeAlignmentBoundary)
        }
    }
}

extension CreateAutoPredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAutoPredictorInput: Swift.Equatable {
    /// The data configuration for your dataset group and any additional datasets.
    public var dataConfig: ForecastClientTypes.DataConfig?
    /// An AWS Key Management Service (KMS) key and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key. You can specify this optional object in the [CreateDataset] and [CreatePredictor] requests.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// Create an Explainability resource for the predictor.
    public var explainPredictor: Swift.Bool?
    /// An array of dimension (field) names that specify how to group the generated forecast. For example, if you are generating forecasts for item sales across all your stores, and your dataset contains a store_id field, you would specify store_id as a dimension to group sales forecasts for each store.
    public var forecastDimensions: [Swift.String]?
    /// The frequency of predictions in a forecast. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes. The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency. When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the RELATED_TIME_SERIES dataset frequency.
    public var forecastFrequency: Swift.String?
    /// The number of time-steps that the model predicts. The forecast horizon is also called the prediction length. The maximum forecast horizon is the lesser of 500 time-steps or 1/4 of the TARGET_TIME_SERIES dataset length. If you are retraining an existing AutoPredictor, then the maximum forecast horizon is the lesser of 500 time-steps or 1/3 of the TARGET_TIME_SERIES dataset length. If you are upgrading to an AutoPredictor or retraining an existing AutoPredictor, you cannot update the forecast horizon parameter. You can meet this requirement by providing longer time-series in the dataset.
    public var forecastHorizon: Swift.Int?
    /// The forecast types used to train a predictor. You can specify up to five forecast types. Forecast types can be quantiles from 0.01 to 0.99, by increments of 0.01 or higher. You can also specify the mean forecast with mean.
    public var forecastTypes: [Swift.String]?
    /// The configuration details for predictor monitoring. Provide a name for the monitor resource to enable predictor monitoring. Predictor monitoring allows you to see how your predictor's performance changes over time. For more information, see [Predictor Monitoring](https://docs.aws.amazon.com/forecast/latest/dg/predictor-monitoring.html).
    public var monitorConfig: ForecastClientTypes.MonitorConfig?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// A unique name for the predictor
    /// This member is required.
    public var predictorName: Swift.String?
    /// The ARN of the predictor to retrain or upgrade. This parameter is only used when retraining or upgrading a predictor. When creating a new predictor, do not specify a value for this parameter. When upgrading or retraining a predictor, only specify values for the ReferencePredictorArn and PredictorName. The value for PredictorName must be a unique predictor name.
    public var referencePredictorArn: Swift.String?
    /// Optional metadata to help you categorize and organize your predictors. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?
    /// The time boundary Forecast uses to align and aggregate any data that doesn't align with your forecast frequency. Provide the unit of time and the time boundary as a key value pair. For more information on specifying a time boundary, see [Specifying a Time Boundary](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html#specifying-time-boundary). If you don't provide a time boundary, Forecast uses a set of [Default Time Boundaries](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html#default-time-boundaries).
    public var timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary?

    public init (
        dataConfig: ForecastClientTypes.DataConfig? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        explainPredictor: Swift.Bool? = nil,
        forecastDimensions: [Swift.String]? = nil,
        forecastFrequency: Swift.String? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        monitorConfig: ForecastClientTypes.MonitorConfig? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        predictorName: Swift.String? = nil,
        referencePredictorArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary? = nil
    )
    {
        self.dataConfig = dataConfig
        self.encryptionConfig = encryptionConfig
        self.explainPredictor = explainPredictor
        self.forecastDimensions = forecastDimensions
        self.forecastFrequency = forecastFrequency
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.monitorConfig = monitorConfig
        self.optimizationMetric = optimizationMetric
        self.predictorName = predictorName
        self.referencePredictorArn = referencePredictorArn
        self.tags = tags
        self.timeAlignmentBoundary = timeAlignmentBoundary
    }
}

struct CreateAutoPredictorInputBody: Swift.Equatable {
    let predictorName: Swift.String?
    let forecastHorizon: Swift.Int?
    let forecastTypes: [Swift.String]?
    let forecastDimensions: [Swift.String]?
    let forecastFrequency: Swift.String?
    let dataConfig: ForecastClientTypes.DataConfig?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let referencePredictorArn: Swift.String?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
    let explainPredictor: Swift.Bool?
    let tags: [ForecastClientTypes.Tag]?
    let monitorConfig: ForecastClientTypes.MonitorConfig?
    let timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary?
}

extension CreateAutoPredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataConfig = "DataConfig"
        case encryptionConfig = "EncryptionConfig"
        case explainPredictor = "ExplainPredictor"
        case forecastDimensions = "ForecastDimensions"
        case forecastFrequency = "ForecastFrequency"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case monitorConfig = "MonitorConfig"
        case optimizationMetric = "OptimizationMetric"
        case predictorName = "PredictorName"
        case referencePredictorArn = "ReferencePredictorArn"
        case tags = "Tags"
        case timeAlignmentBoundary = "TimeAlignmentBoundary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let forecastDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastDimensions)
        var forecastDimensionsDecoded0:[Swift.String]? = nil
        if let forecastDimensionsContainer = forecastDimensionsContainer {
            forecastDimensionsDecoded0 = [Swift.String]()
            for string0 in forecastDimensionsContainer {
                if let string0 = string0 {
                    forecastDimensionsDecoded0?.append(string0)
                }
            }
        }
        forecastDimensions = forecastDimensionsDecoded0
        let forecastFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastFrequency)
        forecastFrequency = forecastFrequencyDecoded
        let dataConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataConfig.self, forKey: .dataConfig)
        dataConfig = dataConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let referencePredictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referencePredictorArn)
        referencePredictorArn = referencePredictorArnDecoded
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
        let explainPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .explainPredictor)
        explainPredictor = explainPredictorDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let monitorConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.MonitorConfig.self, forKey: .monitorConfig)
        monitorConfig = monitorConfigDecoded
        let timeAlignmentBoundaryDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeAlignmentBoundary.self, forKey: .timeAlignmentBoundary)
        timeAlignmentBoundary = timeAlignmentBoundaryDecoded
    }
}

extension CreateAutoPredictorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAutoPredictorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAutoPredictorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAutoPredictorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAutoPredictorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.predictorArn = output.predictorArn
        } else {
            self.predictorArn = nil
        }
    }
}

public struct CreateAutoPredictorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct CreateAutoPredictorOutputResponseBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension CreateAutoPredictorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension CreateDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArns = datasetArns {
            var datasetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasetArns)
            for arn0 in datasetArns {
                try datasetArnsContainer.encode(arn0)
            }
        }
        if let datasetGroupName = self.datasetGroupName {
            try encodeContainer.encode(datasetGroupName, forKey: .datasetGroupName)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetGroupInput: Swift.Equatable {
    /// An array of Amazon Resource Names (ARNs) of the datasets that you want to include in the dataset group.
    public var datasetArns: [Swift.String]?
    /// A name for the dataset group.
    /// This member is required.
    public var datasetGroupName: Swift.String?
    /// The domain associated with the dataset group. When you add a dataset to a dataset group, this value and the value specified for the Domain parameter of the [CreateDataset](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDataset.html) operation must match. The Domain and DatasetType that you choose determine the fields that must be present in training data that you import to a dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires that item_id, timestamp, and demand fields are present in your data. For more information, see [Dataset groups](https://docs.aws.amazon.com/forecast/latest/dg/howitworks-datasets-groups.html).
    /// This member is required.
    public var domain: ForecastClientTypes.Domain?
    /// The optional metadata that you apply to the dataset group to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        datasetArns: [Swift.String]? = nil,
        datasetGroupName: Swift.String? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.datasetArns = datasetArns
        self.datasetGroupName = datasetGroupName
        self.domain = domain
        self.tags = tags
    }
}

struct CreateDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupName: Swift.String?
    let domain: ForecastClientTypes.Domain?
    let datasetArns: [Swift.String]?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[Swift.String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [Swift.String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDatasetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroupArn = output.datasetGroupArn
        } else {
            self.datasetGroupArn = nil
        }
    }
}

public struct CreateDatasetGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct CreateDatasetGroupOutputResponseBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
}

extension CreateDatasetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension CreateDatasetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobName = "DatasetImportJobName"
        case format = "Format"
        case geolocationFormat = "GeolocationFormat"
        case tags = "Tags"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetImportJobName = self.datasetImportJobName {
            try encodeContainer.encode(datasetImportJobName, forKey: .datasetImportJobName)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let geolocationFormat = self.geolocationFormat {
            try encodeContainer.encode(geolocationFormat, forKey: .geolocationFormat)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeZone = self.timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
        if let timestampFormat = self.timestampFormat {
            try encodeContainer.encode(timestampFormat, forKey: .timestampFormat)
        }
        if useGeolocationForTimeZone != false {
            try encodeContainer.encode(useGeolocationForTimeZone, forKey: .useGeolocationForTimeZone)
        }
    }
}

extension CreateDatasetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetImportJobInput: Swift.Equatable {
    /// The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket. If encryption is used, DataSource must include an AWS Key Management Service (KMS) key and the IAM role must allow Amazon Forecast permission to access the key. The KMS key and IAM role must match those specified in the EncryptionConfig parameter of the [CreateDataset](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDataset.html) operation.
    /// This member is required.
    public var dataSource: ForecastClientTypes.DataSource?
    /// The Amazon Resource Name (ARN) of the Amazon Forecast dataset that you want to import data to.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// The name for the dataset import job. We recommend including the current timestamp in the name, for example, 20190721DatasetImport. This can help you avoid getting a ResourceAlreadyExistsException exception.
    /// This member is required.
    public var datasetImportJobName: Swift.String?
    /// The format of the imported data, CSV or PARQUET. The default value is CSV.
    public var format: Swift.String?
    /// The format of the geolocation attribute. The geolocation attribute can be formatted in one of two ways:
    ///
    /// * LAT_LONG - the latitude and longitude in decimal format (Example: 47.61_-122.33).
    ///
    /// * CC_POSTALCODE (US Only) - the country code (US), followed by the 5-digit ZIP code (Example: US_98121).
    public var geolocationFormat: Swift.String?
    /// The optional metadata that you apply to the dataset import job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?
    /// A single time zone for every item in your dataset. This option is ideal for datasets with all timestamps within a single time zone, or if all timestamps are normalized to a single time zone. Refer to the [Joda-Time API](http://joda-time.sourceforge.net/timezones.html) for a complete list of valid time zone names.
    public var timeZone: Swift.String?
    /// The format of timestamps in the dataset. The format that you specify depends on the DataFrequency specified when the dataset was created. The following formats are supported
    ///
    /// * "yyyy-MM-dd" For the following data frequencies: Y, M, W, and D
    ///
    /// * "yyyy-MM-dd HH:mm:ss" For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y, M, W, and D
    ///
    ///
    /// If the format isn't specified, Amazon Forecast expects the format to be "yyyy-MM-dd HH:mm:ss".
    public var timestampFormat: Swift.String?
    /// Automatically derive time zone information from the geolocation attribute. This option is ideal for datasets that contain timestamps in multiple time zones and those timestamps are expressed in local time.
    public var useGeolocationForTimeZone: Swift.Bool

    public init (
        dataSource: ForecastClientTypes.DataSource? = nil,
        datasetArn: Swift.String? = nil,
        datasetImportJobName: Swift.String? = nil,
        format: Swift.String? = nil,
        geolocationFormat: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        timeZone: Swift.String? = nil,
        timestampFormat: Swift.String? = nil,
        useGeolocationForTimeZone: Swift.Bool = false
    )
    {
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.datasetImportJobName = datasetImportJobName
        self.format = format
        self.geolocationFormat = geolocationFormat
        self.tags = tags
        self.timeZone = timeZone
        self.timestampFormat = timestampFormat
        self.useGeolocationForTimeZone = useGeolocationForTimeZone
    }
}

struct CreateDatasetImportJobInputBody: Swift.Equatable {
    let datasetImportJobName: Swift.String?
    let datasetArn: Swift.String?
    let dataSource: ForecastClientTypes.DataSource?
    let timestampFormat: Swift.String?
    let timeZone: Swift.String?
    let useGeolocationForTimeZone: Swift.Bool
    let geolocationFormat: Swift.String?
    let tags: [ForecastClientTypes.Tag]?
    let format: Swift.String?
}

extension CreateDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobName = "DatasetImportJobName"
        case format = "Format"
        case geolocationFormat = "GeolocationFormat"
        case tags = "Tags"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let timestampFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampFormat)
        timestampFormat = timestampFormatDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let useGeolocationForTimeZoneDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useGeolocationForTimeZone) ?? false
        useGeolocationForTimeZone = useGeolocationForTimeZoneDecoded
        let geolocationFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geolocationFormat)
        geolocationFormat = geolocationFormatDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension CreateDatasetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDatasetImportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDatasetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJobArn = output.datasetImportJobArn
        } else {
            self.datasetImportJobArn = nil
        }
    }
}

public struct CreateDatasetImportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job.
    public var datasetImportJobArn: Swift.String?

    public init (
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct CreateDatasetImportJobOutputResponseBody: Swift.Equatable {
    let datasetImportJobArn: Swift.String?
}

extension CreateDatasetImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension CreateDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataFrequency = "DataFrequency"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case schema = "Schema"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataFrequency = self.dataFrequency {
            try encodeContainer.encode(dataFrequency, forKey: .dataFrequency)
        }
        if let datasetName = self.datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let datasetType = self.datasetType {
            try encodeContainer.encode(datasetType.rawValue, forKey: .datasetType)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let encryptionConfig = self.encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetInput: Swift.Equatable {
    /// The frequency of data collection. This parameter is required for RELATED_TIME_SERIES datasets. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "D" indicates every day and "15min" indicates every 15 minutes.
    public var dataFrequency: Swift.String?
    /// A name for the dataset.
    /// This member is required.
    public var datasetName: Swift.String?
    /// The dataset type. Valid values depend on the chosen Domain.
    /// This member is required.
    public var datasetType: ForecastClientTypes.DatasetType?
    /// The domain associated with the dataset. When you add a dataset to a dataset group, this value and the value specified for the Domain parameter of the [CreateDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetGroup.html) operation must match. The Domain and DatasetType that you choose determine the fields that must be present in the training data that you import to the dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires item_id, timestamp, and demand fields to be present in your data. For more information, see [Importing datasets](https://docs.aws.amazon.com/forecast/latest/dg/howitworks-datasets-groups.html).
    /// This member is required.
    public var domain: ForecastClientTypes.Domain?
    /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// The schema for the dataset. The schema attributes and their order must match the fields in your data. The dataset Domain and DatasetType that you choose determine the minimum required fields in your training data. For information about the required fields for a specific dataset domain and type, see [Dataset Domains and Dataset Types](https://docs.aws.amazon.com/forecast/latest/dg/howitworks-domains-ds-types.html).
    /// This member is required.
    public var schema: ForecastClientTypes.Schema?
    /// The optional metadata that you apply to the dataset to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        dataFrequency: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        datasetType: ForecastClientTypes.DatasetType? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.dataFrequency = dataFrequency
        self.datasetName = datasetName
        self.datasetType = datasetType
        self.domain = domain
        self.encryptionConfig = encryptionConfig
        self.schema = schema
        self.tags = tags
    }
}

struct CreateDatasetInputBody: Swift.Equatable {
    let datasetName: Swift.String?
    let domain: ForecastClientTypes.Domain?
    let datasetType: ForecastClientTypes.DatasetType?
    let dataFrequency: Swift.String?
    let schema: ForecastClientTypes.Schema?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataFrequency = "DataFrequency"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case schema = "Schema"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let dataFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataFrequency)
        dataFrequency = dataFrequencyDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetArn = output.datasetArn
        } else {
            self.datasetArn = nil
        }
    }
}

public struct CreateDatasetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct CreateDatasetOutputResponseBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension CreateDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension CreateExplainabilityExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityExportName = "ExplainabilityExportName"
        case format = "Format"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let explainabilityArn = self.explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
        if let explainabilityExportName = self.explainabilityExportName {
            try encodeContainer.encode(explainabilityExportName, forKey: .explainabilityExportName)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateExplainabilityExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateExplainabilityExportInput: Swift.Equatable {
    /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the Explainability to export.
    /// This member is required.
    public var explainabilityArn: Swift.String?
    /// A unique name for the Explainability export.
    /// This member is required.
    public var explainabilityExportName: Swift.String?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// Optional metadata to help you categorize and organize your resources. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        destination: ForecastClientTypes.DataDestination? = nil,
        explainabilityArn: Swift.String? = nil,
        explainabilityExportName: Swift.String? = nil,
        format: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.destination = destination
        self.explainabilityArn = explainabilityArn
        self.explainabilityExportName = explainabilityExportName
        self.format = format
        self.tags = tags
    }
}

struct CreateExplainabilityExportInputBody: Swift.Equatable {
    let explainabilityExportName: Swift.String?
    let explainabilityArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let tags: [ForecastClientTypes.Tag]?
    let format: Swift.String?
}

extension CreateExplainabilityExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityExportName = "ExplainabilityExportName"
        case format = "Format"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportName)
        explainabilityExportName = explainabilityExportNameDecoded
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension CreateExplainabilityExportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateExplainabilityExportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateExplainabilityExportOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateExplainabilityExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateExplainabilityExportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.explainabilityExportArn = output.explainabilityExportArn
        } else {
            self.explainabilityExportArn = nil
        }
    }
}

public struct CreateExplainabilityExportOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the export.
    public var explainabilityExportArn: Swift.String?

    public init (
        explainabilityExportArn: Swift.String? = nil
    )
    {
        self.explainabilityExportArn = explainabilityExportArn
    }
}

struct CreateExplainabilityExportOutputResponseBody: Swift.Equatable {
    let explainabilityExportArn: Swift.String?
}

extension CreateExplainabilityExportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
    }
}

extension CreateExplainabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case enableVisualization = "EnableVisualization"
        case endDateTime = "EndDateTime"
        case explainabilityConfig = "ExplainabilityConfig"
        case explainabilityName = "ExplainabilityName"
        case resourceArn = "ResourceArn"
        case schema = "Schema"
        case startDateTime = "StartDateTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let enableVisualization = self.enableVisualization {
            try encodeContainer.encode(enableVisualization, forKey: .enableVisualization)
        }
        if let endDateTime = self.endDateTime {
            try encodeContainer.encode(endDateTime, forKey: .endDateTime)
        }
        if let explainabilityConfig = self.explainabilityConfig {
            try encodeContainer.encode(explainabilityConfig, forKey: .explainabilityConfig)
        }
        if let explainabilityName = self.explainabilityName {
            try encodeContainer.encode(explainabilityName, forKey: .explainabilityName)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encode(startDateTime, forKey: .startDateTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateExplainabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateExplainabilityInput: Swift.Equatable {
    /// The source of your data, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an AWS Key Management Service (KMS) key.
    public var dataSource: ForecastClientTypes.DataSource?
    /// Create an Explainability visualization that is viewable within the AWS console.
    public var enableVisualization: Swift.Bool?
    /// If TimePointGranularity is set to SPECIFIC, define the last time point for the Explainability. Use the following timestamp format: yyyy-MM-ddTHH:mm:ss (example: 2015-01-01T20:00:00)
    public var endDateTime: Swift.String?
    /// The configuration settings that define the granularity of time series and time points for the Explainability.
    /// This member is required.
    public var explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
    /// A unique name for the Explainability.
    /// This member is required.
    public var explainabilityName: Swift.String?
    /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Defines the fields of a dataset.
    public var schema: ForecastClientTypes.Schema?
    /// If TimePointGranularity is set to SPECIFIC, define the first point for the Explainability. Use the following timestamp format: yyyy-MM-ddTHH:mm:ss (example: 2015-01-01T20:00:00)
    public var startDateTime: Swift.String?
    /// Optional metadata to help you categorize and organize your resources. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        dataSource: ForecastClientTypes.DataSource? = nil,
        enableVisualization: Swift.Bool? = nil,
        endDateTime: Swift.String? = nil,
        explainabilityConfig: ForecastClientTypes.ExplainabilityConfig? = nil,
        explainabilityName: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        startDateTime: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.dataSource = dataSource
        self.enableVisualization = enableVisualization
        self.endDateTime = endDateTime
        self.explainabilityConfig = explainabilityConfig
        self.explainabilityName = explainabilityName
        self.resourceArn = resourceArn
        self.schema = schema
        self.startDateTime = startDateTime
        self.tags = tags
    }
}

struct CreateExplainabilityInputBody: Swift.Equatable {
    let explainabilityName: Swift.String?
    let resourceArn: Swift.String?
    let explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
    let dataSource: ForecastClientTypes.DataSource?
    let schema: ForecastClientTypes.Schema?
    let enableVisualization: Swift.Bool?
    let startDateTime: Swift.String?
    let endDateTime: Swift.String?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateExplainabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case enableVisualization = "EnableVisualization"
        case endDateTime = "EndDateTime"
        case explainabilityConfig = "ExplainabilityConfig"
        case explainabilityName = "ExplainabilityName"
        case resourceArn = "ResourceArn"
        case schema = "Schema"
        case startDateTime = "StartDateTime"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityName)
        explainabilityName = explainabilityNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let explainabilityConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ExplainabilityConfig.self, forKey: .explainabilityConfig)
        explainabilityConfig = explainabilityConfigDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let enableVisualizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableVisualization)
        enableVisualization = enableVisualizationDecoded
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateExplainabilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateExplainabilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateExplainabilityOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateExplainabilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateExplainabilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.explainabilityArn = output.explainabilityArn
        } else {
            self.explainabilityArn = nil
        }
    }
}

public struct CreateExplainabilityOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explainability.
    public var explainabilityArn: Swift.String?

    public init (
        explainabilityArn: Swift.String? = nil
    )
    {
        self.explainabilityArn = explainabilityArn
    }
}

struct CreateExplainabilityOutputResponseBody: Swift.Equatable {
    let explainabilityArn: Swift.String?
}

extension CreateExplainabilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
    }
}

extension CreateForecastExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobName = "ForecastExportJobName"
        case format = "Format"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let forecastArn = self.forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let forecastExportJobName = self.forecastExportJobName {
            try encodeContainer.encode(forecastExportJobName, forKey: .forecastExportJobName)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateForecastExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateForecastExportJobInput: Swift.Equatable {
    /// The location where you want to save the forecast and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the location. The forecast must be exported to an Amazon S3 bucket. If encryption is used, Destination must include an AWS Key Management Service (KMS) key. The IAM role must allow Amazon Forecast permission to access the key.
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the forecast that you want to export.
    /// This member is required.
    public var forecastArn: Swift.String?
    /// The name for the forecast export job.
    /// This member is required.
    public var forecastExportJobName: Swift.String?
    /// The format of the exported data, CSV or PARQUET. The default value is CSV.
    public var format: Swift.String?
    /// The optional metadata that you apply to the forecast export job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        destination: ForecastClientTypes.DataDestination? = nil,
        forecastArn: Swift.String? = nil,
        forecastExportJobName: Swift.String? = nil,
        format: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.destination = destination
        self.forecastArn = forecastArn
        self.forecastExportJobName = forecastExportJobName
        self.format = format
        self.tags = tags
    }
}

struct CreateForecastExportJobInputBody: Swift.Equatable {
    let forecastExportJobName: Swift.String?
    let forecastArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let tags: [ForecastClientTypes.Tag]?
    let format: Swift.String?
}

extension CreateForecastExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobName = "ForecastExportJobName"
        case format = "Format"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension CreateForecastExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateForecastExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateForecastExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateForecastExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateForecastExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecastExportJobArn = output.forecastExportJobArn
        } else {
            self.forecastExportJobArn = nil
        }
    }
}

public struct CreateForecastExportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the export job.
    public var forecastExportJobArn: Swift.String?

    public init (
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct CreateForecastExportJobOutputResponseBody: Swift.Equatable {
    let forecastExportJobArn: Swift.String?
}

extension CreateForecastExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

extension CreateForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case predictorArn = "PredictorArn"
        case tags = "Tags"
        case timeSeriesSelector = "TimeSeriesSelector"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastName = self.forecastName {
            try encodeContainer.encode(forecastName, forKey: .forecastName)
        }
        if let forecastTypes = forecastTypes {
            var forecastTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastTypes)
            for forecasttype0 in forecastTypes {
                try forecastTypesContainer.encode(forecasttype0)
            }
        }
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeSeriesSelector = self.timeSeriesSelector {
            try encodeContainer.encode(timeSeriesSelector, forKey: .timeSeriesSelector)
        }
    }
}

extension CreateForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateForecastInput: Swift.Equatable {
    /// A name for the forecast.
    /// This member is required.
    public var forecastName: Swift.String?
    /// The quantiles at which probabilistic forecasts are generated. You can currently specify up to 5 quantiles per forecast. Accepted values include 0.01 to 0.99 (increments of .01 only) and mean. The mean forecast is different from the median (0.50) when the distribution is not symmetric (for example, Beta and Negative Binomial). The default quantiles are the quantiles you specified during predictor creation. If you didn't specify quantiles, the default values are ["0.1", "0.5", "0.9"].
    public var forecastTypes: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the predictor to use to generate the forecast.
    /// This member is required.
    public var predictorArn: Swift.String?
    /// The optional metadata that you apply to the forecast to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?
    /// Defines the set of time series that are used to create the forecasts in a TimeSeriesIdentifiers object. The TimeSeriesIdentifiers object needs the following information:
    ///
    /// * DataSource
    ///
    /// * Format
    ///
    /// * Schema
    public var timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?

    public init (
        forecastName: Swift.String? = nil,
        forecastTypes: [Swift.String]? = nil,
        predictorArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector? = nil
    )
    {
        self.forecastName = forecastName
        self.forecastTypes = forecastTypes
        self.predictorArn = predictorArn
        self.tags = tags
        self.timeSeriesSelector = timeSeriesSelector
    }
}

struct CreateForecastInputBody: Swift.Equatable {
    let forecastName: Swift.String?
    let predictorArn: Swift.String?
    let forecastTypes: [Swift.String]?
    let tags: [ForecastClientTypes.Tag]?
    let timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?
}

extension CreateForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case predictorArn = "PredictorArn"
        case tags = "Tags"
        case timeSeriesSelector = "TimeSeriesSelector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let timeSeriesSelectorDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesSelector.self, forKey: .timeSeriesSelector)
        timeSeriesSelector = timeSeriesSelectorDecoded
    }
}

extension CreateForecastOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateForecastOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateForecastOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateForecastOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateForecastOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecastArn = output.forecastArn
        } else {
            self.forecastArn = nil
        }
    }
}

public struct CreateForecastOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast.
    public var forecastArn: Swift.String?

    public init (
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct CreateForecastOutputResponseBody: Swift.Equatable {
    let forecastArn: Swift.String?
}

extension CreateForecastOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

extension CreateMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorName = "MonitorName"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorName = self.monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateMonitorInput: Swift.Equatable {
    /// The name of the monitor resource.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor to monitor.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/forecast/latest/dg/tagging-forecast-resources.html) to apply to the monitor resource.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        monitorName: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.monitorName = monitorName
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct CreateMonitorInputBody: Swift.Equatable {
    let monitorName: Swift.String?
    let resourceArn: Swift.String?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorName = "MonitorName"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMonitorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMonitorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMonitorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMonitorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateMonitorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.monitorArn = output.monitorArn
        } else {
            self.monitorArn = nil
        }
    }
}

public struct CreateMonitorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the monitor resource.
    public var monitorArn: Swift.String?

    public init (
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct CreateMonitorOutputResponseBody: Swift.Equatable {
    let monitorArn: Swift.String?
}

extension CreateMonitorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

extension CreatePredictorBacktestExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case format = "Format"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let predictorBacktestExportJobName = self.predictorBacktestExportJobName {
            try encodeContainer.encode(predictorBacktestExportJobName, forKey: .predictorBacktestExportJobName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreatePredictorBacktestExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePredictorBacktestExportJobInput: Swift.Equatable {
    /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The format of the exported data, CSV or PARQUET. The default value is CSV.
    public var format: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor that you want to export.
    /// This member is required.
    public var predictorArn: Swift.String?
    /// The name for the backtest export job.
    /// This member is required.
    public var predictorBacktestExportJobName: Swift.String?
    /// Optional metadata to help you categorize and organize your backtests. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        destination: ForecastClientTypes.DataDestination? = nil,
        format: Swift.String? = nil,
        predictorArn: Swift.String? = nil,
        predictorBacktestExportJobName: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.destination = destination
        self.format = format
        self.predictorArn = predictorArn
        self.predictorBacktestExportJobName = predictorBacktestExportJobName
        self.tags = tags
    }
}

struct CreatePredictorBacktestExportJobInputBody: Swift.Equatable {
    let predictorBacktestExportJobName: Swift.String?
    let predictorArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let tags: [ForecastClientTypes.Tag]?
    let format: Swift.String?
}

extension CreatePredictorBacktestExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case format = "Format"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension CreatePredictorBacktestExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePredictorBacktestExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePredictorBacktestExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePredictorBacktestExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePredictorBacktestExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.predictorBacktestExportJobArn = output.predictorBacktestExportJobArn
        } else {
            self.predictorBacktestExportJobArn = nil
        }
    }
}

public struct CreatePredictorBacktestExportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job that you want to export.
    public var predictorBacktestExportJobArn: Swift.String?

    public init (
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct CreatePredictorBacktestExportJobOutputResponseBody: Swift.Equatable {
    let predictorBacktestExportJobArn: Swift.String?
}

extension CreatePredictorBacktestExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

extension CreatePredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case encryptionConfig = "EncryptionConfig"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hpoConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case optimizationMetric = "OptimizationMetric"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorName = "PredictorName"
        case tags = "Tags"
        case trainingParameters = "TrainingParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = self.algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let autoMLOverrideStrategy = self.autoMLOverrideStrategy {
            try encodeContainer.encode(autoMLOverrideStrategy.rawValue, forKey: .autoMLOverrideStrategy)
        }
        if let encryptionConfig = self.encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let evaluationParameters = self.evaluationParameters {
            try encodeContainer.encode(evaluationParameters, forKey: .evaluationParameters)
        }
        if let featurizationConfig = self.featurizationConfig {
            try encodeContainer.encode(featurizationConfig, forKey: .featurizationConfig)
        }
        if let forecastHorizon = self.forecastHorizon {
            try encodeContainer.encode(forecastHorizon, forKey: .forecastHorizon)
        }
        if let forecastTypes = forecastTypes {
            var forecastTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastTypes)
            for forecasttype0 in forecastTypes {
                try forecastTypesContainer.encode(forecasttype0)
            }
        }
        if let hpoConfig = self.hpoConfig {
            try encodeContainer.encode(hpoConfig, forKey: .hpoConfig)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let optimizationMetric = self.optimizationMetric {
            try encodeContainer.encode(optimizationMetric.rawValue, forKey: .optimizationMetric)
        }
        if let performAutoML = self.performAutoML {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if let performHPO = self.performHPO {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let predictorName = self.predictorName {
            try encodeContainer.encode(predictorName, forKey: .predictorName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let trainingParameters = trainingParameters {
            var trainingParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .trainingParameters)
            for (dictKey0, trainingParameters0) in trainingParameters {
                try trainingParametersContainer.encode(trainingParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the algorithm to use for model training. Required if PerformAutoML is not set to true. Supported algorithms:
    ///
    /// * arn:aws:forecast:::algorithm/ARIMA
    ///
    /// * arn:aws:forecast:::algorithm/CNN-QR
    ///
    /// * arn:aws:forecast:::algorithm/Deep_AR_Plus
    ///
    /// * arn:aws:forecast:::algorithm/ETS
    ///
    /// * arn:aws:forecast:::algorithm/NPTS
    ///
    /// * arn:aws:forecast:::algorithm/Prophet
    public var algorithmArn: Swift.String?
    /// The LatencyOptimized AutoML override strategy is only available in private beta. Contact AWS Support or your account manager to learn more about access privileges. Used to overide the default AutoML strategy, which is to optimize predictor accuracy. To apply an AutoML strategy that minimizes training time, use LatencyOptimized. This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast evaluates a predictor by splitting a dataset into training data and testing data. The evaluation parameters define how to perform the split and the number of iterations.
    public var evaluationParameters: ForecastClientTypes.EvaluationParameters?
    /// The featurization configuration.
    /// This member is required.
    public var featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    /// Specifies the number of time-steps that the model is trained to predict. The forecast horizon is also called the prediction length. For example, if you configure a dataset for daily data collection (using the DataFrequency parameter of the [CreateDataset] operation) and set the forecast horizon to 10, the model returns predictions for 10 days. The maximum forecast horizon is the lesser of 500 time-steps or 1/3 of the TARGET_TIME_SERIES dataset length.
    /// This member is required.
    public var forecastHorizon: Swift.Int?
    /// Specifies the forecast types used to train a predictor. You can specify up to five forecast types. Forecast types can be quantiles from 0.01 to 0.99, by increments of 0.01 or higher. You can also specify the mean forecast with mean. The default value is ["0.10", "0.50", "0.9"].
    public var forecastTypes: [Swift.String]?
    /// Provides hyperparameter override values for the algorithm. If you don't provide this parameter, Amazon Forecast uses default values. The individual algorithms specify which hyperparameters support hyperparameter optimization (HPO). For more information, see [aws-forecast-choosing-recipes]. If you included the HPOConfig object, you must set PerformHPO to true.
    public var hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    /// Describes the dataset group that contains the data to use to train the predictor.
    /// This member is required.
    public var inputDataConfig: ForecastClientTypes.InputDataConfig?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// Whether to perform AutoML. When Amazon Forecast performs AutoML, it evaluates the algorithms it provides and chooses the best algorithm and configuration for your training dataset. The default value is false. In this case, you are required to specify an algorithm. Set PerformAutoML to true to have Amazon Forecast perform AutoML. This is a good option if you aren't sure which algorithm is suitable for your training data. In this case, PerformHPO must be false.
    public var performAutoML: Swift.Bool?
    /// Whether to perform hyperparameter optimization (HPO). HPO finds optimal hyperparameter values for your training data. The process of performing HPO is known as running a hyperparameter tuning job. The default value is false. In this case, Amazon Forecast uses default hyperparameter values from the chosen algorithm. To override the default values, set PerformHPO to true and, optionally, supply the [HyperParameterTuningJobConfig] object. The tuning job specifies a metric to optimize, which hyperparameters participate in tuning, and the valid range for each tunable hyperparameter. In this case, you are required to specify an algorithm and PerformAutoML must be false. The following algorithms support HPO:
    ///
    /// * DeepAR+
    ///
    /// * CNN-QR
    public var performHPO: Swift.Bool?
    /// A name for the predictor.
    /// This member is required.
    public var predictorName: Swift.String?
    /// The optional metadata that you apply to the predictor to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?
    /// The hyperparameters to override for model training. The hyperparameters that you can override are listed in the individual algorithms. For the list of supported algorithms, see [aws-forecast-choosing-recipes].
    public var trainingParameters: [Swift.String:Swift.String]?

    public init (
        algorithmArn: Swift.String? = nil,
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        evaluationParameters: ForecastClientTypes.EvaluationParameters? = nil,
        featurizationConfig: ForecastClientTypes.FeaturizationConfig? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig? = nil,
        inputDataConfig: ForecastClientTypes.InputDataConfig? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        performAutoML: Swift.Bool? = nil,
        performHPO: Swift.Bool? = nil,
        predictorName: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        trainingParameters: [Swift.String:Swift.String]? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.encryptionConfig = encryptionConfig
        self.evaluationParameters = evaluationParameters
        self.featurizationConfig = featurizationConfig
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.hpoConfig = hpoConfig
        self.inputDataConfig = inputDataConfig
        self.optimizationMetric = optimizationMetric
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.predictorName = predictorName
        self.tags = tags
        self.trainingParameters = trainingParameters
    }
}

struct CreatePredictorInputBody: Swift.Equatable {
    let predictorName: Swift.String?
    let algorithmArn: Swift.String?
    let forecastHorizon: Swift.Int?
    let forecastTypes: [Swift.String]?
    let performAutoML: Swift.Bool?
    let autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    let performHPO: Swift.Bool?
    let trainingParameters: [Swift.String:Swift.String]?
    let evaluationParameters: ForecastClientTypes.EvaluationParameters?
    let hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    let inputDataConfig: ForecastClientTypes.InputDataConfig?
    let featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let tags: [ForecastClientTypes.Tag]?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
}

extension CreatePredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case encryptionConfig = "EncryptionConfig"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hpoConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case optimizationMetric = "OptimizationMetric"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorName = "PredictorName"
        case tags = "Tags"
        case trainingParameters = "TrainingParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let trainingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .trainingParameters)
        var trainingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let trainingParametersContainer = trainingParametersContainer {
            trainingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in trainingParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    trainingParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        trainingParameters = trainingParametersDecoded0
        let evaluationParametersDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EvaluationParameters.self, forKey: .evaluationParameters)
        evaluationParameters = evaluationParametersDecoded
        let hpoConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.HyperParameterTuningJobConfig.self, forKey: .hpoConfig)
        hpoConfig = hpoConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let featurizationConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FeaturizationConfig.self, forKey: .featurizationConfig)
        featurizationConfig = featurizationConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
    }
}

extension CreatePredictorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePredictorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePredictorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePredictorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePredictorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.predictorArn = output.predictorArn
        } else {
            self.predictorArn = nil
        }
    }
}

public struct CreatePredictorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct CreatePredictorOutputResponseBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension CreatePredictorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension CreateWhatIfAnalysisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
        case tags = "Tags"
        case timeSeriesSelector = "TimeSeriesSelector"
        case whatIfAnalysisName = "WhatIfAnalysisName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastArn = self.forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeSeriesSelector = self.timeSeriesSelector {
            try encodeContainer.encode(timeSeriesSelector, forKey: .timeSeriesSelector)
        }
        if let whatIfAnalysisName = self.whatIfAnalysisName {
            try encodeContainer.encode(whatIfAnalysisName, forKey: .whatIfAnalysisName)
        }
    }
}

extension CreateWhatIfAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWhatIfAnalysisInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the baseline forecast.
    /// This member is required.
    public var forecastArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/forecast/latest/dg/tagging-forecast-resources.html) to apply to the what if forecast.
    public var tags: [ForecastClientTypes.Tag]?
    /// Defines the set of time series that are used in the what-if analysis with a TimeSeriesIdentifiers object. What-if analyses are performed only for the time series in this object. The TimeSeriesIdentifiers object needs the following information:
    ///
    /// * DataSource
    ///
    /// * Format
    ///
    /// * Schema
    public var timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?
    /// The name of the what-if analysis. Each name must be unique.
    /// This member is required.
    public var whatIfAnalysisName: Swift.String?

    public init (
        forecastArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector? = nil,
        whatIfAnalysisName: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
        self.tags = tags
        self.timeSeriesSelector = timeSeriesSelector
        self.whatIfAnalysisName = whatIfAnalysisName
    }
}

struct CreateWhatIfAnalysisInputBody: Swift.Equatable {
    let whatIfAnalysisName: Swift.String?
    let forecastArn: Swift.String?
    let timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateWhatIfAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
        case tags = "Tags"
        case timeSeriesSelector = "TimeSeriesSelector"
        case whatIfAnalysisName = "WhatIfAnalysisName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfAnalysisNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisName)
        whatIfAnalysisName = whatIfAnalysisNameDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let timeSeriesSelectorDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesSelector.self, forKey: .timeSeriesSelector)
        timeSeriesSelector = timeSeriesSelectorDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWhatIfAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWhatIfAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWhatIfAnalysisOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWhatIfAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWhatIfAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.whatIfAnalysisArn = output.whatIfAnalysisArn
        } else {
            self.whatIfAnalysisArn = nil
        }
    }
}

public struct CreateWhatIfAnalysisOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if analysis.
    public var whatIfAnalysisArn: Swift.String?

    public init (
        whatIfAnalysisArn: Swift.String? = nil
    )
    {
        self.whatIfAnalysisArn = whatIfAnalysisArn
    }
}

struct CreateWhatIfAnalysisOutputResponseBody: Swift.Equatable {
    let whatIfAnalysisArn: Swift.String?
}

extension CreateWhatIfAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
    }
}

extension CreateWhatIfForecastExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case format = "Format"
        case tags = "Tags"
        case whatIfForecastArns = "WhatIfForecastArns"
        case whatIfForecastExportName = "WhatIfForecastExportName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let whatIfForecastArns = whatIfForecastArns {
            var whatIfForecastArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .whatIfForecastArns)
            for longarn0 in whatIfForecastArns {
                try whatIfForecastArnsContainer.encode(longarn0)
            }
        }
        if let whatIfForecastExportName = self.whatIfForecastExportName {
            try encodeContainer.encode(whatIfForecastExportName, forKey: .whatIfForecastExportName)
        }
    }
}

extension CreateWhatIfForecastExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWhatIfForecastExportInput: Swift.Equatable {
    /// The location where you want to save the forecast and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the location. The forecast must be exported to an Amazon S3 bucket. If encryption is used, Destination must include an AWS Key Management Service (KMS) key. The IAM role must allow Amazon Forecast permission to access the key.
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/forecast/latest/dg/tagging-forecast-resources.html) to apply to the what if forecast.
    public var tags: [ForecastClientTypes.Tag]?
    /// The list of what-if forecast Amazon Resource Names (ARNs) to export.
    /// This member is required.
    public var whatIfForecastArns: [Swift.String]?
    /// The name of the what-if forecast to export.
    /// This member is required.
    public var whatIfForecastExportName: Swift.String?

    public init (
        destination: ForecastClientTypes.DataDestination? = nil,
        format: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        whatIfForecastArns: [Swift.String]? = nil,
        whatIfForecastExportName: Swift.String? = nil
    )
    {
        self.destination = destination
        self.format = format
        self.tags = tags
        self.whatIfForecastArns = whatIfForecastArns
        self.whatIfForecastExportName = whatIfForecastExportName
    }
}

struct CreateWhatIfForecastExportInputBody: Swift.Equatable {
    let whatIfForecastExportName: Swift.String?
    let whatIfForecastArns: [Swift.String]?
    let destination: ForecastClientTypes.DataDestination?
    let tags: [ForecastClientTypes.Tag]?
    let format: Swift.String?
}

extension CreateWhatIfForecastExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case format = "Format"
        case tags = "Tags"
        case whatIfForecastArns = "WhatIfForecastArns"
        case whatIfForecastExportName = "WhatIfForecastExportName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportName)
        whatIfForecastExportName = whatIfForecastExportNameDecoded
        let whatIfForecastArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whatIfForecastArns)
        var whatIfForecastArnsDecoded0:[Swift.String]? = nil
        if let whatIfForecastArnsContainer = whatIfForecastArnsContainer {
            whatIfForecastArnsDecoded0 = [Swift.String]()
            for string0 in whatIfForecastArnsContainer {
                if let string0 = string0 {
                    whatIfForecastArnsDecoded0?.append(string0)
                }
            }
        }
        whatIfForecastArns = whatIfForecastArnsDecoded0
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension CreateWhatIfForecastExportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWhatIfForecastExportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWhatIfForecastExportOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWhatIfForecastExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWhatIfForecastExportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.whatIfForecastExportArn = output.whatIfForecastExportArn
        } else {
            self.whatIfForecastExportArn = nil
        }
    }
}

public struct CreateWhatIfForecastExportOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if forecast.
    public var whatIfForecastExportArn: Swift.String?

    public init (
        whatIfForecastExportArn: Swift.String? = nil
    )
    {
        self.whatIfForecastExportArn = whatIfForecastExportArn
    }
}

struct CreateWhatIfForecastExportOutputResponseBody: Swift.Equatable {
    let whatIfForecastExportArn: Swift.String?
}

extension CreateWhatIfForecastExportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastExportArn = "WhatIfForecastExportArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportArn)
        whatIfForecastExportArn = whatIfForecastExportArnDecoded
    }
}

extension CreateWhatIfForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
        case timeSeriesReplacementsDataSource = "TimeSeriesReplacementsDataSource"
        case timeSeriesTransformations = "TimeSeriesTransformations"
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
        case whatIfForecastName = "WhatIfForecastName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeSeriesReplacementsDataSource = self.timeSeriesReplacementsDataSource {
            try encodeContainer.encode(timeSeriesReplacementsDataSource, forKey: .timeSeriesReplacementsDataSource)
        }
        if let timeSeriesTransformations = timeSeriesTransformations {
            var timeSeriesTransformationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timeSeriesTransformations)
            for timeseriestransformation0 in timeSeriesTransformations {
                try timeSeriesTransformationsContainer.encode(timeseriestransformation0)
            }
        }
        if let whatIfAnalysisArn = self.whatIfAnalysisArn {
            try encodeContainer.encode(whatIfAnalysisArn, forKey: .whatIfAnalysisArn)
        }
        if let whatIfForecastName = self.whatIfForecastName {
            try encodeContainer.encode(whatIfForecastName, forKey: .whatIfForecastName)
        }
    }
}

extension CreateWhatIfForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWhatIfForecastInput: Swift.Equatable {
    /// A list of [tags](https://docs.aws.amazon.com/forecast/latest/dg/tagging-forecast-resources.html) to apply to the what if forecast.
    public var tags: [ForecastClientTypes.Tag]?
    /// The replacement time series dataset, which contains the rows that you want to change in the related time series dataset. A replacement time series does not need to contain all rows that are in the baseline related time series. Include only the rows (measure-dimension combinations) that you want to include in the what-if forecast. This dataset is merged with the original time series to create a transformed dataset that is used for the what-if analysis. This dataset should contain the items to modify (such as item_id or workforce_type), any relevant dimensions, the timestamp column, and at least one of the related time series columns. This file should not contain duplicate timestamps for the same time series. Timestamps and item_ids not included in this dataset are not included in the what-if analysis.
    public var timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource?
    /// The transformations that are applied to the baseline time series. Each transformation contains an action and a set of conditions. An action is applied only when all conditions are met. If no conditions are provided, the action is applied to all items.
    public var timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]?
    /// The Amazon Resource Name (ARN) of the what-if analysis.
    /// This member is required.
    public var whatIfAnalysisArn: Swift.String?
    /// The name of the what-if forecast. Names must be unique within each what-if analysis.
    /// This member is required.
    public var whatIfForecastName: Swift.String?

    public init (
        tags: [ForecastClientTypes.Tag]? = nil,
        timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource? = nil,
        timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]? = nil,
        whatIfAnalysisArn: Swift.String? = nil,
        whatIfForecastName: Swift.String? = nil
    )
    {
        self.tags = tags
        self.timeSeriesReplacementsDataSource = timeSeriesReplacementsDataSource
        self.timeSeriesTransformations = timeSeriesTransformations
        self.whatIfAnalysisArn = whatIfAnalysisArn
        self.whatIfForecastName = whatIfForecastName
    }
}

struct CreateWhatIfForecastInputBody: Swift.Equatable {
    let whatIfForecastName: Swift.String?
    let whatIfAnalysisArn: Swift.String?
    let timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]?
    let timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateWhatIfForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
        case timeSeriesReplacementsDataSource = "TimeSeriesReplacementsDataSource"
        case timeSeriesTransformations = "TimeSeriesTransformations"
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
        case whatIfForecastName = "WhatIfForecastName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastName)
        whatIfForecastName = whatIfForecastNameDecoded
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
        let timeSeriesTransformationsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.TimeSeriesTransformation?].self, forKey: .timeSeriesTransformations)
        var timeSeriesTransformationsDecoded0:[ForecastClientTypes.TimeSeriesTransformation]? = nil
        if let timeSeriesTransformationsContainer = timeSeriesTransformationsContainer {
            timeSeriesTransformationsDecoded0 = [ForecastClientTypes.TimeSeriesTransformation]()
            for structure0 in timeSeriesTransformationsContainer {
                if let structure0 = structure0 {
                    timeSeriesTransformationsDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesTransformations = timeSeriesTransformationsDecoded0
        let timeSeriesReplacementsDataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesReplacementsDataSource.self, forKey: .timeSeriesReplacementsDataSource)
        timeSeriesReplacementsDataSource = timeSeriesReplacementsDataSourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWhatIfForecastOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWhatIfForecastOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWhatIfForecastOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWhatIfForecastOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWhatIfForecastOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.whatIfForecastArn = output.whatIfForecastArn
        } else {
            self.whatIfForecastArn = nil
        }
    }
}

public struct CreateWhatIfForecastOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if forecast.
    public var whatIfForecastArn: Swift.String?

    public init (
        whatIfForecastArn: Swift.String? = nil
    )
    {
        self.whatIfForecastArn = whatIfForecastArn
    }
}

struct CreateWhatIfForecastOutputResponseBody: Swift.Equatable {
    let whatIfForecastArn: Swift.String?
}

extension CreateWhatIfForecastOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastArn = "WhatIfForecastArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastArn)
        whatIfForecastArn = whatIfForecastArnDecoded
    }
}

extension ForecastClientTypes.DataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalDatasets = "AdditionalDatasets"
        case attributeConfigs = "AttributeConfigs"
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalDatasets = additionalDatasets {
            var additionalDatasetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalDatasets)
            for additionaldataset0 in additionalDatasets {
                try additionalDatasetsContainer.encode(additionaldataset0)
            }
        }
        if let attributeConfigs = attributeConfigs {
            var attributeConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeConfigs)
            for attributeconfig0 in attributeConfigs {
                try attributeConfigsContainer.encode(attributeconfig0)
            }
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let attributeConfigsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.AttributeConfig?].self, forKey: .attributeConfigs)
        var attributeConfigsDecoded0:[ForecastClientTypes.AttributeConfig]? = nil
        if let attributeConfigsContainer = attributeConfigsContainer {
            attributeConfigsDecoded0 = [ForecastClientTypes.AttributeConfig]()
            for structure0 in attributeConfigsContainer {
                if let structure0 = structure0 {
                    attributeConfigsDecoded0?.append(structure0)
                }
            }
        }
        attributeConfigs = attributeConfigsDecoded0
        let additionalDatasetsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.AdditionalDataset?].self, forKey: .additionalDatasets)
        var additionalDatasetsDecoded0:[ForecastClientTypes.AdditionalDataset]? = nil
        if let additionalDatasetsContainer = additionalDatasetsContainer {
            additionalDatasetsDecoded0 = [ForecastClientTypes.AdditionalDataset]()
            for structure0 in additionalDatasetsContainer {
                if let structure0 = structure0 {
                    additionalDatasetsDecoded0?.append(structure0)
                }
            }
        }
        additionalDatasets = additionalDatasetsDecoded0
    }
}

extension ForecastClientTypes {
    /// The data configuration for your dataset group and any additional datasets.
    public struct DataConfig: Swift.Equatable {
        /// Additional built-in datasets like Holidays and the Weather Index.
        public var additionalDatasets: [ForecastClientTypes.AdditionalDataset]?
        /// Aggregation and filling options for attributes in your dataset group.
        public var attributeConfigs: [ForecastClientTypes.AttributeConfig]?
        /// The ARN of the dataset group used to train the predictor.
        /// This member is required.
        public var datasetGroupArn: Swift.String?

        public init (
            additionalDatasets: [ForecastClientTypes.AdditionalDataset]? = nil,
            attributeConfigs: [ForecastClientTypes.AttributeConfig]? = nil,
            datasetGroupArn: Swift.String? = nil
        )
        {
            self.additionalDatasets = additionalDatasets
            self.attributeConfigs = attributeConfigs
            self.datasetGroupArn = datasetGroupArn
        }
    }

}

extension ForecastClientTypes.DataDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Config = "S3Config"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Config = self.s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
    }
}

extension ForecastClientTypes {
    /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
    public struct DataDestination: Swift.Equatable {
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the bucket.
        /// This member is required.
        public var s3Config: ForecastClientTypes.S3Config?

        public init (
            s3Config: ForecastClientTypes.S3Config? = nil
        )
        {
            self.s3Config = s3Config
        }
    }

}

extension ForecastClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Config = "S3Config"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Config = self.s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
    }
}

extension ForecastClientTypes {
    /// The source of your data, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an AWS Key Management Service (KMS) key.
    public struct DataSource: Swift.Equatable {
        /// The path to the data stored in an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the data.
        /// This member is required.
        public var s3Config: ForecastClientTypes.S3Config?

        public init (
            s3Config: ForecastClientTypes.S3Config? = nil
        )
        {
            self.s3Config = s3Config
        }
    }

}

extension ForecastClientTypes.DatasetGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case datasetGroupName = "DatasetGroupName"
        case lastModificationTime = "LastModificationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let datasetGroupName = self.datasetGroupName {
            try encodeContainer.encode(datasetGroupName, forKey: .datasetGroupName)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset group properties used in the [ListDatasetGroups](https://docs.aws.amazon.com/forecast/latest/dg/API_ListDatasetGroups.html) operation. To get the complete set of properties, call the [DescribeDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_DescribeDatasetGroup.html) operation, and provide the DatasetGroupArn.
    public struct DatasetGroupSummary: Swift.Equatable {
        /// When the dataset group was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// The name of the dataset group.
        public var datasetGroupName: Swift.String?
        /// When the dataset group was created or last updated from a call to the [UpdateDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_UpdateDatasetGroup.html) operation. While the dataset group is being updated, LastModificationTime is the current time of the ListDatasetGroups call.
        public var lastModificationTime: ClientRuntime.Date?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            datasetGroupName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.datasetGroupName = datasetGroupName
            self.lastModificationTime = lastModificationTime
        }
    }

}

extension ForecastClientTypes.DatasetImportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataSource = "DataSource"
        case datasetImportJobArn = "DatasetImportJobArn"
        case datasetImportJobName = "DatasetImportJobName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetImportJobArn = self.datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let datasetImportJobName = self.datasetImportJobName {
            try encodeContainer.encode(datasetImportJobName, forKey: .datasetImportJobName)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset import job properties used in the [ListDatasetImportJobs](https://docs.aws.amazon.com/forecast/latest/dg/API_ListDatasetImportJobs.html) operation. To get the complete set of properties, call the [DescribeDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_DescribeDatasetImportJob.html) operation, and provide the DatasetImportJobArn.
    public struct DatasetImportJobSummary: Swift.Equatable {
        /// When the dataset import job was created.
        public var creationTime: ClientRuntime.Date?
        /// The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket. If encryption is used, DataSource includes an AWS Key Management Service (KMS) key.
        public var dataSource: ForecastClientTypes.DataSource?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public var datasetImportJobArn: Swift.String?
        /// The name of the dataset import job.
        public var datasetImportJobName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the dataset import job. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            dataSource: ForecastClientTypes.DataSource? = nil,
            datasetImportJobArn: Swift.String? = nil,
            datasetImportJobName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.dataSource = dataSource
            self.datasetImportJobArn = datasetImportJobArn
            self.datasetImportJobName = datasetImportJobName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }
    }

}

extension ForecastClientTypes.DatasetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case lastModificationTime = "LastModificationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetName = self.datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let datasetType = self.datasetType {
            try encodeContainer.encode(datasetType.rawValue, forKey: .datasetType)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset properties used in the [ListDatasets](https://docs.aws.amazon.com/forecast/latest/dg/API_ListDatasets.html) operation. To get the complete set of properties, call the [DescribeDataset](https://docs.aws.amazon.com/forecast/latest/dg/API_DescribeDataset.html) operation, and provide the DatasetArn.
    public struct DatasetSummary: Swift.Equatable {
        /// When the dataset was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset.
        public var datasetArn: Swift.String?
        /// The name of the dataset.
        public var datasetName: Swift.String?
        /// The dataset type.
        public var datasetType: ForecastClientTypes.DatasetType?
        /// The domain associated with the dataset.
        public var domain: ForecastClientTypes.Domain?
        /// When you create a dataset, LastModificationTime is the same as CreationTime. While data is being imported to the dataset, LastModificationTime is the current time of the ListDatasets call. After a [CreateDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html) operation has finished, LastModificationTime is when the import job completed or failed.
        public var lastModificationTime: ClientRuntime.Date?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetName: Swift.String? = nil,
            datasetType: ForecastClientTypes.DatasetType? = nil,
            domain: ForecastClientTypes.Domain? = nil,
            lastModificationTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetArn = datasetArn
            self.datasetName = datasetName
            self.datasetType = datasetType
            self.domain = domain
            self.lastModificationTime = lastModificationTime
        }
    }

}

extension ForecastClientTypes {
    public enum DatasetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case itemMetadata
        case relatedTimeSeries
        case targetTimeSeries
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetType] {
            return [
                .itemMetadata,
                .relatedTimeSeries,
                .targetTimeSeries,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .itemMetadata: return "ITEM_METADATA"
            case .relatedTimeSeries: return "RELATED_TIME_SERIES"
            case .targetTimeSeries: return "TARGET_TIME_SERIES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetType(rawValue: rawValue) ?? DatasetType.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes {
    public enum DayOfWeek: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DayOfWeek(rawValue: rawValue) ?? DayOfWeek.sdkUnknown(rawValue)
        }
    }
}

extension DeleteDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

extension DeleteDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDatasetGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group to delete.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DeleteDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
}

extension DeleteDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DeleteDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteDatasetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = self.datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
    }
}

extension DeleteDatasetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDatasetImportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job to delete.
    /// This member is required.
    public var datasetImportJobArn: Swift.String?

    public init (
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct DeleteDatasetImportJobInputBody: Swift.Equatable {
    let datasetImportJobArn: Swift.String?
}

extension DeleteDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension DeleteDatasetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDatasetImportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetImportJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

extension DeleteDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to delete.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension DeleteDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DeleteDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteExplainabilityExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityExportArn = self.explainabilityExportArn {
            try encodeContainer.encode(explainabilityExportArn, forKey: .explainabilityExportArn)
        }
    }
}

extension DeleteExplainabilityExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteExplainabilityExportInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explainability export to delete.
    /// This member is required.
    public var explainabilityExportArn: Swift.String?

    public init (
        explainabilityExportArn: Swift.String? = nil
    )
    {
        self.explainabilityExportArn = explainabilityExportArn
    }
}

struct DeleteExplainabilityExportInputBody: Swift.Equatable {
    let explainabilityExportArn: Swift.String?
}

extension DeleteExplainabilityExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
    }
}

extension DeleteExplainabilityExportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteExplainabilityExportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteExplainabilityExportOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteExplainabilityExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteExplainabilityExportOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteExplainabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityArn = self.explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
    }
}

extension DeleteExplainabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteExplainabilityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explainability resource to delete.
    /// This member is required.
    public var explainabilityArn: Swift.String?

    public init (
        explainabilityArn: Swift.String? = nil
    )
    {
        self.explainabilityArn = explainabilityArn
    }
}

struct DeleteExplainabilityInputBody: Swift.Equatable {
    let explainabilityArn: Swift.String?
}

extension DeleteExplainabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
    }
}

extension DeleteExplainabilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteExplainabilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteExplainabilityOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteExplainabilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteExplainabilityOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteForecastExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastExportJobArn = self.forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
    }
}

extension DeleteForecastExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteForecastExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast export job to delete.
    /// This member is required.
    public var forecastExportJobArn: Swift.String?

    public init (
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct DeleteForecastExportJobInputBody: Swift.Equatable {
    let forecastExportJobArn: Swift.String?
}

extension DeleteForecastExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

extension DeleteForecastExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteForecastExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteForecastExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteForecastExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteForecastExportJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastArn = self.forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
    }
}

extension DeleteForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteForecastInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast to delete.
    /// This member is required.
    public var forecastArn: Swift.String?

    public init (
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct DeleteForecastInputBody: Swift.Equatable {
    let forecastArn: Swift.String?
}

extension DeleteForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

extension DeleteForecastOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteForecastOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteForecastOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteForecastOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteForecastOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
    }
}

extension DeleteMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMonitorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the monitor resource to delete.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init (
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct DeleteMonitorInputBody: Swift.Equatable {
    let monitorArn: Swift.String?
}

extension DeleteMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

extension DeleteMonitorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMonitorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMonitorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMonitorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMonitorOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePredictorBacktestExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorBacktestExportJobArn = self.predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
    }
}

extension DeletePredictorBacktestExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePredictorBacktestExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job to delete.
    /// This member is required.
    public var predictorBacktestExportJobArn: Swift.String?

    public init (
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct DeletePredictorBacktestExportJobInputBody: Swift.Equatable {
    let predictorBacktestExportJobArn: Swift.String?
}

extension DeletePredictorBacktestExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

extension DeletePredictorBacktestExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePredictorBacktestExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePredictorBacktestExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePredictorBacktestExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePredictorBacktestExportJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

extension DeletePredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor to delete.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct DeletePredictorInputBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension DeletePredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension DeletePredictorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePredictorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePredictorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePredictorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePredictorOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteResourceTreeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension DeleteResourceTreeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResourceTreeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the parent resource to delete. All child resources of the parent resource will also be deleted.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourceTreeInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension DeleteResourceTreeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteResourceTreeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceTreeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResourceTreeOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceTreeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceTreeOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWhatIfAnalysisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let whatIfAnalysisArn = self.whatIfAnalysisArn {
            try encodeContainer.encode(whatIfAnalysisArn, forKey: .whatIfAnalysisArn)
        }
    }
}

extension DeleteWhatIfAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWhatIfAnalysisInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if analysis that you want to delete.
    /// This member is required.
    public var whatIfAnalysisArn: Swift.String?

    public init (
        whatIfAnalysisArn: Swift.String? = nil
    )
    {
        self.whatIfAnalysisArn = whatIfAnalysisArn
    }
}

struct DeleteWhatIfAnalysisInputBody: Swift.Equatable {
    let whatIfAnalysisArn: Swift.String?
}

extension DeleteWhatIfAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
    }
}

extension DeleteWhatIfAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWhatIfAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWhatIfAnalysisOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWhatIfAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWhatIfAnalysisOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWhatIfForecastExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastExportArn = "WhatIfForecastExportArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let whatIfForecastExportArn = self.whatIfForecastExportArn {
            try encodeContainer.encode(whatIfForecastExportArn, forKey: .whatIfForecastExportArn)
        }
    }
}

extension DeleteWhatIfForecastExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWhatIfForecastExportInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if forecast export that you want to delete.
    /// This member is required.
    public var whatIfForecastExportArn: Swift.String?

    public init (
        whatIfForecastExportArn: Swift.String? = nil
    )
    {
        self.whatIfForecastExportArn = whatIfForecastExportArn
    }
}

struct DeleteWhatIfForecastExportInputBody: Swift.Equatable {
    let whatIfForecastExportArn: Swift.String?
}

extension DeleteWhatIfForecastExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastExportArn = "WhatIfForecastExportArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportArn)
        whatIfForecastExportArn = whatIfForecastExportArnDecoded
    }
}

extension DeleteWhatIfForecastExportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWhatIfForecastExportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWhatIfForecastExportOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWhatIfForecastExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWhatIfForecastExportOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWhatIfForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastArn = "WhatIfForecastArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let whatIfForecastArn = self.whatIfForecastArn {
            try encodeContainer.encode(whatIfForecastArn, forKey: .whatIfForecastArn)
        }
    }
}

extension DeleteWhatIfForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWhatIfForecastInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if forecast that you want to delete.
    /// This member is required.
    public var whatIfForecastArn: Swift.String?

    public init (
        whatIfForecastArn: Swift.String? = nil
    )
    {
        self.whatIfForecastArn = whatIfForecastArn
    }
}

struct DeleteWhatIfForecastInputBody: Swift.Equatable {
    let whatIfForecastArn: Swift.String?
}

extension DeleteWhatIfForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastArn = "WhatIfForecastArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastArn)
        whatIfForecastArn = whatIfForecastArnDecoded
    }
}

extension DeleteWhatIfForecastOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWhatIfForecastOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWhatIfForecastOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWhatIfForecastOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWhatIfForecastOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeAutoPredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

extension DescribeAutoPredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAutoPredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct DescribeAutoPredictorInputBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension DescribeAutoPredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension DescribeAutoPredictorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAutoPredictorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAutoPredictorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAutoPredictorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAutoPredictorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.dataConfig = output.dataConfig
            self.datasetImportJobArns = output.datasetImportJobArns
            self.encryptionConfig = output.encryptionConfig
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.explainabilityInfo = output.explainabilityInfo
            self.forecastDimensions = output.forecastDimensions
            self.forecastFrequency = output.forecastFrequency
            self.forecastHorizon = output.forecastHorizon
            self.forecastTypes = output.forecastTypes
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.monitorInfo = output.monitorInfo
            self.optimizationMetric = output.optimizationMetric
            self.predictorArn = output.predictorArn
            self.predictorName = output.predictorName
            self.referencePredictorSummary = output.referencePredictorSummary
            self.status = output.status
            self.timeAlignmentBoundary = output.timeAlignmentBoundary
        } else {
            self.creationTime = nil
            self.dataConfig = nil
            self.datasetImportJobArns = nil
            self.encryptionConfig = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.explainabilityInfo = nil
            self.forecastDimensions = nil
            self.forecastFrequency = nil
            self.forecastHorizon = nil
            self.forecastTypes = nil
            self.lastModificationTime = nil
            self.message = nil
            self.monitorInfo = nil
            self.optimizationMetric = nil
            self.predictorArn = nil
            self.predictorName = nil
            self.referencePredictorSummary = nil
            self.status = nil
            self.timeAlignmentBoundary = nil
        }
    }
}

public struct DescribeAutoPredictorOutputResponse: Swift.Equatable {
    /// The timestamp of the CreateAutoPredictor request.
    public var creationTime: ClientRuntime.Date?
    /// The data configuration for your dataset group and any additional datasets.
    public var dataConfig: ForecastClientTypes.DataConfig?
    /// An array of the ARNs of the dataset import jobs used to import training data for the predictor.
    public var datasetImportJobArns: [Swift.String]?
    /// An AWS Key Management Service (KMS) key and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key. You can specify this optional object in the [CreateDataset] and [CreatePredictor] requests.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// The estimated time remaining in minutes for the predictor training job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// Provides the status and ARN of the Predictor Explainability.
    public var explainabilityInfo: ForecastClientTypes.ExplainabilityInfo?
    /// An array of dimension (field) names that specify the attributes used to group your time series.
    public var forecastDimensions: [Swift.String]?
    /// The frequency of predictions in a forecast. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes.
    public var forecastFrequency: Swift.String?
    /// The number of time-steps that the model predicts. The forecast horizon is also called the prediction length.
    public var forecastHorizon: Swift.Int?
    /// The forecast types used during predictor training. Default value is ["0.1","0.5","0.9"].
    public var forecastTypes: [Swift.String]?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// In the event of an error, a message detailing the cause of the error.
    public var message: Swift.String?
    /// A object with the Amazon Resource Name (ARN) and status of the monitor resource.
    public var monitorInfo: ForecastClientTypes.MonitorInfo?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// The Amazon Resource Name (ARN) of the predictor
    public var predictorArn: Swift.String?
    /// The name of the predictor.
    public var predictorName: Swift.String?
    /// The ARN and state of the reference predictor. This parameter is only valid for retrained or upgraded predictors.
    public var referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary?
    /// The status of the predictor. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?
    /// The time boundary Forecast uses when aggregating data.
    public var timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        dataConfig: ForecastClientTypes.DataConfig? = nil,
        datasetImportJobArns: [Swift.String]? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        explainabilityInfo: ForecastClientTypes.ExplainabilityInfo? = nil,
        forecastDimensions: [Swift.String]? = nil,
        forecastFrequency: Swift.String? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        monitorInfo: ForecastClientTypes.MonitorInfo? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        predictorArn: Swift.String? = nil,
        predictorName: Swift.String? = nil,
        referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary? = nil,
        status: Swift.String? = nil,
        timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary? = nil
    )
    {
        self.creationTime = creationTime
        self.dataConfig = dataConfig
        self.datasetImportJobArns = datasetImportJobArns
        self.encryptionConfig = encryptionConfig
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.explainabilityInfo = explainabilityInfo
        self.forecastDimensions = forecastDimensions
        self.forecastFrequency = forecastFrequency
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.monitorInfo = monitorInfo
        self.optimizationMetric = optimizationMetric
        self.predictorArn = predictorArn
        self.predictorName = predictorName
        self.referencePredictorSummary = referencePredictorSummary
        self.status = status
        self.timeAlignmentBoundary = timeAlignmentBoundary
    }
}

struct DescribeAutoPredictorOutputResponseBody: Swift.Equatable {
    let predictorArn: Swift.String?
    let predictorName: Swift.String?
    let forecastHorizon: Swift.Int?
    let forecastTypes: [Swift.String]?
    let forecastFrequency: Swift.String?
    let forecastDimensions: [Swift.String]?
    let datasetImportJobArns: [Swift.String]?
    let dataConfig: ForecastClientTypes.DataConfig?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
    let explainabilityInfo: ForecastClientTypes.ExplainabilityInfo?
    let monitorInfo: ForecastClientTypes.MonitorInfo?
    let timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary?
}

extension DescribeAutoPredictorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataConfig = "DataConfig"
        case datasetImportJobArns = "DatasetImportJobArns"
        case encryptionConfig = "EncryptionConfig"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case explainabilityInfo = "ExplainabilityInfo"
        case forecastDimensions = "ForecastDimensions"
        case forecastFrequency = "ForecastFrequency"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case monitorInfo = "MonitorInfo"
        case optimizationMetric = "OptimizationMetric"
        case predictorArn = "PredictorArn"
        case predictorName = "PredictorName"
        case referencePredictorSummary = "ReferencePredictorSummary"
        case status = "Status"
        case timeAlignmentBoundary = "TimeAlignmentBoundary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let forecastFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastFrequency)
        forecastFrequency = forecastFrequencyDecoded
        let forecastDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastDimensions)
        var forecastDimensionsDecoded0:[Swift.String]? = nil
        if let forecastDimensionsContainer = forecastDimensionsContainer {
            forecastDimensionsDecoded0 = [Swift.String]()
            for string0 in forecastDimensionsContainer {
                if let string0 = string0 {
                    forecastDimensionsDecoded0?.append(string0)
                }
            }
        }
        forecastDimensions = forecastDimensionsDecoded0
        let datasetImportJobArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetImportJobArns)
        var datasetImportJobArnsDecoded0:[Swift.String]? = nil
        if let datasetImportJobArnsContainer = datasetImportJobArnsContainer {
            datasetImportJobArnsDecoded0 = [Swift.String]()
            for string0 in datasetImportJobArnsContainer {
                if let string0 = string0 {
                    datasetImportJobArnsDecoded0?.append(string0)
                }
            }
        }
        datasetImportJobArns = datasetImportJobArnsDecoded0
        let dataConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataConfig.self, forKey: .dataConfig)
        dataConfig = dataConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let referencePredictorSummaryDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ReferencePredictorSummary.self, forKey: .referencePredictorSummary)
        referencePredictorSummary = referencePredictorSummaryDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
        let explainabilityInfoDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ExplainabilityInfo.self, forKey: .explainabilityInfo)
        explainabilityInfo = explainabilityInfoDecoded
        let monitorInfoDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.MonitorInfo.self, forKey: .monitorInfo)
        monitorInfo = monitorInfoDecoded
        let timeAlignmentBoundaryDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeAlignmentBoundary.self, forKey: .timeAlignmentBoundary)
        timeAlignmentBoundary = timeAlignmentBoundaryDecoded
    }
}

extension DescribeDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

extension DescribeDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DescribeDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
}

extension DescribeDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DescribeDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDatasetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.datasetArns = output.datasetArns
            self.datasetGroupArn = output.datasetGroupArn
            self.datasetGroupName = output.datasetGroupName
            self.domain = output.domain
            self.lastModificationTime = output.lastModificationTime
            self.status = output.status
        } else {
            self.creationTime = nil
            self.datasetArns = nil
            self.datasetGroupArn = nil
            self.datasetGroupName = nil
            self.domain = nil
            self.lastModificationTime = nil
            self.status = nil
        }
    }
}

public struct DescribeDatasetGroupOutputResponse: Swift.Equatable {
    /// When the dataset group was created.
    public var creationTime: ClientRuntime.Date?
    /// An array of Amazon Resource Names (ARNs) of the datasets contained in the dataset group.
    public var datasetArns: [Swift.String]?
    /// The ARN of the dataset group.
    public var datasetGroupArn: Swift.String?
    /// The name of the dataset group.
    public var datasetGroupName: Swift.String?
    /// The domain associated with the dataset group.
    public var domain: ForecastClientTypes.Domain?
    /// When the dataset group was created or last updated from a call to the [UpdateDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_UpdateDatasetGroup.html) operation. While the dataset group is being updated, LastModificationTime is the current time of the DescribeDatasetGroup call.
    public var lastModificationTime: ClientRuntime.Date?
    /// The status of the dataset group. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED
    ///
    ///
    /// The UPDATE states apply when you call the [UpdateDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_UpdateDatasetGroup.html) operation. The Status of the dataset group must be ACTIVE before you can use the dataset group to create a predictor.
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        datasetArns: [Swift.String]? = nil,
        datasetGroupArn: Swift.String? = nil,
        datasetGroupName: Swift.String? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetArns = datasetArns
        self.datasetGroupArn = datasetGroupArn
        self.datasetGroupName = datasetGroupName
        self.domain = domain
        self.lastModificationTime = lastModificationTime
        self.status = status
    }
}

struct DescribeDatasetGroupOutputResponseBody: Swift.Equatable {
    let datasetGroupName: Swift.String?
    let datasetGroupArn: Swift.String?
    let datasetArns: [Swift.String]?
    let domain: ForecastClientTypes.Domain?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension DescribeDatasetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case lastModificationTime = "LastModificationTime"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[Swift.String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [Swift.String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension DescribeDatasetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = self.datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
    }
}

extension DescribeDatasetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetImportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job.
    /// This member is required.
    public var datasetImportJobArn: Swift.String?

    public init (
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct DescribeDatasetImportJobInputBody: Swift.Equatable {
    let datasetImportJobArn: Swift.String?
}

extension DescribeDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension DescribeDatasetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDatasetImportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDatasetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.dataSize = output.dataSize
            self.dataSource = output.dataSource
            self.datasetArn = output.datasetArn
            self.datasetImportJobArn = output.datasetImportJobArn
            self.datasetImportJobName = output.datasetImportJobName
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.fieldStatistics = output.fieldStatistics
            self.format = output.format
            self.geolocationFormat = output.geolocationFormat
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
            self.timeZone = output.timeZone
            self.timestampFormat = output.timestampFormat
            self.useGeolocationForTimeZone = output.useGeolocationForTimeZone
        } else {
            self.creationTime = nil
            self.dataSize = nil
            self.dataSource = nil
            self.datasetArn = nil
            self.datasetImportJobArn = nil
            self.datasetImportJobName = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.fieldStatistics = nil
            self.format = nil
            self.geolocationFormat = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
            self.timeZone = nil
            self.timestampFormat = nil
            self.useGeolocationForTimeZone = false
        }
    }
}

public struct DescribeDatasetImportJobOutputResponse: Swift.Equatable {
    /// When the dataset import job was created.
    public var creationTime: ClientRuntime.Date?
    /// The size of the dataset in gigabytes (GB) after the import job has finished.
    public var dataSize: Swift.Double?
    /// The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. If encryption is used, DataSource includes an AWS Key Management Service (KMS) key.
    public var dataSource: ForecastClientTypes.DataSource?
    /// The Amazon Resource Name (ARN) of the dataset that the training data was imported to.
    public var datasetArn: Swift.String?
    /// The ARN of the dataset import job.
    public var datasetImportJobArn: Swift.String?
    /// The name of the dataset import job.
    public var datasetImportJobName: Swift.String?
    /// The estimated time remaining in minutes for the dataset import job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// Statistical information about each field in the input data.
    public var fieldStatistics: [Swift.String:ForecastClientTypes.Statistics]?
    /// The format of the imported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The format of the geolocation attribute. Valid Values:"LAT_LONG" and "CC_POSTALCODE".
    public var geolocationFormat: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the dataset import job. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    public var status: Swift.String?
    /// The single time zone applied to every item in the dataset
    public var timeZone: Swift.String?
    /// The format of timestamps in the dataset. The format that you specify depends on the DataFrequency specified when the dataset was created. The following formats are supported
    ///
    /// * "yyyy-MM-dd" For the following data frequencies: Y, M, W, and D
    ///
    /// * "yyyy-MM-dd HH:mm:ss" For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y, M, W, and D
    public var timestampFormat: Swift.String?
    /// Whether TimeZone is automatically derived from the geolocation attribute.
    public var useGeolocationForTimeZone: Swift.Bool

    public init (
        creationTime: ClientRuntime.Date? = nil,
        dataSize: Swift.Double? = nil,
        dataSource: ForecastClientTypes.DataSource? = nil,
        datasetArn: Swift.String? = nil,
        datasetImportJobArn: Swift.String? = nil,
        datasetImportJobName: Swift.String? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        fieldStatistics: [Swift.String:ForecastClientTypes.Statistics]? = nil,
        format: Swift.String? = nil,
        geolocationFormat: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil,
        timeZone: Swift.String? = nil,
        timestampFormat: Swift.String? = nil,
        useGeolocationForTimeZone: Swift.Bool = false
    )
    {
        self.creationTime = creationTime
        self.dataSize = dataSize
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.datasetImportJobArn = datasetImportJobArn
        self.datasetImportJobName = datasetImportJobName
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.fieldStatistics = fieldStatistics
        self.format = format
        self.geolocationFormat = geolocationFormat
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.timeZone = timeZone
        self.timestampFormat = timestampFormat
        self.useGeolocationForTimeZone = useGeolocationForTimeZone
    }
}

struct DescribeDatasetImportJobOutputResponseBody: Swift.Equatable {
    let datasetImportJobName: Swift.String?
    let datasetImportJobArn: Swift.String?
    let datasetArn: Swift.String?
    let timestampFormat: Swift.String?
    let timeZone: Swift.String?
    let useGeolocationForTimeZone: Swift.Bool
    let geolocationFormat: Swift.String?
    let dataSource: ForecastClientTypes.DataSource?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let fieldStatistics: [Swift.String:ForecastClientTypes.Statistics]?
    let dataSize: Swift.Double?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let format: Swift.String?
}

extension DescribeDatasetImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataSize = "DataSize"
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobArn = "DatasetImportJobArn"
        case datasetImportJobName = "DatasetImportJobName"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case fieldStatistics = "FieldStatistics"
        case format = "Format"
        case geolocationFormat = "GeolocationFormat"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let timestampFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampFormat)
        timestampFormat = timestampFormatDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let useGeolocationForTimeZoneDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useGeolocationForTimeZone) ?? false
        useGeolocationForTimeZone = useGeolocationForTimeZoneDecoded
        let geolocationFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geolocationFormat)
        geolocationFormat = geolocationFormatDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let fieldStatisticsContainer = try containerValues.decodeIfPresent([Swift.String: ForecastClientTypes.Statistics?].self, forKey: .fieldStatistics)
        var fieldStatisticsDecoded0: [Swift.String:ForecastClientTypes.Statistics]? = nil
        if let fieldStatisticsContainer = fieldStatisticsContainer {
            fieldStatisticsDecoded0 = [Swift.String:ForecastClientTypes.Statistics]()
            for (key0, statistics0) in fieldStatisticsContainer {
                if let statistics0 = statistics0 {
                    fieldStatisticsDecoded0?[key0] = statistics0
                }
            }
        }
        fieldStatistics = fieldStatisticsDecoded0
        let dataSizeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .dataSize)
        dataSize = dataSizeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension DescribeDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

extension DescribeDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DescribeDatasetInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension DescribeDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DescribeDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.dataFrequency = output.dataFrequency
            self.datasetArn = output.datasetArn
            self.datasetName = output.datasetName
            self.datasetType = output.datasetType
            self.domain = output.domain
            self.encryptionConfig = output.encryptionConfig
            self.lastModificationTime = output.lastModificationTime
            self.schema = output.schema
            self.status = output.status
        } else {
            self.creationTime = nil
            self.dataFrequency = nil
            self.datasetArn = nil
            self.datasetName = nil
            self.datasetType = nil
            self.domain = nil
            self.encryptionConfig = nil
            self.lastModificationTime = nil
            self.schema = nil
            self.status = nil
        }
    }
}

public struct DescribeDatasetOutputResponse: Swift.Equatable {
    /// When the dataset was created.
    public var creationTime: ClientRuntime.Date?
    /// The frequency of data collection. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "M" indicates every month and "30min" indicates every 30 minutes.
    public var dataFrequency: Swift.String?
    /// The Amazon Resource Name (ARN) of the dataset.
    public var datasetArn: Swift.String?
    /// The name of the dataset.
    public var datasetName: Swift.String?
    /// The dataset type.
    public var datasetType: ForecastClientTypes.DatasetType?
    /// The domain associated with the dataset.
    public var domain: ForecastClientTypes.Domain?
    /// The AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// When you create a dataset, LastModificationTime is the same as CreationTime. While data is being imported to the dataset, LastModificationTime is the current time of the DescribeDataset call. After a [CreateDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html) operation has finished, LastModificationTime is when the import job completed or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// An array of SchemaAttribute objects that specify the dataset fields. Each SchemaAttribute specifies the name and data type of a field.
    public var schema: ForecastClientTypes.Schema?
    /// The status of the dataset. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED
    ///
    ///
    /// The UPDATE states apply while data is imported to the dataset from a call to the [CreateDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html) operation and reflect the status of the dataset import job. For example, when the import job status is CREATE_IN_PROGRESS, the status of the dataset is UPDATE_IN_PROGRESS. The Status of the dataset must be ACTIVE before you can import training data.
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        dataFrequency: Swift.String? = nil,
        datasetArn: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        datasetType: ForecastClientTypes.DatasetType? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.dataFrequency = dataFrequency
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.datasetType = datasetType
        self.domain = domain
        self.encryptionConfig = encryptionConfig
        self.lastModificationTime = lastModificationTime
        self.schema = schema
        self.status = status
    }
}

struct DescribeDatasetOutputResponseBody: Swift.Equatable {
    let datasetArn: Swift.String?
    let datasetName: Swift.String?
    let domain: ForecastClientTypes.Domain?
    let datasetType: ForecastClientTypes.DatasetType?
    let dataFrequency: Swift.String?
    let schema: ForecastClientTypes.Schema?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension DescribeDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataFrequency = "DataFrequency"
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case lastModificationTime = "LastModificationTime"
        case schema = "Schema"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let dataFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataFrequency)
        dataFrequency = dataFrequencyDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension DescribeExplainabilityExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityExportArn = self.explainabilityExportArn {
            try encodeContainer.encode(explainabilityExportArn, forKey: .explainabilityExportArn)
        }
    }
}

extension DescribeExplainabilityExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExplainabilityExportInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explainability export.
    /// This member is required.
    public var explainabilityExportArn: Swift.String?

    public init (
        explainabilityExportArn: Swift.String? = nil
    )
    {
        self.explainabilityExportArn = explainabilityExportArn
    }
}

struct DescribeExplainabilityExportInputBody: Swift.Equatable {
    let explainabilityExportArn: Swift.String?
}

extension DescribeExplainabilityExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
    }
}

extension DescribeExplainabilityExportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExplainabilityExportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeExplainabilityExportOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExplainabilityExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeExplainabilityExportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.explainabilityArn = output.explainabilityArn
            self.explainabilityExportArn = output.explainabilityExportArn
            self.explainabilityExportName = output.explainabilityExportName
            self.format = output.format
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.explainabilityArn = nil
            self.explainabilityExportArn = nil
            self.explainabilityExportName = nil
            self.format = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
        }
    }
}

public struct DescribeExplainabilityExportOutputResponse: Swift.Equatable {
    /// When the Explainability export was created.
    public var creationTime: ClientRuntime.Date?
    /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the Explainability export.
    public var explainabilityArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the Explainability export.
    public var explainabilityExportArn: Swift.String?
    /// The name of the Explainability export.
    public var explainabilityExportName: Swift.String?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// Information about any errors that occurred during the export.
    public var message: Swift.String?
    /// The status of the Explainability export. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        explainabilityArn: Swift.String? = nil,
        explainabilityExportArn: Swift.String? = nil,
        explainabilityExportName: Swift.String? = nil,
        format: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.explainabilityArn = explainabilityArn
        self.explainabilityExportArn = explainabilityExportArn
        self.explainabilityExportName = explainabilityExportName
        self.format = format
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
    }
}

struct DescribeExplainabilityExportOutputResponseBody: Swift.Equatable {
    let explainabilityExportArn: Swift.String?
    let explainabilityExportName: Swift.String?
    let explainabilityArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let message: Swift.String?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let format: Swift.String?
}

extension DescribeExplainabilityExportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityExportArn = "ExplainabilityExportArn"
        case explainabilityExportName = "ExplainabilityExportName"
        case format = "Format"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
        let explainabilityExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportName)
        explainabilityExportName = explainabilityExportNameDecoded
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension DescribeExplainabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityArn = self.explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
    }
}

extension DescribeExplainabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExplainabilityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explaianability to describe.
    /// This member is required.
    public var explainabilityArn: Swift.String?

    public init (
        explainabilityArn: Swift.String? = nil
    )
    {
        self.explainabilityArn = explainabilityArn
    }
}

struct DescribeExplainabilityInputBody: Swift.Equatable {
    let explainabilityArn: Swift.String?
}

extension DescribeExplainabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
    }
}

extension DescribeExplainabilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExplainabilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeExplainabilityOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExplainabilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeExplainabilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.dataSource = output.dataSource
            self.enableVisualization = output.enableVisualization
            self.endDateTime = output.endDateTime
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.explainabilityArn = output.explainabilityArn
            self.explainabilityConfig = output.explainabilityConfig
            self.explainabilityName = output.explainabilityName
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.schema = output.schema
            self.startDateTime = output.startDateTime
            self.status = output.status
        } else {
            self.creationTime = nil
            self.dataSource = nil
            self.enableVisualization = nil
            self.endDateTime = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.explainabilityArn = nil
            self.explainabilityConfig = nil
            self.explainabilityName = nil
            self.lastModificationTime = nil
            self.message = nil
            self.resourceArn = nil
            self.schema = nil
            self.startDateTime = nil
            self.status = nil
        }
    }
}

public struct DescribeExplainabilityOutputResponse: Swift.Equatable {
    /// When the Explainability resource was created.
    public var creationTime: ClientRuntime.Date?
    /// The source of your data, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an AWS Key Management Service (KMS) key.
    public var dataSource: ForecastClientTypes.DataSource?
    /// Whether the visualization was enabled for the Explainability resource.
    public var enableVisualization: Swift.Bool?
    /// If TimePointGranularity is set to SPECIFIC, the last time point in the Explainability.
    public var endDateTime: Swift.String?
    /// The estimated time remaining in minutes for the [CreateExplainability] job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The Amazon Resource Name (ARN) of the Explainability.
    public var explainabilityArn: Swift.String?
    /// The configuration settings that define the granularity of time series and time points for the Explainability.
    public var explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
    /// The name of the Explainability.
    public var explainabilityName: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, a message about the error.
    public var message: Swift.String?
    /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability resource.
    public var resourceArn: Swift.String?
    /// Defines the fields of a dataset.
    public var schema: ForecastClientTypes.Schema?
    /// If TimePointGranularity is set to SPECIFIC, the first time point in the Explainability.
    public var startDateTime: Swift.String?
    /// The status of the Explainability resource. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        dataSource: ForecastClientTypes.DataSource? = nil,
        enableVisualization: Swift.Bool? = nil,
        endDateTime: Swift.String? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        explainabilityArn: Swift.String? = nil,
        explainabilityConfig: ForecastClientTypes.ExplainabilityConfig? = nil,
        explainabilityName: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        startDateTime: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.dataSource = dataSource
        self.enableVisualization = enableVisualization
        self.endDateTime = endDateTime
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.explainabilityArn = explainabilityArn
        self.explainabilityConfig = explainabilityConfig
        self.explainabilityName = explainabilityName
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.resourceArn = resourceArn
        self.schema = schema
        self.startDateTime = startDateTime
        self.status = status
    }
}

struct DescribeExplainabilityOutputResponseBody: Swift.Equatable {
    let explainabilityArn: Swift.String?
    let explainabilityName: Swift.String?
    let resourceArn: Swift.String?
    let explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
    let enableVisualization: Swift.Bool?
    let dataSource: ForecastClientTypes.DataSource?
    let schema: ForecastClientTypes.Schema?
    let startDateTime: Swift.String?
    let endDateTime: Swift.String?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let message: Swift.String?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension DescribeExplainabilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataSource = "DataSource"
        case enableVisualization = "EnableVisualization"
        case endDateTime = "EndDateTime"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityConfig = "ExplainabilityConfig"
        case explainabilityName = "ExplainabilityName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case resourceArn = "ResourceArn"
        case schema = "Schema"
        case startDateTime = "StartDateTime"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let explainabilityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityName)
        explainabilityName = explainabilityNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let explainabilityConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ExplainabilityConfig.self, forKey: .explainabilityConfig)
        explainabilityConfig = explainabilityConfigDecoded
        let enableVisualizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableVisualization)
        enableVisualization = enableVisualizationDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension DescribeForecastExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastExportJobArn = self.forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
    }
}

extension DescribeForecastExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeForecastExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast export job.
    /// This member is required.
    public var forecastExportJobArn: Swift.String?

    public init (
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct DescribeForecastExportJobInputBody: Swift.Equatable {
    let forecastExportJobArn: Swift.String?
}

extension DescribeForecastExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

extension DescribeForecastExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeForecastExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeForecastExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeForecastExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeForecastExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.forecastArn = output.forecastArn
            self.forecastExportJobArn = output.forecastExportJobArn
            self.forecastExportJobName = output.forecastExportJobName
            self.format = output.format
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.forecastArn = nil
            self.forecastExportJobArn = nil
            self.forecastExportJobName = nil
            self.format = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
        }
    }
}

public struct DescribeForecastExportJobOutputResponse: Swift.Equatable {
    /// When the forecast export job was created.
    public var creationTime: ClientRuntime.Date?
    /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the exported forecast.
    public var forecastArn: Swift.String?
    /// The ARN of the forecast export job.
    public var forecastExportJobArn: Swift.String?
    /// The name of the forecast export job.
    public var forecastExportJobName: Swift.String?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the forecast export job. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the forecast export job must be ACTIVE before you can access the forecast in your S3 bucket.
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        forecastArn: Swift.String? = nil,
        forecastExportJobArn: Swift.String? = nil,
        forecastExportJobName: Swift.String? = nil,
        format: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.forecastArn = forecastArn
        self.forecastExportJobArn = forecastExportJobArn
        self.forecastExportJobName = forecastExportJobName
        self.format = format
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
    }
}

struct DescribeForecastExportJobOutputResponseBody: Swift.Equatable {
    let forecastExportJobArn: Swift.String?
    let forecastExportJobName: Swift.String?
    let forecastArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let message: Swift.String?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let format: Swift.String?
}

extension DescribeForecastExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobArn = "ForecastExportJobArn"
        case forecastExportJobName = "ForecastExportJobName"
        case format = "Format"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension DescribeForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastArn = self.forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
    }
}

extension DescribeForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeForecastInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast.
    /// This member is required.
    public var forecastArn: Swift.String?

    public init (
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct DescribeForecastInputBody: Swift.Equatable {
    let forecastArn: Swift.String?
}

extension DescribeForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

extension DescribeForecastOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeForecastOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeForecastOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeForecastOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeForecastOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.datasetGroupArn = output.datasetGroupArn
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.forecastArn = output.forecastArn
            self.forecastName = output.forecastName
            self.forecastTypes = output.forecastTypes
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.predictorArn = output.predictorArn
            self.status = output.status
            self.timeSeriesSelector = output.timeSeriesSelector
        } else {
            self.creationTime = nil
            self.datasetGroupArn = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.forecastArn = nil
            self.forecastName = nil
            self.forecastTypes = nil
            self.lastModificationTime = nil
            self.message = nil
            self.predictorArn = nil
            self.status = nil
            self.timeSeriesSelector = nil
        }
    }
}

public struct DescribeForecastOutputResponse: Swift.Equatable {
    /// When the forecast creation task was created.
    public var creationTime: ClientRuntime.Date?
    /// The ARN of the dataset group that provided the data used to train the predictor.
    public var datasetGroupArn: Swift.String?
    /// The estimated time remaining in minutes for the forecast job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The forecast ARN as specified in the request.
    public var forecastArn: Swift.String?
    /// The name of the forecast.
    public var forecastName: Swift.String?
    /// The quantiles at which probabilistic forecasts were generated.
    public var forecastTypes: [Swift.String]?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The ARN of the predictor used to generate the forecast.
    public var predictorArn: Swift.String?
    /// The status of the forecast. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the forecast must be ACTIVE before you can query or export the forecast.
    public var status: Swift.String?
    /// The time series to include in the forecast.
    public var timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        datasetGroupArn: Swift.String? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        forecastArn: Swift.String? = nil,
        forecastName: Swift.String? = nil,
        forecastTypes: [Swift.String]? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        predictorArn: Swift.String? = nil,
        status: Swift.String? = nil,
        timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetGroupArn = datasetGroupArn
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.forecastArn = forecastArn
        self.forecastName = forecastName
        self.forecastTypes = forecastTypes
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorArn = predictorArn
        self.status = status
        self.timeSeriesSelector = timeSeriesSelector
    }
}

struct DescribeForecastOutputResponseBody: Swift.Equatable {
    let forecastArn: Swift.String?
    let forecastName: Swift.String?
    let forecastTypes: [Swift.String]?
    let predictorArn: Swift.String?
    let datasetGroupArn: Swift.String?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?
}

extension DescribeForecastOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case forecastArn = "ForecastArn"
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case status = "Status"
        case timeSeriesSelector = "TimeSeriesSelector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let forecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let timeSeriesSelectorDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesSelector.self, forKey: .timeSeriesSelector)
        timeSeriesSelector = timeSeriesSelectorDecoded
    }
}

extension DescribeMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
    }
}

extension DescribeMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMonitorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the monitor resource to describe.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init (
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct DescribeMonitorInputBody: Swift.Equatable {
    let monitorArn: Swift.String?
}

extension DescribeMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

extension DescribeMonitorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMonitorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeMonitorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMonitorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeMonitorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baseline = output.baseline
            self.creationTime = output.creationTime
            self.estimatedEvaluationTimeRemainingInMinutes = output.estimatedEvaluationTimeRemainingInMinutes
            self.lastEvaluationState = output.lastEvaluationState
            self.lastEvaluationTime = output.lastEvaluationTime
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.monitorArn = output.monitorArn
            self.monitorName = output.monitorName
            self.resourceArn = output.resourceArn
            self.status = output.status
        } else {
            self.baseline = nil
            self.creationTime = nil
            self.estimatedEvaluationTimeRemainingInMinutes = nil
            self.lastEvaluationState = nil
            self.lastEvaluationTime = nil
            self.lastModificationTime = nil
            self.message = nil
            self.monitorArn = nil
            self.monitorName = nil
            self.resourceArn = nil
            self.status = nil
        }
    }
}

public struct DescribeMonitorOutputResponse: Swift.Equatable {
    /// Metrics you can use as a baseline for comparison purposes. Use these values you interpret monitoring results for an auto predictor.
    public var baseline: ForecastClientTypes.Baseline?
    /// The timestamp for when the monitor resource was created.
    public var creationTime: ClientRuntime.Date?
    /// The estimated number of minutes remaining before the monitor resource finishes its current evaluation.
    public var estimatedEvaluationTimeRemainingInMinutes: Swift.Int?
    /// The state of the monitor's latest evaluation.
    public var lastEvaluationState: Swift.String?
    /// The timestamp of the latest evaluation completed by the monitor.
    public var lastEvaluationTime: ClientRuntime.Date?
    /// The timestamp of the latest modification to the monitor.
    public var lastModificationTime: ClientRuntime.Date?
    /// An error message, if any, for the monitor.
    public var message: Swift.String?
    /// The Amazon Resource Name (ARN) of the monitor resource described.
    public var monitorArn: Swift.String?
    /// The name of the monitor.
    public var monitorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the auto predictor being monitored.
    public var resourceArn: Swift.String?
    /// The status of the monitor resource.
    public var status: Swift.String?

    public init (
        baseline: ForecastClientTypes.Baseline? = nil,
        creationTime: ClientRuntime.Date? = nil,
        estimatedEvaluationTimeRemainingInMinutes: Swift.Int? = nil,
        lastEvaluationState: Swift.String? = nil,
        lastEvaluationTime: ClientRuntime.Date? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.baseline = baseline
        self.creationTime = creationTime
        self.estimatedEvaluationTimeRemainingInMinutes = estimatedEvaluationTimeRemainingInMinutes
        self.lastEvaluationState = lastEvaluationState
        self.lastEvaluationTime = lastEvaluationTime
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.monitorArn = monitorArn
        self.monitorName = monitorName
        self.resourceArn = resourceArn
        self.status = status
    }
}

struct DescribeMonitorOutputResponseBody: Swift.Equatable {
    let monitorName: Swift.String?
    let monitorArn: Swift.String?
    let resourceArn: Swift.String?
    let status: Swift.String?
    let lastEvaluationTime: ClientRuntime.Date?
    let lastEvaluationState: Swift.String?
    let baseline: ForecastClientTypes.Baseline?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let estimatedEvaluationTimeRemainingInMinutes: Swift.Int?
}

extension DescribeMonitorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseline = "Baseline"
        case creationTime = "CreationTime"
        case estimatedEvaluationTimeRemainingInMinutes = "EstimatedEvaluationTimeRemainingInMinutes"
        case lastEvaluationState = "LastEvaluationState"
        case lastEvaluationTime = "LastEvaluationTime"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case monitorArn = "MonitorArn"
        case monitorName = "MonitorName"
        case resourceArn = "ResourceArn"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastEvaluationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastEvaluationTime)
        lastEvaluationTime = lastEvaluationTimeDecoded
        let lastEvaluationStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastEvaluationState)
        lastEvaluationState = lastEvaluationStateDecoded
        let baselineDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Baseline.self, forKey: .baseline)
        baseline = baselineDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let estimatedEvaluationTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedEvaluationTimeRemainingInMinutes)
        estimatedEvaluationTimeRemainingInMinutes = estimatedEvaluationTimeRemainingInMinutesDecoded
    }
}

extension DescribePredictorBacktestExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorBacktestExportJobArn = self.predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
    }
}

extension DescribePredictorBacktestExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePredictorBacktestExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job.
    /// This member is required.
    public var predictorBacktestExportJobArn: Swift.String?

    public init (
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct DescribePredictorBacktestExportJobInputBody: Swift.Equatable {
    let predictorBacktestExportJobArn: Swift.String?
}

extension DescribePredictorBacktestExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

extension DescribePredictorBacktestExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePredictorBacktestExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribePredictorBacktestExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePredictorBacktestExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribePredictorBacktestExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.format = output.format
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.predictorArn = output.predictorArn
            self.predictorBacktestExportJobArn = output.predictorBacktestExportJobArn
            self.predictorBacktestExportJobName = output.predictorBacktestExportJobName
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.format = nil
            self.lastModificationTime = nil
            self.message = nil
            self.predictorArn = nil
            self.predictorBacktestExportJobArn = nil
            self.predictorBacktestExportJobName = nil
            self.status = nil
        }
    }
}

public struct DescribePredictorBacktestExportJobOutputResponse: Swift.Equatable {
    /// When the predictor backtest export job was created.
    public var creationTime: ClientRuntime.Date?
    /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
    public var destination: ForecastClientTypes.DataDestination?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// Information about any errors that may have occurred during the backtest export.
    public var message: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor.
    public var predictorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor backtest export job.
    public var predictorBacktestExportJobArn: Swift.String?
    /// The name of the predictor backtest export job.
    public var predictorBacktestExportJobName: Swift.String?
    /// The status of the predictor backtest export job. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        format: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        predictorArn: Swift.String? = nil,
        predictorBacktestExportJobArn: Swift.String? = nil,
        predictorBacktestExportJobName: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.format = format
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorArn = predictorArn
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
        self.predictorBacktestExportJobName = predictorBacktestExportJobName
        self.status = status
    }
}

struct DescribePredictorBacktestExportJobOutputResponseBody: Swift.Equatable {
    let predictorBacktestExportJobArn: Swift.String?
    let predictorBacktestExportJobName: Swift.String?
    let predictorArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let message: Swift.String?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let format: Swift.String?
}

extension DescribePredictorBacktestExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case format = "Format"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension DescribePredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

extension DescribePredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor that you want information about.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct DescribePredictorInputBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension DescribePredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension DescribePredictorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePredictorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribePredictorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePredictorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribePredictorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.algorithmArn = output.algorithmArn
            self.autoMLAlgorithmArns = output.autoMLAlgorithmArns
            self.autoMLOverrideStrategy = output.autoMLOverrideStrategy
            self.creationTime = output.creationTime
            self.datasetImportJobArns = output.datasetImportJobArns
            self.encryptionConfig = output.encryptionConfig
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.evaluationParameters = output.evaluationParameters
            self.featurizationConfig = output.featurizationConfig
            self.forecastHorizon = output.forecastHorizon
            self.forecastTypes = output.forecastTypes
            self.hpoConfig = output.hpoConfig
            self.inputDataConfig = output.inputDataConfig
            self.isAutoPredictor = output.isAutoPredictor
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.optimizationMetric = output.optimizationMetric
            self.performAutoML = output.performAutoML
            self.performHPO = output.performHPO
            self.predictorArn = output.predictorArn
            self.predictorExecutionDetails = output.predictorExecutionDetails
            self.predictorName = output.predictorName
            self.status = output.status
            self.trainingParameters = output.trainingParameters
        } else {
            self.algorithmArn = nil
            self.autoMLAlgorithmArns = nil
            self.autoMLOverrideStrategy = nil
            self.creationTime = nil
            self.datasetImportJobArns = nil
            self.encryptionConfig = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.evaluationParameters = nil
            self.featurizationConfig = nil
            self.forecastHorizon = nil
            self.forecastTypes = nil
            self.hpoConfig = nil
            self.inputDataConfig = nil
            self.isAutoPredictor = nil
            self.lastModificationTime = nil
            self.message = nil
            self.optimizationMetric = nil
            self.performAutoML = nil
            self.performHPO = nil
            self.predictorArn = nil
            self.predictorExecutionDetails = nil
            self.predictorName = nil
            self.status = nil
            self.trainingParameters = nil
        }
    }
}

public struct DescribePredictorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the algorithm used for model training.
    public var algorithmArn: Swift.String?
    /// When PerformAutoML is specified, the ARN of the chosen algorithm.
    public var autoMLAlgorithmArns: [Swift.String]?
    /// The LatencyOptimized AutoML override strategy is only available in private beta. Contact AWS Support or your account manager to learn more about access privileges. The AutoML strategy used to train the predictor. Unless LatencyOptimized is specified, the AutoML strategy optimizes predictor accuracy. This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// When the model training task was created.
    public var creationTime: ClientRuntime.Date?
    /// An array of the ARNs of the dataset import jobs used to import training data for the predictor.
    public var datasetImportJobArns: [Swift.String]?
    /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// The estimated time remaining in minutes for the predictor training job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast evaluates a predictor by splitting a dataset into training data and testing data. The evaluation parameters define how to perform the split and the number of iterations.
    public var evaluationParameters: ForecastClientTypes.EvaluationParameters?
    /// The featurization configuration.
    public var featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    /// The number of time-steps of the forecast. The forecast horizon is also called the prediction length.
    public var forecastHorizon: Swift.Int?
    /// The forecast types used during predictor training. Default value is ["0.1","0.5","0.9"]
    public var forecastTypes: [Swift.String]?
    /// The hyperparameter override values for the algorithm.
    public var hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    /// Describes the dataset group that contains the data to use to train the predictor.
    public var inputDataConfig: ForecastClientTypes.InputDataConfig?
    /// Whether the predictor was created with [CreateAutoPredictor].
    public var isAutoPredictor: Swift.Bool?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// Whether the predictor is set to perform AutoML.
    public var performAutoML: Swift.Bool?
    /// Whether the predictor is set to perform hyperparameter optimization (HPO).
    public var performHPO: Swift.Bool?
    /// The ARN of the predictor.
    public var predictorArn: Swift.String?
    /// Details on the the status and results of the backtests performed to evaluate the accuracy of the predictor. You specify the number of backtests to perform when you call the operation.
    public var predictorExecutionDetails: ForecastClientTypes.PredictorExecutionDetails?
    /// The name of the predictor.
    public var predictorName: Swift.String?
    /// The status of the predictor. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    ///
    /// The Status of the predictor must be ACTIVE before you can use the predictor to create a forecast.
    public var status: Swift.String?
    /// The default training parameters or overrides selected during model training. When running AutoML or choosing HPO with CNN-QR or DeepAR+, the optimized values for the chosen hyperparameters are returned. For more information, see [aws-forecast-choosing-recipes].
    public var trainingParameters: [Swift.String:Swift.String]?

    public init (
        algorithmArn: Swift.String? = nil,
        autoMLAlgorithmArns: [Swift.String]? = nil,
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        creationTime: ClientRuntime.Date? = nil,
        datasetImportJobArns: [Swift.String]? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        evaluationParameters: ForecastClientTypes.EvaluationParameters? = nil,
        featurizationConfig: ForecastClientTypes.FeaturizationConfig? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig? = nil,
        inputDataConfig: ForecastClientTypes.InputDataConfig? = nil,
        isAutoPredictor: Swift.Bool? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        performAutoML: Swift.Bool? = nil,
        performHPO: Swift.Bool? = nil,
        predictorArn: Swift.String? = nil,
        predictorExecutionDetails: ForecastClientTypes.PredictorExecutionDetails? = nil,
        predictorName: Swift.String? = nil,
        status: Swift.String? = nil,
        trainingParameters: [Swift.String:Swift.String]? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.autoMLAlgorithmArns = autoMLAlgorithmArns
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.creationTime = creationTime
        self.datasetImportJobArns = datasetImportJobArns
        self.encryptionConfig = encryptionConfig
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.evaluationParameters = evaluationParameters
        self.featurizationConfig = featurizationConfig
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.hpoConfig = hpoConfig
        self.inputDataConfig = inputDataConfig
        self.isAutoPredictor = isAutoPredictor
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.optimizationMetric = optimizationMetric
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.predictorArn = predictorArn
        self.predictorExecutionDetails = predictorExecutionDetails
        self.predictorName = predictorName
        self.status = status
        self.trainingParameters = trainingParameters
    }
}

struct DescribePredictorOutputResponseBody: Swift.Equatable {
    let predictorArn: Swift.String?
    let predictorName: Swift.String?
    let algorithmArn: Swift.String?
    let autoMLAlgorithmArns: [Swift.String]?
    let forecastHorizon: Swift.Int?
    let forecastTypes: [Swift.String]?
    let performAutoML: Swift.Bool?
    let autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    let performHPO: Swift.Bool?
    let trainingParameters: [Swift.String:Swift.String]?
    let evaluationParameters: ForecastClientTypes.EvaluationParameters?
    let hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    let inputDataConfig: ForecastClientTypes.InputDataConfig?
    let featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let predictorExecutionDetails: ForecastClientTypes.PredictorExecutionDetails?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let isAutoPredictor: Swift.Bool?
    let datasetImportJobArns: [Swift.String]?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
}

extension DescribePredictorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLAlgorithmArns = "AutoMLAlgorithmArns"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case creationTime = "CreationTime"
        case datasetImportJobArns = "DatasetImportJobArns"
        case encryptionConfig = "EncryptionConfig"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hpoConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case isAutoPredictor = "IsAutoPredictor"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case optimizationMetric = "OptimizationMetric"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorArn = "PredictorArn"
        case predictorExecutionDetails = "PredictorExecutionDetails"
        case predictorName = "PredictorName"
        case status = "Status"
        case trainingParameters = "TrainingParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let autoMLAlgorithmArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .autoMLAlgorithmArns)
        var autoMLAlgorithmArnsDecoded0:[Swift.String]? = nil
        if let autoMLAlgorithmArnsContainer = autoMLAlgorithmArnsContainer {
            autoMLAlgorithmArnsDecoded0 = [Swift.String]()
            for string0 in autoMLAlgorithmArnsContainer {
                if let string0 = string0 {
                    autoMLAlgorithmArnsDecoded0?.append(string0)
                }
            }
        }
        autoMLAlgorithmArns = autoMLAlgorithmArnsDecoded0
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let trainingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .trainingParameters)
        var trainingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let trainingParametersContainer = trainingParametersContainer {
            trainingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in trainingParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    trainingParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        trainingParameters = trainingParametersDecoded0
        let evaluationParametersDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EvaluationParameters.self, forKey: .evaluationParameters)
        evaluationParameters = evaluationParametersDecoded
        let hpoConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.HyperParameterTuningJobConfig.self, forKey: .hpoConfig)
        hpoConfig = hpoConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let featurizationConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FeaturizationConfig.self, forKey: .featurizationConfig)
        featurizationConfig = featurizationConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let predictorExecutionDetailsDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.PredictorExecutionDetails.self, forKey: .predictorExecutionDetails)
        predictorExecutionDetails = predictorExecutionDetailsDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let isAutoPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAutoPredictor)
        isAutoPredictor = isAutoPredictorDecoded
        let datasetImportJobArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetImportJobArns)
        var datasetImportJobArnsDecoded0:[Swift.String]? = nil
        if let datasetImportJobArnsContainer = datasetImportJobArnsContainer {
            datasetImportJobArnsDecoded0 = [Swift.String]()
            for string0 in datasetImportJobArnsContainer {
                if let string0 = string0 {
                    datasetImportJobArnsDecoded0?.append(string0)
                }
            }
        }
        datasetImportJobArns = datasetImportJobArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
    }
}

extension DescribeWhatIfAnalysisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let whatIfAnalysisArn = self.whatIfAnalysisArn {
            try encodeContainer.encode(whatIfAnalysisArn, forKey: .whatIfAnalysisArn)
        }
    }
}

extension DescribeWhatIfAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWhatIfAnalysisInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if analysis that you are interested in.
    /// This member is required.
    public var whatIfAnalysisArn: Swift.String?

    public init (
        whatIfAnalysisArn: Swift.String? = nil
    )
    {
        self.whatIfAnalysisArn = whatIfAnalysisArn
    }
}

struct DescribeWhatIfAnalysisInputBody: Swift.Equatable {
    let whatIfAnalysisArn: Swift.String?
}

extension DescribeWhatIfAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
    }
}

extension DescribeWhatIfAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWhatIfAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWhatIfAnalysisOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWhatIfAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWhatIfAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.forecastArn = output.forecastArn
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
            self.timeSeriesSelector = output.timeSeriesSelector
            self.whatIfAnalysisArn = output.whatIfAnalysisArn
            self.whatIfAnalysisName = output.whatIfAnalysisName
        } else {
            self.creationTime = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.forecastArn = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
            self.timeSeriesSelector = nil
            self.whatIfAnalysisArn = nil
            self.whatIfAnalysisName = nil
        }
    }
}

public struct DescribeWhatIfAnalysisOutputResponse: Swift.Equatable {
    /// When the what-if analysis was created.
    public var creationTime: ClientRuntime.Date?
    /// The approximate time remaining to complete the what-if analysis, in minutes.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The Amazon Resource Name (ARN) of the what-if forecast.
    public var forecastArn: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the what-if analysis. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the what-if analysis must be ACTIVE before you can access the analysis.
    public var status: Swift.String?
    /// Defines the set of time series that are used to create the forecasts in a TimeSeriesIdentifiers object. The TimeSeriesIdentifiers object needs the following information:
    ///
    /// * DataSource
    ///
    /// * Format
    ///
    /// * Schema
    public var timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?
    /// The Amazon Resource Name (ARN) of the what-if analysis.
    public var whatIfAnalysisArn: Swift.String?
    /// The name of the what-if analysis.
    public var whatIfAnalysisName: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        forecastArn: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil,
        timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector? = nil,
        whatIfAnalysisArn: Swift.String? = nil,
        whatIfAnalysisName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.forecastArn = forecastArn
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.timeSeriesSelector = timeSeriesSelector
        self.whatIfAnalysisArn = whatIfAnalysisArn
        self.whatIfAnalysisName = whatIfAnalysisName
    }
}

struct DescribeWhatIfAnalysisOutputResponseBody: Swift.Equatable {
    let whatIfAnalysisName: Swift.String?
    let whatIfAnalysisArn: Swift.String?
    let forecastArn: Swift.String?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?
}

extension DescribeWhatIfAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case forecastArn = "ForecastArn"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case timeSeriesSelector = "TimeSeriesSelector"
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
        case whatIfAnalysisName = "WhatIfAnalysisName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfAnalysisNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisName)
        whatIfAnalysisName = whatIfAnalysisNameDecoded
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let timeSeriesSelectorDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesSelector.self, forKey: .timeSeriesSelector)
        timeSeriesSelector = timeSeriesSelectorDecoded
    }
}

extension DescribeWhatIfForecastExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastExportArn = "WhatIfForecastExportArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let whatIfForecastExportArn = self.whatIfForecastExportArn {
            try encodeContainer.encode(whatIfForecastExportArn, forKey: .whatIfForecastExportArn)
        }
    }
}

extension DescribeWhatIfForecastExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWhatIfForecastExportInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if forecast export that you are interested in.
    /// This member is required.
    public var whatIfForecastExportArn: Swift.String?

    public init (
        whatIfForecastExportArn: Swift.String? = nil
    )
    {
        self.whatIfForecastExportArn = whatIfForecastExportArn
    }
}

struct DescribeWhatIfForecastExportInputBody: Swift.Equatable {
    let whatIfForecastExportArn: Swift.String?
}

extension DescribeWhatIfForecastExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastExportArn = "WhatIfForecastExportArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportArn)
        whatIfForecastExportArn = whatIfForecastExportArnDecoded
    }
}

extension DescribeWhatIfForecastExportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWhatIfForecastExportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWhatIfForecastExportOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWhatIfForecastExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWhatIfForecastExportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.format = output.format
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
            self.whatIfForecastArns = output.whatIfForecastArns
            self.whatIfForecastExportArn = output.whatIfForecastExportArn
            self.whatIfForecastExportName = output.whatIfForecastExportName
        } else {
            self.creationTime = nil
            self.destination = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.format = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
            self.whatIfForecastArns = nil
            self.whatIfForecastExportArn = nil
            self.whatIfForecastExportName = nil
        }
    }
}

public struct DescribeWhatIfForecastExportOutputResponse: Swift.Equatable {
    /// When the what-if forecast export was created.
    public var creationTime: ClientRuntime.Date?
    /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
    public var destination: ForecastClientTypes.DataDestination?
    /// The approximate time remaining to complete the what-if forecast export, in minutes.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the what-if forecast. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the what-if forecast export must be ACTIVE before you can access the forecast export.
    public var status: Swift.String?
    /// An array of Amazon Resource Names (ARNs) that represent all of the what-if forecasts exported in this resource.
    public var whatIfForecastArns: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the what-if forecast export.
    public var whatIfForecastExportArn: Swift.String?
    /// The name of the what-if forecast export.
    public var whatIfForecastExportName: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        format: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil,
        whatIfForecastArns: [Swift.String]? = nil,
        whatIfForecastExportArn: Swift.String? = nil,
        whatIfForecastExportName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.format = format
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.whatIfForecastArns = whatIfForecastArns
        self.whatIfForecastExportArn = whatIfForecastExportArn
        self.whatIfForecastExportName = whatIfForecastExportName
    }
}

struct DescribeWhatIfForecastExportOutputResponseBody: Swift.Equatable {
    let whatIfForecastExportArn: Swift.String?
    let whatIfForecastExportName: Swift.String?
    let whatIfForecastArns: [Swift.String]?
    let destination: ForecastClientTypes.DataDestination?
    let message: Swift.String?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let lastModificationTime: ClientRuntime.Date?
    let format: Swift.String?
}

extension DescribeWhatIfForecastExportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case format = "Format"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case whatIfForecastArns = "WhatIfForecastArns"
        case whatIfForecastExportArn = "WhatIfForecastExportArn"
        case whatIfForecastExportName = "WhatIfForecastExportName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportArn)
        whatIfForecastExportArn = whatIfForecastExportArnDecoded
        let whatIfForecastExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportName)
        whatIfForecastExportName = whatIfForecastExportNameDecoded
        let whatIfForecastArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whatIfForecastArns)
        var whatIfForecastArnsDecoded0:[Swift.String]? = nil
        if let whatIfForecastArnsContainer = whatIfForecastArnsContainer {
            whatIfForecastArnsDecoded0 = [Swift.String]()
            for string0 in whatIfForecastArnsContainer {
                if let string0 = string0 {
                    whatIfForecastArnsDecoded0?.append(string0)
                }
            }
        }
        whatIfForecastArns = whatIfForecastArnsDecoded0
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension DescribeWhatIfForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastArn = "WhatIfForecastArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let whatIfForecastArn = self.whatIfForecastArn {
            try encodeContainer.encode(whatIfForecastArn, forKey: .whatIfForecastArn)
        }
    }
}

extension DescribeWhatIfForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWhatIfForecastInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the what-if forecast that you are interested in.
    /// This member is required.
    public var whatIfForecastArn: Swift.String?

    public init (
        whatIfForecastArn: Swift.String? = nil
    )
    {
        self.whatIfForecastArn = whatIfForecastArn
    }
}

struct DescribeWhatIfForecastInputBody: Swift.Equatable {
    let whatIfForecastArn: Swift.String?
}

extension DescribeWhatIfForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfForecastArn = "WhatIfForecastArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastArn)
        whatIfForecastArn = whatIfForecastArnDecoded
    }
}

extension DescribeWhatIfForecastOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWhatIfForecastOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWhatIfForecastOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWhatIfForecastOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWhatIfForecastOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.forecastTypes = output.forecastTypes
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
            self.timeSeriesReplacementsDataSource = output.timeSeriesReplacementsDataSource
            self.timeSeriesTransformations = output.timeSeriesTransformations
            self.whatIfAnalysisArn = output.whatIfAnalysisArn
            self.whatIfForecastArn = output.whatIfForecastArn
            self.whatIfForecastName = output.whatIfForecastName
        } else {
            self.creationTime = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.forecastTypes = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
            self.timeSeriesReplacementsDataSource = nil
            self.timeSeriesTransformations = nil
            self.whatIfAnalysisArn = nil
            self.whatIfForecastArn = nil
            self.whatIfForecastName = nil
        }
    }
}

public struct DescribeWhatIfForecastOutputResponse: Swift.Equatable {
    /// When the what-if forecast was created.
    public var creationTime: ClientRuntime.Date?
    /// The approximate time remaining to complete the what-if forecast, in minutes.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The quantiles at which probabilistic forecasts are generated. You can specify up to 5 quantiles per what-if forecast in the [CreateWhatIfForecast] operation. If you didn't specify quantiles, the default values are ["0.1", "0.5", "0.9"].
    public var forecastTypes: [Swift.String]?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the what-if forecast. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the what-if forecast must be ACTIVE before you can access the forecast.
    public var status: Swift.String?
    /// An array of S3Config, Schema, and Format elements that describe the replacement time series.
    public var timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource?
    /// An array of Action and TimeSeriesConditions elements that describe what transformations were applied to which time series.
    public var timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]?
    /// The Amazon Resource Name (ARN) of the what-if analysis that contains this forecast.
    public var whatIfAnalysisArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the what-if forecast.
    public var whatIfForecastArn: Swift.String?
    /// The name of the what-if forecast.
    public var whatIfForecastName: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil,
        timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource? = nil,
        timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]? = nil,
        whatIfAnalysisArn: Swift.String? = nil,
        whatIfForecastArn: Swift.String? = nil,
        whatIfForecastName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.forecastTypes = forecastTypes
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.timeSeriesReplacementsDataSource = timeSeriesReplacementsDataSource
        self.timeSeriesTransformations = timeSeriesTransformations
        self.whatIfAnalysisArn = whatIfAnalysisArn
        self.whatIfForecastArn = whatIfForecastArn
        self.whatIfForecastName = whatIfForecastName
    }
}

struct DescribeWhatIfForecastOutputResponseBody: Swift.Equatable {
    let whatIfForecastName: Swift.String?
    let whatIfForecastArn: Swift.String?
    let whatIfAnalysisArn: Swift.String?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]?
    let timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource?
    let forecastTypes: [Swift.String]?
}

extension DescribeWhatIfForecastOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case forecastTypes = "ForecastTypes"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case timeSeriesReplacementsDataSource = "TimeSeriesReplacementsDataSource"
        case timeSeriesTransformations = "TimeSeriesTransformations"
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
        case whatIfForecastArn = "WhatIfForecastArn"
        case whatIfForecastName = "WhatIfForecastName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastName)
        whatIfForecastName = whatIfForecastNameDecoded
        let whatIfForecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastArn)
        whatIfForecastArn = whatIfForecastArnDecoded
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let timeSeriesTransformationsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.TimeSeriesTransformation?].self, forKey: .timeSeriesTransformations)
        var timeSeriesTransformationsDecoded0:[ForecastClientTypes.TimeSeriesTransformation]? = nil
        if let timeSeriesTransformationsContainer = timeSeriesTransformationsContainer {
            timeSeriesTransformationsDecoded0 = [ForecastClientTypes.TimeSeriesTransformation]()
            for structure0 in timeSeriesTransformationsContainer {
                if let structure0 = structure0 {
                    timeSeriesTransformationsDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesTransformations = timeSeriesTransformationsDecoded0
        let timeSeriesReplacementsDataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesReplacementsDataSource.self, forKey: .timeSeriesReplacementsDataSource)
        timeSeriesReplacementsDataSource = timeSeriesReplacementsDataSourceDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
    }
}

extension ForecastClientTypes {
    public enum Domain: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case ec2Capacity
        case inventoryPlanning
        case metrics
        case retail
        case webTraffic
        case workForce
        case sdkUnknown(Swift.String)

        public static var allCases: [Domain] {
            return [
                .custom,
                .ec2Capacity,
                .inventoryPlanning,
                .metrics,
                .retail,
                .webTraffic,
                .workForce,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .ec2Capacity: return "EC2_CAPACITY"
            case .inventoryPlanning: return "INVENTORY_PLANNING"
            case .metrics: return "METRICS"
            case .retail: return "RETAIL"
            case .webTraffic: return "WEB_TRAFFIC"
            case .workForce: return "WORK_FORCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Domain(rawValue: rawValue) ?? Domain.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.EncryptionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn = "KMSKeyArn"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension ForecastClientTypes {
    /// An AWS Key Management Service (KMS) key and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key. You can specify this optional object in the [CreateDataset] and [CreatePredictor] requests.
    public struct EncryptionConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the KMS key.
        /// This member is required.
        public var kmsKeyArn: Swift.String?
        /// The ARN of the IAM role that Amazon Forecast can assume to access the AWS KMS key. Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an InvalidInputException error.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            kmsKeyArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.roleArn = roleArn
        }
    }

}

extension ForecastClientTypes.ErrorMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastType = "ForecastType"
        case mape = "MAPE"
        case mase = "MASE"
        case rmse = "RMSE"
        case wape = "WAPE"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastType = self.forecastType {
            try encodeContainer.encode(forecastType, forKey: .forecastType)
        }
        if let mape = self.mape {
            try encodeContainer.encode(mape, forKey: .mape)
        }
        if let mase = self.mase {
            try encodeContainer.encode(mase, forKey: .mase)
        }
        if let rmse = self.rmse {
            try encodeContainer.encode(rmse, forKey: .rmse)
        }
        if let wape = self.wape {
            try encodeContainer.encode(wape, forKey: .wape)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastType)
        forecastType = forecastTypeDecoded
        let wapeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .wape)
        wape = wapeDecoded
        let rmseDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .rmse)
        rmse = rmseDecoded
        let maseDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .mase)
        mase = maseDecoded
        let mapeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .mape)
        mape = mapeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides detailed error metrics to evaluate the performance of a predictor. This object is part of the [Metrics] object.
    public struct ErrorMetric: Swift.Equatable {
        /// The Forecast type used to compute WAPE, MAPE, MASE, and RMSE.
        public var forecastType: Swift.String?
        /// The Mean Absolute Percentage Error (MAPE)
        public var mape: Swift.Double?
        /// The Mean Absolute Scaled Error (MASE)
        public var mase: Swift.Double?
        /// The root-mean-square error (RMSE).
        public var rmse: Swift.Double?
        /// The weighted absolute percentage error (WAPE).
        public var wape: Swift.Double?

        public init (
            forecastType: Swift.String? = nil,
            mape: Swift.Double? = nil,
            mase: Swift.Double? = nil,
            rmse: Swift.Double? = nil,
            wape: Swift.Double? = nil
        )
        {
            self.forecastType = forecastType
            self.mape = mape
            self.mase = mase
            self.rmse = rmse
            self.wape = wape
        }
    }

}

extension ForecastClientTypes.EvaluationParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backTestWindowOffset = "BackTestWindowOffset"
        case numberOfBacktestWindows = "NumberOfBacktestWindows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backTestWindowOffset = self.backTestWindowOffset {
            try encodeContainer.encode(backTestWindowOffset, forKey: .backTestWindowOffset)
        }
        if let numberOfBacktestWindows = self.numberOfBacktestWindows {
            try encodeContainer.encode(numberOfBacktestWindows, forKey: .numberOfBacktestWindows)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfBacktestWindowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfBacktestWindows)
        numberOfBacktestWindows = numberOfBacktestWindowsDecoded
        let backTestWindowOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backTestWindowOffset)
        backTestWindowOffset = backTestWindowOffsetDecoded
    }
}

extension ForecastClientTypes {
    /// Parameters that define how to split a dataset into training data and testing data, and the number of iterations to perform. These parameters are specified in the predefined algorithms but you can override them in the [CreatePredictor] request.
    public struct EvaluationParameters: Swift.Equatable {
        /// The point from the end of the dataset where you want to split the data for model training and testing (evaluation). Specify the value as the number of data points. The default is the value of the forecast horizon. BackTestWindowOffset can be used to mimic a past virtual forecast start date. This value must be greater than or equal to the forecast horizon and less than half of the TARGET_TIME_SERIES dataset length. ForecastHorizon <= BackTestWindowOffset < 1/2 * TARGET_TIME_SERIES dataset length
        public var backTestWindowOffset: Swift.Int?
        /// The number of times to split the input data. The default is 1. Valid values are 1 through 5.
        public var numberOfBacktestWindows: Swift.Int?

        public init (
            backTestWindowOffset: Swift.Int? = nil,
            numberOfBacktestWindows: Swift.Int? = nil
        )
        {
            self.backTestWindowOffset = backTestWindowOffset
            self.numberOfBacktestWindows = numberOfBacktestWindows
        }
    }

}

extension ForecastClientTypes.EvaluationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case testWindows = "TestWindows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = self.algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let testWindows = testWindows {
            var testWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .testWindows)
            for windowsummary0 in testWindows {
                try testWindowsContainer.encode(windowsummary0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let testWindowsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.WindowSummary?].self, forKey: .testWindows)
        var testWindowsDecoded0:[ForecastClientTypes.WindowSummary]? = nil
        if let testWindowsContainer = testWindowsContainer {
            testWindowsDecoded0 = [ForecastClientTypes.WindowSummary]()
            for structure0 in testWindowsContainer {
                if let structure0 = structure0 {
                    testWindowsDecoded0?.append(structure0)
                }
            }
        }
        testWindows = testWindowsDecoded0
    }
}

extension ForecastClientTypes {
    /// The results of evaluating an algorithm. Returned as part of the [GetAccuracyMetrics] response.
    public struct EvaluationResult: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the algorithm that was evaluated.
        public var algorithmArn: Swift.String?
        /// The array of test windows used for evaluating the algorithm. The NumberOfBacktestWindows from the [EvaluationParameters] object determines the number of windows in the array.
        public var testWindows: [ForecastClientTypes.WindowSummary]?

        public init (
            algorithmArn: Swift.String? = nil,
            testWindows: [ForecastClientTypes.WindowSummary]? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }
    }

}

extension ForecastClientTypes {
    public enum EvaluationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case computed
        case summary
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationType] {
            return [
                .computed,
                .summary,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .computed: return "COMPUTED"
            case .summary: return "SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationType(rawValue: rawValue) ?? EvaluationType.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.ExplainabilityConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timePointGranularity = "TimePointGranularity"
        case timeSeriesGranularity = "TimeSeriesGranularity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timePointGranularity = self.timePointGranularity {
            try encodeContainer.encode(timePointGranularity.rawValue, forKey: .timePointGranularity)
        }
        if let timeSeriesGranularity = self.timeSeriesGranularity {
            try encodeContainer.encode(timeSeriesGranularity.rawValue, forKey: .timeSeriesGranularity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesGranularityDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesGranularity.self, forKey: .timeSeriesGranularity)
        timeSeriesGranularity = timeSeriesGranularityDecoded
        let timePointGranularityDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimePointGranularity.self, forKey: .timePointGranularity)
        timePointGranularity = timePointGranularityDecoded
    }
}

extension ForecastClientTypes {
    /// The ExplainabilityConfig data type defines the number of time series and time points included in [CreateExplainability]. If you provide a predictor ARN for ResourceArn, you must set both TimePointGranularity and TimeSeriesGranularity to “ALL”. When creating Predictor Explainability, Amazon Forecast considers all time series and time points. If you provide a forecast ARN for ResourceArn, you can set TimePointGranularity and TimeSeriesGranularity to either “ALL” or “Specific”.
    public struct ExplainabilityConfig: Swift.Equatable {
        /// To create an Explainability for all time points in your forecast horizon, use ALL. To create an Explainability for specific time points in your forecast horizon, use SPECIFIC. Specify time points with the StartDateTime and EndDateTime parameters within the [CreateExplainability] operation.
        /// This member is required.
        public var timePointGranularity: ForecastClientTypes.TimePointGranularity?
        /// To create an Explainability for all time series in your datasets, use ALL. To create an Explainability for specific time series in your datasets, use SPECIFIC. Specify time series by uploading a CSV or Parquet file to an Amazon S3 bucket and set the location within the [DataDestination] data type.
        /// This member is required.
        public var timeSeriesGranularity: ForecastClientTypes.TimeSeriesGranularity?

        public init (
            timePointGranularity: ForecastClientTypes.TimePointGranularity? = nil,
            timeSeriesGranularity: ForecastClientTypes.TimeSeriesGranularity? = nil
        )
        {
            self.timePointGranularity = timePointGranularity
            self.timeSeriesGranularity = timeSeriesGranularity
        }
    }

}

extension ForecastClientTypes.ExplainabilityExportSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case explainabilityExportArn = "ExplainabilityExportArn"
        case explainabilityExportName = "ExplainabilityExportName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let explainabilityExportArn = self.explainabilityExportArn {
            try encodeContainer.encode(explainabilityExportArn, forKey: .explainabilityExportArn)
        }
        if let explainabilityExportName = self.explainabilityExportName {
            try encodeContainer.encode(explainabilityExportName, forKey: .explainabilityExportName)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
        let explainabilityExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportName)
        explainabilityExportName = explainabilityExportNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the Explainability export properties used in the [ListExplainabilityExports] operation. To get a complete set of properties, call the [DescribeExplainabilityExport] operation, and provide the ExplainabilityExportArn.
    public struct ExplainabilityExportSummary: Swift.Equatable {
        /// When the Explainability was created.
        public var creationTime: ClientRuntime.Date?
        /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
        public var destination: ForecastClientTypes.DataDestination?
        /// The Amazon Resource Name (ARN) of the Explainability export.
        public var explainabilityExportArn: Swift.String?
        /// The name of the Explainability export
        public var explainabilityExportName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// Information about any errors that may have occurred during the Explainability export.
        public var message: Swift.String?
        /// The status of the Explainability export. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            explainabilityExportArn: Swift.String? = nil,
            explainabilityExportName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.explainabilityExportArn = explainabilityExportArn
            self.explainabilityExportName = explainabilityExportName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }
    }

}

extension ForecastClientTypes.ExplainabilityInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityArn = self.explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ForecastClientTypes {
    /// Provides information about the Explainability resource.
    public struct ExplainabilityInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Explainability.
        public var explainabilityArn: Swift.String?
        /// The status of the Explainability. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init (
            explainabilityArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.explainabilityArn = explainabilityArn
            self.status = status
        }
    }

}

extension ForecastClientTypes.ExplainabilitySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityConfig = "ExplainabilityConfig"
        case explainabilityName = "ExplainabilityName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case resourceArn = "ResourceArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let explainabilityArn = self.explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
        if let explainabilityConfig = self.explainabilityConfig {
            try encodeContainer.encode(explainabilityConfig, forKey: .explainabilityConfig)
        }
        if let explainabilityName = self.explainabilityName {
            try encodeContainer.encode(explainabilityName, forKey: .explainabilityName)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let explainabilityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityName)
        explainabilityName = explainabilityNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let explainabilityConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ExplainabilityConfig.self, forKey: .explainabilityConfig)
        explainabilityConfig = explainabilityConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the Explainability properties used in the [ListExplainabilities] operation. To get a complete set of properties, call the [DescribeExplainability] operation, and provide the listed ExplainabilityArn.
    public struct ExplainabilitySummary: Swift.Equatable {
        /// When the Explainability was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the Explainability.
        public var explainabilityArn: Swift.String?
        /// The configuration settings that define the granularity of time series and time points for the Explainability.
        public var explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
        /// The name of the Explainability.
        public var explainabilityName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// Information about any errors that may have occurred during the Explainability creation process.
        public var message: Swift.String?
        /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability.
        public var resourceArn: Swift.String?
        /// The status of the Explainability. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            explainabilityArn: Swift.String? = nil,
            explainabilityConfig: ForecastClientTypes.ExplainabilityConfig? = nil,
            explainabilityName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.explainabilityArn = explainabilityArn
            self.explainabilityConfig = explainabilityConfig
            self.explainabilityName = explainabilityName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.resourceArn = resourceArn
            self.status = status
        }
    }

}

extension ForecastClientTypes.Featurization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case featurizationPipeline = "FeaturizationPipeline"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let featurizationPipeline = featurizationPipeline {
            var featurizationPipelineContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featurizationPipeline)
            for featurizationmethod0 in featurizationPipeline {
                try featurizationPipelineContainer.encode(featurizationmethod0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let featurizationPipelineContainer = try containerValues.decodeIfPresent([ForecastClientTypes.FeaturizationMethod?].self, forKey: .featurizationPipeline)
        var featurizationPipelineDecoded0:[ForecastClientTypes.FeaturizationMethod]? = nil
        if let featurizationPipelineContainer = featurizationPipelineContainer {
            featurizationPipelineDecoded0 = [ForecastClientTypes.FeaturizationMethod]()
            for structure0 in featurizationPipelineContainer {
                if let structure0 = structure0 {
                    featurizationPipelineDecoded0?.append(structure0)
                }
            }
        }
        featurizationPipeline = featurizationPipelineDecoded0
    }
}

extension ForecastClientTypes {
    /// This object belongs to the [CreatePredictor] operation. If you created your predictor with [CreateAutoPredictor], see [AttributeConfig]. Provides featurization (transformation) information for a dataset field. This object is part of the [FeaturizationConfig] object. For example: {
    ///     "AttributeName": "demand",
    ///
    ///
    ///     FeaturizationPipeline [ {
    ///
    ///
    ///     "FeaturizationMethodName": "filling",
    ///
    ///
    ///     "FeaturizationMethodParameters": {"aggregation": "avg", "backfill": "nan"}
    ///
    ///
    ///     } ]
    ///
    ///
    ///     }
    public struct Featurization: Swift.Equatable {
        /// The name of the schema attribute that specifies the data field to be featurized. Amazon Forecast supports the target field of the TARGET_TIME_SERIES and the RELATED_TIME_SERIES datasets. For example, for the RETAIL domain, the target is demand, and for the CUSTOM domain, the target is target_value. For more information, see [howitworks-missing-values].
        /// This member is required.
        public var attributeName: Swift.String?
        /// An array of one FeaturizationMethod object that specifies the feature transformation method.
        public var featurizationPipeline: [ForecastClientTypes.FeaturizationMethod]?

        public init (
            attributeName: Swift.String? = nil,
            featurizationPipeline: [ForecastClientTypes.FeaturizationMethod]? = nil
        )
        {
            self.attributeName = attributeName
            self.featurizationPipeline = featurizationPipeline
        }
    }

}

extension ForecastClientTypes.FeaturizationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featurizations = "Featurizations"
        case forecastDimensions = "ForecastDimensions"
        case forecastFrequency = "ForecastFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featurizations = featurizations {
            var featurizationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featurizations)
            for featurization0 in featurizations {
                try featurizationsContainer.encode(featurization0)
            }
        }
        if let forecastDimensions = forecastDimensions {
            var forecastDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastDimensions)
            for name0 in forecastDimensions {
                try forecastDimensionsContainer.encode(name0)
            }
        }
        if let forecastFrequency = self.forecastFrequency {
            try encodeContainer.encode(forecastFrequency, forKey: .forecastFrequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastFrequency)
        forecastFrequency = forecastFrequencyDecoded
        let forecastDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastDimensions)
        var forecastDimensionsDecoded0:[Swift.String]? = nil
        if let forecastDimensionsContainer = forecastDimensionsContainer {
            forecastDimensionsDecoded0 = [Swift.String]()
            for string0 in forecastDimensionsContainer {
                if let string0 = string0 {
                    forecastDimensionsDecoded0?.append(string0)
                }
            }
        }
        forecastDimensions = forecastDimensionsDecoded0
        let featurizationsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Featurization?].self, forKey: .featurizations)
        var featurizationsDecoded0:[ForecastClientTypes.Featurization]? = nil
        if let featurizationsContainer = featurizationsContainer {
            featurizationsDecoded0 = [ForecastClientTypes.Featurization]()
            for structure0 in featurizationsContainer {
                if let structure0 = structure0 {
                    featurizationsDecoded0?.append(structure0)
                }
            }
        }
        featurizations = featurizationsDecoded0
    }
}

extension ForecastClientTypes {
    /// This object belongs to the [CreatePredictor] operation. If you created your predictor with [CreateAutoPredictor], see [AttributeConfig]. In a [CreatePredictor] operation, the specified algorithm trains a model using the specified dataset group. You can optionally tell the operation to modify data fields prior to training a model. These modifications are referred to as featurization. You define featurization using the FeaturizationConfig object. You specify an array of transformations, one for each field that you want to featurize. You then include the FeaturizationConfig object in your CreatePredictor request. Amazon Forecast applies the featurization to the TARGET_TIME_SERIES and RELATED_TIME_SERIES datasets before model training. You can create multiple featurization configurations. For example, you might call the CreatePredictor operation twice by specifying different featurization configurations.
    public struct FeaturizationConfig: Swift.Equatable {
        /// An array of featurization (transformation) information for the fields of a dataset.
        public var featurizations: [ForecastClientTypes.Featurization]?
        /// An array of dimension (field) names that specify how to group the generated forecast. For example, suppose that you are generating a forecast for item sales across all of your stores, and your dataset contains a store_id field. If you want the sales forecast for each item by store, you would specify store_id as the dimension. All forecast dimensions specified in the TARGET_TIME_SERIES dataset don't need to be specified in the CreatePredictor request. All forecast dimensions specified in the RELATED_TIME_SERIES dataset must be specified in the CreatePredictor request.
        public var forecastDimensions: [Swift.String]?
        /// The frequency of predictions in a forecast. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes. The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency. When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the RELATED_TIME_SERIES dataset frequency.
        /// This member is required.
        public var forecastFrequency: Swift.String?

        public init (
            featurizations: [ForecastClientTypes.Featurization]? = nil,
            forecastDimensions: [Swift.String]? = nil,
            forecastFrequency: Swift.String? = nil
        )
        {
            self.featurizations = featurizations
            self.forecastDimensions = forecastDimensions
            self.forecastFrequency = forecastFrequency
        }
    }

}

extension ForecastClientTypes.FeaturizationMethod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featurizationMethodName = "FeaturizationMethodName"
        case featurizationMethodParameters = "FeaturizationMethodParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featurizationMethodName = self.featurizationMethodName {
            try encodeContainer.encode(featurizationMethodName.rawValue, forKey: .featurizationMethodName)
        }
        if let featurizationMethodParameters = featurizationMethodParameters {
            var featurizationMethodParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .featurizationMethodParameters)
            for (dictKey0, featurizationMethodParameters0) in featurizationMethodParameters {
                try featurizationMethodParametersContainer.encode(featurizationMethodParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featurizationMethodNameDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FeaturizationMethodName.self, forKey: .featurizationMethodName)
        featurizationMethodName = featurizationMethodNameDecoded
        let featurizationMethodParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .featurizationMethodParameters)
        var featurizationMethodParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let featurizationMethodParametersContainer = featurizationMethodParametersContainer {
            featurizationMethodParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in featurizationMethodParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    featurizationMethodParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        featurizationMethodParameters = featurizationMethodParametersDecoded0
    }
}

extension ForecastClientTypes {
    /// Provides information about the method that featurizes (transforms) a dataset field. The method is part of the FeaturizationPipeline of the [Featurization] object. The following is an example of how you specify a FeaturizationMethod object. {
    ///     "FeaturizationMethodName": "filling",
    ///
    ///
    ///     "FeaturizationMethodParameters": {"aggregation": "sum", "middlefill": "zero", "backfill": "zero"}
    ///
    ///
    ///     }
    public struct FeaturizationMethod: Swift.Equatable {
        /// The name of the method. The "filling" method is the only supported method.
        /// This member is required.
        public var featurizationMethodName: ForecastClientTypes.FeaturizationMethodName?
        /// The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters. The following list shows the parameters and their valid values for the "filling" featurization method for a Target Time Series dataset. Bold signifies the default value.
        ///
        /// * aggregation: sum, avg, first, min, max
        ///
        /// * frontfill: none
        ///
        /// * middlefill: zero, nan (not a number), value, median, mean, min, max
        ///
        /// * backfill: zero, nan, value, median, mean, min, max
        ///
        ///
        /// The following list shows the parameters and their valid values for a Related Time Series featurization method (there are no defaults):
        ///
        /// * middlefill: zero, value, median, mean, min, max
        ///
        /// * backfill: zero, value, median, mean, min, max
        ///
        /// * futurefill: zero, value, median, mean, min, max
        ///
        ///
        /// To set a filling method to a specific value, set the fill parameter to value and define the value in a corresponding _value parameter. For example, to set backfilling to a value of 2, include the following: "backfill": "value" and "backfill_value":"2".
        public var featurizationMethodParameters: [Swift.String:Swift.String]?

        public init (
            featurizationMethodName: ForecastClientTypes.FeaturizationMethodName? = nil,
            featurizationMethodParameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.featurizationMethodName = featurizationMethodName
            self.featurizationMethodParameters = featurizationMethodParameters
        }
    }

}

extension ForecastClientTypes {
    public enum FeaturizationMethodName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case filling
        case sdkUnknown(Swift.String)

        public static var allCases: [FeaturizationMethodName] {
            return [
                .filling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .filling: return "filling"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeaturizationMethodName(rawValue: rawValue) ?? FeaturizationMethodName.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FilterConditionString.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ForecastClientTypes {
    /// Describes a filter for choosing a subset of objects. Each filter consists of a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the objects that match the statement, respectively. The match statement consists of a key and a value.
    public struct Filter: Swift.Equatable {
        /// The condition to apply. To include the objects that match the statement, specify IS. To exclude matching objects, specify IS_NOT.
        /// This member is required.
        public var condition: ForecastClientTypes.FilterConditionString?
        /// The name of the parameter to filter on.
        /// This member is required.
        public var key: Swift.String?
        /// The value to match.
        /// This member is required.
        public var value: Swift.String?

        public init (
            condition: ForecastClientTypes.FilterConditionString? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.condition = condition
            self.key = key
            self.value = value
        }
    }

}

extension ForecastClientTypes {
    public enum FilterConditionString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `is`
        case isNot
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterConditionString] {
            return [
                .is,
                .isNot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .is: return "IS"
            case .isNot: return "IS_NOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterConditionString(rawValue: rawValue) ?? FilterConditionString.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.ForecastExportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case forecastExportJobArn = "ForecastExportJobArn"
        case forecastExportJobName = "ForecastExportJobName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let forecastExportJobArn = self.forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
        if let forecastExportJobName = self.forecastExportJobName {
            try encodeContainer.encode(forecastExportJobName, forKey: .forecastExportJobName)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the forecast export job properties used in the [ListForecastExportJobs] operation. To get the complete set of properties, call the [DescribeForecastExportJob] operation, and provide the listed ForecastExportJobArn.
    public struct ForecastExportJobSummary: Swift.Equatable {
        /// When the forecast export job was created.
        public var creationTime: ClientRuntime.Date?
        /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
        public var destination: ForecastClientTypes.DataDestination?
        /// The Amazon Resource Name (ARN) of the forecast export job.
        public var forecastExportJobArn: Swift.String?
        /// The name of the forecast export job.
        public var forecastExportJobName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the forecast export job. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the forecast export job must be ACTIVE before you can access the forecast in your S3 bucket.
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            forecastExportJobArn: Swift.String? = nil,
            forecastExportJobName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.forecastExportJobArn = forecastExportJobArn
            self.forecastExportJobName = forecastExportJobName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }
    }

}

extension ForecastClientTypes.ForecastSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdUsingAutoPredictor = "CreatedUsingAutoPredictor"
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case forecastArn = "ForecastArn"
        case forecastName = "ForecastName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdUsingAutoPredictor = self.createdUsingAutoPredictor {
            try encodeContainer.encode(createdUsingAutoPredictor, forKey: .createdUsingAutoPredictor)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let forecastArn = self.forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let forecastName = self.forecastName {
            try encodeContainer.encode(forecastName, forKey: .forecastName)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let forecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let createdUsingAutoPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createdUsingAutoPredictor)
        createdUsingAutoPredictor = createdUsingAutoPredictorDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the forecast properties used in the [ListForecasts] operation. To get the complete set of properties, call the [DescribeForecast] operation, and provide the ForecastArn that is listed in the summary.
    public struct ForecastSummary: Swift.Equatable {
        /// Whether the Forecast was created from an AutoPredictor.
        public var createdUsingAutoPredictor: Swift.Bool?
        /// When the forecast creation task was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that provided the data used to train the predictor.
        public var datasetGroupArn: Swift.String?
        /// The ARN of the forecast.
        public var forecastArn: Swift.String?
        /// The name of the forecast.
        public var forecastName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The ARN of the predictor used to generate the forecast.
        public var predictorArn: Swift.String?
        /// The status of the forecast. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the forecast must be ACTIVE before you can query or export the forecast.
        public var status: Swift.String?

        public init (
            createdUsingAutoPredictor: Swift.Bool? = nil,
            creationTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            forecastArn: Swift.String? = nil,
            forecastName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            predictorArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.createdUsingAutoPredictor = createdUsingAutoPredictor
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.forecastArn = forecastArn
            self.forecastName = forecastName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.status = status
        }
    }

}

extension GetAccuracyMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

extension GetAccuracyMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccuracyMetricsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor to get metrics for.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct GetAccuracyMetricsInputBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension GetAccuracyMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension GetAccuracyMetricsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccuracyMetricsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAccuracyMetricsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccuracyMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAccuracyMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoMLOverrideStrategy = output.autoMLOverrideStrategy
            self.isAutoPredictor = output.isAutoPredictor
            self.optimizationMetric = output.optimizationMetric
            self.predictorEvaluationResults = output.predictorEvaluationResults
        } else {
            self.autoMLOverrideStrategy = nil
            self.isAutoPredictor = nil
            self.optimizationMetric = nil
            self.predictorEvaluationResults = nil
        }
    }
}

public struct GetAccuracyMetricsOutputResponse: Swift.Equatable {
    /// The LatencyOptimized AutoML override strategy is only available in private beta. Contact AWS Support or your account manager to learn more about access privileges. The AutoML strategy used to train the predictor. Unless LatencyOptimized is specified, the AutoML strategy optimizes predictor accuracy. This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// Whether the predictor was created with [CreateAutoPredictor].
    public var isAutoPredictor: Swift.Bool?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// An array of results from evaluating the predictor.
    public var predictorEvaluationResults: [ForecastClientTypes.EvaluationResult]?

    public init (
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        isAutoPredictor: Swift.Bool? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        predictorEvaluationResults: [ForecastClientTypes.EvaluationResult]? = nil
    )
    {
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.isAutoPredictor = isAutoPredictor
        self.optimizationMetric = optimizationMetric
        self.predictorEvaluationResults = predictorEvaluationResults
    }
}

struct GetAccuracyMetricsOutputResponseBody: Swift.Equatable {
    let predictorEvaluationResults: [ForecastClientTypes.EvaluationResult]?
    let isAutoPredictor: Swift.Bool?
    let autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
}

extension GetAccuracyMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case isAutoPredictor = "IsAutoPredictor"
        case optimizationMetric = "OptimizationMetric"
        case predictorEvaluationResults = "PredictorEvaluationResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorEvaluationResultsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.EvaluationResult?].self, forKey: .predictorEvaluationResults)
        var predictorEvaluationResultsDecoded0:[ForecastClientTypes.EvaluationResult]? = nil
        if let predictorEvaluationResultsContainer = predictorEvaluationResultsContainer {
            predictorEvaluationResultsDecoded0 = [ForecastClientTypes.EvaluationResult]()
            for structure0 in predictorEvaluationResultsContainer {
                if let structure0 = structure0 {
                    predictorEvaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        predictorEvaluationResults = predictorEvaluationResultsDecoded0
        let isAutoPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAutoPredictor)
        isAutoPredictor = isAutoPredictorDecoded
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
    }
}

extension ForecastClientTypes.HyperParameterTuningJobConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterRanges = "ParameterRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterRanges = self.parameterRanges {
            try encodeContainer.encode(parameterRanges, forKey: .parameterRanges)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterRangesDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ParameterRanges.self, forKey: .parameterRanges)
        parameterRanges = parameterRangesDecoded
    }
}

extension ForecastClientTypes {
    /// Configuration information for a hyperparameter tuning job. You specify this object in the [CreatePredictor] request. A hyperparameter is a parameter that governs the model training process. You set hyperparameters before training starts, unlike model parameters, which are determined during training. The values of the hyperparameters effect which values are chosen for the model parameters. In a hyperparameter tuning job, Amazon Forecast chooses the set of hyperparameter values that optimize a specified metric. Forecast accomplishes this by running many training jobs over a range of hyperparameter values. The optimum set of values depends on the algorithm, the training data, and the specified metric objective.
    public struct HyperParameterTuningJobConfig: Swift.Equatable {
        /// Specifies the ranges of valid values for the hyperparameters.
        public var parameterRanges: ForecastClientTypes.ParameterRanges?

        public init (
            parameterRanges: ForecastClientTypes.ParameterRanges? = nil
        )
        {
            self.parameterRanges = parameterRanges
        }
    }

}

extension ForecastClientTypes.InputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
        case supplementaryFeatures = "SupplementaryFeatures"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let supplementaryFeatures = supplementaryFeatures {
            var supplementaryFeaturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supplementaryFeatures)
            for supplementaryfeature0 in supplementaryFeatures {
                try supplementaryFeaturesContainer.encode(supplementaryfeature0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let supplementaryFeaturesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.SupplementaryFeature?].self, forKey: .supplementaryFeatures)
        var supplementaryFeaturesDecoded0:[ForecastClientTypes.SupplementaryFeature]? = nil
        if let supplementaryFeaturesContainer = supplementaryFeaturesContainer {
            supplementaryFeaturesDecoded0 = [ForecastClientTypes.SupplementaryFeature]()
            for structure0 in supplementaryFeaturesContainer {
                if let structure0 = structure0 {
                    supplementaryFeaturesDecoded0?.append(structure0)
                }
            }
        }
        supplementaryFeatures = supplementaryFeaturesDecoded0
    }
}

extension ForecastClientTypes {
    /// This object belongs to the [CreatePredictor] operation. If you created your predictor with [CreateAutoPredictor], see [DataConfig]. The data used to train a predictor. The data includes a dataset group and any supplementary features. You specify this object in the [CreatePredictor] request.
    public struct InputDataConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the dataset group.
        /// This member is required.
        public var datasetGroupArn: Swift.String?
        /// An array of supplementary features. The only supported feature is a holiday calendar.
        public var supplementaryFeatures: [ForecastClientTypes.SupplementaryFeature]?

        public init (
            datasetGroupArn: Swift.String? = nil,
            supplementaryFeatures: [ForecastClientTypes.SupplementaryFeature]? = nil
        )
        {
            self.datasetGroupArn = datasetGroupArn
            self.supplementaryFeatures = supplementaryFeatures
        }
    }

}

extension ForecastClientTypes.IntegerParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxValue = "MaxValue"
        case minValue = "MinValue"
        case name = "Name"
        case scalingType = "ScalingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxValue = self.maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minValue = self.minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scalingType = self.scalingType {
            try encodeContainer.encode(scalingType.rawValue, forKey: .scalingType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minValue)
        minValue = minValueDecoded
        let scalingTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ScalingType.self, forKey: .scalingType)
        scalingType = scalingTypeDecoded
    }
}

extension ForecastClientTypes {
    /// Specifies an integer hyperparameter and it's range of tunable values. This object is part of the [ParameterRanges] object.
    public struct IntegerParameterRange: Swift.Equatable {
        /// The maximum tunable value of the hyperparameter.
        /// This member is required.
        public var maxValue: Swift.Int?
        /// The minimum tunable value of the hyperparameter.
        /// This member is required.
        public var minValue: Swift.Int?
        /// The name of the hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values: Auto Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter. Linear Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale. Logarithmic Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have values greater than 0. ReverseLogarithmic Not supported for IntegerParameterRange. Reverse logarithmic scaling works only for ranges that are entirely within the range 0 <= x < 1.0. For information about choosing a hyperparameter scale, see [Hyperparameter Scaling](http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type). One of the following values:
        public var scalingType: ForecastClientTypes.ScalingType?

        public init (
            maxValue: Swift.Int? = nil,
            minValue: Swift.Int? = nil,
            name: Swift.String? = nil,
            scalingType: ForecastClientTypes.ScalingType? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }
    }

}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// We can't process the request because it includes an invalid value or a value that exceeds the valid range.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The token is not valid. Tokens expire after 24 hours.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit on the number of resources per account has been exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDatasetGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetGroupsInput: Swift.Equatable {
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDatasetGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDatasetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroups = output.datasetGroups
            self.nextToken = output.nextToken
        } else {
            self.datasetGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetGroupsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each dataset group's properties.
    public var datasetGroups: [ForecastClientTypes.DatasetGroupSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        datasetGroups: [ForecastClientTypes.DatasetGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroups = datasetGroups
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsOutputResponseBody: Swift.Equatable {
    let datasetGroups: [ForecastClientTypes.DatasetGroupSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroups = "DatasetGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.DatasetGroupSummary?].self, forKey: .datasetGroups)
        var datasetGroupsDecoded0:[ForecastClientTypes.DatasetGroupSummary]? = nil
        if let datasetGroupsContainer = datasetGroupsContainer {
            datasetGroupsDecoded0 = [ForecastClientTypes.DatasetGroupSummary]()
            for structure0 in datasetGroupsContainer {
                if let structure0 = structure0 {
                    datasetGroupsDecoded0?.append(structure0)
                }
            }
        }
        datasetGroups = datasetGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatasetImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetImportJobsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the datasets that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the datasets that match the statement, specify IS. To exclude matching datasets, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are DatasetArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all dataset import jobs whose status is ACTIVE, you specify the following filter: "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListDatasetImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListDatasetImportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetImportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDatasetImportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetImportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDatasetImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJobs = output.datasetImportJobs
            self.nextToken = output.nextToken
        } else {
            self.datasetImportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetImportJobsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each dataset import job's properties.
    public var datasetImportJobs: [ForecastClientTypes.DatasetImportJobSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        datasetImportJobs: [ForecastClientTypes.DatasetImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetImportJobs = datasetImportJobs
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsOutputResponseBody: Swift.Equatable {
    let datasetImportJobs: [ForecastClientTypes.DatasetImportJobSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetImportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobs = "DatasetImportJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.DatasetImportJobSummary?].self, forKey: .datasetImportJobs)
        var datasetImportJobsDecoded0:[ForecastClientTypes.DatasetImportJobSummary]? = nil
        if let datasetImportJobsContainer = datasetImportJobsContainer {
            datasetImportJobsDecoded0 = [ForecastClientTypes.DatasetImportJobSummary]()
            for structure0 in datasetImportJobsContainer {
                if let structure0 = structure0 {
                    datasetImportJobsDecoded0?.append(structure0)
                }
            }
        }
        datasetImportJobs = datasetImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatasetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetsInput: Swift.Equatable {
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDatasetsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each dataset's properties.
    public var datasets: [ForecastClientTypes.DatasetSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        datasets: [ForecastClientTypes.DatasetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Swift.Equatable {
    let datasets: [ForecastClientTypes.DatasetSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasets = "Datasets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.DatasetSummary?].self, forKey: .datasets)
        var datasetsDecoded0:[ForecastClientTypes.DatasetSummary]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [ForecastClientTypes.DatasetSummary]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExplainabilitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListExplainabilitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListExplainabilitiesInput: Swift.Equatable {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the resources that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are ResourceArn and Status.
    ///
    /// * Value - The value to match.
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items returned in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExplainabilitiesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListExplainabilitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListExplainabilitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExplainabilitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListExplainabilitiesOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExplainabilitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListExplainabilitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.explainabilities = output.explainabilities
            self.nextToken = output.nextToken
        } else {
            self.explainabilities = nil
            self.nextToken = nil
        }
    }
}

public struct ListExplainabilitiesOutputResponse: Swift.Equatable {
    /// An array of objects that summarize the properties of each Explainability resource.
    public var explainabilities: [ForecastClientTypes.ExplainabilitySummary]?
    /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        explainabilities: [ForecastClientTypes.ExplainabilitySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.explainabilities = explainabilities
        self.nextToken = nextToken
    }
}

struct ListExplainabilitiesOutputResponseBody: Swift.Equatable {
    let explainabilities: [ForecastClientTypes.ExplainabilitySummary]?
    let nextToken: Swift.String?
}

extension ListExplainabilitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilities = "Explainabilities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilitiesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ExplainabilitySummary?].self, forKey: .explainabilities)
        var explainabilitiesDecoded0:[ForecastClientTypes.ExplainabilitySummary]? = nil
        if let explainabilitiesContainer = explainabilitiesContainer {
            explainabilitiesDecoded0 = [ForecastClientTypes.ExplainabilitySummary]()
            for structure0 in explainabilitiesContainer {
                if let structure0 = structure0 {
                    explainabilitiesDecoded0?.append(structure0)
                }
            }
        }
        explainabilities = explainabilitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExplainabilityExportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListExplainabilityExportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListExplainabilityExportsInput: Swift.Equatable {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude resources that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are ResourceArn and Status.
    ///
    /// * Value - The value to match.
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExplainabilityExportsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListExplainabilityExportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListExplainabilityExportsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExplainabilityExportsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListExplainabilityExportsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExplainabilityExportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListExplainabilityExportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.explainabilityExports = output.explainabilityExports
            self.nextToken = output.nextToken
        } else {
            self.explainabilityExports = nil
            self.nextToken = nil
        }
    }
}

public struct ListExplainabilityExportsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize the properties of each Explainability export.
    public var explainabilityExports: [ForecastClientTypes.ExplainabilityExportSummary]?
    /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        explainabilityExports: [ForecastClientTypes.ExplainabilityExportSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.explainabilityExports = explainabilityExports
        self.nextToken = nextToken
    }
}

struct ListExplainabilityExportsOutputResponseBody: Swift.Equatable {
    let explainabilityExports: [ForecastClientTypes.ExplainabilityExportSummary]?
    let nextToken: Swift.String?
}

extension ListExplainabilityExportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExports = "ExplainabilityExports"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ExplainabilityExportSummary?].self, forKey: .explainabilityExports)
        var explainabilityExportsDecoded0:[ForecastClientTypes.ExplainabilityExportSummary]? = nil
        if let explainabilityExportsContainer = explainabilityExportsContainer {
            explainabilityExportsDecoded0 = [ForecastClientTypes.ExplainabilityExportSummary]()
            for structure0 in explainabilityExportsContainer {
                if let structure0 = structure0 {
                    explainabilityExportsDecoded0?.append(structure0)
                }
            }
        }
        explainabilityExports = explainabilityExportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListForecastExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListForecastExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListForecastExportJobsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the forecast export jobs that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecast export jobs that match the statement, specify IS. To exclude matching forecast export jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are ForecastArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all jobs that export a forecast named electricityforecast, specify the following filter: "Filters": [ { "Condition": "IS", "Key": "ForecastArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityforecast" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListForecastExportJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListForecastExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListForecastExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListForecastExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListForecastExportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListForecastExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListForecastExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecastExportJobs = output.forecastExportJobs
            self.nextToken = output.nextToken
        } else {
            self.forecastExportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListForecastExportJobsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each export job's properties.
    public var forecastExportJobs: [ForecastClientTypes.ForecastExportJobSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        forecastExportJobs: [ForecastClientTypes.ForecastExportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.forecastExportJobs = forecastExportJobs
        self.nextToken = nextToken
    }
}

struct ListForecastExportJobsOutputResponseBody: Swift.Equatable {
    let forecastExportJobs: [ForecastClientTypes.ForecastExportJobSummary]?
    let nextToken: Swift.String?
}

extension ListForecastExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobs = "ForecastExportJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ForecastExportJobSummary?].self, forKey: .forecastExportJobs)
        var forecastExportJobsDecoded0:[ForecastClientTypes.ForecastExportJobSummary]? = nil
        if let forecastExportJobsContainer = forecastExportJobsContainer {
            forecastExportJobsDecoded0 = [ForecastClientTypes.ForecastExportJobSummary]()
            for structure0 in forecastExportJobsContainer {
                if let structure0 = structure0 {
                    forecastExportJobsDecoded0?.append(structure0)
                }
            }
        }
        forecastExportJobs = forecastExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListForecastsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListForecastsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListForecastsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the forecasts that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecasts that match the statement, specify IS. To exclude matching forecasts, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are DatasetGroupArn, PredictorArn, and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all forecasts whose status is not ACTIVE, you would specify: "Filters": [ { "Condition": "IS_NOT", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListForecastsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListForecastsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListForecastsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListForecastsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListForecastsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListForecastsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListForecastsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecasts = output.forecasts
            self.nextToken = output.nextToken
        } else {
            self.forecasts = nil
            self.nextToken = nil
        }
    }
}

public struct ListForecastsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each forecast's properties.
    public var forecasts: [ForecastClientTypes.ForecastSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        forecasts: [ForecastClientTypes.ForecastSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.forecasts = forecasts
        self.nextToken = nextToken
    }
}

struct ListForecastsOutputResponseBody: Swift.Equatable {
    let forecasts: [ForecastClientTypes.ForecastSummary]?
    let nextToken: Swift.String?
}

extension ListForecastsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecasts = "Forecasts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ForecastSummary?].self, forKey: .forecasts)
        var forecastsDecoded0:[ForecastClientTypes.ForecastSummary]? = nil
        if let forecastsContainer = forecastsContainer {
            forecastsDecoded0 = [ForecastClientTypes.ForecastSummary]()
            for structure0 in forecastsContainer {
                if let structure0 = structure0 {
                    forecastsDecoded0?.append(structure0)
                }
            }
        }
        forecasts = forecastsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMonitorEvaluationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMonitorEvaluationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMonitorEvaluationsInput: Swift.Equatable {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the resources that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. The only valid value is EvaluationState.
    ///
    /// * Value - The value to match. Valid values are only SUCCESS or FAILURE.
    ///
    ///
    /// For example, to list only successful monitor evaluations, you would specify: "Filters": [ { "Condition": "IS", "Key": "EvaluationState", "Value": "SUCCESS" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The maximum number of monitoring results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the monitor resource to get results from.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        monitorArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.monitorArn = monitorArn
        self.nextToken = nextToken
    }
}

struct ListMonitorEvaluationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let monitorArn: Swift.String?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListMonitorEvaluationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListMonitorEvaluationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMonitorEvaluationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMonitorEvaluationsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMonitorEvaluationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMonitorEvaluationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.predictorMonitorEvaluations = output.predictorMonitorEvaluations
        } else {
            self.nextToken = nil
            self.predictorMonitorEvaluations = nil
        }
    }
}

public struct ListMonitorEvaluationsOutputResponse: Swift.Equatable {
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?
    /// The monitoring results and predictor events collected by the monitor resource during different windows of time. For information about monitoring see [Viewing Monitoring Results](https://docs.aws.amazon.com/forecast/latest/dg/predictor-monitoring-results.html). For more information about retrieving monitoring results see [Viewing Monitoring Results](https://docs.aws.amazon.com/forecast/latest/dg/predictor-monitoring-results.html).
    public var predictorMonitorEvaluations: [ForecastClientTypes.PredictorMonitorEvaluation]?

    public init (
        nextToken: Swift.String? = nil,
        predictorMonitorEvaluations: [ForecastClientTypes.PredictorMonitorEvaluation]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictorMonitorEvaluations = predictorMonitorEvaluations
    }
}

struct ListMonitorEvaluationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let predictorMonitorEvaluations: [ForecastClientTypes.PredictorMonitorEvaluation]?
}

extension ListMonitorEvaluationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case predictorMonitorEvaluations = "PredictorMonitorEvaluations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let predictorMonitorEvaluationsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.PredictorMonitorEvaluation?].self, forKey: .predictorMonitorEvaluations)
        var predictorMonitorEvaluationsDecoded0:[ForecastClientTypes.PredictorMonitorEvaluation]? = nil
        if let predictorMonitorEvaluationsContainer = predictorMonitorEvaluationsContainer {
            predictorMonitorEvaluationsDecoded0 = [ForecastClientTypes.PredictorMonitorEvaluation]()
            for structure0 in predictorMonitorEvaluationsContainer {
                if let structure0 = structure0 {
                    predictorMonitorEvaluationsDecoded0?.append(structure0)
                }
            }
        }
        predictorMonitorEvaluations = predictorMonitorEvaluationsDecoded0
    }
}

extension ListMonitorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMonitorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMonitorsInput: Swift.Equatable {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the resources that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. The only valid value is Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all monitors who's status is ACTIVE, you would specify: "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The maximum number of monitors to include in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMonitorsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListMonitorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListMonitorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMonitorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMonitorsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMonitorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMonitorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.monitors = output.monitors
            self.nextToken = output.nextToken
        } else {
            self.monitors = nil
            self.nextToken = nil
        }
    }
}

public struct ListMonitorsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each monitor's properties.
    public var monitors: [ForecastClientTypes.MonitorSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        monitors: [ForecastClientTypes.MonitorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.monitors = monitors
        self.nextToken = nextToken
    }
}

struct ListMonitorsOutputResponseBody: Swift.Equatable {
    let monitors: [ForecastClientTypes.MonitorSummary]?
    let nextToken: Swift.String?
}

extension ListMonitorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitors = "Monitors"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.MonitorSummary?].self, forKey: .monitors)
        var monitorsDecoded0:[ForecastClientTypes.MonitorSummary]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [ForecastClientTypes.MonitorSummary]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPredictorBacktestExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPredictorBacktestExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPredictorBacktestExportJobsInput: Swift.Equatable {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the predictor backtest export jobs that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the predictor backtest export jobs that match the statement, specify IS. To exclude matching predictor backtest export jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are PredictorArn and Status.
    ///
    /// * Value - The value to match.
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPredictorBacktestExportJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListPredictorBacktestExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListPredictorBacktestExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPredictorBacktestExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPredictorBacktestExportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPredictorBacktestExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPredictorBacktestExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.predictorBacktestExportJobs = output.predictorBacktestExportJobs
        } else {
            self.nextToken = nil
            self.predictorBacktestExportJobs = nil
        }
    }
}

public struct ListPredictorBacktestExportJobsOutputResponse: Swift.Equatable {
    /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of objects that summarize the properties of each predictor backtest export job.
    public var predictorBacktestExportJobs: [ForecastClientTypes.PredictorBacktestExportJobSummary]?

    public init (
        nextToken: Swift.String? = nil,
        predictorBacktestExportJobs: [ForecastClientTypes.PredictorBacktestExportJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictorBacktestExportJobs = predictorBacktestExportJobs
    }
}

struct ListPredictorBacktestExportJobsOutputResponseBody: Swift.Equatable {
    let predictorBacktestExportJobs: [ForecastClientTypes.PredictorBacktestExportJobSummary]?
    let nextToken: Swift.String?
}

extension ListPredictorBacktestExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case predictorBacktestExportJobs = "PredictorBacktestExportJobs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.PredictorBacktestExportJobSummary?].self, forKey: .predictorBacktestExportJobs)
        var predictorBacktestExportJobsDecoded0:[ForecastClientTypes.PredictorBacktestExportJobSummary]? = nil
        if let predictorBacktestExportJobsContainer = predictorBacktestExportJobsContainer {
            predictorBacktestExportJobsDecoded0 = [ForecastClientTypes.PredictorBacktestExportJobSummary]()
            for structure0 in predictorBacktestExportJobsContainer {
                if let structure0 = structure0 {
                    predictorBacktestExportJobsDecoded0?.append(structure0)
                }
            }
        }
        predictorBacktestExportJobs = predictorBacktestExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPredictorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPredictorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPredictorsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the predictors that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the predictors that match the statement, specify IS. To exclude matching predictors, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are DatasetGroupArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all predictors whose status is ACTIVE, you would specify: "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPredictorsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListPredictorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListPredictorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPredictorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPredictorsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPredictorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPredictorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.predictors = output.predictors
        } else {
            self.nextToken = nil
            self.predictors = nil
        }
    }
}

public struct ListPredictorsOutputResponse: Swift.Equatable {
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of objects that summarize each predictor's properties.
    public var predictors: [ForecastClientTypes.PredictorSummary]?

    public init (
        nextToken: Swift.String? = nil,
        predictors: [ForecastClientTypes.PredictorSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictors = predictors
    }
}

struct ListPredictorsOutputResponseBody: Swift.Equatable {
    let predictors: [ForecastClientTypes.PredictorSummary]?
    let nextToken: Swift.String?
}

extension ListPredictorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case predictors = "Predictors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.PredictorSummary?].self, forKey: .predictors)
        var predictorsDecoded0:[ForecastClientTypes.PredictorSummary]? = nil
        if let predictorsContainer = predictorsContainer {
            predictorsDecoded0 = [ForecastClientTypes.PredictorSummary]()
            for structure0 in predictorsContainer {
                if let structure0 = structure0 {
                    predictorsDecoded0?.append(structure0)
                }
            }
        }
        predictors = predictorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [ForecastClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListWhatIfAnalysesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWhatIfAnalysesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWhatIfAnalysesInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the what-if analysis jobs that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the what-if analysis jobs that match the statement, specify IS. To exclude matching what-if analysis jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are WhatIfAnalysisArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all jobs that export a forecast named electricityWhatIf, specify the following filter: "Filters": [ { "Condition": "IS", "Key": "WhatIfAnalysisArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityWhatIf" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWhatIfAnalysesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListWhatIfAnalysesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWhatIfAnalysesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWhatIfAnalysesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWhatIfAnalysesOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWhatIfAnalysesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWhatIfAnalysesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.whatIfAnalyses = output.whatIfAnalyses
        } else {
            self.nextToken = nil
            self.whatIfAnalyses = nil
        }
    }
}

public struct ListWhatIfAnalysesOutputResponse: Swift.Equatable {
    /// If the response is truncated, Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of WhatIfAnalysisSummary objects that describe the matched analyses.
    public var whatIfAnalyses: [ForecastClientTypes.WhatIfAnalysisSummary]?

    public init (
        nextToken: Swift.String? = nil,
        whatIfAnalyses: [ForecastClientTypes.WhatIfAnalysisSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.whatIfAnalyses = whatIfAnalyses
    }
}

struct ListWhatIfAnalysesOutputResponseBody: Swift.Equatable {
    let whatIfAnalyses: [ForecastClientTypes.WhatIfAnalysisSummary]?
    let nextToken: Swift.String?
}

extension ListWhatIfAnalysesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case whatIfAnalyses = "WhatIfAnalyses"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfAnalysesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.WhatIfAnalysisSummary?].self, forKey: .whatIfAnalyses)
        var whatIfAnalysesDecoded0:[ForecastClientTypes.WhatIfAnalysisSummary]? = nil
        if let whatIfAnalysesContainer = whatIfAnalysesContainer {
            whatIfAnalysesDecoded0 = [ForecastClientTypes.WhatIfAnalysisSummary]()
            for structure0 in whatIfAnalysesContainer {
                if let structure0 = structure0 {
                    whatIfAnalysesDecoded0?.append(structure0)
                }
            }
        }
        whatIfAnalyses = whatIfAnalysesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWhatIfForecastExportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWhatIfForecastExportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWhatIfForecastExportsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the what-if forecast export jobs that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecast export jobs that match the statement, specify IS. To exclude matching forecast export jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are WhatIfForecastExportArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all jobs that export a forecast named electricityWIFExport, specify the following filter: "Filters": [ { "Condition": "IS", "Key": "WhatIfForecastExportArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityWIFExport" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next  request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWhatIfForecastExportsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListWhatIfForecastExportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWhatIfForecastExportsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWhatIfForecastExportsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWhatIfForecastExportsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWhatIfForecastExportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWhatIfForecastExportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.whatIfForecastExports = output.whatIfForecastExports
        } else {
            self.nextToken = nil
            self.whatIfForecastExports = nil
        }
    }
}

public struct ListWhatIfForecastExportsOutputResponse: Swift.Equatable {
    /// If the response is truncated, Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of WhatIfForecastExports objects that describe the matched forecast exports.
    public var whatIfForecastExports: [ForecastClientTypes.WhatIfForecastExportSummary]?

    public init (
        nextToken: Swift.String? = nil,
        whatIfForecastExports: [ForecastClientTypes.WhatIfForecastExportSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.whatIfForecastExports = whatIfForecastExports
    }
}

struct ListWhatIfForecastExportsOutputResponseBody: Swift.Equatable {
    let whatIfForecastExports: [ForecastClientTypes.WhatIfForecastExportSummary]?
    let nextToken: Swift.String?
}

extension ListWhatIfForecastExportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case whatIfForecastExports = "WhatIfForecastExports"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastExportsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.WhatIfForecastExportSummary?].self, forKey: .whatIfForecastExports)
        var whatIfForecastExportsDecoded0:[ForecastClientTypes.WhatIfForecastExportSummary]? = nil
        if let whatIfForecastExportsContainer = whatIfForecastExportsContainer {
            whatIfForecastExportsDecoded0 = [ForecastClientTypes.WhatIfForecastExportSummary]()
            for structure0 in whatIfForecastExportsContainer {
                if let structure0 = structure0 {
                    whatIfForecastExportsDecoded0?.append(structure0)
                }
            }
        }
        whatIfForecastExports = whatIfForecastExportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWhatIfForecastsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWhatIfForecastsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWhatIfForecastsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the what-if forecast export jobs that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecast export jobs that match the statement, specify IS. To exclude matching forecast export jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are WhatIfForecastArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all jobs that export a forecast named electricityWhatIfForecast, specify the following filter: "Filters": [ { "Condition": "IS", "Key": "WhatIfForecastArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityWhatIfForecast" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next  request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWhatIfForecastsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListWhatIfForecastsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWhatIfForecastsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWhatIfForecastsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWhatIfForecastsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWhatIfForecastsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWhatIfForecastsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.whatIfForecasts = output.whatIfForecasts
        } else {
            self.nextToken = nil
            self.whatIfForecasts = nil
        }
    }
}

public struct ListWhatIfForecastsOutputResponse: Swift.Equatable {
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next  request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?
    /// An array of WhatIfForecasts objects that describe the matched forecasts.
    public var whatIfForecasts: [ForecastClientTypes.WhatIfForecastSummary]?

    public init (
        nextToken: Swift.String? = nil,
        whatIfForecasts: [ForecastClientTypes.WhatIfForecastSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.whatIfForecasts = whatIfForecasts
    }
}

struct ListWhatIfForecastsOutputResponseBody: Swift.Equatable {
    let whatIfForecasts: [ForecastClientTypes.WhatIfForecastSummary]?
    let nextToken: Swift.String?
}

extension ListWhatIfForecastsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case whatIfForecasts = "WhatIfForecasts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.WhatIfForecastSummary?].self, forKey: .whatIfForecasts)
        var whatIfForecastsDecoded0:[ForecastClientTypes.WhatIfForecastSummary]? = nil
        if let whatIfForecastsContainer = whatIfForecastsContainer {
            whatIfForecastsDecoded0 = [ForecastClientTypes.WhatIfForecastSummary]()
            for structure0 in whatIfForecastsContainer {
                if let structure0 = structure0 {
                    whatIfForecastsDecoded0?.append(structure0)
                }
            }
        }
        whatIfForecasts = whatIfForecastsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ForecastClientTypes.MetricResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName = "MetricName"
        case metricValue = "MetricValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricValue = self.metricValue {
            try encodeContainer.encode(metricValue, forKey: .metricValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .metricValue)
        metricValue = metricValueDecoded
    }
}

extension ForecastClientTypes {
    /// An individual metric Forecast calculated when monitoring predictor usage. You can compare the value for this metric to the metric's value in the [Baseline] to see how your predictor's performance is changing. For more information about metrics generated by Forecast see [Evaluating Predictor Accuracy](https://docs.aws.amazon.com/forecast/latest/dg/metrics.html)
    public struct MetricResult: Swift.Equatable {
        /// The name of the metric.
        public var metricName: Swift.String?
        /// The value for the metric.
        public var metricValue: Swift.Double?

        public init (
            metricName: Swift.String? = nil,
            metricValue: Swift.Double? = nil
        )
        {
            self.metricName = metricName
            self.metricValue = metricValue
        }
    }

}

extension ForecastClientTypes.Metrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageWeightedQuantileLoss = "AverageWeightedQuantileLoss"
        case errorMetrics = "ErrorMetrics"
        case rmse = "RMSE"
        case weightedQuantileLosses = "WeightedQuantileLosses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let averageWeightedQuantileLoss = self.averageWeightedQuantileLoss {
            try encodeContainer.encode(averageWeightedQuantileLoss, forKey: .averageWeightedQuantileLoss)
        }
        if let errorMetrics = errorMetrics {
            var errorMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorMetrics)
            for errormetric0 in errorMetrics {
                try errorMetricsContainer.encode(errormetric0)
            }
        }
        if let rmse = self.rmse {
            try encodeContainer.encode(rmse, forKey: .rmse)
        }
        if let weightedQuantileLosses = weightedQuantileLosses {
            var weightedQuantileLossesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .weightedQuantileLosses)
            for weightedquantileloss0 in weightedQuantileLosses {
                try weightedQuantileLossesContainer.encode(weightedquantileloss0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rmseDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .rmse)
        rmse = rmseDecoded
        let weightedQuantileLossesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.WeightedQuantileLoss?].self, forKey: .weightedQuantileLosses)
        var weightedQuantileLossesDecoded0:[ForecastClientTypes.WeightedQuantileLoss]? = nil
        if let weightedQuantileLossesContainer = weightedQuantileLossesContainer {
            weightedQuantileLossesDecoded0 = [ForecastClientTypes.WeightedQuantileLoss]()
            for structure0 in weightedQuantileLossesContainer {
                if let structure0 = structure0 {
                    weightedQuantileLossesDecoded0?.append(structure0)
                }
            }
        }
        weightedQuantileLosses = weightedQuantileLossesDecoded0
        let errorMetricsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ErrorMetric?].self, forKey: .errorMetrics)
        var errorMetricsDecoded0:[ForecastClientTypes.ErrorMetric]? = nil
        if let errorMetricsContainer = errorMetricsContainer {
            errorMetricsDecoded0 = [ForecastClientTypes.ErrorMetric]()
            for structure0 in errorMetricsContainer {
                if let structure0 = structure0 {
                    errorMetricsDecoded0?.append(structure0)
                }
            }
        }
        errorMetrics = errorMetricsDecoded0
        let averageWeightedQuantileLossDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .averageWeightedQuantileLoss)
        averageWeightedQuantileLoss = averageWeightedQuantileLossDecoded
    }
}

extension ForecastClientTypes {
    /// Provides metrics that are used to evaluate the performance of a predictor. This object is part of the [WindowSummary] object.
    public struct Metrics: Swift.Equatable {
        /// The average value of all weighted quantile losses.
        public var averageWeightedQuantileLoss: Swift.Double?
        /// Provides detailed error metrics for each forecast type. Metrics include root-mean square-error (RMSE), mean absolute percentage error (MAPE), mean absolute scaled error (MASE), and weighted average percentage error (WAPE).
        public var errorMetrics: [ForecastClientTypes.ErrorMetric]?
        /// The root-mean-square error (RMSE).
        @available(*, deprecated, message: "This property is deprecated, please refer to ErrorMetrics for both RMSE and WAPE")
        public var rmse: Swift.Double?
        /// An array of weighted quantile losses. Quantiles divide a probability distribution into regions of equal probability. The distribution in this case is the loss function.
        public var weightedQuantileLosses: [ForecastClientTypes.WeightedQuantileLoss]?

        public init (
            averageWeightedQuantileLoss: Swift.Double? = nil,
            errorMetrics: [ForecastClientTypes.ErrorMetric]? = nil,
            rmse: Swift.Double? = nil,
            weightedQuantileLosses: [ForecastClientTypes.WeightedQuantileLoss]? = nil
        )
        {
            self.averageWeightedQuantileLoss = averageWeightedQuantileLoss
            self.errorMetrics = errorMetrics
            self.rmse = rmse
            self.weightedQuantileLosses = weightedQuantileLosses
        }
    }

}

extension ForecastClientTypes.MonitorConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorName = "MonitorName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorName = self.monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
    }
}

extension ForecastClientTypes {
    /// The configuration details for the predictor monitor.
    public struct MonitorConfig: Swift.Equatable {
        /// The name of the monitor resource.
        /// This member is required.
        public var monitorName: Swift.String?

        public init (
            monitorName: Swift.String? = nil
        )
        {
            self.monitorName = monitorName
        }
    }

}

extension ForecastClientTypes.MonitorDataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
        case forecastArn = "ForecastArn"
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = self.datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let forecastArn = self.forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension ForecastClientTypes {
    /// The source of the data the monitor used during the evaluation.
    public struct MonitorDataSource: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the dataset import job used to import the data that initiated the monitor evaluation.
        public var datasetImportJobArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the forecast the monitor used during the evaluation.
        public var forecastArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the predictor resource you are monitoring.
        public var predictorArn: Swift.String?

        public init (
            datasetImportJobArn: Swift.String? = nil,
            forecastArn: Swift.String? = nil,
            predictorArn: Swift.String? = nil
        )
        {
            self.datasetImportJobArn = datasetImportJobArn
            self.forecastArn = forecastArn
            self.predictorArn = predictorArn
        }
    }

}

extension ForecastClientTypes.MonitorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ForecastClientTypes {
    /// Provides information about the monitor resource.
    public struct MonitorInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the monitor resource.
        public var monitorArn: Swift.String?
        /// The status of the monitor. States include:
        ///
        /// * ACTIVE
        ///
        /// * ACTIVE_STOPPING, ACTIVE_STOPPED
        ///
        /// * UPDATE_IN_PROGRESS
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init (
            monitorArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.monitorArn = monitorArn
            self.status = status
        }
    }

}

extension ForecastClientTypes.MonitorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
        case monitorArn = "MonitorArn"
        case monitorName = "MonitorName"
        case resourceArn = "ResourceArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let monitorName = self.monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the monitor properties used in the [ListMonitors] operation. To get a complete set of properties, call the [DescribeMonitor] operation, and provide the listed MonitorArn.
    public struct MonitorSummary: Swift.Equatable {
        /// When the monitor resource was created.
        public var creationTime: ClientRuntime.Date?
        /// The last time the monitor resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * STOPPED - When the resource stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the monitor creation finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the monitor resource.
        public var monitorArn: Swift.String?
        /// The name of the monitor resource.
        public var monitorName: Swift.String?
        /// The Amazon Resource Name (ARN) of the predictor being monitored.
        public var resourceArn: Swift.String?
        /// The status of the monitor. States include:
        ///
        /// * ACTIVE
        ///
        /// * ACTIVE_STOPPING, ACTIVE_STOPPED
        ///
        /// * UPDATE_IN_PROGRESS
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            monitorArn: Swift.String? = nil,
            monitorName: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.resourceArn = resourceArn
            self.status = status
        }
    }

}

extension ForecastClientTypes {
    public enum Month: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case april
        case august
        case december
        case february
        case january
        case july
        case june
        case march
        case may
        case november
        case october
        case september
        case sdkUnknown(Swift.String)

        public static var allCases: [Month] {
            return [
                .april,
                .august,
                .december,
                .february,
                .january,
                .july,
                .june,
                .march,
                .may,
                .november,
                .october,
                .september,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .april: return "APRIL"
            case .august: return "AUGUST"
            case .december: return "DECEMBER"
            case .february: return "FEBRUARY"
            case .january: return "JANUARY"
            case .july: return "JULY"
            case .june: return "JUNE"
            case .march: return "MARCH"
            case .may: return "MAY"
            case .november: return "NOVEMBER"
            case .october: return "OCTOBER"
            case .september: return "SEPTEMBER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Month(rawValue: rawValue) ?? Month.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes {
    public enum Operation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case divide
        case multiply
        case subtract
        case sdkUnknown(Swift.String)

        public static var allCases: [Operation] {
            return [
                .add,
                .divide,
                .multiply,
                .subtract,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .divide: return "DIVIDE"
            case .multiply: return "MULTIPLY"
            case .subtract: return "SUBTRACT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operation(rawValue: rawValue) ?? Operation.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes {
    public enum OptimizationMetric: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case averageweightedquantileloss
        case mape
        case mase
        case rmse
        case wape
        case sdkUnknown(Swift.String)

        public static var allCases: [OptimizationMetric] {
            return [
                .averageweightedquantileloss,
                .mape,
                .mase,
                .rmse,
                .wape,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .averageweightedquantileloss: return "AverageWeightedQuantileLoss"
            case .mape: return "MAPE"
            case .mase: return "MASE"
            case .rmse: return "RMSE"
            case .wape: return "WAPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OptimizationMetric(rawValue: rawValue) ?? OptimizationMetric.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.ParameterRanges: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoricalParameterRanges = "CategoricalParameterRanges"
        case continuousParameterRanges = "ContinuousParameterRanges"
        case integerParameterRanges = "IntegerParameterRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalParameterRanges = categoricalParameterRanges {
            var categoricalParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoricalParameterRanges)
            for categoricalparameterrange0 in categoricalParameterRanges {
                try categoricalParameterRangesContainer.encode(categoricalparameterrange0)
            }
        }
        if let continuousParameterRanges = continuousParameterRanges {
            var continuousParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .continuousParameterRanges)
            for continuousparameterrange0 in continuousParameterRanges {
                try continuousParameterRangesContainer.encode(continuousparameterrange0)
            }
        }
        if let integerParameterRanges = integerParameterRanges {
            var integerParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerParameterRanges)
            for integerparameterrange0 in integerParameterRanges {
                try integerParameterRangesContainer.encode(integerparameterrange0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoricalParameterRangesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.CategoricalParameterRange?].self, forKey: .categoricalParameterRanges)
        var categoricalParameterRangesDecoded0:[ForecastClientTypes.CategoricalParameterRange]? = nil
        if let categoricalParameterRangesContainer = categoricalParameterRangesContainer {
            categoricalParameterRangesDecoded0 = [ForecastClientTypes.CategoricalParameterRange]()
            for structure0 in categoricalParameterRangesContainer {
                if let structure0 = structure0 {
                    categoricalParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        categoricalParameterRanges = categoricalParameterRangesDecoded0
        let continuousParameterRangesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ContinuousParameterRange?].self, forKey: .continuousParameterRanges)
        var continuousParameterRangesDecoded0:[ForecastClientTypes.ContinuousParameterRange]? = nil
        if let continuousParameterRangesContainer = continuousParameterRangesContainer {
            continuousParameterRangesDecoded0 = [ForecastClientTypes.ContinuousParameterRange]()
            for structure0 in continuousParameterRangesContainer {
                if let structure0 = structure0 {
                    continuousParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        continuousParameterRanges = continuousParameterRangesDecoded0
        let integerParameterRangesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.IntegerParameterRange?].self, forKey: .integerParameterRanges)
        var integerParameterRangesDecoded0:[ForecastClientTypes.IntegerParameterRange]? = nil
        if let integerParameterRangesContainer = integerParameterRangesContainer {
            integerParameterRangesDecoded0 = [ForecastClientTypes.IntegerParameterRange]()
            for structure0 in integerParameterRangesContainer {
                if let structure0 = structure0 {
                    integerParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        integerParameterRanges = integerParameterRangesDecoded0
    }
}

extension ForecastClientTypes {
    /// Specifies the categorical, continuous, and integer hyperparameters, and their ranges of tunable values. The range of tunable values determines which values that a hyperparameter tuning job can choose for the specified hyperparameter. This object is part of the [HyperParameterTuningJobConfig] object.
    public struct ParameterRanges: Swift.Equatable {
        /// Specifies the tunable range for each categorical hyperparameter.
        public var categoricalParameterRanges: [ForecastClientTypes.CategoricalParameterRange]?
        /// Specifies the tunable range for each continuous hyperparameter.
        public var continuousParameterRanges: [ForecastClientTypes.ContinuousParameterRange]?
        /// Specifies the tunable range for each integer hyperparameter.
        public var integerParameterRanges: [ForecastClientTypes.IntegerParameterRange]?

        public init (
            categoricalParameterRanges: [ForecastClientTypes.CategoricalParameterRange]? = nil,
            continuousParameterRanges: [ForecastClientTypes.ContinuousParameterRange]? = nil,
            integerParameterRanges: [ForecastClientTypes.IntegerParameterRange]? = nil
        )
        {
            self.categoricalParameterRanges = categoricalParameterRanges
            self.continuousParameterRanges = continuousParameterRanges
            self.integerParameterRanges = integerParameterRanges
        }
    }

}

extension ForecastClientTypes.PredictorBacktestExportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorBacktestExportJobArn = self.predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
        if let predictorBacktestExportJobName = self.predictorBacktestExportJobName {
            try encodeContainer.encode(predictorBacktestExportJobName, forKey: .predictorBacktestExportJobName)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the predictor backtest export job properties used in the [ListPredictorBacktestExportJobs] operation. To get a complete set of properties, call the [DescribePredictorBacktestExportJob] operation, and provide the listed PredictorBacktestExportJobArn.
    public struct PredictorBacktestExportJobSummary: Swift.Equatable {
        /// When the predictor backtest export job was created.
        public var creationTime: ClientRuntime.Date?
        /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
        public var destination: ForecastClientTypes.DataDestination?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// Information about any errors that may have occurred during the backtest export.
        public var message: Swift.String?
        /// The Amazon Resource Name (ARN) of the predictor backtest export job.
        public var predictorBacktestExportJobArn: Swift.String?
        /// The name of the predictor backtest export job.
        public var predictorBacktestExportJobName: Swift.String?
        /// The status of the predictor backtest export job. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            predictorBacktestExportJobArn: Swift.String? = nil,
            predictorBacktestExportJobName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
            self.predictorBacktestExportJobName = predictorBacktestExportJobName
            self.status = status
        }
    }

}

extension ForecastClientTypes.PredictorBaseline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineMetrics = "BaselineMetrics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineMetrics = baselineMetrics {
            var baselineMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .baselineMetrics)
            for baselinemetric0 in baselineMetrics {
                try baselineMetricsContainer.encode(baselinemetric0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineMetricsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.BaselineMetric?].self, forKey: .baselineMetrics)
        var baselineMetricsDecoded0:[ForecastClientTypes.BaselineMetric]? = nil
        if let baselineMetricsContainer = baselineMetricsContainer {
            baselineMetricsDecoded0 = [ForecastClientTypes.BaselineMetric]()
            for structure0 in baselineMetricsContainer {
                if let structure0 = structure0 {
                    baselineMetricsDecoded0?.append(structure0)
                }
            }
        }
        baselineMetrics = baselineMetricsDecoded0
    }
}

extension ForecastClientTypes {
    /// Metrics you can use as a baseline for comparison purposes. Use these metrics when you interpret monitoring results for an auto predictor.
    public struct PredictorBaseline: Swift.Equatable {
        /// The initial [accuracy metrics](https://docs.aws.amazon.com/forecast/latest/dg/metrics.html) for the predictor. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.
        public var baselineMetrics: [ForecastClientTypes.BaselineMetric]?

        public init (
            baselineMetrics: [ForecastClientTypes.BaselineMetric]? = nil
        )
        {
            self.baselineMetrics = baselineMetrics
        }
    }

}

extension ForecastClientTypes.PredictorEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datetime = "Datetime"
        case detail = "Detail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datetime = self.datetime {
            try encodeContainer.encodeTimestamp(datetime, format: .epochSeconds, forKey: .datetime)
        }
        if let detail = self.detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detail)
        detail = detailDecoded
        let datetimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .datetime)
        datetime = datetimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides details about a predictor event, such as a retraining.
    public struct PredictorEvent: Swift.Equatable {
        /// The timestamp for when the event occurred.
        public var datetime: ClientRuntime.Date?
        /// The type of event. For example, Retrain. A retraining event denotes the timepoint when a predictor was retrained. Any monitor results from before the Datetime are from the previous predictor. Any new metrics are for the newly retrained predictor.
        public var detail: Swift.String?

        public init (
            datetime: ClientRuntime.Date? = nil,
            detail: Swift.String? = nil
        )
        {
            self.datetime = datetime
            self.detail = detail
        }
    }

}

extension ForecastClientTypes.PredictorExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case testWindows = "TestWindows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = self.algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let testWindows = testWindows {
            var testWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .testWindows)
            for testwindowsummary0 in testWindows {
                try testWindowsContainer.encode(testwindowsummary0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let testWindowsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.TestWindowSummary?].self, forKey: .testWindows)
        var testWindowsDecoded0:[ForecastClientTypes.TestWindowSummary]? = nil
        if let testWindowsContainer = testWindowsContainer {
            testWindowsDecoded0 = [ForecastClientTypes.TestWindowSummary]()
            for structure0 in testWindowsContainer {
                if let structure0 = structure0 {
                    testWindowsDecoded0?.append(structure0)
                }
            }
        }
        testWindows = testWindowsDecoded0
    }
}

extension ForecastClientTypes {
    /// The algorithm used to perform a backtest and the status of those tests.
    public struct PredictorExecution: Swift.Equatable {
        /// The ARN of the algorithm used to test the predictor.
        public var algorithmArn: Swift.String?
        /// An array of test windows used to evaluate the algorithm. The NumberOfBacktestWindows from the object determines the number of windows in the array.
        public var testWindows: [ForecastClientTypes.TestWindowSummary]?

        public init (
            algorithmArn: Swift.String? = nil,
            testWindows: [ForecastClientTypes.TestWindowSummary]? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }
    }

}

extension ForecastClientTypes.PredictorExecutionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorExecutions = "PredictorExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorExecutions = predictorExecutions {
            var predictorExecutionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predictorExecutions)
            for predictorexecution0 in predictorExecutions {
                try predictorExecutionsContainer.encode(predictorexecution0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorExecutionsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.PredictorExecution?].self, forKey: .predictorExecutions)
        var predictorExecutionsDecoded0:[ForecastClientTypes.PredictorExecution]? = nil
        if let predictorExecutionsContainer = predictorExecutionsContainer {
            predictorExecutionsDecoded0 = [ForecastClientTypes.PredictorExecution]()
            for structure0 in predictorExecutionsContainer {
                if let structure0 = structure0 {
                    predictorExecutionsDecoded0?.append(structure0)
                }
            }
        }
        predictorExecutions = predictorExecutionsDecoded0
    }
}

extension ForecastClientTypes {
    /// Contains details on the backtests performed to evaluate the accuracy of the predictor. The tests are returned in descending order of accuracy, with the most accurate backtest appearing first. You specify the number of backtests to perform when you call the operation.
    public struct PredictorExecutionDetails: Swift.Equatable {
        /// An array of the backtests performed to evaluate the accuracy of the predictor against a particular algorithm. The NumberOfBacktestWindows from the object determines the number of windows in the array.
        public var predictorExecutions: [ForecastClientTypes.PredictorExecution]?

        public init (
            predictorExecutions: [ForecastClientTypes.PredictorExecution]? = nil
        )
        {
            self.predictorExecutions = predictorExecutions
        }
    }

}

extension ForecastClientTypes.PredictorMonitorEvaluation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationState = "EvaluationState"
        case evaluationTime = "EvaluationTime"
        case message = "Message"
        case metricResults = "MetricResults"
        case monitorArn = "MonitorArn"
        case monitorDataSource = "MonitorDataSource"
        case numItemsEvaluated = "NumItemsEvaluated"
        case predictorEvent = "PredictorEvent"
        case resourceArn = "ResourceArn"
        case windowEndDatetime = "WindowEndDatetime"
        case windowStartDatetime = "WindowStartDatetime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationState = self.evaluationState {
            try encodeContainer.encode(evaluationState, forKey: .evaluationState)
        }
        if let evaluationTime = self.evaluationTime {
            try encodeContainer.encodeTimestamp(evaluationTime, format: .epochSeconds, forKey: .evaluationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let metricResults = metricResults {
            var metricResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricResults)
            for metricresult0 in metricResults {
                try metricResultsContainer.encode(metricresult0)
            }
        }
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let monitorDataSource = self.monitorDataSource {
            try encodeContainer.encode(monitorDataSource, forKey: .monitorDataSource)
        }
        if let numItemsEvaluated = self.numItemsEvaluated {
            try encodeContainer.encode(numItemsEvaluated, forKey: .numItemsEvaluated)
        }
        if let predictorEvent = self.predictorEvent {
            try encodeContainer.encode(predictorEvent, forKey: .predictorEvent)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let windowEndDatetime = self.windowEndDatetime {
            try encodeContainer.encodeTimestamp(windowEndDatetime, format: .epochSeconds, forKey: .windowEndDatetime)
        }
        if let windowStartDatetime = self.windowStartDatetime {
            try encodeContainer.encodeTimestamp(windowStartDatetime, format: .epochSeconds, forKey: .windowStartDatetime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let evaluationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .evaluationTime)
        evaluationTime = evaluationTimeDecoded
        let evaluationStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationState)
        evaluationState = evaluationStateDecoded
        let windowStartDatetimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .windowStartDatetime)
        windowStartDatetime = windowStartDatetimeDecoded
        let windowEndDatetimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .windowEndDatetime)
        windowEndDatetime = windowEndDatetimeDecoded
        let predictorEventDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.PredictorEvent.self, forKey: .predictorEvent)
        predictorEvent = predictorEventDecoded
        let monitorDataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.MonitorDataSource.self, forKey: .monitorDataSource)
        monitorDataSource = monitorDataSourceDecoded
        let metricResultsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.MetricResult?].self, forKey: .metricResults)
        var metricResultsDecoded0:[ForecastClientTypes.MetricResult]? = nil
        if let metricResultsContainer = metricResultsContainer {
            metricResultsDecoded0 = [ForecastClientTypes.MetricResult]()
            for structure0 in metricResultsContainer {
                if let structure0 = structure0 {
                    metricResultsDecoded0?.append(structure0)
                }
            }
        }
        metricResults = metricResultsDecoded0
        let numItemsEvaluatedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numItemsEvaluated)
        numItemsEvaluated = numItemsEvaluatedDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ForecastClientTypes {
    /// Describes the results of a monitor evaluation.
    public struct PredictorMonitorEvaluation: Swift.Equatable {
        /// The status of the monitor evaluation. The state can be SUCCESS or FAILURE.
        public var evaluationState: Swift.String?
        /// The timestamp that indicates when the monitor evaluation was started.
        public var evaluationTime: ClientRuntime.Date?
        /// Information about any errors that may have occurred during the monitor evaluation.
        public var message: Swift.String?
        /// A list of metrics Forecast calculated when monitoring a predictor. You can compare the value for each metric in the list to the metric's value in the [Baseline] to see how your predictor's performance is changing.
        public var metricResults: [ForecastClientTypes.MetricResult]?
        /// The Amazon Resource Name (ARN) of the monitor resource.
        public var monitorArn: Swift.String?
        /// The source of the data the monitor resource used during the evaluation.
        public var monitorDataSource: ForecastClientTypes.MonitorDataSource?
        /// The number of items considered during the evaluation.
        public var numItemsEvaluated: Swift.Int?
        /// Provides details about a predictor event, such as a retraining.
        public var predictorEvent: ForecastClientTypes.PredictorEvent?
        /// The Amazon Resource Name (ARN) of the resource to monitor.
        public var resourceArn: Swift.String?
        /// The timestamp that indicates the end of the window that is used for monitor evaluation.
        public var windowEndDatetime: ClientRuntime.Date?
        /// The timestamp that indicates the start of the window that is used for monitor evaluation.
        public var windowStartDatetime: ClientRuntime.Date?

        public init (
            evaluationState: Swift.String? = nil,
            evaluationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            metricResults: [ForecastClientTypes.MetricResult]? = nil,
            monitorArn: Swift.String? = nil,
            monitorDataSource: ForecastClientTypes.MonitorDataSource? = nil,
            numItemsEvaluated: Swift.Int? = nil,
            predictorEvent: ForecastClientTypes.PredictorEvent? = nil,
            resourceArn: Swift.String? = nil,
            windowEndDatetime: ClientRuntime.Date? = nil,
            windowStartDatetime: ClientRuntime.Date? = nil
        )
        {
            self.evaluationState = evaluationState
            self.evaluationTime = evaluationTime
            self.message = message
            self.metricResults = metricResults
            self.monitorArn = monitorArn
            self.monitorDataSource = monitorDataSource
            self.numItemsEvaluated = numItemsEvaluated
            self.predictorEvent = predictorEvent
            self.resourceArn = resourceArn
            self.windowEndDatetime = windowEndDatetime
            self.windowStartDatetime = windowStartDatetime
        }
    }

}

extension ForecastClientTypes.PredictorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case isAutoPredictor = "IsAutoPredictor"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case predictorName = "PredictorName"
        case referencePredictorSummary = "ReferencePredictorSummary"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let isAutoPredictor = self.isAutoPredictor {
            try encodeContainer.encode(isAutoPredictor, forKey: .isAutoPredictor)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorArn = self.predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let predictorName = self.predictorName {
            try encodeContainer.encode(predictorName, forKey: .predictorName)
        }
        if let referencePredictorSummary = self.referencePredictorSummary {
            try encodeContainer.encode(referencePredictorSummary, forKey: .referencePredictorSummary)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let isAutoPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAutoPredictor)
        isAutoPredictor = isAutoPredictorDecoded
        let referencePredictorSummaryDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ReferencePredictorSummary.self, forKey: .referencePredictorSummary)
        referencePredictorSummary = referencePredictorSummaryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the predictor properties that are used in the [ListPredictors] operation. To get the complete set of properties, call the [DescribePredictor] operation, and provide the listed PredictorArn.
    public struct PredictorSummary: Swift.Equatable {
        /// When the model training task was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that contains the data used to train the predictor.
        public var datasetGroupArn: Swift.String?
        /// Whether AutoPredictor was used to create the predictor.
        public var isAutoPredictor: Swift.Bool?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The ARN of the predictor.
        public var predictorArn: Swift.String?
        /// The name of the predictor.
        public var predictorName: Swift.String?
        /// A summary of the reference predictor used if the predictor was retrained or upgraded.
        public var referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary?
        /// The status of the predictor. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        ///
        /// The Status of the predictor must be ACTIVE before you can use the predictor to create a forecast.
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            isAutoPredictor: Swift.Bool? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            predictorArn: Swift.String? = nil,
            predictorName: Swift.String? = nil,
            referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.isAutoPredictor = isAutoPredictor
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.predictorName = predictorName
            self.referencePredictorSummary = referencePredictorSummary
            self.status = status
        }
    }

}

extension ForecastClientTypes.ReferencePredictorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the reference predictor used when retraining or upgrading a predictor.
    public struct ReferencePredictorSummary: Swift.Equatable {
        /// The ARN of the reference predictor.
        public var arn: Swift.String?
        /// Whether the reference predictor is Active or Deleted.
        public var state: ForecastClientTypes.State?

        public init (
            arn: Swift.String? = nil,
            state: ForecastClientTypes.State? = nil
        )
        {
            self.arn = arn
            self.state = state
        }
    }

}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is already a resource with this name. Try again with a different name.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource is in use.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// We can't find a resource with that Amazon Resource Name (ARN). Check the ARN and try again.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResumeResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ResumeResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResumeResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the monitor resource to resume.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ResumeResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ResumeResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResumeResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResumeResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ResumeResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResumeResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ResumeResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ForecastClientTypes.S3Config: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn = "KMSKeyArn"
        case path = "Path"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension ForecastClientTypes {
    /// The path to the file(s) in an Amazon Simple Storage Service (Amazon S3) bucket, and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the file(s). Optionally, includes an AWS Key Management Service (KMS) key. This object is part of the [DataSource] object that is submitted in the [CreateDatasetImportJob] request, and part of the [DataDestination] object.
    public struct S3Config: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key.
        public var kmsKeyArn: Swift.String?
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket or file(s) in an Amazon S3 bucket.
        /// This member is required.
        public var path: Swift.String?
        /// The ARN of the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the Amazon S3 bucket or files. If you provide a value for the KMSKeyArn key, the role must allow access to the key. Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an InvalidInputException error.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            kmsKeyArn: Swift.String? = nil,
            path: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.path = path
            self.roleArn = roleArn
        }
    }

}

extension ForecastClientTypes {
    public enum ScalingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case linear
        case logarithmic
        case reverselogarithmic
        case sdkUnknown(Swift.String)

        public static var allCases: [ScalingType] {
            return [
                .auto,
                .linear,
                .logarithmic,
                .reverselogarithmic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "Auto"
            case .linear: return "Linear"
            case .logarithmic: return "Logarithmic"
            case .reverselogarithmic: return "ReverseLogarithmic"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScalingType(rawValue: rawValue) ?? ScalingType.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.Schema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for schemaattribute0 in attributes {
                try attributesContainer.encode(schemaattribute0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.SchemaAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[ForecastClientTypes.SchemaAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ForecastClientTypes.SchemaAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ForecastClientTypes {
    /// Defines the fields of a dataset.
    public struct Schema: Swift.Equatable {
        /// An array of attributes specifying the name and type of each field in a dataset.
        public var attributes: [ForecastClientTypes.SchemaAttribute]?

        public init (
            attributes: [ForecastClientTypes.SchemaAttribute]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

extension ForecastClientTypes.SchemaAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeType = "AttributeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let attributeType = self.attributeType {
            try encodeContainer.encode(attributeType.rawValue, forKey: .attributeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AttributeType.self, forKey: .attributeType)
        attributeType = attributeTypeDecoded
    }
}

extension ForecastClientTypes {
    /// An attribute of a schema, which defines a dataset field. A schema attribute is required for every field in a dataset. The [Schema](https://docs.aws.amazon.com/forecast/latest/dg/API_Schema.html) object contains an array of SchemaAttribute objects.
    public struct SchemaAttribute: Swift.Equatable {
        /// The name of the dataset field.
        public var attributeName: Swift.String?
        /// The data type of the field. For a related time series dataset, other than date, item_id, and forecast dimensions attributes, all attributes should be of numerical type (integer/float).
        public var attributeType: ForecastClientTypes.AttributeType?

        public init (
            attributeName: Swift.String? = nil,
            attributeType: ForecastClientTypes.AttributeType? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeType = attributeType
        }
    }

}

extension ForecastClientTypes {
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .deleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleted: return "Deleted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.Statistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avg = "Avg"
        case count = "Count"
        case countDistinct = "CountDistinct"
        case countDistinctLong = "CountDistinctLong"
        case countLong = "CountLong"
        case countNan = "CountNan"
        case countNanLong = "CountNanLong"
        case countNull = "CountNull"
        case countNullLong = "CountNullLong"
        case max = "Max"
        case min = "Min"
        case stddev = "Stddev"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let avg = self.avg {
            try encodeContainer.encode(avg, forKey: .avg)
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let countDistinct = self.countDistinct {
            try encodeContainer.encode(countDistinct, forKey: .countDistinct)
        }
        if let countDistinctLong = self.countDistinctLong {
            try encodeContainer.encode(countDistinctLong, forKey: .countDistinctLong)
        }
        if let countLong = self.countLong {
            try encodeContainer.encode(countLong, forKey: .countLong)
        }
        if let countNan = self.countNan {
            try encodeContainer.encode(countNan, forKey: .countNan)
        }
        if let countNanLong = self.countNanLong {
            try encodeContainer.encode(countNanLong, forKey: .countNanLong)
        }
        if let countNull = self.countNull {
            try encodeContainer.encode(countNull, forKey: .countNull)
        }
        if let countNullLong = self.countNullLong {
            try encodeContainer.encode(countNullLong, forKey: .countNullLong)
        }
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
        if let stddev = self.stddev {
            try encodeContainer.encode(stddev, forKey: .stddev)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let countDistinctDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countDistinct)
        countDistinct = countDistinctDecoded
        let countNullDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNull)
        countNull = countNullDecoded
        let countNanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNan)
        countNan = countNanDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .max)
        max = maxDecoded
        let avgDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .avg)
        avg = avgDecoded
        let stddevDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .stddev)
        stddev = stddevDecoded
        let countLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countLong)
        countLong = countLongDecoded
        let countDistinctLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countDistinctLong)
        countDistinctLong = countDistinctLongDecoded
        let countNullLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNullLong)
        countNullLong = countNullLongDecoded
        let countNanLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNanLong)
        countNanLong = countNanLongDecoded
    }
}

extension ForecastClientTypes {
    /// Provides statistics for each data field imported into to an Amazon Forecast dataset with the [CreateDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html) operation.
    public struct Statistics: Swift.Equatable {
        /// For a numeric field, the average value in the field.
        public var avg: Swift.Double?
        /// The number of values in the field. If the response value is -1, refer to CountLong.
        public var count: Swift.Int?
        /// The number of distinct values in the field. If the response value is -1, refer to CountDistinctLong.
        public var countDistinct: Swift.Int?
        /// The number of distinct values in the field. CountDistinctLong is used instead of CountDistinct if the value is greater than 2,147,483,647.
        public var countDistinctLong: Swift.Int?
        /// The number of values in the field. CountLong is used instead of Count if the value is greater than 2,147,483,647.
        public var countLong: Swift.Int?
        /// The number of NAN (not a number) values in the field. If the response value is -1, refer to CountNanLong.
        public var countNan: Swift.Int?
        /// The number of NAN (not a number) values in the field. CountNanLong is used instead of CountNan if the value is greater than 2,147,483,647.
        public var countNanLong: Swift.Int?
        /// The number of null values in the field. If the response value is -1, refer to CountNullLong.
        public var countNull: Swift.Int?
        /// The number of null values in the field. CountNullLong is used instead of CountNull if the value is greater than 2,147,483,647.
        public var countNullLong: Swift.Int?
        /// For a numeric field, the maximum value in the field.
        public var max: Swift.String?
        /// For a numeric field, the minimum value in the field.
        public var min: Swift.String?
        /// For a numeric field, the standard deviation.
        public var stddev: Swift.Double?

        public init (
            avg: Swift.Double? = nil,
            count: Swift.Int? = nil,
            countDistinct: Swift.Int? = nil,
            countDistinctLong: Swift.Int? = nil,
            countLong: Swift.Int? = nil,
            countNan: Swift.Int? = nil,
            countNanLong: Swift.Int? = nil,
            countNull: Swift.Int? = nil,
            countNullLong: Swift.Int? = nil,
            max: Swift.String? = nil,
            min: Swift.String? = nil,
            stddev: Swift.Double? = nil
        )
        {
            self.avg = avg
            self.count = count
            self.countDistinct = countDistinct
            self.countDistinctLong = countDistinctLong
            self.countLong = countLong
            self.countNan = countNan
            self.countNanLong = countNanLong
            self.countNull = countNull
            self.countNullLong = countNullLong
            self.max = max
            self.min = min
            self.stddev = stddev
        }
    }

}

extension StopResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension StopResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource to stop. The supported ARNs are DatasetImportJobArn, PredictorArn, PredictorBacktestExportJobArn, ForecastArn, ForecastExportJobArn, ExplainabilityArn, and ExplainabilityExportArn.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct StopResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension StopResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension StopResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ForecastClientTypes.SupplementaryFeature: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ForecastClientTypes {
    /// This object belongs to the [CreatePredictor] operation. If you created your predictor with [CreateAutoPredictor], see [AdditionalDataset]. Describes a supplementary feature of a dataset group. This object is part of the [InputDataConfig] object. Forecast supports the Weather Index and Holidays built-in featurizations. Weather Index The Amazon Forecast Weather Index is a built-in featurization that incorporates historical and projected weather information into your model. The Weather Index supplements your datasets with over two years of historical weather data and up to 14 days of projected weather data. For more information, see [Amazon Forecast Weather Index](https://docs.aws.amazon.com/forecast/latest/dg/weather.html). Holidays Holidays is a built-in featurization that incorporates a feature-engineered dataset of national holiday information into your model. It provides native support for the holiday calendars of 66 countries. To view the holiday calendars, refer to the [Jollyday](http://jollyday.sourceforge.net/data.html) library. For more information, see [Holidays Featurization](https://docs.aws.amazon.com/forecast/latest/dg/holidays.html).
    public struct SupplementaryFeature: Swift.Equatable {
        /// The name of the feature. Valid values: "holiday" and "weather".
        /// This member is required.
        public var name: Swift.String?
        /// Weather Index To enable the Weather Index, set the value to "true" Holidays To enable Holidays, specify a country with one of the following two-letter country codes:
        ///
        /// * "AL" - ALBANIA
        ///
        /// * "AR" - ARGENTINA
        ///
        /// * "AT" - AUSTRIA
        ///
        /// * "AU" - AUSTRALIA
        ///
        /// * "BA" - BOSNIA HERZEGOVINA
        ///
        /// * "BE" - BELGIUM
        ///
        /// * "BG" - BULGARIA
        ///
        /// * "BO" - BOLIVIA
        ///
        /// * "BR" - BRAZIL
        ///
        /// * "BY" - BELARUS
        ///
        /// * "CA" - CANADA
        ///
        /// * "CL" - CHILE
        ///
        /// * "CO" - COLOMBIA
        ///
        /// * "CR" - COSTA RICA
        ///
        /// * "HR" - CROATIA
        ///
        /// * "CZ" - CZECH REPUBLIC
        ///
        /// * "DK" - DENMARK
        ///
        /// * "EC" - ECUADOR
        ///
        /// * "EE" - ESTONIA
        ///
        /// * "ET" - ETHIOPIA
        ///
        /// * "FI" - FINLAND
        ///
        /// * "FR" - FRANCE
        ///
        /// * "DE" - GERMANY
        ///
        /// * "GR" - GREECE
        ///
        /// * "HU" - HUNGARY
        ///
        /// * "IS" - ICELAND
        ///
        /// * "IN" - INDIA
        ///
        /// * "IE" - IRELAND
        ///
        /// * "IT" - ITALY
        ///
        /// * "JP" - JAPAN
        ///
        /// * "KZ" - KAZAKHSTAN
        ///
        /// * "KR" - KOREA
        ///
        /// * "LV" - LATVIA
        ///
        /// * "LI" - LIECHTENSTEIN
        ///
        /// * "LT" - LITHUANIA
        ///
        /// * "LU" - LUXEMBOURG
        ///
        /// * "MK" - MACEDONIA
        ///
        /// * "MT" - MALTA
        ///
        /// * "MX" - MEXICO
        ///
        /// * "MD" - MOLDOVA
        ///
        /// * "ME" - MONTENEGRO
        ///
        /// * "NL" - NETHERLANDS
        ///
        /// * "NZ" - NEW ZEALAND
        ///
        /// * "NI" - NICARAGUA
        ///
        /// * "NG" - NIGERIA
        ///
        /// * "NO" - NORWAY
        ///
        /// * "PA" - PANAMA
        ///
        /// * "PY" - PARAGUAY
        ///
        /// * "PE" - PERU
        ///
        /// * "PL" - POLAND
        ///
        /// * "PT" - PORTUGAL
        ///
        /// * "RO" - ROMANIA
        ///
        /// * "RU" - RUSSIA
        ///
        /// * "RS" - SERBIA
        ///
        /// * "SK" - SLOVAKIA
        ///
        /// * "SI" - SLOVENIA
        ///
        /// * "ZA" - SOUTH AFRICA
        ///
        /// * "ES" - SPAIN
        ///
        /// * "SE" - SWEDEN
        ///
        /// * "CH" - SWITZERLAND
        ///
        /// * "UA" - UKRAINE
        ///
        /// * "AE" - UNITED ARAB EMIRATES
        ///
        /// * "US" - UNITED STATES
        ///
        /// * "UK" - UNITED KINGDOM
        ///
        /// * "UY" - URUGUAY
        ///
        /// * "VE" - VENEZUELA
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ForecastClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ForecastClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension ForecastClientTypes {
    /// The optional metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.
        /// This member is required.
        public var key: Swift.String?
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor within a tag category (key).
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    /// This member is required.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [ForecastClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ForecastClientTypes.TestWindowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case status = "Status"
        case testWindowEnd = "TestWindowEnd"
        case testWindowStart = "TestWindowStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let testWindowEnd = self.testWindowEnd {
            try encodeContainer.encodeTimestamp(testWindowEnd, format: .epochSeconds, forKey: .testWindowEnd)
        }
        if let testWindowStart = self.testWindowStart {
            try encodeContainer.encodeTimestamp(testWindowStart, format: .epochSeconds, forKey: .testWindowStart)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testWindowStartDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .testWindowStart)
        testWindowStart = testWindowStartDecoded
        let testWindowEndDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .testWindowEnd)
        testWindowEnd = testWindowEndDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ForecastClientTypes {
    /// The status, start time, and end time of a backtest, as well as a failure reason if applicable.
    public struct TestWindowSummary: Swift.Equatable {
        /// If the test failed, the reason why it failed.
        public var message: Swift.String?
        /// The status of the test. Possible status values are:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_IN_PROGRESS
        ///
        /// * CREATE_FAILED
        public var status: Swift.String?
        /// The time at which the test ended.
        public var testWindowEnd: ClientRuntime.Date?
        /// The time at which the test began.
        public var testWindowStart: ClientRuntime.Date?

        public init (
            message: Swift.String? = nil,
            status: Swift.String? = nil,
            testWindowEnd: ClientRuntime.Date? = nil,
            testWindowStart: ClientRuntime.Date? = nil
        )
        {
            self.message = message
            self.status = status
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }
    }

}

extension ForecastClientTypes.TimeAlignmentBoundary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case hour = "Hour"
        case month = "Month"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = self.dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = self.dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
        if let hour = self.hour {
            try encodeContainer.encode(hour, forKey: .hour)
        }
        if let month = self.month {
            try encodeContainer.encode(month.rawValue, forKey: .month)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Month.self, forKey: .month)
        month = monthDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let hourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hour)
        hour = hourDecoded
    }
}

extension ForecastClientTypes {
    /// The time boundary Forecast uses to align and aggregate your data to match your forecast frequency. Provide the unit of time and the time boundary as a key value pair. If you don't provide a time boundary, Forecast uses a set of [Default Time Boundaries](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html#default-time-boundaries). For more information about aggregation, see [Data Aggregation for Different Forecast Frequencies](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html). For more information setting a custom time boundary, see [Specifying a Time Boundary](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html#specifying-time-boundary).
    public struct TimeAlignmentBoundary: Swift.Equatable {
        /// The day of the month to use for time alignment during aggregation.
        public var dayOfMonth: Swift.Int?
        /// The day of week to use for time alignment during aggregation. The day must be in uppercase.
        public var dayOfWeek: ForecastClientTypes.DayOfWeek?
        /// The hour of day to use for time alignment during aggregation.
        public var hour: Swift.Int?
        /// The month to use for time alignment during aggregation. The month must be in uppercase.
        public var month: ForecastClientTypes.Month?

        public init (
            dayOfMonth: Swift.Int? = nil,
            dayOfWeek: ForecastClientTypes.DayOfWeek? = nil,
            hour: Swift.Int? = nil,
            month: ForecastClientTypes.Month? = nil
        )
        {
            self.dayOfMonth = dayOfMonth
            self.dayOfWeek = dayOfWeek
            self.hour = hour
            self.month = month
        }
    }

}

extension ForecastClientTypes {
    public enum TimePointGranularity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case specific
        case sdkUnknown(Swift.String)

        public static var allCases: [TimePointGranularity] {
            return [
                .all,
                .specific,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .specific: return "SPECIFIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimePointGranularity(rawValue: rawValue) ?? TimePointGranularity.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.TimeSeriesCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
        case condition = "Condition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let attributeValue = self.attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
        if let condition = self.condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Condition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ForecastClientTypes {
    /// Creates a subset of items within an attribute that are modified. For example, you can use this operation to create a subset of items that cost $5 or less. To do this, you specify "AttributeName": "price", "AttributeValue": "5", and "Condition": "LESS_THAN". Pair this operation with the [Action] operation within the [CreateWhatIfForecastRequest$TimeSeriesTransformations] operation to define how the attribute is modified.
    public struct TimeSeriesCondition: Swift.Equatable {
        /// The item_id, dimension name, IM name, or timestamp that you are modifying.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The value that is applied for the chosen Condition.
        /// This member is required.
        public var attributeValue: Swift.String?
        /// The condition to apply. Valid values are EQUALS, NOT_EQUALS, LESS_THAN and GREATER_THAN.
        /// This member is required.
        public var condition: ForecastClientTypes.Condition?

        public init (
            attributeName: Swift.String? = nil,
            attributeValue: Swift.String? = nil,
            condition: ForecastClientTypes.Condition? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
            self.condition = condition
        }
    }

}

extension ForecastClientTypes {
    public enum TimeSeriesGranularity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case specific
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeSeriesGranularity] {
            return [
                .all,
                .specific,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .specific: return "SPECIFIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeSeriesGranularity(rawValue: rawValue) ?? TimeSeriesGranularity.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.TimeSeriesIdentifiers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case format = "Format"
        case schema = "Schema"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension ForecastClientTypes {
    /// Details about the import file that contains the time series for which you want to create forecasts.
    public struct TimeSeriesIdentifiers: Swift.Equatable {
        /// The source of your data, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an AWS Key Management Service (KMS) key.
        public var dataSource: ForecastClientTypes.DataSource?
        /// The format of the data, either CSV or PARQUET.
        public var format: Swift.String?
        /// Defines the fields of a dataset.
        public var schema: ForecastClientTypes.Schema?

        public init (
            dataSource: ForecastClientTypes.DataSource? = nil,
            format: Swift.String? = nil,
            schema: ForecastClientTypes.Schema? = nil
        )
        {
            self.dataSource = dataSource
            self.format = format
            self.schema = schema
        }
    }

}

extension ForecastClientTypes.TimeSeriesReplacementsDataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case s3Config = "S3Config"
        case schema = "Schema"
        case timestampFormat = "TimestampFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let s3Config = self.s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let timestampFormat = self.timestampFormat {
            try encodeContainer.encode(timestampFormat, forKey: .timestampFormat)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let timestampFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampFormat)
        timestampFormat = timestampFormatDecoded
    }
}

extension ForecastClientTypes {
    /// A replacement dataset is a modified version of the baseline related time series that contains only the values that you want to include in a what-if forecast. The replacement dataset must contain the forecast dimensions and item identifiers in the baseline related time series as well as at least 1 changed time series. This dataset is merged with the baseline related time series to create a transformed dataset that is used for the what-if forecast.
    public struct TimeSeriesReplacementsDataSource: Swift.Equatable {
        /// The format of the replacement data, CSV or PARQUET.
        public var format: Swift.String?
        /// The path to the file(s) in an Amazon Simple Storage Service (Amazon S3) bucket, and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the file(s). Optionally, includes an AWS Key Management Service (KMS) key. This object is part of the [DataSource] object that is submitted in the [CreateDatasetImportJob] request, and part of the [DataDestination] object.
        /// This member is required.
        public var s3Config: ForecastClientTypes.S3Config?
        /// Defines the fields of a dataset.
        /// This member is required.
        public var schema: ForecastClientTypes.Schema?
        /// The timestamp format of the replacement data.
        public var timestampFormat: Swift.String?

        public init (
            format: Swift.String? = nil,
            s3Config: ForecastClientTypes.S3Config? = nil,
            schema: ForecastClientTypes.Schema? = nil,
            timestampFormat: Swift.String? = nil
        )
        {
            self.format = format
            self.s3Config = s3Config
            self.schema = schema
            self.timestampFormat = timestampFormat
        }
    }

}

extension ForecastClientTypes.TimeSeriesSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeSeriesIdentifiers = "TimeSeriesIdentifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeSeriesIdentifiers = self.timeSeriesIdentifiers {
            try encodeContainer.encode(timeSeriesIdentifiers, forKey: .timeSeriesIdentifiers)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesIdentifiersDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesIdentifiers.self, forKey: .timeSeriesIdentifiers)
        timeSeriesIdentifiers = timeSeriesIdentifiersDecoded
    }
}

extension ForecastClientTypes {
    /// Defines the set of time series that are used to create the forecasts in a TimeSeriesIdentifiers object. The TimeSeriesIdentifiers object needs the following information:
    ///
    /// * DataSource
    ///
    /// * Format
    ///
    /// * Schema
    public struct TimeSeriesSelector: Swift.Equatable {
        /// Details about the import file that contains the time series for which you want to create forecasts.
        public var timeSeriesIdentifiers: ForecastClientTypes.TimeSeriesIdentifiers?

        public init (
            timeSeriesIdentifiers: ForecastClientTypes.TimeSeriesIdentifiers? = nil
        )
        {
            self.timeSeriesIdentifiers = timeSeriesIdentifiers
        }
    }

}

extension ForecastClientTypes.TimeSeriesTransformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case timeSeriesConditions = "TimeSeriesConditions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let timeSeriesConditions = timeSeriesConditions {
            var timeSeriesConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timeSeriesConditions)
            for timeseriescondition0 in timeSeriesConditions {
                try timeSeriesConditionsContainer.encode(timeseriescondition0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let timeSeriesConditionsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.TimeSeriesCondition?].self, forKey: .timeSeriesConditions)
        var timeSeriesConditionsDecoded0:[ForecastClientTypes.TimeSeriesCondition]? = nil
        if let timeSeriesConditionsContainer = timeSeriesConditionsContainer {
            timeSeriesConditionsDecoded0 = [ForecastClientTypes.TimeSeriesCondition]()
            for structure0 in timeSeriesConditionsContainer {
                if let structure0 = structure0 {
                    timeSeriesConditionsDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesConditions = timeSeriesConditionsDecoded0
    }
}

extension ForecastClientTypes {
    /// A transformation function is a pair of operations that select and modify the rows in a related time series. You select the rows that you want with a condition operation and you modify the rows with a transformation operation. All conditions are joined with an AND operation, meaning that all conditions must be true for the transformation to be applied. Transformations are applied in the order that they are listed.
    public struct TimeSeriesTransformation: Swift.Equatable {
        /// An array of actions that define a time series and how it is transformed. These transformations create a new time series that is used for the what-if analysis.
        public var action: ForecastClientTypes.Action?
        /// An array of conditions that define which members of the related time series are transformed.
        public var timeSeriesConditions: [ForecastClientTypes.TimeSeriesCondition]?

        public init (
            action: ForecastClientTypes.Action? = nil,
            timeSeriesConditions: [ForecastClientTypes.TimeSeriesCondition]? = nil
        )
        {
            self.action = action
            self.timeSeriesConditions = timeSeriesConditions
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArns = datasetArns {
            var datasetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasetArns)
            for arn0 in datasetArns {
                try datasetArnsContainer.encode(arn0)
            }
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

extension UpdateDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDatasetGroupInput: Swift.Equatable {
    /// An array of the Amazon Resource Names (ARNs) of the datasets to add to the dataset group.
    /// This member is required.
    public var datasetArns: [Swift.String]?
    /// The ARN of the dataset group.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetArns: [Swift.String]? = nil,
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetArns = datasetArns
        self.datasetGroupArn = datasetGroupArn
    }
}

struct UpdateDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let datasetArns: [Swift.String]?
}

extension UpdateDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[Swift.String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [Swift.String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
    }
}

extension UpdateDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDatasetGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension ForecastClientTypes.WeightedQuantileLoss: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lossValue = "LossValue"
        case quantile = "Quantile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lossValue = self.lossValue {
            try encodeContainer.encode(lossValue, forKey: .lossValue)
        }
        if let quantile = self.quantile {
            try encodeContainer.encode(quantile, forKey: .quantile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantileDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .quantile)
        quantile = quantileDecoded
        let lossValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lossValue)
        lossValue = lossValueDecoded
    }
}

extension ForecastClientTypes {
    /// The weighted loss value for a quantile. This object is part of the [Metrics] object.
    public struct WeightedQuantileLoss: Swift.Equatable {
        /// The difference between the predicted value and the actual value over the quantile, weighted (normalized) by dividing by the sum over all quantiles.
        public var lossValue: Swift.Double?
        /// The quantile. Quantiles divide a probability distribution into regions of equal probability. For example, if the distribution was divided into 5 regions of equal probability, the quantiles would be 0.2, 0.4, 0.6, and 0.8.
        public var quantile: Swift.Double?

        public init (
            lossValue: Swift.Double? = nil,
            quantile: Swift.Double? = nil
        )
        {
            self.lossValue = lossValue
            self.quantile = quantile
        }
    }

}

extension ForecastClientTypes.WhatIfAnalysisSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case forecastArn = "ForecastArn"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
        case whatIfAnalysisName = "WhatIfAnalysisName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let forecastArn = self.forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let whatIfAnalysisArn = self.whatIfAnalysisArn {
            try encodeContainer.encode(whatIfAnalysisArn, forKey: .whatIfAnalysisArn)
        }
        if let whatIfAnalysisName = self.whatIfAnalysisName {
            try encodeContainer.encode(whatIfAnalysisName, forKey: .whatIfAnalysisName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
        let whatIfAnalysisNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisName)
        whatIfAnalysisName = whatIfAnalysisNameDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the what-if analysis properties used in the [ListWhatIfAnalyses] operation. To get the complete set of properties, call the [DescribeWhatIfAnalysis] operation, and provide the WhatIfAnalysisArn that is listed in the summary.
    public struct WhatIfAnalysisSummary: Swift.Equatable {
        /// When the what-if analysis was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the baseline forecast that is being used in this what-if analysis.
        public var forecastArn: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the what-if analysis. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the what-if analysis must be ACTIVE before you can access the analysis.
        public var status: Swift.String?
        /// The Amazon Resource Name (ARN) of the what-if analysis.
        public var whatIfAnalysisArn: Swift.String?
        /// The name of the what-if analysis.
        public var whatIfAnalysisName: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            forecastArn: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil,
            whatIfAnalysisArn: Swift.String? = nil,
            whatIfAnalysisName: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.forecastArn = forecastArn
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.whatIfAnalysisArn = whatIfAnalysisArn
            self.whatIfAnalysisName = whatIfAnalysisName
        }
    }

}

extension ForecastClientTypes.WhatIfForecastExportSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case whatIfForecastArns = "WhatIfForecastArns"
        case whatIfForecastExportArn = "WhatIfForecastExportArn"
        case whatIfForecastExportName = "WhatIfForecastExportName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let whatIfForecastArns = whatIfForecastArns {
            var whatIfForecastArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .whatIfForecastArns)
            for longarn0 in whatIfForecastArns {
                try whatIfForecastArnsContainer.encode(longarn0)
            }
        }
        if let whatIfForecastExportArn = self.whatIfForecastExportArn {
            try encodeContainer.encode(whatIfForecastExportArn, forKey: .whatIfForecastExportArn)
        }
        if let whatIfForecastExportName = self.whatIfForecastExportName {
            try encodeContainer.encode(whatIfForecastExportName, forKey: .whatIfForecastExportName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportArn)
        whatIfForecastExportArn = whatIfForecastExportArnDecoded
        let whatIfForecastArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whatIfForecastArns)
        var whatIfForecastArnsDecoded0:[Swift.String]? = nil
        if let whatIfForecastArnsContainer = whatIfForecastArnsContainer {
            whatIfForecastArnsDecoded0 = [Swift.String]()
            for string0 in whatIfForecastArnsContainer {
                if let string0 = string0 {
                    whatIfForecastArnsDecoded0?.append(string0)
                }
            }
        }
        whatIfForecastArns = whatIfForecastArnsDecoded0
        let whatIfForecastExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastExportName)
        whatIfForecastExportName = whatIfForecastExportNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the what-if forecast export properties used in the [ListWhatIfForecastExports] operation. To get the complete set of properties, call the [DescribeWhatIfForecastExport] operation, and provide the WhatIfForecastExportArn that is listed in the summary.
    public struct WhatIfForecastExportSummary: Swift.Equatable {
        /// When the what-if forecast export was created.
        public var creationTime: ClientRuntime.Date?
        /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
        public var destination: ForecastClientTypes.DataDestination?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the what-if forecast export. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the what-if analysis must be ACTIVE before you can access the analysis.
        public var status: Swift.String?
        /// An array of Amazon Resource Names (ARNs) that define the what-if forecasts included in the export.
        public var whatIfForecastArns: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the what-if forecast export.
        public var whatIfForecastExportArn: Swift.String?
        /// The what-if forecast export name.
        public var whatIfForecastExportName: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil,
            whatIfForecastArns: [Swift.String]? = nil,
            whatIfForecastExportArn: Swift.String? = nil,
            whatIfForecastExportName: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.whatIfForecastArns = whatIfForecastArns
            self.whatIfForecastExportArn = whatIfForecastExportArn
            self.whatIfForecastExportName = whatIfForecastExportName
        }
    }

}

extension ForecastClientTypes.WhatIfForecastSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case whatIfAnalysisArn = "WhatIfAnalysisArn"
        case whatIfForecastArn = "WhatIfForecastArn"
        case whatIfForecastName = "WhatIfForecastName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let whatIfAnalysisArn = self.whatIfAnalysisArn {
            try encodeContainer.encode(whatIfAnalysisArn, forKey: .whatIfAnalysisArn)
        }
        if let whatIfForecastArn = self.whatIfForecastArn {
            try encodeContainer.encode(whatIfForecastArn, forKey: .whatIfForecastArn)
        }
        if let whatIfForecastName = self.whatIfForecastName {
            try encodeContainer.encode(whatIfForecastName, forKey: .whatIfForecastName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfForecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastArn)
        whatIfForecastArn = whatIfForecastArnDecoded
        let whatIfForecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfForecastName)
        whatIfForecastName = whatIfForecastNameDecoded
        let whatIfAnalysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whatIfAnalysisArn)
        whatIfAnalysisArn = whatIfAnalysisArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the what-if forecast properties used in the [ListWhatIfForecasts] operation. To get the complete set of properties, call the [DescribeWhatIfForecast] operation, and provide the WhatIfForecastArn that is listed in the summary.
    public struct WhatIfForecastSummary: Swift.Equatable {
        /// When the what-if forecast was created.
        public var creationTime: ClientRuntime.Date?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the what-if forecast. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the what-if analysis must be ACTIVE before you can access the analysis.
        public var status: Swift.String?
        /// The Amazon Resource Name (ARN) of the what-if analysis that contains this what-if forecast.
        public var whatIfAnalysisArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the what-if forecast.
        public var whatIfForecastArn: Swift.String?
        /// The name of the what-if forecast.
        public var whatIfForecastName: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil,
            whatIfAnalysisArn: Swift.String? = nil,
            whatIfForecastArn: Swift.String? = nil,
            whatIfForecastName: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.whatIfAnalysisArn = whatIfAnalysisArn
            self.whatIfForecastArn = whatIfForecastArn
            self.whatIfForecastName = whatIfForecastName
        }
    }

}

extension ForecastClientTypes.WindowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationType = "EvaluationType"
        case itemCount = "ItemCount"
        case metrics = "Metrics"
        case testWindowEnd = "TestWindowEnd"
        case testWindowStart = "TestWindowStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationType = self.evaluationType {
            try encodeContainer.encode(evaluationType.rawValue, forKey: .evaluationType)
        }
        if let itemCount = self.itemCount {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let metrics = self.metrics {
            try encodeContainer.encode(metrics, forKey: .metrics)
        }
        if let testWindowEnd = self.testWindowEnd {
            try encodeContainer.encodeTimestamp(testWindowEnd, format: .epochSeconds, forKey: .testWindowEnd)
        }
        if let testWindowStart = self.testWindowStart {
            try encodeContainer.encodeTimestamp(testWindowStart, format: .epochSeconds, forKey: .testWindowStart)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testWindowStartDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .testWindowStart)
        testWindowStart = testWindowStartDecoded
        let testWindowEndDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .testWindowEnd)
        testWindowEnd = testWindowEndDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let evaluationTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EvaluationType.self, forKey: .evaluationType)
        evaluationType = evaluationTypeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Metrics.self, forKey: .metrics)
        metrics = metricsDecoded
    }
}

extension ForecastClientTypes {
    /// The metrics for a time range within the evaluation portion of a dataset. This object is part of the [EvaluationResult] object. The TestWindowStart and TestWindowEnd parameters are determined by the BackTestWindowOffset parameter of the [EvaluationParameters] object.
    public struct WindowSummary: Swift.Equatable {
        /// The type of evaluation.
        ///
        /// * SUMMARY - The average metrics across all windows.
        ///
        /// * COMPUTED - The metrics for the specified window.
        public var evaluationType: ForecastClientTypes.EvaluationType?
        /// The number of data points within the window.
        public var itemCount: Swift.Int?
        /// Provides metrics used to evaluate the performance of a predictor.
        public var metrics: ForecastClientTypes.Metrics?
        /// The timestamp that defines the end of the window.
        public var testWindowEnd: ClientRuntime.Date?
        /// The timestamp that defines the start of the window.
        public var testWindowStart: ClientRuntime.Date?

        public init (
            evaluationType: ForecastClientTypes.EvaluationType? = nil,
            itemCount: Swift.Int? = nil,
            metrics: ForecastClientTypes.Metrics? = nil,
            testWindowEnd: ClientRuntime.Date? = nil,
            testWindowStart: ClientRuntime.Date? = nil
        )
        {
            self.evaluationType = evaluationType
            self.itemCount = itemCount
            self.metrics = metrics
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }
    }

}
