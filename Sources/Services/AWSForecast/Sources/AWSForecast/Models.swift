//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

public struct DeleteDatasetGroupOutput {

    public init() { }
}

public struct DeleteDatasetImportJobOutput {

    public init() { }
}

public struct DeleteDatasetOutput {

    public init() { }
}

public struct DeleteExplainabilityExportOutput {

    public init() { }
}

public struct DeleteExplainabilityOutput {

    public init() { }
}

public struct DeleteForecastExportJobOutput {

    public init() { }
}

public struct DeleteForecastOutput {

    public init() { }
}

public struct DeleteMonitorOutput {

    public init() { }
}

public struct DeletePredictorBacktestExportJobOutput {

    public init() { }
}

public struct DeletePredictorOutput {

    public init() { }
}

public struct DeleteResourceTreeOutput {

    public init() { }
}

public struct DeleteWhatIfAnalysisOutput {

    public init() { }
}

public struct DeleteWhatIfForecastExportOutput {

    public init() { }
}

public struct DeleteWhatIfForecastOutput {

    public init() { }
}

public struct ResumeResourceOutput {

    public init() { }
}

public struct StopResourceOutput {

    public init() { }
}

extension ForecastClientTypes {

    public enum Operation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case add
        case divide
        case multiply
        case subtract
        case sdkUnknown(Swift.String)

        public static var allCases: [Operation] {
            return [
                .add,
                .divide,
                .multiply,
                .subtract
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .divide: return "DIVIDE"
            case .multiply: return "MULTIPLY"
            case .subtract: return "SUBTRACT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {
    /// Defines the modifications that you are making to an attribute for a what-if forecast. For example, you can use this operation to create a what-if forecast that investigates a 10% off sale on all shoes. To do this, you specify "AttributeName": "shoes", "Operation": "MULTIPLY", and "Value": "0.90". Pair this operation with the [TimeSeriesCondition] operation within the [CreateWhatIfForecastRequest$TimeSeriesTransformations] operation to define a subset of attribute items that are modified.
    public struct Action {
        /// The related time series that you are modifying. This value is case insensitive.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The operation that is applied to the provided attribute. Operations include:
        ///
        /// * ADD - adds Value to all rows of AttributeName.
        ///
        /// * SUBTRACT - subtracts Value from all rows of AttributeName.
        ///
        /// * MULTIPLY - multiplies all rows of AttributeName by Value.
        ///
        /// * DIVIDE - divides all rows of AttributeName by Value.
        /// This member is required.
        public var operation: ForecastClientTypes.Operation?
        /// The value that is applied for the chosen Operation.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            attributeName: Swift.String? = nil,
            operation: ForecastClientTypes.Operation? = nil,
            value: Swift.Double? = nil
        )
        {
            self.attributeName = attributeName
            self.operation = operation
            self.value = value
        }
    }

}

extension ForecastClientTypes {
    /// Describes an additional dataset. This object is part of the [DataConfig] object. Forecast supports the Weather Index and Holidays additional datasets. Weather Index The Amazon Forecast Weather Index is a built-in dataset that incorporates historical and projected weather information into your model. The Weather Index supplements your datasets with over two years of historical weather data and up to 14 days of projected weather data. For more information, see [Amazon Forecast Weather Index](https://docs.aws.amazon.com/forecast/latest/dg/weather.html). Holidays Holidays is a built-in dataset that incorporates national holiday information into your model. It provides native support for the holiday calendars of 66 countries. To view the holiday calendars, refer to the [Jollyday](http://jollyday.sourceforge.net/data.html) library. For more information, see [Holidays Featurization](https://docs.aws.amazon.com/forecast/latest/dg/holidays.html).
    public struct AdditionalDataset {
        /// Weather Index To enable the Weather Index, do not specify a value for Configuration. Holidays Holidays To enable Holidays, set CountryCode to one of the following two-letter country codes:
        ///
        /// * "AL" - ALBANIA
        ///
        /// * "AR" - ARGENTINA
        ///
        /// * "AT" - AUSTRIA
        ///
        /// * "AU" - AUSTRALIA
        ///
        /// * "BA" - BOSNIA HERZEGOVINA
        ///
        /// * "BE" - BELGIUM
        ///
        /// * "BG" - BULGARIA
        ///
        /// * "BO" - BOLIVIA
        ///
        /// * "BR" - BRAZIL
        ///
        /// * "BY" - BELARUS
        ///
        /// * "CA" - CANADA
        ///
        /// * "CL" - CHILE
        ///
        /// * "CO" - COLOMBIA
        ///
        /// * "CR" - COSTA RICA
        ///
        /// * "HR" - CROATIA
        ///
        /// * "CZ" - CZECH REPUBLIC
        ///
        /// * "DK" - DENMARK
        ///
        /// * "EC" - ECUADOR
        ///
        /// * "EE" - ESTONIA
        ///
        /// * "ET" - ETHIOPIA
        ///
        /// * "FI" - FINLAND
        ///
        /// * "FR" - FRANCE
        ///
        /// * "DE" - GERMANY
        ///
        /// * "GR" - GREECE
        ///
        /// * "HU" - HUNGARY
        ///
        /// * "IS" - ICELAND
        ///
        /// * "IN" - INDIA
        ///
        /// * "IE" - IRELAND
        ///
        /// * "IT" - ITALY
        ///
        /// * "JP" - JAPAN
        ///
        /// * "KZ" - KAZAKHSTAN
        ///
        /// * "KR" - KOREA
        ///
        /// * "LV" - LATVIA
        ///
        /// * "LI" - LIECHTENSTEIN
        ///
        /// * "LT" - LITHUANIA
        ///
        /// * "LU" - LUXEMBOURG
        ///
        /// * "MK" - MACEDONIA
        ///
        /// * "MT" - MALTA
        ///
        /// * "MX" - MEXICO
        ///
        /// * "MD" - MOLDOVA
        ///
        /// * "ME" - MONTENEGRO
        ///
        /// * "NL" - NETHERLANDS
        ///
        /// * "NZ" - NEW ZEALAND
        ///
        /// * "NI" - NICARAGUA
        ///
        /// * "NG" - NIGERIA
        ///
        /// * "NO" - NORWAY
        ///
        /// * "PA" - PANAMA
        ///
        /// * "PY" - PARAGUAY
        ///
        /// * "PE" - PERU
        ///
        /// * "PL" - POLAND
        ///
        /// * "PT" - PORTUGAL
        ///
        /// * "RO" - ROMANIA
        ///
        /// * "RU" - RUSSIA
        ///
        /// * "RS" - SERBIA
        ///
        /// * "SK" - SLOVAKIA
        ///
        /// * "SI" - SLOVENIA
        ///
        /// * "ZA" - SOUTH AFRICA
        ///
        /// * "ES" - SPAIN
        ///
        /// * "SE" - SWEDEN
        ///
        /// * "CH" - SWITZERLAND
        ///
        /// * "UA" - UKRAINE
        ///
        /// * "AE" - UNITED ARAB EMIRATES
        ///
        /// * "US" - UNITED STATES
        ///
        /// * "UK" - UNITED KINGDOM
        ///
        /// * "UY" - URUGUAY
        ///
        /// * "VE" - VENEZUELA
        public var configuration: [Swift.String: [Swift.String]]?
        /// The name of the additional dataset. Valid names: "holiday" and "weather".
        /// This member is required.
        public var name: Swift.String?

        public init(
            configuration: [Swift.String: [Swift.String]]? = nil,
            name: Swift.String? = nil
        )
        {
            self.configuration = configuration
            self.name = name
        }
    }

}

/// We can't process the request because it includes an invalid value or a value that exceeds the valid range.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The limit on the number of resources per account has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There is already a resource with this name. Try again with a different name.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource is in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// We can't find a resource with that Amazon Resource Name (ARN). Check the ARN and try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ForecastClientTypes {
    /// Provides information about the method used to transform attributes. The following is an example using the RETAIL domain: {
    ///     "AttributeName": "demand",
    ///
    ///
    ///     "Transformations": {"aggregation": "sum", "middlefill": "zero", "backfill": "zero"}
    ///
    ///
    ///     }
    public struct AttributeConfig {
        /// The name of the attribute as specified in the schema. Amazon Forecast supports the target field of the target time series and the related time series datasets. For example, for the RETAIL domain, the target is demand.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters. The following list shows the parameters and their valid values for the "filling" featurization method for a Target Time Series dataset. Default values are bolded.
        ///
        /// * aggregation: sum, avg, first, min, max
        ///
        /// * frontfill: none
        ///
        /// * middlefill: zero, nan (not a number), value, median, mean, min, max
        ///
        /// * backfill: zero, nan, value, median, mean, min, max
        ///
        ///
        /// The following list shows the parameters and their valid values for a Related Time Series featurization method (there are no defaults):
        ///
        /// * middlefill: zero, value, median, mean, min, max
        ///
        /// * backfill: zero, value, median, mean, min, max
        ///
        /// * futurefill: zero, value, median, mean, min, max
        ///
        ///
        /// To set a filling method to a specific value, set the fill parameter to value and define the value in a corresponding _value parameter. For example, to set backfilling to a value of 2, include the following: "backfill": "value" and "backfill_value":"2".
        /// This member is required.
        public var transformations: [Swift.String: Swift.String]?

        public init(
            attributeName: Swift.String? = nil,
            transformations: [Swift.String: Swift.String]? = nil
        )
        {
            self.attributeName = attributeName
            self.transformations = transformations
        }
    }

}

extension ForecastClientTypes {
    /// The data configuration for your dataset group and any additional datasets.
    public struct DataConfig {
        /// Additional built-in datasets like Holidays and the Weather Index.
        public var additionalDatasets: [ForecastClientTypes.AdditionalDataset]?
        /// Aggregation and filling options for attributes in your dataset group.
        public var attributeConfigs: [ForecastClientTypes.AttributeConfig]?
        /// The ARN of the dataset group used to train the predictor.
        /// This member is required.
        public var datasetGroupArn: Swift.String?

        public init(
            additionalDatasets: [ForecastClientTypes.AdditionalDataset]? = nil,
            attributeConfigs: [ForecastClientTypes.AttributeConfig]? = nil,
            datasetGroupArn: Swift.String? = nil
        )
        {
            self.additionalDatasets = additionalDatasets
            self.attributeConfigs = attributeConfigs
            self.datasetGroupArn = datasetGroupArn
        }
    }

}

extension ForecastClientTypes {
    /// An Key Management Service (KMS) key and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key. You can specify this optional object in the [CreateDataset] and [CreatePredictor] requests.
    public struct EncryptionConfig {
        /// The Amazon Resource Name (ARN) of the KMS key.
        /// This member is required.
        public var kmsKeyArn: Swift.String?
        /// The ARN of the IAM role that Amazon Forecast can assume to access the KMS key. Passing a role across Amazon Web Services accounts is not allowed. If you pass a role that isn't in your account, you get an InvalidInputException error.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.roleArn = roleArn
        }
    }

}

extension ForecastClientTypes {
    /// The configuration details for the predictor monitor.
    public struct MonitorConfig {
        /// The name of the monitor resource.
        /// This member is required.
        public var monitorName: Swift.String?

        public init(
            monitorName: Swift.String? = nil
        )
        {
            self.monitorName = monitorName
        }
    }

}

extension ForecastClientTypes {

    public enum OptimizationMetric: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case averageweightedquantileloss
        case mape
        case mase
        case rmse
        case wape
        case sdkUnknown(Swift.String)

        public static var allCases: [OptimizationMetric] {
            return [
                .averageweightedquantileloss,
                .mape,
                .mase,
                .rmse,
                .wape
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .averageweightedquantileloss: return "AverageWeightedQuantileLoss"
            case .mape: return "MAPE"
            case .mase: return "MASE"
            case .rmse: return "RMSE"
            case .wape: return "WAPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {
    /// The optional metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public struct Tag {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.
        /// This member is required.
        public var key: Swift.String?
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor within a tag category (key).
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ForecastClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension ForecastClientTypes {

    public enum DayOfWeek: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {

    public enum Month: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case april
        case august
        case december
        case february
        case january
        case july
        case june
        case march
        case may
        case november
        case october
        case september
        case sdkUnknown(Swift.String)

        public static var allCases: [Month] {
            return [
                .april,
                .august,
                .december,
                .february,
                .january,
                .july,
                .june,
                .march,
                .may,
                .november,
                .october,
                .september
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .april: return "APRIL"
            case .august: return "AUGUST"
            case .december: return "DECEMBER"
            case .february: return "FEBRUARY"
            case .january: return "JANUARY"
            case .july: return "JULY"
            case .june: return "JUNE"
            case .march: return "MARCH"
            case .may: return "MAY"
            case .november: return "NOVEMBER"
            case .october: return "OCTOBER"
            case .september: return "SEPTEMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {
    /// The time boundary Forecast uses to align and aggregate your data to match your forecast frequency. Provide the unit of time and the time boundary as a key value pair. If you don't provide a time boundary, Forecast uses a set of [Default Time Boundaries](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html#default-time-boundaries). For more information about aggregation, see [Data Aggregation for Different Forecast Frequencies](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html). For more information setting a custom time boundary, see [Specifying a Time Boundary](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html#specifying-time-boundary).
    public struct TimeAlignmentBoundary {
        /// The day of the month to use for time alignment during aggregation.
        public var dayOfMonth: Swift.Int?
        /// The day of week to use for time alignment during aggregation. The day must be in uppercase.
        public var dayOfWeek: ForecastClientTypes.DayOfWeek?
        /// The hour of day to use for time alignment during aggregation.
        public var hour: Swift.Int?
        /// The month to use for time alignment during aggregation. The month must be in uppercase.
        public var month: ForecastClientTypes.Month?

        public init(
            dayOfMonth: Swift.Int? = nil,
            dayOfWeek: ForecastClientTypes.DayOfWeek? = nil,
            hour: Swift.Int? = nil,
            month: ForecastClientTypes.Month? = nil
        )
        {
            self.dayOfMonth = dayOfMonth
            self.dayOfWeek = dayOfWeek
            self.hour = hour
            self.month = month
        }
    }

}

public struct CreateAutoPredictorInput {
    /// The data configuration for your dataset group and any additional datasets.
    public var dataConfig: ForecastClientTypes.DataConfig?
    /// An Key Management Service (KMS) key and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key. You can specify this optional object in the [CreateDataset] and [CreatePredictor] requests.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// Create an Explainability resource for the predictor.
    public var explainPredictor: Swift.Bool?
    /// An array of dimension (field) names that specify how to group the generated forecast. For example, if you are generating forecasts for item sales across all your stores, and your dataset contains a store_id field, you would specify store_id as a dimension to group sales forecasts for each store.
    public var forecastDimensions: [Swift.String]?
    /// The frequency of predictions in a forecast. Valid intervals are an integer followed by Y (Year), M (Month), W (Week), D (Day), H (Hour), and min (Minute). For example, "1D" indicates every day and "15min" indicates every 15 minutes. You cannot specify a value that would overlap with the next larger frequency. That means, for example, you cannot specify a frequency of 60 minutes, because that is equivalent to 1 hour. The valid values for each frequency are the following:
    ///
    /// * Minute - 1-59
    ///
    /// * Hour - 1-23
    ///
    /// * Day - 1-6
    ///
    /// * Week - 1-4
    ///
    /// * Month - 1-11
    ///
    /// * Year - 1
    ///
    ///
    /// Thus, if you want every other week forecasts, specify "2W". Or, if you want quarterly forecasts, you specify "3M". The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency. When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the RELATED_TIME_SERIES dataset frequency.
    public var forecastFrequency: Swift.String?
    /// The number of time-steps that the model predicts. The forecast horizon is also called the prediction length. The maximum forecast horizon is the lesser of 500 time-steps or 1/4 of the TARGET_TIME_SERIES dataset length. If you are retraining an existing AutoPredictor, then the maximum forecast horizon is the lesser of 500 time-steps or 1/3 of the TARGET_TIME_SERIES dataset length. If you are upgrading to an AutoPredictor or retraining an existing AutoPredictor, you cannot update the forecast horizon parameter. You can meet this requirement by providing longer time-series in the dataset.
    public var forecastHorizon: Swift.Int?
    /// The forecast types used to train a predictor. You can specify up to five forecast types. Forecast types can be quantiles from 0.01 to 0.99, by increments of 0.01 or higher. You can also specify the mean forecast with mean.
    public var forecastTypes: [Swift.String]?
    /// The configuration details for predictor monitoring. Provide a name for the monitor resource to enable predictor monitoring. Predictor monitoring allows you to see how your predictor's performance changes over time. For more information, see [Predictor Monitoring](https://docs.aws.amazon.com/forecast/latest/dg/predictor-monitoring.html).
    public var monitorConfig: ForecastClientTypes.MonitorConfig?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// A unique name for the predictor
    /// This member is required.
    public var predictorName: Swift.String?
    /// The ARN of the predictor to retrain or upgrade. This parameter is only used when retraining or upgrading a predictor. When creating a new predictor, do not specify a value for this parameter. When upgrading or retraining a predictor, only specify values for the ReferencePredictorArn and PredictorName. The value for PredictorName must be a unique predictor name.
    public var referencePredictorArn: Swift.String?
    /// Optional metadata to help you categorize and organize your predictors. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?
    /// The time boundary Forecast uses to align and aggregate any data that doesn't align with your forecast frequency. Provide the unit of time and the time boundary as a key value pair. For more information on specifying a time boundary, see [Specifying a Time Boundary](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html#specifying-time-boundary). If you don't provide a time boundary, Forecast uses a set of [Default Time Boundaries](https://docs.aws.amazon.com/forecast/latest/dg/data-aggregation.html#default-time-boundaries).
    public var timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary?

    public init(
        dataConfig: ForecastClientTypes.DataConfig? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        explainPredictor: Swift.Bool? = nil,
        forecastDimensions: [Swift.String]? = nil,
        forecastFrequency: Swift.String? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        monitorConfig: ForecastClientTypes.MonitorConfig? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        predictorName: Swift.String? = nil,
        referencePredictorArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary? = nil
    )
    {
        self.dataConfig = dataConfig
        self.encryptionConfig = encryptionConfig
        self.explainPredictor = explainPredictor
        self.forecastDimensions = forecastDimensions
        self.forecastFrequency = forecastFrequency
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.monitorConfig = monitorConfig
        self.optimizationMetric = optimizationMetric
        self.predictorName = predictorName
        self.referencePredictorArn = referencePredictorArn
        self.tags = tags
        self.timeAlignmentBoundary = timeAlignmentBoundary
    }
}

public struct CreateAutoPredictorOutput {
    /// The Amazon Resource Name (ARN) of the predictor.
    public var predictorArn: Swift.String?

    public init(
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

extension ForecastClientTypes {

    public enum DatasetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case itemMetadata
        case relatedTimeSeries
        case targetTimeSeries
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetType] {
            return [
                .itemMetadata,
                .relatedTimeSeries,
                .targetTimeSeries
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .itemMetadata: return "ITEM_METADATA"
            case .relatedTimeSeries: return "RELATED_TIME_SERIES"
            case .targetTimeSeries: return "TARGET_TIME_SERIES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {

    public enum Domain: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case ec2Capacity
        case inventoryPlanning
        case metrics
        case retail
        case webTraffic
        case workForce
        case sdkUnknown(Swift.String)

        public static var allCases: [Domain] {
            return [
                .custom,
                .ec2Capacity,
                .inventoryPlanning,
                .metrics,
                .retail,
                .webTraffic,
                .workForce
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .ec2Capacity: return "EC2_CAPACITY"
            case .inventoryPlanning: return "INVENTORY_PLANNING"
            case .metrics: return "METRICS"
            case .retail: return "RETAIL"
            case .webTraffic: return "WEB_TRAFFIC"
            case .workForce: return "WORK_FORCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {

    public enum AttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case float
        case geolocation
        case integer
        case string
        case timestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeType] {
            return [
                .float,
                .geolocation,
                .integer,
                .string,
                .timestamp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .float: return "float"
            case .geolocation: return "geolocation"
            case .integer: return "integer"
            case .string: return "string"
            case .timestamp: return "timestamp"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {
    /// An attribute of a schema, which defines a dataset field. A schema attribute is required for every field in a dataset. The [Schema](https://docs.aws.amazon.com/forecast/latest/dg/API_Schema.html) object contains an array of SchemaAttribute objects.
    public struct SchemaAttribute {
        /// The name of the dataset field.
        public var attributeName: Swift.String?
        /// The data type of the field. For a related time series dataset, other than date, item_id, and forecast dimensions attributes, all attributes should be of numerical type (integer/float).
        public var attributeType: ForecastClientTypes.AttributeType?

        public init(
            attributeName: Swift.String? = nil,
            attributeType: ForecastClientTypes.AttributeType? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeType = attributeType
        }
    }

}

extension ForecastClientTypes {
    /// Defines the fields of a dataset.
    public struct Schema {
        /// An array of attributes specifying the name and type of each field in a dataset.
        public var attributes: [ForecastClientTypes.SchemaAttribute]?

        public init(
            attributes: [ForecastClientTypes.SchemaAttribute]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

public struct CreateDatasetInput {
    /// The frequency of data collection. This parameter is required for RELATED_TIME_SERIES datasets. Valid intervals are an integer followed by Y (Year), M (Month), W (Week), D (Day), H (Hour), and min (Minute). For example, "1D" indicates every day and "15min" indicates every 15 minutes. You cannot specify a value that would overlap with the next larger frequency. That means, for example, you cannot specify a frequency of 60 minutes, because that is equivalent to 1 hour. The valid values for each frequency are the following:
    ///
    /// * Minute - 1-59
    ///
    /// * Hour - 1-23
    ///
    /// * Day - 1-6
    ///
    /// * Week - 1-4
    ///
    /// * Month - 1-11
    ///
    /// * Year - 1
    ///
    ///
    /// Thus, if you want every other week forecasts, specify "2W". Or, if you want quarterly forecasts, you specify "3M".
    public var dataFrequency: Swift.String?
    /// A name for the dataset.
    /// This member is required.
    public var datasetName: Swift.String?
    /// The dataset type. Valid values depend on the chosen Domain.
    /// This member is required.
    public var datasetType: ForecastClientTypes.DatasetType?
    /// The domain associated with the dataset. When you add a dataset to a dataset group, this value and the value specified for the Domain parameter of the [CreateDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetGroup.html) operation must match. The Domain and DatasetType that you choose determine the fields that must be present in the training data that you import to the dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires item_id, timestamp, and demand fields to be present in your data. For more information, see [Importing datasets](https://docs.aws.amazon.com/forecast/latest/dg/howitworks-datasets-groups.html).
    /// This member is required.
    public var domain: ForecastClientTypes.Domain?
    /// An Key Management Service (KMS) key and the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// The schema for the dataset. The schema attributes and their order must match the fields in your data. The dataset Domain and DatasetType that you choose determine the minimum required fields in your training data. For information about the required fields for a specific dataset domain and type, see [Dataset Domains and Dataset Types](https://docs.aws.amazon.com/forecast/latest/dg/howitworks-domains-ds-types.html).
    /// This member is required.
    public var schema: ForecastClientTypes.Schema?
    /// The optional metadata that you apply to the dataset to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        dataFrequency: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        datasetType: ForecastClientTypes.DatasetType? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.dataFrequency = dataFrequency
        self.datasetName = datasetName
        self.datasetType = datasetType
        self.domain = domain
        self.encryptionConfig = encryptionConfig
        self.schema = schema
        self.tags = tags
    }
}

public struct CreateDatasetOutput {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var datasetArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

public struct CreateDatasetGroupInput {
    /// An array of Amazon Resource Names (ARNs) of the datasets that you want to include in the dataset group.
    public var datasetArns: [Swift.String]?
    /// A name for the dataset group.
    /// This member is required.
    public var datasetGroupName: Swift.String?
    /// The domain associated with the dataset group. When you add a dataset to a dataset group, this value and the value specified for the Domain parameter of the [CreateDataset](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDataset.html) operation must match. The Domain and DatasetType that you choose determine the fields that must be present in training data that you import to a dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires that item_id, timestamp, and demand fields are present in your data. For more information, see [Dataset groups](https://docs.aws.amazon.com/forecast/latest/dg/howitworks-datasets-groups.html).
    /// This member is required.
    public var domain: ForecastClientTypes.Domain?
    /// The optional metadata that you apply to the dataset group to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        datasetArns: [Swift.String]? = nil,
        datasetGroupName: Swift.String? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.datasetArns = datasetArns
        self.datasetGroupName = datasetGroupName
        self.domain = domain
        self.tags = tags
    }
}

public struct CreateDatasetGroupOutput {
    /// The Amazon Resource Name (ARN) of the dataset group.
    public var datasetGroupArn: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

extension ForecastClientTypes {
    /// The path to the file(s) in an Amazon Simple Storage Service (Amazon S3) bucket, and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the file(s). Optionally, includes an Key Management Service (KMS) key. This object is part of the [DataSource] object that is submitted in the [CreateDatasetImportJob] request, and part of the [DataDestination] object.
    public struct S3Config {
        /// The Amazon Resource Name (ARN) of an Key Management Service (KMS) key.
        public var kmsKeyArn: Swift.String?
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket or file(s) in an Amazon S3 bucket.
        /// This member is required.
        public var path: Swift.String?
        /// The ARN of the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the Amazon S3 bucket or files. If you provide a value for the KMSKeyArn key, the role must allow access to the key. Passing a role across Amazon Web Services accounts is not allowed. If you pass a role that isn't in your account, you get an InvalidInputException error.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil,
            path: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.path = path
            self.roleArn = roleArn
        }
    }

}

extension ForecastClientTypes {
    /// The source of your data, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an Key Management Service (KMS) key.
    public struct DataSource {
        /// The path to the data stored in an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the data.
        /// This member is required.
        public var s3Config: ForecastClientTypes.S3Config?

        public init(
            s3Config: ForecastClientTypes.S3Config? = nil
        )
        {
            self.s3Config = s3Config
        }
    }

}

extension ForecastClientTypes {

    public enum ImportMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case full
        case incremental
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportMode] {
            return [
                .full,
                .incremental
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .incremental: return "INCREMENTAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDatasetImportJobInput {
    /// The location of the training data to import and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket. If encryption is used, DataSource must include an Key Management Service (KMS) key and the IAM role must allow Amazon Forecast permission to access the key. The KMS key and IAM role must match those specified in the EncryptionConfig parameter of the [CreateDataset](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDataset.html) operation.
    /// This member is required.
    public var dataSource: ForecastClientTypes.DataSource?
    /// The Amazon Resource Name (ARN) of the Amazon Forecast dataset that you want to import data to.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// The name for the dataset import job. We recommend including the current timestamp in the name, for example, 20190721DatasetImport. This can help you avoid getting a ResourceAlreadyExistsException exception.
    /// This member is required.
    public var datasetImportJobName: Swift.String?
    /// The format of the imported data, CSV or PARQUET. The default value is CSV.
    public var format: Swift.String?
    /// The format of the geolocation attribute. The geolocation attribute can be formatted in one of two ways:
    ///
    /// * LAT_LONG - the latitude and longitude in decimal format (Example: 47.61_-122.33).
    ///
    /// * CC_POSTALCODE (US Only) - the country code (US), followed by the 5-digit ZIP code (Example: US_98121).
    public var geolocationFormat: Swift.String?
    /// Specifies whether the dataset import job is a FULL or INCREMENTAL import. A FULL dataset import replaces all of the existing data with the newly imported data. An INCREMENTAL import appends the imported data to the existing data.
    public var importMode: ForecastClientTypes.ImportMode?
    /// The optional metadata that you apply to the dataset import job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?
    /// A single time zone for every item in your dataset. This option is ideal for datasets with all timestamps within a single time zone, or if all timestamps are normalized to a single time zone. Refer to the [Joda-Time API](http://joda-time.sourceforge.net/timezones.html) for a complete list of valid time zone names.
    public var timeZone: Swift.String?
    /// The format of timestamps in the dataset. The format that you specify depends on the DataFrequency specified when the dataset was created. The following formats are supported
    ///
    /// * "yyyy-MM-dd" For the following data frequencies: Y, M, W, and D
    ///
    /// * "yyyy-MM-dd HH:mm:ss" For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y, M, W, and D
    ///
    ///
    /// If the format isn't specified, Amazon Forecast expects the format to be "yyyy-MM-dd HH:mm:ss".
    public var timestampFormat: Swift.String?
    /// Automatically derive time zone information from the geolocation attribute. This option is ideal for datasets that contain timestamps in multiple time zones and those timestamps are expressed in local time.
    public var useGeolocationForTimeZone: Swift.Bool?

    public init(
        dataSource: ForecastClientTypes.DataSource? = nil,
        datasetArn: Swift.String? = nil,
        datasetImportJobName: Swift.String? = nil,
        format: Swift.String? = nil,
        geolocationFormat: Swift.String? = nil,
        importMode: ForecastClientTypes.ImportMode? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        timeZone: Swift.String? = nil,
        timestampFormat: Swift.String? = nil,
        useGeolocationForTimeZone: Swift.Bool? = false
    )
    {
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.datasetImportJobName = datasetImportJobName
        self.format = format
        self.geolocationFormat = geolocationFormat
        self.importMode = importMode
        self.tags = tags
        self.timeZone = timeZone
        self.timestampFormat = timestampFormat
        self.useGeolocationForTimeZone = useGeolocationForTimeZone
    }
}

public struct CreateDatasetImportJobOutput {
    /// The Amazon Resource Name (ARN) of the dataset import job.
    public var datasetImportJobArn: Swift.String?

    public init(
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

extension ForecastClientTypes {

    public enum TimePointGranularity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case specific
        case sdkUnknown(Swift.String)

        public static var allCases: [TimePointGranularity] {
            return [
                .all,
                .specific
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .specific: return "SPECIFIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {

    public enum TimeSeriesGranularity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case specific
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeSeriesGranularity] {
            return [
                .all,
                .specific
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .specific: return "SPECIFIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {
    /// The ExplainabilityConfig data type defines the number of time series and time points included in [CreateExplainability]. If you provide a predictor ARN for ResourceArn, you must set both TimePointGranularity and TimeSeriesGranularity to “ALL”. When creating Predictor Explainability, Amazon Forecast considers all time series and time points. If you provide a forecast ARN for ResourceArn, you can set TimePointGranularity and TimeSeriesGranularity to either “ALL” or “Specific”.
    public struct ExplainabilityConfig {
        /// To create an Explainability for all time points in your forecast horizon, use ALL. To create an Explainability for specific time points in your forecast horizon, use SPECIFIC. Specify time points with the StartDateTime and EndDateTime parameters within the [CreateExplainability] operation.
        /// This member is required.
        public var timePointGranularity: ForecastClientTypes.TimePointGranularity?
        /// To create an Explainability for all time series in your datasets, use ALL. To create an Explainability for specific time series in your datasets, use SPECIFIC. Specify time series by uploading a CSV or Parquet file to an Amazon S3 bucket and set the location within the [DataDestination] data type.
        /// This member is required.
        public var timeSeriesGranularity: ForecastClientTypes.TimeSeriesGranularity?

        public init(
            timePointGranularity: ForecastClientTypes.TimePointGranularity? = nil,
            timeSeriesGranularity: ForecastClientTypes.TimeSeriesGranularity? = nil
        )
        {
            self.timePointGranularity = timePointGranularity
            self.timeSeriesGranularity = timeSeriesGranularity
        }
    }

}

public struct CreateExplainabilityInput {
    /// The source of your data, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an Key Management Service (KMS) key.
    public var dataSource: ForecastClientTypes.DataSource?
    /// Create an Explainability visualization that is viewable within the Amazon Web Services console.
    public var enableVisualization: Swift.Bool?
    /// If TimePointGranularity is set to SPECIFIC, define the last time point for the Explainability. Use the following timestamp format: yyyy-MM-ddTHH:mm:ss (example: 2015-01-01T20:00:00)
    public var endDateTime: Swift.String?
    /// The configuration settings that define the granularity of time series and time points for the Explainability.
    /// This member is required.
    public var explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
    /// A unique name for the Explainability.
    /// This member is required.
    public var explainabilityName: Swift.String?
    /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Defines the fields of a dataset.
    public var schema: ForecastClientTypes.Schema?
    /// If TimePointGranularity is set to SPECIFIC, define the first point for the Explainability. Use the following timestamp format: yyyy-MM-ddTHH:mm:ss (example: 2015-01-01T20:00:00)
    public var startDateTime: Swift.String?
    /// Optional metadata to help you categorize and organize your resources. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        dataSource: ForecastClientTypes.DataSource? = nil,
        enableVisualization: Swift.Bool? = nil,
        endDateTime: Swift.String? = nil,
        explainabilityConfig: ForecastClientTypes.ExplainabilityConfig? = nil,
        explainabilityName: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        startDateTime: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.dataSource = dataSource
        self.enableVisualization = enableVisualization
        self.endDateTime = endDateTime
        self.explainabilityConfig = explainabilityConfig
        self.explainabilityName = explainabilityName
        self.resourceArn = resourceArn
        self.schema = schema
        self.startDateTime = startDateTime
        self.tags = tags
    }
}

public struct CreateExplainabilityOutput {
    /// The Amazon Resource Name (ARN) of the Explainability.
    public var explainabilityArn: Swift.String?

    public init(
        explainabilityArn: Swift.String? = nil
    )
    {
        self.explainabilityArn = explainabilityArn
    }
}

extension ForecastClientTypes {
    /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
    public struct DataDestination {
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the bucket.
        /// This member is required.
        public var s3Config: ForecastClientTypes.S3Config?

        public init(
            s3Config: ForecastClientTypes.S3Config? = nil
        )
        {
            self.s3Config = s3Config
        }
    }

}

public struct CreateExplainabilityExportInput {
    /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the Explainability to export.
    /// This member is required.
    public var explainabilityArn: Swift.String?
    /// A unique name for the Explainability export.
    /// This member is required.
    public var explainabilityExportName: Swift.String?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// Optional metadata to help you categorize and organize your resources. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        destination: ForecastClientTypes.DataDestination? = nil,
        explainabilityArn: Swift.String? = nil,
        explainabilityExportName: Swift.String? = nil,
        format: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.destination = destination
        self.explainabilityArn = explainabilityArn
        self.explainabilityExportName = explainabilityExportName
        self.format = format
        self.tags = tags
    }
}

public struct CreateExplainabilityExportOutput {
    /// The Amazon Resource Name (ARN) of the export.
    public var explainabilityExportArn: Swift.String?

    public init(
        explainabilityExportArn: Swift.String? = nil
    )
    {
        self.explainabilityExportArn = explainabilityExportArn
    }
}

extension ForecastClientTypes {
    /// Details about the import file that contains the time series for which you want to create forecasts.
    public struct TimeSeriesIdentifiers {
        /// The source of your data, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an Key Management Service (KMS) key.
        public var dataSource: ForecastClientTypes.DataSource?
        /// The format of the data, either CSV or PARQUET.
        public var format: Swift.String?
        /// Defines the fields of a dataset.
        public var schema: ForecastClientTypes.Schema?

        public init(
            dataSource: ForecastClientTypes.DataSource? = nil,
            format: Swift.String? = nil,
            schema: ForecastClientTypes.Schema? = nil
        )
        {
            self.dataSource = dataSource
            self.format = format
            self.schema = schema
        }
    }

}

extension ForecastClientTypes {
    /// Defines the set of time series that are used to create the forecasts in a TimeSeriesIdentifiers object. The TimeSeriesIdentifiers object needs the following information:
    ///
    /// * DataSource
    ///
    /// * Format
    ///
    /// * Schema
    public struct TimeSeriesSelector {
        /// Details about the import file that contains the time series for which you want to create forecasts.
        public var timeSeriesIdentifiers: ForecastClientTypes.TimeSeriesIdentifiers?

        public init(
            timeSeriesIdentifiers: ForecastClientTypes.TimeSeriesIdentifiers? = nil
        )
        {
            self.timeSeriesIdentifiers = timeSeriesIdentifiers
        }
    }

}

public struct CreateForecastInput {
    /// A name for the forecast.
    /// This member is required.
    public var forecastName: Swift.String?
    /// The quantiles at which probabilistic forecasts are generated. You can currently specify up to 5 quantiles per forecast. Accepted values include 0.01 to 0.99 (increments of .01 only) and mean. The mean forecast is different from the median (0.50) when the distribution is not symmetric (for example, Beta and Negative Binomial). The default quantiles are the quantiles you specified during predictor creation. If you didn't specify quantiles, the default values are ["0.1", "0.5", "0.9"].
    public var forecastTypes: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the predictor to use to generate the forecast.
    /// This member is required.
    public var predictorArn: Swift.String?
    /// The optional metadata that you apply to the forecast to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?
    /// Defines the set of time series that are used to create the forecasts in a TimeSeriesIdentifiers object. The TimeSeriesIdentifiers object needs the following information:
    ///
    /// * DataSource
    ///
    /// * Format
    ///
    /// * Schema
    public var timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?

    public init(
        forecastName: Swift.String? = nil,
        forecastTypes: [Swift.String]? = nil,
        predictorArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector? = nil
    )
    {
        self.forecastName = forecastName
        self.forecastTypes = forecastTypes
        self.predictorArn = predictorArn
        self.tags = tags
        self.timeSeriesSelector = timeSeriesSelector
    }
}

public struct CreateForecastOutput {
    /// The Amazon Resource Name (ARN) of the forecast.
    public var forecastArn: Swift.String?

    public init(
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

public struct CreateForecastExportJobInput {
    /// The location where you want to save the forecast and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the location. The forecast must be exported to an Amazon S3 bucket. If encryption is used, Destination must include an Key Management Service (KMS) key. The IAM role must allow Amazon Forecast permission to access the key.
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the forecast that you want to export.
    /// This member is required.
    public var forecastArn: Swift.String?
    /// The name for the forecast export job.
    /// This member is required.
    public var forecastExportJobName: Swift.String?
    /// The format of the exported data, CSV or PARQUET. The default value is CSV.
    public var format: Swift.String?
    /// The optional metadata that you apply to the forecast export job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        destination: ForecastClientTypes.DataDestination? = nil,
        forecastArn: Swift.String? = nil,
        forecastExportJobName: Swift.String? = nil,
        format: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.destination = destination
        self.forecastArn = forecastArn
        self.forecastExportJobName = forecastExportJobName
        self.format = format
        self.tags = tags
    }
}

public struct CreateForecastExportJobOutput {
    /// The Amazon Resource Name (ARN) of the export job.
    public var forecastExportJobArn: Swift.String?

    public init(
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

public struct CreateMonitorInput {
    /// The name of the monitor resource.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor to monitor.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/forecast/latest/dg/tagging-forecast-resources.html) to apply to the monitor resource.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        monitorName: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.monitorName = monitorName
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct CreateMonitorOutput {
    /// The Amazon Resource Name (ARN) of the monitor resource.
    public var monitorArn: Swift.String?

    public init(
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

extension ForecastClientTypes {

    public enum AutoMLOverrideStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accuracyoptimized
        case latencyoptimized
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoMLOverrideStrategy] {
            return [
                .accuracyoptimized,
                .latencyoptimized
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accuracyoptimized: return "AccuracyOptimized"
            case .latencyoptimized: return "LatencyOptimized"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {
    /// Parameters that define how to split a dataset into training data and testing data, and the number of iterations to perform. These parameters are specified in the predefined algorithms but you can override them in the [CreatePredictor] request.
    public struct EvaluationParameters {
        /// The point from the end of the dataset where you want to split the data for model training and testing (evaluation). Specify the value as the number of data points. The default is the value of the forecast horizon. BackTestWindowOffset can be used to mimic a past virtual forecast start date. This value must be greater than or equal to the forecast horizon and less than half of the TARGET_TIME_SERIES dataset length. ForecastHorizon <= BackTestWindowOffset < 1/2 * TARGET_TIME_SERIES dataset length
        public var backTestWindowOffset: Swift.Int?
        /// The number of times to split the input data. The default is 1. Valid values are 1 through 5.
        public var numberOfBacktestWindows: Swift.Int?

        public init(
            backTestWindowOffset: Swift.Int? = nil,
            numberOfBacktestWindows: Swift.Int? = nil
        )
        {
            self.backTestWindowOffset = backTestWindowOffset
            self.numberOfBacktestWindows = numberOfBacktestWindows
        }
    }

}

extension ForecastClientTypes {

    public enum FeaturizationMethodName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case filling
        case sdkUnknown(Swift.String)

        public static var allCases: [FeaturizationMethodName] {
            return [
                .filling
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .filling: return "filling"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {
    /// Provides information about the method that featurizes (transforms) a dataset field. The method is part of the FeaturizationPipeline of the [Featurization] object. The following is an example of how you specify a FeaturizationMethod object. {
    ///     "FeaturizationMethodName": "filling",
    ///
    ///
    ///     "FeaturizationMethodParameters": {"aggregation": "sum", "middlefill": "zero", "backfill": "zero"}
    ///
    ///
    ///     }
    public struct FeaturizationMethod {
        /// The name of the method. The "filling" method is the only supported method.
        /// This member is required.
        public var featurizationMethodName: ForecastClientTypes.FeaturizationMethodName?
        /// The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters. The following list shows the parameters and their valid values for the "filling" featurization method for a Target Time Series dataset. Bold signifies the default value.
        ///
        /// * aggregation: sum, avg, first, min, max
        ///
        /// * frontfill: none
        ///
        /// * middlefill: zero, nan (not a number), value, median, mean, min, max
        ///
        /// * backfill: zero, nan, value, median, mean, min, max
        ///
        ///
        /// The following list shows the parameters and their valid values for a Related Time Series featurization method (there are no defaults):
        ///
        /// * middlefill: zero, value, median, mean, min, max
        ///
        /// * backfill: zero, value, median, mean, min, max
        ///
        /// * futurefill: zero, value, median, mean, min, max
        ///
        ///
        /// To set a filling method to a specific value, set the fill parameter to value and define the value in a corresponding _value parameter. For example, to set backfilling to a value of 2, include the following: "backfill": "value" and "backfill_value":"2".
        public var featurizationMethodParameters: [Swift.String: Swift.String]?

        public init(
            featurizationMethodName: ForecastClientTypes.FeaturizationMethodName? = nil,
            featurizationMethodParameters: [Swift.String: Swift.String]? = nil
        )
        {
            self.featurizationMethodName = featurizationMethodName
            self.featurizationMethodParameters = featurizationMethodParameters
        }
    }

}

extension ForecastClientTypes {
    /// This object belongs to the [CreatePredictor] operation. If you created your predictor with [CreateAutoPredictor], see [AttributeConfig]. Provides featurization (transformation) information for a dataset field. This object is part of the [FeaturizationConfig] object. For example: {
    ///     "AttributeName": "demand",
    ///
    ///
    ///     FeaturizationPipeline [ {
    ///
    ///
    ///     "FeaturizationMethodName": "filling",
    ///
    ///
    ///     "FeaturizationMethodParameters": {"aggregation": "avg", "backfill": "nan"}
    ///
    ///
    ///     } ]
    ///
    ///
    ///     }
    public struct Featurization {
        /// The name of the schema attribute that specifies the data field to be featurized. Amazon Forecast supports the target field of the TARGET_TIME_SERIES and the RELATED_TIME_SERIES datasets. For example, for the RETAIL domain, the target is demand, and for the CUSTOM domain, the target is target_value. For more information, see [howitworks-missing-values].
        /// This member is required.
        public var attributeName: Swift.String?
        /// An array of one FeaturizationMethod object that specifies the feature transformation method.
        public var featurizationPipeline: [ForecastClientTypes.FeaturizationMethod]?

        public init(
            attributeName: Swift.String? = nil,
            featurizationPipeline: [ForecastClientTypes.FeaturizationMethod]? = nil
        )
        {
            self.attributeName = attributeName
            self.featurizationPipeline = featurizationPipeline
        }
    }

}

extension ForecastClientTypes {
    /// This object belongs to the [CreatePredictor] operation. If you created your predictor with [CreateAutoPredictor], see [AttributeConfig]. In a [CreatePredictor] operation, the specified algorithm trains a model using the specified dataset group. You can optionally tell the operation to modify data fields prior to training a model. These modifications are referred to as featurization. You define featurization using the FeaturizationConfig object. You specify an array of transformations, one for each field that you want to featurize. You then include the FeaturizationConfig object in your CreatePredictor request. Amazon Forecast applies the featurization to the TARGET_TIME_SERIES and RELATED_TIME_SERIES datasets before model training. You can create multiple featurization configurations. For example, you might call the CreatePredictor operation twice by specifying different featurization configurations.
    public struct FeaturizationConfig {
        /// An array of featurization (transformation) information for the fields of a dataset.
        public var featurizations: [ForecastClientTypes.Featurization]?
        /// An array of dimension (field) names that specify how to group the generated forecast. For example, suppose that you are generating a forecast for item sales across all of your stores, and your dataset contains a store_id field. If you want the sales forecast for each item by store, you would specify store_id as the dimension. All forecast dimensions specified in the TARGET_TIME_SERIES dataset don't need to be specified in the CreatePredictor request. All forecast dimensions specified in the RELATED_TIME_SERIES dataset must be specified in the CreatePredictor request.
        public var forecastDimensions: [Swift.String]?
        /// The frequency of predictions in a forecast. Valid intervals are an integer followed by Y (Year), M (Month), W (Week), D (Day), H (Hour), and min (Minute). For example, "1D" indicates every day and "15min" indicates every 15 minutes. You cannot specify a value that would overlap with the next larger frequency. That means, for example, you cannot specify a frequency of 60 minutes, because that is equivalent to 1 hour. The valid values for each frequency are the following:
        ///
        /// * Minute - 1-59
        ///
        /// * Hour - 1-23
        ///
        /// * Day - 1-6
        ///
        /// * Week - 1-4
        ///
        /// * Month - 1-11
        ///
        /// * Year - 1
        ///
        ///
        /// Thus, if you want every other week forecasts, specify "2W". Or, if you want quarterly forecasts, you specify "3M". The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency. When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the TARGET_TIME_SERIES dataset frequency.
        /// This member is required.
        public var forecastFrequency: Swift.String?

        public init(
            featurizations: [ForecastClientTypes.Featurization]? = nil,
            forecastDimensions: [Swift.String]? = nil,
            forecastFrequency: Swift.String? = nil
        )
        {
            self.featurizations = featurizations
            self.forecastDimensions = forecastDimensions
            self.forecastFrequency = forecastFrequency
        }
    }

}

extension ForecastClientTypes {
    /// Specifies a categorical hyperparameter and it's range of tunable values. This object is part of the [ParameterRanges] object.
    public struct CategoricalParameterRange {
        /// The name of the categorical hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// A list of the tunable categories for the hyperparameter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension ForecastClientTypes {

    public enum ScalingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case linear
        case logarithmic
        case reverselogarithmic
        case sdkUnknown(Swift.String)

        public static var allCases: [ScalingType] {
            return [
                .auto,
                .linear,
                .logarithmic,
                .reverselogarithmic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "Auto"
            case .linear: return "Linear"
            case .logarithmic: return "Logarithmic"
            case .reverselogarithmic: return "ReverseLogarithmic"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {
    /// Specifies a continuous hyperparameter and it's range of tunable values. This object is part of the [ParameterRanges] object.
    public struct ContinuousParameterRange {
        /// The maximum tunable value of the hyperparameter.
        /// This member is required.
        public var maxValue: Swift.Double?
        /// The minimum tunable value of the hyperparameter.
        /// This member is required.
        public var minValue: Swift.Double?
        /// The name of the hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values: Auto Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter. Linear Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale. Logarithmic Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have values greater than 0. ReverseLogarithmic hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale. Reverse logarithmic scaling works only for ranges that are entirely within the range 0 <= x < 1.0. For information about choosing a hyperparameter scale, see [Hyperparameter Scaling](http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type). One of the following values:
        public var scalingType: ForecastClientTypes.ScalingType?

        public init(
            maxValue: Swift.Double? = nil,
            minValue: Swift.Double? = nil,
            name: Swift.String? = nil,
            scalingType: ForecastClientTypes.ScalingType? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }
    }

}

extension ForecastClientTypes {
    /// Specifies an integer hyperparameter and it's range of tunable values. This object is part of the [ParameterRanges] object.
    public struct IntegerParameterRange {
        /// The maximum tunable value of the hyperparameter.
        /// This member is required.
        public var maxValue: Swift.Int?
        /// The minimum tunable value of the hyperparameter.
        /// This member is required.
        public var minValue: Swift.Int?
        /// The name of the hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values: Auto Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter. Linear Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale. Logarithmic Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have values greater than 0. ReverseLogarithmic Not supported for IntegerParameterRange. Reverse logarithmic scaling works only for ranges that are entirely within the range 0 <= x < 1.0. For information about choosing a hyperparameter scale, see [Hyperparameter Scaling](http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type). One of the following values:
        public var scalingType: ForecastClientTypes.ScalingType?

        public init(
            maxValue: Swift.Int? = nil,
            minValue: Swift.Int? = nil,
            name: Swift.String? = nil,
            scalingType: ForecastClientTypes.ScalingType? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }
    }

}

extension ForecastClientTypes {
    /// Specifies the categorical, continuous, and integer hyperparameters, and their ranges of tunable values. The range of tunable values determines which values that a hyperparameter tuning job can choose for the specified hyperparameter. This object is part of the [HyperParameterTuningJobConfig] object.
    public struct ParameterRanges {
        /// Specifies the tunable range for each categorical hyperparameter.
        public var categoricalParameterRanges: [ForecastClientTypes.CategoricalParameterRange]?
        /// Specifies the tunable range for each continuous hyperparameter.
        public var continuousParameterRanges: [ForecastClientTypes.ContinuousParameterRange]?
        /// Specifies the tunable range for each integer hyperparameter.
        public var integerParameterRanges: [ForecastClientTypes.IntegerParameterRange]?

        public init(
            categoricalParameterRanges: [ForecastClientTypes.CategoricalParameterRange]? = nil,
            continuousParameterRanges: [ForecastClientTypes.ContinuousParameterRange]? = nil,
            integerParameterRanges: [ForecastClientTypes.IntegerParameterRange]? = nil
        )
        {
            self.categoricalParameterRanges = categoricalParameterRanges
            self.continuousParameterRanges = continuousParameterRanges
            self.integerParameterRanges = integerParameterRanges
        }
    }

}

extension ForecastClientTypes {
    /// Configuration information for a hyperparameter tuning job. You specify this object in the [CreatePredictor] request. A hyperparameter is a parameter that governs the model training process. You set hyperparameters before training starts, unlike model parameters, which are determined during training. The values of the hyperparameters effect which values are chosen for the model parameters. In a hyperparameter tuning job, Amazon Forecast chooses the set of hyperparameter values that optimize a specified metric. Forecast accomplishes this by running many training jobs over a range of hyperparameter values. The optimum set of values depends on the algorithm, the training data, and the specified metric objective.
    public struct HyperParameterTuningJobConfig {
        /// Specifies the ranges of valid values for the hyperparameters.
        public var parameterRanges: ForecastClientTypes.ParameterRanges?

        public init(
            parameterRanges: ForecastClientTypes.ParameterRanges? = nil
        )
        {
            self.parameterRanges = parameterRanges
        }
    }

}

extension ForecastClientTypes {
    /// This object belongs to the [CreatePredictor] operation. If you created your predictor with [CreateAutoPredictor], see [AdditionalDataset]. Describes a supplementary feature of a dataset group. This object is part of the [InputDataConfig] object. Forecast supports the Weather Index and Holidays built-in featurizations. Weather Index The Amazon Forecast Weather Index is a built-in featurization that incorporates historical and projected weather information into your model. The Weather Index supplements your datasets with over two years of historical weather data and up to 14 days of projected weather data. For more information, see [Amazon Forecast Weather Index](https://docs.aws.amazon.com/forecast/latest/dg/weather.html). Holidays Holidays is a built-in featurization that incorporates a feature-engineered dataset of national holiday information into your model. It provides native support for the holiday calendars of 66 countries. To view the holiday calendars, refer to the [Jollyday](http://jollyday.sourceforge.net/data.html) library. For more information, see [Holidays Featurization](https://docs.aws.amazon.com/forecast/latest/dg/holidays.html).
    public struct SupplementaryFeature {
        /// The name of the feature. Valid values: "holiday" and "weather".
        /// This member is required.
        public var name: Swift.String?
        /// Weather Index To enable the Weather Index, set the value to "true" Holidays To enable Holidays, specify a country with one of the following two-letter country codes:
        ///
        /// * "AL" - ALBANIA
        ///
        /// * "AR" - ARGENTINA
        ///
        /// * "AT" - AUSTRIA
        ///
        /// * "AU" - AUSTRALIA
        ///
        /// * "BA" - BOSNIA HERZEGOVINA
        ///
        /// * "BE" - BELGIUM
        ///
        /// * "BG" - BULGARIA
        ///
        /// * "BO" - BOLIVIA
        ///
        /// * "BR" - BRAZIL
        ///
        /// * "BY" - BELARUS
        ///
        /// * "CA" - CANADA
        ///
        /// * "CL" - CHILE
        ///
        /// * "CO" - COLOMBIA
        ///
        /// * "CR" - COSTA RICA
        ///
        /// * "HR" - CROATIA
        ///
        /// * "CZ" - CZECH REPUBLIC
        ///
        /// * "DK" - DENMARK
        ///
        /// * "EC" - ECUADOR
        ///
        /// * "EE" - ESTONIA
        ///
        /// * "ET" - ETHIOPIA
        ///
        /// * "FI" - FINLAND
        ///
        /// * "FR" - FRANCE
        ///
        /// * "DE" - GERMANY
        ///
        /// * "GR" - GREECE
        ///
        /// * "HU" - HUNGARY
        ///
        /// * "IS" - ICELAND
        ///
        /// * "IN" - INDIA
        ///
        /// * "IE" - IRELAND
        ///
        /// * "IT" - ITALY
        ///
        /// * "JP" - JAPAN
        ///
        /// * "KZ" - KAZAKHSTAN
        ///
        /// * "KR" - KOREA
        ///
        /// * "LV" - LATVIA
        ///
        /// * "LI" - LIECHTENSTEIN
        ///
        /// * "LT" - LITHUANIA
        ///
        /// * "LU" - LUXEMBOURG
        ///
        /// * "MK" - MACEDONIA
        ///
        /// * "MT" - MALTA
        ///
        /// * "MX" - MEXICO
        ///
        /// * "MD" - MOLDOVA
        ///
        /// * "ME" - MONTENEGRO
        ///
        /// * "NL" - NETHERLANDS
        ///
        /// * "NZ" - NEW ZEALAND
        ///
        /// * "NI" - NICARAGUA
        ///
        /// * "NG" - NIGERIA
        ///
        /// * "NO" - NORWAY
        ///
        /// * "PA" - PANAMA
        ///
        /// * "PY" - PARAGUAY
        ///
        /// * "PE" - PERU
        ///
        /// * "PL" - POLAND
        ///
        /// * "PT" - PORTUGAL
        ///
        /// * "RO" - ROMANIA
        ///
        /// * "RU" - RUSSIA
        ///
        /// * "RS" - SERBIA
        ///
        /// * "SK" - SLOVAKIA
        ///
        /// * "SI" - SLOVENIA
        ///
        /// * "ZA" - SOUTH AFRICA
        ///
        /// * "ES" - SPAIN
        ///
        /// * "SE" - SWEDEN
        ///
        /// * "CH" - SWITZERLAND
        ///
        /// * "UA" - UKRAINE
        ///
        /// * "AE" - UNITED ARAB EMIRATES
        ///
        /// * "US" - UNITED STATES
        ///
        /// * "UK" - UNITED KINGDOM
        ///
        /// * "UY" - URUGUAY
        ///
        /// * "VE" - VENEZUELA
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ForecastClientTypes {
    /// This object belongs to the [CreatePredictor] operation. If you created your predictor with [CreateAutoPredictor], see [DataConfig]. The data used to train a predictor. The data includes a dataset group and any supplementary features. You specify this object in the [CreatePredictor] request.
    public struct InputDataConfig {
        /// The Amazon Resource Name (ARN) of the dataset group.
        /// This member is required.
        public var datasetGroupArn: Swift.String?
        /// An array of supplementary features. The only supported feature is a holiday calendar.
        public var supplementaryFeatures: [ForecastClientTypes.SupplementaryFeature]?

        public init(
            datasetGroupArn: Swift.String? = nil,
            supplementaryFeatures: [ForecastClientTypes.SupplementaryFeature]? = nil
        )
        {
            self.datasetGroupArn = datasetGroupArn
            self.supplementaryFeatures = supplementaryFeatures
        }
    }

}

public struct CreatePredictorInput {
    /// The Amazon Resource Name (ARN) of the algorithm to use for model training. Required if PerformAutoML is not set to true. Supported algorithms:
    ///
    /// * arn:aws:forecast:::algorithm/ARIMA
    ///
    /// * arn:aws:forecast:::algorithm/CNN-QR
    ///
    /// * arn:aws:forecast:::algorithm/Deep_AR_Plus
    ///
    /// * arn:aws:forecast:::algorithm/ETS
    ///
    /// * arn:aws:forecast:::algorithm/NPTS
    ///
    /// * arn:aws:forecast:::algorithm/Prophet
    public var algorithmArn: Swift.String?
    /// The LatencyOptimized AutoML override strategy is only available in private beta. Contact Amazon Web Services Support or your account manager to learn more about access privileges. Used to overide the default AutoML strategy, which is to optimize predictor accuracy. To apply an AutoML strategy that minimizes training time, use LatencyOptimized. This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// An Key Management Service (KMS) key and the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast evaluates a predictor by splitting a dataset into training data and testing data. The evaluation parameters define how to perform the split and the number of iterations.
    public var evaluationParameters: ForecastClientTypes.EvaluationParameters?
    /// The featurization configuration.
    /// This member is required.
    public var featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    /// Specifies the number of time-steps that the model is trained to predict. The forecast horizon is also called the prediction length. For example, if you configure a dataset for daily data collection (using the DataFrequency parameter of the [CreateDataset] operation) and set the forecast horizon to 10, the model returns predictions for 10 days. The maximum forecast horizon is the lesser of 500 time-steps or 1/3 of the TARGET_TIME_SERIES dataset length.
    /// This member is required.
    public var forecastHorizon: Swift.Int?
    /// Specifies the forecast types used to train a predictor. You can specify up to five forecast types. Forecast types can be quantiles from 0.01 to 0.99, by increments of 0.01 or higher. You can also specify the mean forecast with mean. The default value is ["0.10", "0.50", "0.9"].
    public var forecastTypes: [Swift.String]?
    /// Provides hyperparameter override values for the algorithm. If you don't provide this parameter, Amazon Forecast uses default values. The individual algorithms specify which hyperparameters support hyperparameter optimization (HPO). For more information, see [aws-forecast-choosing-recipes]. If you included the HPOConfig object, you must set PerformHPO to true.
    public var hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    /// Describes the dataset group that contains the data to use to train the predictor.
    /// This member is required.
    public var inputDataConfig: ForecastClientTypes.InputDataConfig?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// Whether to perform AutoML. When Amazon Forecast performs AutoML, it evaluates the algorithms it provides and chooses the best algorithm and configuration for your training dataset. The default value is false. In this case, you are required to specify an algorithm. Set PerformAutoML to true to have Amazon Forecast perform AutoML. This is a good option if you aren't sure which algorithm is suitable for your training data. In this case, PerformHPO must be false.
    public var performAutoML: Swift.Bool?
    /// Whether to perform hyperparameter optimization (HPO). HPO finds optimal hyperparameter values for your training data. The process of performing HPO is known as running a hyperparameter tuning job. The default value is false. In this case, Amazon Forecast uses default hyperparameter values from the chosen algorithm. To override the default values, set PerformHPO to true and, optionally, supply the [HyperParameterTuningJobConfig] object. The tuning job specifies a metric to optimize, which hyperparameters participate in tuning, and the valid range for each tunable hyperparameter. In this case, you are required to specify an algorithm and PerformAutoML must be false. The following algorithms support HPO:
    ///
    /// * DeepAR+
    ///
    /// * CNN-QR
    public var performHPO: Swift.Bool?
    /// A name for the predictor.
    /// This member is required.
    public var predictorName: Swift.String?
    /// The optional metadata that you apply to the predictor to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?
    /// The hyperparameters to override for model training. The hyperparameters that you can override are listed in the individual algorithms. For the list of supported algorithms, see [aws-forecast-choosing-recipes].
    public var trainingParameters: [Swift.String: Swift.String]?

    public init(
        algorithmArn: Swift.String? = nil,
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        evaluationParameters: ForecastClientTypes.EvaluationParameters? = nil,
        featurizationConfig: ForecastClientTypes.FeaturizationConfig? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig? = nil,
        inputDataConfig: ForecastClientTypes.InputDataConfig? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        performAutoML: Swift.Bool? = nil,
        performHPO: Swift.Bool? = nil,
        predictorName: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        trainingParameters: [Swift.String: Swift.String]? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.encryptionConfig = encryptionConfig
        self.evaluationParameters = evaluationParameters
        self.featurizationConfig = featurizationConfig
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.hpoConfig = hpoConfig
        self.inputDataConfig = inputDataConfig
        self.optimizationMetric = optimizationMetric
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.predictorName = predictorName
        self.tags = tags
        self.trainingParameters = trainingParameters
    }
}

public struct CreatePredictorOutput {
    /// The Amazon Resource Name (ARN) of the predictor.
    public var predictorArn: Swift.String?

    public init(
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

public struct CreatePredictorBacktestExportJobInput {
    /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The format of the exported data, CSV or PARQUET. The default value is CSV.
    public var format: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor that you want to export.
    /// This member is required.
    public var predictorArn: Swift.String?
    /// The name for the backtest export job.
    /// This member is required.
    public var predictorBacktestExportJobName: Swift.String?
    /// Optional metadata to help you categorize and organize your backtests. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        destination: ForecastClientTypes.DataDestination? = nil,
        format: Swift.String? = nil,
        predictorArn: Swift.String? = nil,
        predictorBacktestExportJobName: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.destination = destination
        self.format = format
        self.predictorArn = predictorArn
        self.predictorBacktestExportJobName = predictorBacktestExportJobName
        self.tags = tags
    }
}

public struct CreatePredictorBacktestExportJobOutput {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job that you want to export.
    public var predictorBacktestExportJobArn: Swift.String?

    public init(
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

public struct CreateWhatIfAnalysisInput {
    /// The Amazon Resource Name (ARN) of the baseline forecast.
    /// This member is required.
    public var forecastArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/forecast/latest/dg/tagging-forecast-resources.html) to apply to the what if forecast.
    public var tags: [ForecastClientTypes.Tag]?
    /// Defines the set of time series that are used in the what-if analysis with a TimeSeriesIdentifiers object. What-if analyses are performed only for the time series in this object. The TimeSeriesIdentifiers object needs the following information:
    ///
    /// * DataSource
    ///
    /// * Format
    ///
    /// * Schema
    public var timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?
    /// The name of the what-if analysis. Each name must be unique.
    /// This member is required.
    public var whatIfAnalysisName: Swift.String?

    public init(
        forecastArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector? = nil,
        whatIfAnalysisName: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
        self.tags = tags
        self.timeSeriesSelector = timeSeriesSelector
        self.whatIfAnalysisName = whatIfAnalysisName
    }
}

public struct CreateWhatIfAnalysisOutput {
    /// The Amazon Resource Name (ARN) of the what-if analysis.
    public var whatIfAnalysisArn: Swift.String?

    public init(
        whatIfAnalysisArn: Swift.String? = nil
    )
    {
        self.whatIfAnalysisArn = whatIfAnalysisArn
    }
}

extension ForecastClientTypes {
    /// A replacement dataset is a modified version of the baseline related time series that contains only the values that you want to include in a what-if forecast. The replacement dataset must contain the forecast dimensions and item identifiers in the baseline related time series as well as at least 1 changed time series. This dataset is merged with the baseline related time series to create a transformed dataset that is used for the what-if forecast.
    public struct TimeSeriesReplacementsDataSource {
        /// The format of the replacement data, CSV or PARQUET.
        public var format: Swift.String?
        /// The path to the file(s) in an Amazon Simple Storage Service (Amazon S3) bucket, and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the file(s). Optionally, includes an Key Management Service (KMS) key. This object is part of the [DataSource] object that is submitted in the [CreateDatasetImportJob] request, and part of the [DataDestination] object.
        /// This member is required.
        public var s3Config: ForecastClientTypes.S3Config?
        /// Defines the fields of a dataset.
        /// This member is required.
        public var schema: ForecastClientTypes.Schema?
        /// The timestamp format of the replacement data.
        public var timestampFormat: Swift.String?

        public init(
            format: Swift.String? = nil,
            s3Config: ForecastClientTypes.S3Config? = nil,
            schema: ForecastClientTypes.Schema? = nil,
            timestampFormat: Swift.String? = nil
        )
        {
            self.format = format
            self.s3Config = s3Config
            self.schema = schema
            self.timestampFormat = timestampFormat
        }
    }

}

extension ForecastClientTypes {

    public enum Condition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case greaterThan
        case lessThan
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [Condition] {
            return [
                .equals,
                .greaterThan,
                .lessThan,
                .notEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {
    /// Creates a subset of items within an attribute that are modified. For example, you can use this operation to create a subset of items that cost $5 or less. To do this, you specify "AttributeName": "price", "AttributeValue": "5", and "Condition": "LESS_THAN". Pair this operation with the [Action] operation within the [CreateWhatIfForecastRequest$TimeSeriesTransformations] operation to define how the attribute is modified.
    public struct TimeSeriesCondition {
        /// The item_id, dimension name, IM name, or timestamp that you are modifying.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The value that is applied for the chosen Condition.
        /// This member is required.
        public var attributeValue: Swift.String?
        /// The condition to apply. Valid values are EQUALS, NOT_EQUALS, LESS_THAN and GREATER_THAN.
        /// This member is required.
        public var condition: ForecastClientTypes.Condition?

        public init(
            attributeName: Swift.String? = nil,
            attributeValue: Swift.String? = nil,
            condition: ForecastClientTypes.Condition? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
            self.condition = condition
        }
    }

}

extension ForecastClientTypes {
    /// A transformation function is a pair of operations that select and modify the rows in a related time series. You select the rows that you want with a condition operation and you modify the rows with a transformation operation. All conditions are joined with an AND operation, meaning that all conditions must be true for the transformation to be applied. Transformations are applied in the order that they are listed.
    public struct TimeSeriesTransformation {
        /// An array of actions that define a time series and how it is transformed. These transformations create a new time series that is used for the what-if analysis.
        public var action: ForecastClientTypes.Action?
        /// An array of conditions that define which members of the related time series are transformed.
        public var timeSeriesConditions: [ForecastClientTypes.TimeSeriesCondition]?

        public init(
            action: ForecastClientTypes.Action? = nil,
            timeSeriesConditions: [ForecastClientTypes.TimeSeriesCondition]? = nil
        )
        {
            self.action = action
            self.timeSeriesConditions = timeSeriesConditions
        }
    }

}

public struct CreateWhatIfForecastInput {
    /// A list of [tags](https://docs.aws.amazon.com/forecast/latest/dg/tagging-forecast-resources.html) to apply to the what if forecast.
    public var tags: [ForecastClientTypes.Tag]?
    /// The replacement time series dataset, which contains the rows that you want to change in the related time series dataset. A replacement time series does not need to contain all rows that are in the baseline related time series. Include only the rows (measure-dimension combinations) that you want to include in the what-if forecast. This dataset is merged with the original time series to create a transformed dataset that is used for the what-if analysis. This dataset should contain the items to modify (such as item_id or workforce_type), any relevant dimensions, the timestamp column, and at least one of the related time series columns. This file should not contain duplicate timestamps for the same time series. Timestamps and item_ids not included in this dataset are not included in the what-if analysis.
    public var timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource?
    /// The transformations that are applied to the baseline time series. Each transformation contains an action and a set of conditions. An action is applied only when all conditions are met. If no conditions are provided, the action is applied to all items.
    public var timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]?
    /// The Amazon Resource Name (ARN) of the what-if analysis.
    /// This member is required.
    public var whatIfAnalysisArn: Swift.String?
    /// The name of the what-if forecast. Names must be unique within each what-if analysis.
    /// This member is required.
    public var whatIfForecastName: Swift.String?

    public init(
        tags: [ForecastClientTypes.Tag]? = nil,
        timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource? = nil,
        timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]? = nil,
        whatIfAnalysisArn: Swift.String? = nil,
        whatIfForecastName: Swift.String? = nil
    )
    {
        self.tags = tags
        self.timeSeriesReplacementsDataSource = timeSeriesReplacementsDataSource
        self.timeSeriesTransformations = timeSeriesTransformations
        self.whatIfAnalysisArn = whatIfAnalysisArn
        self.whatIfForecastName = whatIfForecastName
    }
}

public struct CreateWhatIfForecastOutput {
    /// The Amazon Resource Name (ARN) of the what-if forecast.
    public var whatIfForecastArn: Swift.String?

    public init(
        whatIfForecastArn: Swift.String? = nil
    )
    {
        self.whatIfForecastArn = whatIfForecastArn
    }
}

public struct CreateWhatIfForecastExportInput {
    /// The location where you want to save the forecast and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the location. The forecast must be exported to an Amazon S3 bucket. If encryption is used, Destination must include an Key Management Service (KMS) key. The IAM role must allow Amazon Forecast permission to access the key.
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/forecast/latest/dg/tagging-forecast-resources.html) to apply to the what if forecast.
    public var tags: [ForecastClientTypes.Tag]?
    /// The list of what-if forecast Amazon Resource Names (ARNs) to export.
    /// This member is required.
    public var whatIfForecastArns: [Swift.String]?
    /// The name of the what-if forecast to export.
    /// This member is required.
    public var whatIfForecastExportName: Swift.String?

    public init(
        destination: ForecastClientTypes.DataDestination? = nil,
        format: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        whatIfForecastArns: [Swift.String]? = nil,
        whatIfForecastExportName: Swift.String? = nil
    )
    {
        self.destination = destination
        self.format = format
        self.tags = tags
        self.whatIfForecastArns = whatIfForecastArns
        self.whatIfForecastExportName = whatIfForecastExportName
    }
}

public struct CreateWhatIfForecastExportOutput {
    /// The Amazon Resource Name (ARN) of the what-if forecast.
    public var whatIfForecastExportArn: Swift.String?

    public init(
        whatIfForecastExportArn: Swift.String? = nil
    )
    {
        self.whatIfForecastExportArn = whatIfForecastExportArn
    }
}

public struct DeleteDatasetInput {
    /// The Amazon Resource Name (ARN) of the dataset to delete.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

public struct DeleteDatasetGroupInput {
    /// The Amazon Resource Name (ARN) of the dataset group to delete.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

public struct DeleteDatasetImportJobInput {
    /// The Amazon Resource Name (ARN) of the dataset import job to delete.
    /// This member is required.
    public var datasetImportJobArn: Swift.String?

    public init(
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

public struct DeleteExplainabilityInput {
    /// The Amazon Resource Name (ARN) of the Explainability resource to delete.
    /// This member is required.
    public var explainabilityArn: Swift.String?

    public init(
        explainabilityArn: Swift.String? = nil
    )
    {
        self.explainabilityArn = explainabilityArn
    }
}

public struct DeleteExplainabilityExportInput {
    /// The Amazon Resource Name (ARN) of the Explainability export to delete.
    /// This member is required.
    public var explainabilityExportArn: Swift.String?

    public init(
        explainabilityExportArn: Swift.String? = nil
    )
    {
        self.explainabilityExportArn = explainabilityExportArn
    }
}

public struct DeleteForecastInput {
    /// The Amazon Resource Name (ARN) of the forecast to delete.
    /// This member is required.
    public var forecastArn: Swift.String?

    public init(
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

public struct DeleteForecastExportJobInput {
    /// The Amazon Resource Name (ARN) of the forecast export job to delete.
    /// This member is required.
    public var forecastExportJobArn: Swift.String?

    public init(
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

public struct DeleteMonitorInput {
    /// The Amazon Resource Name (ARN) of the monitor resource to delete.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init(
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

public struct DeletePredictorInput {
    /// The Amazon Resource Name (ARN) of the predictor to delete.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init(
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

public struct DeletePredictorBacktestExportJobInput {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job to delete.
    /// This member is required.
    public var predictorBacktestExportJobArn: Swift.String?

    public init(
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

public struct DeleteResourceTreeInput {
    /// The Amazon Resource Name (ARN) of the parent resource to delete. All child resources of the parent resource will also be deleted.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct DeleteWhatIfAnalysisInput {
    /// The Amazon Resource Name (ARN) of the what-if analysis that you want to delete.
    /// This member is required.
    public var whatIfAnalysisArn: Swift.String?

    public init(
        whatIfAnalysisArn: Swift.String? = nil
    )
    {
        self.whatIfAnalysisArn = whatIfAnalysisArn
    }
}

public struct DeleteWhatIfForecastInput {
    /// The Amazon Resource Name (ARN) of the what-if forecast that you want to delete.
    /// This member is required.
    public var whatIfForecastArn: Swift.String?

    public init(
        whatIfForecastArn: Swift.String? = nil
    )
    {
        self.whatIfForecastArn = whatIfForecastArn
    }
}

public struct DeleteWhatIfForecastExportInput {
    /// The Amazon Resource Name (ARN) of the what-if forecast export that you want to delete.
    /// This member is required.
    public var whatIfForecastExportArn: Swift.String?

    public init(
        whatIfForecastExportArn: Swift.String? = nil
    )
    {
        self.whatIfForecastExportArn = whatIfForecastExportArn
    }
}

public struct DescribeAutoPredictorInput {
    /// The Amazon Resource Name (ARN) of the predictor.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init(
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

extension ForecastClientTypes {
    /// Provides information about the Explainability resource.
    public struct ExplainabilityInfo {
        /// The Amazon Resource Name (ARN) of the Explainability.
        public var explainabilityArn: Swift.String?
        /// The status of the Explainability. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init(
            explainabilityArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.explainabilityArn = explainabilityArn
            self.status = status
        }
    }

}

extension ForecastClientTypes {
    /// Provides information about the monitor resource.
    public struct MonitorInfo {
        /// The Amazon Resource Name (ARN) of the monitor resource.
        public var monitorArn: Swift.String?
        /// The status of the monitor. States include:
        ///
        /// * ACTIVE
        ///
        /// * ACTIVE_STOPPING, ACTIVE_STOPPED
        ///
        /// * UPDATE_IN_PROGRESS
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init(
            monitorArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.monitorArn = monitorArn
            self.status = status
        }
    }

}

extension ForecastClientTypes {

    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .deleted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleted: return "Deleted"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the reference predictor used when retraining or upgrading a predictor.
    public struct ReferencePredictorSummary {
        /// The ARN of the reference predictor.
        public var arn: Swift.String?
        /// Whether the reference predictor is Active or Deleted.
        public var state: ForecastClientTypes.State?

        public init(
            arn: Swift.String? = nil,
            state: ForecastClientTypes.State? = nil
        )
        {
            self.arn = arn
            self.state = state
        }
    }

}

public struct DescribeAutoPredictorOutput {
    /// The timestamp of the CreateAutoPredictor request.
    public var creationTime: Foundation.Date?
    /// The data configuration for your dataset group and any additional datasets.
    public var dataConfig: ForecastClientTypes.DataConfig?
    /// An array of the ARNs of the dataset import jobs used to import training data for the predictor.
    public var datasetImportJobArns: [Swift.String]?
    /// An Key Management Service (KMS) key and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key. You can specify this optional object in the [CreateDataset] and [CreatePredictor] requests.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// The estimated time remaining in minutes for the predictor training job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// Provides the status and ARN of the Predictor Explainability.
    public var explainabilityInfo: ForecastClientTypes.ExplainabilityInfo?
    /// An array of dimension (field) names that specify the attributes used to group your time series.
    public var forecastDimensions: [Swift.String]?
    /// The frequency of predictions in a forecast. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes.
    public var forecastFrequency: Swift.String?
    /// The number of time-steps that the model predicts. The forecast horizon is also called the prediction length.
    public var forecastHorizon: Swift.Int?
    /// The forecast types used during predictor training. Default value is ["0.1","0.5","0.9"].
    public var forecastTypes: [Swift.String]?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: Foundation.Date?
    /// In the event of an error, a message detailing the cause of the error.
    public var message: Swift.String?
    /// A object with the Amazon Resource Name (ARN) and status of the monitor resource.
    public var monitorInfo: ForecastClientTypes.MonitorInfo?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// The Amazon Resource Name (ARN) of the predictor
    public var predictorArn: Swift.String?
    /// The name of the predictor.
    public var predictorName: Swift.String?
    /// The ARN and state of the reference predictor. This parameter is only valid for retrained or upgraded predictors.
    public var referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary?
    /// The status of the predictor. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?
    /// The time boundary Forecast uses when aggregating data.
    public var timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary?

    public init(
        creationTime: Foundation.Date? = nil,
        dataConfig: ForecastClientTypes.DataConfig? = nil,
        datasetImportJobArns: [Swift.String]? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        explainabilityInfo: ForecastClientTypes.ExplainabilityInfo? = nil,
        forecastDimensions: [Swift.String]? = nil,
        forecastFrequency: Swift.String? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        lastModificationTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        monitorInfo: ForecastClientTypes.MonitorInfo? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        predictorArn: Swift.String? = nil,
        predictorName: Swift.String? = nil,
        referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary? = nil,
        status: Swift.String? = nil,
        timeAlignmentBoundary: ForecastClientTypes.TimeAlignmentBoundary? = nil
    )
    {
        self.creationTime = creationTime
        self.dataConfig = dataConfig
        self.datasetImportJobArns = datasetImportJobArns
        self.encryptionConfig = encryptionConfig
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.explainabilityInfo = explainabilityInfo
        self.forecastDimensions = forecastDimensions
        self.forecastFrequency = forecastFrequency
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.monitorInfo = monitorInfo
        self.optimizationMetric = optimizationMetric
        self.predictorArn = predictorArn
        self.predictorName = predictorName
        self.referencePredictorSummary = referencePredictorSummary
        self.status = status
        self.timeAlignmentBoundary = timeAlignmentBoundary
    }
}

public struct DescribeDatasetInput {
    /// The Amazon Resource Name (ARN) of the dataset.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

public struct DescribeDatasetOutput {
    /// When the dataset was created.
    public var creationTime: Foundation.Date?
    /// The frequency of data collection. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "M" indicates every month and "30min" indicates every 30 minutes.
    public var dataFrequency: Swift.String?
    /// The Amazon Resource Name (ARN) of the dataset.
    public var datasetArn: Swift.String?
    /// The name of the dataset.
    public var datasetName: Swift.String?
    /// The dataset type.
    public var datasetType: ForecastClientTypes.DatasetType?
    /// The domain associated with the dataset.
    public var domain: ForecastClientTypes.Domain?
    /// The Key Management Service (KMS) key and the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// When you create a dataset, LastModificationTime is the same as CreationTime. While data is being imported to the dataset, LastModificationTime is the current time of the DescribeDataset call. After a [CreateDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html) operation has finished, LastModificationTime is when the import job completed or failed.
    public var lastModificationTime: Foundation.Date?
    /// An array of SchemaAttribute objects that specify the dataset fields. Each SchemaAttribute specifies the name and data type of a field.
    public var schema: ForecastClientTypes.Schema?
    /// The status of the dataset. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED
    ///
    ///
    /// The UPDATE states apply while data is imported to the dataset from a call to the [CreateDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html) operation and reflect the status of the dataset import job. For example, when the import job status is CREATE_IN_PROGRESS, the status of the dataset is UPDATE_IN_PROGRESS. The Status of the dataset must be ACTIVE before you can import training data.
    public var status: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        dataFrequency: Swift.String? = nil,
        datasetArn: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        datasetType: ForecastClientTypes.DatasetType? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        lastModificationTime: Foundation.Date? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.dataFrequency = dataFrequency
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.datasetType = datasetType
        self.domain = domain
        self.encryptionConfig = encryptionConfig
        self.lastModificationTime = lastModificationTime
        self.schema = schema
        self.status = status
    }
}

public struct DescribeDatasetGroupInput {
    /// The Amazon Resource Name (ARN) of the dataset group.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

public struct DescribeDatasetGroupOutput {
    /// When the dataset group was created.
    public var creationTime: Foundation.Date?
    /// An array of Amazon Resource Names (ARNs) of the datasets contained in the dataset group.
    public var datasetArns: [Swift.String]?
    /// The ARN of the dataset group.
    public var datasetGroupArn: Swift.String?
    /// The name of the dataset group.
    public var datasetGroupName: Swift.String?
    /// The domain associated with the dataset group.
    public var domain: ForecastClientTypes.Domain?
    /// When the dataset group was created or last updated from a call to the [UpdateDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_UpdateDatasetGroup.html) operation. While the dataset group is being updated, LastModificationTime is the current time of the DescribeDatasetGroup call.
    public var lastModificationTime: Foundation.Date?
    /// The status of the dataset group. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED
    ///
    ///
    /// The UPDATE states apply when you call the [UpdateDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_UpdateDatasetGroup.html) operation. The Status of the dataset group must be ACTIVE before you can use the dataset group to create a predictor.
    public var status: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        datasetArns: [Swift.String]? = nil,
        datasetGroupArn: Swift.String? = nil,
        datasetGroupName: Swift.String? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        lastModificationTime: Foundation.Date? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetArns = datasetArns
        self.datasetGroupArn = datasetGroupArn
        self.datasetGroupName = datasetGroupName
        self.domain = domain
        self.lastModificationTime = lastModificationTime
        self.status = status
    }
}

public struct DescribeDatasetImportJobInput {
    /// The Amazon Resource Name (ARN) of the dataset import job.
    /// This member is required.
    public var datasetImportJobArn: Swift.String?

    public init(
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

extension ForecastClientTypes {
    /// Provides statistics for each data field imported into to an Amazon Forecast dataset with the [CreateDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html) operation.
    public struct Statistics {
        /// For a numeric field, the average value in the field.
        public var avg: Swift.Double?
        /// The number of values in the field. If the response value is -1, refer to CountLong.
        public var count: Swift.Int?
        /// The number of distinct values in the field. If the response value is -1, refer to CountDistinctLong.
        public var countDistinct: Swift.Int?
        /// The number of distinct values in the field. CountDistinctLong is used instead of CountDistinct if the value is greater than 2,147,483,647.
        public var countDistinctLong: Swift.Int?
        /// The number of values in the field. CountLong is used instead of Count if the value is greater than 2,147,483,647.
        public var countLong: Swift.Int?
        /// The number of NAN (not a number) values in the field. If the response value is -1, refer to CountNanLong.
        public var countNan: Swift.Int?
        /// The number of NAN (not a number) values in the field. CountNanLong is used instead of CountNan if the value is greater than 2,147,483,647.
        public var countNanLong: Swift.Int?
        /// The number of null values in the field. If the response value is -1, refer to CountNullLong.
        public var countNull: Swift.Int?
        /// The number of null values in the field. CountNullLong is used instead of CountNull if the value is greater than 2,147,483,647.
        public var countNullLong: Swift.Int?
        /// For a numeric field, the maximum value in the field.
        public var max: Swift.String?
        /// For a numeric field, the minimum value in the field.
        public var min: Swift.String?
        /// For a numeric field, the standard deviation.
        public var stddev: Swift.Double?

        public init(
            avg: Swift.Double? = nil,
            count: Swift.Int? = nil,
            countDistinct: Swift.Int? = nil,
            countDistinctLong: Swift.Int? = nil,
            countLong: Swift.Int? = nil,
            countNan: Swift.Int? = nil,
            countNanLong: Swift.Int? = nil,
            countNull: Swift.Int? = nil,
            countNullLong: Swift.Int? = nil,
            max: Swift.String? = nil,
            min: Swift.String? = nil,
            stddev: Swift.Double? = nil
        )
        {
            self.avg = avg
            self.count = count
            self.countDistinct = countDistinct
            self.countDistinctLong = countDistinctLong
            self.countLong = countLong
            self.countNan = countNan
            self.countNanLong = countNanLong
            self.countNull = countNull
            self.countNullLong = countNullLong
            self.max = max
            self.min = min
            self.stddev = stddev
        }
    }

}

public struct DescribeDatasetImportJobOutput {
    /// When the dataset import job was created.
    public var creationTime: Foundation.Date?
    /// The size of the dataset in gigabytes (GB) after the import job has finished.
    public var dataSize: Swift.Double?
    /// The location of the training data to import and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. If encryption is used, DataSource includes an Key Management Service (KMS) key.
    public var dataSource: ForecastClientTypes.DataSource?
    /// The Amazon Resource Name (ARN) of the dataset that the training data was imported to.
    public var datasetArn: Swift.String?
    /// The ARN of the dataset import job.
    public var datasetImportJobArn: Swift.String?
    /// The name of the dataset import job.
    public var datasetImportJobName: Swift.String?
    /// The estimated time remaining in minutes for the dataset import job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// Statistical information about each field in the input data.
    public var fieldStatistics: [Swift.String: ForecastClientTypes.Statistics]?
    /// The format of the imported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The format of the geolocation attribute. Valid Values:"LAT_LONG" and "CC_POSTALCODE".
    public var geolocationFormat: Swift.String?
    /// The import mode of the dataset import job, FULL or INCREMENTAL.
    public var importMode: ForecastClientTypes.ImportMode?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: Foundation.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the dataset import job. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    public var status: Swift.String?
    /// The single time zone applied to every item in the dataset
    public var timeZone: Swift.String?
    /// The format of timestamps in the dataset. The format that you specify depends on the DataFrequency specified when the dataset was created. The following formats are supported
    ///
    /// * "yyyy-MM-dd" For the following data frequencies: Y, M, W, and D
    ///
    /// * "yyyy-MM-dd HH:mm:ss" For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y, M, W, and D
    public var timestampFormat: Swift.String?
    /// Whether TimeZone is automatically derived from the geolocation attribute.
    public var useGeolocationForTimeZone: Swift.Bool

    public init(
        creationTime: Foundation.Date? = nil,
        dataSize: Swift.Double? = nil,
        dataSource: ForecastClientTypes.DataSource? = nil,
        datasetArn: Swift.String? = nil,
        datasetImportJobArn: Swift.String? = nil,
        datasetImportJobName: Swift.String? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        fieldStatistics: [Swift.String: ForecastClientTypes.Statistics]? = nil,
        format: Swift.String? = nil,
        geolocationFormat: Swift.String? = nil,
        importMode: ForecastClientTypes.ImportMode? = nil,
        lastModificationTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil,
        timeZone: Swift.String? = nil,
        timestampFormat: Swift.String? = nil,
        useGeolocationForTimeZone: Swift.Bool = false
    )
    {
        self.creationTime = creationTime
        self.dataSize = dataSize
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.datasetImportJobArn = datasetImportJobArn
        self.datasetImportJobName = datasetImportJobName
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.fieldStatistics = fieldStatistics
        self.format = format
        self.geolocationFormat = geolocationFormat
        self.importMode = importMode
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.timeZone = timeZone
        self.timestampFormat = timestampFormat
        self.useGeolocationForTimeZone = useGeolocationForTimeZone
    }
}

public struct DescribeExplainabilityInput {
    /// The Amazon Resource Name (ARN) of the Explaianability to describe.
    /// This member is required.
    public var explainabilityArn: Swift.String?

    public init(
        explainabilityArn: Swift.String? = nil
    )
    {
        self.explainabilityArn = explainabilityArn
    }
}

public struct DescribeExplainabilityOutput {
    /// When the Explainability resource was created.
    public var creationTime: Foundation.Date?
    /// The source of your data, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an Key Management Service (KMS) key.
    public var dataSource: ForecastClientTypes.DataSource?
    /// Whether the visualization was enabled for the Explainability resource.
    public var enableVisualization: Swift.Bool?
    /// If TimePointGranularity is set to SPECIFIC, the last time point in the Explainability.
    public var endDateTime: Swift.String?
    /// The estimated time remaining in minutes for the [CreateExplainability] job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The Amazon Resource Name (ARN) of the Explainability.
    public var explainabilityArn: Swift.String?
    /// The configuration settings that define the granularity of time series and time points for the Explainability.
    public var explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
    /// The name of the Explainability.
    public var explainabilityName: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: Foundation.Date?
    /// If an error occurred, a message about the error.
    public var message: Swift.String?
    /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability resource.
    public var resourceArn: Swift.String?
    /// Defines the fields of a dataset.
    public var schema: ForecastClientTypes.Schema?
    /// If TimePointGranularity is set to SPECIFIC, the first time point in the Explainability.
    public var startDateTime: Swift.String?
    /// The status of the Explainability resource. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        dataSource: ForecastClientTypes.DataSource? = nil,
        enableVisualization: Swift.Bool? = nil,
        endDateTime: Swift.String? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        explainabilityArn: Swift.String? = nil,
        explainabilityConfig: ForecastClientTypes.ExplainabilityConfig? = nil,
        explainabilityName: Swift.String? = nil,
        lastModificationTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        startDateTime: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.dataSource = dataSource
        self.enableVisualization = enableVisualization
        self.endDateTime = endDateTime
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.explainabilityArn = explainabilityArn
        self.explainabilityConfig = explainabilityConfig
        self.explainabilityName = explainabilityName
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.resourceArn = resourceArn
        self.schema = schema
        self.startDateTime = startDateTime
        self.status = status
    }
}

public struct DescribeExplainabilityExportInput {
    /// The Amazon Resource Name (ARN) of the Explainability export.
    /// This member is required.
    public var explainabilityExportArn: Swift.String?

    public init(
        explainabilityExportArn: Swift.String? = nil
    )
    {
        self.explainabilityExportArn = explainabilityExportArn
    }
}

public struct DescribeExplainabilityExportOutput {
    /// When the Explainability export was created.
    public var creationTime: Foundation.Date?
    /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the Explainability export.
    public var explainabilityArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the Explainability export.
    public var explainabilityExportArn: Swift.String?
    /// The name of the Explainability export.
    public var explainabilityExportName: Swift.String?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: Foundation.Date?
    /// Information about any errors that occurred during the export.
    public var message: Swift.String?
    /// The status of the Explainability export. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        explainabilityArn: Swift.String? = nil,
        explainabilityExportArn: Swift.String? = nil,
        explainabilityExportName: Swift.String? = nil,
        format: Swift.String? = nil,
        lastModificationTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.explainabilityArn = explainabilityArn
        self.explainabilityExportArn = explainabilityExportArn
        self.explainabilityExportName = explainabilityExportName
        self.format = format
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
    }
}

public struct DescribeForecastInput {
    /// The Amazon Resource Name (ARN) of the forecast.
    /// This member is required.
    public var forecastArn: Swift.String?

    public init(
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

public struct DescribeForecastOutput {
    /// When the forecast creation task was created.
    public var creationTime: Foundation.Date?
    /// The ARN of the dataset group that provided the data used to train the predictor.
    public var datasetGroupArn: Swift.String?
    /// The estimated time remaining in minutes for the forecast job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The forecast ARN as specified in the request.
    public var forecastArn: Swift.String?
    /// The name of the forecast.
    public var forecastName: Swift.String?
    /// The quantiles at which probabilistic forecasts were generated.
    public var forecastTypes: [Swift.String]?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: Foundation.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The ARN of the predictor used to generate the forecast.
    public var predictorArn: Swift.String?
    /// The status of the forecast. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the forecast must be ACTIVE before you can query or export the forecast.
    public var status: Swift.String?
    /// The time series to include in the forecast.
    public var timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?

    public init(
        creationTime: Foundation.Date? = nil,
        datasetGroupArn: Swift.String? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        forecastArn: Swift.String? = nil,
        forecastName: Swift.String? = nil,
        forecastTypes: [Swift.String]? = nil,
        lastModificationTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        predictorArn: Swift.String? = nil,
        status: Swift.String? = nil,
        timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetGroupArn = datasetGroupArn
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.forecastArn = forecastArn
        self.forecastName = forecastName
        self.forecastTypes = forecastTypes
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorArn = predictorArn
        self.status = status
        self.timeSeriesSelector = timeSeriesSelector
    }
}

public struct DescribeForecastExportJobInput {
    /// The Amazon Resource Name (ARN) of the forecast export job.
    /// This member is required.
    public var forecastExportJobArn: Swift.String?

    public init(
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

public struct DescribeForecastExportJobOutput {
    /// When the forecast export job was created.
    public var creationTime: Foundation.Date?
    /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the exported forecast.
    public var forecastArn: Swift.String?
    /// The ARN of the forecast export job.
    public var forecastExportJobArn: Swift.String?
    /// The name of the forecast export job.
    public var forecastExportJobName: Swift.String?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: Foundation.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the forecast export job. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the forecast export job must be ACTIVE before you can access the forecast in your S3 bucket.
    public var status: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        forecastArn: Swift.String? = nil,
        forecastExportJobArn: Swift.String? = nil,
        forecastExportJobName: Swift.String? = nil,
        format: Swift.String? = nil,
        lastModificationTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.forecastArn = forecastArn
        self.forecastExportJobArn = forecastExportJobArn
        self.forecastExportJobName = forecastExportJobName
        self.format = format
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
    }
}

public struct DescribeMonitorInput {
    /// The Amazon Resource Name (ARN) of the monitor resource to describe.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init(
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

extension ForecastClientTypes {
    /// An individual metric that you can use for comparison as you evaluate your monitoring results.
    public struct BaselineMetric {
        /// The name of the metric.
        public var name: Swift.String?
        /// The value for the metric.
        public var value: Swift.Double?

        public init(
            name: Swift.String? = nil,
            value: Swift.Double? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ForecastClientTypes {
    /// Metrics you can use as a baseline for comparison purposes. Use these metrics when you interpret monitoring results for an auto predictor.
    public struct PredictorBaseline {
        /// The initial [accuracy metrics](https://docs.aws.amazon.com/forecast/latest/dg/metrics.html) for the predictor. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.
        public var baselineMetrics: [ForecastClientTypes.BaselineMetric]?

        public init(
            baselineMetrics: [ForecastClientTypes.BaselineMetric]? = nil
        )
        {
            self.baselineMetrics = baselineMetrics
        }
    }

}

extension ForecastClientTypes {
    /// Metrics you can use as a baseline for comparison purposes. Use these metrics when you interpret monitoring results for an auto predictor.
    public struct Baseline {
        /// The initial [accuracy metrics](https://docs.aws.amazon.com/forecast/latest/dg/metrics.html) for the predictor you are monitoring. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.
        public var predictorBaseline: ForecastClientTypes.PredictorBaseline?

        public init(
            predictorBaseline: ForecastClientTypes.PredictorBaseline? = nil
        )
        {
            self.predictorBaseline = predictorBaseline
        }
    }

}

public struct DescribeMonitorOutput {
    /// Metrics you can use as a baseline for comparison purposes. Use these values you interpret monitoring results for an auto predictor.
    public var baseline: ForecastClientTypes.Baseline?
    /// The timestamp for when the monitor resource was created.
    public var creationTime: Foundation.Date?
    /// The estimated number of minutes remaining before the monitor resource finishes its current evaluation.
    public var estimatedEvaluationTimeRemainingInMinutes: Swift.Int?
    /// The state of the monitor's latest evaluation.
    public var lastEvaluationState: Swift.String?
    /// The timestamp of the latest evaluation completed by the monitor.
    public var lastEvaluationTime: Foundation.Date?
    /// The timestamp of the latest modification to the monitor.
    public var lastModificationTime: Foundation.Date?
    /// An error message, if any, for the monitor.
    public var message: Swift.String?
    /// The Amazon Resource Name (ARN) of the monitor resource described.
    public var monitorArn: Swift.String?
    /// The name of the monitor.
    public var monitorName: Swift.String?
    /// The Amazon Resource Name (ARN) of the auto predictor being monitored.
    public var resourceArn: Swift.String?
    /// The status of the monitor resource.
    public var status: Swift.String?

    public init(
        baseline: ForecastClientTypes.Baseline? = nil,
        creationTime: Foundation.Date? = nil,
        estimatedEvaluationTimeRemainingInMinutes: Swift.Int? = nil,
        lastEvaluationState: Swift.String? = nil,
        lastEvaluationTime: Foundation.Date? = nil,
        lastModificationTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.baseline = baseline
        self.creationTime = creationTime
        self.estimatedEvaluationTimeRemainingInMinutes = estimatedEvaluationTimeRemainingInMinutes
        self.lastEvaluationState = lastEvaluationState
        self.lastEvaluationTime = lastEvaluationTime
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.monitorArn = monitorArn
        self.monitorName = monitorName
        self.resourceArn = resourceArn
        self.status = status
    }
}

public struct DescribePredictorInput {
    /// The Amazon Resource Name (ARN) of the predictor that you want information about.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init(
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

extension ForecastClientTypes {
    /// The status, start time, and end time of a backtest, as well as a failure reason if applicable.
    public struct TestWindowSummary {
        /// If the test failed, the reason why it failed.
        public var message: Swift.String?
        /// The status of the test. Possible status values are:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_IN_PROGRESS
        ///
        /// * CREATE_FAILED
        public var status: Swift.String?
        /// The time at which the test ended.
        public var testWindowEnd: Foundation.Date?
        /// The time at which the test began.
        public var testWindowStart: Foundation.Date?

        public init(
            message: Swift.String? = nil,
            status: Swift.String? = nil,
            testWindowEnd: Foundation.Date? = nil,
            testWindowStart: Foundation.Date? = nil
        )
        {
            self.message = message
            self.status = status
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }
    }

}

extension ForecastClientTypes {
    /// The algorithm used to perform a backtest and the status of those tests.
    public struct PredictorExecution {
        /// The ARN of the algorithm used to test the predictor.
        public var algorithmArn: Swift.String?
        /// An array of test windows used to evaluate the algorithm. The NumberOfBacktestWindows from the object determines the number of windows in the array.
        public var testWindows: [ForecastClientTypes.TestWindowSummary]?

        public init(
            algorithmArn: Swift.String? = nil,
            testWindows: [ForecastClientTypes.TestWindowSummary]? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }
    }

}

extension ForecastClientTypes {
    /// Contains details on the backtests performed to evaluate the accuracy of the predictor. The tests are returned in descending order of accuracy, with the most accurate backtest appearing first. You specify the number of backtests to perform when you call the operation.
    public struct PredictorExecutionDetails {
        /// An array of the backtests performed to evaluate the accuracy of the predictor against a particular algorithm. The NumberOfBacktestWindows from the object determines the number of windows in the array.
        public var predictorExecutions: [ForecastClientTypes.PredictorExecution]?

        public init(
            predictorExecutions: [ForecastClientTypes.PredictorExecution]? = nil
        )
        {
            self.predictorExecutions = predictorExecutions
        }
    }

}

public struct DescribePredictorOutput {
    /// The Amazon Resource Name (ARN) of the algorithm used for model training.
    public var algorithmArn: Swift.String?
    /// When PerformAutoML is specified, the ARN of the chosen algorithm.
    public var autoMLAlgorithmArns: [Swift.String]?
    /// The LatencyOptimized AutoML override strategy is only available in private beta. Contact Amazon Web Services Support or your account manager to learn more about access privileges. The AutoML strategy used to train the predictor. Unless LatencyOptimized is specified, the AutoML strategy optimizes predictor accuracy. This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// When the model training task was created.
    public var creationTime: Foundation.Date?
    /// An array of the ARNs of the dataset import jobs used to import training data for the predictor.
    public var datasetImportJobArns: [Swift.String]?
    /// An Key Management Service (KMS) key and the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// The estimated time remaining in minutes for the predictor training job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast evaluates a predictor by splitting a dataset into training data and testing data. The evaluation parameters define how to perform the split and the number of iterations.
    public var evaluationParameters: ForecastClientTypes.EvaluationParameters?
    /// The featurization configuration.
    public var featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    /// The number of time-steps of the forecast. The forecast horizon is also called the prediction length.
    public var forecastHorizon: Swift.Int?
    /// The forecast types used during predictor training. Default value is ["0.1","0.5","0.9"]
    public var forecastTypes: [Swift.String]?
    /// The hyperparameter override values for the algorithm.
    public var hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    /// Describes the dataset group that contains the data to use to train the predictor.
    public var inputDataConfig: ForecastClientTypes.InputDataConfig?
    /// Whether the predictor was created with [CreateAutoPredictor].
    public var isAutoPredictor: Swift.Bool?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: Foundation.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// Whether the predictor is set to perform AutoML.
    public var performAutoML: Swift.Bool?
    /// Whether the predictor is set to perform hyperparameter optimization (HPO).
    public var performHPO: Swift.Bool?
    /// The ARN of the predictor.
    public var predictorArn: Swift.String?
    /// Details on the the status and results of the backtests performed to evaluate the accuracy of the predictor. You specify the number of backtests to perform when you call the operation.
    public var predictorExecutionDetails: ForecastClientTypes.PredictorExecutionDetails?
    /// The name of the predictor.
    public var predictorName: Swift.String?
    /// The status of the predictor. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    ///
    /// The Status of the predictor must be ACTIVE before you can use the predictor to create a forecast.
    public var status: Swift.String?
    /// The default training parameters or overrides selected during model training. When running AutoML or choosing HPO with CNN-QR or DeepAR+, the optimized values for the chosen hyperparameters are returned. For more information, see [aws-forecast-choosing-recipes].
    public var trainingParameters: [Swift.String: Swift.String]?

    public init(
        algorithmArn: Swift.String? = nil,
        autoMLAlgorithmArns: [Swift.String]? = nil,
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        creationTime: Foundation.Date? = nil,
        datasetImportJobArns: [Swift.String]? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        evaluationParameters: ForecastClientTypes.EvaluationParameters? = nil,
        featurizationConfig: ForecastClientTypes.FeaturizationConfig? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        hpoConfig: ForecastClientTypes.HyperParameterTuningJobConfig? = nil,
        inputDataConfig: ForecastClientTypes.InputDataConfig? = nil,
        isAutoPredictor: Swift.Bool? = nil,
        lastModificationTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        performAutoML: Swift.Bool? = nil,
        performHPO: Swift.Bool? = nil,
        predictorArn: Swift.String? = nil,
        predictorExecutionDetails: ForecastClientTypes.PredictorExecutionDetails? = nil,
        predictorName: Swift.String? = nil,
        status: Swift.String? = nil,
        trainingParameters: [Swift.String: Swift.String]? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.autoMLAlgorithmArns = autoMLAlgorithmArns
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.creationTime = creationTime
        self.datasetImportJobArns = datasetImportJobArns
        self.encryptionConfig = encryptionConfig
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.evaluationParameters = evaluationParameters
        self.featurizationConfig = featurizationConfig
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.hpoConfig = hpoConfig
        self.inputDataConfig = inputDataConfig
        self.isAutoPredictor = isAutoPredictor
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.optimizationMetric = optimizationMetric
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.predictorArn = predictorArn
        self.predictorExecutionDetails = predictorExecutionDetails
        self.predictorName = predictorName
        self.status = status
        self.trainingParameters = trainingParameters
    }
}

public struct DescribePredictorBacktestExportJobInput {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job.
    /// This member is required.
    public var predictorBacktestExportJobArn: Swift.String?

    public init(
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

public struct DescribePredictorBacktestExportJobOutput {
    /// When the predictor backtest export job was created.
    public var creationTime: Foundation.Date?
    /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
    public var destination: ForecastClientTypes.DataDestination?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: Foundation.Date?
    /// Information about any errors that may have occurred during the backtest export.
    public var message: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor.
    public var predictorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor backtest export job.
    public var predictorBacktestExportJobArn: Swift.String?
    /// The name of the predictor backtest export job.
    public var predictorBacktestExportJobName: Swift.String?
    /// The status of the predictor backtest export job. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        format: Swift.String? = nil,
        lastModificationTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        predictorArn: Swift.String? = nil,
        predictorBacktestExportJobArn: Swift.String? = nil,
        predictorBacktestExportJobName: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.format = format
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorArn = predictorArn
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
        self.predictorBacktestExportJobName = predictorBacktestExportJobName
        self.status = status
    }
}

public struct DescribeWhatIfAnalysisInput {
    /// The Amazon Resource Name (ARN) of the what-if analysis that you are interested in.
    /// This member is required.
    public var whatIfAnalysisArn: Swift.String?

    public init(
        whatIfAnalysisArn: Swift.String? = nil
    )
    {
        self.whatIfAnalysisArn = whatIfAnalysisArn
    }
}

public struct DescribeWhatIfAnalysisOutput {
    /// When the what-if analysis was created.
    public var creationTime: Foundation.Date?
    /// The approximate time remaining to complete the what-if analysis, in minutes.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The Amazon Resource Name (ARN) of the what-if forecast.
    public var forecastArn: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: Foundation.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the what-if analysis. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the what-if analysis must be ACTIVE before you can access the analysis.
    public var status: Swift.String?
    /// Defines the set of time series that are used to create the forecasts in a TimeSeriesIdentifiers object. The TimeSeriesIdentifiers object needs the following information:
    ///
    /// * DataSource
    ///
    /// * Format
    ///
    /// * Schema
    public var timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector?
    /// The Amazon Resource Name (ARN) of the what-if analysis.
    public var whatIfAnalysisArn: Swift.String?
    /// The name of the what-if analysis.
    public var whatIfAnalysisName: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        forecastArn: Swift.String? = nil,
        lastModificationTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil,
        timeSeriesSelector: ForecastClientTypes.TimeSeriesSelector? = nil,
        whatIfAnalysisArn: Swift.String? = nil,
        whatIfAnalysisName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.forecastArn = forecastArn
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.timeSeriesSelector = timeSeriesSelector
        self.whatIfAnalysisArn = whatIfAnalysisArn
        self.whatIfAnalysisName = whatIfAnalysisName
    }
}

public struct DescribeWhatIfForecastInput {
    /// The Amazon Resource Name (ARN) of the what-if forecast that you are interested in.
    /// This member is required.
    public var whatIfForecastArn: Swift.String?

    public init(
        whatIfForecastArn: Swift.String? = nil
    )
    {
        self.whatIfForecastArn = whatIfForecastArn
    }
}

public struct DescribeWhatIfForecastOutput {
    /// When the what-if forecast was created.
    public var creationTime: Foundation.Date?
    /// The approximate time remaining to complete the what-if forecast, in minutes.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The quantiles at which probabilistic forecasts are generated. You can specify up to five quantiles per what-if forecast in the [CreateWhatIfForecast] operation. If you didn't specify quantiles, the default values are ["0.1", "0.5", "0.9"].
    public var forecastTypes: [Swift.String]?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: Foundation.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the what-if forecast. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the what-if forecast must be ACTIVE before you can access the forecast.
    public var status: Swift.String?
    /// An array of S3Config, Schema, and Format elements that describe the replacement time series.
    public var timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource?
    /// An array of Action and TimeSeriesConditions elements that describe what transformations were applied to which time series.
    public var timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]?
    /// The Amazon Resource Name (ARN) of the what-if analysis that contains this forecast.
    public var whatIfAnalysisArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the what-if forecast.
    public var whatIfForecastArn: Swift.String?
    /// The name of the what-if forecast.
    public var whatIfForecastName: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        lastModificationTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil,
        timeSeriesReplacementsDataSource: ForecastClientTypes.TimeSeriesReplacementsDataSource? = nil,
        timeSeriesTransformations: [ForecastClientTypes.TimeSeriesTransformation]? = nil,
        whatIfAnalysisArn: Swift.String? = nil,
        whatIfForecastArn: Swift.String? = nil,
        whatIfForecastName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.forecastTypes = forecastTypes
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.timeSeriesReplacementsDataSource = timeSeriesReplacementsDataSource
        self.timeSeriesTransformations = timeSeriesTransformations
        self.whatIfAnalysisArn = whatIfAnalysisArn
        self.whatIfForecastArn = whatIfForecastArn
        self.whatIfForecastName = whatIfForecastName
    }
}

public struct DescribeWhatIfForecastExportInput {
    /// The Amazon Resource Name (ARN) of the what-if forecast export that you are interested in.
    /// This member is required.
    public var whatIfForecastExportArn: Swift.String?

    public init(
        whatIfForecastExportArn: Swift.String? = nil
    )
    {
        self.whatIfForecastExportArn = whatIfForecastExportArn
    }
}

public struct DescribeWhatIfForecastExportOutput {
    /// When the what-if forecast export was created.
    public var creationTime: Foundation.Date?
    /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
    public var destination: ForecastClientTypes.DataDestination?
    /// The approximate time remaining to complete the what-if forecast export, in minutes.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The format of the exported data, CSV or PARQUET.
    public var format: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: Foundation.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the what-if forecast. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the what-if forecast export must be ACTIVE before you can access the forecast export.
    public var status: Swift.String?
    /// An array of Amazon Resource Names (ARNs) that represent all of the what-if forecasts exported in this resource.
    public var whatIfForecastArns: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the what-if forecast export.
    public var whatIfForecastExportArn: Swift.String?
    /// The name of the what-if forecast export.
    public var whatIfForecastExportName: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        format: Swift.String? = nil,
        lastModificationTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil,
        whatIfForecastArns: [Swift.String]? = nil,
        whatIfForecastExportArn: Swift.String? = nil,
        whatIfForecastExportName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.format = format
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.whatIfForecastArns = whatIfForecastArns
        self.whatIfForecastExportArn = whatIfForecastExportArn
        self.whatIfForecastExportName = whatIfForecastExportName
    }
}

public struct GetAccuracyMetricsInput {
    /// The Amazon Resource Name (ARN) of the predictor to get metrics for.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init(
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

extension ForecastClientTypes {

    public enum EvaluationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case computed
        case summary
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationType] {
            return [
                .computed,
                .summary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .computed: return "COMPUTED"
            case .summary: return "SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {
    /// Provides detailed error metrics to evaluate the performance of a predictor. This object is part of the [Metrics] object.
    public struct ErrorMetric {
        /// The Forecast type used to compute WAPE, MAPE, MASE, and RMSE.
        public var forecastType: Swift.String?
        /// The Mean Absolute Percentage Error (MAPE)
        public var mape: Swift.Double?
        /// The Mean Absolute Scaled Error (MASE)
        public var mase: Swift.Double?
        /// The root-mean-square error (RMSE).
        public var rmse: Swift.Double?
        /// The weighted absolute percentage error (WAPE).
        public var wape: Swift.Double?

        public init(
            forecastType: Swift.String? = nil,
            mape: Swift.Double? = nil,
            mase: Swift.Double? = nil,
            rmse: Swift.Double? = nil,
            wape: Swift.Double? = nil
        )
        {
            self.forecastType = forecastType
            self.mape = mape
            self.mase = mase
            self.rmse = rmse
            self.wape = wape
        }
    }

}

extension ForecastClientTypes {
    /// The weighted loss value for a quantile. This object is part of the [Metrics] object.
    public struct WeightedQuantileLoss {
        /// The difference between the predicted value and the actual value over the quantile, weighted (normalized) by dividing by the sum over all quantiles.
        public var lossValue: Swift.Double?
        /// The quantile. Quantiles divide a probability distribution into regions of equal probability. For example, if the distribution was divided into 5 regions of equal probability, the quantiles would be 0.2, 0.4, 0.6, and 0.8.
        public var quantile: Swift.Double?

        public init(
            lossValue: Swift.Double? = nil,
            quantile: Swift.Double? = nil
        )
        {
            self.lossValue = lossValue
            self.quantile = quantile
        }
    }

}

extension ForecastClientTypes {
    /// Provides metrics that are used to evaluate the performance of a predictor. This object is part of the [WindowSummary] object.
    public struct Metrics {
        /// The average value of all weighted quantile losses.
        public var averageWeightedQuantileLoss: Swift.Double?
        /// Provides detailed error metrics for each forecast type. Metrics include root-mean square-error (RMSE), mean absolute percentage error (MAPE), mean absolute scaled error (MASE), and weighted average percentage error (WAPE).
        public var errorMetrics: [ForecastClientTypes.ErrorMetric]?
        /// The root-mean-square error (RMSE).
        @available(*, deprecated, message: "This property is deprecated, please refer to ErrorMetrics for both RMSE and WAPE")
        public var rmse: Swift.Double?
        /// An array of weighted quantile losses. Quantiles divide a probability distribution into regions of equal probability. The distribution in this case is the loss function.
        public var weightedQuantileLosses: [ForecastClientTypes.WeightedQuantileLoss]?

        public init(
            averageWeightedQuantileLoss: Swift.Double? = nil,
            errorMetrics: [ForecastClientTypes.ErrorMetric]? = nil,
            rmse: Swift.Double? = nil,
            weightedQuantileLosses: [ForecastClientTypes.WeightedQuantileLoss]? = nil
        )
        {
            self.averageWeightedQuantileLoss = averageWeightedQuantileLoss
            self.errorMetrics = errorMetrics
            self.rmse = rmse
            self.weightedQuantileLosses = weightedQuantileLosses
        }
    }

}

extension ForecastClientTypes {
    /// The metrics for a time range within the evaluation portion of a dataset. This object is part of the [EvaluationResult] object. The TestWindowStart and TestWindowEnd parameters are determined by the BackTestWindowOffset parameter of the [EvaluationParameters] object.
    public struct WindowSummary {
        /// The type of evaluation.
        ///
        /// * SUMMARY - The average metrics across all windows.
        ///
        /// * COMPUTED - The metrics for the specified window.
        public var evaluationType: ForecastClientTypes.EvaluationType?
        /// The number of data points within the window.
        public var itemCount: Swift.Int?
        /// Provides metrics used to evaluate the performance of a predictor.
        public var metrics: ForecastClientTypes.Metrics?
        /// The timestamp that defines the end of the window.
        public var testWindowEnd: Foundation.Date?
        /// The timestamp that defines the start of the window.
        public var testWindowStart: Foundation.Date?

        public init(
            evaluationType: ForecastClientTypes.EvaluationType? = nil,
            itemCount: Swift.Int? = nil,
            metrics: ForecastClientTypes.Metrics? = nil,
            testWindowEnd: Foundation.Date? = nil,
            testWindowStart: Foundation.Date? = nil
        )
        {
            self.evaluationType = evaluationType
            self.itemCount = itemCount
            self.metrics = metrics
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }
    }

}

extension ForecastClientTypes {
    /// The results of evaluating an algorithm. Returned as part of the [GetAccuracyMetrics] response.
    public struct EvaluationResult {
        /// The Amazon Resource Name (ARN) of the algorithm that was evaluated.
        public var algorithmArn: Swift.String?
        /// The array of test windows used for evaluating the algorithm. The NumberOfBacktestWindows from the [EvaluationParameters] object determines the number of windows in the array.
        public var testWindows: [ForecastClientTypes.WindowSummary]?

        public init(
            algorithmArn: Swift.String? = nil,
            testWindows: [ForecastClientTypes.WindowSummary]? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }
    }

}

public struct GetAccuracyMetricsOutput {
    /// The LatencyOptimized AutoML override strategy is only available in private beta. Contact Amazon Web Services Support or your account manager to learn more about access privileges. The AutoML strategy used to train the predictor. Unless LatencyOptimized is specified, the AutoML strategy optimizes predictor accuracy. This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// Whether the predictor was created with [CreateAutoPredictor].
    public var isAutoPredictor: Swift.Bool?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// An array of results from evaluating the predictor.
    public var predictorEvaluationResults: [ForecastClientTypes.EvaluationResult]?

    public init(
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        isAutoPredictor: Swift.Bool? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        predictorEvaluationResults: [ForecastClientTypes.EvaluationResult]? = nil
    )
    {
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.isAutoPredictor = isAutoPredictor
        self.optimizationMetric = optimizationMetric
        self.predictorEvaluationResults = predictorEvaluationResults
    }
}

/// The token is not valid. Tokens expire after 24 hours.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListDatasetGroupsInput {
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset group properties used in the [ListDatasetGroups](https://docs.aws.amazon.com/forecast/latest/dg/API_ListDatasetGroups.html) operation. To get the complete set of properties, call the [DescribeDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_DescribeDatasetGroup.html) operation, and provide the DatasetGroupArn.
    public struct DatasetGroupSummary {
        /// When the dataset group was created.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// The name of the dataset group.
        public var datasetGroupName: Swift.String?
        /// When the dataset group was created or last updated from a call to the [UpdateDatasetGroup](https://docs.aws.amazon.com/forecast/latest/dg/API_UpdateDatasetGroup.html) operation. While the dataset group is being updated, LastModificationTime is the current time of the ListDatasetGroups call.
        public var lastModificationTime: Foundation.Date?

        public init(
            creationTime: Foundation.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            datasetGroupName: Swift.String? = nil,
            lastModificationTime: Foundation.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.datasetGroupName = datasetGroupName
            self.lastModificationTime = lastModificationTime
        }
    }

}

public struct ListDatasetGroupsOutput {
    /// An array of objects that summarize each dataset group's properties.
    public var datasetGroups: [ForecastClientTypes.DatasetGroupSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        datasetGroups: [ForecastClientTypes.DatasetGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroups = datasetGroups
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {

    public enum FilterConditionString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `is`
        case isNot
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterConditionString] {
            return [
                .is,
                .isNot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .is: return "IS"
            case .isNot: return "IS_NOT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ForecastClientTypes {
    /// Describes a filter for choosing a subset of objects. Each filter consists of a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the objects that match the statement, respectively. The match statement consists of a key and a value.
    public struct Filter {
        /// The condition to apply. To include the objects that match the statement, specify IS. To exclude matching objects, specify IS_NOT.
        /// This member is required.
        public var condition: ForecastClientTypes.FilterConditionString?
        /// The name of the parameter to filter on.
        /// This member is required.
        public var key: Swift.String?
        /// The value to match.
        /// This member is required.
        public var value: Swift.String?

        public init(
            condition: ForecastClientTypes.FilterConditionString? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.condition = condition
            self.key = key
            self.value = value
        }
    }

}

public struct ListDatasetImportJobsInput {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the datasets that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the datasets that match the statement, specify IS. To exclude matching datasets, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are DatasetArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all dataset import jobs whose status is ACTIVE, you specify the following filter: "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset import job properties used in the [ListDatasetImportJobs](https://docs.aws.amazon.com/forecast/latest/dg/API_ListDatasetImportJobs.html) operation. To get the complete set of properties, call the [DescribeDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_DescribeDatasetImportJob.html) operation, and provide the DatasetImportJobArn.
    public struct DatasetImportJobSummary {
        /// When the dataset import job was created.
        public var creationTime: Foundation.Date?
        /// The location of the training data to import and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket. If encryption is used, DataSource includes an Key Management Service (KMS) key.
        public var dataSource: ForecastClientTypes.DataSource?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public var datasetImportJobArn: Swift.String?
        /// The name of the dataset import job.
        public var datasetImportJobName: Swift.String?
        /// The import mode of the dataset import job, FULL or INCREMENTAL.
        public var importMode: ForecastClientTypes.ImportMode?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: Foundation.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the dataset import job. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        public var status: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            dataSource: ForecastClientTypes.DataSource? = nil,
            datasetImportJobArn: Swift.String? = nil,
            datasetImportJobName: Swift.String? = nil,
            importMode: ForecastClientTypes.ImportMode? = nil,
            lastModificationTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.dataSource = dataSource
            self.datasetImportJobArn = datasetImportJobArn
            self.datasetImportJobName = datasetImportJobName
            self.importMode = importMode
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }
    }

}

public struct ListDatasetImportJobsOutput {
    /// An array of objects that summarize each dataset import job's properties.
    public var datasetImportJobs: [ForecastClientTypes.DatasetImportJobSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        datasetImportJobs: [ForecastClientTypes.DatasetImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetImportJobs = datasetImportJobs
        self.nextToken = nextToken
    }
}

public struct ListDatasetsInput {
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset properties used in the [ListDatasets](https://docs.aws.amazon.com/forecast/latest/dg/API_ListDatasets.html) operation. To get the complete set of properties, call the [DescribeDataset](https://docs.aws.amazon.com/forecast/latest/dg/API_DescribeDataset.html) operation, and provide the DatasetArn.
    public struct DatasetSummary {
        /// When the dataset was created.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the dataset.
        public var datasetArn: Swift.String?
        /// The name of the dataset.
        public var datasetName: Swift.String?
        /// The dataset type.
        public var datasetType: ForecastClientTypes.DatasetType?
        /// The domain associated with the dataset.
        public var domain: ForecastClientTypes.Domain?
        /// When you create a dataset, LastModificationTime is the same as CreationTime. While data is being imported to the dataset, LastModificationTime is the current time of the ListDatasets call. After a [CreateDatasetImportJob](https://docs.aws.amazon.com/forecast/latest/dg/API_CreateDatasetImportJob.html) operation has finished, LastModificationTime is when the import job completed or failed.
        public var lastModificationTime: Foundation.Date?

        public init(
            creationTime: Foundation.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetName: Swift.String? = nil,
            datasetType: ForecastClientTypes.DatasetType? = nil,
            domain: ForecastClientTypes.Domain? = nil,
            lastModificationTime: Foundation.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetArn = datasetArn
            self.datasetName = datasetName
            self.datasetType = datasetType
            self.domain = domain
            self.lastModificationTime = lastModificationTime
        }
    }

}

public struct ListDatasetsOutput {
    /// An array of objects that summarize each dataset's properties.
    public var datasets: [ForecastClientTypes.DatasetSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        datasets: [ForecastClientTypes.DatasetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

public struct ListExplainabilitiesInput {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the resources that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are ResourceArn and Status.
    ///
    /// * Value - The value to match.
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items returned in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the Explainability properties used in the [ListExplainabilities] operation. To get a complete set of properties, call the [DescribeExplainability] operation, and provide the listed ExplainabilityArn.
    public struct ExplainabilitySummary {
        /// When the Explainability was created.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the Explainability.
        public var explainabilityArn: Swift.String?
        /// The configuration settings that define the granularity of time series and time points for the Explainability.
        public var explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
        /// The name of the Explainability.
        public var explainabilityName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: Foundation.Date?
        /// Information about any errors that may have occurred during the Explainability creation process.
        public var message: Swift.String?
        /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability.
        public var resourceArn: Swift.String?
        /// The status of the Explainability. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            explainabilityArn: Swift.String? = nil,
            explainabilityConfig: ForecastClientTypes.ExplainabilityConfig? = nil,
            explainabilityName: Swift.String? = nil,
            lastModificationTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.explainabilityArn = explainabilityArn
            self.explainabilityConfig = explainabilityConfig
            self.explainabilityName = explainabilityName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.resourceArn = resourceArn
            self.status = status
        }
    }

}

public struct ListExplainabilitiesOutput {
    /// An array of objects that summarize the properties of each Explainability resource.
    public var explainabilities: [ForecastClientTypes.ExplainabilitySummary]?
    /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        explainabilities: [ForecastClientTypes.ExplainabilitySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.explainabilities = explainabilities
        self.nextToken = nextToken
    }
}

public struct ListExplainabilityExportsInput {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude resources that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are ResourceArn and Status.
    ///
    /// * Value - The value to match.
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the Explainability export properties used in the [ListExplainabilityExports] operation. To get a complete set of properties, call the [DescribeExplainabilityExport] operation, and provide the ExplainabilityExportArn.
    public struct ExplainabilityExportSummary {
        /// When the Explainability was created.
        public var creationTime: Foundation.Date?
        /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
        public var destination: ForecastClientTypes.DataDestination?
        /// The Amazon Resource Name (ARN) of the Explainability export.
        public var explainabilityExportArn: Swift.String?
        /// The name of the Explainability export
        public var explainabilityExportName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: Foundation.Date?
        /// Information about any errors that may have occurred during the Explainability export.
        public var message: Swift.String?
        /// The status of the Explainability export. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            explainabilityExportArn: Swift.String? = nil,
            explainabilityExportName: Swift.String? = nil,
            lastModificationTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.explainabilityExportArn = explainabilityExportArn
            self.explainabilityExportName = explainabilityExportName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }
    }

}

public struct ListExplainabilityExportsOutput {
    /// An array of objects that summarize the properties of each Explainability export.
    public var explainabilityExports: [ForecastClientTypes.ExplainabilityExportSummary]?
    /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        explainabilityExports: [ForecastClientTypes.ExplainabilityExportSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.explainabilityExports = explainabilityExports
        self.nextToken = nextToken
    }
}

public struct ListForecastExportJobsInput {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the forecast export jobs that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecast export jobs that match the statement, specify IS. To exclude matching forecast export jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are ForecastArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all jobs that export a forecast named electricityforecast, specify the following filter: "Filters": [ { "Condition": "IS", "Key": "ForecastArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityforecast" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the forecast export job properties used in the [ListForecastExportJobs] operation. To get the complete set of properties, call the [DescribeForecastExportJob] operation, and provide the listed ForecastExportJobArn.
    public struct ForecastExportJobSummary {
        /// When the forecast export job was created.
        public var creationTime: Foundation.Date?
        /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
        public var destination: ForecastClientTypes.DataDestination?
        /// The Amazon Resource Name (ARN) of the forecast export job.
        public var forecastExportJobArn: Swift.String?
        /// The name of the forecast export job.
        public var forecastExportJobName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: Foundation.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the forecast export job. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the forecast export job must be ACTIVE before you can access the forecast in your S3 bucket.
        public var status: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            forecastExportJobArn: Swift.String? = nil,
            forecastExportJobName: Swift.String? = nil,
            lastModificationTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.forecastExportJobArn = forecastExportJobArn
            self.forecastExportJobName = forecastExportJobName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }
    }

}

public struct ListForecastExportJobsOutput {
    /// An array of objects that summarize each export job's properties.
    public var forecastExportJobs: [ForecastClientTypes.ForecastExportJobSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        forecastExportJobs: [ForecastClientTypes.ForecastExportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.forecastExportJobs = forecastExportJobs
        self.nextToken = nextToken
    }
}

public struct ListForecastsInput {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the forecasts that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecasts that match the statement, specify IS. To exclude matching forecasts, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are DatasetGroupArn, PredictorArn, and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all forecasts whose status is not ACTIVE, you would specify: "Filters": [ { "Condition": "IS_NOT", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the forecast properties used in the [ListForecasts] operation. To get the complete set of properties, call the [DescribeForecast] operation, and provide the ForecastArn that is listed in the summary.
    public struct ForecastSummary {
        /// Whether the Forecast was created from an AutoPredictor.
        public var createdUsingAutoPredictor: Swift.Bool?
        /// When the forecast creation task was created.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that provided the data used to train the predictor.
        public var datasetGroupArn: Swift.String?
        /// The ARN of the forecast.
        public var forecastArn: Swift.String?
        /// The name of the forecast.
        public var forecastName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: Foundation.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The ARN of the predictor used to generate the forecast.
        public var predictorArn: Swift.String?
        /// The status of the forecast. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the forecast must be ACTIVE before you can query or export the forecast.
        public var status: Swift.String?

        public init(
            createdUsingAutoPredictor: Swift.Bool? = nil,
            creationTime: Foundation.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            forecastArn: Swift.String? = nil,
            forecastName: Swift.String? = nil,
            lastModificationTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            predictorArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.createdUsingAutoPredictor = createdUsingAutoPredictor
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.forecastArn = forecastArn
            self.forecastName = forecastName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.status = status
        }
    }

}

public struct ListForecastsOutput {
    /// An array of objects that summarize each forecast's properties.
    public var forecasts: [ForecastClientTypes.ForecastSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        forecasts: [ForecastClientTypes.ForecastSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.forecasts = forecasts
        self.nextToken = nextToken
    }
}

public struct ListMonitorEvaluationsInput {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the resources that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. The only valid value is EvaluationState.
    ///
    /// * Value - The value to match. Valid values are only SUCCESS or FAILURE.
    ///
    ///
    /// For example, to list only successful monitor evaluations, you would specify: "Filters": [ { "Condition": "IS", "Key": "EvaluationState", "Value": "SUCCESS" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The maximum number of monitoring results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the monitor resource to get results from.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        monitorArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.monitorArn = monitorArn
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {
    /// An individual metric Forecast calculated when monitoring predictor usage. You can compare the value for this metric to the metric's value in the [Baseline] to see how your predictor's performance is changing. For more information about metrics generated by Forecast see [Evaluating Predictor Accuracy](https://docs.aws.amazon.com/forecast/latest/dg/metrics.html)
    public struct MetricResult {
        /// The name of the metric.
        public var metricName: Swift.String?
        /// The value for the metric.
        public var metricValue: Swift.Double?

        public init(
            metricName: Swift.String? = nil,
            metricValue: Swift.Double? = nil
        )
        {
            self.metricName = metricName
            self.metricValue = metricValue
        }
    }

}

extension ForecastClientTypes {
    /// The source of the data the monitor used during the evaluation.
    public struct MonitorDataSource {
        /// The Amazon Resource Name (ARN) of the dataset import job used to import the data that initiated the monitor evaluation.
        public var datasetImportJobArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the forecast the monitor used during the evaluation.
        public var forecastArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the predictor resource you are monitoring.
        public var predictorArn: Swift.String?

        public init(
            datasetImportJobArn: Swift.String? = nil,
            forecastArn: Swift.String? = nil,
            predictorArn: Swift.String? = nil
        )
        {
            self.datasetImportJobArn = datasetImportJobArn
            self.forecastArn = forecastArn
            self.predictorArn = predictorArn
        }
    }

}

extension ForecastClientTypes {
    /// Provides details about a predictor event, such as a retraining.
    public struct PredictorEvent {
        /// The timestamp for when the event occurred.
        public var datetime: Foundation.Date?
        /// The type of event. For example, Retrain. A retraining event denotes the timepoint when a predictor was retrained. Any monitor results from before the Datetime are from the previous predictor. Any new metrics are for the newly retrained predictor.
        public var detail: Swift.String?

        public init(
            datetime: Foundation.Date? = nil,
            detail: Swift.String? = nil
        )
        {
            self.datetime = datetime
            self.detail = detail
        }
    }

}

extension ForecastClientTypes {
    /// Describes the results of a monitor evaluation.
    public struct PredictorMonitorEvaluation {
        /// The status of the monitor evaluation. The state can be SUCCESS or FAILURE.
        public var evaluationState: Swift.String?
        /// The timestamp that indicates when the monitor evaluation was started.
        public var evaluationTime: Foundation.Date?
        /// Information about any errors that may have occurred during the monitor evaluation.
        public var message: Swift.String?
        /// A list of metrics Forecast calculated when monitoring a predictor. You can compare the value for each metric in the list to the metric's value in the [Baseline] to see how your predictor's performance is changing.
        public var metricResults: [ForecastClientTypes.MetricResult]?
        /// The Amazon Resource Name (ARN) of the monitor resource.
        public var monitorArn: Swift.String?
        /// The source of the data the monitor resource used during the evaluation.
        public var monitorDataSource: ForecastClientTypes.MonitorDataSource?
        /// The number of items considered during the evaluation.
        public var numItemsEvaluated: Swift.Int?
        /// Provides details about a predictor event, such as a retraining.
        public var predictorEvent: ForecastClientTypes.PredictorEvent?
        /// The Amazon Resource Name (ARN) of the resource to monitor.
        public var resourceArn: Swift.String?
        /// The timestamp that indicates the end of the window that is used for monitor evaluation.
        public var windowEndDatetime: Foundation.Date?
        /// The timestamp that indicates the start of the window that is used for monitor evaluation.
        public var windowStartDatetime: Foundation.Date?

        public init(
            evaluationState: Swift.String? = nil,
            evaluationTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            metricResults: [ForecastClientTypes.MetricResult]? = nil,
            monitorArn: Swift.String? = nil,
            monitorDataSource: ForecastClientTypes.MonitorDataSource? = nil,
            numItemsEvaluated: Swift.Int? = nil,
            predictorEvent: ForecastClientTypes.PredictorEvent? = nil,
            resourceArn: Swift.String? = nil,
            windowEndDatetime: Foundation.Date? = nil,
            windowStartDatetime: Foundation.Date? = nil
        )
        {
            self.evaluationState = evaluationState
            self.evaluationTime = evaluationTime
            self.message = message
            self.metricResults = metricResults
            self.monitorArn = monitorArn
            self.monitorDataSource = monitorDataSource
            self.numItemsEvaluated = numItemsEvaluated
            self.predictorEvent = predictorEvent
            self.resourceArn = resourceArn
            self.windowEndDatetime = windowEndDatetime
            self.windowStartDatetime = windowStartDatetime
        }
    }

}

public struct ListMonitorEvaluationsOutput {
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?
    /// The monitoring results and predictor events collected by the monitor resource during different windows of time. For information about monitoring see [Viewing Monitoring Results](https://docs.aws.amazon.com/forecast/latest/dg/predictor-monitoring-results.html). For more information about retrieving monitoring results see [Viewing Monitoring Results](https://docs.aws.amazon.com/forecast/latest/dg/predictor-monitoring-results.html).
    public var predictorMonitorEvaluations: [ForecastClientTypes.PredictorMonitorEvaluation]?

    public init(
        nextToken: Swift.String? = nil,
        predictorMonitorEvaluations: [ForecastClientTypes.PredictorMonitorEvaluation]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictorMonitorEvaluations = predictorMonitorEvaluations
    }
}

public struct ListMonitorsInput {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the resources that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. The only valid value is Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all monitors who's status is ACTIVE, you would specify: "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The maximum number of monitors to include in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the monitor properties used in the [ListMonitors] operation. To get a complete set of properties, call the [DescribeMonitor] operation, and provide the listed MonitorArn.
    public struct MonitorSummary {
        /// When the monitor resource was created.
        public var creationTime: Foundation.Date?
        /// The last time the monitor resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * STOPPED - When the resource stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the monitor creation finished or failed.
        public var lastModificationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the monitor resource.
        public var monitorArn: Swift.String?
        /// The name of the monitor resource.
        public var monitorName: Swift.String?
        /// The Amazon Resource Name (ARN) of the predictor being monitored.
        public var resourceArn: Swift.String?
        /// The status of the monitor. States include:
        ///
        /// * ACTIVE
        ///
        /// * ACTIVE_STOPPING, ACTIVE_STOPPED
        ///
        /// * UPDATE_IN_PROGRESS
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            lastModificationTime: Foundation.Date? = nil,
            monitorArn: Swift.String? = nil,
            monitorName: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.resourceArn = resourceArn
            self.status = status
        }
    }

}

public struct ListMonitorsOutput {
    /// An array of objects that summarize each monitor's properties.
    public var monitors: [ForecastClientTypes.MonitorSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        monitors: [ForecastClientTypes.MonitorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.monitors = monitors
        self.nextToken = nextToken
    }
}

public struct ListPredictorBacktestExportJobsInput {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the predictor backtest export jobs that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the predictor backtest export jobs that match the statement, specify IS. To exclude matching predictor backtest export jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are PredictorArn and Status.
    ///
    /// * Value - The value to match.
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the predictor backtest export job properties used in the [ListPredictorBacktestExportJobs] operation. To get a complete set of properties, call the [DescribePredictorBacktestExportJob] operation, and provide the listed PredictorBacktestExportJobArn.
    public struct PredictorBacktestExportJobSummary {
        /// When the predictor backtest export job was created.
        public var creationTime: Foundation.Date?
        /// The destination for an export job. Provide an S3 path, an Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an Key Management Service (KMS) key (optional).
        public var destination: ForecastClientTypes.DataDestination?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: Foundation.Date?
        /// Information about any errors that may have occurred during the backtest export.
        public var message: Swift.String?
        /// The Amazon Resource Name (ARN) of the predictor backtest export job.
        public var predictorBacktestExportJobArn: Swift.String?
        /// The name of the predictor backtest export job.
        public var predictorBacktestExportJobName: Swift.String?
        /// The status of the predictor backtest export job. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            lastModificationTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            predictorBacktestExportJobArn: Swift.String? = nil,
            predictorBacktestExportJobName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
            self.predictorBacktestExportJobName = predictorBacktestExportJobName
            self.status = status
        }
    }

}

public struct ListPredictorBacktestExportJobsOutput {
    /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of objects that summarize the properties of each predictor backtest export job.
    public var predictorBacktestExportJobs: [ForecastClientTypes.PredictorBacktestExportJobSummary]?

    public init(
        nextToken: Swift.String? = nil,
        predictorBacktestExportJobs: [ForecastClientTypes.PredictorBacktestExportJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictorBacktestExportJobs = predictorBacktestExportJobs
    }
}

public struct ListPredictorsInput {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the predictors that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the predictors that match the statement, specify IS. To exclude matching predictors, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are DatasetGroupArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all predictors whose status is ACTIVE, you would specify: "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the predictor properties that are used in the [ListPredictors] operation. To get the complete set of properties, call the [DescribePredictor] operation, and provide the listed PredictorArn.
    public struct PredictorSummary {
        /// When the model training task was created.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that contains the data used to train the predictor.
        public var datasetGroupArn: Swift.String?
        /// Whether AutoPredictor was used to create the predictor.
        public var isAutoPredictor: Swift.Bool?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: Foundation.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The ARN of the predictor.
        public var predictorArn: Swift.String?
        /// The name of the predictor.
        public var predictorName: Swift.String?
        /// A summary of the reference predictor used if the predictor was retrained or upgraded.
        public var referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary?
        /// The status of the predictor. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        ///
        /// The Status of the predictor must be ACTIVE before you can use the predictor to create a forecast.
        public var status: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            isAutoPredictor: Swift.Bool? = nil,
            lastModificationTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            predictorArn: Swift.String? = nil,
            predictorName: Swift.String? = nil,
            referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.isAutoPredictor = isAutoPredictor
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.predictorName = predictorName
            self.referencePredictorSummary = referencePredictorSummary
            self.status = status
        }
    }

}

public struct ListPredictorsOutput {
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of objects that summarize each predictor's properties.
    public var predictors: [ForecastClientTypes.PredictorSummary]?

    public init(
        nextToken: Swift.String? = nil,
        predictors: [ForecastClientTypes.PredictorSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictors = predictors
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The tags for the resource.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListWhatIfAnalysesInput {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the what-if analysis jobs that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the what-if analysis jobs that match the statement, specify IS. To exclude matching what-if analysis jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are WhatIfAnalysisArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all jobs that export a forecast named electricityWhatIf, specify the following filter: "Filters": [ { "Condition": "IS", "Key": "WhatIfAnalysisArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityWhatIf" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the what-if analysis properties used in the [ListWhatIfAnalyses] operation. To get the complete set of properties, call the [DescribeWhatIfAnalysis] operation, and provide the WhatIfAnalysisArn that is listed in the summary.
    public struct WhatIfAnalysisSummary {
        /// When the what-if analysis was created.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the baseline forecast that is being used in this what-if analysis.
        public var forecastArn: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: Foundation.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the what-if analysis. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the what-if analysis must be ACTIVE before you can access the analysis.
        public var status: Swift.String?
        /// The Amazon Resource Name (ARN) of the what-if analysis.
        public var whatIfAnalysisArn: Swift.String?
        /// The name of the what-if analysis.
        public var whatIfAnalysisName: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            forecastArn: Swift.String? = nil,
            lastModificationTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil,
            whatIfAnalysisArn: Swift.String? = nil,
            whatIfAnalysisName: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.forecastArn = forecastArn
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.whatIfAnalysisArn = whatIfAnalysisArn
            self.whatIfAnalysisName = whatIfAnalysisName
        }
    }

}

public struct ListWhatIfAnalysesOutput {
    /// If the response is truncated, Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of WhatIfAnalysisSummary objects that describe the matched analyses.
    public var whatIfAnalyses: [ForecastClientTypes.WhatIfAnalysisSummary]?

    public init(
        nextToken: Swift.String? = nil,
        whatIfAnalyses: [ForecastClientTypes.WhatIfAnalysisSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.whatIfAnalyses = whatIfAnalyses
    }
}

public struct ListWhatIfForecastExportsInput {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the what-if forecast export jobs that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecast export jobs that match the statement, specify IS. To exclude matching forecast export jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are WhatIfForecastExportArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all jobs that export a forecast named electricityWIFExport, specify the following filter: "Filters": [ { "Condition": "IS", "Key": "WhatIfForecastExportArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityWIFExport" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next  request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the what-if forecast export properties used in the [ListWhatIfForecastExports] operation. To get the complete set of properties, call the [DescribeWhatIfForecastExport] operation, and provide the WhatIfForecastExportArn that is listed in the summary.
    public struct WhatIfForecastExportSummary {
        /// When the what-if forecast export was created.
        public var creationTime: Foundation.Date?
        /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
        public var destination: ForecastClientTypes.DataDestination?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: Foundation.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the what-if forecast export. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the what-if analysis must be ACTIVE before you can access the analysis.
        public var status: Swift.String?
        /// An array of Amazon Resource Names (ARNs) that define the what-if forecasts included in the export.
        public var whatIfForecastArns: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the what-if forecast export.
        public var whatIfForecastExportArn: Swift.String?
        /// The what-if forecast export name.
        public var whatIfForecastExportName: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            lastModificationTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil,
            whatIfForecastArns: [Swift.String]? = nil,
            whatIfForecastExportArn: Swift.String? = nil,
            whatIfForecastExportName: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.whatIfForecastArns = whatIfForecastArns
            self.whatIfForecastExportArn = whatIfForecastExportArn
            self.whatIfForecastExportName = whatIfForecastExportName
        }
    }

}

public struct ListWhatIfForecastExportsOutput {
    /// If the response is truncated, Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of WhatIfForecastExports objects that describe the matched forecast exports.
    public var whatIfForecastExports: [ForecastClientTypes.WhatIfForecastExportSummary]?

    public init(
        nextToken: Swift.String? = nil,
        whatIfForecastExports: [ForecastClientTypes.WhatIfForecastExportSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.whatIfForecastExports = whatIfForecastExports
    }
}

public struct ListWhatIfForecastsInput {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the what-if forecast export jobs that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecast export jobs that match the statement, specify IS. To exclude matching forecast export jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are WhatIfForecastArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all jobs that export a forecast named electricityWhatIfForecast, specify the following filter: "Filters": [ { "Condition": "IS", "Key": "WhatIfForecastArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityWhatIfForecast" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next  request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the what-if forecast properties used in the [ListWhatIfForecasts] operation. To get the complete set of properties, call the [DescribeWhatIfForecast] operation, and provide the WhatIfForecastArn that is listed in the summary.
    public struct WhatIfForecastSummary {
        /// When the what-if forecast was created.
        public var creationTime: Foundation.Date?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: Foundation.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the what-if forecast. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the what-if analysis must be ACTIVE before you can access the analysis.
        public var status: Swift.String?
        /// The Amazon Resource Name (ARN) of the what-if analysis that contains this what-if forecast.
        public var whatIfAnalysisArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the what-if forecast.
        public var whatIfForecastArn: Swift.String?
        /// The name of the what-if forecast.
        public var whatIfForecastName: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            lastModificationTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil,
            whatIfAnalysisArn: Swift.String? = nil,
            whatIfForecastArn: Swift.String? = nil,
            whatIfForecastName: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.whatIfAnalysisArn = whatIfAnalysisArn
            self.whatIfForecastArn = whatIfForecastArn
            self.whatIfForecastName = whatIfForecastName
        }
    }

}

public struct ListWhatIfForecastsOutput {
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next  request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?
    /// An array of WhatIfForecasts objects that describe the matched forecasts.
    public var whatIfForecasts: [ForecastClientTypes.WhatIfForecastSummary]?

    public init(
        nextToken: Swift.String? = nil,
        whatIfForecasts: [ForecastClientTypes.WhatIfForecastSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.whatIfForecasts = whatIfForecasts
    }
}

public struct ResumeResourceInput {
    /// The Amazon Resource Name (ARN) of the monitor resource to resume.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct StopResourceInput {
    /// The Amazon Resource Name (ARN) that identifies the resource to stop. The supported ARNs are DatasetImportJobArn, PredictorArn, PredictorBacktestExportJobArn, ForecastArn, ForecastExportJobArn, ExplainabilityArn, and ExplainabilityExportArn.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    /// This member is required.
    public var tags: [ForecastClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateDatasetGroupInput {
    /// An array of the Amazon Resource Names (ARNs) of the datasets to add to the dataset group.
    /// This member is required.
    public var datasetArns: [Swift.String]?
    /// The ARN of the dataset group.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init(
        datasetArns: [Swift.String]? = nil,
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetArns = datasetArns
        self.datasetGroupArn = datasetGroupArn
    }
}

public struct UpdateDatasetGroupOutput {

    public init() { }
}

extension CreateAutoPredictorInput {

    static func urlPathProvider(_ value: CreateAutoPredictorInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDatasetInput {

    static func urlPathProvider(_ value: CreateDatasetInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDatasetGroupInput {

    static func urlPathProvider(_ value: CreateDatasetGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDatasetImportJobInput {

    static func urlPathProvider(_ value: CreateDatasetImportJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateExplainabilityInput {

    static func urlPathProvider(_ value: CreateExplainabilityInput) -> Swift.String? {
        return "/"
    }
}

extension CreateExplainabilityExportInput {

    static func urlPathProvider(_ value: CreateExplainabilityExportInput) -> Swift.String? {
        return "/"
    }
}

extension CreateForecastInput {

    static func urlPathProvider(_ value: CreateForecastInput) -> Swift.String? {
        return "/"
    }
}

extension CreateForecastExportJobInput {

    static func urlPathProvider(_ value: CreateForecastExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateMonitorInput {

    static func urlPathProvider(_ value: CreateMonitorInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePredictorInput {

    static func urlPathProvider(_ value: CreatePredictorInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePredictorBacktestExportJobInput {

    static func urlPathProvider(_ value: CreatePredictorBacktestExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWhatIfAnalysisInput {

    static func urlPathProvider(_ value: CreateWhatIfAnalysisInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWhatIfForecastInput {

    static func urlPathProvider(_ value: CreateWhatIfForecastInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWhatIfForecastExportInput {

    static func urlPathProvider(_ value: CreateWhatIfForecastExportInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDatasetInput {

    static func urlPathProvider(_ value: DeleteDatasetInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDatasetGroupInput {

    static func urlPathProvider(_ value: DeleteDatasetGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDatasetImportJobInput {

    static func urlPathProvider(_ value: DeleteDatasetImportJobInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteExplainabilityInput {

    static func urlPathProvider(_ value: DeleteExplainabilityInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteExplainabilityExportInput {

    static func urlPathProvider(_ value: DeleteExplainabilityExportInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteForecastInput {

    static func urlPathProvider(_ value: DeleteForecastInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteForecastExportJobInput {

    static func urlPathProvider(_ value: DeleteForecastExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteMonitorInput {

    static func urlPathProvider(_ value: DeleteMonitorInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePredictorInput {

    static func urlPathProvider(_ value: DeletePredictorInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePredictorBacktestExportJobInput {

    static func urlPathProvider(_ value: DeletePredictorBacktestExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResourceTreeInput {

    static func urlPathProvider(_ value: DeleteResourceTreeInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWhatIfAnalysisInput {

    static func urlPathProvider(_ value: DeleteWhatIfAnalysisInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWhatIfForecastInput {

    static func urlPathProvider(_ value: DeleteWhatIfForecastInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWhatIfForecastExportInput {

    static func urlPathProvider(_ value: DeleteWhatIfForecastExportInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAutoPredictorInput {

    static func urlPathProvider(_ value: DescribeAutoPredictorInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDatasetInput {

    static func urlPathProvider(_ value: DescribeDatasetInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDatasetGroupInput {

    static func urlPathProvider(_ value: DescribeDatasetGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDatasetImportJobInput {

    static func urlPathProvider(_ value: DescribeDatasetImportJobInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeExplainabilityInput {

    static func urlPathProvider(_ value: DescribeExplainabilityInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeExplainabilityExportInput {

    static func urlPathProvider(_ value: DescribeExplainabilityExportInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeForecastInput {

    static func urlPathProvider(_ value: DescribeForecastInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeForecastExportJobInput {

    static func urlPathProvider(_ value: DescribeForecastExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMonitorInput {

    static func urlPathProvider(_ value: DescribeMonitorInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePredictorInput {

    static func urlPathProvider(_ value: DescribePredictorInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePredictorBacktestExportJobInput {

    static func urlPathProvider(_ value: DescribePredictorBacktestExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWhatIfAnalysisInput {

    static func urlPathProvider(_ value: DescribeWhatIfAnalysisInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWhatIfForecastInput {

    static func urlPathProvider(_ value: DescribeWhatIfForecastInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWhatIfForecastExportInput {

    static func urlPathProvider(_ value: DescribeWhatIfForecastExportInput) -> Swift.String? {
        return "/"
    }
}

extension GetAccuracyMetricsInput {

    static func urlPathProvider(_ value: GetAccuracyMetricsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDatasetGroupsInput {

    static func urlPathProvider(_ value: ListDatasetGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDatasetImportJobsInput {

    static func urlPathProvider(_ value: ListDatasetImportJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDatasetsInput {

    static func urlPathProvider(_ value: ListDatasetsInput) -> Swift.String? {
        return "/"
    }
}

extension ListExplainabilitiesInput {

    static func urlPathProvider(_ value: ListExplainabilitiesInput) -> Swift.String? {
        return "/"
    }
}

extension ListExplainabilityExportsInput {

    static func urlPathProvider(_ value: ListExplainabilityExportsInput) -> Swift.String? {
        return "/"
    }
}

extension ListForecastExportJobsInput {

    static func urlPathProvider(_ value: ListForecastExportJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListForecastsInput {

    static func urlPathProvider(_ value: ListForecastsInput) -> Swift.String? {
        return "/"
    }
}

extension ListMonitorEvaluationsInput {

    static func urlPathProvider(_ value: ListMonitorEvaluationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListMonitorsInput {

    static func urlPathProvider(_ value: ListMonitorsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPredictorBacktestExportJobsInput {

    static func urlPathProvider(_ value: ListPredictorBacktestExportJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPredictorsInput {

    static func urlPathProvider(_ value: ListPredictorsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListWhatIfAnalysesInput {

    static func urlPathProvider(_ value: ListWhatIfAnalysesInput) -> Swift.String? {
        return "/"
    }
}

extension ListWhatIfForecastExportsInput {

    static func urlPathProvider(_ value: ListWhatIfForecastExportsInput) -> Swift.String? {
        return "/"
    }
}

extension ListWhatIfForecastsInput {

    static func urlPathProvider(_ value: ListWhatIfForecastsInput) -> Swift.String? {
        return "/"
    }
}

extension ResumeResourceInput {

    static func urlPathProvider(_ value: ResumeResourceInput) -> Swift.String? {
        return "/"
    }
}

extension StopResourceInput {

    static func urlPathProvider(_ value: StopResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDatasetGroupInput {

    static func urlPathProvider(_ value: UpdateDatasetGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAutoPredictorInput {

    static func write(value: CreateAutoPredictorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataConfig"].write(value.dataConfig, with: ForecastClientTypes.DataConfig.write(value:to:))
        try writer["EncryptionConfig"].write(value.encryptionConfig, with: ForecastClientTypes.EncryptionConfig.write(value:to:))
        try writer["ExplainPredictor"].write(value.explainPredictor)
        try writer["ForecastDimensions"].writeList(value.forecastDimensions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ForecastFrequency"].write(value.forecastFrequency)
        try writer["ForecastHorizon"].write(value.forecastHorizon)
        try writer["ForecastTypes"].writeList(value.forecastTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MonitorConfig"].write(value.monitorConfig, with: ForecastClientTypes.MonitorConfig.write(value:to:))
        try writer["OptimizationMetric"].write(value.optimizationMetric)
        try writer["PredictorName"].write(value.predictorName)
        try writer["ReferencePredictorArn"].write(value.referencePredictorArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TimeAlignmentBoundary"].write(value.timeAlignmentBoundary, with: ForecastClientTypes.TimeAlignmentBoundary.write(value:to:))
    }
}

extension CreateDatasetInput {

    static func write(value: CreateDatasetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataFrequency"].write(value.dataFrequency)
        try writer["DatasetName"].write(value.datasetName)
        try writer["DatasetType"].write(value.datasetType)
        try writer["Domain"].write(value.domain)
        try writer["EncryptionConfig"].write(value.encryptionConfig, with: ForecastClientTypes.EncryptionConfig.write(value:to:))
        try writer["Schema"].write(value.schema, with: ForecastClientTypes.Schema.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDatasetGroupInput {

    static func write(value: CreateDatasetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatasetArns"].writeList(value.datasetArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DatasetGroupName"].write(value.datasetGroupName)
        try writer["Domain"].write(value.domain)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDatasetImportJobInput {

    static func write(value: CreateDatasetImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSource"].write(value.dataSource, with: ForecastClientTypes.DataSource.write(value:to:))
        try writer["DatasetArn"].write(value.datasetArn)
        try writer["DatasetImportJobName"].write(value.datasetImportJobName)
        try writer["Format"].write(value.format)
        try writer["GeolocationFormat"].write(value.geolocationFormat)
        try writer["ImportMode"].write(value.importMode)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TimeZone"].write(value.timeZone)
        try writer["TimestampFormat"].write(value.timestampFormat)
        try writer["UseGeolocationForTimeZone"].write(value.useGeolocationForTimeZone)
    }
}

extension CreateExplainabilityInput {

    static func write(value: CreateExplainabilityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSource"].write(value.dataSource, with: ForecastClientTypes.DataSource.write(value:to:))
        try writer["EnableVisualization"].write(value.enableVisualization)
        try writer["EndDateTime"].write(value.endDateTime)
        try writer["ExplainabilityConfig"].write(value.explainabilityConfig, with: ForecastClientTypes.ExplainabilityConfig.write(value:to:))
        try writer["ExplainabilityName"].write(value.explainabilityName)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Schema"].write(value.schema, with: ForecastClientTypes.Schema.write(value:to:))
        try writer["StartDateTime"].write(value.startDateTime)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateExplainabilityExportInput {

    static func write(value: CreateExplainabilityExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination, with: ForecastClientTypes.DataDestination.write(value:to:))
        try writer["ExplainabilityArn"].write(value.explainabilityArn)
        try writer["ExplainabilityExportName"].write(value.explainabilityExportName)
        try writer["Format"].write(value.format)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateForecastInput {

    static func write(value: CreateForecastInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForecastName"].write(value.forecastName)
        try writer["ForecastTypes"].writeList(value.forecastTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PredictorArn"].write(value.predictorArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TimeSeriesSelector"].write(value.timeSeriesSelector, with: ForecastClientTypes.TimeSeriesSelector.write(value:to:))
    }
}

extension CreateForecastExportJobInput {

    static func write(value: CreateForecastExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination, with: ForecastClientTypes.DataDestination.write(value:to:))
        try writer["ForecastArn"].write(value.forecastArn)
        try writer["ForecastExportJobName"].write(value.forecastExportJobName)
        try writer["Format"].write(value.format)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMonitorInput {

    static func write(value: CreateMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MonitorName"].write(value.monitorName)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreatePredictorInput {

    static func write(value: CreatePredictorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlgorithmArn"].write(value.algorithmArn)
        try writer["AutoMLOverrideStrategy"].write(value.autoMLOverrideStrategy)
        try writer["EncryptionConfig"].write(value.encryptionConfig, with: ForecastClientTypes.EncryptionConfig.write(value:to:))
        try writer["EvaluationParameters"].write(value.evaluationParameters, with: ForecastClientTypes.EvaluationParameters.write(value:to:))
        try writer["FeaturizationConfig"].write(value.featurizationConfig, with: ForecastClientTypes.FeaturizationConfig.write(value:to:))
        try writer["ForecastHorizon"].write(value.forecastHorizon)
        try writer["ForecastTypes"].writeList(value.forecastTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HPOConfig"].write(value.hpoConfig, with: ForecastClientTypes.HyperParameterTuningJobConfig.write(value:to:))
        try writer["InputDataConfig"].write(value.inputDataConfig, with: ForecastClientTypes.InputDataConfig.write(value:to:))
        try writer["OptimizationMetric"].write(value.optimizationMetric)
        try writer["PerformAutoML"].write(value.performAutoML)
        try writer["PerformHPO"].write(value.performHPO)
        try writer["PredictorName"].write(value.predictorName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TrainingParameters"].writeMap(value.trainingParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreatePredictorBacktestExportJobInput {

    static func write(value: CreatePredictorBacktestExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination, with: ForecastClientTypes.DataDestination.write(value:to:))
        try writer["Format"].write(value.format)
        try writer["PredictorArn"].write(value.predictorArn)
        try writer["PredictorBacktestExportJobName"].write(value.predictorBacktestExportJobName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateWhatIfAnalysisInput {

    static func write(value: CreateWhatIfAnalysisInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForecastArn"].write(value.forecastArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TimeSeriesSelector"].write(value.timeSeriesSelector, with: ForecastClientTypes.TimeSeriesSelector.write(value:to:))
        try writer["WhatIfAnalysisName"].write(value.whatIfAnalysisName)
    }
}

extension CreateWhatIfForecastInput {

    static func write(value: CreateWhatIfForecastInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TimeSeriesReplacementsDataSource"].write(value.timeSeriesReplacementsDataSource, with: ForecastClientTypes.TimeSeriesReplacementsDataSource.write(value:to:))
        try writer["TimeSeriesTransformations"].writeList(value.timeSeriesTransformations, memberWritingClosure: ForecastClientTypes.TimeSeriesTransformation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WhatIfAnalysisArn"].write(value.whatIfAnalysisArn)
        try writer["WhatIfForecastName"].write(value.whatIfForecastName)
    }
}

extension CreateWhatIfForecastExportInput {

    static func write(value: CreateWhatIfForecastExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination, with: ForecastClientTypes.DataDestination.write(value:to:))
        try writer["Format"].write(value.format)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WhatIfForecastArns"].writeList(value.whatIfForecastArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WhatIfForecastExportName"].write(value.whatIfForecastExportName)
    }
}

extension DeleteDatasetInput {

    static func write(value: DeleteDatasetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatasetArn"].write(value.datasetArn)
    }
}

extension DeleteDatasetGroupInput {

    static func write(value: DeleteDatasetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatasetGroupArn"].write(value.datasetGroupArn)
    }
}

extension DeleteDatasetImportJobInput {

    static func write(value: DeleteDatasetImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatasetImportJobArn"].write(value.datasetImportJobArn)
    }
}

extension DeleteExplainabilityInput {

    static func write(value: DeleteExplainabilityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExplainabilityArn"].write(value.explainabilityArn)
    }
}

extension DeleteExplainabilityExportInput {

    static func write(value: DeleteExplainabilityExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExplainabilityExportArn"].write(value.explainabilityExportArn)
    }
}

extension DeleteForecastInput {

    static func write(value: DeleteForecastInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForecastArn"].write(value.forecastArn)
    }
}

extension DeleteForecastExportJobInput {

    static func write(value: DeleteForecastExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForecastExportJobArn"].write(value.forecastExportJobArn)
    }
}

extension DeleteMonitorInput {

    static func write(value: DeleteMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MonitorArn"].write(value.monitorArn)
    }
}

extension DeletePredictorInput {

    static func write(value: DeletePredictorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PredictorArn"].write(value.predictorArn)
    }
}

extension DeletePredictorBacktestExportJobInput {

    static func write(value: DeletePredictorBacktestExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PredictorBacktestExportJobArn"].write(value.predictorBacktestExportJobArn)
    }
}

extension DeleteResourceTreeInput {

    static func write(value: DeleteResourceTreeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension DeleteWhatIfAnalysisInput {

    static func write(value: DeleteWhatIfAnalysisInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WhatIfAnalysisArn"].write(value.whatIfAnalysisArn)
    }
}

extension DeleteWhatIfForecastInput {

    static func write(value: DeleteWhatIfForecastInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WhatIfForecastArn"].write(value.whatIfForecastArn)
    }
}

extension DeleteWhatIfForecastExportInput {

    static func write(value: DeleteWhatIfForecastExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WhatIfForecastExportArn"].write(value.whatIfForecastExportArn)
    }
}

extension DescribeAutoPredictorInput {

    static func write(value: DescribeAutoPredictorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PredictorArn"].write(value.predictorArn)
    }
}

extension DescribeDatasetInput {

    static func write(value: DescribeDatasetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatasetArn"].write(value.datasetArn)
    }
}

extension DescribeDatasetGroupInput {

    static func write(value: DescribeDatasetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatasetGroupArn"].write(value.datasetGroupArn)
    }
}

extension DescribeDatasetImportJobInput {

    static func write(value: DescribeDatasetImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatasetImportJobArn"].write(value.datasetImportJobArn)
    }
}

extension DescribeExplainabilityInput {

    static func write(value: DescribeExplainabilityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExplainabilityArn"].write(value.explainabilityArn)
    }
}

extension DescribeExplainabilityExportInput {

    static func write(value: DescribeExplainabilityExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExplainabilityExportArn"].write(value.explainabilityExportArn)
    }
}

extension DescribeForecastInput {

    static func write(value: DescribeForecastInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForecastArn"].write(value.forecastArn)
    }
}

extension DescribeForecastExportJobInput {

    static func write(value: DescribeForecastExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForecastExportJobArn"].write(value.forecastExportJobArn)
    }
}

extension DescribeMonitorInput {

    static func write(value: DescribeMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MonitorArn"].write(value.monitorArn)
    }
}

extension DescribePredictorInput {

    static func write(value: DescribePredictorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PredictorArn"].write(value.predictorArn)
    }
}

extension DescribePredictorBacktestExportJobInput {

    static func write(value: DescribePredictorBacktestExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PredictorBacktestExportJobArn"].write(value.predictorBacktestExportJobArn)
    }
}

extension DescribeWhatIfAnalysisInput {

    static func write(value: DescribeWhatIfAnalysisInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WhatIfAnalysisArn"].write(value.whatIfAnalysisArn)
    }
}

extension DescribeWhatIfForecastInput {

    static func write(value: DescribeWhatIfForecastInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WhatIfForecastArn"].write(value.whatIfForecastArn)
    }
}

extension DescribeWhatIfForecastExportInput {

    static func write(value: DescribeWhatIfForecastExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WhatIfForecastExportArn"].write(value.whatIfForecastExportArn)
    }
}

extension GetAccuracyMetricsInput {

    static func write(value: GetAccuracyMetricsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PredictorArn"].write(value.predictorArn)
    }
}

extension ListDatasetGroupsInput {

    static func write(value: ListDatasetGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListDatasetImportJobsInput {

    static func write(value: ListDatasetImportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ForecastClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListDatasetsInput {

    static func write(value: ListDatasetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListExplainabilitiesInput {

    static func write(value: ListExplainabilitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ForecastClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListExplainabilityExportsInput {

    static func write(value: ListExplainabilityExportsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ForecastClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListForecastExportJobsInput {

    static func write(value: ListForecastExportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ForecastClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListForecastsInput {

    static func write(value: ListForecastsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ForecastClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListMonitorEvaluationsInput {

    static func write(value: ListMonitorEvaluationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ForecastClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["MonitorArn"].write(value.monitorArn)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListMonitorsInput {

    static func write(value: ListMonitorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ForecastClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListPredictorBacktestExportJobsInput {

    static func write(value: ListPredictorBacktestExportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ForecastClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListPredictorsInput {

    static func write(value: ListPredictorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ForecastClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ListWhatIfAnalysesInput {

    static func write(value: ListWhatIfAnalysesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ForecastClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListWhatIfForecastExportsInput {

    static func write(value: ListWhatIfForecastExportsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ForecastClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListWhatIfForecastsInput {

    static func write(value: ListWhatIfForecastsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ForecastClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ResumeResourceInput {

    static func write(value: ResumeResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension StopResourceInput {

    static func write(value: StopResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ForecastClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDatasetGroupInput {

    static func write(value: UpdateDatasetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatasetArns"].writeList(value.datasetArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DatasetGroupArn"].write(value.datasetGroupArn)
    }
}

extension CreateAutoPredictorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAutoPredictorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAutoPredictorOutput()
        value.predictorArn = try reader["PredictorArn"].readIfPresent()
        return value
    }
}

extension CreateDatasetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDatasetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDatasetOutput()
        value.datasetArn = try reader["DatasetArn"].readIfPresent()
        return value
    }
}

extension CreateDatasetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDatasetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDatasetGroupOutput()
        value.datasetGroupArn = try reader["DatasetGroupArn"].readIfPresent()
        return value
    }
}

extension CreateDatasetImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDatasetImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDatasetImportJobOutput()
        value.datasetImportJobArn = try reader["DatasetImportJobArn"].readIfPresent()
        return value
    }
}

extension CreateExplainabilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateExplainabilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateExplainabilityOutput()
        value.explainabilityArn = try reader["ExplainabilityArn"].readIfPresent()
        return value
    }
}

extension CreateExplainabilityExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateExplainabilityExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateExplainabilityExportOutput()
        value.explainabilityExportArn = try reader["ExplainabilityExportArn"].readIfPresent()
        return value
    }
}

extension CreateForecastOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateForecastOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateForecastOutput()
        value.forecastArn = try reader["ForecastArn"].readIfPresent()
        return value
    }
}

extension CreateForecastExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateForecastExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateForecastExportJobOutput()
        value.forecastExportJobArn = try reader["ForecastExportJobArn"].readIfPresent()
        return value
    }
}

extension CreateMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMonitorOutput()
        value.monitorArn = try reader["MonitorArn"].readIfPresent()
        return value
    }
}

extension CreatePredictorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePredictorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePredictorOutput()
        value.predictorArn = try reader["PredictorArn"].readIfPresent()
        return value
    }
}

extension CreatePredictorBacktestExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePredictorBacktestExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePredictorBacktestExportJobOutput()
        value.predictorBacktestExportJobArn = try reader["PredictorBacktestExportJobArn"].readIfPresent()
        return value
    }
}

extension CreateWhatIfAnalysisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWhatIfAnalysisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWhatIfAnalysisOutput()
        value.whatIfAnalysisArn = try reader["WhatIfAnalysisArn"].readIfPresent()
        return value
    }
}

extension CreateWhatIfForecastOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWhatIfForecastOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWhatIfForecastOutput()
        value.whatIfForecastArn = try reader["WhatIfForecastArn"].readIfPresent()
        return value
    }
}

extension CreateWhatIfForecastExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWhatIfForecastExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWhatIfForecastExportOutput()
        value.whatIfForecastExportArn = try reader["WhatIfForecastExportArn"].readIfPresent()
        return value
    }
}

extension DeleteDatasetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDatasetOutput {
        return DeleteDatasetOutput()
    }
}

extension DeleteDatasetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDatasetGroupOutput {
        return DeleteDatasetGroupOutput()
    }
}

extension DeleteDatasetImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDatasetImportJobOutput {
        return DeleteDatasetImportJobOutput()
    }
}

extension DeleteExplainabilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteExplainabilityOutput {
        return DeleteExplainabilityOutput()
    }
}

extension DeleteExplainabilityExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteExplainabilityExportOutput {
        return DeleteExplainabilityExportOutput()
    }
}

extension DeleteForecastOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteForecastOutput {
        return DeleteForecastOutput()
    }
}

extension DeleteForecastExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteForecastExportJobOutput {
        return DeleteForecastExportJobOutput()
    }
}

extension DeleteMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMonitorOutput {
        return DeleteMonitorOutput()
    }
}

extension DeletePredictorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePredictorOutput {
        return DeletePredictorOutput()
    }
}

extension DeletePredictorBacktestExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePredictorBacktestExportJobOutput {
        return DeletePredictorBacktestExportJobOutput()
    }
}

extension DeleteResourceTreeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourceTreeOutput {
        return DeleteResourceTreeOutput()
    }
}

extension DeleteWhatIfAnalysisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWhatIfAnalysisOutput {
        return DeleteWhatIfAnalysisOutput()
    }
}

extension DeleteWhatIfForecastOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWhatIfForecastOutput {
        return DeleteWhatIfForecastOutput()
    }
}

extension DeleteWhatIfForecastExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWhatIfForecastExportOutput {
        return DeleteWhatIfForecastExportOutput()
    }
}

extension DescribeAutoPredictorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAutoPredictorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAutoPredictorOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataConfig = try reader["DataConfig"].readIfPresent(with: ForecastClientTypes.DataConfig.read(from:))
        value.datasetImportJobArns = try reader["DatasetImportJobArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.encryptionConfig = try reader["EncryptionConfig"].readIfPresent(with: ForecastClientTypes.EncryptionConfig.read(from:))
        value.estimatedTimeRemainingInMinutes = try reader["EstimatedTimeRemainingInMinutes"].readIfPresent()
        value.explainabilityInfo = try reader["ExplainabilityInfo"].readIfPresent(with: ForecastClientTypes.ExplainabilityInfo.read(from:))
        value.forecastDimensions = try reader["ForecastDimensions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.forecastFrequency = try reader["ForecastFrequency"].readIfPresent()
        value.forecastHorizon = try reader["ForecastHorizon"].readIfPresent()
        value.forecastTypes = try reader["ForecastTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.monitorInfo = try reader["MonitorInfo"].readIfPresent(with: ForecastClientTypes.MonitorInfo.read(from:))
        value.optimizationMetric = try reader["OptimizationMetric"].readIfPresent()
        value.predictorArn = try reader["PredictorArn"].readIfPresent()
        value.predictorName = try reader["PredictorName"].readIfPresent()
        value.referencePredictorSummary = try reader["ReferencePredictorSummary"].readIfPresent(with: ForecastClientTypes.ReferencePredictorSummary.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.timeAlignmentBoundary = try reader["TimeAlignmentBoundary"].readIfPresent(with: ForecastClientTypes.TimeAlignmentBoundary.read(from:))
        return value
    }
}

extension DescribeDatasetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDatasetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDatasetOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataFrequency = try reader["DataFrequency"].readIfPresent()
        value.datasetArn = try reader["DatasetArn"].readIfPresent()
        value.datasetName = try reader["DatasetName"].readIfPresent()
        value.datasetType = try reader["DatasetType"].readIfPresent()
        value.domain = try reader["Domain"].readIfPresent()
        value.encryptionConfig = try reader["EncryptionConfig"].readIfPresent(with: ForecastClientTypes.EncryptionConfig.read(from:))
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.schema = try reader["Schema"].readIfPresent(with: ForecastClientTypes.Schema.read(from:))
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeDatasetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDatasetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDatasetGroupOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.datasetArns = try reader["DatasetArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.datasetGroupArn = try reader["DatasetGroupArn"].readIfPresent()
        value.datasetGroupName = try reader["DatasetGroupName"].readIfPresent()
        value.domain = try reader["Domain"].readIfPresent()
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeDatasetImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDatasetImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDatasetImportJobOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataSize = try reader["DataSize"].readIfPresent()
        value.dataSource = try reader["DataSource"].readIfPresent(with: ForecastClientTypes.DataSource.read(from:))
        value.datasetArn = try reader["DatasetArn"].readIfPresent()
        value.datasetImportJobArn = try reader["DatasetImportJobArn"].readIfPresent()
        value.datasetImportJobName = try reader["DatasetImportJobName"].readIfPresent()
        value.estimatedTimeRemainingInMinutes = try reader["EstimatedTimeRemainingInMinutes"].readIfPresent()
        value.fieldStatistics = try reader["FieldStatistics"].readMapIfPresent(valueReadingClosure: ForecastClientTypes.Statistics.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.format = try reader["Format"].readIfPresent()
        value.geolocationFormat = try reader["GeolocationFormat"].readIfPresent()
        value.importMode = try reader["ImportMode"].readIfPresent()
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.timeZone = try reader["TimeZone"].readIfPresent()
        value.timestampFormat = try reader["TimestampFormat"].readIfPresent()
        value.useGeolocationForTimeZone = try reader["UseGeolocationForTimeZone"].readIfPresent() ?? false
        return value
    }
}

extension DescribeExplainabilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeExplainabilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeExplainabilityOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataSource = try reader["DataSource"].readIfPresent(with: ForecastClientTypes.DataSource.read(from:))
        value.enableVisualization = try reader["EnableVisualization"].readIfPresent()
        value.endDateTime = try reader["EndDateTime"].readIfPresent()
        value.estimatedTimeRemainingInMinutes = try reader["EstimatedTimeRemainingInMinutes"].readIfPresent()
        value.explainabilityArn = try reader["ExplainabilityArn"].readIfPresent()
        value.explainabilityConfig = try reader["ExplainabilityConfig"].readIfPresent(with: ForecastClientTypes.ExplainabilityConfig.read(from:))
        value.explainabilityName = try reader["ExplainabilityName"].readIfPresent()
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.schema = try reader["Schema"].readIfPresent(with: ForecastClientTypes.Schema.read(from:))
        value.startDateTime = try reader["StartDateTime"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeExplainabilityExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeExplainabilityExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeExplainabilityExportOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destination = try reader["Destination"].readIfPresent(with: ForecastClientTypes.DataDestination.read(from:))
        value.explainabilityArn = try reader["ExplainabilityArn"].readIfPresent()
        value.explainabilityExportArn = try reader["ExplainabilityExportArn"].readIfPresent()
        value.explainabilityExportName = try reader["ExplainabilityExportName"].readIfPresent()
        value.format = try reader["Format"].readIfPresent()
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeForecastOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeForecastOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeForecastOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.datasetGroupArn = try reader["DatasetGroupArn"].readIfPresent()
        value.estimatedTimeRemainingInMinutes = try reader["EstimatedTimeRemainingInMinutes"].readIfPresent()
        value.forecastArn = try reader["ForecastArn"].readIfPresent()
        value.forecastName = try reader["ForecastName"].readIfPresent()
        value.forecastTypes = try reader["ForecastTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.predictorArn = try reader["PredictorArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.timeSeriesSelector = try reader["TimeSeriesSelector"].readIfPresent(with: ForecastClientTypes.TimeSeriesSelector.read(from:))
        return value
    }
}

extension DescribeForecastExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeForecastExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeForecastExportJobOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destination = try reader["Destination"].readIfPresent(with: ForecastClientTypes.DataDestination.read(from:))
        value.forecastArn = try reader["ForecastArn"].readIfPresent()
        value.forecastExportJobArn = try reader["ForecastExportJobArn"].readIfPresent()
        value.forecastExportJobName = try reader["ForecastExportJobName"].readIfPresent()
        value.format = try reader["Format"].readIfPresent()
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMonitorOutput()
        value.baseline = try reader["Baseline"].readIfPresent(with: ForecastClientTypes.Baseline.read(from:))
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.estimatedEvaluationTimeRemainingInMinutes = try reader["EstimatedEvaluationTimeRemainingInMinutes"].readIfPresent()
        value.lastEvaluationState = try reader["LastEvaluationState"].readIfPresent()
        value.lastEvaluationTime = try reader["LastEvaluationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.monitorArn = try reader["MonitorArn"].readIfPresent()
        value.monitorName = try reader["MonitorName"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribePredictorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePredictorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePredictorOutput()
        value.algorithmArn = try reader["AlgorithmArn"].readIfPresent()
        value.autoMLAlgorithmArns = try reader["AutoMLAlgorithmArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.autoMLOverrideStrategy = try reader["AutoMLOverrideStrategy"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.datasetImportJobArns = try reader["DatasetImportJobArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.encryptionConfig = try reader["EncryptionConfig"].readIfPresent(with: ForecastClientTypes.EncryptionConfig.read(from:))
        value.estimatedTimeRemainingInMinutes = try reader["EstimatedTimeRemainingInMinutes"].readIfPresent()
        value.evaluationParameters = try reader["EvaluationParameters"].readIfPresent(with: ForecastClientTypes.EvaluationParameters.read(from:))
        value.featurizationConfig = try reader["FeaturizationConfig"].readIfPresent(with: ForecastClientTypes.FeaturizationConfig.read(from:))
        value.forecastHorizon = try reader["ForecastHorizon"].readIfPresent()
        value.forecastTypes = try reader["ForecastTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.hpoConfig = try reader["HPOConfig"].readIfPresent(with: ForecastClientTypes.HyperParameterTuningJobConfig.read(from:))
        value.inputDataConfig = try reader["InputDataConfig"].readIfPresent(with: ForecastClientTypes.InputDataConfig.read(from:))
        value.isAutoPredictor = try reader["IsAutoPredictor"].readIfPresent()
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.optimizationMetric = try reader["OptimizationMetric"].readIfPresent()
        value.performAutoML = try reader["PerformAutoML"].readIfPresent()
        value.performHPO = try reader["PerformHPO"].readIfPresent()
        value.predictorArn = try reader["PredictorArn"].readIfPresent()
        value.predictorExecutionDetails = try reader["PredictorExecutionDetails"].readIfPresent(with: ForecastClientTypes.PredictorExecutionDetails.read(from:))
        value.predictorName = try reader["PredictorName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.trainingParameters = try reader["TrainingParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribePredictorBacktestExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePredictorBacktestExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePredictorBacktestExportJobOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destination = try reader["Destination"].readIfPresent(with: ForecastClientTypes.DataDestination.read(from:))
        value.format = try reader["Format"].readIfPresent()
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.predictorArn = try reader["PredictorArn"].readIfPresent()
        value.predictorBacktestExportJobArn = try reader["PredictorBacktestExportJobArn"].readIfPresent()
        value.predictorBacktestExportJobName = try reader["PredictorBacktestExportJobName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeWhatIfAnalysisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWhatIfAnalysisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWhatIfAnalysisOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.estimatedTimeRemainingInMinutes = try reader["EstimatedTimeRemainingInMinutes"].readIfPresent()
        value.forecastArn = try reader["ForecastArn"].readIfPresent()
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.timeSeriesSelector = try reader["TimeSeriesSelector"].readIfPresent(with: ForecastClientTypes.TimeSeriesSelector.read(from:))
        value.whatIfAnalysisArn = try reader["WhatIfAnalysisArn"].readIfPresent()
        value.whatIfAnalysisName = try reader["WhatIfAnalysisName"].readIfPresent()
        return value
    }
}

extension DescribeWhatIfForecastOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWhatIfForecastOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWhatIfForecastOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.estimatedTimeRemainingInMinutes = try reader["EstimatedTimeRemainingInMinutes"].readIfPresent()
        value.forecastTypes = try reader["ForecastTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.timeSeriesReplacementsDataSource = try reader["TimeSeriesReplacementsDataSource"].readIfPresent(with: ForecastClientTypes.TimeSeriesReplacementsDataSource.read(from:))
        value.timeSeriesTransformations = try reader["TimeSeriesTransformations"].readListIfPresent(memberReadingClosure: ForecastClientTypes.TimeSeriesTransformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.whatIfAnalysisArn = try reader["WhatIfAnalysisArn"].readIfPresent()
        value.whatIfForecastArn = try reader["WhatIfForecastArn"].readIfPresent()
        value.whatIfForecastName = try reader["WhatIfForecastName"].readIfPresent()
        return value
    }
}

extension DescribeWhatIfForecastExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWhatIfForecastExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWhatIfForecastExportOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destination = try reader["Destination"].readIfPresent(with: ForecastClientTypes.DataDestination.read(from:))
        value.estimatedTimeRemainingInMinutes = try reader["EstimatedTimeRemainingInMinutes"].readIfPresent()
        value.format = try reader["Format"].readIfPresent()
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.whatIfForecastArns = try reader["WhatIfForecastArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.whatIfForecastExportArn = try reader["WhatIfForecastExportArn"].readIfPresent()
        value.whatIfForecastExportName = try reader["WhatIfForecastExportName"].readIfPresent()
        return value
    }
}

extension GetAccuracyMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccuracyMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccuracyMetricsOutput()
        value.autoMLOverrideStrategy = try reader["AutoMLOverrideStrategy"].readIfPresent()
        value.isAutoPredictor = try reader["IsAutoPredictor"].readIfPresent()
        value.optimizationMetric = try reader["OptimizationMetric"].readIfPresent()
        value.predictorEvaluationResults = try reader["PredictorEvaluationResults"].readListIfPresent(memberReadingClosure: ForecastClientTypes.EvaluationResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDatasetGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDatasetGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDatasetGroupsOutput()
        value.datasetGroups = try reader["DatasetGroups"].readListIfPresent(memberReadingClosure: ForecastClientTypes.DatasetGroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDatasetImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDatasetImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDatasetImportJobsOutput()
        value.datasetImportJobs = try reader["DatasetImportJobs"].readListIfPresent(memberReadingClosure: ForecastClientTypes.DatasetImportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDatasetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDatasetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDatasetsOutput()
        value.datasets = try reader["Datasets"].readListIfPresent(memberReadingClosure: ForecastClientTypes.DatasetSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListExplainabilitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExplainabilitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExplainabilitiesOutput()
        value.explainabilities = try reader["Explainabilities"].readListIfPresent(memberReadingClosure: ForecastClientTypes.ExplainabilitySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListExplainabilityExportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExplainabilityExportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExplainabilityExportsOutput()
        value.explainabilityExports = try reader["ExplainabilityExports"].readListIfPresent(memberReadingClosure: ForecastClientTypes.ExplainabilityExportSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListForecastExportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListForecastExportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListForecastExportJobsOutput()
        value.forecastExportJobs = try reader["ForecastExportJobs"].readListIfPresent(memberReadingClosure: ForecastClientTypes.ForecastExportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListForecastsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListForecastsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListForecastsOutput()
        value.forecasts = try reader["Forecasts"].readListIfPresent(memberReadingClosure: ForecastClientTypes.ForecastSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMonitorEvaluationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMonitorEvaluationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMonitorEvaluationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.predictorMonitorEvaluations = try reader["PredictorMonitorEvaluations"].readListIfPresent(memberReadingClosure: ForecastClientTypes.PredictorMonitorEvaluation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListMonitorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMonitorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMonitorsOutput()
        value.monitors = try reader["Monitors"].readListIfPresent(memberReadingClosure: ForecastClientTypes.MonitorSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPredictorBacktestExportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPredictorBacktestExportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPredictorBacktestExportJobsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.predictorBacktestExportJobs = try reader["PredictorBacktestExportJobs"].readListIfPresent(memberReadingClosure: ForecastClientTypes.PredictorBacktestExportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPredictorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPredictorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPredictorsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.predictors = try reader["Predictors"].readListIfPresent(memberReadingClosure: ForecastClientTypes.PredictorSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ForecastClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWhatIfAnalysesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWhatIfAnalysesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWhatIfAnalysesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.whatIfAnalyses = try reader["WhatIfAnalyses"].readListIfPresent(memberReadingClosure: ForecastClientTypes.WhatIfAnalysisSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWhatIfForecastExportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWhatIfForecastExportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWhatIfForecastExportsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.whatIfForecastExports = try reader["WhatIfForecastExports"].readListIfPresent(memberReadingClosure: ForecastClientTypes.WhatIfForecastExportSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWhatIfForecastsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWhatIfForecastsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWhatIfForecastsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.whatIfForecasts = try reader["WhatIfForecasts"].readListIfPresent(memberReadingClosure: ForecastClientTypes.WhatIfForecastSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ResumeResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResumeResourceOutput {
        return ResumeResourceOutput()
    }
}

extension StopResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopResourceOutput {
        return StopResourceOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDatasetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDatasetGroupOutput {
        return UpdateDatasetGroupOutput()
    }
}

enum CreateAutoPredictorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDatasetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDatasetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDatasetImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateExplainabilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateExplainabilityExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateForecastOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateForecastExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePredictorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePredictorBacktestExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWhatIfAnalysisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWhatIfForecastOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWhatIfForecastExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDatasetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDatasetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDatasetImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteExplainabilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteExplainabilityExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteForecastOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteForecastExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePredictorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePredictorBacktestExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourceTreeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWhatIfAnalysisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWhatIfForecastOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWhatIfForecastExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAutoPredictorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDatasetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDatasetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDatasetImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeExplainabilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeExplainabilityExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeForecastOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeForecastExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePredictorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePredictorBacktestExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWhatIfAnalysisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWhatIfForecastOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWhatIfForecastExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccuracyMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDatasetGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDatasetImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDatasetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExplainabilitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExplainabilityExportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListForecastExportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListForecastsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMonitorEvaluationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMonitorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPredictorBacktestExportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPredictorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWhatIfAnalysesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWhatIfForecastExportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWhatIfForecastsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResumeResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDatasetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidInputException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInputException {
        let reader = baseError.errorBodyReader
        var value = InvalidInputException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForecastClientTypes.DataConfig {

    static func write(value: ForecastClientTypes.DataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalDatasets"].writeList(value.additionalDatasets, memberWritingClosure: ForecastClientTypes.AdditionalDataset.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AttributeConfigs"].writeList(value.attributeConfigs, memberWritingClosure: ForecastClientTypes.AttributeConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DatasetGroupArn"].write(value.datasetGroupArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.DataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.DataConfig()
        value.datasetGroupArn = try reader["DatasetGroupArn"].readIfPresent() ?? ""
        value.attributeConfigs = try reader["AttributeConfigs"].readListIfPresent(memberReadingClosure: ForecastClientTypes.AttributeConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.additionalDatasets = try reader["AdditionalDatasets"].readListIfPresent(memberReadingClosure: ForecastClientTypes.AdditionalDataset.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ForecastClientTypes.AdditionalDataset {

    static func write(value: ForecastClientTypes.AdditionalDataset?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configuration"].writeMap(value.configuration, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.AdditionalDataset {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.AdditionalDataset()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.configuration = try reader["Configuration"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ForecastClientTypes.AttributeConfig {

    static func write(value: ForecastClientTypes.AttributeConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["Transformations"].writeMap(value.transformations, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.AttributeConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.AttributeConfig()
        value.attributeName = try reader["AttributeName"].readIfPresent() ?? ""
        value.transformations = try reader["Transformations"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension ForecastClientTypes.EncryptionConfig {

    static func write(value: ForecastClientTypes.EncryptionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KMSKeyArn"].write(value.kmsKeyArn)
        try writer["RoleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.EncryptionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.EncryptionConfig()
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent() ?? ""
        return value
    }
}

extension ForecastClientTypes.ReferencePredictorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.ReferencePredictorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.ReferencePredictorSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.ExplainabilityInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.ExplainabilityInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.ExplainabilityInfo()
        value.explainabilityArn = try reader["ExplainabilityArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.MonitorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.MonitorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.MonitorInfo()
        value.monitorArn = try reader["MonitorArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.TimeAlignmentBoundary {

    static func write(value: ForecastClientTypes.TimeAlignmentBoundary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DayOfMonth"].write(value.dayOfMonth)
        try writer["DayOfWeek"].write(value.dayOfWeek)
        try writer["Hour"].write(value.hour)
        try writer["Month"].write(value.month)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.TimeAlignmentBoundary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.TimeAlignmentBoundary()
        value.month = try reader["Month"].readIfPresent()
        value.dayOfMonth = try reader["DayOfMonth"].readIfPresent()
        value.dayOfWeek = try reader["DayOfWeek"].readIfPresent()
        value.hour = try reader["Hour"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.Schema {

    static func write(value: ForecastClientTypes.Schema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeList(value.attributes, memberWritingClosure: ForecastClientTypes.SchemaAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.Schema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.Schema()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: ForecastClientTypes.SchemaAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ForecastClientTypes.SchemaAttribute {

    static func write(value: ForecastClientTypes.SchemaAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["AttributeType"].write(value.attributeType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.SchemaAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.SchemaAttribute()
        value.attributeName = try reader["AttributeName"].readIfPresent()
        value.attributeType = try reader["AttributeType"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.DataSource {

    static func write(value: ForecastClientTypes.DataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Config"].write(value.s3Config, with: ForecastClientTypes.S3Config.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.DataSource()
        value.s3Config = try reader["S3Config"].readIfPresent(with: ForecastClientTypes.S3Config.read(from:))
        return value
    }
}

extension ForecastClientTypes.S3Config {

    static func write(value: ForecastClientTypes.S3Config?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KMSKeyArn"].write(value.kmsKeyArn)
        try writer["Path"].write(value.path)
        try writer["RoleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.S3Config {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.S3Config()
        value.path = try reader["Path"].readIfPresent() ?? ""
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.Statistics {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.Statistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.Statistics()
        value.count = try reader["Count"].readIfPresent()
        value.countDistinct = try reader["CountDistinct"].readIfPresent()
        value.countNull = try reader["CountNull"].readIfPresent()
        value.countNan = try reader["CountNan"].readIfPresent()
        value.min = try reader["Min"].readIfPresent()
        value.max = try reader["Max"].readIfPresent()
        value.avg = try reader["Avg"].readIfPresent()
        value.stddev = try reader["Stddev"].readIfPresent()
        value.countLong = try reader["CountLong"].readIfPresent()
        value.countDistinctLong = try reader["CountDistinctLong"].readIfPresent()
        value.countNullLong = try reader["CountNullLong"].readIfPresent()
        value.countNanLong = try reader["CountNanLong"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.ExplainabilityConfig {

    static func write(value: ForecastClientTypes.ExplainabilityConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TimePointGranularity"].write(value.timePointGranularity)
        try writer["TimeSeriesGranularity"].write(value.timeSeriesGranularity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.ExplainabilityConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.ExplainabilityConfig()
        value.timeSeriesGranularity = try reader["TimeSeriesGranularity"].readIfPresent() ?? .sdkUnknown("")
        value.timePointGranularity = try reader["TimePointGranularity"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ForecastClientTypes.DataDestination {

    static func write(value: ForecastClientTypes.DataDestination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Config"].write(value.s3Config, with: ForecastClientTypes.S3Config.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.DataDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.DataDestination()
        value.s3Config = try reader["S3Config"].readIfPresent(with: ForecastClientTypes.S3Config.read(from:))
        return value
    }
}

extension ForecastClientTypes.TimeSeriesSelector {

    static func write(value: ForecastClientTypes.TimeSeriesSelector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TimeSeriesIdentifiers"].write(value.timeSeriesIdentifiers, with: ForecastClientTypes.TimeSeriesIdentifiers.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.TimeSeriesSelector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.TimeSeriesSelector()
        value.timeSeriesIdentifiers = try reader["TimeSeriesIdentifiers"].readIfPresent(with: ForecastClientTypes.TimeSeriesIdentifiers.read(from:))
        return value
    }
}

extension ForecastClientTypes.TimeSeriesIdentifiers {

    static func write(value: ForecastClientTypes.TimeSeriesIdentifiers?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSource"].write(value.dataSource, with: ForecastClientTypes.DataSource.write(value:to:))
        try writer["Format"].write(value.format)
        try writer["Schema"].write(value.schema, with: ForecastClientTypes.Schema.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.TimeSeriesIdentifiers {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.TimeSeriesIdentifiers()
        value.dataSource = try reader["DataSource"].readIfPresent(with: ForecastClientTypes.DataSource.read(from:))
        value.schema = try reader["Schema"].readIfPresent(with: ForecastClientTypes.Schema.read(from:))
        value.format = try reader["Format"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.Baseline {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.Baseline {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.Baseline()
        value.predictorBaseline = try reader["PredictorBaseline"].readIfPresent(with: ForecastClientTypes.PredictorBaseline.read(from:))
        return value
    }
}

extension ForecastClientTypes.PredictorBaseline {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.PredictorBaseline {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.PredictorBaseline()
        value.baselineMetrics = try reader["BaselineMetrics"].readListIfPresent(memberReadingClosure: ForecastClientTypes.BaselineMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ForecastClientTypes.BaselineMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.BaselineMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.BaselineMetric()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.EvaluationParameters {

    static func write(value: ForecastClientTypes.EvaluationParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackTestWindowOffset"].write(value.backTestWindowOffset)
        try writer["NumberOfBacktestWindows"].write(value.numberOfBacktestWindows)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.EvaluationParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.EvaluationParameters()
        value.numberOfBacktestWindows = try reader["NumberOfBacktestWindows"].readIfPresent()
        value.backTestWindowOffset = try reader["BackTestWindowOffset"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.HyperParameterTuningJobConfig {

    static func write(value: ForecastClientTypes.HyperParameterTuningJobConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ParameterRanges"].write(value.parameterRanges, with: ForecastClientTypes.ParameterRanges.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.HyperParameterTuningJobConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.HyperParameterTuningJobConfig()
        value.parameterRanges = try reader["ParameterRanges"].readIfPresent(with: ForecastClientTypes.ParameterRanges.read(from:))
        return value
    }
}

extension ForecastClientTypes.ParameterRanges {

    static func write(value: ForecastClientTypes.ParameterRanges?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoricalParameterRanges"].writeList(value.categoricalParameterRanges, memberWritingClosure: ForecastClientTypes.CategoricalParameterRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ContinuousParameterRanges"].writeList(value.continuousParameterRanges, memberWritingClosure: ForecastClientTypes.ContinuousParameterRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IntegerParameterRanges"].writeList(value.integerParameterRanges, memberWritingClosure: ForecastClientTypes.IntegerParameterRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.ParameterRanges {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.ParameterRanges()
        value.categoricalParameterRanges = try reader["CategoricalParameterRanges"].readListIfPresent(memberReadingClosure: ForecastClientTypes.CategoricalParameterRange.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.continuousParameterRanges = try reader["ContinuousParameterRanges"].readListIfPresent(memberReadingClosure: ForecastClientTypes.ContinuousParameterRange.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.integerParameterRanges = try reader["IntegerParameterRanges"].readListIfPresent(memberReadingClosure: ForecastClientTypes.IntegerParameterRange.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ForecastClientTypes.IntegerParameterRange {

    static func write(value: ForecastClientTypes.IntegerParameterRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxValue"].write(value.maxValue)
        try writer["MinValue"].write(value.minValue)
        try writer["Name"].write(value.name)
        try writer["ScalingType"].write(value.scalingType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.IntegerParameterRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.IntegerParameterRange()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.maxValue = try reader["MaxValue"].readIfPresent() ?? 0
        value.minValue = try reader["MinValue"].readIfPresent() ?? 0
        value.scalingType = try reader["ScalingType"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.ContinuousParameterRange {

    static func write(value: ForecastClientTypes.ContinuousParameterRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxValue"].write(value.maxValue)
        try writer["MinValue"].write(value.minValue)
        try writer["Name"].write(value.name)
        try writer["ScalingType"].write(value.scalingType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.ContinuousParameterRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.ContinuousParameterRange()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.maxValue = try reader["MaxValue"].readIfPresent() ?? 0.0
        value.minValue = try reader["MinValue"].readIfPresent() ?? 0.0
        value.scalingType = try reader["ScalingType"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.CategoricalParameterRange {

    static func write(value: ForecastClientTypes.CategoricalParameterRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.CategoricalParameterRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.CategoricalParameterRange()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ForecastClientTypes.InputDataConfig {

    static func write(value: ForecastClientTypes.InputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatasetGroupArn"].write(value.datasetGroupArn)
        try writer["SupplementaryFeatures"].writeList(value.supplementaryFeatures, memberWritingClosure: ForecastClientTypes.SupplementaryFeature.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.InputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.InputDataConfig()
        value.datasetGroupArn = try reader["DatasetGroupArn"].readIfPresent() ?? ""
        value.supplementaryFeatures = try reader["SupplementaryFeatures"].readListIfPresent(memberReadingClosure: ForecastClientTypes.SupplementaryFeature.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ForecastClientTypes.SupplementaryFeature {

    static func write(value: ForecastClientTypes.SupplementaryFeature?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.SupplementaryFeature {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.SupplementaryFeature()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension ForecastClientTypes.FeaturizationConfig {

    static func write(value: ForecastClientTypes.FeaturizationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Featurizations"].writeList(value.featurizations, memberWritingClosure: ForecastClientTypes.Featurization.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ForecastDimensions"].writeList(value.forecastDimensions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ForecastFrequency"].write(value.forecastFrequency)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.FeaturizationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.FeaturizationConfig()
        value.forecastFrequency = try reader["ForecastFrequency"].readIfPresent() ?? ""
        value.forecastDimensions = try reader["ForecastDimensions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.featurizations = try reader["Featurizations"].readListIfPresent(memberReadingClosure: ForecastClientTypes.Featurization.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ForecastClientTypes.Featurization {

    static func write(value: ForecastClientTypes.Featurization?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["FeaturizationPipeline"].writeList(value.featurizationPipeline, memberWritingClosure: ForecastClientTypes.FeaturizationMethod.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.Featurization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.Featurization()
        value.attributeName = try reader["AttributeName"].readIfPresent() ?? ""
        value.featurizationPipeline = try reader["FeaturizationPipeline"].readListIfPresent(memberReadingClosure: ForecastClientTypes.FeaturizationMethod.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ForecastClientTypes.FeaturizationMethod {

    static func write(value: ForecastClientTypes.FeaturizationMethod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FeaturizationMethodName"].write(value.featurizationMethodName)
        try writer["FeaturizationMethodParameters"].writeMap(value.featurizationMethodParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.FeaturizationMethod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.FeaturizationMethod()
        value.featurizationMethodName = try reader["FeaturizationMethodName"].readIfPresent() ?? .sdkUnknown("")
        value.featurizationMethodParameters = try reader["FeaturizationMethodParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ForecastClientTypes.PredictorExecutionDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.PredictorExecutionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.PredictorExecutionDetails()
        value.predictorExecutions = try reader["PredictorExecutions"].readListIfPresent(memberReadingClosure: ForecastClientTypes.PredictorExecution.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ForecastClientTypes.PredictorExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.PredictorExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.PredictorExecution()
        value.algorithmArn = try reader["AlgorithmArn"].readIfPresent()
        value.testWindows = try reader["TestWindows"].readListIfPresent(memberReadingClosure: ForecastClientTypes.TestWindowSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ForecastClientTypes.TestWindowSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.TestWindowSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.TestWindowSummary()
        value.testWindowStart = try reader["TestWindowStart"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.testWindowEnd = try reader["TestWindowEnd"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.TimeSeriesTransformation {

    static func write(value: ForecastClientTypes.TimeSeriesTransformation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action, with: ForecastClientTypes.Action.write(value:to:))
        try writer["TimeSeriesConditions"].writeList(value.timeSeriesConditions, memberWritingClosure: ForecastClientTypes.TimeSeriesCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.TimeSeriesTransformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.TimeSeriesTransformation()
        value.action = try reader["Action"].readIfPresent(with: ForecastClientTypes.Action.read(from:))
        value.timeSeriesConditions = try reader["TimeSeriesConditions"].readListIfPresent(memberReadingClosure: ForecastClientTypes.TimeSeriesCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ForecastClientTypes.TimeSeriesCondition {

    static func write(value: ForecastClientTypes.TimeSeriesCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["AttributeValue"].write(value.attributeValue)
        try writer["Condition"].write(value.condition)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.TimeSeriesCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.TimeSeriesCondition()
        value.attributeName = try reader["AttributeName"].readIfPresent() ?? ""
        value.attributeValue = try reader["AttributeValue"].readIfPresent() ?? ""
        value.condition = try reader["Condition"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ForecastClientTypes.Action {

    static func write(value: ForecastClientTypes.Action?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["Operation"].write(value.operation)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.Action()
        value.attributeName = try reader["AttributeName"].readIfPresent() ?? ""
        value.operation = try reader["Operation"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["Value"].readIfPresent() ?? 0.0
        return value
    }
}

extension ForecastClientTypes.TimeSeriesReplacementsDataSource {

    static func write(value: ForecastClientTypes.TimeSeriesReplacementsDataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Format"].write(value.format)
        try writer["S3Config"].write(value.s3Config, with: ForecastClientTypes.S3Config.write(value:to:))
        try writer["Schema"].write(value.schema, with: ForecastClientTypes.Schema.write(value:to:))
        try writer["TimestampFormat"].write(value.timestampFormat)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.TimeSeriesReplacementsDataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.TimeSeriesReplacementsDataSource()
        value.s3Config = try reader["S3Config"].readIfPresent(with: ForecastClientTypes.S3Config.read(from:))
        value.schema = try reader["Schema"].readIfPresent(with: ForecastClientTypes.Schema.read(from:))
        value.format = try reader["Format"].readIfPresent()
        value.timestampFormat = try reader["TimestampFormat"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.EvaluationResult {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.EvaluationResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.EvaluationResult()
        value.algorithmArn = try reader["AlgorithmArn"].readIfPresent()
        value.testWindows = try reader["TestWindows"].readListIfPresent(memberReadingClosure: ForecastClientTypes.WindowSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ForecastClientTypes.WindowSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.WindowSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.WindowSummary()
        value.testWindowStart = try reader["TestWindowStart"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.testWindowEnd = try reader["TestWindowEnd"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.itemCount = try reader["ItemCount"].readIfPresent()
        value.evaluationType = try reader["EvaluationType"].readIfPresent()
        value.metrics = try reader["Metrics"].readIfPresent(with: ForecastClientTypes.Metrics.read(from:))
        return value
    }
}

extension ForecastClientTypes.Metrics {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.Metrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.Metrics()
        value.rmse = try reader["RMSE"].readIfPresent()
        value.weightedQuantileLosses = try reader["WeightedQuantileLosses"].readListIfPresent(memberReadingClosure: ForecastClientTypes.WeightedQuantileLoss.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorMetrics = try reader["ErrorMetrics"].readListIfPresent(memberReadingClosure: ForecastClientTypes.ErrorMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.averageWeightedQuantileLoss = try reader["AverageWeightedQuantileLoss"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.ErrorMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.ErrorMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.ErrorMetric()
        value.forecastType = try reader["ForecastType"].readIfPresent()
        value.wape = try reader["WAPE"].readIfPresent()
        value.rmse = try reader["RMSE"].readIfPresent()
        value.mase = try reader["MASE"].readIfPresent()
        value.mape = try reader["MAPE"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.WeightedQuantileLoss {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.WeightedQuantileLoss {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.WeightedQuantileLoss()
        value.quantile = try reader["Quantile"].readIfPresent()
        value.lossValue = try reader["LossValue"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.DatasetGroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.DatasetGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.DatasetGroupSummary()
        value.datasetGroupArn = try reader["DatasetGroupArn"].readIfPresent()
        value.datasetGroupName = try reader["DatasetGroupName"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ForecastClientTypes.DatasetImportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.DatasetImportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.DatasetImportJobSummary()
        value.datasetImportJobArn = try reader["DatasetImportJobArn"].readIfPresent()
        value.datasetImportJobName = try reader["DatasetImportJobName"].readIfPresent()
        value.dataSource = try reader["DataSource"].readIfPresent(with: ForecastClientTypes.DataSource.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.importMode = try reader["ImportMode"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.DatasetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.DatasetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.DatasetSummary()
        value.datasetArn = try reader["DatasetArn"].readIfPresent()
        value.datasetName = try reader["DatasetName"].readIfPresent()
        value.datasetType = try reader["DatasetType"].readIfPresent()
        value.domain = try reader["Domain"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ForecastClientTypes.ExplainabilitySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.ExplainabilitySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.ExplainabilitySummary()
        value.explainabilityArn = try reader["ExplainabilityArn"].readIfPresent()
        value.explainabilityName = try reader["ExplainabilityName"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.explainabilityConfig = try reader["ExplainabilityConfig"].readIfPresent(with: ForecastClientTypes.ExplainabilityConfig.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ForecastClientTypes.ExplainabilityExportSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.ExplainabilityExportSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.ExplainabilityExportSummary()
        value.explainabilityExportArn = try reader["ExplainabilityExportArn"].readIfPresent()
        value.explainabilityExportName = try reader["ExplainabilityExportName"].readIfPresent()
        value.destination = try reader["Destination"].readIfPresent(with: ForecastClientTypes.DataDestination.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ForecastClientTypes.ForecastExportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.ForecastExportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.ForecastExportJobSummary()
        value.forecastExportJobArn = try reader["ForecastExportJobArn"].readIfPresent()
        value.forecastExportJobName = try reader["ForecastExportJobName"].readIfPresent()
        value.destination = try reader["Destination"].readIfPresent(with: ForecastClientTypes.DataDestination.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ForecastClientTypes.ForecastSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.ForecastSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.ForecastSummary()
        value.forecastArn = try reader["ForecastArn"].readIfPresent()
        value.forecastName = try reader["ForecastName"].readIfPresent()
        value.predictorArn = try reader["PredictorArn"].readIfPresent()
        value.createdUsingAutoPredictor = try reader["CreatedUsingAutoPredictor"].readIfPresent()
        value.datasetGroupArn = try reader["DatasetGroupArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ForecastClientTypes.PredictorMonitorEvaluation {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.PredictorMonitorEvaluation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.PredictorMonitorEvaluation()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.monitorArn = try reader["MonitorArn"].readIfPresent()
        value.evaluationTime = try reader["EvaluationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.evaluationState = try reader["EvaluationState"].readIfPresent()
        value.windowStartDatetime = try reader["WindowStartDatetime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.windowEndDatetime = try reader["WindowEndDatetime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.predictorEvent = try reader["PredictorEvent"].readIfPresent(with: ForecastClientTypes.PredictorEvent.read(from:))
        value.monitorDataSource = try reader["MonitorDataSource"].readIfPresent(with: ForecastClientTypes.MonitorDataSource.read(from:))
        value.metricResults = try reader["MetricResults"].readListIfPresent(memberReadingClosure: ForecastClientTypes.MetricResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.numItemsEvaluated = try reader["NumItemsEvaluated"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.MetricResult {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.MetricResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.MetricResult()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.metricValue = try reader["MetricValue"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.MonitorDataSource {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.MonitorDataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.MonitorDataSource()
        value.datasetImportJobArn = try reader["DatasetImportJobArn"].readIfPresent()
        value.forecastArn = try reader["ForecastArn"].readIfPresent()
        value.predictorArn = try reader["PredictorArn"].readIfPresent()
        return value
    }
}

extension ForecastClientTypes.PredictorEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.PredictorEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.PredictorEvent()
        value.detail = try reader["Detail"].readIfPresent()
        value.datetime = try reader["Datetime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ForecastClientTypes.MonitorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.MonitorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.MonitorSummary()
        value.monitorArn = try reader["MonitorArn"].readIfPresent()
        value.monitorName = try reader["MonitorName"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ForecastClientTypes.PredictorBacktestExportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.PredictorBacktestExportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.PredictorBacktestExportJobSummary()
        value.predictorBacktestExportJobArn = try reader["PredictorBacktestExportJobArn"].readIfPresent()
        value.predictorBacktestExportJobName = try reader["PredictorBacktestExportJobName"].readIfPresent()
        value.destination = try reader["Destination"].readIfPresent(with: ForecastClientTypes.DataDestination.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ForecastClientTypes.PredictorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.PredictorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.PredictorSummary()
        value.predictorArn = try reader["PredictorArn"].readIfPresent()
        value.predictorName = try reader["PredictorName"].readIfPresent()
        value.datasetGroupArn = try reader["DatasetGroupArn"].readIfPresent()
        value.isAutoPredictor = try reader["IsAutoPredictor"].readIfPresent()
        value.referencePredictorSummary = try reader["ReferencePredictorSummary"].readIfPresent(with: ForecastClientTypes.ReferencePredictorSummary.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ForecastClientTypes.Tag {

    static func write(value: ForecastClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension ForecastClientTypes.WhatIfAnalysisSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.WhatIfAnalysisSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.WhatIfAnalysisSummary()
        value.whatIfAnalysisArn = try reader["WhatIfAnalysisArn"].readIfPresent()
        value.whatIfAnalysisName = try reader["WhatIfAnalysisName"].readIfPresent()
        value.forecastArn = try reader["ForecastArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ForecastClientTypes.WhatIfForecastExportSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.WhatIfForecastExportSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.WhatIfForecastExportSummary()
        value.whatIfForecastExportArn = try reader["WhatIfForecastExportArn"].readIfPresent()
        value.whatIfForecastArns = try reader["WhatIfForecastArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.whatIfForecastExportName = try reader["WhatIfForecastExportName"].readIfPresent()
        value.destination = try reader["Destination"].readIfPresent(with: ForecastClientTypes.DataDestination.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ForecastClientTypes.WhatIfForecastSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ForecastClientTypes.WhatIfForecastSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ForecastClientTypes.WhatIfForecastSummary()
        value.whatIfForecastArn = try reader["WhatIfForecastArn"].readIfPresent()
        value.whatIfForecastName = try reader["WhatIfForecastName"].readIfPresent()
        value.whatIfAnalysisArn = try reader["WhatIfAnalysisArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ForecastClientTypes.MonitorConfig {

    static func write(value: ForecastClientTypes.MonitorConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MonitorName"].write(value.monitorName)
    }
}

extension ForecastClientTypes.Filter {

    static func write(value: ForecastClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Condition"].write(value.condition)
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }
}

public enum ForecastClientTypes {}
