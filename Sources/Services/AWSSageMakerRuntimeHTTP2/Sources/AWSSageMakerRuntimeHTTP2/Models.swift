//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyEventStreams.DefaultMessageDecoder
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyEventStreamsAPI.MessageType
import enum SmithyReadWrite.ReaderError
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct SmithyEventStreams.DefaultMessageDecoderStream
import struct SmithyEventStreamsAPI.Header
import struct SmithyEventStreamsAPI.Message
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
import typealias SmithyEventStreamsAPI.MarshalClosure
import typealias SmithyEventStreamsAPI.UnmarshalClosure

/// The input fails to satisfy the constraints specified by an AWS service.
public struct InputValidationError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Error code.
        public internal(set) var errorCode: Swift.String? = nil
        /// Error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InputValidationError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Error code.
        public internal(set) var errorCode: Swift.String? = nil
        /// Error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

/// Internal stream failure that occurs during streaming.
public struct InternalStreamFailure: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalStreamFailure" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// An error occurred while processing the model.
public struct ModelError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Error code.
        public internal(set) var errorCode: Swift.String? = nil
        /// CloudWatch log stream ARN.
        public internal(set) var logStreamArn: Swift.String? = nil
        /// Error message.
        public internal(set) var message: Swift.String? = nil
        /// Original error message from the model.
        public internal(set) var originalMessage: Swift.String? = nil
        /// HTTP status code returned by model.
        public internal(set) var originalStatusCode: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        logStreamArn: Swift.String? = nil,
        message: Swift.String? = nil,
        originalMessage: Swift.String? = nil,
        originalStatusCode: Swift.Int? = nil
    ) {
        self.properties.errorCode = errorCode
        self.properties.logStreamArn = logStreamArn
        self.properties.message = message
        self.properties.originalMessage = originalMessage
        self.properties.originalStatusCode = originalStatusCode
    }
}

/// Model stream error that occurs during streaming.
public struct ModelStreamError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Error code.
        public internal(set) var errorCode: Swift.String? = nil
        /// Error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelStreamError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

/// The request has failed due to a temporary failure of the server.
public struct ServiceUnavailableError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Error code.
        public internal(set) var errorCode: Swift.String? = nil
        /// Error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

extension SageMakerRuntimeHTTP2ClientTypes {

    /// Request payload part structure.
    public struct RequestPayloadPart: Swift.Sendable {
        /// The payload bytes.
        public var bytes: Foundation.Data?
        /// Completion state header. Can be one of these possible values: "PARTIAL", "COMPLETE".
        public var completionState: Swift.String?
        /// Data type header. Can be one of these possible values: "UTF8", "BINARY".
        public var dataType: Swift.String?
        /// Padding string for alignment.
        public var p: Swift.String?

        public init(
            bytes: Foundation.Data? = nil,
            completionState: Swift.String? = nil,
            dataType: Swift.String? = nil,
            p: Swift.String? = nil
        ) {
            self.bytes = bytes
            self.completionState = completionState
            self.dataType = dataType
            self.p = p
        }
    }
}

extension SageMakerRuntimeHTTP2ClientTypes.RequestPayloadPart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestPayloadPart(completionState: \(Swift.String(describing: completionState)), dataType: \(Swift.String(describing: dataType)), p: \(Swift.String(describing: p)), bytes: \"CONTENT_REDACTED\")"}
}

extension SageMakerRuntimeHTTP2ClientTypes {

    /// Request stream event union.
    public enum RequestStreamEvent: Swift.Sendable {
        /// Payload part event.
        case payloadpart(SageMakerRuntimeHTTP2ClientTypes.RequestPayloadPart)
        case sdkUnknown(Swift.String)
    }
}

public struct InvokeEndpointWithBidirectionalStreamInput: Swift.Sendable {
    /// The request payload stream.
    /// This member is required.
    public var body: AsyncThrowingStream<SageMakerRuntimeHTTP2ClientTypes.RequestStreamEvent, Swift.Error>?
    /// The name of the endpoint to invoke.
    /// This member is required.
    public var endpointName: Swift.String?
    /// Model invocation path.
    public var modelInvocationPath: Swift.String?
    /// Model query string.
    public var modelQueryString: Swift.String?
    /// Target variant for the request.
    public var targetVariant: Swift.String?

    public init(
        body: AsyncThrowingStream<SageMakerRuntimeHTTP2ClientTypes.RequestStreamEvent, Swift.Error>? = nil,
        endpointName: Swift.String? = nil,
        modelInvocationPath: Swift.String? = nil,
        modelQueryString: Swift.String? = nil,
        targetVariant: Swift.String? = nil
    ) {
        self.body = body
        self.endpointName = endpointName
        self.modelInvocationPath = modelInvocationPath
        self.modelQueryString = modelQueryString
        self.targetVariant = targetVariant
    }
}

extension SageMakerRuntimeHTTP2ClientTypes {

    /// Response payload part structure.
    public struct ResponsePayloadPart: Swift.Sendable {
        /// The payload bytes.
        public var bytes: Foundation.Data?
        /// Completion state header. Can be one of these possible values: "PARTIAL", "COMPLETE".
        public var completionState: Swift.String?
        /// Data type header. Can be one of these possible values: "UTF8", "BINARY".
        public var dataType: Swift.String?
        /// Padding string for alignment.
        public var p: Swift.String?

        public init(
            bytes: Foundation.Data? = nil,
            completionState: Swift.String? = nil,
            dataType: Swift.String? = nil,
            p: Swift.String? = nil
        ) {
            self.bytes = bytes
            self.completionState = completionState
            self.dataType = dataType
            self.p = p
        }
    }
}

extension SageMakerRuntimeHTTP2ClientTypes.ResponsePayloadPart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResponsePayloadPart(completionState: \(Swift.String(describing: completionState)), dataType: \(Swift.String(describing: dataType)), p: \(Swift.String(describing: p)), bytes: \"CONTENT_REDACTED\")"}
}

extension SageMakerRuntimeHTTP2ClientTypes {

    /// Response stream event union.
    public enum ResponseStreamEvent: Swift.Sendable {
        /// Payload part event.
        case payloadpart(SageMakerRuntimeHTTP2ClientTypes.ResponsePayloadPart)
        case sdkUnknown(Swift.String)
    }
}

public struct InvokeEndpointWithBidirectionalStreamOutput: Swift.Sendable {
    /// The response payload stream.
    /// This member is required.
    public var body: AsyncThrowingStream<SageMakerRuntimeHTTP2ClientTypes.ResponseStreamEvent, Swift.Error>?
    /// The invoked production variant.
    public var invokedProductionVariant: Swift.String?

    public init(
        body: AsyncThrowingStream<SageMakerRuntimeHTTP2ClientTypes.ResponseStreamEvent, Swift.Error>? = nil,
        invokedProductionVariant: Swift.String? = nil
    ) {
        self.body = body
        self.invokedProductionVariant = invokedProductionVariant
    }
}

extension InvokeEndpointWithBidirectionalStreamInput {

    static func urlPathProvider(_ value: InvokeEndpointWithBidirectionalStreamInput) -> Swift.String? {
        guard let endpointName = value.endpointName else {
            return nil
        }
        return "/endpoints/\(endpointName.urlPercentEncoding())/invocations-bidirectional-stream"
    }
}

extension InvokeEndpointWithBidirectionalStreamInput {

    static func headerProvider(_ value: InvokeEndpointWithBidirectionalStreamInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let modelInvocationPath = value.modelInvocationPath {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-SageMaker-Model-Invocation-Path", value: Swift.String(modelInvocationPath)))
        }
        if let modelQueryString = value.modelQueryString {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-SageMaker-Model-Query-String", value: Swift.String(modelQueryString)))
        }
        if let targetVariant = value.targetVariant {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-SageMaker-Target-Variant", value: Swift.String(targetVariant)))
        }
        return items
    }
}

extension InvokeEndpointWithBidirectionalStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeEndpointWithBidirectionalStreamOutput {
        var value = InvokeEndpointWithBidirectionalStreamOutput()
        if let invokedProductionVariantHeaderValue = httpResponse.headers.value(for: "X-Amzn-Invoked-Production-Variant") {
            value.invokedProductionVariant = invokedProductionVariantHeaderValue
        }
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: SageMakerRuntimeHTTP2ClientTypes.ResponseStreamEvent.unmarshal)
            value.body = decoderStream.toAsyncStream()
        }
        return value
    }
}

enum InvokeEndpointWithBidirectionalStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InputValidationError": return try InputValidationError.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InternalStreamFailure": return try InternalStreamFailure.makeError(baseError: baseError)
            case "ModelError": return try ModelError.makeError(baseError: baseError)
            case "ModelStreamError": return try ModelStreamError.makeError(baseError: baseError)
            case "ServiceUnavailableError": return try ServiceUnavailableError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InputValidationError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InputValidationError {
        let reader = baseError.errorBodyReader
        var value = InputValidationError()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerError {
        let reader = baseError.errorBodyReader
        var value = InternalServerError()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalStreamFailure {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalStreamFailure {
        let reader = baseError.errorBodyReader
        var value = InternalStreamFailure()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ModelError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelError {
        let reader = baseError.errorBodyReader
        var value = ModelError()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.logStreamArn = try reader["LogStreamArn"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.originalMessage = try reader["OriginalMessage"].readIfPresent()
        value.properties.originalStatusCode = try reader["OriginalStatusCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ModelStreamError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelStreamError {
        let reader = baseError.errorBodyReader
        var value = ModelStreamError()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableError {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableError()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SageMakerRuntimeHTTP2ClientTypes.RequestStreamEvent {
    static var marshal: SmithyEventStreamsAPI.MarshalClosure<SageMakerRuntimeHTTP2ClientTypes.RequestStreamEvent> {
        { (self) in
            var headers: [SmithyEventStreamsAPI.Header] = [.init(name: ":message-type", value: .string("event"))]
            var payload: Foundation.Data? = nil
            switch self {
            case .payloadpart(let value):
                headers.append(.init(name: ":event-type", value: .string("PayloadPart")))
                if let headerValue = value.dataType {
                    headers.append(.init(name: "DataType", value: .string(headerValue)))
                }
                if let headerValue = value.completionState {
                    headers.append(.init(name: "CompletionState", value: .string(headerValue)))
                }
                if let headerValue = value.p {
                    headers.append(.init(name: "P", value: .string(headerValue)))
                }
                headers.append(.init(name: ":content-type", value: .string("application/octet-stream")))
                payload = value.bytes
            case .sdkUnknown(_):
                throw Smithy.ClientError.unknownError("cannot serialize the unknown event type!")
            }
            return SmithyEventStreamsAPI.Message(headers: headers, payload: payload ?? .init())
        }
    }
}

extension SageMakerRuntimeHTTP2ClientTypes.ResponseStreamEvent {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<SageMakerRuntimeHTTP2ClientTypes.ResponseStreamEvent> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "PayloadPart":
                    var event = SageMakerRuntimeHTTP2ClientTypes.ResponsePayloadPart()
                    if case .string(let value) = message.headers.value(name: "DataType") {
                        event.dataType = value
                    }
                    if case .string(let value) = message.headers.value(name: "CompletionState") {
                        event.completionState = value
                    }
                    if case .string(let value) = message.headers.value(name: "P") {
                        event.p = value
                    }
                    event.bytes = message.payload
                    return .payloadpart(event)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    case "ModelStreamError":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ModelStreamError.read(from:))
                        return value
                    case "InternalStreamFailure":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: InternalStreamFailure.read(from:))
                        return value
                    default:
                        let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension InternalStreamFailure {

    static func read(from reader: SmithyJSON.Reader) throws -> InternalStreamFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternalStreamFailure()
        value.properties.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension ModelStreamError {

    static func read(from reader: SmithyJSON.Reader) throws -> ModelStreamError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ModelStreamError()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        return value
    }
}

extension SageMakerRuntimeHTTP2ClientTypes.ResponsePayloadPart {

    static func read(from reader: SmithyJSON.Reader) throws -> SageMakerRuntimeHTTP2ClientTypes.ResponsePayloadPart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SageMakerRuntimeHTTP2ClientTypes.ResponsePayloadPart()
        value.bytes = try reader["Bytes"].readIfPresent()
        value.dataType = try reader["DataType"].readIfPresent()
        value.completionState = try reader["CompletionState"].readIfPresent()
        value.p = try reader["P"].readIfPresent()
        return value
    }
}

extension SageMakerRuntimeHTTP2ClientTypes.RequestPayloadPart {

    static func write(value: SageMakerRuntimeHTTP2ClientTypes.RequestPayloadPart?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bytes"].write(value.bytes)
        try writer["CompletionState"].write(value.completionState)
        try writer["DataType"].write(value.dataType)
        try writer["P"].write(value.p)
    }
}

public enum SageMakerRuntimeHTTP2ClientTypes {}
