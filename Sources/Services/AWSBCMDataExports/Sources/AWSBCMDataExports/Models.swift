//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// An error on the server occurred during the processing of your request. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You've reached the limit on the number of resources you can create, or exceeded the size of an individual resource.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code that was exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The identifier of the resource that exceeded quota.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that exceeded quota.
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code that exceeded quota. It will always be “AWSBillingAndCostManagementDataExports”.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code that exceeded the throttling limit.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The service code that exceeded the throttling limit. It will always be “AWSBillingAndCostManagementDataExports”.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.serviceCode = serviceCode
    }
}

extension BCMDataExportsClientTypes {

    /// The input failed to meet the constraints specified by the Amazon Web Services service in a specified field.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message with the reason for the validation exception error.
        /// This member is required.
        public var message: Swift.String?
        /// The field name where the invalid entry was detected.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension BCMDataExportsClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The list of fields that are invalid.
        public internal(set) var fields: [BCMDataExportsClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation exception.
        public internal(set) var reason: BCMDataExportsClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [BCMDataExportsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: BCMDataExportsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension BCMDataExportsClientTypes {

    /// The SQL query of column selections and row filters from the data table you want.
    public struct DataQuery: Swift.Sendable {
        /// The query statement.
        /// This member is required.
        public var queryStatement: Swift.String?
        /// The table configuration.
        public var tableConfigurations: [Swift.String: [Swift.String: Swift.String]]?

        public init(
            queryStatement: Swift.String? = nil,
            tableConfigurations: [Swift.String: [Swift.String: Swift.String]]? = nil
        )
        {
            self.queryStatement = queryStatement
            self.tableConfigurations = tableConfigurations
        }
    }
}

extension BCMDataExportsClientTypes {

    public enum CompressionOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gzip
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionOption] {
            return [
                .gzip,
                .parquet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDataExportsClientTypes {

    public enum FormatOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case parquet
        case textOrCsv
        case sdkUnknown(Swift.String)

        public static var allCases: [FormatOption] {
            return [
                .parquet,
                .textOrCsv
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .parquet: return "PARQUET"
            case .textOrCsv: return "TEXT_OR_CSV"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDataExportsClientTypes {

    public enum S3OutputType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [S3OutputType] {
            return [
                .custom
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDataExportsClientTypes {

    public enum OverwriteOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createNewReport
        case overwriteReport
        case sdkUnknown(Swift.String)

        public static var allCases: [OverwriteOption] {
            return [
                .createNewReport,
                .overwriteReport
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createNewReport: return "CREATE_NEW_REPORT"
            case .overwriteReport: return "OVERWRITE_REPORT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDataExportsClientTypes {

    /// The compression type, file format, and overwrite preference for the data export.
    public struct S3OutputConfigurations: Swift.Sendable {
        /// The compression type for the data export.
        /// This member is required.
        public var compression: BCMDataExportsClientTypes.CompressionOption?
        /// The file format for the data export.
        /// This member is required.
        public var format: BCMDataExportsClientTypes.FormatOption?
        /// The output type for the data export.
        /// This member is required.
        public var outputType: BCMDataExportsClientTypes.S3OutputType?
        /// The rule to follow when generating a version of the data export file. You have the choice to overwrite the previous version or to be delivered in addition to the previous versions. Overwriting exports can save on Amazon S3 storage costs. Creating new export versions allows you to track the changes in cost and usage data over time.
        /// This member is required.
        public var overwrite: BCMDataExportsClientTypes.OverwriteOption?

        public init(
            compression: BCMDataExportsClientTypes.CompressionOption? = nil,
            format: BCMDataExportsClientTypes.FormatOption? = nil,
            outputType: BCMDataExportsClientTypes.S3OutputType? = nil,
            overwrite: BCMDataExportsClientTypes.OverwriteOption? = nil
        )
        {
            self.compression = compression
            self.format = format
            self.outputType = outputType
            self.overwrite = overwrite
        }
    }
}

extension BCMDataExportsClientTypes {

    /// Describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and object keys of a data exports file.
    public struct S3Destination: Swift.Sendable {
        /// The name of the Amazon S3 bucket used as the destination of a data export file.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The output configuration for the data export.
        /// This member is required.
        public var s3OutputConfigurations: BCMDataExportsClientTypes.S3OutputConfigurations?
        /// The S3 path prefix you want prepended to the name of your data export.
        /// This member is required.
        public var s3Prefix: Swift.String?
        /// The S3 bucket Region.
        /// This member is required.
        public var s3Region: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3OutputConfigurations: BCMDataExportsClientTypes.S3OutputConfigurations? = nil,
            s3Prefix: Swift.String? = nil,
            s3Region: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3OutputConfigurations = s3OutputConfigurations
            self.s3Prefix = s3Prefix
            self.s3Region = s3Region
        }
    }
}

extension BCMDataExportsClientTypes {

    /// The destinations used for data exports.
    public struct DestinationConfigurations: Swift.Sendable {
        /// An object that describes the destination of the data exports file.
        /// This member is required.
        public var s3Destination: BCMDataExportsClientTypes.S3Destination?

        public init(
            s3Destination: BCMDataExportsClientTypes.S3Destination? = nil
        )
        {
            self.s3Destination = s3Destination
        }
    }
}

extension BCMDataExportsClientTypes {

    public enum FrequencyOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case synchronous
        case sdkUnknown(Swift.String)

        public static var allCases: [FrequencyOption] {
            return [
                .synchronous
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .synchronous: return "SYNCHRONOUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDataExportsClientTypes {

    /// The cadence for Amazon Web Services to update the data export in your S3 bucket.
    public struct RefreshCadence: Swift.Sendable {
        /// The frequency that data exports are updated. The export refreshes each time the source data updates, up to three times daily.
        /// This member is required.
        public var frequency: BCMDataExportsClientTypes.FrequencyOption?

        public init(
            frequency: BCMDataExportsClientTypes.FrequencyOption? = nil
        )
        {
            self.frequency = frequency
        }
    }
}

extension BCMDataExportsClientTypes {

    /// The details that are available for an export.
    public struct Export: Swift.Sendable {
        /// The data query for this specific data export.
        /// This member is required.
        public var dataQuery: BCMDataExportsClientTypes.DataQuery?
        /// The description for this specific data export.
        public var description: Swift.String?
        /// The destination configuration for this specific data export.
        /// This member is required.
        public var destinationConfigurations: BCMDataExportsClientTypes.DestinationConfigurations?
        /// The Amazon Resource Name (ARN) for this export.
        public var exportArn: Swift.String?
        /// The name of this specific data export.
        /// This member is required.
        public var name: Swift.String?
        /// The cadence for Amazon Web Services to update the export in your S3 bucket.
        /// This member is required.
        public var refreshCadence: BCMDataExportsClientTypes.RefreshCadence?

        public init(
            dataQuery: BCMDataExportsClientTypes.DataQuery? = nil,
            description: Swift.String? = nil,
            destinationConfigurations: BCMDataExportsClientTypes.DestinationConfigurations? = nil,
            exportArn: Swift.String? = nil,
            name: Swift.String? = nil,
            refreshCadence: BCMDataExportsClientTypes.RefreshCadence? = nil
        )
        {
            self.dataQuery = dataQuery
            self.description = description
            self.destinationConfigurations = destinationConfigurations
            self.exportArn = exportArn
            self.name = name
            self.refreshCadence = refreshCadence
        }
    }
}

extension BCMDataExportsClientTypes {

    /// The tag structure that contains a tag key and value.
    public struct ResourceTag: Swift.Sendable {
        /// The key that's associated with the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value that's associated with the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateExportInput: Swift.Sendable {
    /// The details of the export, including data query, name, description, and destination configuration.
    /// This member is required.
    public var export: BCMDataExportsClientTypes.Export?
    /// An optional list of tags to associate with the specified export. Each tag consists of a key and a value, and each key must be unique for the resource.
    public var resourceTags: [BCMDataExportsClientTypes.ResourceTag]?

    public init(
        export: BCMDataExportsClientTypes.Export? = nil,
        resourceTags: [BCMDataExportsClientTypes.ResourceTag]? = nil
    )
    {
        self.export = export
        self.resourceTags = resourceTags
    }
}

public struct CreateExportOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for this export.
    public var exportArn: Swift.String?

    public init(
        exportArn: Swift.String? = nil
    )
    {
        self.exportArn = exportArn
    }
}

/// The specified Amazon Resource Name (ARN) in the request doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that was not found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that was not found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

public struct DeleteExportInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for this export.
    /// This member is required.
    public var exportArn: Swift.String?

    public init(
        exportArn: Swift.String? = nil
    )
    {
        self.exportArn = exportArn
    }
}

public struct DeleteExportOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for this export.
    public var exportArn: Swift.String?

    public init(
        exportArn: Swift.String? = nil
    )
    {
        self.exportArn = exportArn
    }
}

public struct GetExecutionInput: Swift.Sendable {
    /// The ID for this specific execution.
    /// This member is required.
    public var executionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Export object that generated this specific execution.
    /// This member is required.
    public var exportArn: Swift.String?

    public init(
        executionId: Swift.String? = nil,
        exportArn: Swift.String? = nil
    )
    {
        self.executionId = executionId
        self.exportArn = exportArn
    }
}

extension BCMDataExportsClientTypes {

    public enum ExecutionStatusCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deliveryFailure
        case deliveryInProcess
        case deliverySuccess
        case initiationInProcess
        case queryFailure
        case queryInProcess
        case queryQueued
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatusCode] {
            return [
                .deliveryFailure,
                .deliveryInProcess,
                .deliverySuccess,
                .initiationInProcess,
                .queryFailure,
                .queryInProcess,
                .queryQueued
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deliveryFailure: return "DELIVERY_FAILURE"
            case .deliveryInProcess: return "DELIVERY_IN_PROCESS"
            case .deliverySuccess: return "DELIVERY_SUCCESS"
            case .initiationInProcess: return "INITIATION_IN_PROCESS"
            case .queryFailure: return "QUERY_FAILURE"
            case .queryInProcess: return "QUERY_IN_PROCESS"
            case .queryQueued: return "QUERY_QUEUED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDataExportsClientTypes {

    public enum ExecutionStatusReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case billOwnerChanged
        case insufficientPermission
        case internalFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatusReason] {
            return [
                .billOwnerChanged,
                .insufficientPermission,
                .internalFailure
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .billOwnerChanged: return "BILL_OWNER_CHANGED"
            case .insufficientPermission: return "INSUFFICIENT_PERMISSION"
            case .internalFailure: return "INTERNAL_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDataExportsClientTypes {

    /// The status of the execution.
    public struct ExecutionStatus: Swift.Sendable {
        /// The time when the execution was completed.
        public var completedAt: Foundation.Date?
        /// The time when the execution was created.
        public var createdAt: Foundation.Date?
        /// The time when the execution was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The code for the status of the execution.
        public var statusCode: BCMDataExportsClientTypes.ExecutionStatusCode?
        /// The reason for the failed status.
        public var statusReason: BCMDataExportsClientTypes.ExecutionStatusReason?

        public init(
            completedAt: Foundation.Date? = nil,
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            statusCode: BCMDataExportsClientTypes.ExecutionStatusCode? = nil,
            statusReason: BCMDataExportsClientTypes.ExecutionStatusReason? = nil
        )
        {
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.statusCode = statusCode
            self.statusReason = statusReason
        }
    }
}

public struct GetExecutionOutput: Swift.Sendable {
    /// The ID for this specific execution.
    public var executionId: Swift.String?
    /// The status of this specific execution.
    public var executionStatus: BCMDataExportsClientTypes.ExecutionStatus?
    /// The export data for this specific execution. This export data is a snapshot from when the execution was generated. The data could be different from the current export data if the export was updated since the execution was generated.
    public var export: BCMDataExportsClientTypes.Export?

    public init(
        executionId: Swift.String? = nil,
        executionStatus: BCMDataExportsClientTypes.ExecutionStatus? = nil,
        export: BCMDataExportsClientTypes.Export? = nil
    )
    {
        self.executionId = executionId
        self.executionStatus = executionStatus
        self.export = export
    }
}

public struct GetExportInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for this export.
    /// This member is required.
    public var exportArn: Swift.String?

    public init(
        exportArn: Swift.String? = nil
    )
    {
        self.exportArn = exportArn
    }
}

extension BCMDataExportsClientTypes {

    public enum ExportStatusCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportStatusCode] {
            return [
                .healthy,
                .unhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDataExportsClientTypes {

    /// The status of the data export.
    public struct ExportStatus: Swift.Sendable {
        /// The timestamp of when the export was created.
        public var createdAt: Foundation.Date?
        /// The timestamp of when the export was last generated.
        public var lastRefreshedAt: Foundation.Date?
        /// The timestamp of when the export was updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The status code for the request.
        public var statusCode: BCMDataExportsClientTypes.ExportStatusCode?
        /// The description for the status code.
        public var statusReason: BCMDataExportsClientTypes.ExecutionStatusReason?

        public init(
            createdAt: Foundation.Date? = nil,
            lastRefreshedAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            statusCode: BCMDataExportsClientTypes.ExportStatusCode? = nil,
            statusReason: BCMDataExportsClientTypes.ExecutionStatusReason? = nil
        )
        {
            self.createdAt = createdAt
            self.lastRefreshedAt = lastRefreshedAt
            self.lastUpdatedAt = lastUpdatedAt
            self.statusCode = statusCode
            self.statusReason = statusReason
        }
    }
}

public struct GetExportOutput: Swift.Sendable {
    /// The data for this specific export.
    public var export: BCMDataExportsClientTypes.Export?
    /// The status of this specific export.
    public var exportStatus: BCMDataExportsClientTypes.ExportStatus?

    public init(
        export: BCMDataExportsClientTypes.Export? = nil,
        exportStatus: BCMDataExportsClientTypes.ExportStatus? = nil
    )
    {
        self.export = export
        self.exportStatus = exportStatus
    }
}

public struct GetTableInput: Swift.Sendable {
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?
    /// TableProperties are additional configurations you can provide to change the data and schema of a table. Each table can have different TableProperties. Tables are not required to have any TableProperties. Each table property has a default value that it assumes if not specified.
    public var tableProperties: [Swift.String: Swift.String]?

    public init(
        tableName: Swift.String? = nil,
        tableProperties: [Swift.String: Swift.String]? = nil
    )
    {
        self.tableName = tableName
        self.tableProperties = tableProperties
    }
}

extension BCMDataExportsClientTypes {

    /// Includes basic information for a data column such as its description, name, and type.
    public struct Column: Swift.Sendable {
        /// The description for a column.
        public var description: Swift.String?
        /// The column name.
        public var name: Swift.String?
        /// The kind of data a column stores.
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.type = type
        }
    }
}

public struct GetTableOutput: Swift.Sendable {
    /// The table description.
    public var description: Swift.String?
    /// The schema of the table.
    public var schema: [BCMDataExportsClientTypes.Column]?
    /// The name of the table.
    public var tableName: Swift.String?
    /// TableProperties are additional configurations you can provide to change the data and schema of a table. Each table can have different TableProperties. Tables are not required to have any TableProperties. Each table property has a default value that it assumes if not specified.
    public var tableProperties: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        schema: [BCMDataExportsClientTypes.Column]? = nil,
        tableName: Swift.String? = nil,
        tableProperties: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.schema = schema
        self.tableName = tableName
        self.tableProperties = tableProperties
    }
}

public struct ListExecutionsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for this export.
    /// This member is required.
    public var exportArn: Swift.String?
    /// The maximum number of objects that are returned for the request.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        exportArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportArn = exportArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BCMDataExportsClientTypes {

    /// The reference for the data export update.
    public struct ExecutionReference: Swift.Sendable {
        /// The ID for this specific execution.
        /// This member is required.
        public var executionId: Swift.String?
        /// The status of this specific execution.
        /// This member is required.
        public var executionStatus: BCMDataExportsClientTypes.ExecutionStatus?

        public init(
            executionId: Swift.String? = nil,
            executionStatus: BCMDataExportsClientTypes.ExecutionStatus? = nil
        )
        {
            self.executionId = executionId
            self.executionStatus = executionStatus
        }
    }
}

public struct ListExecutionsOutput: Swift.Sendable {
    /// The list of executions.
    public var executions: [BCMDataExportsClientTypes.ExecutionReference]?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        executions: [BCMDataExportsClientTypes.ExecutionReference]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.executions = executions
        self.nextToken = nextToken
    }
}

public struct ListExportsInput: Swift.Sendable {
    /// The maximum number of objects that are returned for the request.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BCMDataExportsClientTypes {

    /// The reference details for a given export.
    public struct ExportReference: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for this export.
        /// This member is required.
        public var exportArn: Swift.String?
        /// The name of this specific data export.
        /// This member is required.
        public var exportName: Swift.String?
        /// The status of this specific data export.
        /// This member is required.
        public var exportStatus: BCMDataExportsClientTypes.ExportStatus?

        public init(
            exportArn: Swift.String? = nil,
            exportName: Swift.String? = nil,
            exportStatus: BCMDataExportsClientTypes.ExportStatus? = nil
        )
        {
            self.exportArn = exportArn
            self.exportName = exportName
            self.exportStatus = exportStatus
        }
    }
}

public struct ListExportsOutput: Swift.Sendable {
    /// The details of the exports, including name and export status.
    public var exports: [BCMDataExportsClientTypes.ExportReference]?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        exports: [BCMDataExportsClientTypes.ExportReference]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exports = exports
        self.nextToken = nextToken
    }
}

public struct ListTablesInput: Swift.Sendable {
    /// The maximum number of objects that are returned for the request.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BCMDataExportsClientTypes {

    /// The properties for the data export table.
    public struct TablePropertyDescription: Swift.Sendable {
        /// The default value for the table.
        public var defaultValue: Swift.String?
        /// The description for the table.
        public var description: Swift.String?
        /// The name of the table.
        public var name: Swift.String?
        /// The valid values for the table.
        public var validValues: [Swift.String]?

        public init(
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            validValues: [Swift.String]? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.validValues = validValues
        }
    }
}

extension BCMDataExportsClientTypes {

    /// The details for the data export table.
    public struct Table: Swift.Sendable {
        /// The description for the table.
        public var description: Swift.String?
        /// The name of the table.
        public var tableName: Swift.String?
        /// The properties for the table.
        public var tableProperties: [BCMDataExportsClientTypes.TablePropertyDescription]?

        public init(
            description: Swift.String? = nil,
            tableName: Swift.String? = nil,
            tableProperties: [BCMDataExportsClientTypes.TablePropertyDescription]? = nil
        )
        {
            self.description = description
            self.tableName = tableName
            self.tableProperties = tableProperties
        }
    }
}

public struct ListTablesOutput: Swift.Sendable {
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of tables.
    public var tables: [BCMDataExportsClientTypes.Table]?

    public init(
        nextToken: Swift.String? = nil,
        tables: [BCMDataExportsClientTypes.Table]? = nil
    )
    {
        self.nextToken = nextToken
        self.tables = tables
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The maximum number of objects that are returned for the request.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The unique identifier for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional list of tags to associate with the specified export. Each tag consists of a key and a value, and each key must be unique for the resource.
    public var resourceTags: [BCMDataExportsClientTypes.ResourceTag]?

    public init(
        nextToken: Swift.String? = nil,
        resourceTags: [BCMDataExportsClientTypes.ResourceTag]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceTags = resourceTags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The unique identifier for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to associate with the resource. Each tag consists of a key and a value, and each key must be unique for the resource.
    /// This member is required.
    public var resourceTags: [BCMDataExportsClientTypes.ResourceTag]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTags: [BCMDataExportsClientTypes.ResourceTag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceTags = resourceTags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The unique identifier for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys that are associated with the resource ARN.
    /// This member is required.
    public var resourceTagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceTagKeys = resourceTagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateExportInput: Swift.Sendable {
    /// The name and query details for the export.
    /// This member is required.
    public var export: BCMDataExportsClientTypes.Export?
    /// The Amazon Resource Name (ARN) for this export.
    /// This member is required.
    public var exportArn: Swift.String?

    public init(
        export: BCMDataExportsClientTypes.Export? = nil,
        exportArn: Swift.String? = nil
    )
    {
        self.export = export
        self.exportArn = exportArn
    }
}

public struct UpdateExportOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for this export.
    public var exportArn: Swift.String?

    public init(
        exportArn: Swift.String? = nil
    )
    {
        self.exportArn = exportArn
    }
}

extension CreateExportInput {

    static func urlPathProvider(_ value: CreateExportInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteExportInput {

    static func urlPathProvider(_ value: DeleteExportInput) -> Swift.String? {
        return "/"
    }
}

extension GetExecutionInput {

    static func urlPathProvider(_ value: GetExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension GetExportInput {

    static func urlPathProvider(_ value: GetExportInput) -> Swift.String? {
        return "/"
    }
}

extension GetTableInput {

    static func urlPathProvider(_ value: GetTableInput) -> Swift.String? {
        return "/"
    }
}

extension ListExecutionsInput {

    static func urlPathProvider(_ value: ListExecutionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListExportsInput {

    static func urlPathProvider(_ value: ListExportsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTablesInput {

    static func urlPathProvider(_ value: ListTablesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateExportInput {

    static func urlPathProvider(_ value: UpdateExportInput) -> Swift.String? {
        return "/"
    }
}

extension CreateExportInput {

    static func write(value: CreateExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Export"].write(value.export, with: BCMDataExportsClientTypes.Export.write(value:to:))
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: BCMDataExportsClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteExportInput {

    static func write(value: DeleteExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExportArn"].write(value.exportArn)
    }
}

extension GetExecutionInput {

    static func write(value: GetExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExecutionId"].write(value.executionId)
        try writer["ExportArn"].write(value.exportArn)
    }
}

extension GetExportInput {

    static func write(value: GetExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExportArn"].write(value.exportArn)
    }
}

extension GetTableInput {

    static func write(value: GetTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TableName"].write(value.tableName)
        try writer["TableProperties"].writeMap(value.tableProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListExecutionsInput {

    static func write(value: ListExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExportArn"].write(value.exportArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListExportsInput {

    static func write(value: ListExportsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTablesInput {

    static func write(value: ListTablesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: BCMDataExportsClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["ResourceTagKeys"].writeList(value.resourceTagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateExportInput {

    static func write(value: UpdateExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Export"].write(value.export, with: BCMDataExportsClientTypes.Export.write(value:to:))
        try writer["ExportArn"].write(value.exportArn)
    }
}

extension CreateExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateExportOutput()
        value.exportArn = try reader["ExportArn"].readIfPresent()
        return value
    }
}

extension DeleteExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteExportOutput()
        value.exportArn = try reader["ExportArn"].readIfPresent()
        return value
    }
}

extension GetExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExecutionOutput()
        value.executionId = try reader["ExecutionId"].readIfPresent()
        value.executionStatus = try reader["ExecutionStatus"].readIfPresent(with: BCMDataExportsClientTypes.ExecutionStatus.read(from:))
        value.export = try reader["Export"].readIfPresent(with: BCMDataExportsClientTypes.Export.read(from:))
        return value
    }
}

extension GetExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExportOutput()
        value.export = try reader["Export"].readIfPresent(with: BCMDataExportsClientTypes.Export.read(from:))
        value.exportStatus = try reader["ExportStatus"].readIfPresent(with: BCMDataExportsClientTypes.ExportStatus.read(from:))
        return value
    }
}

extension GetTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableOutput()
        value.description = try reader["Description"].readIfPresent()
        value.schema = try reader["Schema"].readListIfPresent(memberReadingClosure: BCMDataExportsClientTypes.Column.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tableName = try reader["TableName"].readIfPresent()
        value.tableProperties = try reader["TableProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExecutionsOutput()
        value.executions = try reader["Executions"].readListIfPresent(memberReadingClosure: BCMDataExportsClientTypes.ExecutionReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListExportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExportsOutput()
        value.exports = try reader["Exports"].readListIfPresent(memberReadingClosure: BCMDataExportsClientTypes.ExportReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTablesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tables = try reader["Tables"].readListIfPresent(memberReadingClosure: BCMDataExportsClientTypes.Table.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: BCMDataExportsClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateExportOutput()
        value.exportArn = try reader["ExportArn"].readIfPresent()
        return value
    }
}

enum CreateExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: BCMDataExportsClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BCMDataExportsClientTypes.Export {

    static func write(value: BCMDataExportsClientTypes.Export?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataQuery"].write(value.dataQuery, with: BCMDataExportsClientTypes.DataQuery.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["DestinationConfigurations"].write(value.destinationConfigurations, with: BCMDataExportsClientTypes.DestinationConfigurations.write(value:to:))
        try writer["ExportArn"].write(value.exportArn)
        try writer["Name"].write(value.name)
        try writer["RefreshCadence"].write(value.refreshCadence, with: BCMDataExportsClientTypes.RefreshCadence.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.Export {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.Export()
        value.exportArn = try reader["ExportArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.dataQuery = try reader["DataQuery"].readIfPresent(with: BCMDataExportsClientTypes.DataQuery.read(from:))
        value.destinationConfigurations = try reader["DestinationConfigurations"].readIfPresent(with: BCMDataExportsClientTypes.DestinationConfigurations.read(from:))
        value.refreshCadence = try reader["RefreshCadence"].readIfPresent(with: BCMDataExportsClientTypes.RefreshCadence.read(from:))
        return value
    }
}

extension BCMDataExportsClientTypes.RefreshCadence {

    static func write(value: BCMDataExportsClientTypes.RefreshCadence?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Frequency"].write(value.frequency)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.RefreshCadence {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.RefreshCadence()
        value.frequency = try reader["Frequency"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BCMDataExportsClientTypes.DestinationConfigurations {

    static func write(value: BCMDataExportsClientTypes.DestinationConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Destination"].write(value.s3Destination, with: BCMDataExportsClientTypes.S3Destination.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.DestinationConfigurations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.DestinationConfigurations()
        value.s3Destination = try reader["S3Destination"].readIfPresent(with: BCMDataExportsClientTypes.S3Destination.read(from:))
        return value
    }
}

extension BCMDataExportsClientTypes.S3Destination {

    static func write(value: BCMDataExportsClientTypes.S3Destination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Bucket"].write(value.s3Bucket)
        try writer["S3OutputConfigurations"].write(value.s3OutputConfigurations, with: BCMDataExportsClientTypes.S3OutputConfigurations.write(value:to:))
        try writer["S3Prefix"].write(value.s3Prefix)
        try writer["S3Region"].write(value.s3Region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.S3Destination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.S3Destination()
        value.s3Bucket = try reader["S3Bucket"].readIfPresent() ?? ""
        value.s3Prefix = try reader["S3Prefix"].readIfPresent() ?? ""
        value.s3Region = try reader["S3Region"].readIfPresent() ?? ""
        value.s3OutputConfigurations = try reader["S3OutputConfigurations"].readIfPresent(with: BCMDataExportsClientTypes.S3OutputConfigurations.read(from:))
        return value
    }
}

extension BCMDataExportsClientTypes.S3OutputConfigurations {

    static func write(value: BCMDataExportsClientTypes.S3OutputConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Compression"].write(value.compression)
        try writer["Format"].write(value.format)
        try writer["OutputType"].write(value.outputType)
        try writer["Overwrite"].write(value.overwrite)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.S3OutputConfigurations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.S3OutputConfigurations()
        value.outputType = try reader["OutputType"].readIfPresent() ?? .sdkUnknown("")
        value.format = try reader["Format"].readIfPresent() ?? .sdkUnknown("")
        value.compression = try reader["Compression"].readIfPresent() ?? .sdkUnknown("")
        value.overwrite = try reader["Overwrite"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BCMDataExportsClientTypes.DataQuery {

    static func write(value: BCMDataExportsClientTypes.DataQuery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryStatement"].write(value.queryStatement)
        try writer["TableConfigurations"].writeMap(value.tableConfigurations, valueWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.DataQuery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.DataQuery()
        value.queryStatement = try reader["QueryStatement"].readIfPresent() ?? ""
        value.tableConfigurations = try reader["TableConfigurations"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BCMDataExportsClientTypes.ExecutionStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.ExecutionStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.ExecutionStatus()
        value.statusCode = try reader["StatusCode"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.completedAt = try reader["CompletedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BCMDataExportsClientTypes.ExportStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.ExportStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.ExportStatus()
        value.statusCode = try reader["StatusCode"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastRefreshedAt = try reader["LastRefreshedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BCMDataExportsClientTypes.Column {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.Column {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.Column()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension BCMDataExportsClientTypes.ExecutionReference {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.ExecutionReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.ExecutionReference()
        value.executionId = try reader["ExecutionId"].readIfPresent() ?? ""
        value.executionStatus = try reader["ExecutionStatus"].readIfPresent(with: BCMDataExportsClientTypes.ExecutionStatus.read(from:))
        return value
    }
}

extension BCMDataExportsClientTypes.ExportReference {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.ExportReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.ExportReference()
        value.exportArn = try reader["ExportArn"].readIfPresent() ?? ""
        value.exportName = try reader["ExportName"].readIfPresent() ?? ""
        value.exportStatus = try reader["ExportStatus"].readIfPresent(with: BCMDataExportsClientTypes.ExportStatus.read(from:))
        return value
    }
}

extension BCMDataExportsClientTypes.Table {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.Table {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.Table()
        value.tableName = try reader["TableName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.tableProperties = try reader["TableProperties"].readListIfPresent(memberReadingClosure: BCMDataExportsClientTypes.TablePropertyDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BCMDataExportsClientTypes.TablePropertyDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.TablePropertyDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.TablePropertyDescription()
        value.name = try reader["Name"].readIfPresent()
        value.validValues = try reader["ValidValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension BCMDataExportsClientTypes.ResourceTag {

    static func write(value: BCMDataExportsClientTypes.ResourceTag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.ResourceTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.ResourceTag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension BCMDataExportsClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDataExportsClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDataExportsClientTypes.ValidationExceptionField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

public enum BCMDataExportsClientTypes {}
