// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BCMDataExportsClientTypes.Column: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension BCMDataExportsClientTypes {
    /// Includes basic information for a data column such as its description, name, and type.
    public struct Column: Swift.Equatable {
        /// The description for a column.
        public var description: Swift.String?
        /// The column name.
        public var name: Swift.String?
        /// The kind of data a column stores.
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.type = type
        }
    }

}

extension BCMDataExportsClientTypes {
    public enum CompressionOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gzip
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionOption] {
            return [
                .gzip,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CompressionOption(rawValue: rawValue) ?? CompressionOption.sdkUnknown(rawValue)
        }
    }
}

extension CreateExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case export = "Export"
        case resourceTags = "ResourceTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let export = self.export {
            try encodeContainer.encode(export, forKey: .export)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetag0 in resourceTags {
                try resourceTagsContainer.encode(resourcetag0)
            }
        }
    }
}

extension CreateExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateExportInput: Swift.Equatable {
    /// The details of the export, including data query, name, description, and destination configuration.
    /// This member is required.
    public var export: BCMDataExportsClientTypes.Export?
    /// An optional list of tags to associate with the specified export. Each tag consists of a key and a value, and each key must be unique for the resource.
    public var resourceTags: [BCMDataExportsClientTypes.ResourceTag]?

    public init(
        export: BCMDataExportsClientTypes.Export? = nil,
        resourceTags: [BCMDataExportsClientTypes.ResourceTag]? = nil
    )
    {
        self.export = export
        self.resourceTags = resourceTags
    }
}

struct CreateExportInputBody: Swift.Equatable {
    let export: BCMDataExportsClientTypes.Export?
    let resourceTags: [BCMDataExportsClientTypes.ResourceTag]?
}

extension CreateExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case export = "Export"
        case resourceTags = "ResourceTags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.Export.self, forKey: .export)
        export = exportDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([BCMDataExportsClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[BCMDataExportsClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [BCMDataExportsClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

extension CreateExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.exportArn = output.exportArn
        } else {
            self.exportArn = nil
        }
    }
}

public struct CreateExportOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for this export.
    public var exportArn: Swift.String?

    public init(
        exportArn: Swift.String? = nil
    )
    {
        self.exportArn = exportArn
    }
}

struct CreateExportOutputBody: Swift.Equatable {
    let exportArn: Swift.String?
}

extension CreateExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportArn = "ExportArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportArn)
        exportArn = exportArnDecoded
    }
}

enum CreateExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BCMDataExportsClientTypes.DataQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryStatement = "QueryStatement"
        case tableConfigurations = "TableConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryStatement = self.queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let tableConfigurations = tableConfigurations {
            var tableConfigurationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tableConfigurations)
            for (dictKey0, tableConfigurations0) in tableConfigurations {
                var tableConfigurations0Container = tableConfigurationsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, tableProperties1) in tableConfigurations0 {
                    try tableConfigurations0Container.encode(tableProperties1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let tableConfigurationsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .tableConfigurations)
        var tableConfigurationsDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let tableConfigurationsContainer = tableConfigurationsContainer {
            tableConfigurationsDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, tableproperties0) in tableConfigurationsContainer {
                var tableproperties0Decoded0: [Swift.String: Swift.String]? = nil
                if let tableproperties0 = tableproperties0 {
                    tableproperties0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, genericstring1) in tableproperties0 {
                        if let genericstring1 = genericstring1 {
                            tableproperties0Decoded0?[key1] = genericstring1
                        }
                    }
                }
                tableConfigurationsDecoded0?[key0] = tableproperties0Decoded0
            }
        }
        tableConfigurations = tableConfigurationsDecoded0
    }
}

extension BCMDataExportsClientTypes {
    /// The SQL query of column selections and row filters from the data table you want.
    public struct DataQuery: Swift.Equatable {
        /// The query statement.
        /// This member is required.
        public var queryStatement: Swift.String?
        /// The table configuration.
        public var tableConfigurations: [Swift.String:[Swift.String:Swift.String]]?

        public init(
            queryStatement: Swift.String? = nil,
            tableConfigurations: [Swift.String:[Swift.String:Swift.String]]? = nil
        )
        {
            self.queryStatement = queryStatement
            self.tableConfigurations = tableConfigurations
        }
    }

}

extension DeleteExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportArn = "ExportArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportArn = self.exportArn {
            try encodeContainer.encode(exportArn, forKey: .exportArn)
        }
    }
}

extension DeleteExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteExportInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for this export.
    /// This member is required.
    public var exportArn: Swift.String?

    public init(
        exportArn: Swift.String? = nil
    )
    {
        self.exportArn = exportArn
    }
}

struct DeleteExportInputBody: Swift.Equatable {
    let exportArn: Swift.String?
}

extension DeleteExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportArn = "ExportArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportArn)
        exportArn = exportArnDecoded
    }
}

extension DeleteExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.exportArn = output.exportArn
        } else {
            self.exportArn = nil
        }
    }
}

public struct DeleteExportOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for this export.
    public var exportArn: Swift.String?

    public init(
        exportArn: Swift.String? = nil
    )
    {
        self.exportArn = exportArn
    }
}

struct DeleteExportOutputBody: Swift.Equatable {
    let exportArn: Swift.String?
}

extension DeleteExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportArn = "ExportArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportArn)
        exportArn = exportArnDecoded
    }
}

enum DeleteExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BCMDataExportsClientTypes.DestinationConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Destination = "S3Destination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Destination = self.s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DestinationDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

extension BCMDataExportsClientTypes {
    /// The destinations used for data exports.
    public struct DestinationConfigurations: Swift.Equatable {
        /// An object that describes the destination of the data exports file.
        /// This member is required.
        public var s3Destination: BCMDataExportsClientTypes.S3Destination?

        public init(
            s3Destination: BCMDataExportsClientTypes.S3Destination? = nil
        )
        {
            self.s3Destination = s3Destination
        }
    }

}

extension BCMDataExportsClientTypes.ExecutionReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case executionStatus = "ExecutionStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let executionStatus = self.executionStatus {
            try encodeContainer.encode(executionStatus, forKey: .executionStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let executionStatusDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.ExecutionStatus.self, forKey: .executionStatus)
        executionStatus = executionStatusDecoded
    }
}

extension BCMDataExportsClientTypes {
    /// The reference for the data export update.
    public struct ExecutionReference: Swift.Equatable {
        /// The ID for this specific execution.
        /// This member is required.
        public var executionId: Swift.String?
        /// The status of this specific execution.
        /// This member is required.
        public var executionStatus: BCMDataExportsClientTypes.ExecutionStatus?

        public init(
            executionId: Swift.String? = nil,
            executionStatus: BCMDataExportsClientTypes.ExecutionStatus? = nil
        )
        {
            self.executionId = executionId
            self.executionStatus = executionStatus
        }
    }

}

extension BCMDataExportsClientTypes.ExecutionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completedAt = "CompletedAt"
        case createdAt = "CreatedAt"
        case lastUpdatedAt = "LastUpdatedAt"
        case statusCode = "StatusCode"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedAt = self.completedAt {
            try encodeContainer.encodeTimestamp(completedAt, format: .dateTime, forKey: .completedAt)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason.rawValue, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.ExecutionStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.ExecutionStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let completedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completedAt)
        completedAt = completedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension BCMDataExportsClientTypes {
    /// The status of the execution.
    public struct ExecutionStatus: Swift.Equatable {
        /// The time when the execution was completed.
        public var completedAt: ClientRuntime.Date?
        /// The time when the execution was created.
        public var createdAt: ClientRuntime.Date?
        /// The time when the execution was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The code for the status of the execution.
        public var statusCode: BCMDataExportsClientTypes.ExecutionStatusCode?
        /// The reason for the failed status.
        public var statusReason: BCMDataExportsClientTypes.ExecutionStatusReason?

        public init(
            completedAt: ClientRuntime.Date? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            statusCode: BCMDataExportsClientTypes.ExecutionStatusCode? = nil,
            statusReason: BCMDataExportsClientTypes.ExecutionStatusReason? = nil
        )
        {
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.statusCode = statusCode
            self.statusReason = statusReason
        }
    }

}

extension BCMDataExportsClientTypes {
    public enum ExecutionStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deliveryFailure
        case deliveryInProcess
        case deliverySuccess
        case initiationInProcess
        case queryFailure
        case queryInProcess
        case queryQueued
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatusCode] {
            return [
                .deliveryFailure,
                .deliveryInProcess,
                .deliverySuccess,
                .initiationInProcess,
                .queryFailure,
                .queryInProcess,
                .queryQueued,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deliveryFailure: return "DELIVERY_FAILURE"
            case .deliveryInProcess: return "DELIVERY_IN_PROCESS"
            case .deliverySuccess: return "DELIVERY_SUCCESS"
            case .initiationInProcess: return "INITIATION_IN_PROCESS"
            case .queryFailure: return "QUERY_FAILURE"
            case .queryInProcess: return "QUERY_IN_PROCESS"
            case .queryQueued: return "QUERY_QUEUED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionStatusCode(rawValue: rawValue) ?? ExecutionStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension BCMDataExportsClientTypes {
    public enum ExecutionStatusReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case billOwnerChanged
        case insufficientPermission
        case internalFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatusReason] {
            return [
                .billOwnerChanged,
                .insufficientPermission,
                .internalFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .billOwnerChanged: return "BILL_OWNER_CHANGED"
            case .insufficientPermission: return "INSUFFICIENT_PERMISSION"
            case .internalFailure: return "INTERNAL_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionStatusReason(rawValue: rawValue) ?? ExecutionStatusReason.sdkUnknown(rawValue)
        }
    }
}

extension BCMDataExportsClientTypes.Export: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataQuery = "DataQuery"
        case description = "Description"
        case destinationConfigurations = "DestinationConfigurations"
        case exportArn = "ExportArn"
        case name = "Name"
        case refreshCadence = "RefreshCadence"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataQuery = self.dataQuery {
            try encodeContainer.encode(dataQuery, forKey: .dataQuery)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationConfigurations = self.destinationConfigurations {
            try encodeContainer.encode(destinationConfigurations, forKey: .destinationConfigurations)
        }
        if let exportArn = self.exportArn {
            try encodeContainer.encode(exportArn, forKey: .exportArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let refreshCadence = self.refreshCadence {
            try encodeContainer.encode(refreshCadence, forKey: .refreshCadence)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportArn)
        exportArn = exportArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataQueryDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.DataQuery.self, forKey: .dataQuery)
        dataQuery = dataQueryDecoded
        let destinationConfigurationsDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.DestinationConfigurations.self, forKey: .destinationConfigurations)
        destinationConfigurations = destinationConfigurationsDecoded
        let refreshCadenceDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.RefreshCadence.self, forKey: .refreshCadence)
        refreshCadence = refreshCadenceDecoded
    }
}

extension BCMDataExportsClientTypes {
    /// The details that are available for an export.
    public struct Export: Swift.Equatable {
        /// The data query for this specific data export.
        /// This member is required.
        public var dataQuery: BCMDataExportsClientTypes.DataQuery?
        /// The description for this specific data export.
        public var description: Swift.String?
        /// The destination configuration for this specific data export.
        /// This member is required.
        public var destinationConfigurations: BCMDataExportsClientTypes.DestinationConfigurations?
        /// The Amazon Resource Name (ARN) for this export.
        public var exportArn: Swift.String?
        /// The name of this specific data export.
        /// This member is required.
        public var name: Swift.String?
        /// The cadence for Amazon Web Services to update the export in your S3 bucket.
        /// This member is required.
        public var refreshCadence: BCMDataExportsClientTypes.RefreshCadence?

        public init(
            dataQuery: BCMDataExportsClientTypes.DataQuery? = nil,
            description: Swift.String? = nil,
            destinationConfigurations: BCMDataExportsClientTypes.DestinationConfigurations? = nil,
            exportArn: Swift.String? = nil,
            name: Swift.String? = nil,
            refreshCadence: BCMDataExportsClientTypes.RefreshCadence? = nil
        )
        {
            self.dataQuery = dataQuery
            self.description = description
            self.destinationConfigurations = destinationConfigurations
            self.exportArn = exportArn
            self.name = name
            self.refreshCadence = refreshCadence
        }
    }

}

extension BCMDataExportsClientTypes.ExportReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportArn = "ExportArn"
        case exportName = "ExportName"
        case exportStatus = "ExportStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportArn = self.exportArn {
            try encodeContainer.encode(exportArn, forKey: .exportArn)
        }
        if let exportName = self.exportName {
            try encodeContainer.encode(exportName, forKey: .exportName)
        }
        if let exportStatus = self.exportStatus {
            try encodeContainer.encode(exportStatus, forKey: .exportStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportArn)
        exportArn = exportArnDecoded
        let exportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportName)
        exportName = exportNameDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
    }
}

extension BCMDataExportsClientTypes {
    /// The reference details for a given export.
    public struct ExportReference: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for this export.
        /// This member is required.
        public var exportArn: Swift.String?
        /// The name of this specific data export.
        /// This member is required.
        public var exportName: Swift.String?
        /// The status of this specific data export.
        /// This member is required.
        public var exportStatus: BCMDataExportsClientTypes.ExportStatus?

        public init(
            exportArn: Swift.String? = nil,
            exportName: Swift.String? = nil,
            exportStatus: BCMDataExportsClientTypes.ExportStatus? = nil
        )
        {
            self.exportArn = exportArn
            self.exportName = exportName
            self.exportStatus = exportStatus
        }
    }

}

extension BCMDataExportsClientTypes.ExportStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case lastRefreshedAt = "LastRefreshedAt"
        case lastUpdatedAt = "LastUpdatedAt"
        case statusCode = "StatusCode"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastRefreshedAt = self.lastRefreshedAt {
            try encodeContainer.encodeTimestamp(lastRefreshedAt, format: .dateTime, forKey: .lastRefreshedAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason.rawValue, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.ExportStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.ExecutionStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let lastRefreshedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastRefreshedAt)
        lastRefreshedAt = lastRefreshedAtDecoded
    }
}

extension BCMDataExportsClientTypes {
    /// The status of the data export.
    public struct ExportStatus: Swift.Equatable {
        /// The timestamp of when the export was created.
        public var createdAt: ClientRuntime.Date?
        /// The timestamp of when the export was last generated.
        public var lastRefreshedAt: ClientRuntime.Date?
        /// The timestamp of when the export was updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The status code for the request.
        public var statusCode: BCMDataExportsClientTypes.ExportStatusCode?
        /// The description for the status code.
        public var statusReason: BCMDataExportsClientTypes.ExecutionStatusReason?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            lastRefreshedAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            statusCode: BCMDataExportsClientTypes.ExportStatusCode? = nil,
            statusReason: BCMDataExportsClientTypes.ExecutionStatusReason? = nil
        )
        {
            self.createdAt = createdAt
            self.lastRefreshedAt = lastRefreshedAt
            self.lastUpdatedAt = lastUpdatedAt
            self.statusCode = statusCode
            self.statusReason = statusReason
        }
    }

}

extension BCMDataExportsClientTypes {
    public enum ExportStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportStatusCode] {
            return [
                .healthy,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportStatusCode(rawValue: rawValue) ?? ExportStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension BCMDataExportsClientTypes {
    public enum FormatOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case parquet
        case textOrCsv
        case sdkUnknown(Swift.String)

        public static var allCases: [FormatOption] {
            return [
                .parquet,
                .textOrCsv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .parquet: return "PARQUET"
            case .textOrCsv: return "TEXT_OR_CSV"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FormatOption(rawValue: rawValue) ?? FormatOption.sdkUnknown(rawValue)
        }
    }
}

extension BCMDataExportsClientTypes {
    public enum FrequencyOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case synchronous
        case sdkUnknown(Swift.String)

        public static var allCases: [FrequencyOption] {
            return [
                .synchronous,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .synchronous: return "SYNCHRONOUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FrequencyOption(rawValue: rawValue) ?? FrequencyOption.sdkUnknown(rawValue)
        }
    }
}

extension GetExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case exportArn = "ExportArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let exportArn = self.exportArn {
            try encodeContainer.encode(exportArn, forKey: .exportArn)
        }
    }
}

extension GetExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetExecutionInput: Swift.Equatable {
    /// The ID for this specific execution.
    /// This member is required.
    public var executionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Export object that generated this specific execution.
    /// This member is required.
    public var exportArn: Swift.String?

    public init(
        executionId: Swift.String? = nil,
        exportArn: Swift.String? = nil
    )
    {
        self.executionId = executionId
        self.exportArn = exportArn
    }
}

struct GetExecutionInputBody: Swift.Equatable {
    let exportArn: Swift.String?
    let executionId: Swift.String?
}

extension GetExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case exportArn = "ExportArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportArn)
        exportArn = exportArnDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
    }
}

extension GetExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.executionId = output.executionId
            self.executionStatus = output.executionStatus
            self.export = output.export
        } else {
            self.executionId = nil
            self.executionStatus = nil
            self.export = nil
        }
    }
}

public struct GetExecutionOutput: Swift.Equatable {
    /// The ID for this specific execution.
    public var executionId: Swift.String?
    /// The status of this specific execution.
    public var executionStatus: BCMDataExportsClientTypes.ExecutionStatus?
    /// The export data for this specific execution. This export data is a snapshot from when the execution was generated. The data could be different from the current export data if the export was updated since the execution was generated.
    public var export: BCMDataExportsClientTypes.Export?

    public init(
        executionId: Swift.String? = nil,
        executionStatus: BCMDataExportsClientTypes.ExecutionStatus? = nil,
        export: BCMDataExportsClientTypes.Export? = nil
    )
    {
        self.executionId = executionId
        self.executionStatus = executionStatus
        self.export = export
    }
}

struct GetExecutionOutputBody: Swift.Equatable {
    let executionId: Swift.String?
    let export: BCMDataExportsClientTypes.Export?
    let executionStatus: BCMDataExportsClientTypes.ExecutionStatus?
}

extension GetExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case executionStatus = "ExecutionStatus"
        case export = "Export"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let exportDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.Export.self, forKey: .export)
        export = exportDecoded
        let executionStatusDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.ExecutionStatus.self, forKey: .executionStatus)
        executionStatus = executionStatusDecoded
    }
}

enum GetExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportArn = "ExportArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportArn = self.exportArn {
            try encodeContainer.encode(exportArn, forKey: .exportArn)
        }
    }
}

extension GetExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetExportInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for this export.
    /// This member is required.
    public var exportArn: Swift.String?

    public init(
        exportArn: Swift.String? = nil
    )
    {
        self.exportArn = exportArn
    }
}

struct GetExportInputBody: Swift.Equatable {
    let exportArn: Swift.String?
}

extension GetExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportArn = "ExportArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportArn)
        exportArn = exportArnDecoded
    }
}

extension GetExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.export = output.export
            self.exportStatus = output.exportStatus
        } else {
            self.export = nil
            self.exportStatus = nil
        }
    }
}

public struct GetExportOutput: Swift.Equatable {
    /// The data for this specific export.
    public var export: BCMDataExportsClientTypes.Export?
    /// The status of this specific export.
    public var exportStatus: BCMDataExportsClientTypes.ExportStatus?

    public init(
        export: BCMDataExportsClientTypes.Export? = nil,
        exportStatus: BCMDataExportsClientTypes.ExportStatus? = nil
    )
    {
        self.export = export
        self.exportStatus = exportStatus
    }
}

struct GetExportOutputBody: Swift.Equatable {
    let export: BCMDataExportsClientTypes.Export?
    let exportStatus: BCMDataExportsClientTypes.ExportStatus?
}

extension GetExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case export = "Export"
        case exportStatus = "ExportStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.Export.self, forKey: .export)
        export = exportDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
    }
}

enum GetExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableName = "TableName"
        case tableProperties = "TableProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tableProperties = tableProperties {
            var tablePropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tableProperties)
            for (dictKey0, tableProperties0) in tableProperties {
                try tablePropertiesContainer.encode(tableProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension GetTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTableInput: Swift.Equatable {
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?
    /// TableProperties are additional configurations you can provide to change the data and schema of a table. Each table can have different TableProperties. Tables are not required to have any TableProperties. Each table property has a default value that it assumes if not specified.
    public var tableProperties: [Swift.String:Swift.String]?

    public init(
        tableName: Swift.String? = nil,
        tableProperties: [Swift.String:Swift.String]? = nil
    )
    {
        self.tableName = tableName
        self.tableProperties = tableProperties
    }
}

struct GetTableInputBody: Swift.Equatable {
    let tableName: Swift.String?
    let tableProperties: [Swift.String:Swift.String]?
}

extension GetTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableName = "TableName"
        case tableProperties = "TableProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let tablePropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tableProperties)
        var tablePropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let tablePropertiesContainer = tablePropertiesContainer {
            tablePropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, genericstring0) in tablePropertiesContainer {
                if let genericstring0 = genericstring0 {
                    tablePropertiesDecoded0?[key0] = genericstring0
                }
            }
        }
        tableProperties = tablePropertiesDecoded0
    }
}

extension GetTableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTableOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.schema = output.schema
            self.tableName = output.tableName
            self.tableProperties = output.tableProperties
        } else {
            self.description = nil
            self.schema = nil
            self.tableName = nil
            self.tableProperties = nil
        }
    }
}

public struct GetTableOutput: Swift.Equatable {
    /// The table description.
    public var description: Swift.String?
    /// The schema of the table.
    public var schema: [BCMDataExportsClientTypes.Column]?
    /// The name of the table.
    public var tableName: Swift.String?
    /// TableProperties are additional configurations you can provide to change the data and schema of a table. Each table can have different TableProperties. Tables are not required to have any TableProperties. Each table property has a default value that it assumes if not specified.
    public var tableProperties: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        schema: [BCMDataExportsClientTypes.Column]? = nil,
        tableName: Swift.String? = nil,
        tableProperties: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.schema = schema
        self.tableName = tableName
        self.tableProperties = tableProperties
    }
}

struct GetTableOutputBody: Swift.Equatable {
    let tableName: Swift.String?
    let description: Swift.String?
    let tableProperties: [Swift.String:Swift.String]?
    let schema: [BCMDataExportsClientTypes.Column]?
}

extension GetTableOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case schema = "Schema"
        case tableName = "TableName"
        case tableProperties = "TableProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tablePropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tableProperties)
        var tablePropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let tablePropertiesContainer = tablePropertiesContainer {
            tablePropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, genericstring0) in tablePropertiesContainer {
                if let genericstring0 = genericstring0 {
                    tablePropertiesDecoded0?[key0] = genericstring0
                }
            }
        }
        tableProperties = tablePropertiesDecoded0
        let schemaContainer = try containerValues.decodeIfPresent([BCMDataExportsClientTypes.Column?].self, forKey: .schema)
        var schemaDecoded0:[BCMDataExportsClientTypes.Column]? = nil
        if let schemaContainer = schemaContainer {
            schemaDecoded0 = [BCMDataExportsClientTypes.Column]()
            for structure0 in schemaContainer {
                if let structure0 = structure0 {
                    schemaDecoded0?.append(structure0)
                }
            }
        }
        schema = schemaDecoded0
    }
}

enum GetTableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error on the server occurred during the processing of your request. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportArn = "ExportArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportArn = self.exportArn {
            try encodeContainer.encode(exportArn, forKey: .exportArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListExecutionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for this export.
    /// This member is required.
    public var exportArn: Swift.String?
    /// The maximum number of objects that are returned for the request.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        exportArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportArn = exportArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExecutionsInputBody: Swift.Equatable {
    let exportArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportArn = "ExportArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportArn)
        exportArn = exportArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExecutionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExecutionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.executions = output.executions
            self.nextToken = output.nextToken
        } else {
            self.executions = nil
            self.nextToken = nil
        }
    }
}

public struct ListExecutionsOutput: Swift.Equatable {
    /// The list of executions.
    public var executions: [BCMDataExportsClientTypes.ExecutionReference]?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        executions: [BCMDataExportsClientTypes.ExecutionReference]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.executions = executions
        self.nextToken = nextToken
    }
}

struct ListExecutionsOutputBody: Swift.Equatable {
    let executions: [BCMDataExportsClientTypes.ExecutionReference]?
    let nextToken: Swift.String?
}

extension ListExecutionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executions = "Executions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionsContainer = try containerValues.decodeIfPresent([BCMDataExportsClientTypes.ExecutionReference?].self, forKey: .executions)
        var executionsDecoded0:[BCMDataExportsClientTypes.ExecutionReference]? = nil
        if let executionsContainer = executionsContainer {
            executionsDecoded0 = [BCMDataExportsClientTypes.ExecutionReference]()
            for structure0 in executionsContainer {
                if let structure0 = structure0 {
                    executionsDecoded0?.append(structure0)
                }
            }
        }
        executions = executionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExecutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListExportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListExportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListExportsInput: Swift.Equatable {
    /// The maximum number of objects that are returned for the request.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExportsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListExportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.exports = output.exports
            self.nextToken = output.nextToken
        } else {
            self.exports = nil
            self.nextToken = nil
        }
    }
}

public struct ListExportsOutput: Swift.Equatable {
    /// The details of the exports, including name and export status.
    public var exports: [BCMDataExportsClientTypes.ExportReference]?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        exports: [BCMDataExportsClientTypes.ExportReference]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exports = exports
        self.nextToken = nextToken
    }
}

struct ListExportsOutputBody: Swift.Equatable {
    let exports: [BCMDataExportsClientTypes.ExportReference]?
    let nextToken: Swift.String?
}

extension ListExportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exports = "Exports"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportsContainer = try containerValues.decodeIfPresent([BCMDataExportsClientTypes.ExportReference?].self, forKey: .exports)
        var exportsDecoded0:[BCMDataExportsClientTypes.ExportReference]? = nil
        if let exportsContainer = exportsContainer {
            exportsDecoded0 = [BCMDataExportsClientTypes.ExportReference]()
            for structure0 in exportsContainer {
                if let structure0 = structure0 {
                    exportsDecoded0?.append(structure0)
                }
            }
        }
        exports = exportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTablesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTablesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTablesInput: Swift.Equatable {
    /// The maximum number of objects that are returned for the request.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTablesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTablesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTablesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTablesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tables = output.tables
        } else {
            self.nextToken = nil
            self.tables = nil
        }
    }
}

public struct ListTablesOutput: Swift.Equatable {
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of tables.
    public var tables: [BCMDataExportsClientTypes.Table]?

    public init(
        nextToken: Swift.String? = nil,
        tables: [BCMDataExportsClientTypes.Table]? = nil
    )
    {
        self.nextToken = nextToken
        self.tables = tables
    }
}

struct ListTablesOutputBody: Swift.Equatable {
    let tables: [BCMDataExportsClientTypes.Table]?
    let nextToken: Swift.String?
}

extension ListTablesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tables = "Tables"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tablesContainer = try containerValues.decodeIfPresent([BCMDataExportsClientTypes.Table?].self, forKey: .tables)
        var tablesDecoded0:[BCMDataExportsClientTypes.Table]? = nil
        if let tablesContainer = tablesContainer {
            tablesDecoded0 = [BCMDataExportsClientTypes.Table]()
            for structure0 in tablesContainer {
                if let structure0 = structure0 {
                    tablesDecoded0?.append(structure0)
                }
            }
        }
        tables = tablesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTablesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of objects that are returned for the request.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The unique identifier for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceTags = output.resourceTags
        } else {
            self.nextToken = nil
            self.resourceTags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional list of tags to associate with the specified export. Each tag consists of a key and a value, and each key must be unique for the resource.
    public var resourceTags: [BCMDataExportsClientTypes.ResourceTag]?

    public init(
        nextToken: Swift.String? = nil,
        resourceTags: [BCMDataExportsClientTypes.ResourceTag]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceTags = resourceTags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let resourceTags: [BCMDataExportsClientTypes.ResourceTag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceTags = "ResourceTags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTagsContainer = try containerValues.decodeIfPresent([BCMDataExportsClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[BCMDataExportsClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [BCMDataExportsClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BCMDataExportsClientTypes {
    public enum OverwriteOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createNewReport
        case overwriteReport
        case sdkUnknown(Swift.String)

        public static var allCases: [OverwriteOption] {
            return [
                .createNewReport,
                .overwriteReport,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createNewReport: return "CREATE_NEW_REPORT"
            case .overwriteReport: return "OVERWRITE_REPORT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OverwriteOption(rawValue: rawValue) ?? OverwriteOption.sdkUnknown(rawValue)
        }
    }
}

extension BCMDataExportsClientTypes.RefreshCadence: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frequency = "Frequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frequencyDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.FrequencyOption.self, forKey: .frequency)
        frequency = frequencyDecoded
    }
}

extension BCMDataExportsClientTypes {
    /// The cadence for Amazon Web Services to update the data export in your S3 bucket.
    public struct RefreshCadence: Swift.Equatable {
        /// The frequency that data exports are updated. The export refreshes each time the source data updates, up to three times daily.
        /// This member is required.
        public var frequency: BCMDataExportsClientTypes.FrequencyOption?

        public init(
            frequency: BCMDataExportsClientTypes.FrequencyOption? = nil
        )
        {
            self.frequency = frequency
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified Amazon Resource Name (ARN) in the request doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that was not found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that was not found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension BCMDataExportsClientTypes.ResourceTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension BCMDataExportsClientTypes {
    /// The tag structure that contains a tag key and value.
    public struct ResourceTag: Swift.Equatable {
        /// The key that's associated with the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value that's associated with the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension BCMDataExportsClientTypes.S3Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case s3OutputConfigurations = "S3OutputConfigurations"
        case s3Prefix = "S3Prefix"
        case s3Region = "S3Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3OutputConfigurations = self.s3OutputConfigurations {
            try encodeContainer.encode(s3OutputConfigurations, forKey: .s3OutputConfigurations)
        }
        if let s3Prefix = self.s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
        if let s3Region = self.s3Region {
            try encodeContainer.encode(s3Region, forKey: .s3Region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let s3RegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Region)
        s3Region = s3RegionDecoded
        let s3OutputConfigurationsDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.S3OutputConfigurations.self, forKey: .s3OutputConfigurations)
        s3OutputConfigurations = s3OutputConfigurationsDecoded
    }
}

extension BCMDataExportsClientTypes {
    /// Describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and object keys of a data exports file.
    public struct S3Destination: Swift.Equatable {
        /// The name of the Amazon S3 bucket used as the destination of a data export file.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The output configuration for the data export.
        /// This member is required.
        public var s3OutputConfigurations: BCMDataExportsClientTypes.S3OutputConfigurations?
        /// The S3 path prefix you want prepended to the name of your data export.
        /// This member is required.
        public var s3Prefix: Swift.String?
        /// The S3 bucket Region.
        /// This member is required.
        public var s3Region: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3OutputConfigurations: BCMDataExportsClientTypes.S3OutputConfigurations? = nil,
            s3Prefix: Swift.String? = nil,
            s3Region: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3OutputConfigurations = s3OutputConfigurations
            self.s3Prefix = s3Prefix
            self.s3Region = s3Region
        }
    }

}

extension BCMDataExportsClientTypes.S3OutputConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compression = "Compression"
        case format = "Format"
        case outputType = "OutputType"
        case overwrite = "Overwrite"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compression = self.compression {
            try encodeContainer.encode(compression.rawValue, forKey: .compression)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let outputType = self.outputType {
            try encodeContainer.encode(outputType.rawValue, forKey: .outputType)
        }
        if let overwrite = self.overwrite {
            try encodeContainer.encode(overwrite.rawValue, forKey: .overwrite)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputTypeDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.S3OutputType.self, forKey: .outputType)
        outputType = outputTypeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.FormatOption.self, forKey: .format)
        format = formatDecoded
        let compressionDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.CompressionOption.self, forKey: .compression)
        compression = compressionDecoded
        let overwriteDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.OverwriteOption.self, forKey: .overwrite)
        overwrite = overwriteDecoded
    }
}

extension BCMDataExportsClientTypes {
    /// The compression type, file format, and overwrite preference for the data export.
    public struct S3OutputConfigurations: Swift.Equatable {
        /// The compression type for the data export.
        /// This member is required.
        public var compression: BCMDataExportsClientTypes.CompressionOption?
        /// The file format for the data export.
        /// This member is required.
        public var format: BCMDataExportsClientTypes.FormatOption?
        /// The output type for the data export.
        /// This member is required.
        public var outputType: BCMDataExportsClientTypes.S3OutputType?
        /// The rule to follow when generating a version of the data export file. You have the choice to overwrite the previous version or to be delivered in addition to the previous versions. Overwriting exports can save on Amazon S3 storage costs. Creating new export versions allows you to track the changes in cost and usage data over time.
        /// This member is required.
        public var overwrite: BCMDataExportsClientTypes.OverwriteOption?

        public init(
            compression: BCMDataExportsClientTypes.CompressionOption? = nil,
            format: BCMDataExportsClientTypes.FormatOption? = nil,
            outputType: BCMDataExportsClientTypes.S3OutputType? = nil,
            overwrite: BCMDataExportsClientTypes.OverwriteOption? = nil
        )
        {
            self.compression = compression
            self.format = format
            self.outputType = outputType
            self.overwrite = overwrite
        }
    }

}

extension BCMDataExportsClientTypes {
    public enum S3OutputType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [S3OutputType] {
            return [
                .custom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3OutputType(rawValue: rawValue) ?? S3OutputType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You've reached the limit on the number of resources you can create, or exceeded the size of an individual resource.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code that was exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The identifier of the resource that exceeded quota.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that exceeded quota.
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code that exceeded quota. It will always be “AWSBillingAndCostManagementDataExports”.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension BCMDataExportsClientTypes.Table: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case tableName = "TableName"
        case tableProperties = "TableProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tableProperties = tableProperties {
            var tablePropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tableProperties)
            for tablepropertydescription0 in tableProperties {
                try tablePropertiesContainer.encode(tablepropertydescription0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tablePropertiesContainer = try containerValues.decodeIfPresent([BCMDataExportsClientTypes.TablePropertyDescription?].self, forKey: .tableProperties)
        var tablePropertiesDecoded0:[BCMDataExportsClientTypes.TablePropertyDescription]? = nil
        if let tablePropertiesContainer = tablePropertiesContainer {
            tablePropertiesDecoded0 = [BCMDataExportsClientTypes.TablePropertyDescription]()
            for structure0 in tablePropertiesContainer {
                if let structure0 = structure0 {
                    tablePropertiesDecoded0?.append(structure0)
                }
            }
        }
        tableProperties = tablePropertiesDecoded0
    }
}

extension BCMDataExportsClientTypes {
    /// The details for the data export table.
    public struct Table: Swift.Equatable {
        /// The description for the table.
        public var description: Swift.String?
        /// The name of the table.
        public var tableName: Swift.String?
        /// The properties for the table.
        public var tableProperties: [BCMDataExportsClientTypes.TablePropertyDescription]?

        public init(
            description: Swift.String? = nil,
            tableName: Swift.String? = nil,
            tableProperties: [BCMDataExportsClientTypes.TablePropertyDescription]? = nil
        )
        {
            self.description = description
            self.tableName = tableName
            self.tableProperties = tableProperties
        }
    }

}

extension BCMDataExportsClientTypes.TablePropertyDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case description = "Description"
        case name = "Name"
        case validValues = "ValidValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let validValues = validValues {
            var validValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validValues)
            for genericstring0 in validValues {
                try validValuesContainer.encode(genericstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let validValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .validValues)
        var validValuesDecoded0:[Swift.String]? = nil
        if let validValuesContainer = validValuesContainer {
            validValuesDecoded0 = [Swift.String]()
            for string0 in validValuesContainer {
                if let string0 = string0 {
                    validValuesDecoded0?.append(string0)
                }
            }
        }
        validValues = validValuesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension BCMDataExportsClientTypes {
    /// The properties for the data export table.
    public struct TablePropertyDescription: Swift.Equatable {
        /// The default value for the table.
        public var defaultValue: Swift.String?
        /// The description for the table.
        public var description: Swift.String?
        /// The name of the table.
        public var name: Swift.String?
        /// The valid values for the table.
        public var validValues: [Swift.String]?

        public init(
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            validValues: [Swift.String]? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.validValues = validValues
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourceTags = "ResourceTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetag0 in resourceTags {
                try resourceTagsContainer.encode(resourcetag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The unique identifier for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to associate with the resource. Each tag consists of a key and a value, and each key must be unique for the resource.
    /// This member is required.
    public var resourceTags: [BCMDataExportsClientTypes.ResourceTag]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTags: [BCMDataExportsClientTypes.ResourceTag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceTags = resourceTags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let resourceTags: [BCMDataExportsClientTypes.ResourceTag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourceTags = "ResourceTags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([BCMDataExportsClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[BCMDataExportsClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [BCMDataExportsClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code that exceeded the throttling limit.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The service code that exceeded the throttling limit. It will always be “AWSBillingAndCostManagementDataExports”.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourceTagKeys = "ResourceTagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceTagKeys = resourceTagKeys {
            var resourceTagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTagKeys)
            for resourcetagkey0 in resourceTagKeys {
                try resourceTagKeysContainer.encode(resourcetagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The unique identifier for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys that are associated with the resource ARN.
    /// This member is required.
    public var resourceTagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceTagKeys = resourceTagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let resourceTagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourceTagKeys = "ResourceTagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTagKeys)
        var resourceTagKeysDecoded0:[Swift.String]? = nil
        if let resourceTagKeysContainer = resourceTagKeysContainer {
            resourceTagKeysDecoded0 = [Swift.String]()
            for string0 in resourceTagKeysContainer {
                if let string0 = string0 {
                    resourceTagKeysDecoded0?.append(string0)
                }
            }
        }
        resourceTagKeys = resourceTagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case export = "Export"
        case exportArn = "ExportArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let export = self.export {
            try encodeContainer.encode(export, forKey: .export)
        }
        if let exportArn = self.exportArn {
            try encodeContainer.encode(exportArn, forKey: .exportArn)
        }
    }
}

extension UpdateExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateExportInput: Swift.Equatable {
    /// The name and query details for the export.
    /// This member is required.
    public var export: BCMDataExportsClientTypes.Export?
    /// The Amazon Resource Name (ARN) for this export.
    /// This member is required.
    public var exportArn: Swift.String?

    public init(
        export: BCMDataExportsClientTypes.Export? = nil,
        exportArn: Swift.String? = nil
    )
    {
        self.export = export
        self.exportArn = exportArn
    }
}

struct UpdateExportInputBody: Swift.Equatable {
    let exportArn: Swift.String?
    let export: BCMDataExportsClientTypes.Export?
}

extension UpdateExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case export = "Export"
        case exportArn = "ExportArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportArn)
        exportArn = exportArnDecoded
        let exportDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.Export.self, forKey: .export)
        export = exportDecoded
    }
}

extension UpdateExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.exportArn = output.exportArn
        } else {
            self.exportArn = nil
        }
    }
}

public struct UpdateExportOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for this export.
    public var exportArn: Swift.String?

    public init(
        exportArn: Swift.String? = nil
    )
    {
        self.exportArn = exportArn
    }
}

struct UpdateExportOutputBody: Swift.Equatable {
    let exportArn: Swift.String?
}

extension UpdateExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportArn = "ExportArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportArn)
        exportArn = exportArnDecoded
    }
}

enum UpdateExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The list of fields that are invalid.
        public internal(set) var fields: [BCMDataExportsClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation exception.
        public internal(set) var reason: BCMDataExportsClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [BCMDataExportsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: BCMDataExportsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: BCMDataExportsClientTypes.ValidationExceptionReason?
    let fields: [BCMDataExportsClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(BCMDataExportsClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([BCMDataExportsClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[BCMDataExportsClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [BCMDataExportsClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension BCMDataExportsClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BCMDataExportsClientTypes {
    /// The input failed to meet the constraints specified by the Amazon Web Services service in a specified field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message with the reason for the validation exception error.
        /// This member is required.
        public var message: Swift.String?
        /// The field name where the invalid entry was detected.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension BCMDataExportsClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
