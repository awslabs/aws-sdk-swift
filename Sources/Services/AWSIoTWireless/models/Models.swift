// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IoTWirelessClientTypes.AbpV1_0_x: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devAddr = "DevAddr"
        case fCntStart = "FCntStart"
        case sessionKeys = "SessionKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devAddr = self.devAddr {
            try encodeContainer.encode(devAddr, forKey: .devAddr)
        }
        if let fCntStart = self.fCntStart {
            try encodeContainer.encode(fCntStart, forKey: .fCntStart)
        }
        if let sessionKeys = self.sessionKeys {
            try encodeContainer.encode(sessionKeys, forKey: .sessionKeys)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devAddrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devAddr)
        devAddr = devAddrDecoded
        let sessionKeysDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SessionKeysAbpV1_0_x.self, forKey: .sessionKeys)
        sessionKeys = sessionKeysDecoded
        let fCntStartDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fCntStart)
        fCntStart = fCntStartDecoded
    }
}

extension IoTWirelessClientTypes {
    /// ABP device object for LoRaWAN specification v1.0.x
    public struct AbpV1_0_x: Swift.Equatable {
        /// The DevAddr value.
        public var devAddr: Swift.String?
        /// The FCnt init value.
        public var fCntStart: Swift.Int?
        /// Session keys for ABP v1.0.x
        public var sessionKeys: IoTWirelessClientTypes.SessionKeysAbpV1_0_x?

        public init(
            devAddr: Swift.String? = nil,
            fCntStart: Swift.Int? = nil,
            sessionKeys: IoTWirelessClientTypes.SessionKeysAbpV1_0_x? = nil
        )
        {
            self.devAddr = devAddr
            self.fCntStart = fCntStart
            self.sessionKeys = sessionKeys
        }
    }

}

extension IoTWirelessClientTypes.AbpV1_1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devAddr = "DevAddr"
        case fCntStart = "FCntStart"
        case sessionKeys = "SessionKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devAddr = self.devAddr {
            try encodeContainer.encode(devAddr, forKey: .devAddr)
        }
        if let fCntStart = self.fCntStart {
            try encodeContainer.encode(fCntStart, forKey: .fCntStart)
        }
        if let sessionKeys = self.sessionKeys {
            try encodeContainer.encode(sessionKeys, forKey: .sessionKeys)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devAddrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devAddr)
        devAddr = devAddrDecoded
        let sessionKeysDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SessionKeysAbpV1_1.self, forKey: .sessionKeys)
        sessionKeys = sessionKeysDecoded
        let fCntStartDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fCntStart)
        fCntStart = fCntStartDecoded
    }
}

extension IoTWirelessClientTypes {
    /// ABP device object for LoRaWAN specification v1.1
    public struct AbpV1_1: Swift.Equatable {
        /// The DevAddr value.
        public var devAddr: Swift.String?
        /// The FCnt init value.
        public var fCntStart: Swift.Int?
        /// Session keys for ABP v1.1
        public var sessionKeys: IoTWirelessClientTypes.SessionKeysAbpV1_1?

        public init(
            devAddr: Swift.String? = nil,
            fCntStart: Swift.Int? = nil,
            sessionKeys: IoTWirelessClientTypes.SessionKeysAbpV1_1? = nil
        )
        {
            self.devAddr = devAddr
            self.fCntStart = fCntStart
            self.sessionKeys = sessionKeys
        }
    }

}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// User does not have permission to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTWirelessClientTypes.Accuracy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case horizontalAccuracy = "HorizontalAccuracy"
        case verticalAccuracy = "VerticalAccuracy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let horizontalAccuracy = self.horizontalAccuracy {
            try encodeContainer.encode(horizontalAccuracy, forKey: .horizontalAccuracy)
        }
        if let verticalAccuracy = self.verticalAccuracy {
            try encodeContainer.encode(verticalAccuracy, forKey: .verticalAccuracy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let horizontalAccuracyDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .horizontalAccuracy)
        horizontalAccuracy = horizontalAccuracyDecoded
        let verticalAccuracyDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .verticalAccuracy)
        verticalAccuracy = verticalAccuracyDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The accuracy of the estimated position in meters. An empty value indicates that no position data is available. A value of ‘0.0’ value indicates that position data is available. This data corresponds to the position information that you specified instead of the position computed by solver.
    public struct Accuracy: Swift.Equatable {
        /// The horizontal accuracy of the estimated position, which is the difference between the estimated location and the actual device location.
        public var horizontalAccuracy: Swift.Float?
        /// The vertical accuracy of the estimated position, which is the difference between the estimated altitude and actual device latitude in meters.
        public var verticalAccuracy: Swift.Float?

        public init(
            horizontalAccuracy: Swift.Float? = nil,
            verticalAccuracy: Swift.Float? = nil
        )
        {
            self.horizontalAccuracy = horizontalAccuracy
            self.verticalAccuracy = verticalAccuracy
        }
    }

}

extension IoTWirelessClientTypes.ApplicationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationName = "DestinationName"
        case fPort = "FPort"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let fPort = self.fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fPort)
        fPort = fPortDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ApplicationConfigType.self, forKey: .type)
        type = typeDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWAN application configuration, which can be used to perform geolocation.
    public struct ApplicationConfig: Swift.Equatable {
        /// The name of the position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
        public var destinationName: Swift.String?
        /// The Fport value.
        public var fPort: Swift.Int?
        /// Application type, which can be specified to obtain real-time position information of your LoRaWAN device.
        public var type: IoTWirelessClientTypes.ApplicationConfigType?

        public init(
            destinationName: Swift.String? = nil,
            fPort: Swift.Int? = nil,
            type: IoTWirelessClientTypes.ApplicationConfigType? = nil
        )
        {
            self.destinationName = destinationName
            self.fPort = fPort
            self.type = type
        }
    }

}

extension IoTWirelessClientTypes {
    public enum ApplicationConfigType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case semtechgeolocation
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationConfigType] {
            return [
                .semtechgeolocation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .semtechgeolocation: return "SemtechGeolocation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationConfigType(rawValue: rawValue) ?? ApplicationConfigType.sdkUnknown(rawValue)
        }
    }
}

extension AssociateAwsAccountWithPartnerAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension AssociateAwsAccountWithPartnerAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/partner-accounts"
    }
}

public struct AssociateAwsAccountWithPartnerAccountInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The Sidewalk account credentials.
    /// This member is required.
    public var sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo?
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sidewalk = sidewalk
        self.tags = tags
    }
}

struct AssociateAwsAccountWithPartnerAccountInputBody: Swift.Equatable {
    let sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo?
    let clientRequestToken: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension AssociateAwsAccountWithPartnerAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkAccountInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AssociateAwsAccountWithPartnerAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateAwsAccountWithPartnerAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.sidewalk = output.sidewalk
        } else {
            self.arn = nil
            self.sidewalk = nil
        }
    }
}

public struct AssociateAwsAccountWithPartnerAccountOutput: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The Sidewalk account credentials.
    public var sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo?

    public init(
        arn: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo? = nil
    )
    {
        self.arn = arn
        self.sidewalk = sidewalk
    }
}

struct AssociateAwsAccountWithPartnerAccountOutputBody: Swift.Equatable {
    let sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo?
    let arn: Swift.String?
}

extension AssociateAwsAccountWithPartnerAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case sidewalk = "Sidewalk"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkAccountInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum AssociateAwsAccountWithPartnerAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateMulticastGroupWithFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastGroupId = "MulticastGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let multicastGroupId = self.multicastGroupId {
            try encodeContainer.encode(multicastGroupId, forKey: .multicastGroupId)
        }
    }
}

extension AssociateMulticastGroupWithFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/multicast-group"
    }
}

public struct AssociateMulticastGroupWithFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the multicast group.
    /// This member is required.
    public var multicastGroupId: Swift.String?

    public init(
        id: Swift.String? = nil,
        multicastGroupId: Swift.String? = nil
    )
    {
        self.id = id
        self.multicastGroupId = multicastGroupId
    }
}

struct AssociateMulticastGroupWithFuotaTaskInputBody: Swift.Equatable {
    let multicastGroupId: Swift.String?
}

extension AssociateMulticastGroupWithFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastGroupId = "MulticastGroupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multicastGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multicastGroupId)
        multicastGroupId = multicastGroupIdDecoded
    }
}

extension AssociateMulticastGroupWithFuotaTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateMulticastGroupWithFuotaTaskOutput: Swift.Equatable {

    public init() { }
}

enum AssociateMulticastGroupWithFuotaTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateWirelessDeviceWithFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessDeviceId = self.wirelessDeviceId {
            try encodeContainer.encode(wirelessDeviceId, forKey: .wirelessDeviceId)
        }
    }
}

extension AssociateWirelessDeviceWithFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/wireless-device"
    }
}

public struct AssociateWirelessDeviceWithFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init(
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct AssociateWirelessDeviceWithFuotaTaskInputBody: Swift.Equatable {
    let wirelessDeviceId: Swift.String?
}

extension AssociateWirelessDeviceWithFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessDeviceId)
        wirelessDeviceId = wirelessDeviceIdDecoded
    }
}

extension AssociateWirelessDeviceWithFuotaTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateWirelessDeviceWithFuotaTaskOutput: Swift.Equatable {

    public init() { }
}

enum AssociateWirelessDeviceWithFuotaTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateWirelessDeviceWithMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessDeviceId = self.wirelessDeviceId {
            try encodeContainer.encode(wirelessDeviceId, forKey: .wirelessDeviceId)
        }
    }
}

extension AssociateWirelessDeviceWithMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/wireless-device"
    }
}

public struct AssociateWirelessDeviceWithMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init(
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct AssociateWirelessDeviceWithMulticastGroupInputBody: Swift.Equatable {
    let wirelessDeviceId: Swift.String?
}

extension AssociateWirelessDeviceWithMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessDeviceId)
        wirelessDeviceId = wirelessDeviceIdDecoded
    }
}

extension AssociateWirelessDeviceWithMulticastGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateWirelessDeviceWithMulticastGroupOutput: Swift.Equatable {

    public init() { }
}

enum AssociateWirelessDeviceWithMulticastGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateWirelessDeviceWithThingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }
}

extension AssociateWirelessDeviceWithThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/thing"
    }
}

public struct AssociateWirelessDeviceWithThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of the thing to associate with the wireless device.
    /// This member is required.
    public var thingArn: Swift.String?

    public init(
        id: Swift.String? = nil,
        thingArn: Swift.String? = nil
    )
    {
        self.id = id
        self.thingArn = thingArn
    }
}

struct AssociateWirelessDeviceWithThingInputBody: Swift.Equatable {
    let thingArn: Swift.String?
}

extension AssociateWirelessDeviceWithThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension AssociateWirelessDeviceWithThingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateWirelessDeviceWithThingOutput: Swift.Equatable {

    public init() { }
}

enum AssociateWirelessDeviceWithThingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateWirelessGatewayWithCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotCertificateId = self.iotCertificateId {
            try encodeContainer.encode(iotCertificateId, forKey: .iotCertificateId)
        }
    }
}

extension AssociateWirelessGatewayWithCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
    }
}

public struct AssociateWirelessGatewayWithCertificateInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the certificate to associate with the wireless gateway.
    /// This member is required.
    public var iotCertificateId: Swift.String?

    public init(
        id: Swift.String? = nil,
        iotCertificateId: Swift.String? = nil
    )
    {
        self.id = id
        self.iotCertificateId = iotCertificateId
    }
}

struct AssociateWirelessGatewayWithCertificateInputBody: Swift.Equatable {
    let iotCertificateId: Swift.String?
}

extension AssociateWirelessGatewayWithCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
    }
}

extension AssociateWirelessGatewayWithCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateWirelessGatewayWithCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.iotCertificateId = output.iotCertificateId
        } else {
            self.iotCertificateId = nil
        }
    }
}

public struct AssociateWirelessGatewayWithCertificateOutput: Swift.Equatable {
    /// The ID of the certificate associated with the wireless gateway.
    public var iotCertificateId: Swift.String?

    public init(
        iotCertificateId: Swift.String? = nil
    )
    {
        self.iotCertificateId = iotCertificateId
    }
}

struct AssociateWirelessGatewayWithCertificateOutputBody: Swift.Equatable {
    let iotCertificateId: Swift.String?
}

extension AssociateWirelessGatewayWithCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
    }
}

enum AssociateWirelessGatewayWithCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateWirelessGatewayWithThingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }
}

extension AssociateWirelessGatewayWithThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/thing"
    }
}

public struct AssociateWirelessGatewayWithThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of the thing to associate with the wireless gateway.
    /// This member is required.
    public var thingArn: Swift.String?

    public init(
        id: Swift.String? = nil,
        thingArn: Swift.String? = nil
    )
    {
        self.id = id
        self.thingArn = thingArn
    }
}

struct AssociateWirelessGatewayWithThingInputBody: Swift.Equatable {
    let thingArn: Swift.String?
}

extension AssociateWirelessGatewayWithThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension AssociateWirelessGatewayWithThingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateWirelessGatewayWithThingOutput: Swift.Equatable {

    public init() { }
}

enum AssociateWirelessGatewayWithThingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTWirelessClientTypes {
    /// Sidewalk device battery level.
    public enum BatteryLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case low
        case normal
        case sdkUnknown(Swift.String)

        public static var allCases: [BatteryLevel] {
            return [
                .critical,
                .low,
                .normal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "critical"
            case .low: return "low"
            case .normal: return "normal"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatteryLevel(rawValue: rawValue) ?? BatteryLevel.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.Beaconing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRate = "DataRate"
        case frequencies = "Frequencies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRate = self.dataRate {
            try encodeContainer.encode(dataRate, forKey: .dataRate)
        }
        if let frequencies = frequencies {
            var frequenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .frequencies)
            for beaconingfrequency0 in frequencies {
                try frequenciesContainer.encode(beaconingfrequency0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRate)
        dataRate = dataRateDecoded
        let frequenciesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .frequencies)
        var frequenciesDecoded0:[Swift.Int]? = nil
        if let frequenciesContainer = frequenciesContainer {
            frequenciesDecoded0 = [Swift.Int]()
            for integer0 in frequenciesContainer {
                if let integer0 = integer0 {
                    frequenciesDecoded0?.append(integer0)
                }
            }
        }
        frequencies = frequenciesDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// Beaconing parameters for configuring the wireless gateways.
    public struct Beaconing: Swift.Equatable {
        /// The data rate for gateways that are sending the beacons.
        public var dataRate: Swift.Int?
        /// The frequency list for the gateways to send the beacons.
        public var frequencies: [Swift.Int]?

        public init(
            dataRate: Swift.Int? = nil,
            frequencies: [Swift.Int]? = nil
        )
        {
            self.dataRate = dataRate
            self.frequencies = frequencies
        }
    }

}

extension CancelMulticastGroupSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/session"
    }
}

public struct CancelMulticastGroupSessionInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CancelMulticastGroupSessionInputBody: Swift.Equatable {
}

extension CancelMulticastGroupSessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelMulticastGroupSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelMulticastGroupSessionOutput: Swift.Equatable {

    public init() { }
}

enum CancelMulticastGroupSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTWirelessClientTypes.CdmaLocalId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdmaChannel = "CdmaChannel"
        case pnOffset = "PnOffset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdmaChannel = self.cdmaChannel {
            try encodeContainer.encode(cdmaChannel, forKey: .cdmaChannel)
        }
        if let pnOffset = self.pnOffset {
            try encodeContainer.encode(pnOffset, forKey: .pnOffset)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pnOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pnOffset)
        pnOffset = pnOffsetDecoded
        let cdmaChannelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cdmaChannel)
        cdmaChannel = cdmaChannelDecoded
    }
}

extension IoTWirelessClientTypes {
    /// CDMA local ID information, which corresponds to the local identification parameters of a CDMA cell.
    public struct CdmaLocalId: Swift.Equatable {
        /// CDMA channel information.
        /// This member is required.
        public var cdmaChannel: Swift.Int?
        /// Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.
        /// This member is required.
        public var pnOffset: Swift.Int?

        public init(
            cdmaChannel: Swift.Int? = nil,
            pnOffset: Swift.Int? = nil
        )
        {
            self.cdmaChannel = cdmaChannel
            self.pnOffset = pnOffset
        }
    }

}

extension IoTWirelessClientTypes.CdmaNmrObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseStationId = "BaseStationId"
        case cdmaChannel = "CdmaChannel"
        case pilotPower = "PilotPower"
        case pnOffset = "PnOffset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseStationId = self.baseStationId {
            try encodeContainer.encode(baseStationId, forKey: .baseStationId)
        }
        if let cdmaChannel = self.cdmaChannel {
            try encodeContainer.encode(cdmaChannel, forKey: .cdmaChannel)
        }
        if let pilotPower = self.pilotPower {
            try encodeContainer.encode(pilotPower, forKey: .pilotPower)
        }
        if let pnOffset = self.pnOffset {
            try encodeContainer.encode(pnOffset, forKey: .pnOffset)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pnOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pnOffset)
        pnOffset = pnOffsetDecoded
        let cdmaChannelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cdmaChannel)
        cdmaChannel = cdmaChannelDecoded
        let pilotPowerDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pilotPower)
        pilotPower = pilotPowerDecoded
        let baseStationIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseStationId)
        baseStationId = baseStationIdDecoded
    }
}

extension IoTWirelessClientTypes {
    /// CDMA object for network measurement reports.
    public struct CdmaNmrObj: Swift.Equatable {
        /// CDMA base station ID (BSID).
        public var baseStationId: Swift.Int?
        /// CDMA channel information.
        /// This member is required.
        public var cdmaChannel: Swift.Int?
        /// Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).
        public var pilotPower: Swift.Int?
        /// Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.
        /// This member is required.
        public var pnOffset: Swift.Int?

        public init(
            baseStationId: Swift.Int? = nil,
            cdmaChannel: Swift.Int? = nil,
            pilotPower: Swift.Int? = nil,
            pnOffset: Swift.Int? = nil
        )
        {
            self.baseStationId = baseStationId
            self.cdmaChannel = cdmaChannel
            self.pilotPower = pilotPower
            self.pnOffset = pnOffset
        }
    }

}

extension IoTWirelessClientTypes.CdmaObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseLat = "BaseLat"
        case baseLng = "BaseLng"
        case baseStationId = "BaseStationId"
        case cdmaLocalId = "CdmaLocalId"
        case cdmaNmr = "CdmaNmr"
        case networkId = "NetworkId"
        case pilotPower = "PilotPower"
        case registrationZone = "RegistrationZone"
        case systemId = "SystemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseLat = self.baseLat {
            try encodeContainer.encode(baseLat, forKey: .baseLat)
        }
        if let baseLng = self.baseLng {
            try encodeContainer.encode(baseLng, forKey: .baseLng)
        }
        if let baseStationId = self.baseStationId {
            try encodeContainer.encode(baseStationId, forKey: .baseStationId)
        }
        if let cdmaLocalId = self.cdmaLocalId {
            try encodeContainer.encode(cdmaLocalId, forKey: .cdmaLocalId)
        }
        if let cdmaNmr = cdmaNmr {
            var cdmaNmrContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cdmaNmr)
            for cdmanmrobj0 in cdmaNmr {
                try cdmaNmrContainer.encode(cdmanmrobj0)
            }
        }
        if let networkId = self.networkId {
            try encodeContainer.encode(networkId, forKey: .networkId)
        }
        if let pilotPower = self.pilotPower {
            try encodeContainer.encode(pilotPower, forKey: .pilotPower)
        }
        if let registrationZone = self.registrationZone {
            try encodeContainer.encode(registrationZone, forKey: .registrationZone)
        }
        if let systemId = self.systemId {
            try encodeContainer.encode(systemId, forKey: .systemId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let systemIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .systemId)
        systemId = systemIdDecoded
        let networkIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .networkId)
        networkId = networkIdDecoded
        let baseStationIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseStationId)
        baseStationId = baseStationIdDecoded
        let registrationZoneDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .registrationZone)
        registrationZone = registrationZoneDecoded
        let cdmaLocalIdDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.CdmaLocalId.self, forKey: .cdmaLocalId)
        cdmaLocalId = cdmaLocalIdDecoded
        let pilotPowerDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pilotPower)
        pilotPower = pilotPowerDecoded
        let baseLatDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .baseLat)
        baseLat = baseLatDecoded
        let baseLngDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .baseLng)
        baseLng = baseLngDecoded
        let cdmaNmrContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.CdmaNmrObj?].self, forKey: .cdmaNmr)
        var cdmaNmrDecoded0:[IoTWirelessClientTypes.CdmaNmrObj]? = nil
        if let cdmaNmrContainer = cdmaNmrContainer {
            cdmaNmrDecoded0 = [IoTWirelessClientTypes.CdmaNmrObj]()
            for structure0 in cdmaNmrContainer {
                if let structure0 = structure0 {
                    cdmaNmrDecoded0?.append(structure0)
                }
            }
        }
        cdmaNmr = cdmaNmrDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// CDMA (Code-division multiple access) object.
    public struct CdmaObj: Swift.Equatable {
        /// CDMA base station latitude in degrees.
        public var baseLat: Swift.Float?
        /// CDMA base station longitude in degrees.
        public var baseLng: Swift.Float?
        /// CDMA base station ID (BSID).
        /// This member is required.
        public var baseStationId: Swift.Int?
        /// CDMA local identification (local ID) parameters.
        public var cdmaLocalId: IoTWirelessClientTypes.CdmaLocalId?
        /// CDMA network measurement reports.
        public var cdmaNmr: [IoTWirelessClientTypes.CdmaNmrObj]?
        /// CDMA network ID (NID).
        /// This member is required.
        public var networkId: Swift.Int?
        /// Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).
        public var pilotPower: Swift.Int?
        /// CDMA registration zone (RZ).
        public var registrationZone: Swift.Int?
        /// CDMA system ID (SID).
        /// This member is required.
        public var systemId: Swift.Int?

        public init(
            baseLat: Swift.Float? = nil,
            baseLng: Swift.Float? = nil,
            baseStationId: Swift.Int? = nil,
            cdmaLocalId: IoTWirelessClientTypes.CdmaLocalId? = nil,
            cdmaNmr: [IoTWirelessClientTypes.CdmaNmrObj]? = nil,
            networkId: Swift.Int? = nil,
            pilotPower: Swift.Int? = nil,
            registrationZone: Swift.Int? = nil,
            systemId: Swift.Int? = nil
        )
        {
            self.baseLat = baseLat
            self.baseLng = baseLng
            self.baseStationId = baseStationId
            self.cdmaLocalId = cdmaLocalId
            self.cdmaNmr = cdmaNmr
            self.networkId = networkId
            self.pilotPower = pilotPower
            self.registrationZone = registrationZone
            self.systemId = systemId
        }
    }

}

extension IoTWirelessClientTypes.CellTowers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdma = "Cdma"
        case gsm = "Gsm"
        case lte = "Lte"
        case tdscdma = "Tdscdma"
        case wcdma = "Wcdma"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdma = cdma {
            var cdmaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cdma)
            for cdmaobj0 in cdma {
                try cdmaContainer.encode(cdmaobj0)
            }
        }
        if let gsm = gsm {
            var gsmContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gsm)
            for gsmobj0 in gsm {
                try gsmContainer.encode(gsmobj0)
            }
        }
        if let lte = lte {
            var lteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lte)
            for lteobj0 in lte {
                try lteContainer.encode(lteobj0)
            }
        }
        if let tdscdma = tdscdma {
            var tdscdmaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tdscdma)
            for tdscdmaobj0 in tdscdma {
                try tdscdmaContainer.encode(tdscdmaobj0)
            }
        }
        if let wcdma = wcdma {
            var wcdmaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wcdma)
            for wcdmaobj0 in wcdma {
                try wcdmaContainer.encode(wcdmaobj0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gsmContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.GsmObj?].self, forKey: .gsm)
        var gsmDecoded0:[IoTWirelessClientTypes.GsmObj]? = nil
        if let gsmContainer = gsmContainer {
            gsmDecoded0 = [IoTWirelessClientTypes.GsmObj]()
            for structure0 in gsmContainer {
                if let structure0 = structure0 {
                    gsmDecoded0?.append(structure0)
                }
            }
        }
        gsm = gsmDecoded0
        let wcdmaContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WcdmaObj?].self, forKey: .wcdma)
        var wcdmaDecoded0:[IoTWirelessClientTypes.WcdmaObj]? = nil
        if let wcdmaContainer = wcdmaContainer {
            wcdmaDecoded0 = [IoTWirelessClientTypes.WcdmaObj]()
            for structure0 in wcdmaContainer {
                if let structure0 = structure0 {
                    wcdmaDecoded0?.append(structure0)
                }
            }
        }
        wcdma = wcdmaDecoded0
        let tdscdmaContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.TdscdmaObj?].self, forKey: .tdscdma)
        var tdscdmaDecoded0:[IoTWirelessClientTypes.TdscdmaObj]? = nil
        if let tdscdmaContainer = tdscdmaContainer {
            tdscdmaDecoded0 = [IoTWirelessClientTypes.TdscdmaObj]()
            for structure0 in tdscdmaContainer {
                if let structure0 = structure0 {
                    tdscdmaDecoded0?.append(structure0)
                }
            }
        }
        tdscdma = tdscdmaDecoded0
        let lteContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.LteObj?].self, forKey: .lte)
        var lteDecoded0:[IoTWirelessClientTypes.LteObj]? = nil
        if let lteContainer = lteContainer {
            lteDecoded0 = [IoTWirelessClientTypes.LteObj]()
            for structure0 in lteContainer {
                if let structure0 = structure0 {
                    lteDecoded0?.append(structure0)
                }
            }
        }
        lte = lteDecoded0
        let cdmaContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.CdmaObj?].self, forKey: .cdma)
        var cdmaDecoded0:[IoTWirelessClientTypes.CdmaObj]? = nil
        if let cdmaContainer = cdmaContainer {
            cdmaDecoded0 = [IoTWirelessClientTypes.CdmaObj]()
            for structure0 in cdmaContainer {
                if let structure0 = structure0 {
                    cdmaDecoded0?.append(structure0)
                }
            }
        }
        cdma = cdmaDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// The cell towers that were used to perform the measurements.
    public struct CellTowers: Swift.Equatable {
        /// CDMA object information.
        public var cdma: [IoTWirelessClientTypes.CdmaObj]?
        /// GSM object information.
        public var gsm: [IoTWirelessClientTypes.GsmObj]?
        /// LTE object information.
        public var lte: [IoTWirelessClientTypes.LteObj]?
        /// TD-SCDMA object information.
        public var tdscdma: [IoTWirelessClientTypes.TdscdmaObj]?
        /// WCDMA object information.
        public var wcdma: [IoTWirelessClientTypes.WcdmaObj]?

        public init(
            cdma: [IoTWirelessClientTypes.CdmaObj]? = nil,
            gsm: [IoTWirelessClientTypes.GsmObj]? = nil,
            lte: [IoTWirelessClientTypes.LteObj]? = nil,
            tdscdma: [IoTWirelessClientTypes.TdscdmaObj]? = nil,
            wcdma: [IoTWirelessClientTypes.WcdmaObj]? = nil
        )
        {
            self.cdma = cdma
            self.gsm = gsm
            self.lte = lte
            self.tdscdma = tdscdma
            self.wcdma = wcdma
        }
    }

}

extension IoTWirelessClientTypes.CertificateList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingAlg = "SigningAlg"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingAlg = self.signingAlg {
            try encodeContainer.encode(signingAlg.rawValue, forKey: .signingAlg)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingAlgDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SigningAlg.self, forKey: .signingAlg)
        signingAlg = signingAlgDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTWirelessClientTypes {
    /// List of sidewalk certificates.
    public struct CertificateList: Swift.Equatable {
        /// The certificate chain algorithm provided by sidewalk.
        /// This member is required.
        public var signingAlg: IoTWirelessClientTypes.SigningAlg?
        /// The value of the chosen sidewalk certificate.
        /// This member is required.
        public var value: Swift.String?

        public init(
            signingAlg: IoTWirelessClientTypes.SigningAlg? = nil,
            value: Swift.String? = nil
        )
        {
            self.signingAlg = signingAlg
            self.value = value
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Adding, updating, or deleting the resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Id of the resource in the conflicting operation.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource in the conflicting operation.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension IoTWirelessClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .connected,
                .disconnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "Connected"
            case .disconnected: return "Disconnected"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.ConnectionStatusEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
        case wirelessGatewayIdEventTopic = "WirelessGatewayIdEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let wirelessGatewayIdEventTopic = self.wirelessGatewayIdEventTopic {
            try encodeContainer.encode(wirelessGatewayIdEventTopic.rawValue, forKey: .wirelessGatewayIdEventTopic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let wirelessGatewayIdEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessGatewayIdEventTopic)
        wirelessGatewayIdEventTopic = wirelessGatewayIdEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Connection status event configuration object for enabling or disabling topic.
    public struct ConnectionStatusEventConfiguration: Swift.Equatable {
        /// Connection status event configuration object for enabling or disabling LoRaWAN related event topics.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations?
        /// Denotes whether the wireless gateway ID connection status event topic is enabled or disabled.
        public var wirelessGatewayIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations? = nil,
            wirelessGatewayIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.wirelessGatewayIdEventTopic = wirelessGatewayIdEventTopic
        }
    }

}

extension IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Connection status resource type event configuration object for enabling or disabling topic.
    public struct ConnectionStatusResourceTypeEventConfiguration: Swift.Equatable {
        /// Connection status resource type event configuration object for enabling or disabling LoRaWAN related event topics.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration? = nil
        )
        {
            self.loRaWAN = loRaWAN
        }
    }

}

extension CreateDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = self.expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/destinations"
    }
}

public struct CreateDestinationInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The rule name or topic rule to send messages to.
    /// This member is required.
    public var expression: Swift.String?
    /// The type of value in Expression.
    /// This member is required.
    public var expressionType: IoTWirelessClientTypes.ExpressionType?
    /// The name of the new resource.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags to attach to the new destination. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IoTWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateDestinationInputBody: Swift.Equatable {
    let name: Swift.String?
    let expressionType: IoTWirelessClientTypes.ExpressionType?
    let expression: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateDestinationOutput: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The name of the new resource.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateDestinationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
}

extension CreateDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDeviceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDeviceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/device-profiles"
    }
}

public struct CreateDeviceProfileInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The device profile information to use to create the device profile.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The Sidewalk-related information for creating the Sidewalk device profile.
    public var sidewalk: IoTWirelessClientTypes.SidewalkCreateDeviceProfile?
    /// The tags to attach to the new device profile. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile? = nil,
        name: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkCreateDeviceProfile? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.loRaWAN = loRaWAN
        self.name = name
        self.sidewalk = sidewalk
        self.tags = tags
    }
}

struct CreateDeviceProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile?
    let tags: [IoTWirelessClientTypes.Tag]?
    let clientRequestToken: Swift.String?
    let sidewalk: IoTWirelessClientTypes.SidewalkCreateDeviceProfile?
}

extension CreateDeviceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANDeviceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkCreateDeviceProfile.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension CreateDeviceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDeviceProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateDeviceProfileOutput: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new device profile.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateDeviceProfileOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateDeviceProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum CreateDeviceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case fragmentIntervalMS = "FragmentIntervalMS"
        case fragmentSizeBytes = "FragmentSizeBytes"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case redundancyPercent = "RedundancyPercent"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let firmwareUpdateImage = self.firmwareUpdateImage {
            try encodeContainer.encode(firmwareUpdateImage, forKey: .firmwareUpdateImage)
        }
        if let firmwareUpdateRole = self.firmwareUpdateRole {
            try encodeContainer.encode(firmwareUpdateRole, forKey: .firmwareUpdateRole)
        }
        if let fragmentIntervalMS = self.fragmentIntervalMS {
            try encodeContainer.encode(fragmentIntervalMS, forKey: .fragmentIntervalMS)
        }
        if let fragmentSizeBytes = self.fragmentSizeBytes {
            try encodeContainer.encode(fragmentSizeBytes, forKey: .fragmentSizeBytes)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let redundancyPercent = self.redundancyPercent {
            try encodeContainer.encode(redundancyPercent, forKey: .redundancyPercent)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/fuota-tasks"
    }
}

public struct CreateFuotaTaskInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The S3 URI points to a firmware update image that is to be used with a FUOTA task.
    /// This member is required.
    public var firmwareUpdateImage: Swift.String?
    /// The firmware update role that is to be used with a FUOTA task.
    /// This member is required.
    public var firmwareUpdateRole: Swift.String?
    /// The interval for sending fragments in milliseconds, rounded to the nearest second. This interval only determines the timing for when the Cloud sends down the fragments to yor device. There can be a delay for when your device will receive these fragments. This delay depends on the device's class and the communication delay with the cloud.
    public var fragmentIntervalMS: Swift.Int?
    /// The size of each fragment in bytes. This parameter is supported only for FUOTA tasks with multicast groups.
    public var fragmentSizeBytes: Swift.Int?
    /// The LoRaWAN information used with a FUOTA task.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask?
    /// The name of a FUOTA task.
    public var name: Swift.String?
    /// The percentage of the added fragments that are redundant. For example, if the size of the firmware image file is 100 bytes and the fragment size is 10 bytes, with RedundancyPercent set to 50(%), the final number of encoded fragments is (100 / 10) + (100 / 10 * 50%) = 15.
    public var redundancyPercent: Swift.Int?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        firmwareUpdateImage: Swift.String? = nil,
        firmwareUpdateRole: Swift.String? = nil,
        fragmentIntervalMS: Swift.Int? = nil,
        fragmentSizeBytes: Swift.Int? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask? = nil,
        name: Swift.String? = nil,
        redundancyPercent: Swift.Int? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.firmwareUpdateImage = firmwareUpdateImage
        self.firmwareUpdateRole = firmwareUpdateRole
        self.fragmentIntervalMS = fragmentIntervalMS
        self.fragmentSizeBytes = fragmentSizeBytes
        self.loRaWAN = loRaWAN
        self.name = name
        self.redundancyPercent = redundancyPercent
        self.tags = tags
    }
}

struct CreateFuotaTaskInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask?
    let firmwareUpdateImage: Swift.String?
    let firmwareUpdateRole: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
    let redundancyPercent: Swift.Int?
    let fragmentSizeBytes: Swift.Int?
    let fragmentIntervalMS: Swift.Int?
}

extension CreateFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case fragmentIntervalMS = "FragmentIntervalMS"
        case fragmentSizeBytes = "FragmentSizeBytes"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case redundancyPercent = "RedundancyPercent"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANFuotaTask.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let firmwareUpdateImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateImage)
        firmwareUpdateImage = firmwareUpdateImageDecoded
        let firmwareUpdateRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateRole)
        firmwareUpdateRole = firmwareUpdateRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let redundancyPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .redundancyPercent)
        redundancyPercent = redundancyPercentDecoded
        let fragmentSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fragmentSizeBytes)
        fragmentSizeBytes = fragmentSizeBytesDecoded
        let fragmentIntervalMSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fragmentIntervalMS)
        fragmentIntervalMS = fragmentIntervalMSDecoded
    }
}

extension CreateFuotaTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFuotaTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateFuotaTaskOutput: Swift.Equatable {
    /// The arn of a FUOTA task.
    public var arn: Swift.String?
    /// The ID of a FUOTA task.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateFuotaTaskOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateFuotaTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum CreateFuotaTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/multicast-groups"
    }
}

public struct CreateMulticastGroupInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the multicast group.
    public var description: Swift.String?
    /// The LoRaWAN information that is to be used with the multicast group.
    /// This member is required.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast?
    /// The name of the multicast group.
    public var name: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateMulticastGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast?
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension CreateMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANMulticast.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMulticastGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMulticastGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateMulticastGroupOutput: Swift.Equatable {
    /// The arn of the multicast group.
    public var arn: Swift.String?
    /// The ID of the multicast group.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateMulticastGroupOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateMulticastGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum CreateMulticastGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateNetworkAnalyzerConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case multicastGroups = "MulticastGroups"
        case name = "Name"
        case tags = "Tags"
        case traceContent = "TraceContent"
        case wirelessDevices = "WirelessDevices"
        case wirelessGateways = "WirelessGateways"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let multicastGroups = multicastGroups {
            var multicastGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .multicastGroups)
            for multicastgroupid0 in multicastGroups {
                try multicastGroupsContainer.encode(multicastgroupid0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let traceContent = self.traceContent {
            try encodeContainer.encode(traceContent, forKey: .traceContent)
        }
        if let wirelessDevices = wirelessDevices {
            var wirelessDevicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessDevices)
            for wirelessdeviceid0 in wirelessDevices {
                try wirelessDevicesContainer.encode(wirelessdeviceid0)
            }
        }
        if let wirelessGateways = wirelessGateways {
            var wirelessGatewaysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessGateways)
            for wirelessgatewayid0 in wirelessGateways {
                try wirelessGatewaysContainer.encode(wirelessgatewayid0)
            }
        }
    }
}

extension CreateNetworkAnalyzerConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/network-analyzer-configurations"
    }
}

public struct CreateNetworkAnalyzerConfigurationInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// Multicast Group resources to add to the network analyzer configruation. Provide the MulticastGroupId of the resource to add in the input array.
    public var multicastGroups: [Swift.String]?
    /// Name of the network analyzer configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?
    /// Trace content for your wireless gateway and wireless device resources.
    public var traceContent: IoTWirelessClientTypes.TraceContent?
    /// Wireless device resources to add to the network analyzer configuration. Provide the WirelessDeviceId of the resource to add in the input array.
    public var wirelessDevices: [Swift.String]?
    /// Wireless gateway resources to add to the network analyzer configuration. Provide the WirelessGatewayId of the resource to add in the input array.
    public var wirelessGateways: [Swift.String]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        multicastGroups: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil,
        traceContent: IoTWirelessClientTypes.TraceContent? = nil,
        wirelessDevices: [Swift.String]? = nil,
        wirelessGateways: [Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.multicastGroups = multicastGroups
        self.name = name
        self.tags = tags
        self.traceContent = traceContent
        self.wirelessDevices = wirelessDevices
        self.wirelessGateways = wirelessGateways
    }
}

struct CreateNetworkAnalyzerConfigurationInputBody: Swift.Equatable {
    let name: Swift.String?
    let traceContent: IoTWirelessClientTypes.TraceContent?
    let wirelessDevices: [Swift.String]?
    let wirelessGateways: [Swift.String]?
    let description: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
    let clientRequestToken: Swift.String?
    let multicastGroups: [Swift.String]?
}

extension CreateNetworkAnalyzerConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case multicastGroups = "MulticastGroups"
        case name = "Name"
        case tags = "Tags"
        case traceContent = "TraceContent"
        case wirelessDevices = "WirelessDevices"
        case wirelessGateways = "WirelessGateways"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let traceContentDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.TraceContent.self, forKey: .traceContent)
        traceContent = traceContentDecoded
        let wirelessDevicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessDevices)
        var wirelessDevicesDecoded0:[Swift.String]? = nil
        if let wirelessDevicesContainer = wirelessDevicesContainer {
            wirelessDevicesDecoded0 = [Swift.String]()
            for string0 in wirelessDevicesContainer {
                if let string0 = string0 {
                    wirelessDevicesDecoded0?.append(string0)
                }
            }
        }
        wirelessDevices = wirelessDevicesDecoded0
        let wirelessGatewaysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessGateways)
        var wirelessGatewaysDecoded0:[Swift.String]? = nil
        if let wirelessGatewaysContainer = wirelessGatewaysContainer {
            wirelessGatewaysDecoded0 = [Swift.String]()
            for string0 in wirelessGatewaysContainer {
                if let string0 = string0 {
                    wirelessGatewaysDecoded0?.append(string0)
                }
            }
        }
        wirelessGateways = wirelessGatewaysDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let multicastGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .multicastGroups)
        var multicastGroupsDecoded0:[Swift.String]? = nil
        if let multicastGroupsContainer = multicastGroupsContainer {
            multicastGroupsDecoded0 = [Swift.String]()
            for string0 in multicastGroupsContainer {
                if let string0 = string0 {
                    multicastGroupsDecoded0?.append(string0)
                }
            }
        }
        multicastGroups = multicastGroupsDecoded0
    }
}

extension CreateNetworkAnalyzerConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateNetworkAnalyzerConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateNetworkAnalyzerConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// Name of the network analyzer configuration.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateNetworkAnalyzerConfigurationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
}

extension CreateNetworkAnalyzerConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateNetworkAnalyzerConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateServiceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateServiceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/service-profiles"
    }
}

public struct CreateServiceProfileInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The service profile information to use to create the service profile.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANServiceProfile?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new service profile. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANServiceProfile? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateServiceProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANServiceProfile?
    let tags: [IoTWirelessClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateServiceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANServiceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateServiceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServiceProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateServiceProfileOutput: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new service profile.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateServiceProfileOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateServiceProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum CreateServiceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWirelessDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case positioning = "Positioning"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let positioning = self.positioning {
            try encodeContainer.encode(positioning.rawValue, forKey: .positioning)
        }
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-devices"
    }
}

public struct CreateWirelessDeviceInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The name of the destination to assign to the new wireless device.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The device configuration information to use to create the wireless device.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDevice?
    /// The name of the new resource.
    public var name: Swift.String?
    /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
    public var positioning: IoTWirelessClientTypes.PositioningConfigStatus?
    /// The device configuration information to use to create the Sidewalk device.
    public var sidewalk: IoTWirelessClientTypes.SidewalkCreateWirelessDevice?
    /// The tags to attach to the new wireless device. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?
    /// The wireless device type.
    /// This member is required.
    public var type: IoTWirelessClientTypes.WirelessDeviceType?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDevice? = nil,
        name: Swift.String? = nil,
        positioning: IoTWirelessClientTypes.PositioningConfigStatus? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkCreateWirelessDevice? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil,
        type: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.destinationName = destinationName
        self.loRaWAN = loRaWAN
        self.name = name
        self.positioning = positioning
        self.sidewalk = sidewalk
        self.tags = tags
        self.type = type
    }
}

struct CreateWirelessDeviceInputBody: Swift.Equatable {
    let type: IoTWirelessClientTypes.WirelessDeviceType?
    let name: Swift.String?
    let description: Swift.String?
    let destinationName: Swift.String?
    let clientRequestToken: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANDevice?
    let tags: [IoTWirelessClientTypes.Tag]?
    let positioning: IoTWirelessClientTypes.PositioningConfigStatus?
    let sidewalk: IoTWirelessClientTypes.SidewalkCreateWirelessDevice?
}

extension CreateWirelessDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case positioning = "Positioning"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let positioningDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositioningConfigStatus.self, forKey: .positioning)
        positioning = positioningDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkCreateWirelessDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension CreateWirelessDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWirelessDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessDeviceOutput: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new wireless device.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessDeviceOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateWirelessDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum CreateWirelessDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWirelessGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateWirelessGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-gateways"
    }
}

public struct CreateWirelessGatewayInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The gateway configuration information to use to create the wireless gateway.
    /// This member is required.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANGateway?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new wireless gateway. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANGateway? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateWirelessGatewayInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANGateway?
    let tags: [IoTWirelessClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateWirelessGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateWirelessGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWirelessGatewayOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessGatewayOutput: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new wireless gateway.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessGatewayOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateWirelessGatewayOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum CreateWirelessGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWirelessGatewayTaskDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoCreateTasks = "AutoCreateTasks"
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case tags = "Tags"
        case update = "Update"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoCreateTasks = self.autoCreateTasks {
            try encodeContainer.encode(autoCreateTasks, forKey: .autoCreateTasks)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let update = self.update {
            try encodeContainer.encode(update, forKey: .update)
        }
    }
}

extension CreateWirelessGatewayTaskDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-gateway-task-definitions"
    }
}

public struct CreateWirelessGatewayTaskDefinitionInput: Swift.Equatable {
    /// Whether to automatically create tasks using this task definition for all gateways with the specified current version. If false, the task must me created by calling CreateWirelessGatewayTask.
    /// This member is required.
    public var autoCreateTasks: Swift.Bool?
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?
    /// Information about the gateways to update.
    public var update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate?

    public init(
        autoCreateTasks: Swift.Bool? = nil,
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil,
        update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate? = nil
    )
    {
        self.autoCreateTasks = autoCreateTasks
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.tags = tags
        self.update = update
    }
}

struct CreateWirelessGatewayTaskDefinitionInputBody: Swift.Equatable {
    let autoCreateTasks: Swift.Bool?
    let name: Swift.String?
    let update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate?
    let clientRequestToken: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension CreateWirelessGatewayTaskDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoCreateTasks = "AutoCreateTasks"
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case tags = "Tags"
        case update = "Update"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoCreateTasksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoCreateTasks)
        autoCreateTasks = autoCreateTasksDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate.self, forKey: .update)
        update = updateDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWirelessGatewayTaskDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWirelessGatewayTaskDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessGatewayTaskDefinitionOutput: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the new wireless gateway task definition.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessGatewayTaskDefinitionOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension CreateWirelessGatewayTaskDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateWirelessGatewayTaskDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWirelessGatewayTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessGatewayTaskDefinitionId = self.wirelessGatewayTaskDefinitionId {
            try encodeContainer.encode(wirelessGatewayTaskDefinitionId, forKey: .wirelessGatewayTaskDefinitionId)
        }
    }
}

extension CreateWirelessGatewayTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
    }
}

public struct CreateWirelessGatewayTaskInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the WirelessGatewayTaskDefinition.
    /// This member is required.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init(
        id: Swift.String? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct CreateWirelessGatewayTaskInputBody: Swift.Equatable {
    let wirelessGatewayTaskDefinitionId: Swift.String?
}

extension CreateWirelessGatewayTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
    }
}

extension CreateWirelessGatewayTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWirelessGatewayTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.wirelessGatewayTaskDefinitionId = output.wirelessGatewayTaskDefinitionId
        } else {
            self.status = nil
            self.wirelessGatewayTaskDefinitionId = nil
        }
    }
}

public struct CreateWirelessGatewayTaskOutput: Swift.Equatable {
    /// The status of the request.
    public var status: IoTWirelessClientTypes.WirelessGatewayTaskStatus?
    /// The ID of the WirelessGatewayTaskDefinition.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init(
        status: IoTWirelessClientTypes.WirelessGatewayTaskStatus? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.status = status
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct CreateWirelessGatewayTaskOutputBody: Swift.Equatable {
    let wirelessGatewayTaskDefinitionId: Swift.String?
    let status: IoTWirelessClientTypes.WirelessGatewayTaskStatus?
}

extension CreateWirelessGatewayTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessGatewayTaskStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateWirelessGatewayTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTWirelessClientTypes.DakCertificateMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apId = "ApId"
        case certificateId = "CertificateId"
        case deviceTypeId = "DeviceTypeId"
        case factorySupport = "FactorySupport"
        case maxAllowedSignature = "MaxAllowedSignature"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apId = self.apId {
            try encodeContainer.encode(apId, forKey: .apId)
        }
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let deviceTypeId = self.deviceTypeId {
            try encodeContainer.encode(deviceTypeId, forKey: .deviceTypeId)
        }
        if let factorySupport = self.factorySupport {
            try encodeContainer.encode(factorySupport, forKey: .factorySupport)
        }
        if let maxAllowedSignature = self.maxAllowedSignature {
            try encodeContainer.encode(maxAllowedSignature, forKey: .maxAllowedSignature)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let maxAllowedSignatureDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllowedSignature)
        maxAllowedSignature = maxAllowedSignatureDecoded
        let factorySupportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .factorySupport)
        factorySupport = factorySupportDecoded
        let apIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apId)
        apId = apIdDecoded
        let deviceTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceTypeId)
        deviceTypeId = deviceTypeIdDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The device attestation key (DAK) information.
    public struct DakCertificateMetadata: Swift.Equatable {
        /// The advertised product ID (APID) that's used for pre-production and production applications.
        public var apId: Swift.String?
        /// The certificate ID for the DAK.
        /// This member is required.
        public var certificateId: Swift.String?
        /// The device type ID that's used for prototyping applications.
        public var deviceTypeId: Swift.String?
        /// Whether factory support has been enabled.
        public var factorySupport: Swift.Bool?
        /// The maximum number of signatures that the DAK can sign. A value of -1 indicates that there's no device limit.
        public var maxAllowedSignature: Swift.Int?

        public init(
            apId: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            deviceTypeId: Swift.String? = nil,
            factorySupport: Swift.Bool? = nil,
            maxAllowedSignature: Swift.Int? = nil
        )
        {
            self.apId = apId
            self.certificateId = certificateId
            self.deviceTypeId = deviceTypeId
            self.factorySupport = factorySupport
            self.maxAllowedSignature = maxAllowedSignature
        }
    }

}

extension DeleteDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

public struct DeleteDestinationInput: Swift.Equatable {
    /// The name of the resource to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDestinationInputBody: Swift.Equatable {
}

extension DeleteDestinationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDestinationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDeviceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/device-profiles/\(id.urlPercentEncoding())"
    }
}

public struct DeleteDeviceProfileInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteDeviceProfileInputBody: Swift.Equatable {
}

extension DeleteDeviceProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeviceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDeviceProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDeviceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

public struct DeleteFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteFuotaTaskInputBody: Swift.Equatable {
}

extension DeleteFuotaTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFuotaTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFuotaTaskOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFuotaTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())"
    }
}

public struct DeleteMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteMulticastGroupInputBody: Swift.Equatable {
}

extension DeleteMulticastGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMulticastGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMulticastGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMulticastGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteNetworkAnalyzerConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationName = configurationName else {
            return nil
        }
        return "/network-analyzer-configurations/\(configurationName.urlPercentEncoding())"
    }
}

public struct DeleteNetworkAnalyzerConfigurationInput: Swift.Equatable {
    /// Name of the network analyzer configuration.
    /// This member is required.
    public var configurationName: Swift.String?

    public init(
        configurationName: Swift.String? = nil
    )
    {
        self.configurationName = configurationName
    }
}

struct DeleteNetworkAnalyzerConfigurationInputBody: Swift.Equatable {
}

extension DeleteNetworkAnalyzerConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNetworkAnalyzerConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteNetworkAnalyzerConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteNetworkAnalyzerConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteQueuedMessagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let wirelessDeviceType = wirelessDeviceType {
                let wirelessDeviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "WirelessDeviceType".urlPercentEncoding(), value: Swift.String(wirelessDeviceType.rawValue).urlPercentEncoding())
                items.append(wirelessDeviceTypeQueryItem)
            }
            guard let messageId = messageId else {
                let message = "Creating a URL Query Item failed. messageId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let messageIdQueryItem = ClientRuntime.URLQueryItem(name: "messageId".urlPercentEncoding(), value: Swift.String(messageId).urlPercentEncoding())
            items.append(messageIdQueryItem)
            return items
        }
    }
}

extension DeleteQueuedMessagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/data"
    }
}

public struct DeleteQueuedMessagesInput: Swift.Equatable {
    /// The ID of a given wireless device for which downlink messages will be deleted.
    /// This member is required.
    public var id: Swift.String?
    /// If message ID is "*", it cleares the entire downlink queue for a given device, specified by the wireless device ID. Otherwise, the downlink message with the specified message ID will be deleted.
    /// This member is required.
    public var messageId: Swift.String?
    /// The wireless device type, which can be either Sidewalk or LoRaWAN.
    public var wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType?

    public init(
        id: Swift.String? = nil,
        messageId: Swift.String? = nil,
        wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.id = id
        self.messageId = messageId
        self.wirelessDeviceType = wirelessDeviceType
    }
}

struct DeleteQueuedMessagesInputBody: Swift.Equatable {
}

extension DeleteQueuedMessagesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteQueuedMessagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteQueuedMessagesOutput: Swift.Equatable {

    public init() { }
}

enum DeleteQueuedMessagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServiceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/service-profiles/\(id.urlPercentEncoding())"
    }
}

public struct DeleteServiceProfileInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteServiceProfileInputBody: Swift.Equatable {
}

extension DeleteServiceProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteServiceProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteServiceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWirelessDeviceImportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless_device_import_task/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWirelessDeviceImportTaskInput: Swift.Equatable {
    /// The unique identifier of the import task to be deleted.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessDeviceImportTaskInputBody: Swift.Equatable {
}

extension DeleteWirelessDeviceImportTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessDeviceImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWirelessDeviceImportTaskOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWirelessDeviceImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWirelessDeviceInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessDeviceInputBody: Swift.Equatable {
}

extension DeleteWirelessDeviceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWirelessDeviceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWirelessDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWirelessGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWirelessGatewayInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayInputBody: Swift.Equatable {
}

extension DeleteWirelessGatewayInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWirelessGatewayOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWirelessGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWirelessGatewayTaskDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateway-task-definitions/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWirelessGatewayTaskDefinitionInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayTaskDefinitionInputBody: Swift.Equatable {
}

extension DeleteWirelessGatewayTaskDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayTaskDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWirelessGatewayTaskDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWirelessGatewayTaskDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWirelessGatewayTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
    }
}

public struct DeleteWirelessGatewayTaskInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayTaskInputBody: Swift.Equatable {
}

extension DeleteWirelessGatewayTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWirelessGatewayTaskOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWirelessGatewayTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterWirelessDeviceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let wirelessDeviceType = wirelessDeviceType {
                let wirelessDeviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "WirelessDeviceType".urlPercentEncoding(), value: Swift.String(wirelessDeviceType.rawValue).urlPercentEncoding())
                items.append(wirelessDeviceTypeQueryItem)
            }
            return items
        }
    }
}

extension DeregisterWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/wireless-devices/\(identifier.urlPercentEncoding())/deregister"
    }
}

public struct DeregisterWirelessDeviceInput: Swift.Equatable {
    /// The identifier of the wireless device to deregister from AWS IoT Wireless.
    /// This member is required.
    public var identifier: Swift.String?
    /// The type of wireless device to deregister from AWS IoT Wireless, which can be LoRaWAN or Sidewalk.
    public var wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType?

    public init(
        identifier: Swift.String? = nil,
        wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.identifier = identifier
        self.wirelessDeviceType = wirelessDeviceType
    }
}

struct DeregisterWirelessDeviceInputBody: Swift.Equatable {
}

extension DeregisterWirelessDeviceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterWirelessDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterWirelessDeviceOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterWirelessDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTWirelessClientTypes.Destinations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = self.expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Describes a destination.
    public struct Destinations: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The description of the resource.
        public var description: Swift.String?
        /// The rule name or topic rule to send messages to.
        public var expression: Swift.String?
        /// The type of value in Expression.
        public var expressionType: IoTWirelessClientTypes.ExpressionType?
        /// The name of the resource.
        public var name: Swift.String?
        /// The ARN of the IAM Role that authorizes the destination.
        public var roleArn: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            expression: Swift.String? = nil,
            expressionType: IoTWirelessClientTypes.ExpressionType? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.expression = expression
            self.expressionType = expressionType
            self.name = name
            self.roleArn = roleArn
        }
    }

}

extension IoTWirelessClientTypes.DeviceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Describes a device profile.
    public struct DeviceProfile: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the device profile.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension IoTWirelessClientTypes {
    public enum DeviceProfileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lorawan
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceProfileType] {
            return [
                .lorawan,
                .sidewalk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lorawan: return "LoRaWAN"
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceProfileType(rawValue: rawValue) ?? DeviceProfileType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
        case wirelessDeviceIdEventTopic = "WirelessDeviceIdEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let wirelessDeviceIdEventTopic = self.wirelessDeviceIdEventTopic {
            try encodeContainer.encode(wirelessDeviceIdEventTopic.rawValue, forKey: .wirelessDeviceIdEventTopic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkEventNotificationConfigurations.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let wirelessDeviceIdEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessDeviceIdEventTopic)
        wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Device registration state event configuration object for enabling and disabling relevant topics.
    public struct DeviceRegistrationStateEventConfiguration: Swift.Equatable {
        /// Device registration state event configuration object for enabling or disabling Sidewalk related event topics.
        public var sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations?
        /// Denotes whether the wireless device ID device registration state event topic is enabled or disabled.
        public var wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations? = nil,
            wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.sidewalk = sidewalk
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }
    }

}

extension IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Device registration state resource type event configuration object for enabling or disabling topic.
    public struct DeviceRegistrationStateResourceTypeEventConfiguration: Swift.Equatable {
        /// Device registration resource type state event configuration object for enabling or disabling Sidewalk related event topics.
        public var sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration?

        public init(
            sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration? = nil
        )
        {
            self.sidewalk = sidewalk
        }
    }

}

extension IoTWirelessClientTypes {
    /// Device state defines the device status of sidewalk device.
    public enum DeviceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case provisioned
        case registerednotseen
        case registeredreachable
        case registeredunreachable
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceState] {
            return [
                .provisioned,
                .registerednotseen,
                .registeredreachable,
                .registeredunreachable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .provisioned: return "Provisioned"
            case .registerednotseen: return "RegisteredNotSeen"
            case .registeredreachable: return "RegisteredReachable"
            case .registeredunreachable: return "RegisteredUnreachable"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceState(rawValue: rawValue) ?? DeviceState.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateAwsAccountFromPartnerAccountInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let partnerType = partnerType else {
                let message = "Creating a URL Query Item failed. partnerType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            items.append(partnerTypeQueryItem)
            return items
        }
    }
}

extension DisassociateAwsAccountFromPartnerAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let partnerAccountId = partnerAccountId else {
            return nil
        }
        return "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
    }
}

public struct DisassociateAwsAccountFromPartnerAccountInput: Swift.Equatable {
    /// The partner account ID to disassociate from the AWS account.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IoTWirelessClientTypes.PartnerType?

    public init(
        partnerAccountId: Swift.String? = nil,
        partnerType: IoTWirelessClientTypes.PartnerType? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
    }
}

struct DisassociateAwsAccountFromPartnerAccountInputBody: Swift.Equatable {
}

extension DisassociateAwsAccountFromPartnerAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateAwsAccountFromPartnerAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateAwsAccountFromPartnerAccountOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateAwsAccountFromPartnerAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateMulticastGroupFromFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        guard let multicastGroupId = multicastGroupId else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/multicast-groups/\(multicastGroupId.urlPercentEncoding())"
    }
}

public struct DisassociateMulticastGroupFromFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the multicast group.
    /// This member is required.
    public var multicastGroupId: Swift.String?

    public init(
        id: Swift.String? = nil,
        multicastGroupId: Swift.String? = nil
    )
    {
        self.id = id
        self.multicastGroupId = multicastGroupId
    }
}

struct DisassociateMulticastGroupFromFuotaTaskInputBody: Swift.Equatable {
}

extension DisassociateMulticastGroupFromFuotaTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateMulticastGroupFromFuotaTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateMulticastGroupFromFuotaTaskOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateMulticastGroupFromFuotaTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateWirelessDeviceFromFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        guard let wirelessDeviceId = wirelessDeviceId else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/wireless-devices/\(wirelessDeviceId.urlPercentEncoding())"
    }
}

public struct DisassociateWirelessDeviceFromFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init(
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct DisassociateWirelessDeviceFromFuotaTaskInputBody: Swift.Equatable {
}

extension DisassociateWirelessDeviceFromFuotaTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessDeviceFromFuotaTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateWirelessDeviceFromFuotaTaskOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateWirelessDeviceFromFuotaTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateWirelessDeviceFromMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        guard let wirelessDeviceId = wirelessDeviceId else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/wireless-devices/\(wirelessDeviceId.urlPercentEncoding())"
    }
}

public struct DisassociateWirelessDeviceFromMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init(
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct DisassociateWirelessDeviceFromMulticastGroupInputBody: Swift.Equatable {
}

extension DisassociateWirelessDeviceFromMulticastGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessDeviceFromMulticastGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateWirelessDeviceFromMulticastGroupOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateWirelessDeviceFromMulticastGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateWirelessDeviceFromThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/thing"
    }
}

public struct DisassociateWirelessDeviceFromThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessDeviceFromThingInputBody: Swift.Equatable {
}

extension DisassociateWirelessDeviceFromThingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessDeviceFromThingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateWirelessDeviceFromThingOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateWirelessDeviceFromThingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateWirelessGatewayFromCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
    }
}

public struct DisassociateWirelessGatewayFromCertificateInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessGatewayFromCertificateInputBody: Swift.Equatable {
}

extension DisassociateWirelessGatewayFromCertificateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessGatewayFromCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateWirelessGatewayFromCertificateOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateWirelessGatewayFromCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateWirelessGatewayFromThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/thing"
    }
}

public struct DisassociateWirelessGatewayFromThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessGatewayFromThingInputBody: Swift.Equatable {
}

extension DisassociateWirelessGatewayFromThingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessGatewayFromThingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateWirelessGatewayFromThingOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateWirelessGatewayFromThingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTWirelessClientTypes {
    /// DlClass for LoRaWAM, valid values are ClassB and ClassC.
    public enum DlClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case classb
        case classc
        case sdkUnknown(Swift.String)

        public static var allCases: [DlClass] {
            return [
                .classb,
                .classc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .classb: return "ClassB"
            case .classc: return "ClassC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DlClass(rawValue: rawValue) ?? DlClass.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum DownlinkMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concurrent
        case sequential
        case usingUplinkGateway
        case sdkUnknown(Swift.String)

        public static var allCases: [DownlinkMode] {
            return [
                .concurrent,
                .sequential,
                .usingUplinkGateway,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concurrent: return "CONCURRENT"
            case .sequential: return "SEQUENTIAL"
            case .usingUplinkGateway: return "USING_UPLINK_GATEWAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DownlinkMode(rawValue: rawValue) ?? DownlinkMode.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.DownlinkQueueMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
        case messageId = "MessageId"
        case receivedAt = "ReceivedAt"
        case transmitMode = "TransmitMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let receivedAt = self.receivedAt {
            try encodeContainer.encode(receivedAt, forKey: .receivedAt)
        }
        if let transmitMode = self.transmitMode {
            try encodeContainer.encode(transmitMode, forKey: .transmitMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let transmitModeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .transmitMode)
        transmitMode = transmitModeDecoded
        let receivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .receivedAt)
        receivedAt = receivedAtDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANSendDataToDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The message in the downlink queue.
    public struct DownlinkQueueMessage: Swift.Equatable {
        /// LoRaWAN router info.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANSendDataToDevice?
        /// The message ID assigned by IoT Wireless to each downlink message, which helps identify the message.
        public var messageId: Swift.String?
        /// The time at which Iot Wireless received the downlink message.
        public var receivedAt: Swift.String?
        /// The transmit mode to use for sending data to the wireless device. This can be 0 for UM (unacknowledge mode) or 1 for AM (acknowledge mode).
        public var transmitMode: Swift.Int?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANSendDataToDevice? = nil,
            messageId: Swift.String? = nil,
            receivedAt: Swift.String? = nil,
            transmitMode: Swift.Int? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.messageId = messageId
            self.receivedAt = receivedAt
            self.transmitMode = transmitMode
        }
    }

}

extension IoTWirelessClientTypes {
    /// Sidewalk device status notification.
    public enum Event: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ack
        case discovered
        case lost
        case nack
        case passthrough
        case sdkUnknown(Swift.String)

        public static var allCases: [Event] {
            return [
                .ack,
                .discovered,
                .lost,
                .nack,
                .passthrough,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ack: return "ack"
            case .discovered: return "discovered"
            case .lost: return "lost"
            case .nack: return "nack"
            case .passthrough: return "passthrough"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Event(rawValue: rawValue) ?? Event.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.EventConfigurationItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case identifier = "Identifier"
        case identifierType = "IdentifierType"
        case partnerType = "PartnerType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = self.events {
            try encodeContainer.encode(events, forKey: .events)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let identifierType = self.identifierType {
            try encodeContainer.encode(identifierType.rawValue, forKey: .identifierType)
        }
        if let partnerType = self.partnerType {
            try encodeContainer.encode(partnerType.rawValue, forKey: .partnerType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let identifierTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.IdentifierType.self, forKey: .identifierType)
        identifierType = identifierTypeDecoded
        let partnerTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationPartnerType.self, forKey: .partnerType)
        partnerType = partnerTypeDecoded
        let eventsDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationItemConfigurations.self, forKey: .events)
        events = eventsDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Event configuration object for a single resource.
    public struct EventConfigurationItem: Swift.Equatable {
        /// Object of all event configurations and the status of the event topics.
        public var events: IoTWirelessClientTypes.EventNotificationItemConfigurations?
        /// Resource identifier opted in for event messaging.
        public var identifier: Swift.String?
        /// Identifier type of the particular resource identifier for event configuration.
        public var identifierType: IoTWirelessClientTypes.IdentifierType?
        /// Partner type of the resource if the identifier type is PartnerAccountId.
        public var partnerType: IoTWirelessClientTypes.EventNotificationPartnerType?

        public init(
            events: IoTWirelessClientTypes.EventNotificationItemConfigurations? = nil,
            identifier: Swift.String? = nil,
            identifierType: IoTWirelessClientTypes.IdentifierType? = nil,
            partnerType: IoTWirelessClientTypes.EventNotificationPartnerType? = nil
        )
        {
            self.events = events
            self.identifier = identifier
            self.identifierType = identifierType
            self.partnerType = partnerType
        }
    }

}

extension IoTWirelessClientTypes.EventNotificationItemConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case deviceRegistrationState = "DeviceRegistrationState"
        case join = "Join"
        case messageDeliveryStatus = "MessageDeliveryStatus"
        case proximity = "Proximity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionStatus = self.connectionStatus {
            try encodeContainer.encode(connectionStatus, forKey: .connectionStatus)
        }
        if let deviceRegistrationState = self.deviceRegistrationState {
            try encodeContainer.encode(deviceRegistrationState, forKey: .deviceRegistrationState)
        }
        if let join = self.join {
            try encodeContainer.encode(join, forKey: .join)
        }
        if let messageDeliveryStatus = self.messageDeliveryStatus {
            try encodeContainer.encode(messageDeliveryStatus, forKey: .messageDeliveryStatus)
        }
        if let proximity = self.proximity {
            try encodeContainer.encode(proximity, forKey: .proximity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceRegistrationStateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration.self, forKey: .deviceRegistrationState)
        deviceRegistrationState = deviceRegistrationStateDecoded
        let proximityDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ProximityEventConfiguration.self, forKey: .proximity)
        proximity = proximityDecoded
        let joinDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.JoinEventConfiguration.self, forKey: .join)
        join = joinDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ConnectionStatusEventConfiguration.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let messageDeliveryStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration.self, forKey: .messageDeliveryStatus)
        messageDeliveryStatus = messageDeliveryStatusDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Object of all event configurations and the status of the event topics.
    public struct EventNotificationItemConfigurations: Swift.Equatable {
        /// Connection status event configuration for an event configuration item.
        public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration?
        /// Device registration state event configuration for an event configuration item.
        public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
        /// Join event configuration for an event configuration item.
        public var join: IoTWirelessClientTypes.JoinEventConfiguration?
        /// Message delivery status event configuration for an event configuration item.
        public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration?
        /// Proximity event configuration for an event configuration item.
        public var proximity: IoTWirelessClientTypes.ProximityEventConfiguration?

        public init(
            connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration? = nil,
            deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration? = nil,
            join: IoTWirelessClientTypes.JoinEventConfiguration? = nil,
            messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration? = nil,
            proximity: IoTWirelessClientTypes.ProximityEventConfiguration? = nil
        )
        {
            self.connectionStatus = connectionStatus
            self.deviceRegistrationState = deviceRegistrationState
            self.join = join
            self.messageDeliveryStatus = messageDeliveryStatus
            self.proximity = proximity
        }
    }

}

extension IoTWirelessClientTypes {
    public enum EventNotificationPartnerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [EventNotificationPartnerType] {
            return [
                .sidewalk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventNotificationPartnerType(rawValue: rawValue) ?? EventNotificationPartnerType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum EventNotificationResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sidewalkaccount
        case wirelessdevice
        case wirelessgateway
        case sdkUnknown(Swift.String)

        public static var allCases: [EventNotificationResourceType] {
            return [
                .sidewalkaccount,
                .wirelessdevice,
                .wirelessgateway,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sidewalkaccount: return "SidewalkAccount"
            case .wirelessdevice: return "WirelessDevice"
            case .wirelessgateway: return "WirelessGateway"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventNotificationResourceType(rawValue: rawValue) ?? EventNotificationResourceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum EventNotificationTopicStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EventNotificationTopicStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventNotificationTopicStatus(rawValue: rawValue) ?? EventNotificationTopicStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum ExpressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mqtttopic
        case rulename
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpressionType] {
            return [
                .mqtttopic,
                .rulename,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mqtttopic: return "MqttTopic"
            case .rulename: return "RuleName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExpressionType(rawValue: rawValue) ?? ExpressionType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.FPorts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case clockSync = "ClockSync"
        case fuota = "Fuota"
        case multicast = "Multicast"
        case positioning = "Positioning"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for applicationconfig0 in applications {
                try applicationsContainer.encode(applicationconfig0)
            }
        }
        if let clockSync = self.clockSync {
            try encodeContainer.encode(clockSync, forKey: .clockSync)
        }
        if let fuota = self.fuota {
            try encodeContainer.encode(fuota, forKey: .fuota)
        }
        if let multicast = self.multicast {
            try encodeContainer.encode(multicast, forKey: .multicast)
        }
        if let positioning = self.positioning {
            try encodeContainer.encode(positioning, forKey: .positioning)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fuotaDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fuota)
        fuota = fuotaDecoded
        let multicastDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .multicast)
        multicast = multicastDecoded
        let clockSyncDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clockSync)
        clockSync = clockSyncDecoded
        let positioningDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.Positioning.self, forKey: .positioning)
        positioning = positioningDecoded
        let applicationsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.ApplicationConfig?].self, forKey: .applications)
        var applicationsDecoded0:[IoTWirelessClientTypes.ApplicationConfig]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [IoTWirelessClientTypes.ApplicationConfig]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// List of FPort assigned for different LoRaWAN application packages to use
    public struct FPorts: Swift.Equatable {
        /// Optional LoRaWAN application information, which can be used for geolocation.
        public var applications: [IoTWirelessClientTypes.ApplicationConfig]?
        /// The Fport value.
        public var clockSync: Swift.Int?
        /// The Fport value.
        public var fuota: Swift.Int?
        /// The Fport value.
        public var multicast: Swift.Int?
        /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
        public var positioning: IoTWirelessClientTypes.Positioning?

        public init(
            applications: [IoTWirelessClientTypes.ApplicationConfig]? = nil,
            clockSync: Swift.Int? = nil,
            fuota: Swift.Int? = nil,
            multicast: Swift.Int? = nil,
            positioning: IoTWirelessClientTypes.Positioning? = nil
        )
        {
            self.applications = applications
            self.clockSync = clockSync
            self.fuota = fuota
            self.multicast = multicast
            self.positioning = positioning
        }
    }

}

extension IoTWirelessClientTypes {
    /// The status of a wireless device in a FUOTA task.
    public enum FuotaDeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fragalgoUnsupported
        case fragindexUnsupported
        case initial
        case micerror
        case memoryerror
        case missingfrag
        case notEnoughMemory
        case packageNotSupported
        case sessioncntReplay
        case successful
        case wrongDescriptor
        case sdkUnknown(Swift.String)

        public static var allCases: [FuotaDeviceStatus] {
            return [
                .fragalgoUnsupported,
                .fragindexUnsupported,
                .initial,
                .micerror,
                .memoryerror,
                .missingfrag,
                .notEnoughMemory,
                .packageNotSupported,
                .sessioncntReplay,
                .successful,
                .wrongDescriptor,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fragalgoUnsupported: return "FragAlgo_unsupported"
            case .fragindexUnsupported: return "FragIndex_unsupported"
            case .initial: return "Initial"
            case .micerror: return "MICError"
            case .memoryerror: return "MemoryError"
            case .missingfrag: return "MissingFrag"
            case .notEnoughMemory: return "Not_enough_memory"
            case .packageNotSupported: return "Package_Not_Supported"
            case .sessioncntReplay: return "SessionCnt_replay"
            case .successful: return "Successful"
            case .wrongDescriptor: return "Wrong_descriptor"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FuotaDeviceStatus(rawValue: rawValue) ?? FuotaDeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.FuotaTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IoTWirelessClientTypes {
    /// A FUOTA task.
    public struct FuotaTask: Swift.Equatable {
        /// The arn of a FUOTA task.
        public var arn: Swift.String?
        /// The ID of a FUOTA task.
        public var id: Swift.String?
        /// The name of a FUOTA task.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension IoTWirelessClientTypes {
    /// The status of a FUOTA task.
    public enum FuotaTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteWaiting
        case fuotadone
        case fuotasessionWaiting
        case inFuotasession
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [FuotaTaskStatus] {
            return [
                .deleteWaiting,
                .fuotadone,
                .fuotasessionWaiting,
                .inFuotasession,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteWaiting: return "Delete_Waiting"
            case .fuotadone: return "FuotaDone"
            case .fuotasessionWaiting: return "FuotaSession_Waiting"
            case .inFuotasession: return "In_FuotaSession"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FuotaTaskStatus(rawValue: rawValue) ?? FuotaTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.GatewayListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downlinkFrequency = "DownlinkFrequency"
        case gatewayId = "GatewayId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downlinkFrequency = self.downlinkFrequency {
            try encodeContainer.encode(downlinkFrequency, forKey: .downlinkFrequency)
        }
        if let gatewayId = self.gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let downlinkFrequencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkFrequency)
        downlinkFrequency = downlinkFrequencyDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Gateway list item object that specifies the frequency and list of gateways for which the downlink message should be sent.
    public struct GatewayListItem: Swift.Equatable {
        /// The frequency to use for the gateways when sending a downlink message to the wireless device.
        /// This member is required.
        public var downlinkFrequency: Swift.Int?
        /// The ID of the wireless gateways that you want to add to the list of gateways when sending downlink messages.
        /// This member is required.
        public var gatewayId: Swift.String?

        public init(
            downlinkFrequency: Swift.Int? = nil,
            gatewayId: Swift.String? = nil
        )
        {
            self.downlinkFrequency = downlinkFrequency
            self.gatewayId = gatewayId
        }
    }

}

extension GetDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

public struct GetDestinationInput: Swift.Equatable {
    /// The name of the resource to get.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetDestinationInputBody: Swift.Equatable {
}

extension GetDestinationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.expression = output.expression
            self.expressionType = output.expressionType
            self.name = output.name
            self.roleArn = output.roleArn
        } else {
            self.arn = nil
            self.description = nil
            self.expression = nil
            self.expressionType = nil
            self.name = nil
            self.roleArn = nil
        }
    }
}

public struct GetDestinationOutput: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The rule name or topic rule to send messages to.
    public var expression: Swift.String?
    /// The type of value in Expression.
    public var expressionType: IoTWirelessClientTypes.ExpressionType?
    /// The name of the resource.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    public var roleArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IoTWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
    }
}

struct GetDestinationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let expression: Swift.String?
    let expressionType: IoTWirelessClientTypes.ExpressionType?
    let description: Swift.String?
    let roleArn: Swift.String?
}

extension GetDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum GetDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeviceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/device-profiles/\(id.urlPercentEncoding())"
    }
}

public struct GetDeviceProfileInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDeviceProfileInputBody: Swift.Equatable {
}

extension GetDeviceProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeviceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeviceProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.sidewalk = output.sidewalk
        } else {
            self.arn = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.sidewalk = nil
        }
    }
}

public struct GetDeviceProfileOutput: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the device profile.
    public var id: Swift.String?
    /// Information about the device profile.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile?
    /// The name of the resource.
    public var name: Swift.String?
    /// Information about the Sidewalk parameters in the device profile.
    public var sidewalk: IoTWirelessClientTypes.SidewalkGetDeviceProfile?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile? = nil,
        name: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkGetDeviceProfile? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.sidewalk = sidewalk
    }
}

struct GetDeviceProfileOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let id: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile?
    let sidewalk: IoTWirelessClientTypes.SidewalkGetDeviceProfile?
}

extension GetDeviceProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case sidewalk = "Sidewalk"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANDeviceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkGetDeviceProfile.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

enum GetDeviceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEventConfigurationByResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/event-configurations-resource-types"
    }
}

public struct GetEventConfigurationByResourceTypesInput: Swift.Equatable {

    public init() { }
}

struct GetEventConfigurationByResourceTypesInputBody: Swift.Equatable {
}

extension GetEventConfigurationByResourceTypesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEventConfigurationByResourceTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEventConfigurationByResourceTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectionStatus = output.connectionStatus
            self.deviceRegistrationState = output.deviceRegistrationState
            self.join = output.join
            self.messageDeliveryStatus = output.messageDeliveryStatus
            self.proximity = output.proximity
        } else {
            self.connectionStatus = nil
            self.deviceRegistrationState = nil
            self.join = nil
            self.messageDeliveryStatus = nil
            self.proximity = nil
        }
    }
}

public struct GetEventConfigurationByResourceTypesOutput: Swift.Equatable {
    /// Resource type event configuration for the connection status event.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration?
    /// Resource type event configuration for the device registration state event.
    public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration?
    /// Resource type event configuration for the join event.
    public var join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration?
    /// Resource type event configuration object for the message delivery status event.
    public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration?
    /// Resource type event configuration for the proximity event.
    public var proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration?

    public init(
        connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration? = nil,
        deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration? = nil,
        join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration? = nil,
        messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration? = nil,
        proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.deviceRegistrationState = deviceRegistrationState
        self.join = join
        self.messageDeliveryStatus = messageDeliveryStatus
        self.proximity = proximity
    }
}

struct GetEventConfigurationByResourceTypesOutputBody: Swift.Equatable {
    let deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration?
    let proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration?
    let join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration?
    let connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration?
    let messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration?
}

extension GetEventConfigurationByResourceTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case deviceRegistrationState = "DeviceRegistrationState"
        case join = "Join"
        case messageDeliveryStatus = "MessageDeliveryStatus"
        case proximity = "Proximity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceRegistrationStateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration.self, forKey: .deviceRegistrationState)
        deviceRegistrationState = deviceRegistrationStateDecoded
        let proximityDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration.self, forKey: .proximity)
        proximity = proximityDecoded
        let joinDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.JoinResourceTypeEventConfiguration.self, forKey: .join)
        join = joinDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let messageDeliveryStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration.self, forKey: .messageDeliveryStatus)
        messageDeliveryStatus = messageDeliveryStatusDecoded
    }
}

enum GetEventConfigurationByResourceTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

public struct GetFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFuotaTaskInputBody: Swift.Equatable {
}

extension GetFuotaTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFuotaTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFuotaTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.description = output.description
            self.firmwareUpdateImage = output.firmwareUpdateImage
            self.firmwareUpdateRole = output.firmwareUpdateRole
            self.fragmentIntervalMS = output.fragmentIntervalMS
            self.fragmentSizeBytes = output.fragmentSizeBytes
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.redundancyPercent = output.redundancyPercent
            self.status = output.status
        } else {
            self.arn = nil
            self.createdAt = nil
            self.description = nil
            self.firmwareUpdateImage = nil
            self.firmwareUpdateRole = nil
            self.fragmentIntervalMS = nil
            self.fragmentSizeBytes = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.redundancyPercent = nil
            self.status = nil
        }
    }
}

public struct GetFuotaTaskOutput: Swift.Equatable {
    /// The arn of a FUOTA task.
    public var arn: Swift.String?
    /// Created at timestamp for the resource.
    public var createdAt: ClientRuntime.Date?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The S3 URI points to a firmware update image that is to be used with a FUOTA task.
    public var firmwareUpdateImage: Swift.String?
    /// The firmware update role that is to be used with a FUOTA task.
    public var firmwareUpdateRole: Swift.String?
    /// The interval for sending fragments in milliseconds, rounded to the nearest second. This interval only determines the timing for when the Cloud sends down the fragments to yor device. There can be a delay for when your device will receive these fragments. This delay depends on the device's class and the communication delay with the cloud.
    public var fragmentIntervalMS: Swift.Int?
    /// The size of each fragment in bytes. This parameter is supported only for FUOTA tasks with multicast groups.
    public var fragmentSizeBytes: Swift.Int?
    /// The ID of a FUOTA task.
    public var id: Swift.String?
    /// The LoRaWAN information returned from getting a FUOTA task.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo?
    /// The name of a FUOTA task.
    public var name: Swift.String?
    /// The percentage of the added fragments that are redundant. For example, if the size of the firmware image file is 100 bytes and the fragment size is 10 bytes, with RedundancyPercent set to 50(%), the final number of encoded fragments is (100 / 10) + (100 / 10 * 50%) = 15.
    public var redundancyPercent: Swift.Int?
    /// The status of a FUOTA task.
    public var status: IoTWirelessClientTypes.FuotaTaskStatus?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        firmwareUpdateImage: Swift.String? = nil,
        firmwareUpdateRole: Swift.String? = nil,
        fragmentIntervalMS: Swift.Int? = nil,
        fragmentSizeBytes: Swift.Int? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo? = nil,
        name: Swift.String? = nil,
        redundancyPercent: Swift.Int? = nil,
        status: IoTWirelessClientTypes.FuotaTaskStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.firmwareUpdateImage = firmwareUpdateImage
        self.firmwareUpdateRole = firmwareUpdateRole
        self.fragmentIntervalMS = fragmentIntervalMS
        self.fragmentSizeBytes = fragmentSizeBytes
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.redundancyPercent = redundancyPercent
        self.status = status
    }
}

struct GetFuotaTaskOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let status: IoTWirelessClientTypes.FuotaTaskStatus?
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo?
    let firmwareUpdateImage: Swift.String?
    let firmwareUpdateRole: Swift.String?
    let createdAt: ClientRuntime.Date?
    let redundancyPercent: Swift.Int?
    let fragmentSizeBytes: Swift.Int?
    let fragmentIntervalMS: Swift.Int?
}

extension GetFuotaTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case fragmentIntervalMS = "FragmentIntervalMS"
        case fragmentSizeBytes = "FragmentSizeBytes"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case redundancyPercent = "RedundancyPercent"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.FuotaTaskStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let firmwareUpdateImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateImage)
        firmwareUpdateImage = firmwareUpdateImageDecoded
        let firmwareUpdateRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateRole)
        firmwareUpdateRole = firmwareUpdateRoleDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let redundancyPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .redundancyPercent)
        redundancyPercent = redundancyPercentDecoded
        let fragmentSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fragmentSizeBytes)
        fragmentSizeBytes = fragmentSizeBytesDecoded
        let fragmentIntervalMSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fragmentIntervalMS)
        fragmentIntervalMS = fragmentIntervalMSDecoded
    }
}

enum GetFuotaTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLogLevelsByResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/log-levels"
    }
}

public struct GetLogLevelsByResourceTypesInput: Swift.Equatable {

    public init() { }
}

struct GetLogLevelsByResourceTypesInputBody: Swift.Equatable {
}

extension GetLogLevelsByResourceTypesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLogLevelsByResourceTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLogLevelsByResourceTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.defaultLogLevel = output.defaultLogLevel
            self.wirelessDeviceLogOptions = output.wirelessDeviceLogOptions
            self.wirelessGatewayLogOptions = output.wirelessGatewayLogOptions
        } else {
            self.defaultLogLevel = nil
            self.wirelessDeviceLogOptions = nil
            self.wirelessGatewayLogOptions = nil
        }
    }
}

public struct GetLogLevelsByResourceTypesOutput: Swift.Equatable {
    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    public var defaultLogLevel: IoTWirelessClientTypes.LogLevel?
    /// The list of wireless device log options.
    public var wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]?
    /// The list of wireless gateway log options.
    public var wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]?

    public init(
        defaultLogLevel: IoTWirelessClientTypes.LogLevel? = nil,
        wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]? = nil,
        wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.wirelessDeviceLogOptions = wirelessDeviceLogOptions
        self.wirelessGatewayLogOptions = wirelessGatewayLogOptions
    }
}

struct GetLogLevelsByResourceTypesOutputBody: Swift.Equatable {
    let defaultLogLevel: IoTWirelessClientTypes.LogLevel?
    let wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]?
    let wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]?
}

extension GetLogLevelsByResourceTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultLogLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .defaultLogLevel)
        defaultLogLevel = defaultLogLevelDecoded
        let wirelessGatewayLogOptionsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessGatewayLogOption?].self, forKey: .wirelessGatewayLogOptions)
        var wirelessGatewayLogOptionsDecoded0:[IoTWirelessClientTypes.WirelessGatewayLogOption]? = nil
        if let wirelessGatewayLogOptionsContainer = wirelessGatewayLogOptionsContainer {
            wirelessGatewayLogOptionsDecoded0 = [IoTWirelessClientTypes.WirelessGatewayLogOption]()
            for structure0 in wirelessGatewayLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessGatewayLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayLogOptions = wirelessGatewayLogOptionsDecoded0
        let wirelessDeviceLogOptionsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessDeviceLogOption?].self, forKey: .wirelessDeviceLogOptions)
        var wirelessDeviceLogOptionsDecoded0:[IoTWirelessClientTypes.WirelessDeviceLogOption]? = nil
        if let wirelessDeviceLogOptionsContainer = wirelessDeviceLogOptionsContainer {
            wirelessDeviceLogOptionsDecoded0 = [IoTWirelessClientTypes.WirelessDeviceLogOption]()
            for structure0 in wirelessDeviceLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessDeviceLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceLogOptions = wirelessDeviceLogOptionsDecoded0
    }
}

enum GetLogLevelsByResourceTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())"
    }
}

public struct GetMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetMulticastGroupInputBody: Swift.Equatable {
}

extension GetMulticastGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMulticastGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMulticastGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.description = output.description
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.createdAt = nil
            self.description = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct GetMulticastGroupOutput: Swift.Equatable {
    /// The arn of the multicast group.
    public var arn: Swift.String?
    /// Created at timestamp for the resource.
    public var createdAt: ClientRuntime.Date?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The ID of the multicast group.
    public var id: Swift.String?
    /// The LoRaWAN information that is to be returned from getting multicast group information.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastGet?
    /// The name of the multicast group.
    public var name: Swift.String?
    /// The status of the multicast group.
    public var status: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastGet? = nil,
        name: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.status = status
    }
}

struct GetMulticastGroupOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let status: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastGet?
    let createdAt: ClientRuntime.Date?
}

extension GetMulticastGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANMulticastGet.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

enum GetMulticastGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMulticastGroupSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/session"
    }
}

public struct GetMulticastGroupSessionInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetMulticastGroupSessionInputBody: Swift.Equatable {
}

extension GetMulticastGroupSessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMulticastGroupSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMulticastGroupSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.loRaWAN = output.loRaWAN
        } else {
            self.loRaWAN = nil
        }
    }
}

public struct GetMulticastGroupSessionOutput: Swift.Equatable {
    /// The LoRaWAN information used with the multicast session.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession?

    public init(
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession? = nil
    )
    {
        self.loRaWAN = loRaWAN
    }
}

struct GetMulticastGroupSessionOutputBody: Swift.Equatable {
    let loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession?
}

extension GetMulticastGroupSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANMulticastSession.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

enum GetMulticastGroupSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetNetworkAnalyzerConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationName = configurationName else {
            return nil
        }
        return "/network-analyzer-configurations/\(configurationName.urlPercentEncoding())"
    }
}

public struct GetNetworkAnalyzerConfigurationInput: Swift.Equatable {
    /// Name of the network analyzer configuration.
    /// This member is required.
    public var configurationName: Swift.String?

    public init(
        configurationName: Swift.String? = nil
    )
    {
        self.configurationName = configurationName
    }
}

struct GetNetworkAnalyzerConfigurationInputBody: Swift.Equatable {
}

extension GetNetworkAnalyzerConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkAnalyzerConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetNetworkAnalyzerConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.multicastGroups = output.multicastGroups
            self.name = output.name
            self.traceContent = output.traceContent
            self.wirelessDevices = output.wirelessDevices
            self.wirelessGateways = output.wirelessGateways
        } else {
            self.arn = nil
            self.description = nil
            self.multicastGroups = nil
            self.name = nil
            self.traceContent = nil
            self.wirelessDevices = nil
            self.wirelessGateways = nil
        }
    }
}

public struct GetNetworkAnalyzerConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// List of multicast group resources that have been added to the network analyzer configuration.
    public var multicastGroups: [Swift.String]?
    /// Name of the network analyzer configuration.
    public var name: Swift.String?
    /// Trace content for your wireless gateway and wireless device resources.
    public var traceContent: IoTWirelessClientTypes.TraceContent?
    /// List of wireless gateway resources that have been added to the network analyzer configuration.
    public var wirelessDevices: [Swift.String]?
    /// List of wireless gateway resources that have been added to the network analyzer configuration.
    public var wirelessGateways: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        multicastGroups: [Swift.String]? = nil,
        name: Swift.String? = nil,
        traceContent: IoTWirelessClientTypes.TraceContent? = nil,
        wirelessDevices: [Swift.String]? = nil,
        wirelessGateways: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.multicastGroups = multicastGroups
        self.name = name
        self.traceContent = traceContent
        self.wirelessDevices = wirelessDevices
        self.wirelessGateways = wirelessGateways
    }
}

struct GetNetworkAnalyzerConfigurationOutputBody: Swift.Equatable {
    let traceContent: IoTWirelessClientTypes.TraceContent?
    let wirelessDevices: [Swift.String]?
    let wirelessGateways: [Swift.String]?
    let description: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let multicastGroups: [Swift.String]?
}

extension GetNetworkAnalyzerConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case multicastGroups = "MulticastGroups"
        case name = "Name"
        case traceContent = "TraceContent"
        case wirelessDevices = "WirelessDevices"
        case wirelessGateways = "WirelessGateways"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceContentDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.TraceContent.self, forKey: .traceContent)
        traceContent = traceContentDecoded
        let wirelessDevicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessDevices)
        var wirelessDevicesDecoded0:[Swift.String]? = nil
        if let wirelessDevicesContainer = wirelessDevicesContainer {
            wirelessDevicesDecoded0 = [Swift.String]()
            for string0 in wirelessDevicesContainer {
                if let string0 = string0 {
                    wirelessDevicesDecoded0?.append(string0)
                }
            }
        }
        wirelessDevices = wirelessDevicesDecoded0
        let wirelessGatewaysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessGateways)
        var wirelessGatewaysDecoded0:[Swift.String]? = nil
        if let wirelessGatewaysContainer = wirelessGatewaysContainer {
            wirelessGatewaysDecoded0 = [Swift.String]()
            for string0 in wirelessGatewaysContainer {
                if let string0 = string0 {
                    wirelessGatewaysDecoded0?.append(string0)
                }
            }
        }
        wirelessGateways = wirelessGatewaysDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let multicastGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .multicastGroups)
        var multicastGroupsDecoded0:[Swift.String]? = nil
        if let multicastGroupsContainer = multicastGroupsContainer {
            multicastGroupsDecoded0 = [Swift.String]()
            for string0 in multicastGroupsContainer {
                if let string0 = string0 {
                    multicastGroupsDecoded0?.append(string0)
                }
            }
        }
        multicastGroups = multicastGroupsDecoded0
    }
}

enum GetNetworkAnalyzerConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPartnerAccountInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let partnerType = partnerType else {
                let message = "Creating a URL Query Item failed. partnerType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            items.append(partnerTypeQueryItem)
            return items
        }
    }
}

extension GetPartnerAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let partnerAccountId = partnerAccountId else {
            return nil
        }
        return "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
    }
}

public struct GetPartnerAccountInput: Swift.Equatable {
    /// The partner account ID to disassociate from the AWS account.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IoTWirelessClientTypes.PartnerType?

    public init(
        partnerAccountId: Swift.String? = nil,
        partnerType: IoTWirelessClientTypes.PartnerType? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
    }
}

struct GetPartnerAccountInputBody: Swift.Equatable {
}

extension GetPartnerAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPartnerAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPartnerAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountLinked = output.accountLinked
            self.sidewalk = output.sidewalk
        } else {
            self.accountLinked = false
            self.sidewalk = nil
        }
    }
}

public struct GetPartnerAccountOutput: Swift.Equatable {
    /// Whether the partner account is linked to the AWS account.
    public var accountLinked: Swift.Bool
    /// The Sidewalk account credentials.
    public var sidewalk: IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint?

    public init(
        accountLinked: Swift.Bool = false,
        sidewalk: IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint? = nil
    )
    {
        self.accountLinked = accountLinked
        self.sidewalk = sidewalk
    }
}

struct GetPartnerAccountOutputBody: Swift.Equatable {
    let sidewalk: IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint?
    let accountLinked: Swift.Bool
}

extension GetPartnerAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLinked = "AccountLinked"
        case sidewalk = "Sidewalk"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let accountLinkedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accountLinked) ?? false
        accountLinked = accountLinkedDecoded
    }
}

enum GetPartnerAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPositionConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension GetPositionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/position-configurations/\(resourceIdentifier.urlPercentEncoding())"
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct GetPositionConfigurationInput: Swift.Equatable {
    /// Resource identifier used in a position configuration.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// Resource type of the resource for which position configuration is retrieved.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init(
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct GetPositionConfigurationInputBody: Swift.Equatable {
}

extension GetPositionConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPositionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPositionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.destination = output.destination
            self.solvers = output.solvers
        } else {
            self.destination = nil
            self.solvers = nil
        }
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct GetPositionConfigurationOutput: Swift.Equatable {
    /// The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
    public var destination: Swift.String?
    /// The wrapper for the solver configuration details object.
    public var solvers: IoTWirelessClientTypes.PositionSolverDetails?

    public init(
        destination: Swift.String? = nil,
        solvers: IoTWirelessClientTypes.PositionSolverDetails? = nil
    )
    {
        self.destination = destination
        self.solvers = solvers
    }
}

struct GetPositionConfigurationOutputBody: Swift.Equatable {
    let solvers: IoTWirelessClientTypes.PositionSolverDetails?
    let destination: Swift.String?
}

extension GetPositionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case solvers = "Solvers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solversDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionSolverDetails.self, forKey: .solvers)
        solvers = solversDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

enum GetPositionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPositionEstimateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellTowers = "CellTowers"
        case gnss = "Gnss"
        case ip = "Ip"
        case timestamp = "Timestamp"
        case wiFiAccessPoints = "WiFiAccessPoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellTowers = self.cellTowers {
            try encodeContainer.encode(cellTowers, forKey: .cellTowers)
        }
        if let gnss = self.gnss {
            try encodeContainer.encode(gnss, forKey: .gnss)
        }
        if let ip = self.ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let wiFiAccessPoints = wiFiAccessPoints {
            var wiFiAccessPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wiFiAccessPoints)
            for wifiaccesspoint0 in wiFiAccessPoints {
                try wiFiAccessPointsContainer.encode(wifiaccesspoint0)
            }
        }
    }
}

extension GetPositionEstimateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/position-estimate"
    }
}

public struct GetPositionEstimateInput: Swift.Equatable {
    /// Retrieves an estimated device position by resolving measurement data from cellular radio towers. The position is resolved using HERE's cellular-based solver.
    public var cellTowers: IoTWirelessClientTypes.CellTowers?
    /// Retrieves an estimated device position by resolving the global navigation satellite system (GNSS) scan data. The position is resolved using the GNSS solver powered by LoRa Cloud.
    public var gnss: IoTWirelessClientTypes.Gnss?
    /// Retrieves an estimated device position by resolving the IP address information from the device. The position is resolved using MaxMind's IP-based solver.
    public var ip: IoTWirelessClientTypes.Ip?
    /// Optional information that specifies the time when the position information will be resolved. It uses the Unix timestamp format. If not specified, the time at which the request was received will be used.
    public var timestamp: ClientRuntime.Date?
    /// Retrieves an estimated device position by resolving WLAN measurement data. The position is resolved using HERE's Wi-Fi based solver.
    public var wiFiAccessPoints: [IoTWirelessClientTypes.WiFiAccessPoint]?

    public init(
        cellTowers: IoTWirelessClientTypes.CellTowers? = nil,
        gnss: IoTWirelessClientTypes.Gnss? = nil,
        ip: IoTWirelessClientTypes.Ip? = nil,
        timestamp: ClientRuntime.Date? = nil,
        wiFiAccessPoints: [IoTWirelessClientTypes.WiFiAccessPoint]? = nil
    )
    {
        self.cellTowers = cellTowers
        self.gnss = gnss
        self.ip = ip
        self.timestamp = timestamp
        self.wiFiAccessPoints = wiFiAccessPoints
    }
}

struct GetPositionEstimateInputBody: Swift.Equatable {
    let wiFiAccessPoints: [IoTWirelessClientTypes.WiFiAccessPoint]?
    let cellTowers: IoTWirelessClientTypes.CellTowers?
    let ip: IoTWirelessClientTypes.Ip?
    let gnss: IoTWirelessClientTypes.Gnss?
    let timestamp: ClientRuntime.Date?
}

extension GetPositionEstimateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellTowers = "CellTowers"
        case gnss = "Gnss"
        case ip = "Ip"
        case timestamp = "Timestamp"
        case wiFiAccessPoints = "WiFiAccessPoints"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wiFiAccessPointsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WiFiAccessPoint?].self, forKey: .wiFiAccessPoints)
        var wiFiAccessPointsDecoded0:[IoTWirelessClientTypes.WiFiAccessPoint]? = nil
        if let wiFiAccessPointsContainer = wiFiAccessPointsContainer {
            wiFiAccessPointsDecoded0 = [IoTWirelessClientTypes.WiFiAccessPoint]()
            for structure0 in wiFiAccessPointsContainer {
                if let structure0 = structure0 {
                    wiFiAccessPointsDecoded0?.append(structure0)
                }
            }
        }
        wiFiAccessPoints = wiFiAccessPointsDecoded0
        let cellTowersDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.CellTowers.self, forKey: .cellTowers)
        cellTowers = cellTowersDecoded
        let ipDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.Ip.self, forKey: .ip)
        ip = ipDecoded
        let gnssDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.Gnss.self, forKey: .gnss)
        gnss = gnssDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension GetPositionEstimateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        switch httpResponse.body {
        case .data(let data):
            self.geoJsonPayload = data
        case .stream(let stream):
            self.geoJsonPayload = try stream.readToEnd()
        case .none:
            self.geoJsonPayload = nil
        }
    }
}

public struct GetPositionEstimateOutput: Swift.Equatable {
    /// The position information of the resource, displayed as a JSON payload. The payload uses the GeoJSON format, which a format that's used to encode geographic data structures. For more information, see [GeoJSON](https://geojson.org/).
    public var geoJsonPayload: ClientRuntime.Data?

    public init(
        geoJsonPayload: ClientRuntime.Data? = nil
    )
    {
        self.geoJsonPayload = geoJsonPayload
    }
}

struct GetPositionEstimateOutputBody: Swift.Equatable {
    let geoJsonPayload: ClientRuntime.Data?
}

extension GetPositionEstimateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geoJsonPayload = "GeoJsonPayload"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoJsonPayloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .geoJsonPayload)
        geoJsonPayload = geoJsonPayloadDecoded
    }
}

enum GetPositionEstimateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPositionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension GetPositionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/positions/\(resourceIdentifier.urlPercentEncoding())"
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct GetPositionInput: Swift.Equatable {
    /// Resource identifier used to retrieve the position information.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// Resource type of the resource for which position information is retrieved.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init(
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct GetPositionInputBody: Swift.Equatable {
}

extension GetPositionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPositionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPositionOutputBody = try responseDecoder.decode(responseBody: data)
            self.accuracy = output.accuracy
            self.position = output.position
            self.solverProvider = output.solverProvider
            self.solverType = output.solverType
            self.solverVersion = output.solverVersion
            self.timestamp = output.timestamp
        } else {
            self.accuracy = nil
            self.position = nil
            self.solverProvider = nil
            self.solverType = nil
            self.solverVersion = nil
            self.timestamp = nil
        }
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct GetPositionOutput: Swift.Equatable {
    /// The accuracy of the estimated position in meters. An empty value indicates that no position data is available. A value of ‘0.0’ value indicates that position data is available. This data corresponds to the position information that you specified instead of the position computed by solver.
    public var accuracy: IoTWirelessClientTypes.Accuracy?
    /// The position information of the resource.
    public var position: [Swift.Float]?
    /// The vendor of the positioning solver.
    public var solverProvider: IoTWirelessClientTypes.PositionSolverProvider?
    /// The type of solver used to identify the position of the resource.
    public var solverType: IoTWirelessClientTypes.PositionSolverType?
    /// The version of the positioning solver.
    public var solverVersion: Swift.String?
    /// The timestamp at which the device's position was determined.
    public var timestamp: Swift.String?

    public init(
        accuracy: IoTWirelessClientTypes.Accuracy? = nil,
        position: [Swift.Float]? = nil,
        solverProvider: IoTWirelessClientTypes.PositionSolverProvider? = nil,
        solverType: IoTWirelessClientTypes.PositionSolverType? = nil,
        solverVersion: Swift.String? = nil,
        timestamp: Swift.String? = nil
    )
    {
        self.accuracy = accuracy
        self.position = position
        self.solverProvider = solverProvider
        self.solverType = solverType
        self.solverVersion = solverVersion
        self.timestamp = timestamp
    }
}

struct GetPositionOutputBody: Swift.Equatable {
    let position: [Swift.Float]?
    let accuracy: IoTWirelessClientTypes.Accuracy?
    let solverType: IoTWirelessClientTypes.PositionSolverType?
    let solverProvider: IoTWirelessClientTypes.PositionSolverProvider?
    let solverVersion: Swift.String?
    let timestamp: Swift.String?
}

extension GetPositionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accuracy = "Accuracy"
        case position = "Position"
        case solverProvider = "SolverProvider"
        case solverType = "SolverType"
        case solverVersion = "SolverVersion"
        case timestamp = "Timestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positionContainer = try containerValues.decodeIfPresent([Swift.Float?].self, forKey: .position)
        var positionDecoded0:[Swift.Float]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Float]()
            for float0 in positionContainer {
                if let float0 = float0 {
                    positionDecoded0?.append(float0)
                }
            }
        }
        position = positionDecoded0
        let accuracyDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.Accuracy.self, forKey: .accuracy)
        accuracy = accuracyDecoded
        let solverTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionSolverType.self, forKey: .solverType)
        solverType = solverTypeDecoded
        let solverProviderDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionSolverProvider.self, forKey: .solverProvider)
        solverProvider = solverProviderDecoded
        let solverVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solverVersion)
        solverVersion = solverVersionDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

enum GetPositionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourceEventConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let partnerType = partnerType {
                let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
                items.append(partnerTypeQueryItem)
            }
            guard let identifierType = identifierType else {
                let message = "Creating a URL Query Item failed. identifierType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let identifierTypeQueryItem = ClientRuntime.URLQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
            items.append(identifierTypeQueryItem)
            return items
        }
    }
}

extension GetResourceEventConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/event-configurations/\(identifier.urlPercentEncoding())"
    }
}

public struct GetResourceEventConfigurationInput: Swift.Equatable {
    /// Resource identifier to opt in for event messaging.
    /// This member is required.
    public var identifier: Swift.String?
    /// Identifier type of the particular resource identifier for event configuration.
    /// This member is required.
    public var identifierType: IoTWirelessClientTypes.IdentifierType?
    /// Partner type of the resource if the identifier type is PartnerAccountId.
    public var partnerType: IoTWirelessClientTypes.EventNotificationPartnerType?

    public init(
        identifier: Swift.String? = nil,
        identifierType: IoTWirelessClientTypes.IdentifierType? = nil,
        partnerType: IoTWirelessClientTypes.EventNotificationPartnerType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
        self.partnerType = partnerType
    }
}

struct GetResourceEventConfigurationInputBody: Swift.Equatable {
}

extension GetResourceEventConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceEventConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourceEventConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectionStatus = output.connectionStatus
            self.deviceRegistrationState = output.deviceRegistrationState
            self.join = output.join
            self.messageDeliveryStatus = output.messageDeliveryStatus
            self.proximity = output.proximity
        } else {
            self.connectionStatus = nil
            self.deviceRegistrationState = nil
            self.join = nil
            self.messageDeliveryStatus = nil
            self.proximity = nil
        }
    }
}

public struct GetResourceEventConfigurationOutput: Swift.Equatable {
    /// Event configuration for the connection status event.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration?
    /// Event configuration for the device registration state event.
    public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
    /// Event configuration for the join event.
    public var join: IoTWirelessClientTypes.JoinEventConfiguration?
    /// Event configuration for the message delivery status event.
    public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration?
    /// Event configuration for the proximity event.
    public var proximity: IoTWirelessClientTypes.ProximityEventConfiguration?

    public init(
        connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration? = nil,
        deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration? = nil,
        join: IoTWirelessClientTypes.JoinEventConfiguration? = nil,
        messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration? = nil,
        proximity: IoTWirelessClientTypes.ProximityEventConfiguration? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.deviceRegistrationState = deviceRegistrationState
        self.join = join
        self.messageDeliveryStatus = messageDeliveryStatus
        self.proximity = proximity
    }
}

struct GetResourceEventConfigurationOutputBody: Swift.Equatable {
    let deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
    let proximity: IoTWirelessClientTypes.ProximityEventConfiguration?
    let join: IoTWirelessClientTypes.JoinEventConfiguration?
    let connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration?
    let messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration?
}

extension GetResourceEventConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case deviceRegistrationState = "DeviceRegistrationState"
        case join = "Join"
        case messageDeliveryStatus = "MessageDeliveryStatus"
        case proximity = "Proximity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceRegistrationStateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration.self, forKey: .deviceRegistrationState)
        deviceRegistrationState = deviceRegistrationStateDecoded
        let proximityDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ProximityEventConfiguration.self, forKey: .proximity)
        proximity = proximityDecoded
        let joinDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.JoinEventConfiguration.self, forKey: .join)
        join = joinDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ConnectionStatusEventConfiguration.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let messageDeliveryStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration.self, forKey: .messageDeliveryStatus)
        messageDeliveryStatus = messageDeliveryStatusDecoded
    }
}

enum GetResourceEventConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourceLogLevelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension GetResourceLogLevelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct GetResourceLogLevelInput: Swift.Equatable {
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway, it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct GetResourceLogLevelInputBody: Swift.Equatable {
}

extension GetResourceLogLevelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceLogLevelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourceLogLevelOutputBody = try responseDecoder.decode(responseBody: data)
            self.logLevel = output.logLevel
        } else {
            self.logLevel = nil
        }
    }
}

public struct GetResourceLogLevelOutput: Swift.Equatable {
    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    public var logLevel: IoTWirelessClientTypes.LogLevel?

    public init(
        logLevel: IoTWirelessClientTypes.LogLevel? = nil
    )
    {
        self.logLevel = logLevel
    }
}

struct GetResourceLogLevelOutputBody: Swift.Equatable {
    let logLevel: IoTWirelessClientTypes.LogLevel?
}

extension GetResourceLogLevelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

enum GetResourceLogLevelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourcePositionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension GetResourcePositionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/resource-positions/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct GetResourcePositionInput: Swift.Equatable {
    /// The identifier of the resource for which position information is retrieved. It can be the wireless device ID or the wireless gateway ID, depending on the resource type.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of resource for which position information is retrieved, which can be a wireless device or a wireless gateway.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init(
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct GetResourcePositionInputBody: Swift.Equatable {
}

extension GetResourcePositionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcePositionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        switch httpResponse.body {
        case .data(let data):
            self.geoJsonPayload = data
        case .stream(let stream):
            self.geoJsonPayload = try stream.readToEnd()
        case .none:
            self.geoJsonPayload = nil
        }
    }
}

public struct GetResourcePositionOutput: Swift.Equatable {
    /// The position information of the resource, displayed as a JSON payload. The payload uses the GeoJSON format, which a format that's used to encode geographic data structures. For more information, see [GeoJSON](https://geojson.org/).
    public var geoJsonPayload: ClientRuntime.Data?

    public init(
        geoJsonPayload: ClientRuntime.Data? = nil
    )
    {
        self.geoJsonPayload = geoJsonPayload
    }
}

struct GetResourcePositionOutputBody: Swift.Equatable {
    let geoJsonPayload: ClientRuntime.Data?
}

extension GetResourcePositionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geoJsonPayload = "GeoJsonPayload"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoJsonPayloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .geoJsonPayload)
        geoJsonPayload = geoJsonPayloadDecoded
    }
}

enum GetResourcePositionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceEndpointInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let serviceType = serviceType {
                let serviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "serviceType".urlPercentEncoding(), value: Swift.String(serviceType.rawValue).urlPercentEncoding())
                items.append(serviceTypeQueryItem)
            }
            return items
        }
    }
}

extension GetServiceEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/service-endpoint"
    }
}

public struct GetServiceEndpointInput: Swift.Equatable {
    /// The service type for which to get endpoint information about. Can be CUPS for the Configuration and Update Server endpoint, or LNS for the LoRaWAN Network Server endpoint or CLAIM for the global endpoint.
    public var serviceType: IoTWirelessClientTypes.WirelessGatewayServiceType?

    public init(
        serviceType: IoTWirelessClientTypes.WirelessGatewayServiceType? = nil
    )
    {
        self.serviceType = serviceType
    }
}

struct GetServiceEndpointInputBody: Swift.Equatable {
}

extension GetServiceEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.serverTrust = output.serverTrust
            self.serviceEndpoint = output.serviceEndpoint
            self.serviceType = output.serviceType
        } else {
            self.serverTrust = nil
            self.serviceEndpoint = nil
            self.serviceType = nil
        }
    }
}

public struct GetServiceEndpointOutput: Swift.Equatable {
    /// The Root CA of the server trust certificate.
    public var serverTrust: Swift.String?
    /// The service endpoint value.
    public var serviceEndpoint: Swift.String?
    /// The endpoint's service type.
    public var serviceType: IoTWirelessClientTypes.WirelessGatewayServiceType?

    public init(
        serverTrust: Swift.String? = nil,
        serviceEndpoint: Swift.String? = nil,
        serviceType: IoTWirelessClientTypes.WirelessGatewayServiceType? = nil
    )
    {
        self.serverTrust = serverTrust
        self.serviceEndpoint = serviceEndpoint
        self.serviceType = serviceType
    }
}

struct GetServiceEndpointOutputBody: Swift.Equatable {
    let serviceType: IoTWirelessClientTypes.WirelessGatewayServiceType?
    let serviceEndpoint: Swift.String?
    let serverTrust: Swift.String?
}

extension GetServiceEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverTrust = "ServerTrust"
        case serviceEndpoint = "ServiceEndpoint"
        case serviceType = "ServiceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessGatewayServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let serviceEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceEndpoint)
        serviceEndpoint = serviceEndpointDecoded
        let serverTrustDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverTrust)
        serverTrust = serverTrustDecoded
    }
}

enum GetServiceEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/service-profiles/\(id.urlPercentEncoding())"
    }
}

public struct GetServiceProfileInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetServiceProfileInputBody: Swift.Equatable {
}

extension GetServiceProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
        } else {
            self.arn = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
        }
    }
}

public struct GetServiceProfileOutput: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the service profile.
    public var id: Swift.String?
    /// Information about the service profile.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo?
    /// The name of the resource.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct GetServiceProfileOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let id: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo?
}

extension GetServiceProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

enum GetServiceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWirelessDeviceImportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless_device_import_task/\(id.urlPercentEncoding())"
    }
}

public struct GetWirelessDeviceImportTaskInput: Swift.Equatable {
    /// The identifier of the import task for which information is requested.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessDeviceImportTaskInputBody: Swift.Equatable {
}

extension GetWirelessDeviceImportTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessDeviceImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWirelessDeviceImportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.destinationName = output.destinationName
            self.failedImportedDeviceCount = output.failedImportedDeviceCount
            self.id = output.id
            self.initializedImportedDeviceCount = output.initializedImportedDeviceCount
            self.onboardedImportedDeviceCount = output.onboardedImportedDeviceCount
            self.pendingImportedDeviceCount = output.pendingImportedDeviceCount
            self.sidewalk = output.sidewalk
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.arn = nil
            self.creationTime = nil
            self.destinationName = nil
            self.failedImportedDeviceCount = nil
            self.id = nil
            self.initializedImportedDeviceCount = nil
            self.onboardedImportedDeviceCount = nil
            self.pendingImportedDeviceCount = nil
            self.sidewalk = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct GetWirelessDeviceImportTaskOutput: Swift.Equatable {
    /// The ARN (Amazon Resource Name) of the import task.
    public var arn: Swift.String?
    /// The time at which the import task was created.
    public var creationTime: ClientRuntime.Date?
    /// The name of the destination that's assigned to the wireless devices in the import task.
    public var destinationName: Swift.String?
    /// The number of devices in the import task that failed to onboard to the import task.
    public var failedImportedDeviceCount: Swift.Int?
    /// The identifier of the import task for which information is retrieved.
    public var id: Swift.String?
    /// The number of devices in the import task that are waiting for the control log to start processing.
    public var initializedImportedDeviceCount: Swift.Int?
    /// The number of devices in the import task that have been onboarded to the import task.
    public var onboardedImportedDeviceCount: Swift.Int?
    /// The number of devices in the import task that are waiting in the import task queue to be onboarded.
    public var pendingImportedDeviceCount: Swift.Int?
    /// The Sidewalk-related information about an import task.
    public var sidewalk: IoTWirelessClientTypes.SidewalkGetStartImportInfo?
    /// The import task status.
    public var status: IoTWirelessClientTypes.ImportTaskStatus?
    /// The reason for the provided status information, such as a validation error that causes the import task to fail.
    public var statusReason: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        destinationName: Swift.String? = nil,
        failedImportedDeviceCount: Swift.Int? = nil,
        id: Swift.String? = nil,
        initializedImportedDeviceCount: Swift.Int? = nil,
        onboardedImportedDeviceCount: Swift.Int? = nil,
        pendingImportedDeviceCount: Swift.Int? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkGetStartImportInfo? = nil,
        status: IoTWirelessClientTypes.ImportTaskStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.destinationName = destinationName
        self.failedImportedDeviceCount = failedImportedDeviceCount
        self.id = id
        self.initializedImportedDeviceCount = initializedImportedDeviceCount
        self.onboardedImportedDeviceCount = onboardedImportedDeviceCount
        self.pendingImportedDeviceCount = pendingImportedDeviceCount
        self.sidewalk = sidewalk
        self.status = status
        self.statusReason = statusReason
    }
}

struct GetWirelessDeviceImportTaskOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let destinationName: Swift.String?
    let sidewalk: IoTWirelessClientTypes.SidewalkGetStartImportInfo?
    let creationTime: ClientRuntime.Date?
    let status: IoTWirelessClientTypes.ImportTaskStatus?
    let statusReason: Swift.String?
    let initializedImportedDeviceCount: Swift.Int?
    let pendingImportedDeviceCount: Swift.Int?
    let onboardedImportedDeviceCount: Swift.Int?
    let failedImportedDeviceCount: Swift.Int?
}

extension GetWirelessDeviceImportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case destinationName = "DestinationName"
        case failedImportedDeviceCount = "FailedImportedDeviceCount"
        case id = "Id"
        case initializedImportedDeviceCount = "InitializedImportedDeviceCount"
        case onboardedImportedDeviceCount = "OnboardedImportedDeviceCount"
        case pendingImportedDeviceCount = "PendingImportedDeviceCount"
        case sidewalk = "Sidewalk"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkGetStartImportInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ImportTaskStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let initializedImportedDeviceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .initializedImportedDeviceCount)
        initializedImportedDeviceCount = initializedImportedDeviceCountDecoded
        let pendingImportedDeviceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pendingImportedDeviceCount)
        pendingImportedDeviceCount = pendingImportedDeviceCountDecoded
        let onboardedImportedDeviceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .onboardedImportedDeviceCount)
        onboardedImportedDeviceCount = onboardedImportedDeviceCountDecoded
        let failedImportedDeviceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedImportedDeviceCount)
        failedImportedDeviceCount = failedImportedDeviceCountDecoded
    }
}

enum GetWirelessDeviceImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWirelessDeviceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let identifierType = identifierType else {
                let message = "Creating a URL Query Item failed. identifierType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let identifierTypeQueryItem = ClientRuntime.URLQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
            items.append(identifierTypeQueryItem)
            return items
        }
    }
}

extension GetWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/wireless-devices/\(identifier.urlPercentEncoding())"
    }
}

public struct GetWirelessDeviceInput: Swift.Equatable {
    /// The identifier of the wireless device to get.
    /// This member is required.
    public var identifier: Swift.String?
    /// The type of identifier used in identifier.
    /// This member is required.
    public var identifierType: IoTWirelessClientTypes.WirelessDeviceIdType?

    public init(
        identifier: Swift.String? = nil,
        identifierType: IoTWirelessClientTypes.WirelessDeviceIdType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
    }
}

struct GetWirelessDeviceInputBody: Swift.Equatable {
}

extension GetWirelessDeviceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWirelessDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.destinationName = output.destinationName
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.positioning = output.positioning
            self.sidewalk = output.sidewalk
            self.thingArn = output.thingArn
            self.thingName = output.thingName
            self.type = output.type
        } else {
            self.arn = nil
            self.description = nil
            self.destinationName = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.positioning = nil
            self.sidewalk = nil
            self.thingArn = nil
            self.thingName = nil
            self.type = nil
        }
    }
}

public struct GetWirelessDeviceOutput: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The name of the destination to which the device is assigned.
    public var destinationName: Swift.String?
    /// The ID of the wireless device.
    public var id: Swift.String?
    /// Information about the wireless device.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDevice?
    /// The name of the resource.
    public var name: Swift.String?
    /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
    public var positioning: IoTWirelessClientTypes.PositioningConfigStatus?
    /// Sidewalk device object.
    public var sidewalk: IoTWirelessClientTypes.SidewalkDevice?
    /// The ARN of the thing associated with the wireless device.
    public var thingArn: Swift.String?
    /// The name of the thing associated with the wireless device. The value is empty if a thing isn't associated with the device.
    public var thingName: Swift.String?
    /// The wireless device type.
    public var type: IoTWirelessClientTypes.WirelessDeviceType?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDevice? = nil,
        name: Swift.String? = nil,
        positioning: IoTWirelessClientTypes.PositioningConfigStatus? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkDevice? = nil,
        thingArn: Swift.String? = nil,
        thingName: Swift.String? = nil,
        type: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.destinationName = destinationName
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.positioning = positioning
        self.sidewalk = sidewalk
        self.thingArn = thingArn
        self.thingName = thingName
        self.type = type
    }
}

struct GetWirelessDeviceOutputBody: Swift.Equatable {
    let type: IoTWirelessClientTypes.WirelessDeviceType?
    let name: Swift.String?
    let description: Swift.String?
    let destinationName: Swift.String?
    let id: Swift.String?
    let arn: Swift.String?
    let thingName: Swift.String?
    let thingArn: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANDevice?
    let sidewalk: IoTWirelessClientTypes.SidewalkDevice?
    let positioning: IoTWirelessClientTypes.PositioningConfigStatus?
}

extension GetWirelessDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case destinationName = "DestinationName"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case positioning = "Positioning"
        case sidewalk = "Sidewalk"
        case thingArn = "ThingArn"
        case thingName = "ThingName"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let positioningDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositioningConfigStatus.self, forKey: .positioning)
        positioning = positioningDecoded
    }
}

enum GetWirelessDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWirelessDeviceStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let wirelessDeviceId = wirelessDeviceId else {
            return nil
        }
        return "/wireless-devices/\(wirelessDeviceId.urlPercentEncoding())/statistics"
    }
}

public struct GetWirelessDeviceStatisticsInput: Swift.Equatable {
    /// The ID of the wireless device for which to get the data.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init(
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct GetWirelessDeviceStatisticsInputBody: Swift.Equatable {
}

extension GetWirelessDeviceStatisticsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessDeviceStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWirelessDeviceStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.loRaWAN = output.loRaWAN
            self.sidewalk = output.sidewalk
            self.wirelessDeviceId = output.wirelessDeviceId
        } else {
            self.lastUplinkReceivedAt = nil
            self.loRaWAN = nil
            self.sidewalk = nil
            self.wirelessDeviceId = nil
        }
    }
}

public struct GetWirelessDeviceStatisticsOutput: Swift.Equatable {
    /// The date and time when the most recent uplink was received. This value is only valid for 3 months.
    public var lastUplinkReceivedAt: Swift.String?
    /// Information about the wireless device's operations.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceMetadata?
    /// MetaData for Sidewalk device.
    public var sidewalk: IoTWirelessClientTypes.SidewalkDeviceMetadata?
    /// The ID of the wireless device.
    public var wirelessDeviceId: Swift.String?

    public init(
        lastUplinkReceivedAt: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceMetadata? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkDeviceMetadata? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.loRaWAN = loRaWAN
        self.sidewalk = sidewalk
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct GetWirelessDeviceStatisticsOutputBody: Swift.Equatable {
    let wirelessDeviceId: Swift.String?
    let lastUplinkReceivedAt: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceMetadata?
    let sidewalk: IoTWirelessClientTypes.SidewalkDeviceMetadata?
}

extension GetWirelessDeviceStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case sidewalk = "Sidewalk"
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessDeviceId)
        wirelessDeviceId = wirelessDeviceIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANDeviceMetadata.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkDeviceMetadata.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

enum GetWirelessDeviceStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWirelessGatewayCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
    }
}

public struct GetWirelessGatewayCertificateInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayCertificateInputBody: Swift.Equatable {
}

extension GetWirelessGatewayCertificateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWirelessGatewayCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.iotCertificateId = output.iotCertificateId
            self.loRaWANNetworkServerCertificateId = output.loRaWANNetworkServerCertificateId
        } else {
            self.iotCertificateId = nil
            self.loRaWANNetworkServerCertificateId = nil
        }
    }
}

public struct GetWirelessGatewayCertificateOutput: Swift.Equatable {
    /// The ID of the certificate associated with the wireless gateway.
    public var iotCertificateId: Swift.String?
    /// The ID of the certificate that is associated with the wireless gateway and used for the LoRaWANNetworkServer endpoint.
    public var loRaWANNetworkServerCertificateId: Swift.String?

    public init(
        iotCertificateId: Swift.String? = nil,
        loRaWANNetworkServerCertificateId: Swift.String? = nil
    )
    {
        self.iotCertificateId = iotCertificateId
        self.loRaWANNetworkServerCertificateId = loRaWANNetworkServerCertificateId
    }
}

struct GetWirelessGatewayCertificateOutputBody: Swift.Equatable {
    let iotCertificateId: Swift.String?
    let loRaWANNetworkServerCertificateId: Swift.String?
}

extension GetWirelessGatewayCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
        case loRaWANNetworkServerCertificateId = "LoRaWANNetworkServerCertificateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
        let loRaWANNetworkServerCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loRaWANNetworkServerCertificateId)
        loRaWANNetworkServerCertificateId = loRaWANNetworkServerCertificateIdDecoded
    }
}

enum GetWirelessGatewayCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWirelessGatewayFirmwareInformationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/firmware-information"
    }
}

public struct GetWirelessGatewayFirmwareInformationInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayFirmwareInformationInputBody: Swift.Equatable {
}

extension GetWirelessGatewayFirmwareInformationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayFirmwareInformationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWirelessGatewayFirmwareInformationOutputBody = try responseDecoder.decode(responseBody: data)
            self.loRaWAN = output.loRaWAN
        } else {
            self.loRaWAN = nil
        }
    }
}

public struct GetWirelessGatewayFirmwareInformationOutput: Swift.Equatable {
    /// Information about the wireless gateway's firmware.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion?

    public init(
        loRaWAN: IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion? = nil
    )
    {
        self.loRaWAN = loRaWAN
    }
}

struct GetWirelessGatewayFirmwareInformationOutputBody: Swift.Equatable {
    let loRaWAN: IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion?
}

extension GetWirelessGatewayFirmwareInformationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

enum GetWirelessGatewayFirmwareInformationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWirelessGatewayInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let identifierType = identifierType else {
                let message = "Creating a URL Query Item failed. identifierType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let identifierTypeQueryItem = ClientRuntime.URLQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
            items.append(identifierTypeQueryItem)
            return items
        }
    }
}

extension GetWirelessGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/wireless-gateways/\(identifier.urlPercentEncoding())"
    }
}

public struct GetWirelessGatewayInput: Swift.Equatable {
    /// The identifier of the wireless gateway to get.
    /// This member is required.
    public var identifier: Swift.String?
    /// The type of identifier used in identifier.
    /// This member is required.
    public var identifierType: IoTWirelessClientTypes.WirelessGatewayIdType?

    public init(
        identifier: Swift.String? = nil,
        identifierType: IoTWirelessClientTypes.WirelessGatewayIdType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
    }
}

struct GetWirelessGatewayInputBody: Swift.Equatable {
}

extension GetWirelessGatewayInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWirelessGatewayOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.thingArn = output.thingArn
            self.thingName = output.thingName
        } else {
            self.arn = nil
            self.description = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.thingArn = nil
            self.thingName = nil
        }
    }
}

public struct GetWirelessGatewayOutput: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The ID of the wireless gateway.
    public var id: Swift.String?
    /// Information about the wireless gateway.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANGateway?
    /// The name of the resource.
    public var name: Swift.String?
    /// The ARN of the thing associated with the wireless gateway.
    public var thingArn: Swift.String?
    /// The name of the thing associated with the wireless gateway. The value is empty if a thing isn't associated with the gateway.
    public var thingName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANGateway? = nil,
        name: Swift.String? = nil,
        thingArn: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.thingArn = thingArn
        self.thingName = thingName
    }
}

struct GetWirelessGatewayOutputBody: Swift.Equatable {
    let name: Swift.String?
    let id: Swift.String?
    let description: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANGateway?
    let arn: Swift.String?
    let thingName: Swift.String?
    let thingArn: Swift.String?
}

extension GetWirelessGatewayOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case thingArn = "ThingArn"
        case thingName = "ThingName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

enum GetWirelessGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWirelessGatewayStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let wirelessGatewayId = wirelessGatewayId else {
            return nil
        }
        return "/wireless-gateways/\(wirelessGatewayId.urlPercentEncoding())/statistics"
    }
}

public struct GetWirelessGatewayStatisticsInput: Swift.Equatable {
    /// The ID of the wireless gateway for which to get the data.
    /// This member is required.
    public var wirelessGatewayId: Swift.String?

    public init(
        wirelessGatewayId: Swift.String? = nil
    )
    {
        self.wirelessGatewayId = wirelessGatewayId
    }
}

struct GetWirelessGatewayStatisticsInputBody: Swift.Equatable {
}

extension GetWirelessGatewayStatisticsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWirelessGatewayStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectionStatus = output.connectionStatus
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.wirelessGatewayId = output.wirelessGatewayId
        } else {
            self.connectionStatus = nil
            self.lastUplinkReceivedAt = nil
            self.wirelessGatewayId = nil
        }
    }
}

public struct GetWirelessGatewayStatisticsOutput: Swift.Equatable {
    /// The connection status of the wireless gateway.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatus?
    /// The date and time when the most recent uplink was received. This value is only valid for 3 months.
    public var lastUplinkReceivedAt: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayId: Swift.String?

    public init(
        connectionStatus: IoTWirelessClientTypes.ConnectionStatus? = nil,
        lastUplinkReceivedAt: Swift.String? = nil,
        wirelessGatewayId: Swift.String? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.wirelessGatewayId = wirelessGatewayId
    }
}

struct GetWirelessGatewayStatisticsOutputBody: Swift.Equatable {
    let wirelessGatewayId: Swift.String?
    let lastUplinkReceivedAt: Swift.String?
    let connectionStatus: IoTWirelessClientTypes.ConnectionStatus?
}

extension GetWirelessGatewayStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case wirelessGatewayId = "WirelessGatewayId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayId)
        wirelessGatewayId = wirelessGatewayIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
    }
}

enum GetWirelessGatewayStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWirelessGatewayTaskDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateway-task-definitions/\(id.urlPercentEncoding())"
    }
}

public struct GetWirelessGatewayTaskDefinitionInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayTaskDefinitionInputBody: Swift.Equatable {
}

extension GetWirelessGatewayTaskDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayTaskDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWirelessGatewayTaskDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.autoCreateTasks = output.autoCreateTasks
            self.name = output.name
            self.update = output.update
        } else {
            self.arn = nil
            self.autoCreateTasks = false
            self.name = nil
            self.update = nil
        }
    }
}

public struct GetWirelessGatewayTaskDefinitionOutput: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// Whether to automatically create tasks using this task definition for all gateways with the specified current version. If false, the task must me created by calling CreateWirelessGatewayTask.
    public var autoCreateTasks: Swift.Bool
    /// The name of the resource.
    public var name: Swift.String?
    /// Information about the gateways to update.
    public var update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate?

    public init(
        arn: Swift.String? = nil,
        autoCreateTasks: Swift.Bool = false,
        name: Swift.String? = nil,
        update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate? = nil
    )
    {
        self.arn = arn
        self.autoCreateTasks = autoCreateTasks
        self.name = name
        self.update = update
    }
}

struct GetWirelessGatewayTaskDefinitionOutputBody: Swift.Equatable {
    let autoCreateTasks: Swift.Bool
    let name: Swift.String?
    let update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate?
    let arn: Swift.String?
}

extension GetWirelessGatewayTaskDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case autoCreateTasks = "AutoCreateTasks"
        case name = "Name"
        case update = "Update"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoCreateTasksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoCreateTasks) ?? false
        autoCreateTasks = autoCreateTasksDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate.self, forKey: .update)
        update = updateDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum GetWirelessGatewayTaskDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWirelessGatewayTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
    }
}

public struct GetWirelessGatewayTaskInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayTaskInputBody: Swift.Equatable {
}

extension GetWirelessGatewayTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWirelessGatewayTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.status = output.status
            self.taskCreatedAt = output.taskCreatedAt
            self.wirelessGatewayId = output.wirelessGatewayId
            self.wirelessGatewayTaskDefinitionId = output.wirelessGatewayTaskDefinitionId
        } else {
            self.lastUplinkReceivedAt = nil
            self.status = nil
            self.taskCreatedAt = nil
            self.wirelessGatewayId = nil
            self.wirelessGatewayTaskDefinitionId = nil
        }
    }
}

public struct GetWirelessGatewayTaskOutput: Swift.Equatable {
    /// The date and time when the most recent uplink was received. This value is only valid for 3 months.
    public var lastUplinkReceivedAt: Swift.String?
    /// The status of the request.
    public var status: IoTWirelessClientTypes.WirelessGatewayTaskStatus?
    /// The date and time when the task was created.
    public var taskCreatedAt: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayId: Swift.String?
    /// The ID of the WirelessGatewayTask.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init(
        lastUplinkReceivedAt: Swift.String? = nil,
        status: IoTWirelessClientTypes.WirelessGatewayTaskStatus? = nil,
        taskCreatedAt: Swift.String? = nil,
        wirelessGatewayId: Swift.String? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.status = status
        self.taskCreatedAt = taskCreatedAt
        self.wirelessGatewayId = wirelessGatewayId
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct GetWirelessGatewayTaskOutputBody: Swift.Equatable {
    let wirelessGatewayId: Swift.String?
    let wirelessGatewayTaskDefinitionId: Swift.String?
    let lastUplinkReceivedAt: Swift.String?
    let taskCreatedAt: Swift.String?
    let status: IoTWirelessClientTypes.WirelessGatewayTaskStatus?
}

extension GetWirelessGatewayTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case status = "Status"
        case taskCreatedAt = "TaskCreatedAt"
        case wirelessGatewayId = "WirelessGatewayId"
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayId)
        wirelessGatewayId = wirelessGatewayIdDecoded
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let taskCreatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskCreatedAt)
        taskCreatedAt = taskCreatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessGatewayTaskStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum GetWirelessGatewayTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTWirelessClientTypes.GlobalIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geranCid = "GeranCid"
        case lac = "Lac"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geranCid = self.geranCid {
            try encodeContainer.encode(geranCid, forKey: .geranCid)
        }
        if let lac = self.lac {
            try encodeContainer.encode(lac, forKey: .lac)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lacDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lac)
        lac = lacDecoded
        let geranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .geranCid)
        geranCid = geranCidDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Global identity information.
    public struct GlobalIdentity: Swift.Equatable {
        /// GERAN (GSM EDGE Radio Access Network) cell global identifier.
        /// This member is required.
        public var geranCid: Swift.Int?
        /// Location area code of the global identity.
        /// This member is required.
        public var lac: Swift.Int?

        public init(
            geranCid: Swift.Int? = nil,
            lac: Swift.Int? = nil
        )
        {
            self.geranCid = geranCid
            self.lac = lac
        }
    }

}

extension IoTWirelessClientTypes.Gnss: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistAltitude = "AssistAltitude"
        case assistPosition = "AssistPosition"
        case captureTime = "CaptureTime"
        case captureTimeAccuracy = "CaptureTimeAccuracy"
        case payload = "Payload"
        case use2DSolver = "Use2DSolver"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistAltitude = self.assistAltitude {
            try encodeContainer.encode(assistAltitude, forKey: .assistAltitude)
        }
        if let assistPosition = assistPosition {
            var assistPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assistPosition)
            for coordinate0 in assistPosition {
                try assistPositionContainer.encode(coordinate0)
            }
        }
        if let captureTime = self.captureTime {
            try encodeContainer.encode(captureTime, forKey: .captureTime)
        }
        if let captureTimeAccuracy = self.captureTimeAccuracy {
            try encodeContainer.encode(captureTimeAccuracy, forKey: .captureTimeAccuracy)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if use2DSolver != false {
            try encodeContainer.encode(use2DSolver, forKey: .use2DSolver)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payload)
        payload = payloadDecoded
        let captureTimeDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .captureTime)
        captureTime = captureTimeDecoded
        let captureTimeAccuracyDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .captureTimeAccuracy)
        captureTimeAccuracy = captureTimeAccuracyDecoded
        let assistPositionContainer = try containerValues.decodeIfPresent([Swift.Float?].self, forKey: .assistPosition)
        var assistPositionDecoded0:[Swift.Float]? = nil
        if let assistPositionContainer = assistPositionContainer {
            assistPositionDecoded0 = [Swift.Float]()
            for float0 in assistPositionContainer {
                if let float0 = float0 {
                    assistPositionDecoded0?.append(float0)
                }
            }
        }
        assistPosition = assistPositionDecoded0
        let assistAltitudeDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .assistAltitude)
        assistAltitude = assistAltitudeDecoded
        let use2DSolverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .use2DSolver) ?? false
        use2DSolver = use2DSolverDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Global navigation satellite system (GNSS) object used for positioning.
    public struct Gnss: Swift.Equatable {
        /// Optional assistance altitude, which is the altitude of the device at capture time, specified in meters above the WGS84 reference ellipsoid.
        public var assistAltitude: Swift.Float?
        /// Optional assistance position information, specified using latitude and longitude values in degrees. The coordinates are inside the WGS84 reference frame.
        public var assistPosition: [Swift.Float]?
        /// Optional parameter that gives an estimate of the time when the GNSS scan information is taken, in seconds GPS time (GPST). If capture time is not specified, the local server time is used.
        public var captureTime: Swift.Float?
        /// Optional value that gives the capture time estimate accuracy, in seconds. If capture time accuracy is not specified, default value of 300 is used.
        public var captureTimeAccuracy: Swift.Float?
        /// Payload that contains the GNSS scan result, or NAV message, in hexadecimal notation.
        /// This member is required.
        public var payload: Swift.String?
        /// Optional parameter that forces 2D solve, which modifies the positioning algorithm to a 2D solution problem. When this parameter is specified, the assistance altitude should have an accuracy of at least 10 meters.
        public var use2DSolver: Swift.Bool

        public init(
            assistAltitude: Swift.Float? = nil,
            assistPosition: [Swift.Float]? = nil,
            captureTime: Swift.Float? = nil,
            captureTimeAccuracy: Swift.Float? = nil,
            payload: Swift.String? = nil,
            use2DSolver: Swift.Bool = false
        )
        {
            self.assistAltitude = assistAltitude
            self.assistPosition = assistPosition
            self.captureTime = captureTime
            self.captureTimeAccuracy = captureTimeAccuracy
            self.payload = payload
            self.use2DSolver = use2DSolver
        }
    }

}

extension IoTWirelessClientTypes.GsmLocalId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bcch = "Bcch"
        case bsic = "Bsic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bcch = self.bcch {
            try encodeContainer.encode(bcch, forKey: .bcch)
        }
        if let bsic = self.bsic {
            try encodeContainer.encode(bsic, forKey: .bsic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bsicDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bsic)
        bsic = bsicDecoded
        let bcchDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bcch)
        bcch = bcchDecoded
    }
}

extension IoTWirelessClientTypes {
    /// GSM local ID information, which corresponds to the local identification parameters of a GSM cell.
    public struct GsmLocalId: Swift.Equatable {
        /// GSM broadcast control channel.
        /// This member is required.
        public var bcch: Swift.Int?
        /// GSM base station identity code (BSIC).
        /// This member is required.
        public var bsic: Swift.Int?

        public init(
            bcch: Swift.Int? = nil,
            bsic: Swift.Int? = nil
        )
        {
            self.bcch = bcch
            self.bsic = bsic
        }
    }

}

extension IoTWirelessClientTypes.GsmNmrObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bcch = "Bcch"
        case bsic = "Bsic"
        case globalIdentity = "GlobalIdentity"
        case rxLevel = "RxLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bcch = self.bcch {
            try encodeContainer.encode(bcch, forKey: .bcch)
        }
        if let bsic = self.bsic {
            try encodeContainer.encode(bsic, forKey: .bsic)
        }
        if let globalIdentity = self.globalIdentity {
            try encodeContainer.encode(globalIdentity, forKey: .globalIdentity)
        }
        if let rxLevel = self.rxLevel {
            try encodeContainer.encode(rxLevel, forKey: .rxLevel)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bsicDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bsic)
        bsic = bsicDecoded
        let bcchDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bcch)
        bcch = bcchDecoded
        let rxLevelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxLevel)
        rxLevel = rxLevelDecoded
        let globalIdentityDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.GlobalIdentity.self, forKey: .globalIdentity)
        globalIdentity = globalIdentityDecoded
    }
}

extension IoTWirelessClientTypes {
    /// GSM object for network measurement reports.
    public struct GsmNmrObj: Swift.Equatable {
        /// GSM broadcast control channel.
        /// This member is required.
        public var bcch: Swift.Int?
        /// GSM base station identity code (BSIC).
        /// This member is required.
        public var bsic: Swift.Int?
        /// Global identity information of the GSM object.
        public var globalIdentity: IoTWirelessClientTypes.GlobalIdentity?
        /// Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).
        public var rxLevel: Swift.Int?

        public init(
            bcch: Swift.Int? = nil,
            bsic: Swift.Int? = nil,
            globalIdentity: IoTWirelessClientTypes.GlobalIdentity? = nil,
            rxLevel: Swift.Int? = nil
        )
        {
            self.bcch = bcch
            self.bsic = bsic
            self.globalIdentity = globalIdentity
            self.rxLevel = rxLevel
        }
    }

}

extension IoTWirelessClientTypes.GsmObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geranCid = "GeranCid"
        case gsmLocalId = "GsmLocalId"
        case gsmNmr = "GsmNmr"
        case gsmTimingAdvance = "GsmTimingAdvance"
        case lac = "Lac"
        case mcc = "Mcc"
        case mnc = "Mnc"
        case rxLevel = "RxLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geranCid = self.geranCid {
            try encodeContainer.encode(geranCid, forKey: .geranCid)
        }
        if let gsmLocalId = self.gsmLocalId {
            try encodeContainer.encode(gsmLocalId, forKey: .gsmLocalId)
        }
        if let gsmNmr = gsmNmr {
            var gsmNmrContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gsmNmr)
            for gsmnmrobj0 in gsmNmr {
                try gsmNmrContainer.encode(gsmnmrobj0)
            }
        }
        if let gsmTimingAdvance = self.gsmTimingAdvance {
            try encodeContainer.encode(gsmTimingAdvance, forKey: .gsmTimingAdvance)
        }
        if let lac = self.lac {
            try encodeContainer.encode(lac, forKey: .lac)
        }
        if let mcc = self.mcc {
            try encodeContainer.encode(mcc, forKey: .mcc)
        }
        if let mnc = self.mnc {
            try encodeContainer.encode(mnc, forKey: .mnc)
        }
        if let rxLevel = self.rxLevel {
            try encodeContainer.encode(rxLevel, forKey: .rxLevel)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mccDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mcc)
        mcc = mccDecoded
        let mncDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mnc)
        mnc = mncDecoded
        let lacDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lac)
        lac = lacDecoded
        let geranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .geranCid)
        geranCid = geranCidDecoded
        let gsmLocalIdDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.GsmLocalId.self, forKey: .gsmLocalId)
        gsmLocalId = gsmLocalIdDecoded
        let gsmTimingAdvanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gsmTimingAdvance)
        gsmTimingAdvance = gsmTimingAdvanceDecoded
        let rxLevelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxLevel)
        rxLevel = rxLevelDecoded
        let gsmNmrContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.GsmNmrObj?].self, forKey: .gsmNmr)
        var gsmNmrDecoded0:[IoTWirelessClientTypes.GsmNmrObj]? = nil
        if let gsmNmrContainer = gsmNmrContainer {
            gsmNmrDecoded0 = [IoTWirelessClientTypes.GsmNmrObj]()
            for structure0 in gsmNmrContainer {
                if let structure0 = structure0 {
                    gsmNmrDecoded0?.append(structure0)
                }
            }
        }
        gsmNmr = gsmNmrDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// GSM object.
    public struct GsmObj: Swift.Equatable {
        /// GERAN (GSM EDGE Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var geranCid: Swift.Int?
        /// GSM local identification (local ID) information.
        public var gsmLocalId: IoTWirelessClientTypes.GsmLocalId?
        /// GSM object for network measurement reports.
        public var gsmNmr: [IoTWirelessClientTypes.GsmNmrObj]?
        /// Timing advance value, which corresponds to the length of time a signal takes to reach the base station from a mobile phone.
        public var gsmTimingAdvance: Swift.Int?
        /// Location area code.
        /// This member is required.
        public var lac: Swift.Int?
        /// Mobile Country Code.
        /// This member is required.
        public var mcc: Swift.Int?
        /// Mobile Network Code.
        /// This member is required.
        public var mnc: Swift.Int?
        /// Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).
        public var rxLevel: Swift.Int?

        public init(
            geranCid: Swift.Int? = nil,
            gsmLocalId: IoTWirelessClientTypes.GsmLocalId? = nil,
            gsmNmr: [IoTWirelessClientTypes.GsmNmrObj]? = nil,
            gsmTimingAdvance: Swift.Int? = nil,
            lac: Swift.Int? = nil,
            mcc: Swift.Int? = nil,
            mnc: Swift.Int? = nil,
            rxLevel: Swift.Int? = nil
        )
        {
            self.geranCid = geranCid
            self.gsmLocalId = gsmLocalId
            self.gsmNmr = gsmNmr
            self.gsmTimingAdvance = gsmTimingAdvance
            self.lac = lac
            self.mcc = mcc
            self.mnc = mnc
            self.rxLevel = rxLevel
        }
    }

}

extension IoTWirelessClientTypes {
    public enum IdentifierType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deveui
        case gatewayeui
        case partneraccountid
        case wirelessdeviceid
        case wirelessgatewayid
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentifierType] {
            return [
                .deveui,
                .gatewayeui,
                .partneraccountid,
                .wirelessdeviceid,
                .wirelessgatewayid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deveui: return "DevEui"
            case .gatewayeui: return "GatewayEui"
            case .partneraccountid: return "PartnerAccountId"
            case .wirelessdeviceid: return "WirelessDeviceId"
            case .wirelessgatewayid: return "WirelessGatewayId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentifierType(rawValue: rawValue) ?? IdentifierType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum ImportTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case deleting
        case failed
        case initialized
        case initializing
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportTaskStatus] {
            return [
                .complete,
                .deleting,
                .failed,
                .initialized,
                .initializing,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .initialized: return "INITIALIZED"
            case .initializing: return "INITIALIZING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportTaskStatus(rawValue: rawValue) ?? ImportTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.ImportedSidewalkDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUpdateTime = "LastUpdateTime"
        case onboardingStatus = "OnboardingStatus"
        case onboardingStatusReason = "OnboardingStatusReason"
        case sidewalkManufacturingSn = "SidewalkManufacturingSn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .dateTime, forKey: .lastUpdateTime)
        }
        if let onboardingStatus = self.onboardingStatus {
            try encodeContainer.encode(onboardingStatus.rawValue, forKey: .onboardingStatus)
        }
        if let onboardingStatusReason = self.onboardingStatusReason {
            try encodeContainer.encode(onboardingStatusReason, forKey: .onboardingStatusReason)
        }
        if let sidewalkManufacturingSn = self.sidewalkManufacturingSn {
            try encodeContainer.encode(sidewalkManufacturingSn, forKey: .sidewalkManufacturingSn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkManufacturingSnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkManufacturingSn)
        sidewalkManufacturingSn = sidewalkManufacturingSnDecoded
        let onboardingStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.OnboardStatus.self, forKey: .onboardingStatus)
        onboardingStatus = onboardingStatusDecoded
        let onboardingStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onboardingStatusReason)
        onboardingStatusReason = onboardingStatusReasonDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about a Sidewalk device that has been added to an import task.
    public struct ImportedSidewalkDevice: Swift.Equatable {
        /// The time at which the status information was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The onboarding status of the Sidewalk device in the import task.
        public var onboardingStatus: IoTWirelessClientTypes.OnboardStatus?
        /// The reason for the onboarding status information for the Sidewalk device.
        public var onboardingStatusReason: Swift.String?
        /// The Sidewalk manufacturing serial number (SMSN) of the Sidewalk device.
        public var sidewalkManufacturingSn: Swift.String?

        public init(
            lastUpdateTime: ClientRuntime.Date? = nil,
            onboardingStatus: IoTWirelessClientTypes.OnboardStatus? = nil,
            onboardingStatusReason: Swift.String? = nil,
            sidewalkManufacturingSn: Swift.String? = nil
        )
        {
            self.lastUpdateTime = lastUpdateTime
            self.onboardingStatus = onboardingStatus
            self.onboardingStatusReason = onboardingStatusReason
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
        }
    }

}

extension IoTWirelessClientTypes.ImportedWirelessDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ImportedSidewalkDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about a wireless device that has been added to an import task.
    public struct ImportedWirelessDevice: Swift.Equatable {
        /// The Sidewalk-related information about a device that has been added to an import task.
        public var sidewalk: IoTWirelessClientTypes.ImportedSidewalkDevice?

        public init(
            sidewalk: IoTWirelessClientTypes.ImportedSidewalkDevice? = nil
        )
        {
            self.sidewalk = sidewalk
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error occurred while processing a request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTWirelessClientTypes.Ip: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension IoTWirelessClientTypes {
    /// IP address used for resolving device location.
    public struct Ip: Swift.Equatable {
        /// IP address information.
        /// This member is required.
        public var ipAddress: Swift.String?

        public init(
            ipAddress: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
        }
    }

}

extension IoTWirelessClientTypes.JoinEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
        case wirelessDeviceIdEventTopic = "WirelessDeviceIdEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let wirelessDeviceIdEventTopic = self.wirelessDeviceIdEventTopic {
            try encodeContainer.encode(wirelessDeviceIdEventTopic.rawValue, forKey: .wirelessDeviceIdEventTopic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let wirelessDeviceIdEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessDeviceIdEventTopic)
        wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Join event configuration object for enabling or disabling topic.
    public struct JoinEventConfiguration: Swift.Equatable {
        /// Join event configuration object for enabling or disabling LoRaWAN related event topics.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations?
        /// Denotes whether the wireless device ID join event topic is enabled or disabled.
        public var wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations? = nil,
            wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }
    }

}

extension IoTWirelessClientTypes.JoinResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Join resource type event configuration object for enabling or disabling topic.
    public struct JoinResourceTypeEventConfiguration: Swift.Equatable {
        /// Join resource type event configuration object for enabling or disabling LoRaWAN related event topics.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration? = nil
        )
        {
            self.loRaWAN = loRaWAN
        }
    }

}

extension ListDestinationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDestinationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/destinations"
    }
}

public struct ListDestinationsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDestinationsInputBody: Swift.Equatable {
}

extension ListDestinationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDestinationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDestinationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinationList = output.destinationList
            self.nextToken = output.nextToken
        } else {
            self.destinationList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDestinationsOutput: Swift.Equatable {
    /// The list of destinations.
    public var destinationList: [IoTWirelessClientTypes.Destinations]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        destinationList: [IoTWirelessClientTypes.Destinations]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationList = destinationList
        self.nextToken = nextToken
    }
}

struct ListDestinationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let destinationList: [IoTWirelessClientTypes.Destinations]?
}

extension ListDestinationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationList = "DestinationList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let destinationListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Destinations?].self, forKey: .destinationList)
        var destinationListDecoded0:[IoTWirelessClientTypes.Destinations]? = nil
        if let destinationListContainer = destinationListContainer {
            destinationListDecoded0 = [IoTWirelessClientTypes.Destinations]()
            for structure0 in destinationListContainer {
                if let structure0 = structure0 {
                    destinationListDecoded0?.append(structure0)
                }
            }
        }
        destinationList = destinationListDecoded0
    }
}

enum ListDestinationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDeviceProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let deviceProfileType = deviceProfileType {
                let deviceProfileTypeQueryItem = ClientRuntime.URLQueryItem(name: "deviceProfileType".urlPercentEncoding(), value: Swift.String(deviceProfileType.rawValue).urlPercentEncoding())
                items.append(deviceProfileTypeQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDeviceProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/device-profiles"
    }
}

public struct ListDeviceProfilesInput: Swift.Equatable {
    /// A filter to list only device profiles that use this type, which can be LoRaWAN or Sidewalk.
    public var deviceProfileType: IoTWirelessClientTypes.DeviceProfileType?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        deviceProfileType: IoTWirelessClientTypes.DeviceProfileType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceProfileType = deviceProfileType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceProfilesInputBody: Swift.Equatable {
}

extension ListDeviceProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDeviceProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDeviceProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceProfileList = output.deviceProfileList
            self.nextToken = output.nextToken
        } else {
            self.deviceProfileList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceProfilesOutput: Swift.Equatable {
    /// The list of device profiles.
    public var deviceProfileList: [IoTWirelessClientTypes.DeviceProfile]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deviceProfileList: [IoTWirelessClientTypes.DeviceProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceProfileList = deviceProfileList
        self.nextToken = nextToken
    }
}

struct ListDeviceProfilesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let deviceProfileList: [IoTWirelessClientTypes.DeviceProfile]?
}

extension ListDeviceProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceProfileList = "DeviceProfileList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let deviceProfileListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.DeviceProfile?].self, forKey: .deviceProfileList)
        var deviceProfileListDecoded0:[IoTWirelessClientTypes.DeviceProfile]? = nil
        if let deviceProfileListContainer = deviceProfileListContainer {
            deviceProfileListDecoded0 = [IoTWirelessClientTypes.DeviceProfile]()
            for structure0 in deviceProfileListContainer {
                if let structure0 = structure0 {
                    deviceProfileListDecoded0?.append(structure0)
                }
            }
        }
        deviceProfileList = deviceProfileListDecoded0
    }
}

enum ListDeviceProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDevicesForWirelessDeviceImportTaskInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let id = id else {
                let message = "Creating a URL Query Item failed. id is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
            return items
        }
    }
}

extension ListDevicesForWirelessDeviceImportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless_device_import_task"
    }
}

public struct ListDevicesForWirelessDeviceImportTaskInput: Swift.Equatable {
    /// The identifier of the import task for which wireless devices are listed.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The status of the devices in the import task.
    public var status: IoTWirelessClientTypes.OnboardStatus?

    public init(
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: IoTWirelessClientTypes.OnboardStatus? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListDevicesForWirelessDeviceImportTaskInputBody: Swift.Equatable {
}

extension ListDevicesForWirelessDeviceImportTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDevicesForWirelessDeviceImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDevicesForWirelessDeviceImportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinationName = output.destinationName
            self.importedWirelessDeviceList = output.importedWirelessDeviceList
            self.nextToken = output.nextToken
        } else {
            self.destinationName = nil
            self.importedWirelessDeviceList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicesForWirelessDeviceImportTaskOutput: Swift.Equatable {
    /// The name of the Sidewalk destination that describes the IoT rule to route messages received from devices in an import task that are onboarded to AWS IoT Wireless.
    public var destinationName: Swift.String?
    /// List of wireless devices in an import task and their onboarding status.
    public var importedWirelessDeviceList: [IoTWirelessClientTypes.ImportedWirelessDevice]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        destinationName: Swift.String? = nil,
        importedWirelessDeviceList: [IoTWirelessClientTypes.ImportedWirelessDevice]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationName = destinationName
        self.importedWirelessDeviceList = importedWirelessDeviceList
        self.nextToken = nextToken
    }
}

struct ListDevicesForWirelessDeviceImportTaskOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let destinationName: Swift.String?
    let importedWirelessDeviceList: [IoTWirelessClientTypes.ImportedWirelessDevice]?
}

extension ListDevicesForWirelessDeviceImportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationName = "DestinationName"
        case importedWirelessDeviceList = "ImportedWirelessDeviceList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let importedWirelessDeviceListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.ImportedWirelessDevice?].self, forKey: .importedWirelessDeviceList)
        var importedWirelessDeviceListDecoded0:[IoTWirelessClientTypes.ImportedWirelessDevice]? = nil
        if let importedWirelessDeviceListContainer = importedWirelessDeviceListContainer {
            importedWirelessDeviceListDecoded0 = [IoTWirelessClientTypes.ImportedWirelessDevice]()
            for structure0 in importedWirelessDeviceListContainer {
                if let structure0 = structure0 {
                    importedWirelessDeviceListDecoded0?.append(structure0)
                }
            }
        }
        importedWirelessDeviceList = importedWirelessDeviceListDecoded0
    }
}

enum ListDevicesForWirelessDeviceImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEventConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension ListEventConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/event-configurations"
    }
}

public struct ListEventConfigurationsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// Resource type to filter event configurations.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.EventNotificationResourceType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.EventNotificationResourceType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListEventConfigurationsInputBody: Swift.Equatable {
}

extension ListEventConfigurationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEventConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEventConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventConfigurationsList = output.eventConfigurationsList
            self.nextToken = output.nextToken
        } else {
            self.eventConfigurationsList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventConfigurationsOutput: Swift.Equatable {
    /// Event configurations of all events for a single resource.
    public var eventConfigurationsList: [IoTWirelessClientTypes.EventConfigurationItem]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        eventConfigurationsList: [IoTWirelessClientTypes.EventConfigurationItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventConfigurationsList = eventConfigurationsList
        self.nextToken = nextToken
    }
}

struct ListEventConfigurationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let eventConfigurationsList: [IoTWirelessClientTypes.EventConfigurationItem]?
}

extension ListEventConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventConfigurationsList = "EventConfigurationsList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let eventConfigurationsListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.EventConfigurationItem?].self, forKey: .eventConfigurationsList)
        var eventConfigurationsListDecoded0:[IoTWirelessClientTypes.EventConfigurationItem]? = nil
        if let eventConfigurationsListContainer = eventConfigurationsListContainer {
            eventConfigurationsListDecoded0 = [IoTWirelessClientTypes.EventConfigurationItem]()
            for structure0 in eventConfigurationsListContainer {
                if let structure0 = structure0 {
                    eventConfigurationsListDecoded0?.append(structure0)
                }
            }
        }
        eventConfigurationsList = eventConfigurationsListDecoded0
    }
}

enum ListEventConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFuotaTasksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFuotaTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/fuota-tasks"
    }
}

public struct ListFuotaTasksInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFuotaTasksInputBody: Swift.Equatable {
}

extension ListFuotaTasksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFuotaTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFuotaTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.fuotaTaskList = output.fuotaTaskList
            self.nextToken = output.nextToken
        } else {
            self.fuotaTaskList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFuotaTasksOutput: Swift.Equatable {
    /// Lists the FUOTA tasks registered to your AWS account.
    public var fuotaTaskList: [IoTWirelessClientTypes.FuotaTask]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        fuotaTaskList: [IoTWirelessClientTypes.FuotaTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fuotaTaskList = fuotaTaskList
        self.nextToken = nextToken
    }
}

struct ListFuotaTasksOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let fuotaTaskList: [IoTWirelessClientTypes.FuotaTask]?
}

extension ListFuotaTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fuotaTaskList = "FuotaTaskList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let fuotaTaskListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.FuotaTask?].self, forKey: .fuotaTaskList)
        var fuotaTaskListDecoded0:[IoTWirelessClientTypes.FuotaTask]? = nil
        if let fuotaTaskListContainer = fuotaTaskListContainer {
            fuotaTaskListDecoded0 = [IoTWirelessClientTypes.FuotaTask]()
            for structure0 in fuotaTaskListContainer {
                if let structure0 = structure0 {
                    fuotaTaskListDecoded0?.append(structure0)
                }
            }
        }
        fuotaTaskList = fuotaTaskListDecoded0
    }
}

enum ListFuotaTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMulticastGroupsByFuotaTaskInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMulticastGroupsByFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/multicast-groups"
    }
}

public struct ListMulticastGroupsByFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMulticastGroupsByFuotaTaskInputBody: Swift.Equatable {
}

extension ListMulticastGroupsByFuotaTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMulticastGroupsByFuotaTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMulticastGroupsByFuotaTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.multicastGroupList = output.multicastGroupList
            self.nextToken = output.nextToken
        } else {
            self.multicastGroupList = nil
            self.nextToken = nil
        }
    }
}

public struct ListMulticastGroupsByFuotaTaskOutput: Swift.Equatable {
    /// List of multicast groups associated with a FUOTA task.
    public var multicastGroupList: [IoTWirelessClientTypes.MulticastGroupByFuotaTask]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        multicastGroupList: [IoTWirelessClientTypes.MulticastGroupByFuotaTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.multicastGroupList = multicastGroupList
        self.nextToken = nextToken
    }
}

struct ListMulticastGroupsByFuotaTaskOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let multicastGroupList: [IoTWirelessClientTypes.MulticastGroupByFuotaTask]?
}

extension ListMulticastGroupsByFuotaTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastGroupList = "MulticastGroupList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let multicastGroupListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.MulticastGroupByFuotaTask?].self, forKey: .multicastGroupList)
        var multicastGroupListDecoded0:[IoTWirelessClientTypes.MulticastGroupByFuotaTask]? = nil
        if let multicastGroupListContainer = multicastGroupListContainer {
            multicastGroupListDecoded0 = [IoTWirelessClientTypes.MulticastGroupByFuotaTask]()
            for structure0 in multicastGroupListContainer {
                if let structure0 = structure0 {
                    multicastGroupListDecoded0?.append(structure0)
                }
            }
        }
        multicastGroupList = multicastGroupListDecoded0
    }
}

enum ListMulticastGroupsByFuotaTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMulticastGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMulticastGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/multicast-groups"
    }
}

public struct ListMulticastGroupsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMulticastGroupsInputBody: Swift.Equatable {
}

extension ListMulticastGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMulticastGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMulticastGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.multicastGroupList = output.multicastGroupList
            self.nextToken = output.nextToken
        } else {
            self.multicastGroupList = nil
            self.nextToken = nil
        }
    }
}

public struct ListMulticastGroupsOutput: Swift.Equatable {
    /// List of multicast groups.
    public var multicastGroupList: [IoTWirelessClientTypes.MulticastGroup]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        multicastGroupList: [IoTWirelessClientTypes.MulticastGroup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.multicastGroupList = multicastGroupList
        self.nextToken = nextToken
    }
}

struct ListMulticastGroupsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let multicastGroupList: [IoTWirelessClientTypes.MulticastGroup]?
}

extension ListMulticastGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastGroupList = "MulticastGroupList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let multicastGroupListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.MulticastGroup?].self, forKey: .multicastGroupList)
        var multicastGroupListDecoded0:[IoTWirelessClientTypes.MulticastGroup]? = nil
        if let multicastGroupListContainer = multicastGroupListContainer {
            multicastGroupListDecoded0 = [IoTWirelessClientTypes.MulticastGroup]()
            for structure0 in multicastGroupListContainer {
                if let structure0 = structure0 {
                    multicastGroupListDecoded0?.append(structure0)
                }
            }
        }
        multicastGroupList = multicastGroupListDecoded0
    }
}

enum ListMulticastGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNetworkAnalyzerConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListNetworkAnalyzerConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/network-analyzer-configurations"
    }
}

public struct ListNetworkAnalyzerConfigurationsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNetworkAnalyzerConfigurationsInputBody: Swift.Equatable {
}

extension ListNetworkAnalyzerConfigurationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListNetworkAnalyzerConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNetworkAnalyzerConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkAnalyzerConfigurationList = output.networkAnalyzerConfigurationList
            self.nextToken = output.nextToken
        } else {
            self.networkAnalyzerConfigurationList = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworkAnalyzerConfigurationsOutput: Swift.Equatable {
    /// The list of network analyzer configurations.
    public var networkAnalyzerConfigurationList: [IoTWirelessClientTypes.NetworkAnalyzerConfigurations]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        networkAnalyzerConfigurationList: [IoTWirelessClientTypes.NetworkAnalyzerConfigurations]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkAnalyzerConfigurationList = networkAnalyzerConfigurationList
        self.nextToken = nextToken
    }
}

struct ListNetworkAnalyzerConfigurationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let networkAnalyzerConfigurationList: [IoTWirelessClientTypes.NetworkAnalyzerConfigurations]?
}

extension ListNetworkAnalyzerConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkAnalyzerConfigurationList = "NetworkAnalyzerConfigurationList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let networkAnalyzerConfigurationListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.NetworkAnalyzerConfigurations?].self, forKey: .networkAnalyzerConfigurationList)
        var networkAnalyzerConfigurationListDecoded0:[IoTWirelessClientTypes.NetworkAnalyzerConfigurations]? = nil
        if let networkAnalyzerConfigurationListContainer = networkAnalyzerConfigurationListContainer {
            networkAnalyzerConfigurationListDecoded0 = [IoTWirelessClientTypes.NetworkAnalyzerConfigurations]()
            for structure0 in networkAnalyzerConfigurationListContainer {
                if let structure0 = structure0 {
                    networkAnalyzerConfigurationListDecoded0?.append(structure0)
                }
            }
        }
        networkAnalyzerConfigurationList = networkAnalyzerConfigurationListDecoded0
    }
}

enum ListNetworkAnalyzerConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPartnerAccountsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPartnerAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/partner-accounts"
    }
}

public struct ListPartnerAccountsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPartnerAccountsInputBody: Swift.Equatable {
}

extension ListPartnerAccountsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPartnerAccountsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPartnerAccountsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sidewalk = output.sidewalk
        } else {
            self.nextToken = nil
            self.sidewalk = nil
        }
    }
}

public struct ListPartnerAccountsOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The Sidewalk account credentials.
    public var sidewalk: [IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint]?

    public init(
        nextToken: Swift.String? = nil,
        sidewalk: [IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint]? = nil
    )
    {
        self.nextToken = nextToken
        self.sidewalk = sidewalk
    }
}

struct ListPartnerAccountsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sidewalk: [IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint]?
}

extension ListPartnerAccountsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sidewalk = "Sidewalk"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sidewalkContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint?].self, forKey: .sidewalk)
        var sidewalkDecoded0:[IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint]? = nil
        if let sidewalkContainer = sidewalkContainer {
            sidewalkDecoded0 = [IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint]()
            for structure0 in sidewalkContainer {
                if let structure0 = structure0 {
                    sidewalkDecoded0?.append(structure0)
                }
            }
        }
        sidewalk = sidewalkDecoded0
    }
}

enum ListPartnerAccountsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPositionConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let resourceType = resourceType {
                let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
                items.append(resourceTypeQueryItem)
            }
            return items
        }
    }
}

extension ListPositionConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/position-configurations"
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct ListPositionConfigurationsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// Resource type for which position configurations are listed.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListPositionConfigurationsInputBody: Swift.Equatable {
}

extension ListPositionConfigurationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPositionConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPositionConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.positionConfigurationList = output.positionConfigurationList
        } else {
            self.nextToken = nil
            self.positionConfigurationList = nil
        }
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct ListPositionConfigurationsOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of position configurations.
    public var positionConfigurationList: [IoTWirelessClientTypes.PositionConfigurationItem]?

    public init(
        nextToken: Swift.String? = nil,
        positionConfigurationList: [IoTWirelessClientTypes.PositionConfigurationItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.positionConfigurationList = positionConfigurationList
    }
}

struct ListPositionConfigurationsOutputBody: Swift.Equatable {
    let positionConfigurationList: [IoTWirelessClientTypes.PositionConfigurationItem]?
    let nextToken: Swift.String?
}

extension ListPositionConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case positionConfigurationList = "PositionConfigurationList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positionConfigurationListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.PositionConfigurationItem?].self, forKey: .positionConfigurationList)
        var positionConfigurationListDecoded0:[IoTWirelessClientTypes.PositionConfigurationItem]? = nil
        if let positionConfigurationListContainer = positionConfigurationListContainer {
            positionConfigurationListDecoded0 = [IoTWirelessClientTypes.PositionConfigurationItem]()
            for structure0 in positionConfigurationListContainer {
                if let structure0 = structure0 {
                    positionConfigurationListDecoded0?.append(structure0)
                }
            }
        }
        positionConfigurationList = positionConfigurationListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPositionConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListQueuedMessagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let wirelessDeviceType = wirelessDeviceType {
                let wirelessDeviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "WirelessDeviceType".urlPercentEncoding(), value: Swift.String(wirelessDeviceType.rawValue).urlPercentEncoding())
                items.append(wirelessDeviceTypeQueryItem)
            }
            return items
        }
    }
}

extension ListQueuedMessagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/data"
    }
}

public struct ListQueuedMessagesInput: Swift.Equatable {
    /// The ID of a given wireless device which the downlink message packets are being sent.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The wireless device type, whic can be either Sidewalk or LoRaWAN.
    public var wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType?

    public init(
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.wirelessDeviceType = wirelessDeviceType
    }
}

struct ListQueuedMessagesInputBody: Swift.Equatable {
}

extension ListQueuedMessagesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListQueuedMessagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListQueuedMessagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.downlinkQueueMessagesList = output.downlinkQueueMessagesList
            self.nextToken = output.nextToken
        } else {
            self.downlinkQueueMessagesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListQueuedMessagesOutput: Swift.Equatable {
    /// The messages in the downlink queue.
    public var downlinkQueueMessagesList: [IoTWirelessClientTypes.DownlinkQueueMessage]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        downlinkQueueMessagesList: [IoTWirelessClientTypes.DownlinkQueueMessage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.downlinkQueueMessagesList = downlinkQueueMessagesList
        self.nextToken = nextToken
    }
}

struct ListQueuedMessagesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let downlinkQueueMessagesList: [IoTWirelessClientTypes.DownlinkQueueMessage]?
}

extension ListQueuedMessagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downlinkQueueMessagesList = "DownlinkQueueMessagesList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let downlinkQueueMessagesListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.DownlinkQueueMessage?].self, forKey: .downlinkQueueMessagesList)
        var downlinkQueueMessagesListDecoded0:[IoTWirelessClientTypes.DownlinkQueueMessage]? = nil
        if let downlinkQueueMessagesListContainer = downlinkQueueMessagesListContainer {
            downlinkQueueMessagesListDecoded0 = [IoTWirelessClientTypes.DownlinkQueueMessage]()
            for structure0 in downlinkQueueMessagesListContainer {
                if let structure0 = structure0 {
                    downlinkQueueMessagesListDecoded0?.append(structure0)
                }
            }
        }
        downlinkQueueMessagesList = downlinkQueueMessagesListDecoded0
    }
}

enum ListQueuedMessagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListServiceProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/service-profiles"
    }
}

public struct ListServiceProfilesInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServiceProfilesInputBody: Swift.Equatable {
}

extension ListServiceProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListServiceProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceProfileList = output.serviceProfileList
        } else {
            self.nextToken = nil
            self.serviceProfileList = nil
        }
    }
}

public struct ListServiceProfilesOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of service profiles.
    public var serviceProfileList: [IoTWirelessClientTypes.ServiceProfile]?

    public init(
        nextToken: Swift.String? = nil,
        serviceProfileList: [IoTWirelessClientTypes.ServiceProfile]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceProfileList = serviceProfileList
    }
}

struct ListServiceProfilesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serviceProfileList: [IoTWirelessClientTypes.ServiceProfile]?
}

extension ListServiceProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serviceProfileList = "ServiceProfileList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serviceProfileListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.ServiceProfile?].self, forKey: .serviceProfileList)
        var serviceProfileListDecoded0:[IoTWirelessClientTypes.ServiceProfile]? = nil
        if let serviceProfileListContainer = serviceProfileListContainer {
            serviceProfileListDecoded0 = [IoTWirelessClientTypes.ServiceProfile]()
            for structure0 in serviceProfileListContainer {
                if let structure0 = structure0 {
                    serviceProfileListDecoded0?.append(structure0)
                }
            }
        }
        serviceProfileList = serviceProfileListDecoded0
    }
}

enum ListServiceProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource for which you want to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWirelessDeviceImportTasksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListWirelessDeviceImportTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless_device_import_tasks"
    }
}

public struct ListWirelessDeviceImportTasksInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWirelessDeviceImportTasksInputBody: Swift.Equatable {
}

extension ListWirelessDeviceImportTasksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWirelessDeviceImportTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWirelessDeviceImportTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.wirelessDeviceImportTaskList = output.wirelessDeviceImportTaskList
        } else {
            self.nextToken = nil
            self.wirelessDeviceImportTaskList = nil
        }
    }
}

public struct ListWirelessDeviceImportTasksOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// List of import tasks and summary information of onboarding status of devices in each import task.
    public var wirelessDeviceImportTaskList: [IoTWirelessClientTypes.WirelessDeviceImportTask]?

    public init(
        nextToken: Swift.String? = nil,
        wirelessDeviceImportTaskList: [IoTWirelessClientTypes.WirelessDeviceImportTask]? = nil
    )
    {
        self.nextToken = nextToken
        self.wirelessDeviceImportTaskList = wirelessDeviceImportTaskList
    }
}

struct ListWirelessDeviceImportTasksOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let wirelessDeviceImportTaskList: [IoTWirelessClientTypes.WirelessDeviceImportTask]?
}

extension ListWirelessDeviceImportTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case wirelessDeviceImportTaskList = "WirelessDeviceImportTaskList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let wirelessDeviceImportTaskListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessDeviceImportTask?].self, forKey: .wirelessDeviceImportTaskList)
        var wirelessDeviceImportTaskListDecoded0:[IoTWirelessClientTypes.WirelessDeviceImportTask]? = nil
        if let wirelessDeviceImportTaskListContainer = wirelessDeviceImportTaskListContainer {
            wirelessDeviceImportTaskListDecoded0 = [IoTWirelessClientTypes.WirelessDeviceImportTask]()
            for structure0 in wirelessDeviceImportTaskListContainer {
                if let structure0 = structure0 {
                    wirelessDeviceImportTaskListDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceImportTaskList = wirelessDeviceImportTaskListDecoded0
    }
}

enum ListWirelessDeviceImportTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWirelessDevicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let fuotaTaskId = fuotaTaskId {
                let fuotaTaskIdQueryItem = ClientRuntime.URLQueryItem(name: "fuotaTaskId".urlPercentEncoding(), value: Swift.String(fuotaTaskId).urlPercentEncoding())
                items.append(fuotaTaskIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let deviceProfileId = deviceProfileId {
                let deviceProfileIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceProfileId".urlPercentEncoding(), value: Swift.String(deviceProfileId).urlPercentEncoding())
                items.append(deviceProfileIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let multicastGroupId = multicastGroupId {
                let multicastGroupIdQueryItem = ClientRuntime.URLQueryItem(name: "multicastGroupId".urlPercentEncoding(), value: Swift.String(multicastGroupId).urlPercentEncoding())
                items.append(multicastGroupIdQueryItem)
            }
            if let destinationName = destinationName {
                let destinationNameQueryItem = ClientRuntime.URLQueryItem(name: "destinationName".urlPercentEncoding(), value: Swift.String(destinationName).urlPercentEncoding())
                items.append(destinationNameQueryItem)
            }
            if let wirelessDeviceType = wirelessDeviceType {
                let wirelessDeviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "wirelessDeviceType".urlPercentEncoding(), value: Swift.String(wirelessDeviceType.rawValue).urlPercentEncoding())
                items.append(wirelessDeviceTypeQueryItem)
            }
            if let serviceProfileId = serviceProfileId {
                let serviceProfileIdQueryItem = ClientRuntime.URLQueryItem(name: "serviceProfileId".urlPercentEncoding(), value: Swift.String(serviceProfileId).urlPercentEncoding())
                items.append(serviceProfileIdQueryItem)
            }
            return items
        }
    }
}

extension ListWirelessDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-devices"
    }
}

public struct ListWirelessDevicesInput: Swift.Equatable {
    /// A filter to list only the wireless devices that use this destination.
    public var destinationName: Swift.String?
    /// A filter to list only the wireless devices that use this device profile.
    public var deviceProfileId: Swift.String?
    /// The ID of a FUOTA task.
    public var fuotaTaskId: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// The ID of the multicast group.
    public var multicastGroupId: Swift.String?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// A filter to list only the wireless devices that use this service profile.
    public var serviceProfileId: Swift.String?
    /// A filter to list only the wireless devices that use this wireless device type.
    public var wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType?

    public init(
        destinationName: Swift.String? = nil,
        deviceProfileId: Swift.String? = nil,
        fuotaTaskId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        multicastGroupId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceProfileId: Swift.String? = nil,
        wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.destinationName = destinationName
        self.deviceProfileId = deviceProfileId
        self.fuotaTaskId = fuotaTaskId
        self.maxResults = maxResults
        self.multicastGroupId = multicastGroupId
        self.nextToken = nextToken
        self.serviceProfileId = serviceProfileId
        self.wirelessDeviceType = wirelessDeviceType
    }
}

struct ListWirelessDevicesInputBody: Swift.Equatable {
}

extension ListWirelessDevicesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWirelessDevicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWirelessDevicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.wirelessDeviceList = output.wirelessDeviceList
        } else {
            self.nextToken = nil
            self.wirelessDeviceList = nil
        }
    }
}

public struct ListWirelessDevicesOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the wireless device.
    public var wirelessDeviceList: [IoTWirelessClientTypes.WirelessDeviceStatistics]?

    public init(
        nextToken: Swift.String? = nil,
        wirelessDeviceList: [IoTWirelessClientTypes.WirelessDeviceStatistics]? = nil
    )
    {
        self.nextToken = nextToken
        self.wirelessDeviceList = wirelessDeviceList
    }
}

struct ListWirelessDevicesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let wirelessDeviceList: [IoTWirelessClientTypes.WirelessDeviceStatistics]?
}

extension ListWirelessDevicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case wirelessDeviceList = "WirelessDeviceList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let wirelessDeviceListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessDeviceStatistics?].self, forKey: .wirelessDeviceList)
        var wirelessDeviceListDecoded0:[IoTWirelessClientTypes.WirelessDeviceStatistics]? = nil
        if let wirelessDeviceListContainer = wirelessDeviceListContainer {
            wirelessDeviceListDecoded0 = [IoTWirelessClientTypes.WirelessDeviceStatistics]()
            for structure0 in wirelessDeviceListContainer {
                if let structure0 = structure0 {
                    wirelessDeviceListDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceList = wirelessDeviceListDecoded0
    }
}

enum ListWirelessDevicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWirelessGatewayTaskDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let taskDefinitionType = taskDefinitionType {
                let taskDefinitionTypeQueryItem = ClientRuntime.URLQueryItem(name: "taskDefinitionType".urlPercentEncoding(), value: Swift.String(taskDefinitionType.rawValue).urlPercentEncoding())
                items.append(taskDefinitionTypeQueryItem)
            }
            return items
        }
    }
}

extension ListWirelessGatewayTaskDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-gateway-task-definitions"
    }
}

public struct ListWirelessGatewayTaskDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// A filter to list only the wireless gateway task definitions that use this task definition type.
    public var taskDefinitionType: IoTWirelessClientTypes.WirelessGatewayTaskDefinitionType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        taskDefinitionType: IoTWirelessClientTypes.WirelessGatewayTaskDefinitionType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskDefinitionType = taskDefinitionType
    }
}

struct ListWirelessGatewayTaskDefinitionsInputBody: Swift.Equatable {
}

extension ListWirelessGatewayTaskDefinitionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWirelessGatewayTaskDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWirelessGatewayTaskDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.taskDefinitions = output.taskDefinitions
        } else {
            self.nextToken = nil
            self.taskDefinitions = nil
        }
    }
}

public struct ListWirelessGatewayTaskDefinitionsOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of task definitions.
    public var taskDefinitions: [IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry]?

    public init(
        nextToken: Swift.String? = nil,
        taskDefinitions: [IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskDefinitions = taskDefinitions
    }
}

struct ListWirelessGatewayTaskDefinitionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let taskDefinitions: [IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry]?
}

extension ListWirelessGatewayTaskDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case taskDefinitions = "TaskDefinitions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let taskDefinitionsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry?].self, forKey: .taskDefinitions)
        var taskDefinitionsDecoded0:[IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry]? = nil
        if let taskDefinitionsContainer = taskDefinitionsContainer {
            taskDefinitionsDecoded0 = [IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry]()
            for structure0 in taskDefinitionsContainer {
                if let structure0 = structure0 {
                    taskDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        taskDefinitions = taskDefinitionsDecoded0
    }
}

enum ListWirelessGatewayTaskDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWirelessGatewaysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListWirelessGatewaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-gateways"
    }
}

public struct ListWirelessGatewaysInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWirelessGatewaysInputBody: Swift.Equatable {
}

extension ListWirelessGatewaysInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWirelessGatewaysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWirelessGatewaysOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.wirelessGatewayList = output.wirelessGatewayList
        } else {
            self.nextToken = nil
            self.wirelessGatewayList = nil
        }
    }
}

public struct ListWirelessGatewaysOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayList: [IoTWirelessClientTypes.WirelessGatewayStatistics]?

    public init(
        nextToken: Swift.String? = nil,
        wirelessGatewayList: [IoTWirelessClientTypes.WirelessGatewayStatistics]? = nil
    )
    {
        self.nextToken = nextToken
        self.wirelessGatewayList = wirelessGatewayList
    }
}

struct ListWirelessGatewaysOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let wirelessGatewayList: [IoTWirelessClientTypes.WirelessGatewayStatistics]?
}

extension ListWirelessGatewaysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case wirelessGatewayList = "WirelessGatewayList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let wirelessGatewayListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessGatewayStatistics?].self, forKey: .wirelessGatewayList)
        var wirelessGatewayListDecoded0:[IoTWirelessClientTypes.WirelessGatewayStatistics]? = nil
        if let wirelessGatewayListContainer = wirelessGatewayListContainer {
            wirelessGatewayListDecoded0 = [IoTWirelessClientTypes.WirelessGatewayStatistics]()
            for structure0 in wirelessGatewayListContainer {
                if let structure0 = structure0 {
                    wirelessGatewayListDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayList = wirelessGatewayListDecoded0
    }
}

enum ListWirelessGatewaysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayEuiEventTopic = "GatewayEuiEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayEuiEventTopic = self.gatewayEuiEventTopic {
            try encodeContainer.encode(gatewayEuiEventTopic.rawValue, forKey: .gatewayEuiEventTopic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayEuiEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .gatewayEuiEventTopic)
        gatewayEuiEventTopic = gatewayEuiEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Object for LoRaWAN connection status resource type event configuration.
    public struct LoRaWANConnectionStatusEventNotificationConfigurations: Swift.Equatable {
        /// Denotes whether the gateway EUI connection status event topic is enabled or disabled.
        public var gatewayEuiEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            gatewayEuiEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.gatewayEuiEventTopic = gatewayEuiEventTopic
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessGatewayEventTopic = "WirelessGatewayEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessGatewayEventTopic = self.wirelessGatewayEventTopic {
            try encodeContainer.encode(wirelessGatewayEventTopic.rawValue, forKey: .wirelessGatewayEventTopic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessGatewayEventTopic)
        wirelessGatewayEventTopic = wirelessGatewayEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Object for LoRaWAN connection status resource type event configuration.
    public struct LoRaWANConnectionStatusResourceTypeEventConfiguration: Swift.Equatable {
        /// Denotes whether the wireless gateway connection status event topic is enabled or disabled.
        public var wirelessGatewayEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            wirelessGatewayEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.wirelessGatewayEventTopic = wirelessGatewayEventTopic
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abpV1_0_x = "AbpV1_0_x"
        case abpV1_1 = "AbpV1_1"
        case devEui = "DevEui"
        case deviceProfileId = "DeviceProfileId"
        case fPorts = "FPorts"
        case otaaV1_0_x = "OtaaV1_0_x"
        case otaaV1_1 = "OtaaV1_1"
        case serviceProfileId = "ServiceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abpV1_0_x = self.abpV1_0_x {
            try encodeContainer.encode(abpV1_0_x, forKey: .abpV1_0_x)
        }
        if let abpV1_1 = self.abpV1_1 {
            try encodeContainer.encode(abpV1_1, forKey: .abpV1_1)
        }
        if let devEui = self.devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
        if let deviceProfileId = self.deviceProfileId {
            try encodeContainer.encode(deviceProfileId, forKey: .deviceProfileId)
        }
        if let fPorts = self.fPorts {
            try encodeContainer.encode(fPorts, forKey: .fPorts)
        }
        if let otaaV1_0_x = self.otaaV1_0_x {
            try encodeContainer.encode(otaaV1_0_x, forKey: .otaaV1_0_x)
        }
        if let otaaV1_1 = self.otaaV1_1 {
            try encodeContainer.encode(otaaV1_1, forKey: .otaaV1_1)
        }
        if let serviceProfileId = self.serviceProfileId {
            try encodeContainer.encode(serviceProfileId, forKey: .serviceProfileId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devEui)
        devEui = devEuiDecoded
        let deviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceProfileId)
        deviceProfileId = deviceProfileIdDecoded
        let serviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProfileId)
        serviceProfileId = serviceProfileIdDecoded
        let otaaV1_1Decoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.OtaaV1_1.self, forKey: .otaaV1_1)
        otaaV1_1 = otaaV1_1Decoded
        let otaaV1_0_xDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.OtaaV1_0_x.self, forKey: .otaaV1_0_x)
        otaaV1_0_x = otaaV1_0_xDecoded
        let abpV1_1Decoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.AbpV1_1.self, forKey: .abpV1_1)
        abpV1_1 = abpV1_1Decoded
        let abpV1_0_xDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.AbpV1_0_x.self, forKey: .abpV1_0_x)
        abpV1_0_x = abpV1_0_xDecoded
        let fPortsDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.FPorts.self, forKey: .fPorts)
        fPorts = fPortsDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWAN object for create functions.
    public struct LoRaWANDevice: Swift.Equatable {
        /// LoRaWAN object for create APIs
        public var abpV1_0_x: IoTWirelessClientTypes.AbpV1_0_x?
        /// ABP device object for create APIs for v1.1
        public var abpV1_1: IoTWirelessClientTypes.AbpV1_1?
        /// The DevEUI value.
        public var devEui: Swift.String?
        /// The ID of the device profile for the new wireless device.
        public var deviceProfileId: Swift.String?
        /// List of FPort assigned for different LoRaWAN application packages to use
        public var fPorts: IoTWirelessClientTypes.FPorts?
        /// OTAA device object for create APIs for v1.0.x
        public var otaaV1_0_x: IoTWirelessClientTypes.OtaaV1_0_x?
        /// OTAA device object for v1.1 for create APIs
        public var otaaV1_1: IoTWirelessClientTypes.OtaaV1_1?
        /// The ID of the service profile.
        public var serviceProfileId: Swift.String?

        public init(
            abpV1_0_x: IoTWirelessClientTypes.AbpV1_0_x? = nil,
            abpV1_1: IoTWirelessClientTypes.AbpV1_1? = nil,
            devEui: Swift.String? = nil,
            deviceProfileId: Swift.String? = nil,
            fPorts: IoTWirelessClientTypes.FPorts? = nil,
            otaaV1_0_x: IoTWirelessClientTypes.OtaaV1_0_x? = nil,
            otaaV1_1: IoTWirelessClientTypes.OtaaV1_1? = nil,
            serviceProfileId: Swift.String? = nil
        )
        {
            self.abpV1_0_x = abpV1_0_x
            self.abpV1_1 = abpV1_1
            self.devEui = devEui
            self.deviceProfileId = deviceProfileId
            self.fPorts = fPorts
            self.otaaV1_0_x = otaaV1_0_x
            self.otaaV1_1 = otaaV1_1
            self.serviceProfileId = serviceProfileId
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANDeviceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRate = "DataRate"
        case devEui = "DevEui"
        case fPort = "FPort"
        case frequency = "Frequency"
        case gateways = "Gateways"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRate = self.dataRate {
            try encodeContainer.encode(dataRate, forKey: .dataRate)
        }
        if let devEui = self.devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
        if let fPort = self.fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
        if let gateways = gateways {
            var gatewaysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gateways)
            for lorawangatewaymetadata0 in gateways {
                try gatewaysContainer.encode(lorawangatewaymetadata0)
            }
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devEui)
        devEui = devEuiDecoded
        let fPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fPort)
        fPort = fPortDecoded
        let dataRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRate)
        dataRate = dataRateDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .frequency)
        frequency = frequencyDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let gatewaysContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.LoRaWANGatewayMetadata?].self, forKey: .gateways)
        var gatewaysDecoded0:[IoTWirelessClientTypes.LoRaWANGatewayMetadata]? = nil
        if let gatewaysContainer = gatewaysContainer {
            gatewaysDecoded0 = [IoTWirelessClientTypes.LoRaWANGatewayMetadata]()
            for structure0 in gatewaysContainer {
                if let structure0 = structure0 {
                    gatewaysDecoded0?.append(structure0)
                }
            }
        }
        gateways = gatewaysDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWAN device metatdata.
    public struct LoRaWANDeviceMetadata: Swift.Equatable {
        /// The DataRate value.
        public var dataRate: Swift.Int?
        /// The DevEUI value.
        public var devEui: Swift.String?
        /// The FPort value.
        public var fPort: Swift.Int?
        /// The device's channel frequency in Hz.
        public var frequency: Swift.Int?
        /// Information about the gateways accessed by the device.
        public var gateways: [IoTWirelessClientTypes.LoRaWANGatewayMetadata]?
        /// The date and time of the metadata.
        public var timestamp: Swift.String?

        public init(
            dataRate: Swift.Int? = nil,
            devEui: Swift.String? = nil,
            fPort: Swift.Int? = nil,
            frequency: Swift.Int? = nil,
            gateways: [IoTWirelessClientTypes.LoRaWANGatewayMetadata]? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.dataRate = dataRate
            self.devEui = devEui
            self.fPort = fPort
            self.frequency = frequency
            self.gateways = gateways
            self.timestamp = timestamp
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANDeviceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classBTimeout = "ClassBTimeout"
        case classCTimeout = "ClassCTimeout"
        case factoryPresetFreqsList = "FactoryPresetFreqsList"
        case macVersion = "MacVersion"
        case maxDutyCycle = "MaxDutyCycle"
        case maxEirp = "MaxEirp"
        case pingSlotDr = "PingSlotDr"
        case pingSlotFreq = "PingSlotFreq"
        case pingSlotPeriod = "PingSlotPeriod"
        case regParamsRevision = "RegParamsRevision"
        case rfRegion = "RfRegion"
        case rxDataRate2 = "RxDataRate2"
        case rxDelay1 = "RxDelay1"
        case rxDrOffset1 = "RxDrOffset1"
        case rxFreq2 = "RxFreq2"
        case supports32BitFCnt = "Supports32BitFCnt"
        case supportsClassB = "SupportsClassB"
        case supportsClassC = "SupportsClassC"
        case supportsJoin = "SupportsJoin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classBTimeout = self.classBTimeout {
            try encodeContainer.encode(classBTimeout, forKey: .classBTimeout)
        }
        if let classCTimeout = self.classCTimeout {
            try encodeContainer.encode(classCTimeout, forKey: .classCTimeout)
        }
        if let factoryPresetFreqsList = factoryPresetFreqsList {
            var factoryPresetFreqsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .factoryPresetFreqsList)
            for presetfreq0 in factoryPresetFreqsList {
                try factoryPresetFreqsListContainer.encode(presetfreq0)
            }
        }
        if let macVersion = self.macVersion {
            try encodeContainer.encode(macVersion, forKey: .macVersion)
        }
        if let maxDutyCycle = self.maxDutyCycle {
            try encodeContainer.encode(maxDutyCycle, forKey: .maxDutyCycle)
        }
        if let maxEirp = self.maxEirp {
            try encodeContainer.encode(maxEirp, forKey: .maxEirp)
        }
        if let pingSlotDr = self.pingSlotDr {
            try encodeContainer.encode(pingSlotDr, forKey: .pingSlotDr)
        }
        if let pingSlotFreq = self.pingSlotFreq {
            try encodeContainer.encode(pingSlotFreq, forKey: .pingSlotFreq)
        }
        if let pingSlotPeriod = self.pingSlotPeriod {
            try encodeContainer.encode(pingSlotPeriod, forKey: .pingSlotPeriod)
        }
        if let regParamsRevision = self.regParamsRevision {
            try encodeContainer.encode(regParamsRevision, forKey: .regParamsRevision)
        }
        if let rfRegion = self.rfRegion {
            try encodeContainer.encode(rfRegion, forKey: .rfRegion)
        }
        if let rxDataRate2 = self.rxDataRate2 {
            try encodeContainer.encode(rxDataRate2, forKey: .rxDataRate2)
        }
        if let rxDelay1 = self.rxDelay1 {
            try encodeContainer.encode(rxDelay1, forKey: .rxDelay1)
        }
        if let rxDrOffset1 = self.rxDrOffset1 {
            try encodeContainer.encode(rxDrOffset1, forKey: .rxDrOffset1)
        }
        if let rxFreq2 = self.rxFreq2 {
            try encodeContainer.encode(rxFreq2, forKey: .rxFreq2)
        }
        if supports32BitFCnt != false {
            try encodeContainer.encode(supports32BitFCnt, forKey: .supports32BitFCnt)
        }
        if supportsClassB != false {
            try encodeContainer.encode(supportsClassB, forKey: .supportsClassB)
        }
        if supportsClassC != false {
            try encodeContainer.encode(supportsClassC, forKey: .supportsClassC)
        }
        if let supportsJoin = self.supportsJoin {
            try encodeContainer.encode(supportsJoin, forKey: .supportsJoin)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportsClassBDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsClassB) ?? false
        supportsClassB = supportsClassBDecoded
        let classBTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classBTimeout)
        classBTimeout = classBTimeoutDecoded
        let pingSlotPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pingSlotPeriod)
        pingSlotPeriod = pingSlotPeriodDecoded
        let pingSlotDrDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pingSlotDr)
        pingSlotDr = pingSlotDrDecoded
        let pingSlotFreqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pingSlotFreq)
        pingSlotFreq = pingSlotFreqDecoded
        let supportsClassCDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsClassC) ?? false
        supportsClassC = supportsClassCDecoded
        let classCTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classCTimeout)
        classCTimeout = classCTimeoutDecoded
        let macVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macVersion)
        macVersion = macVersionDecoded
        let regParamsRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regParamsRevision)
        regParamsRevision = regParamsRevisionDecoded
        let rxDelay1Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxDelay1)
        rxDelay1 = rxDelay1Decoded
        let rxDrOffset1Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxDrOffset1)
        rxDrOffset1 = rxDrOffset1Decoded
        let rxDataRate2Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxDataRate2)
        rxDataRate2 = rxDataRate2Decoded
        let rxFreq2Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxFreq2)
        rxFreq2 = rxFreq2Decoded
        let factoryPresetFreqsListContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .factoryPresetFreqsList)
        var factoryPresetFreqsListDecoded0:[Swift.Int]? = nil
        if let factoryPresetFreqsListContainer = factoryPresetFreqsListContainer {
            factoryPresetFreqsListDecoded0 = [Swift.Int]()
            for integer0 in factoryPresetFreqsListContainer {
                if let integer0 = integer0 {
                    factoryPresetFreqsListDecoded0?.append(integer0)
                }
            }
        }
        factoryPresetFreqsList = factoryPresetFreqsListDecoded0
        let maxEirpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxEirp)
        maxEirp = maxEirpDecoded
        let maxDutyCycleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDutyCycle)
        maxDutyCycle = maxDutyCycleDecoded
        let rfRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let supportsJoinDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsJoin)
        supportsJoin = supportsJoinDecoded
        let supports32BitFCntDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supports32BitFCnt) ?? false
        supports32BitFCnt = supports32BitFCntDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANDeviceProfile object.
    public struct LoRaWANDeviceProfile: Swift.Equatable {
        /// The ClassBTimeout value.
        public var classBTimeout: Swift.Int?
        /// The ClassCTimeout value.
        public var classCTimeout: Swift.Int?
        /// The list of values that make up the FactoryPresetFreqs value.
        public var factoryPresetFreqsList: [Swift.Int]?
        /// The MAC version (such as OTAA 1.1 or OTAA 1.0.3) to use with this device profile.
        public var macVersion: Swift.String?
        /// The MaxDutyCycle value.
        public var maxDutyCycle: Swift.Int?
        /// The MaxEIRP value.
        public var maxEirp: Swift.Int?
        /// The PingSlotDR value.
        public var pingSlotDr: Swift.Int?
        /// The PingSlotFreq value.
        public var pingSlotFreq: Swift.Int?
        /// The PingSlotPeriod value.
        public var pingSlotPeriod: Swift.Int?
        /// The version of regional parameters.
        public var regParamsRevision: Swift.String?
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// The RXDataRate2 value.
        public var rxDataRate2: Swift.Int?
        /// The RXDelay1 value.
        public var rxDelay1: Swift.Int?
        /// The RXDROffset1 value.
        public var rxDrOffset1: Swift.Int?
        /// The RXFreq2 value.
        public var rxFreq2: Swift.Int?
        /// The Supports32BitFCnt value.
        public var supports32BitFCnt: Swift.Bool
        /// The SupportsClassB value.
        public var supportsClassB: Swift.Bool
        /// The SupportsClassC value.
        public var supportsClassC: Swift.Bool
        /// The SupportsJoin value.
        public var supportsJoin: Swift.Bool?

        public init(
            classBTimeout: Swift.Int? = nil,
            classCTimeout: Swift.Int? = nil,
            factoryPresetFreqsList: [Swift.Int]? = nil,
            macVersion: Swift.String? = nil,
            maxDutyCycle: Swift.Int? = nil,
            maxEirp: Swift.Int? = nil,
            pingSlotDr: Swift.Int? = nil,
            pingSlotFreq: Swift.Int? = nil,
            pingSlotPeriod: Swift.Int? = nil,
            regParamsRevision: Swift.String? = nil,
            rfRegion: Swift.String? = nil,
            rxDataRate2: Swift.Int? = nil,
            rxDelay1: Swift.Int? = nil,
            rxDrOffset1: Swift.Int? = nil,
            rxFreq2: Swift.Int? = nil,
            supports32BitFCnt: Swift.Bool = false,
            supportsClassB: Swift.Bool = false,
            supportsClassC: Swift.Bool = false,
            supportsJoin: Swift.Bool? = nil
        )
        {
            self.classBTimeout = classBTimeout
            self.classCTimeout = classCTimeout
            self.factoryPresetFreqsList = factoryPresetFreqsList
            self.macVersion = macVersion
            self.maxDutyCycle = maxDutyCycle
            self.maxEirp = maxEirp
            self.pingSlotDr = pingSlotDr
            self.pingSlotFreq = pingSlotFreq
            self.pingSlotPeriod = pingSlotPeriod
            self.regParamsRevision = regParamsRevision
            self.rfRegion = rfRegion
            self.rxDataRate2 = rxDataRate2
            self.rxDelay1 = rxDelay1
            self.rxDrOffset1 = rxDrOffset1
            self.rxFreq2 = rxFreq2
            self.supports32BitFCnt = supports32BitFCnt
            self.supportsClassB = supportsClassB
            self.supportsClassC = supportsClassC
            self.supportsJoin = supportsJoin
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANFuotaTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rfRegion = "RfRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rfRegion = self.rfRegion {
            try encodeContainer.encode(rfRegion.rawValue, forKey: .rfRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rfRegionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SupportedRfRegion.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The LoRaWAN information used with a FUOTA task.
    public struct LoRaWANFuotaTask: Swift.Equatable {
        /// Supported RfRegions
        public var rfRegion: IoTWirelessClientTypes.SupportedRfRegion?

        public init(
            rfRegion: IoTWirelessClientTypes.SupportedRfRegion? = nil
        )
        {
            self.rfRegion = rfRegion
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rfRegion = "RfRegion"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rfRegion = self.rfRegion {
            try encodeContainer.encode(rfRegion, forKey: .rfRegion)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rfRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The LoRaWAN information returned from getting a FUOTA task.
    public struct LoRaWANFuotaTaskGetInfo: Swift.Equatable {
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// Start time of a FUOTA task.
        public var startTime: ClientRuntime.Date?

        public init(
            rfRegion: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.rfRegion = rfRegion
            self.startTime = startTime
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANGateway: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beaconing = "Beaconing"
        case gatewayEui = "GatewayEui"
        case joinEuiFilters = "JoinEuiFilters"
        case maxEirp = "MaxEirp"
        case netIdFilters = "NetIdFilters"
        case rfRegion = "RfRegion"
        case subBands = "SubBands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beaconing = self.beaconing {
            try encodeContainer.encode(beaconing, forKey: .beaconing)
        }
        if let gatewayEui = self.gatewayEui {
            try encodeContainer.encode(gatewayEui, forKey: .gatewayEui)
        }
        if let joinEuiFilters = joinEuiFilters {
            var joinEuiFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .joinEuiFilters)
            for joineuirange0 in joinEuiFilters {
                var joineuirange0Container = joinEuiFiltersContainer.nestedUnkeyedContainer()
                for joineui1 in joineuirange0 {
                    try joineuirange0Container.encode(joineui1)
                }
            }
        }
        if let maxEirp = self.maxEirp {
            try encodeContainer.encode(maxEirp, forKey: .maxEirp)
        }
        if let netIdFilters = netIdFilters {
            var netIdFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .netIdFilters)
            for netid0 in netIdFilters {
                try netIdFiltersContainer.encode(netid0)
            }
        }
        if let rfRegion = self.rfRegion {
            try encodeContainer.encode(rfRegion, forKey: .rfRegion)
        }
        if let subBands = subBands {
            var subBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subBands)
            for subband0 in subBands {
                try subBandsContainer.encode(subband0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayEui)
        gatewayEui = gatewayEuiDecoded
        let rfRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let joinEuiFiltersContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .joinEuiFilters)
        var joinEuiFiltersDecoded0:[[Swift.String]]? = nil
        if let joinEuiFiltersContainer = joinEuiFiltersContainer {
            joinEuiFiltersDecoded0 = [[Swift.String]]()
            for list0 in joinEuiFiltersContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    joinEuiFiltersDecoded0?.append(list0Decoded0)
                }
            }
        }
        joinEuiFilters = joinEuiFiltersDecoded0
        let netIdFiltersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .netIdFilters)
        var netIdFiltersDecoded0:[Swift.String]? = nil
        if let netIdFiltersContainer = netIdFiltersContainer {
            netIdFiltersDecoded0 = [Swift.String]()
            for string0 in netIdFiltersContainer {
                if let string0 = string0 {
                    netIdFiltersDecoded0?.append(string0)
                }
            }
        }
        netIdFilters = netIdFiltersDecoded0
        let subBandsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .subBands)
        var subBandsDecoded0:[Swift.Int]? = nil
        if let subBandsContainer = subBandsContainer {
            subBandsDecoded0 = [Swift.Int]()
            for integer0 in subBandsContainer {
                if let integer0 = integer0 {
                    subBandsDecoded0?.append(integer0)
                }
            }
        }
        subBands = subBandsDecoded0
        let beaconingDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.Beaconing.self, forKey: .beaconing)
        beaconing = beaconingDecoded
        let maxEirpDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .maxEirp)
        maxEirp = maxEirpDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANGateway object.
    public struct LoRaWANGateway: Swift.Equatable {
        /// Beaconing object information, which consists of the data rate and frequency parameters.
        public var beaconing: IoTWirelessClientTypes.Beaconing?
        /// The gateway's EUI value.
        public var gatewayEui: Swift.String?
        /// A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.
        public var joinEuiFilters: [[Swift.String]]?
        /// The MaxEIRP value.
        public var maxEirp: Swift.Float?
        /// A list of NetId values that are used by LoRa gateways to filter the uplink frames.
        public var netIdFilters: [Swift.String]?
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// A list of integer indicating which sub bands are supported by LoRa gateway.
        public var subBands: [Swift.Int]?

        public init(
            beaconing: IoTWirelessClientTypes.Beaconing? = nil,
            gatewayEui: Swift.String? = nil,
            joinEuiFilters: [[Swift.String]]? = nil,
            maxEirp: Swift.Float? = nil,
            netIdFilters: [Swift.String]? = nil,
            rfRegion: Swift.String? = nil,
            subBands: [Swift.Int]? = nil
        )
        {
            self.beaconing = beaconing
            self.gatewayEui = gatewayEui
            self.joinEuiFilters = joinEuiFilters
            self.maxEirp = maxEirp
            self.netIdFilters = netIdFilters
            self.rfRegion = rfRegion
            self.subBands = subBands
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANGatewayCurrentVersion object.
    public struct LoRaWANGatewayCurrentVersion: Swift.Equatable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?

        public init(
            currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANGatewayMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayEui = "GatewayEui"
        case rssi = "Rssi"
        case snr = "Snr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayEui = self.gatewayEui {
            try encodeContainer.encode(gatewayEui, forKey: .gatewayEui)
        }
        if let rssi = self.rssi {
            try encodeContainer.encode(rssi, forKey: .rssi)
        }
        if let snr = self.snr {
            try encodeContainer.encode(snr, forKey: .snr)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayEui)
        gatewayEui = gatewayEuiDecoded
        let snrDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .snr)
        snr = snrDecoded
        let rssiDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .rssi)
        rssi = rssiDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWAN gateway metatdata.
    public struct LoRaWANGatewayMetadata: Swift.Equatable {
        /// The gateway's EUI value.
        public var gatewayEui: Swift.String?
        /// The RSSI value.
        public var rssi: Swift.Double?
        /// The SNR value.
        public var snr: Swift.Double?

        public init(
            gatewayEui: Swift.String? = nil,
            rssi: Swift.Double? = nil,
            snr: Swift.Double? = nil
        )
        {
            self.gatewayEui = gatewayEui
            self.rssi = rssi
            self.snr = snr
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANGatewayVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case model = "Model"
        case packageVersion = "PackageVersion"
        case station = "Station"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
        if let station = self.station {
            try encodeContainer.encode(station, forKey: .station)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let stationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .station)
        station = stationDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANGatewayVersion object.
    public struct LoRaWANGatewayVersion: Swift.Equatable {
        /// The model number of the wireless gateway.
        public var model: Swift.String?
        /// The version of the wireless gateway firmware.
        public var packageVersion: Swift.String?
        /// The basic station version of the wireless gateway.
        public var station: Swift.String?

        public init(
            model: Swift.String? = nil,
            packageVersion: Swift.String? = nil,
            station: Swift.String? = nil
        )
        {
            self.model = model
            self.packageVersion = packageVersion
            self.station = station
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addGwMetadata = "AddGwMetadata"
        case channelMask = "ChannelMask"
        case devStatusReqFreq = "DevStatusReqFreq"
        case dlBucketSize = "DlBucketSize"
        case dlRate = "DlRate"
        case dlRatePolicy = "DlRatePolicy"
        case drMax = "DrMax"
        case drMin = "DrMin"
        case hrAllowed = "HrAllowed"
        case minGwDiversity = "MinGwDiversity"
        case nwkGeoLoc = "NwkGeoLoc"
        case prAllowed = "PrAllowed"
        case raAllowed = "RaAllowed"
        case reportDevStatusBattery = "ReportDevStatusBattery"
        case reportDevStatusMargin = "ReportDevStatusMargin"
        case targetPer = "TargetPer"
        case ulBucketSize = "UlBucketSize"
        case ulRate = "UlRate"
        case ulRatePolicy = "UlRatePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if addGwMetadata != false {
            try encodeContainer.encode(addGwMetadata, forKey: .addGwMetadata)
        }
        if let channelMask = self.channelMask {
            try encodeContainer.encode(channelMask, forKey: .channelMask)
        }
        if let devStatusReqFreq = self.devStatusReqFreq {
            try encodeContainer.encode(devStatusReqFreq, forKey: .devStatusReqFreq)
        }
        if let dlBucketSize = self.dlBucketSize {
            try encodeContainer.encode(dlBucketSize, forKey: .dlBucketSize)
        }
        if let dlRate = self.dlRate {
            try encodeContainer.encode(dlRate, forKey: .dlRate)
        }
        if let dlRatePolicy = self.dlRatePolicy {
            try encodeContainer.encode(dlRatePolicy, forKey: .dlRatePolicy)
        }
        if drMax != 0 {
            try encodeContainer.encode(drMax, forKey: .drMax)
        }
        if drMin != 0 {
            try encodeContainer.encode(drMin, forKey: .drMin)
        }
        if hrAllowed != false {
            try encodeContainer.encode(hrAllowed, forKey: .hrAllowed)
        }
        if let minGwDiversity = self.minGwDiversity {
            try encodeContainer.encode(minGwDiversity, forKey: .minGwDiversity)
        }
        if nwkGeoLoc != false {
            try encodeContainer.encode(nwkGeoLoc, forKey: .nwkGeoLoc)
        }
        if prAllowed != false {
            try encodeContainer.encode(prAllowed, forKey: .prAllowed)
        }
        if raAllowed != false {
            try encodeContainer.encode(raAllowed, forKey: .raAllowed)
        }
        if reportDevStatusBattery != false {
            try encodeContainer.encode(reportDevStatusBattery, forKey: .reportDevStatusBattery)
        }
        if reportDevStatusMargin != false {
            try encodeContainer.encode(reportDevStatusMargin, forKey: .reportDevStatusMargin)
        }
        if targetPer != 0 {
            try encodeContainer.encode(targetPer, forKey: .targetPer)
        }
        if let ulBucketSize = self.ulBucketSize {
            try encodeContainer.encode(ulBucketSize, forKey: .ulBucketSize)
        }
        if let ulRate = self.ulRate {
            try encodeContainer.encode(ulRate, forKey: .ulRate)
        }
        if let ulRatePolicy = self.ulRatePolicy {
            try encodeContainer.encode(ulRatePolicy, forKey: .ulRatePolicy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ulRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ulRate)
        ulRate = ulRateDecoded
        let ulBucketSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ulBucketSize)
        ulBucketSize = ulBucketSizeDecoded
        let ulRatePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ulRatePolicy)
        ulRatePolicy = ulRatePolicyDecoded
        let dlRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dlRate)
        dlRate = dlRateDecoded
        let dlBucketSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dlBucketSize)
        dlBucketSize = dlBucketSizeDecoded
        let dlRatePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dlRatePolicy)
        dlRatePolicy = dlRatePolicyDecoded
        let addGwMetadataDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addGwMetadata) ?? false
        addGwMetadata = addGwMetadataDecoded
        let devStatusReqFreqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .devStatusReqFreq)
        devStatusReqFreq = devStatusReqFreqDecoded
        let reportDevStatusBatteryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .reportDevStatusBattery) ?? false
        reportDevStatusBattery = reportDevStatusBatteryDecoded
        let reportDevStatusMarginDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .reportDevStatusMargin) ?? false
        reportDevStatusMargin = reportDevStatusMarginDecoded
        let drMinDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .drMin) ?? 0
        drMin = drMinDecoded
        let drMaxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .drMax) ?? 0
        drMax = drMaxDecoded
        let channelMaskDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelMask)
        channelMask = channelMaskDecoded
        let prAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .prAllowed) ?? false
        prAllowed = prAllowedDecoded
        let hrAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hrAllowed) ?? false
        hrAllowed = hrAllowedDecoded
        let raAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .raAllowed) ?? false
        raAllowed = raAllowedDecoded
        let nwkGeoLocDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .nwkGeoLoc) ?? false
        nwkGeoLoc = nwkGeoLocDecoded
        let targetPerDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetPer) ?? 0
        targetPer = targetPerDecoded
        let minGwDiversityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minGwDiversity)
        minGwDiversity = minGwDiversityDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANGetServiceProfileInfo object.
    public struct LoRaWANGetServiceProfileInfo: Swift.Equatable {
        /// The AddGWMetaData value.
        public var addGwMetadata: Swift.Bool
        /// The ChannelMask value.
        public var channelMask: Swift.String?
        /// The DevStatusReqFreq value.
        public var devStatusReqFreq: Swift.Int?
        /// The DLBucketSize value.
        public var dlBucketSize: Swift.Int?
        /// The DLRate value.
        public var dlRate: Swift.Int?
        /// The DLRatePolicy value.
        public var dlRatePolicy: Swift.String?
        /// The DRMax value.
        public var drMax: Swift.Int
        /// The DRMin value.
        public var drMin: Swift.Int
        /// The HRAllowed value that describes whether handover roaming is allowed.
        public var hrAllowed: Swift.Bool
        /// The MinGwDiversity value.
        public var minGwDiversity: Swift.Int?
        /// The NwkGeoLoc value.
        public var nwkGeoLoc: Swift.Bool
        /// The PRAllowed value that describes whether passive roaming is allowed.
        public var prAllowed: Swift.Bool
        /// The RAAllowed value that describes whether roaming activation is allowed.
        public var raAllowed: Swift.Bool
        /// The ReportDevStatusBattery value.
        public var reportDevStatusBattery: Swift.Bool
        /// The ReportDevStatusMargin value.
        public var reportDevStatusMargin: Swift.Bool
        /// The TargetPER value.
        public var targetPer: Swift.Int
        /// The ULBucketSize value.
        public var ulBucketSize: Swift.Int?
        /// The ULRate value.
        public var ulRate: Swift.Int?
        /// The ULRatePolicy value.
        public var ulRatePolicy: Swift.String?

        public init(
            addGwMetadata: Swift.Bool = false,
            channelMask: Swift.String? = nil,
            devStatusReqFreq: Swift.Int? = nil,
            dlBucketSize: Swift.Int? = nil,
            dlRate: Swift.Int? = nil,
            dlRatePolicy: Swift.String? = nil,
            drMax: Swift.Int = 0,
            drMin: Swift.Int = 0,
            hrAllowed: Swift.Bool = false,
            minGwDiversity: Swift.Int? = nil,
            nwkGeoLoc: Swift.Bool = false,
            prAllowed: Swift.Bool = false,
            raAllowed: Swift.Bool = false,
            reportDevStatusBattery: Swift.Bool = false,
            reportDevStatusMargin: Swift.Bool = false,
            targetPer: Swift.Int = 0,
            ulBucketSize: Swift.Int? = nil,
            ulRate: Swift.Int? = nil,
            ulRatePolicy: Swift.String? = nil
        )
        {
            self.addGwMetadata = addGwMetadata
            self.channelMask = channelMask
            self.devStatusReqFreq = devStatusReqFreq
            self.dlBucketSize = dlBucketSize
            self.dlRate = dlRate
            self.dlRatePolicy = dlRatePolicy
            self.drMax = drMax
            self.drMin = drMin
            self.hrAllowed = hrAllowed
            self.minGwDiversity = minGwDiversity
            self.nwkGeoLoc = nwkGeoLoc
            self.prAllowed = prAllowed
            self.raAllowed = raAllowed
            self.reportDevStatusBattery = reportDevStatusBattery
            self.reportDevStatusMargin = reportDevStatusMargin
            self.targetPer = targetPer
            self.ulBucketSize = ulBucketSize
            self.ulRate = ulRate
            self.ulRatePolicy = ulRatePolicy
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devEuiEventTopic = "DevEuiEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devEuiEventTopic = self.devEuiEventTopic {
            try encodeContainer.encode(devEuiEventTopic.rawValue, forKey: .devEuiEventTopic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .devEuiEventTopic)
        devEuiEventTopic = devEuiEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Object for LoRaWAN join resource type event configuration.
    public struct LoRaWANJoinEventNotificationConfigurations: Swift.Equatable {
        /// Denotes whether the Dev EUI join event topic is enabled or disabled.
        public var devEuiEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            devEuiEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.devEuiEventTopic = devEuiEventTopic
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceEventTopic = "WirelessDeviceEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessDeviceEventTopic = self.wirelessDeviceEventTopic {
            try encodeContainer.encode(wirelessDeviceEventTopic.rawValue, forKey: .wirelessDeviceEventTopic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessDeviceEventTopic)
        wirelessDeviceEventTopic = wirelessDeviceEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Object for LoRaWAN join resource type event configuration.
    public struct LoRaWANJoinResourceTypeEventConfiguration: Swift.Equatable {
        /// Denotes whether the wireless device join event topic is enabled or disabled.
        public var wirelessDeviceEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            wirelessDeviceEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.wirelessDeviceEventTopic = wirelessDeviceEventTopic
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANListDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devEui = "DevEui"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devEui = self.devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devEui)
        devEui = devEuiDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWAN object for list functions.
    public struct LoRaWANListDevice: Swift.Equatable {
        /// The DevEUI value.
        public var devEui: Swift.String?

        public init(
            devEui: Swift.String? = nil
        )
        {
            self.devEui = devEui
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANMulticast: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dlClass = "DlClass"
        case rfRegion = "RfRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dlClass = self.dlClass {
            try encodeContainer.encode(dlClass.rawValue, forKey: .dlClass)
        }
        if let rfRegion = self.rfRegion {
            try encodeContainer.encode(rfRegion.rawValue, forKey: .rfRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rfRegionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SupportedRfRegion.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let dlClassDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DlClass.self, forKey: .dlClass)
        dlClass = dlClassDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The LoRaWAN information that is to be used with the multicast group.
    public struct LoRaWANMulticast: Swift.Equatable {
        /// DlClass for LoRaWAM, valid values are ClassB and ClassC.
        public var dlClass: IoTWirelessClientTypes.DlClass?
        /// Supported RfRegions
        public var rfRegion: IoTWirelessClientTypes.SupportedRfRegion?

        public init(
            dlClass: IoTWirelessClientTypes.DlClass? = nil,
            rfRegion: IoTWirelessClientTypes.SupportedRfRegion? = nil
        )
        {
            self.dlClass = dlClass
            self.rfRegion = rfRegion
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANMulticastGet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dlClass = "DlClass"
        case numberOfDevicesInGroup = "NumberOfDevicesInGroup"
        case numberOfDevicesRequested = "NumberOfDevicesRequested"
        case rfRegion = "RfRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dlClass = self.dlClass {
            try encodeContainer.encode(dlClass.rawValue, forKey: .dlClass)
        }
        if let numberOfDevicesInGroup = self.numberOfDevicesInGroup {
            try encodeContainer.encode(numberOfDevicesInGroup, forKey: .numberOfDevicesInGroup)
        }
        if let numberOfDevicesRequested = self.numberOfDevicesRequested {
            try encodeContainer.encode(numberOfDevicesRequested, forKey: .numberOfDevicesRequested)
        }
        if let rfRegion = self.rfRegion {
            try encodeContainer.encode(rfRegion.rawValue, forKey: .rfRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rfRegionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SupportedRfRegion.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let dlClassDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DlClass.self, forKey: .dlClass)
        dlClass = dlClassDecoded
        let numberOfDevicesRequestedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDevicesRequested)
        numberOfDevicesRequested = numberOfDevicesRequestedDecoded
        let numberOfDevicesInGroupDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDevicesInGroup)
        numberOfDevicesInGroup = numberOfDevicesInGroupDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The LoRaWAN information that is to be returned from getting multicast group information.
    public struct LoRaWANMulticastGet: Swift.Equatable {
        /// DlClass for LoRaWAM, valid values are ClassB and ClassC.
        public var dlClass: IoTWirelessClientTypes.DlClass?
        /// Number of devices that are associated to the multicast group.
        public var numberOfDevicesInGroup: Swift.Int?
        /// Number of devices that are requested to be associated with the multicast group.
        public var numberOfDevicesRequested: Swift.Int?
        /// Supported RfRegions
        public var rfRegion: IoTWirelessClientTypes.SupportedRfRegion?

        public init(
            dlClass: IoTWirelessClientTypes.DlClass? = nil,
            numberOfDevicesInGroup: Swift.Int? = nil,
            numberOfDevicesRequested: Swift.Int? = nil,
            rfRegion: IoTWirelessClientTypes.SupportedRfRegion? = nil
        )
        {
            self.dlClass = dlClass
            self.numberOfDevicesInGroup = numberOfDevicesInGroup
            self.numberOfDevicesRequested = numberOfDevicesRequested
            self.rfRegion = rfRegion
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANMulticastMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fPort = "FPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fPort = self.fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fPort)
        fPort = fPortDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The metadata information of the LoRaWAN multicast group.
    public struct LoRaWANMulticastMetadata: Swift.Equatable {
        /// The Fport value.
        public var fPort: Swift.Int?

        public init(
            fPort: Swift.Int? = nil
        )
        {
            self.fPort = fPort
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANMulticastSession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dlDr = "DlDr"
        case dlFreq = "DlFreq"
        case pingSlotPeriod = "PingSlotPeriod"
        case sessionStartTime = "SessionStartTime"
        case sessionTimeout = "SessionTimeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dlDr = self.dlDr {
            try encodeContainer.encode(dlDr, forKey: .dlDr)
        }
        if let dlFreq = self.dlFreq {
            try encodeContainer.encode(dlFreq, forKey: .dlFreq)
        }
        if let pingSlotPeriod = self.pingSlotPeriod {
            try encodeContainer.encode(pingSlotPeriod, forKey: .pingSlotPeriod)
        }
        if let sessionStartTime = self.sessionStartTime {
            try encodeContainer.encodeTimestamp(sessionStartTime, format: .dateTime, forKey: .sessionStartTime)
        }
        if let sessionTimeout = self.sessionTimeout {
            try encodeContainer.encode(sessionTimeout, forKey: .sessionTimeout)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dlDrDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dlDr)
        dlDr = dlDrDecoded
        let dlFreqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dlFreq)
        dlFreq = dlFreqDecoded
        let sessionStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sessionStartTime)
        sessionStartTime = sessionStartTimeDecoded
        let sessionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionTimeout)
        sessionTimeout = sessionTimeoutDecoded
        let pingSlotPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pingSlotPeriod)
        pingSlotPeriod = pingSlotPeriodDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The LoRaWAN information used with the multicast session.
    public struct LoRaWANMulticastSession: Swift.Equatable {
        /// Downlink data rate.
        public var dlDr: Swift.Int?
        /// Downlink frequency.
        public var dlFreq: Swift.Int?
        /// The PingSlotPeriod value.
        public var pingSlotPeriod: Swift.Int?
        /// Timestamp of when the multicast group session is to start.
        public var sessionStartTime: ClientRuntime.Date?
        /// How long before a multicast group session is to timeout.
        public var sessionTimeout: Swift.Int?

        public init(
            dlDr: Swift.Int? = nil,
            dlFreq: Swift.Int? = nil,
            pingSlotPeriod: Swift.Int? = nil,
            sessionStartTime: ClientRuntime.Date? = nil,
            sessionTimeout: Swift.Int? = nil
        )
        {
            self.dlDr = dlDr
            self.dlFreq = dlFreq
            self.pingSlotPeriod = pingSlotPeriod
            self.sessionStartTime = sessionStartTime
            self.sessionTimeout = sessionTimeout
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANSendDataToDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fPort = "FPort"
        case participatingGateways = "ParticipatingGateways"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fPort = self.fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
        if let participatingGateways = self.participatingGateways {
            try encodeContainer.encode(participatingGateways, forKey: .participatingGateways)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fPort)
        fPort = fPortDecoded
        let participatingGatewaysDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ParticipatingGateways.self, forKey: .participatingGateways)
        participatingGateways = participatingGatewaysDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWAN router info.
    public struct LoRaWANSendDataToDevice: Swift.Equatable {
        /// The Fport value.
        public var fPort: Swift.Int?
        /// Choose the gateways that you want to use for the downlink data traffic when the wireless device is running in class B or class C mode.
        public var participatingGateways: IoTWirelessClientTypes.ParticipatingGateways?

        public init(
            fPort: Swift.Int? = nil,
            participatingGateways: IoTWirelessClientTypes.ParticipatingGateways? = nil
        )
        {
            self.fPort = fPort
            self.participatingGateways = participatingGateways
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANServiceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addGwMetadata = "AddGwMetadata"
        case drMax = "DrMax"
        case drMin = "DrMin"
        case prAllowed = "PrAllowed"
        case raAllowed = "RaAllowed"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if addGwMetadata != false {
            try encodeContainer.encode(addGwMetadata, forKey: .addGwMetadata)
        }
        if let drMax = self.drMax {
            try encodeContainer.encode(drMax, forKey: .drMax)
        }
        if let drMin = self.drMin {
            try encodeContainer.encode(drMin, forKey: .drMin)
        }
        if prAllowed != false {
            try encodeContainer.encode(prAllowed, forKey: .prAllowed)
        }
        if raAllowed != false {
            try encodeContainer.encode(raAllowed, forKey: .raAllowed)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addGwMetadataDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addGwMetadata) ?? false
        addGwMetadata = addGwMetadataDecoded
        let drMinDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .drMin)
        drMin = drMinDecoded
        let drMaxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .drMax)
        drMax = drMaxDecoded
        let prAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .prAllowed) ?? false
        prAllowed = prAllowedDecoded
        let raAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .raAllowed) ?? false
        raAllowed = raAllowedDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANServiceProfile object.
    public struct LoRaWANServiceProfile: Swift.Equatable {
        /// The AddGWMetaData value.
        public var addGwMetadata: Swift.Bool
        /// The DrMax value.
        public var drMax: Swift.Int?
        /// The DrMin value.
        public var drMin: Swift.Int?
        /// The PRAllowed value that describes whether passive roaming is allowed.
        public var prAllowed: Swift.Bool
        /// The RAAllowed value that describes whether roaming activation is allowed.
        public var raAllowed: Swift.Bool

        public init(
            addGwMetadata: Swift.Bool = false,
            drMax: Swift.Int? = nil,
            drMin: Swift.Int? = nil,
            prAllowed: Swift.Bool = false,
            raAllowed: Swift.Bool = false
        )
        {
            self.addGwMetadata = addGwMetadata
            self.drMax = drMax
            self.drMin = drMin
            self.prAllowed = prAllowed
            self.raAllowed = raAllowed
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANStartFuotaTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The LoRaWAN information used to start a FUOTA task.
    public struct LoRaWANStartFuotaTask: Swift.Equatable {
        /// Start time of a FUOTA task.
        public var startTime: ClientRuntime.Date?

        public init(
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.startTime = startTime
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANUpdateDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abpV1_0_x = "AbpV1_0_x"
        case abpV1_1 = "AbpV1_1"
        case deviceProfileId = "DeviceProfileId"
        case fPorts = "FPorts"
        case serviceProfileId = "ServiceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abpV1_0_x = self.abpV1_0_x {
            try encodeContainer.encode(abpV1_0_x, forKey: .abpV1_0_x)
        }
        if let abpV1_1 = self.abpV1_1 {
            try encodeContainer.encode(abpV1_1, forKey: .abpV1_1)
        }
        if let deviceProfileId = self.deviceProfileId {
            try encodeContainer.encode(deviceProfileId, forKey: .deviceProfileId)
        }
        if let fPorts = self.fPorts {
            try encodeContainer.encode(fPorts, forKey: .fPorts)
        }
        if let serviceProfileId = self.serviceProfileId {
            try encodeContainer.encode(serviceProfileId, forKey: .serviceProfileId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceProfileId)
        deviceProfileId = deviceProfileIdDecoded
        let serviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProfileId)
        serviceProfileId = serviceProfileIdDecoded
        let abpV1_1Decoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.UpdateAbpV1_1.self, forKey: .abpV1_1)
        abpV1_1 = abpV1_1Decoded
        let abpV1_0_xDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.UpdateAbpV1_0_x.self, forKey: .abpV1_0_x)
        abpV1_0_x = abpV1_0_xDecoded
        let fPortsDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.UpdateFPorts.self, forKey: .fPorts)
        fPorts = fPortsDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWAN object for update functions.
    public struct LoRaWANUpdateDevice: Swift.Equatable {
        /// ABP device object for update APIs for v1.0.x
        public var abpV1_0_x: IoTWirelessClientTypes.UpdateAbpV1_0_x?
        /// ABP device object for update APIs for v1.1
        public var abpV1_1: IoTWirelessClientTypes.UpdateAbpV1_1?
        /// The ID of the device profile for the wireless device.
        public var deviceProfileId: Swift.String?
        /// FPorts object for the positioning information of the device.
        public var fPorts: IoTWirelessClientTypes.UpdateFPorts?
        /// The ID of the service profile.
        public var serviceProfileId: Swift.String?

        public init(
            abpV1_0_x: IoTWirelessClientTypes.UpdateAbpV1_0_x? = nil,
            abpV1_1: IoTWirelessClientTypes.UpdateAbpV1_1? = nil,
            deviceProfileId: Swift.String? = nil,
            fPorts: IoTWirelessClientTypes.UpdateFPorts? = nil,
            serviceProfileId: Swift.String? = nil
        )
        {
            self.abpV1_0_x = abpV1_0_x
            self.abpV1_1 = abpV1_1
            self.deviceProfileId = deviceProfileId
            self.fPorts = fPorts
            self.serviceProfileId = serviceProfileId
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case sigKeyCrc = "SigKeyCrc"
        case updateSignature = "UpdateSignature"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let sigKeyCrc = self.sigKeyCrc {
            try encodeContainer.encode(sigKeyCrc, forKey: .sigKeyCrc)
        }
        if let updateSignature = self.updateSignature {
            try encodeContainer.encode(updateSignature, forKey: .updateSignature)
        }
        if let updateVersion = self.updateVersion {
            try encodeContainer.encode(updateVersion, forKey: .updateVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateSignature)
        updateSignature = updateSignatureDecoded
        let sigKeyCrcDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sigKeyCrc)
        sigKeyCrc = sigKeyCrcDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let updateVersionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .updateVersion)
        updateVersion = updateVersionDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANUpdateGatewayTaskCreate object.
    public struct LoRaWANUpdateGatewayTaskCreate: Swift.Equatable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?
        /// The CRC of the signature private key to check.
        public var sigKeyCrc: Swift.Int?
        /// The signature used to verify the update firmware.
        public var updateSignature: Swift.String?
        /// The firmware version to update the gateway to.
        public var updateVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?

        public init(
            currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil,
            sigKeyCrc: Swift.Int? = nil,
            updateSignature: Swift.String? = nil,
            updateVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
            self.sigKeyCrc = sigKeyCrc
            self.updateSignature = updateSignature
            self.updateVersion = updateVersion
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let updateVersion = self.updateVersion {
            try encodeContainer.encode(updateVersion, forKey: .updateVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let updateVersionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .updateVersion)
        updateVersion = updateVersionDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANUpdateGatewayTaskEntry object.
    public struct LoRaWANUpdateGatewayTaskEntry: Swift.Equatable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?
        /// The firmware version to update the gateway to.
        public var updateVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?

        public init(
            currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil,
            updateVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
            self.updateVersion = updateVersion
        }
    }

}

extension IoTWirelessClientTypes {
    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    public enum LogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case error
        case info
        case sdkUnknown(Swift.String)

        public static var allCases: [LogLevel] {
            return [
                .disabled,
                .error,
                .info,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .error: return "ERROR"
            case .info: return "INFO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogLevel(rawValue: rawValue) ?? LogLevel.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.LteLocalId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case earfcn = "Earfcn"
        case pci = "Pci"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let earfcn = self.earfcn {
            try encodeContainer.encode(earfcn, forKey: .earfcn)
        }
        if let pci = self.pci {
            try encodeContainer.encode(pci, forKey: .pci)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pciDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pci)
        pci = pciDecoded
        let earfcnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .earfcn)
        earfcn = earfcnDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LTE local identification (local ID) information.
    public struct LteLocalId: Swift.Equatable {
        /// Evolved universal terrestrial radio access (E-UTRA) absolute radio frequency channel number (FCN).
        /// This member is required.
        public var earfcn: Swift.Int?
        /// Physical cell ID.
        /// This member is required.
        public var pci: Swift.Int?

        public init(
            earfcn: Swift.Int? = nil,
            pci: Swift.Int? = nil
        )
        {
            self.earfcn = earfcn
            self.pci = pci
        }
    }

}

extension IoTWirelessClientTypes.LteNmrObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case earfcn = "Earfcn"
        case eutranCid = "EutranCid"
        case pci = "Pci"
        case rsrp = "Rsrp"
        case rsrq = "Rsrq"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let earfcn = self.earfcn {
            try encodeContainer.encode(earfcn, forKey: .earfcn)
        }
        if let eutranCid = self.eutranCid {
            try encodeContainer.encode(eutranCid, forKey: .eutranCid)
        }
        if let pci = self.pci {
            try encodeContainer.encode(pci, forKey: .pci)
        }
        if let rsrp = self.rsrp {
            try encodeContainer.encode(rsrp, forKey: .rsrp)
        }
        if let rsrq = self.rsrq {
            try encodeContainer.encode(rsrq, forKey: .rsrq)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pciDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pci)
        pci = pciDecoded
        let earfcnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .earfcn)
        earfcn = earfcnDecoded
        let eutranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eutranCid)
        eutranCid = eutranCidDecoded
        let rsrpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rsrp)
        rsrp = rsrpDecoded
        let rsrqDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .rsrq)
        rsrq = rsrqDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LTE object for network measurement reports.
    public struct LteNmrObj: Swift.Equatable {
        /// E-UTRA (Evolved universal terrestrial Radio Access) absolute radio frequency channel Number (EARFCN).
        /// This member is required.
        public var earfcn: Swift.Int?
        /// E-UTRAN (Evolved Universal Terrestrial Radio Access Network) cell global identifier (EUTRANCID).
        /// This member is required.
        public var eutranCid: Swift.Int?
        /// Physical cell ID.
        /// This member is required.
        public var pci: Swift.Int?
        /// Signal power of the reference signal received, measured in dBm (decibel-milliwatts).
        public var rsrp: Swift.Int?
        /// Signal quality of the reference Signal received, measured in decibels (dB).
        public var rsrq: Swift.Float?

        public init(
            earfcn: Swift.Int? = nil,
            eutranCid: Swift.Int? = nil,
            pci: Swift.Int? = nil,
            rsrp: Swift.Int? = nil,
            rsrq: Swift.Float? = nil
        )
        {
            self.earfcn = earfcn
            self.eutranCid = eutranCid
            self.pci = pci
            self.rsrp = rsrp
            self.rsrq = rsrq
        }
    }

}

extension IoTWirelessClientTypes.LteObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eutranCid = "EutranCid"
        case lteLocalId = "LteLocalId"
        case lteNmr = "LteNmr"
        case lteTimingAdvance = "LteTimingAdvance"
        case mcc = "Mcc"
        case mnc = "Mnc"
        case nrCapable = "NrCapable"
        case rsrp = "Rsrp"
        case rsrq = "Rsrq"
        case tac = "Tac"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eutranCid = self.eutranCid {
            try encodeContainer.encode(eutranCid, forKey: .eutranCid)
        }
        if let lteLocalId = self.lteLocalId {
            try encodeContainer.encode(lteLocalId, forKey: .lteLocalId)
        }
        if let lteNmr = lteNmr {
            var lteNmrContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lteNmr)
            for ltenmrobj0 in lteNmr {
                try lteNmrContainer.encode(ltenmrobj0)
            }
        }
        if let lteTimingAdvance = self.lteTimingAdvance {
            try encodeContainer.encode(lteTimingAdvance, forKey: .lteTimingAdvance)
        }
        if let mcc = self.mcc {
            try encodeContainer.encode(mcc, forKey: .mcc)
        }
        if let mnc = self.mnc {
            try encodeContainer.encode(mnc, forKey: .mnc)
        }
        if nrCapable != false {
            try encodeContainer.encode(nrCapable, forKey: .nrCapable)
        }
        if let rsrp = self.rsrp {
            try encodeContainer.encode(rsrp, forKey: .rsrp)
        }
        if let rsrq = self.rsrq {
            try encodeContainer.encode(rsrq, forKey: .rsrq)
        }
        if let tac = self.tac {
            try encodeContainer.encode(tac, forKey: .tac)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mccDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mcc)
        mcc = mccDecoded
        let mncDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mnc)
        mnc = mncDecoded
        let eutranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eutranCid)
        eutranCid = eutranCidDecoded
        let tacDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tac)
        tac = tacDecoded
        let lteLocalIdDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LteLocalId.self, forKey: .lteLocalId)
        lteLocalId = lteLocalIdDecoded
        let lteTimingAdvanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lteTimingAdvance)
        lteTimingAdvance = lteTimingAdvanceDecoded
        let rsrpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rsrp)
        rsrp = rsrpDecoded
        let rsrqDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .rsrq)
        rsrq = rsrqDecoded
        let nrCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .nrCapable) ?? false
        nrCapable = nrCapableDecoded
        let lteNmrContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.LteNmrObj?].self, forKey: .lteNmr)
        var lteNmrDecoded0:[IoTWirelessClientTypes.LteNmrObj]? = nil
        if let lteNmrContainer = lteNmrContainer {
            lteNmrDecoded0 = [IoTWirelessClientTypes.LteNmrObj]()
            for structure0 in lteNmrContainer {
                if let structure0 = structure0 {
                    lteNmrDecoded0?.append(structure0)
                }
            }
        }
        lteNmr = lteNmrDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// LTE object.
    public struct LteObj: Swift.Equatable {
        /// E-UTRAN (Evolved Universal Terrestrial Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var eutranCid: Swift.Int?
        /// LTE local identification (local ID) information.
        public var lteLocalId: IoTWirelessClientTypes.LteLocalId?
        /// LTE object for network measurement reports.
        public var lteNmr: [IoTWirelessClientTypes.LteNmrObj]?
        /// LTE timing advance.
        public var lteTimingAdvance: Swift.Int?
        /// Mobile Country Code.
        /// This member is required.
        public var mcc: Swift.Int?
        /// Mobile Network Code.
        /// This member is required.
        public var mnc: Swift.Int?
        /// Parameter that determines whether the LTE object is capable of supporting NR (new radio).
        public var nrCapable: Swift.Bool
        /// Signal power of the reference signal received, measured in dBm (decibel-milliwatts).
        public var rsrp: Swift.Int?
        /// Signal quality of the reference Signal received, measured in decibels (dB).
        public var rsrq: Swift.Float?
        /// LTE tracking area code.
        public var tac: Swift.Int?

        public init(
            eutranCid: Swift.Int? = nil,
            lteLocalId: IoTWirelessClientTypes.LteLocalId? = nil,
            lteNmr: [IoTWirelessClientTypes.LteNmrObj]? = nil,
            lteTimingAdvance: Swift.Int? = nil,
            mcc: Swift.Int? = nil,
            mnc: Swift.Int? = nil,
            nrCapable: Swift.Bool = false,
            rsrp: Swift.Int? = nil,
            rsrq: Swift.Float? = nil,
            tac: Swift.Int? = nil
        )
        {
            self.eutranCid = eutranCid
            self.lteLocalId = lteLocalId
            self.lteNmr = lteNmr
            self.lteTimingAdvance = lteTimingAdvance
            self.mcc = mcc
            self.mnc = mnc
            self.nrCapable = nrCapable
            self.rsrp = rsrp
            self.rsrq = rsrq
            self.tac = tac
        }
    }

}

extension IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
        case wirelessDeviceIdEventTopic = "WirelessDeviceIdEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let wirelessDeviceIdEventTopic = self.wirelessDeviceIdEventTopic {
            try encodeContainer.encode(wirelessDeviceIdEventTopic.rawValue, forKey: .wirelessDeviceIdEventTopic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkEventNotificationConfigurations.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let wirelessDeviceIdEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessDeviceIdEventTopic)
        wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Message delivery status event configuration object for enabling and disabling relevant topics.
    public struct MessageDeliveryStatusEventConfiguration: Swift.Equatable {
        /// SidewalkEventNotificationConfigurations object, which is the event configuration object for Sidewalk-related event topics.
        public var sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations?
        /// Denotes whether the wireless device ID message delivery status event topic is enabled or disabled.
        public var wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations? = nil,
            wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.sidewalk = sidewalk
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }
    }

}

extension IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Message delivery status resource type event configuration object for enabling or disabling relevant topic.
    public struct MessageDeliveryStatusResourceTypeEventConfiguration: Swift.Equatable {
        /// Sidewalk resource type event configuration object for enabling or disabling topic.
        public var sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration?

        public init(
            sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration? = nil
        )
        {
            self.sidewalk = sidewalk
        }
    }

}

extension IoTWirelessClientTypes {
    /// Sidewalk device message type. Default value is CUSTOM_COMMAND_ID_NOTIFY.
    public enum MessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customCommandIdGet
        case customCommandIdNotify
        case customCommandIdResp
        case customCommandIdSet
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .customCommandIdGet,
                .customCommandIdNotify,
                .customCommandIdResp,
                .customCommandIdSet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customCommandIdGet: return "CUSTOM_COMMAND_ID_GET"
            case .customCommandIdNotify: return "CUSTOM_COMMAND_ID_NOTIFY"
            case .customCommandIdResp: return "CUSTOM_COMMAND_ID_RESP"
            case .customCommandIdSet: return "CUSTOM_COMMAND_ID_SET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    /// FrameInfo of your multicast group resources for the trace content. Use FrameInfo to debug the multicast communication between your LoRaWAN end devices and the network server.
    public enum MulticastFrameInfo: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MulticastFrameInfo] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MulticastFrameInfo(rawValue: rawValue) ?? MulticastFrameInfo.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.MulticastGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IoTWirelessClientTypes {
    /// A multicast group.
    public struct MulticastGroup: Swift.Equatable {
        /// The arn of the multicast group.
        public var arn: Swift.String?
        /// The ID of the multicast group.
        public var id: Swift.String?
        /// The name of the multicast group.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension IoTWirelessClientTypes.MulticastGroupByFuotaTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTWirelessClientTypes {
    /// A multicast group that is associated with a FUOTA task.
    public struct MulticastGroupByFuotaTask: Swift.Equatable {
        /// The ID of the multicast group.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IoTWirelessClientTypes.MulticastWirelessMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANMulticastMetadata.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Wireless metadata that is to be sent to multicast group.
    public struct MulticastWirelessMetadata: Swift.Equatable {
        /// The metadata information of the LoRaWAN multicast group.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastMetadata?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastMetadata? = nil
        )
        {
            self.loRaWAN = loRaWAN
        }
    }

}

extension IoTWirelessClientTypes.NetworkAnalyzerConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Network analyzer configurations.
    public struct NetworkAnalyzerConfigurations: Swift.Equatable {
        /// The Amazon Resource Name of the new resource.
        public var arn: Swift.String?
        /// Name of the network analyzer configuration.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension IoTWirelessClientTypes {
    public enum OnboardStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case initialized
        case onboarded
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [OnboardStatus] {
            return [
                .failed,
                .initialized,
                .onboarded,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .initialized: return "INITIALIZED"
            case .onboarded: return "ONBOARDED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OnboardStatus(rawValue: rawValue) ?? OnboardStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.OtaaV1_0_x: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appEui = "AppEui"
        case appKey = "AppKey"
        case genAppKey = "GenAppKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appEui = self.appEui {
            try encodeContainer.encode(appEui, forKey: .appEui)
        }
        if let appKey = self.appKey {
            try encodeContainer.encode(appKey, forKey: .appKey)
        }
        if let genAppKey = self.genAppKey {
            try encodeContainer.encode(genAppKey, forKey: .genAppKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appKey)
        appKey = appKeyDecoded
        let appEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appEui)
        appEui = appEuiDecoded
        let genAppKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .genAppKey)
        genAppKey = genAppKeyDecoded
    }
}

extension IoTWirelessClientTypes {
    /// OTAA device object for v1.0.x
    public struct OtaaV1_0_x: Swift.Equatable {
        /// The AppEUI value.
        public var appEui: Swift.String?
        /// The AppKey value.
        public var appKey: Swift.String?
        /// The GenAppKey value.
        public var genAppKey: Swift.String?

        public init(
            appEui: Swift.String? = nil,
            appKey: Swift.String? = nil,
            genAppKey: Swift.String? = nil
        )
        {
            self.appEui = appEui
            self.appKey = appKey
            self.genAppKey = genAppKey
        }
    }

}

extension IoTWirelessClientTypes.OtaaV1_1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appKey = "AppKey"
        case joinEui = "JoinEui"
        case nwkKey = "NwkKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appKey = self.appKey {
            try encodeContainer.encode(appKey, forKey: .appKey)
        }
        if let joinEui = self.joinEui {
            try encodeContainer.encode(joinEui, forKey: .joinEui)
        }
        if let nwkKey = self.nwkKey {
            try encodeContainer.encode(nwkKey, forKey: .nwkKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appKey)
        appKey = appKeyDecoded
        let nwkKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nwkKey)
        nwkKey = nwkKeyDecoded
        let joinEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .joinEui)
        joinEui = joinEuiDecoded
    }
}

extension IoTWirelessClientTypes {
    /// OTAA device object for v1.1
    public struct OtaaV1_1: Swift.Equatable {
        /// The AppKey value.
        public var appKey: Swift.String?
        /// The JoinEUI value.
        public var joinEui: Swift.String?
        /// The NwkKey value.
        public var nwkKey: Swift.String?

        public init(
            appKey: Swift.String? = nil,
            joinEui: Swift.String? = nil,
            nwkKey: Swift.String? = nil
        )
        {
            self.appKey = appKey
            self.joinEui = joinEui
            self.nwkKey = nwkKey
        }
    }

}

extension IoTWirelessClientTypes.ParticipatingGateways: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downlinkMode = "DownlinkMode"
        case gatewayList = "GatewayList"
        case transmissionInterval = "TransmissionInterval"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downlinkMode = self.downlinkMode {
            try encodeContainer.encode(downlinkMode.rawValue, forKey: .downlinkMode)
        }
        if let gatewayList = gatewayList {
            var gatewayListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gatewayList)
            for gatewaylistitem0 in gatewayList {
                try gatewayListContainer.encode(gatewaylistitem0)
            }
        }
        if let transmissionInterval = self.transmissionInterval {
            try encodeContainer.encode(transmissionInterval, forKey: .transmissionInterval)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let downlinkModeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DownlinkMode.self, forKey: .downlinkMode)
        downlinkMode = downlinkModeDecoded
        let gatewayListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.GatewayListItem?].self, forKey: .gatewayList)
        var gatewayListDecoded0:[IoTWirelessClientTypes.GatewayListItem]? = nil
        if let gatewayListContainer = gatewayListContainer {
            gatewayListDecoded0 = [IoTWirelessClientTypes.GatewayListItem]()
            for structure0 in gatewayListContainer {
                if let structure0 = structure0 {
                    gatewayListDecoded0?.append(structure0)
                }
            }
        }
        gatewayList = gatewayListDecoded0
        let transmissionIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .transmissionInterval)
        transmissionInterval = transmissionIntervalDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Specify the list of gateways to which you want to send downlink data traffic when the wireless device is running in class B or class C mode.
    public struct ParticipatingGateways: Swift.Equatable {
        /// Indicates whether to send the downlink message in sequential mode or concurrent mode, or to use only the chosen gateways from the previous uplink message transmission.
        /// This member is required.
        public var downlinkMode: IoTWirelessClientTypes.DownlinkMode?
        /// The list of gateways that you want to use for sending the downlink data traffic.
        /// This member is required.
        public var gatewayList: [IoTWirelessClientTypes.GatewayListItem]?
        /// The duration of time for which AWS IoT Core for LoRaWAN will wait before transmitting the payload to the next gateway.
        /// This member is required.
        public var transmissionInterval: Swift.Int?

        public init(
            downlinkMode: IoTWirelessClientTypes.DownlinkMode? = nil,
            gatewayList: [IoTWirelessClientTypes.GatewayListItem]? = nil,
            transmissionInterval: Swift.Int? = nil
        )
        {
            self.downlinkMode = downlinkMode
            self.gatewayList = gatewayList
            self.transmissionInterval = transmissionInterval
        }
    }

}

extension IoTWirelessClientTypes {
    public enum PartnerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [PartnerType] {
            return [
                .sidewalk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PartnerType(rawValue: rawValue) ?? PartnerType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum PositionConfigurationFec: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case rose
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionConfigurationFec] {
            return [
                .none,
                .rose,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .rose: return "ROSE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PositionConfigurationFec(rawValue: rawValue) ?? PositionConfigurationFec.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.PositionConfigurationItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case resourceIdentifier = "ResourceIdentifier"
        case resourceType = "ResourceType"
        case solvers = "Solvers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let solvers = self.solvers {
            try encodeContainer.encode(solvers, forKey: .solvers)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let solversDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionSolverDetails.self, forKey: .solvers)
        solvers = solversDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The wrapper for a position configuration.
    public struct PositionConfigurationItem: Swift.Equatable {
        /// The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
        public var destination: Swift.String?
        /// Resource identifier for the position configuration.
        public var resourceIdentifier: Swift.String?
        /// Resource type of the resource for the position configuration.
        public var resourceType: IoTWirelessClientTypes.PositionResourceType?
        /// The details of the positioning solver object used to compute the location.
        public var solvers: IoTWirelessClientTypes.PositionSolverDetails?

        public init(
            destination: Swift.String? = nil,
            resourceIdentifier: Swift.String? = nil,
            resourceType: IoTWirelessClientTypes.PositionResourceType? = nil,
            solvers: IoTWirelessClientTypes.PositionSolverDetails? = nil
        )
        {
            self.destination = destination
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
            self.solvers = solvers
        }
    }

}

extension IoTWirelessClientTypes {
    public enum PositionConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionConfigurationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PositionConfigurationStatus(rawValue: rawValue) ?? PositionConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum PositionResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case wirelessdevice
        case wirelessgateway
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionResourceType] {
            return [
                .wirelessdevice,
                .wirelessgateway,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .wirelessdevice: return "WirelessDevice"
            case .wirelessgateway: return "WirelessGateway"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PositionResourceType(rawValue: rawValue) ?? PositionResourceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.PositionSolverConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case semtechGnss = "SemtechGnss"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let semtechGnss = self.semtechGnss {
            try encodeContainer.encode(semtechGnss, forKey: .semtechGnss)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let semtechGnssDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SemtechGnssConfiguration.self, forKey: .semtechGnss)
        semtechGnss = semtechGnssDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The wrapper for position solver configurations.
    public struct PositionSolverConfigurations: Swift.Equatable {
        /// The Semtech GNSS solver configuration object.
        public var semtechGnss: IoTWirelessClientTypes.SemtechGnssConfiguration?

        public init(
            semtechGnss: IoTWirelessClientTypes.SemtechGnssConfiguration? = nil
        )
        {
            self.semtechGnss = semtechGnss
        }
    }

}

extension IoTWirelessClientTypes.PositionSolverDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case semtechGnss = "SemtechGnss"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let semtechGnss = self.semtechGnss {
            try encodeContainer.encode(semtechGnss, forKey: .semtechGnss)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let semtechGnssDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SemtechGnssDetail.self, forKey: .semtechGnss)
        semtechGnss = semtechGnssDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The wrapper for position solver details.
    public struct PositionSolverDetails: Swift.Equatable {
        /// The Semtech GNSS solver object details.
        public var semtechGnss: IoTWirelessClientTypes.SemtechGnssDetail?

        public init(
            semtechGnss: IoTWirelessClientTypes.SemtechGnssDetail? = nil
        )
        {
            self.semtechGnss = semtechGnss
        }
    }

}

extension IoTWirelessClientTypes {
    public enum PositionSolverProvider: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case semtech
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionSolverProvider] {
            return [
                .semtech,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .semtech: return "Semtech"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PositionSolverProvider(rawValue: rawValue) ?? PositionSolverProvider.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum PositionSolverType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gnss
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionSolverType] {
            return [
                .gnss,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gnss: return "GNSS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PositionSolverType(rawValue: rawValue) ?? PositionSolverType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.Positioning: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clockSync = "ClockSync"
        case gnss = "Gnss"
        case stream = "Stream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clockSync = self.clockSync {
            try encodeContainer.encode(clockSync, forKey: .clockSync)
        }
        if let gnss = self.gnss {
            try encodeContainer.encode(gnss, forKey: .gnss)
        }
        if let stream = self.stream {
            try encodeContainer.encode(stream, forKey: .stream)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clockSyncDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clockSync)
        clockSync = clockSyncDecoded
        let streamDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stream)
        stream = streamDecoded
        let gnssDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gnss)
        gnss = gnssDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The FPorts for the position information.
    public struct Positioning: Swift.Equatable {
        /// The Fport value.
        public var clockSync: Swift.Int?
        /// The Fport value.
        public var gnss: Swift.Int?
        /// The Fport value.
        public var stream: Swift.Int?

        public init(
            clockSync: Swift.Int? = nil,
            gnss: Swift.Int? = nil,
            stream: Swift.Int? = nil
        )
        {
            self.clockSync = clockSync
            self.gnss = gnss
            self.stream = stream
        }
    }

}

extension IoTWirelessClientTypes {
    public enum PositioningConfigStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PositioningConfigStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PositioningConfigStatus(rawValue: rawValue) ?? PositioningConfigStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.ProximityEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
        case wirelessDeviceIdEventTopic = "WirelessDeviceIdEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let wirelessDeviceIdEventTopic = self.wirelessDeviceIdEventTopic {
            try encodeContainer.encode(wirelessDeviceIdEventTopic.rawValue, forKey: .wirelessDeviceIdEventTopic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkEventNotificationConfigurations.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let wirelessDeviceIdEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessDeviceIdEventTopic)
        wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Proximity event configuration object for enabling and disabling relevant topics.
    public struct ProximityEventConfiguration: Swift.Equatable {
        /// Proximity event configuration object for enabling or disabling Sidewalk related event topics.
        public var sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations?
        /// Denotes whether the wireless device ID proximity event topic is enabled or disabled.
        public var wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations? = nil,
            wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.sidewalk = sidewalk
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }
    }

}

extension IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Proximity resource type event configuration object for enabling or disabling topic.
    public struct ProximityResourceTypeEventConfiguration: Swift.Equatable {
        /// Proximity resource type event configuration object for enabling and disabling wireless device topic.
        public var sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration?

        public init(
            sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration? = nil
        )
        {
            self.sidewalk = sidewalk
        }
    }

}

extension PutPositionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case solvers = "Solvers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let solvers = self.solvers {
            try encodeContainer.encode(solvers, forKey: .solvers)
        }
    }
}

extension PutPositionConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension PutPositionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/position-configurations/\(resourceIdentifier.urlPercentEncoding())"
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct PutPositionConfigurationInput: Swift.Equatable {
    /// The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
    public var destination: Swift.String?
    /// Resource identifier used to update the position configuration.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// Resource type of the resource for which you want to update the position configuration.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?
    /// The positioning solvers used to update the position configuration of the resource.
    public var solvers: IoTWirelessClientTypes.PositionSolverConfigurations?

    public init(
        destination: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil,
        solvers: IoTWirelessClientTypes.PositionSolverConfigurations? = nil
    )
    {
        self.destination = destination
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
        self.solvers = solvers
    }
}

struct PutPositionConfigurationInputBody: Swift.Equatable {
    let solvers: IoTWirelessClientTypes.PositionSolverConfigurations?
    let destination: Swift.String?
}

extension PutPositionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case solvers = "Solvers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solversDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionSolverConfigurations.self, forKey: .solvers)
        solvers = solversDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension PutPositionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct PutPositionConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutPositionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutResourceLogLevelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }
}

extension PutResourceLogLevelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension PutResourceLogLevelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct PutResourceLogLevelInput: Swift.Equatable {
    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    /// This member is required.
    public var logLevel: IoTWirelessClientTypes.LogLevel?
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway, it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        logLevel: IoTWirelessClientTypes.LogLevel? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.logLevel = logLevel
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct PutResourceLogLevelInputBody: Swift.Equatable {
    let logLevel: IoTWirelessClientTypes.LogLevel?
}

extension PutResourceLogLevelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension PutResourceLogLevelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutResourceLogLevelOutput: Swift.Equatable {

    public init() { }
}

enum PutResourceLogLevelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResetAllResourceLogLevelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/log-levels"
    }
}

public struct ResetAllResourceLogLevelsInput: Swift.Equatable {

    public init() { }
}

struct ResetAllResourceLogLevelsInputBody: Swift.Equatable {
}

extension ResetAllResourceLogLevelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ResetAllResourceLogLevelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ResetAllResourceLogLevelsOutput: Swift.Equatable {

    public init() { }
}

enum ResetAllResourceLogLevelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResetResourceLogLevelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension ResetResourceLogLevelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct ResetResourceLogLevelInput: Swift.Equatable {
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway, it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct ResetResourceLogLevelInputBody: Swift.Equatable {
}

extension ResetResourceLogLevelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ResetResourceLogLevelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ResetResourceLogLevelOutput: Swift.Equatable {

    public init() { }
}

enum ResetResourceLogLevelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Id of the not found resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the font found resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension IoTWirelessClientTypes.SemtechGnssConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fec = "Fec"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fec = self.fec {
            try encodeContainer.encode(fec.rawValue, forKey: .fec)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let fecDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionConfigurationFec.self, forKey: .fec)
        fec = fecDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about the Semtech GNSS solver configuration.
    public struct SemtechGnssConfiguration: Swift.Equatable {
        /// Whether forward error correction is enabled.
        /// This member is required.
        public var fec: IoTWirelessClientTypes.PositionConfigurationFec?
        /// The status indicating whether the solver is enabled.
        /// This member is required.
        public var status: IoTWirelessClientTypes.PositionConfigurationStatus?

        public init(
            fec: IoTWirelessClientTypes.PositionConfigurationFec? = nil,
            status: IoTWirelessClientTypes.PositionConfigurationStatus? = nil
        )
        {
            self.fec = fec
            self.status = status
        }
    }

}

extension IoTWirelessClientTypes.SemtechGnssDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fec = "Fec"
        case provider = "Provider"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fec = self.fec {
            try encodeContainer.encode(fec.rawValue, forKey: .fec)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionSolverProvider.self, forKey: .provider)
        provider = providerDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionSolverType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let fecDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionConfigurationFec.self, forKey: .fec)
        fec = fecDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Details of the Semtech GNSS solver object.
    public struct SemtechGnssDetail: Swift.Equatable {
        /// Whether forward error correction is enabled.
        public var fec: IoTWirelessClientTypes.PositionConfigurationFec?
        /// The vendor of the solver object.
        public var provider: IoTWirelessClientTypes.PositionSolverProvider?
        /// The status indicating whether the solver is enabled.
        public var status: IoTWirelessClientTypes.PositionConfigurationStatus?
        /// The type of positioning solver used.
        public var type: IoTWirelessClientTypes.PositionSolverType?

        public init(
            fec: IoTWirelessClientTypes.PositionConfigurationFec? = nil,
            provider: IoTWirelessClientTypes.PositionSolverProvider? = nil,
            status: IoTWirelessClientTypes.PositionConfigurationStatus? = nil,
            type: IoTWirelessClientTypes.PositionSolverType? = nil
        )
        {
            self.fec = fec
            self.provider = provider
            self.status = status
            self.type = type
        }
    }

}

extension SendDataToMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadData = "PayloadData"
        case wirelessMetadata = "WirelessMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payloadData = self.payloadData {
            try encodeContainer.encode(payloadData, forKey: .payloadData)
        }
        if let wirelessMetadata = self.wirelessMetadata {
            try encodeContainer.encode(wirelessMetadata, forKey: .wirelessMetadata)
        }
    }
}

extension SendDataToMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/data"
    }
}

public struct SendDataToMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The binary to be sent to the end device, encoded in base64.
    /// This member is required.
    public var payloadData: Swift.String?
    /// Wireless metadata that is to be sent to multicast group.
    /// This member is required.
    public var wirelessMetadata: IoTWirelessClientTypes.MulticastWirelessMetadata?

    public init(
        id: Swift.String? = nil,
        payloadData: Swift.String? = nil,
        wirelessMetadata: IoTWirelessClientTypes.MulticastWirelessMetadata? = nil
    )
    {
        self.id = id
        self.payloadData = payloadData
        self.wirelessMetadata = wirelessMetadata
    }
}

struct SendDataToMulticastGroupInputBody: Swift.Equatable {
    let payloadData: Swift.String?
    let wirelessMetadata: IoTWirelessClientTypes.MulticastWirelessMetadata?
}

extension SendDataToMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadData = "PayloadData"
        case wirelessMetadata = "WirelessMetadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadData)
        payloadData = payloadDataDecoded
        let wirelessMetadataDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MulticastWirelessMetadata.self, forKey: .wirelessMetadata)
        wirelessMetadata = wirelessMetadataDecoded
    }
}

extension SendDataToMulticastGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendDataToMulticastGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

public struct SendDataToMulticastGroupOutput: Swift.Equatable {
    /// ID of a multicast group message.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendDataToMulticastGroupOutputBody: Swift.Equatable {
    let messageId: Swift.String?
}

extension SendDataToMulticastGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

enum SendDataToMulticastGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SendDataToWirelessDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadData = "PayloadData"
        case transmitMode = "TransmitMode"
        case wirelessMetadata = "WirelessMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payloadData = self.payloadData {
            try encodeContainer.encode(payloadData, forKey: .payloadData)
        }
        if let transmitMode = self.transmitMode {
            try encodeContainer.encode(transmitMode, forKey: .transmitMode)
        }
        if let wirelessMetadata = self.wirelessMetadata {
            try encodeContainer.encode(wirelessMetadata, forKey: .wirelessMetadata)
        }
    }
}

extension SendDataToWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/data"
    }
}

public struct SendDataToWirelessDeviceInput: Swift.Equatable {
    /// The ID of the wireless device to receive the data.
    /// This member is required.
    public var id: Swift.String?
    /// The binary to be sent to the end device, encoded in base64.
    /// This member is required.
    public var payloadData: Swift.String?
    /// The transmit mode to use to send data to the wireless device. Can be: 0 for UM (unacknowledge mode) or 1 for AM (acknowledge mode).
    /// This member is required.
    public var transmitMode: Swift.Int?
    /// Metadata about the message request.
    public var wirelessMetadata: IoTWirelessClientTypes.WirelessMetadata?

    public init(
        id: Swift.String? = nil,
        payloadData: Swift.String? = nil,
        transmitMode: Swift.Int? = nil,
        wirelessMetadata: IoTWirelessClientTypes.WirelessMetadata? = nil
    )
    {
        self.id = id
        self.payloadData = payloadData
        self.transmitMode = transmitMode
        self.wirelessMetadata = wirelessMetadata
    }
}

struct SendDataToWirelessDeviceInputBody: Swift.Equatable {
    let transmitMode: Swift.Int?
    let payloadData: Swift.String?
    let wirelessMetadata: IoTWirelessClientTypes.WirelessMetadata?
}

extension SendDataToWirelessDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadData = "PayloadData"
        case transmitMode = "TransmitMode"
        case wirelessMetadata = "WirelessMetadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transmitModeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .transmitMode)
        transmitMode = transmitModeDecoded
        let payloadDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadData)
        payloadData = payloadDataDecoded
        let wirelessMetadataDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessMetadata.self, forKey: .wirelessMetadata)
        wirelessMetadata = wirelessMetadataDecoded
    }
}

extension SendDataToWirelessDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendDataToWirelessDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

public struct SendDataToWirelessDeviceOutput: Swift.Equatable {
    /// The ID of the message sent to the wireless device.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendDataToWirelessDeviceOutputBody: Swift.Equatable {
    let messageId: Swift.String?
}

extension SendDataToWirelessDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

enum SendDataToWirelessDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTWirelessClientTypes.ServiceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about a service profile.
    public struct ServiceProfile: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the service profile.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension IoTWirelessClientTypes.SessionKeysAbpV1_0_x: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSKey = "AppSKey"
        case nwkSKey = "NwkSKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appSKey = self.appSKey {
            try encodeContainer.encode(appSKey, forKey: .appSKey)
        }
        if let nwkSKey = self.nwkSKey {
            try encodeContainer.encode(nwkSKey, forKey: .nwkSKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nwkSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nwkSKey)
        nwkSKey = nwkSKeyDecoded
        let appSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appSKey)
        appSKey = appSKeyDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Session keys for ABP v1.1
    public struct SessionKeysAbpV1_0_x: Swift.Equatable {
        /// The AppSKey value.
        public var appSKey: Swift.String?
        /// The NwkSKey value.
        public var nwkSKey: Swift.String?

        public init(
            appSKey: Swift.String? = nil,
            nwkSKey: Swift.String? = nil
        )
        {
            self.appSKey = appSKey
            self.nwkSKey = nwkSKey
        }
    }

}

extension IoTWirelessClientTypes.SessionKeysAbpV1_1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSKey = "AppSKey"
        case fNwkSIntKey = "FNwkSIntKey"
        case nwkSEncKey = "NwkSEncKey"
        case sNwkSIntKey = "SNwkSIntKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appSKey = self.appSKey {
            try encodeContainer.encode(appSKey, forKey: .appSKey)
        }
        if let fNwkSIntKey = self.fNwkSIntKey {
            try encodeContainer.encode(fNwkSIntKey, forKey: .fNwkSIntKey)
        }
        if let nwkSEncKey = self.nwkSEncKey {
            try encodeContainer.encode(nwkSEncKey, forKey: .nwkSEncKey)
        }
        if let sNwkSIntKey = self.sNwkSIntKey {
            try encodeContainer.encode(sNwkSIntKey, forKey: .sNwkSIntKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fNwkSIntKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fNwkSIntKey)
        fNwkSIntKey = fNwkSIntKeyDecoded
        let sNwkSIntKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sNwkSIntKey)
        sNwkSIntKey = sNwkSIntKeyDecoded
        let nwkSEncKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nwkSEncKey)
        nwkSEncKey = nwkSEncKeyDecoded
        let appSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appSKey)
        appSKey = appSKeyDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Session keys for ABP v1.1
    public struct SessionKeysAbpV1_1: Swift.Equatable {
        /// The AppSKey value.
        public var appSKey: Swift.String?
        /// The FNwkSIntKey value.
        public var fNwkSIntKey: Swift.String?
        /// The NwkSEncKey value.
        public var nwkSEncKey: Swift.String?
        /// The SNwkSIntKey value.
        public var sNwkSIntKey: Swift.String?

        public init(
            appSKey: Swift.String? = nil,
            fNwkSIntKey: Swift.String? = nil,
            nwkSEncKey: Swift.String? = nil,
            sNwkSIntKey: Swift.String? = nil
        )
        {
            self.appSKey = appSKey
            self.fNwkSIntKey = fNwkSIntKey
            self.nwkSEncKey = nwkSEncKey
            self.sNwkSIntKey = sNwkSIntKey
        }
    }

}

extension IoTWirelessClientTypes.SidewalkAccountInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case appServerPrivateKey = "AppServerPrivateKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = self.amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let appServerPrivateKey = self.appServerPrivateKey {
            try encodeContainer.encode(appServerPrivateKey, forKey: .appServerPrivateKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let appServerPrivateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appServerPrivateKey)
        appServerPrivateKey = appServerPrivateKeyDecoded
    }
}

extension IoTWirelessClientTypes.SidewalkAccountInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkAccountInfo(amazonId: \(Swift.String(describing: amazonId)), appServerPrivateKey: \"CONTENT_REDACTED\")"}
}

extension IoTWirelessClientTypes {
    /// Information about a Sidewalk account.
    public struct SidewalkAccountInfo: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The Sidewalk application server private key.
        public var appServerPrivateKey: Swift.String?

        public init(
            amazonId: Swift.String? = nil,
            appServerPrivateKey: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.appServerPrivateKey = appServerPrivateKey
        }
    }

}

extension IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case arn = "Arn"
        case fingerprint = "Fingerprint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = self.amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let fingerprint = self.fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkAccountInfoWithFingerprint(amazonId: \(Swift.String(describing: amazonId)), arn: \(Swift.String(describing: arn)), fingerprint: \"CONTENT_REDACTED\")"}
}

extension IoTWirelessClientTypes {
    /// Information about a Sidewalk account.
    public struct SidewalkAccountInfoWithFingerprint: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The fingerprint of the Sidewalk application server private key.
        public var fingerprint: Swift.String?

        public init(
            amazonId: Swift.String? = nil,
            arn: Swift.String? = nil,
            fingerprint: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.arn = arn
            self.fingerprint = fingerprint
        }
    }

}

extension IoTWirelessClientTypes.SidewalkCreateDeviceProfile: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension IoTWirelessClientTypes {
    /// Sidewalk object for creating a device profile.
    public struct SidewalkCreateDeviceProfile: Swift.Equatable {

        public init() { }
    }

}

extension IoTWirelessClientTypes.SidewalkCreateWirelessDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceProfileId = "DeviceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceProfileId = self.deviceProfileId {
            try encodeContainer.encode(deviceProfileId, forKey: .deviceProfileId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceProfileId)
        deviceProfileId = deviceProfileIdDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Sidewalk object for creating a wireless device.
    public struct SidewalkCreateWirelessDevice: Swift.Equatable {
        /// The ID of the Sidewalk device profile.
        public var deviceProfileId: Swift.String?

        public init(
            deviceProfileId: Swift.String? = nil
        )
        {
            self.deviceProfileId = deviceProfileId
        }
    }

}

extension IoTWirelessClientTypes.SidewalkDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case certificateId = "CertificateId"
        case deviceCertificates = "DeviceCertificates"
        case deviceProfileId = "DeviceProfileId"
        case privateKeys = "PrivateKeys"
        case sidewalkId = "SidewalkId"
        case sidewalkManufacturingSn = "SidewalkManufacturingSn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = self.amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let deviceCertificates = deviceCertificates {
            var deviceCertificatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceCertificates)
            for certificatelist0 in deviceCertificates {
                try deviceCertificatesContainer.encode(certificatelist0)
            }
        }
        if let deviceProfileId = self.deviceProfileId {
            try encodeContainer.encode(deviceProfileId, forKey: .deviceProfileId)
        }
        if let privateKeys = privateKeys {
            var privateKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateKeys)
            for certificatelist0 in privateKeys {
                try privateKeysContainer.encode(certificatelist0)
            }
        }
        if let sidewalkId = self.sidewalkId {
            try encodeContainer.encode(sidewalkId, forKey: .sidewalkId)
        }
        if let sidewalkManufacturingSn = self.sidewalkManufacturingSn {
            try encodeContainer.encode(sidewalkManufacturingSn, forKey: .sidewalkManufacturingSn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let sidewalkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkId)
        sidewalkId = sidewalkIdDecoded
        let sidewalkManufacturingSnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkManufacturingSn)
        sidewalkManufacturingSn = sidewalkManufacturingSnDecoded
        let deviceCertificatesContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.CertificateList?].self, forKey: .deviceCertificates)
        var deviceCertificatesDecoded0:[IoTWirelessClientTypes.CertificateList]? = nil
        if let deviceCertificatesContainer = deviceCertificatesContainer {
            deviceCertificatesDecoded0 = [IoTWirelessClientTypes.CertificateList]()
            for structure0 in deviceCertificatesContainer {
                if let structure0 = structure0 {
                    deviceCertificatesDecoded0?.append(structure0)
                }
            }
        }
        deviceCertificates = deviceCertificatesDecoded0
        let privateKeysContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.CertificateList?].self, forKey: .privateKeys)
        var privateKeysDecoded0:[IoTWirelessClientTypes.CertificateList]? = nil
        if let privateKeysContainer = privateKeysContainer {
            privateKeysDecoded0 = [IoTWirelessClientTypes.CertificateList]()
            for structure0 in privateKeysContainer {
                if let structure0 = structure0 {
                    privateKeysDecoded0?.append(structure0)
                }
            }
        }
        privateKeys = privateKeysDecoded0
        let deviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceProfileId)
        deviceProfileId = deviceProfileIdDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessDeviceSidewalkStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Sidewalk device object.
    public struct SidewalkDevice: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The ID of the Sidewalk device profile.
        public var certificateId: Swift.String?
        /// The sidewalk device certificates for Ed25519 and P256r1.
        public var deviceCertificates: [IoTWirelessClientTypes.CertificateList]?
        /// The ID of the Sidewalk device profile.
        public var deviceProfileId: Swift.String?
        /// The Sidewalk device private keys that will be used for onboarding the device.
        public var privateKeys: [IoTWirelessClientTypes.CertificateList]?
        /// The sidewalk device identification.
        public var sidewalkId: Swift.String?
        /// The Sidewalk manufacturing series number.
        public var sidewalkManufacturingSn: Swift.String?
        /// The Sidewalk device status, such as provisioned or registered.
        public var status: IoTWirelessClientTypes.WirelessDeviceSidewalkStatus?

        public init(
            amazonId: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            deviceCertificates: [IoTWirelessClientTypes.CertificateList]? = nil,
            deviceProfileId: Swift.String? = nil,
            privateKeys: [IoTWirelessClientTypes.CertificateList]? = nil,
            sidewalkId: Swift.String? = nil,
            sidewalkManufacturingSn: Swift.String? = nil,
            status: IoTWirelessClientTypes.WirelessDeviceSidewalkStatus? = nil
        )
        {
            self.amazonId = amazonId
            self.certificateId = certificateId
            self.deviceCertificates = deviceCertificates
            self.deviceProfileId = deviceProfileId
            self.privateKeys = privateKeys
            self.sidewalkId = sidewalkId
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
            self.status = status
        }
    }

}

extension IoTWirelessClientTypes.SidewalkDeviceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batteryLevel = "BatteryLevel"
        case deviceState = "DeviceState"
        case event = "Event"
        case rssi = "Rssi"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batteryLevel = self.batteryLevel {
            try encodeContainer.encode(batteryLevel.rawValue, forKey: .batteryLevel)
        }
        if let deviceState = self.deviceState {
            try encodeContainer.encode(deviceState.rawValue, forKey: .deviceState)
        }
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let rssi = self.rssi {
            try encodeContainer.encode(rssi, forKey: .rssi)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rssiDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rssi)
        rssi = rssiDecoded
        let batteryLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.BatteryLevel.self, forKey: .batteryLevel)
        batteryLevel = batteryLevelDecoded
        let eventDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let deviceStateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DeviceState.self, forKey: .deviceState)
        deviceState = deviceStateDecoded
    }
}

extension IoTWirelessClientTypes {
    /// MetaData for Sidewalk device.
    public struct SidewalkDeviceMetadata: Swift.Equatable {
        /// Sidewalk device battery level.
        public var batteryLevel: IoTWirelessClientTypes.BatteryLevel?
        /// Device state defines the device status of sidewalk device.
        public var deviceState: IoTWirelessClientTypes.DeviceState?
        /// Sidewalk device status notification.
        public var event: IoTWirelessClientTypes.Event?
        /// The RSSI value.
        public var rssi: Swift.Int?

        public init(
            batteryLevel: IoTWirelessClientTypes.BatteryLevel? = nil,
            deviceState: IoTWirelessClientTypes.DeviceState? = nil,
            event: IoTWirelessClientTypes.Event? = nil,
            rssi: Swift.Int? = nil
        )
        {
            self.batteryLevel = batteryLevel
            self.deviceState = deviceState
            self.event = event
            self.rssi = rssi
        }
    }

}

extension IoTWirelessClientTypes.SidewalkEventNotificationConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonIdEventTopic = "AmazonIdEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonIdEventTopic = self.amazonIdEventTopic {
            try encodeContainer.encode(amazonIdEventTopic.rawValue, forKey: .amazonIdEventTopic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .amazonIdEventTopic)
        amazonIdEventTopic = amazonIdEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// SidewalkEventNotificationConfigurations object, which is the event configuration object for Sidewalk-related event topics.
    public struct SidewalkEventNotificationConfigurations: Swift.Equatable {
        /// Denotes whether the Amazon ID event topic is enabled or disabled.
        public var amazonIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            amazonIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.amazonIdEventTopic = amazonIdEventTopic
        }
    }

}

extension IoTWirelessClientTypes.SidewalkGetDeviceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationServerPublicKey = "ApplicationServerPublicKey"
        case dakCertificateMetadata = "DakCertificateMetadata"
        case qualificationStatus = "QualificationStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationServerPublicKey = self.applicationServerPublicKey {
            try encodeContainer.encode(applicationServerPublicKey, forKey: .applicationServerPublicKey)
        }
        if let dakCertificateMetadata = dakCertificateMetadata {
            var dakCertificateMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dakCertificateMetadata)
            for dakcertificatemetadata0 in dakCertificateMetadata {
                try dakCertificateMetadataContainer.encode(dakcertificatemetadata0)
            }
        }
        if let qualificationStatus = self.qualificationStatus {
            try encodeContainer.encode(qualificationStatus, forKey: .qualificationStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationServerPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationServerPublicKey)
        applicationServerPublicKey = applicationServerPublicKeyDecoded
        let qualificationStatusDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .qualificationStatus)
        qualificationStatus = qualificationStatusDecoded
        let dakCertificateMetadataContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.DakCertificateMetadata?].self, forKey: .dakCertificateMetadata)
        var dakCertificateMetadataDecoded0:[IoTWirelessClientTypes.DakCertificateMetadata]? = nil
        if let dakCertificateMetadataContainer = dakCertificateMetadataContainer {
            dakCertificateMetadataDecoded0 = [IoTWirelessClientTypes.DakCertificateMetadata]()
            for structure0 in dakCertificateMetadataContainer {
                if let structure0 = structure0 {
                    dakCertificateMetadataDecoded0?.append(structure0)
                }
            }
        }
        dakCertificateMetadata = dakCertificateMetadataDecoded0
    }
}

extension IoTWirelessClientTypes.SidewalkGetDeviceProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkGetDeviceProfile(dakCertificateMetadata: \(Swift.String(describing: dakCertificateMetadata)), qualificationStatus: \(Swift.String(describing: qualificationStatus)), applicationServerPublicKey: \"CONTENT_REDACTED\")"}
}

extension IoTWirelessClientTypes {
    /// Gets information about a Sidewalk device profile.
    public struct SidewalkGetDeviceProfile: Swift.Equatable {
        /// The Sidewalk application server public key.
        public var applicationServerPublicKey: Swift.String?
        /// The DAK certificate information of the Sidewalk device profile.
        public var dakCertificateMetadata: [IoTWirelessClientTypes.DakCertificateMetadata]?
        /// Gets information about the certification status of a Sidewalk device profile.
        public var qualificationStatus: Swift.Bool?

        public init(
            applicationServerPublicKey: Swift.String? = nil,
            dakCertificateMetadata: [IoTWirelessClientTypes.DakCertificateMetadata]? = nil,
            qualificationStatus: Swift.Bool? = nil
        )
        {
            self.applicationServerPublicKey = applicationServerPublicKey
            self.dakCertificateMetadata = dakCertificateMetadata
            self.qualificationStatus = qualificationStatus
        }
    }

}

extension IoTWirelessClientTypes.SidewalkGetStartImportInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCreationFileList = "DeviceCreationFileList"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceCreationFileList = deviceCreationFileList {
            var deviceCreationFileListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceCreationFileList)
            for devicecreationfile0 in deviceCreationFileList {
                try deviceCreationFileListContainer.encode(devicecreationfile0)
            }
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceCreationFileListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceCreationFileList)
        var deviceCreationFileListDecoded0:[Swift.String]? = nil
        if let deviceCreationFileListContainer = deviceCreationFileListContainer {
            deviceCreationFileListDecoded0 = [Swift.String]()
            for string0 in deviceCreationFileListContainer {
                if let string0 = string0 {
                    deviceCreationFileListDecoded0?.append(string0)
                }
            }
        }
        deviceCreationFileList = deviceCreationFileListDecoded0
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Sidewalk-related information for devices in an import task that are being onboarded.
    public struct SidewalkGetStartImportInfo: Swift.Equatable {
        /// List of Sidewalk devices that are added to the import task.
        public var deviceCreationFileList: [Swift.String]?
        /// The IAM role that allows AWS IoT Wireless to access the CSV file in the S3 bucket.
        public var role: Swift.String?

        public init(
            deviceCreationFileList: [Swift.String]? = nil,
            role: Swift.String? = nil
        )
        {
            self.deviceCreationFileList = deviceCreationFileList
            self.role = role
        }
    }

}

extension IoTWirelessClientTypes.SidewalkListDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case deviceCertificates = "DeviceCertificates"
        case deviceProfileId = "DeviceProfileId"
        case sidewalkId = "SidewalkId"
        case sidewalkManufacturingSn = "SidewalkManufacturingSn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = self.amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let deviceCertificates = deviceCertificates {
            var deviceCertificatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceCertificates)
            for certificatelist0 in deviceCertificates {
                try deviceCertificatesContainer.encode(certificatelist0)
            }
        }
        if let deviceProfileId = self.deviceProfileId {
            try encodeContainer.encode(deviceProfileId, forKey: .deviceProfileId)
        }
        if let sidewalkId = self.sidewalkId {
            try encodeContainer.encode(sidewalkId, forKey: .sidewalkId)
        }
        if let sidewalkManufacturingSn = self.sidewalkManufacturingSn {
            try encodeContainer.encode(sidewalkManufacturingSn, forKey: .sidewalkManufacturingSn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let sidewalkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkId)
        sidewalkId = sidewalkIdDecoded
        let sidewalkManufacturingSnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkManufacturingSn)
        sidewalkManufacturingSn = sidewalkManufacturingSnDecoded
        let deviceCertificatesContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.CertificateList?].self, forKey: .deviceCertificates)
        var deviceCertificatesDecoded0:[IoTWirelessClientTypes.CertificateList]? = nil
        if let deviceCertificatesContainer = deviceCertificatesContainer {
            deviceCertificatesDecoded0 = [IoTWirelessClientTypes.CertificateList]()
            for structure0 in deviceCertificatesContainer {
                if let structure0 = structure0 {
                    deviceCertificatesDecoded0?.append(structure0)
                }
            }
        }
        deviceCertificates = deviceCertificatesDecoded0
        let deviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceProfileId)
        deviceProfileId = deviceProfileIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessDeviceSidewalkStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Sidewalk object used by list functions.
    public struct SidewalkListDevice: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The sidewalk device certificates for Ed25519 and P256r1.
        public var deviceCertificates: [IoTWirelessClientTypes.CertificateList]?
        /// Sidewalk object used by list functions.
        public var deviceProfileId: Swift.String?
        /// The sidewalk device identification.
        public var sidewalkId: Swift.String?
        /// The Sidewalk manufacturing series number.
        public var sidewalkManufacturingSn: Swift.String?
        /// The status of the Sidewalk devices, such as provisioned or registered.
        public var status: IoTWirelessClientTypes.WirelessDeviceSidewalkStatus?

        public init(
            amazonId: Swift.String? = nil,
            deviceCertificates: [IoTWirelessClientTypes.CertificateList]? = nil,
            deviceProfileId: Swift.String? = nil,
            sidewalkId: Swift.String? = nil,
            sidewalkManufacturingSn: Swift.String? = nil,
            status: IoTWirelessClientTypes.WirelessDeviceSidewalkStatus? = nil
        )
        {
            self.amazonId = amazonId
            self.deviceCertificates = deviceCertificates
            self.deviceProfileId = deviceProfileId
            self.sidewalkId = sidewalkId
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
            self.status = status
        }
    }

}

extension IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceEventTopic = "WirelessDeviceEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessDeviceEventTopic = self.wirelessDeviceEventTopic {
            try encodeContainer.encode(wirelessDeviceEventTopic.rawValue, forKey: .wirelessDeviceEventTopic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessDeviceEventTopic)
        wirelessDeviceEventTopic = wirelessDeviceEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Sidewalk resource type event configuration object for enabling or disabling topic.
    public struct SidewalkResourceTypeEventConfiguration: Swift.Equatable {
        /// Denotes whether the wireless device join event topic is enabled or disabled.
        public var wirelessDeviceEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            wirelessDeviceEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.wirelessDeviceEventTopic = wirelessDeviceEventTopic
        }
    }

}

extension IoTWirelessClientTypes.SidewalkSendDataToDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ackModeRetryDurationSecs = "AckModeRetryDurationSecs"
        case messageType = "MessageType"
        case seq = "Seq"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ackModeRetryDurationSecs = self.ackModeRetryDurationSecs {
            try encodeContainer.encode(ackModeRetryDurationSecs, forKey: .ackModeRetryDurationSecs)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let seq = self.seq {
            try encodeContainer.encode(seq, forKey: .seq)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let seqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .seq)
        seq = seqDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let ackModeRetryDurationSecsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ackModeRetryDurationSecs)
        ackModeRetryDurationSecs = ackModeRetryDurationSecsDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about a Sidewalk router.
    public struct SidewalkSendDataToDevice: Swift.Equatable {
        /// The duration of time in seconds to retry sending the ACK.
        public var ackModeRetryDurationSecs: Swift.Int?
        /// Sidewalk device message type. Default value is CUSTOM_COMMAND_ID_NOTIFY.
        public var messageType: IoTWirelessClientTypes.MessageType?
        /// The sequence number.
        public var seq: Swift.Int?

        public init(
            ackModeRetryDurationSecs: Swift.Int? = nil,
            messageType: IoTWirelessClientTypes.MessageType? = nil,
            seq: Swift.Int? = nil
        )
        {
            self.ackModeRetryDurationSecs = ackModeRetryDurationSecs
            self.messageType = messageType
            self.seq = seq
        }
    }

}

extension IoTWirelessClientTypes.SidewalkSingleStartImportInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalkManufacturingSn = "SidewalkManufacturingSn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalkManufacturingSn = self.sidewalkManufacturingSn {
            try encodeContainer.encode(sidewalkManufacturingSn, forKey: .sidewalkManufacturingSn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkManufacturingSnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkManufacturingSn)
        sidewalkManufacturingSn = sidewalkManufacturingSnDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about an import task created for an individual Sidewalk device.
    public struct SidewalkSingleStartImportInfo: Swift.Equatable {
        /// The Sidewalk manufacturing serial number (SMSN) of the device added to the import task.
        public var sidewalkManufacturingSn: Swift.String?

        public init(
            sidewalkManufacturingSn: Swift.String? = nil
        )
        {
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
        }
    }

}

extension IoTWirelessClientTypes.SidewalkStartImportInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCreationFile = "DeviceCreationFile"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceCreationFile = self.deviceCreationFile {
            try encodeContainer.encode(deviceCreationFile, forKey: .deviceCreationFile)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceCreationFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCreationFile)
        deviceCreationFile = deviceCreationFileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about an import task created for bulk provisioning.
    public struct SidewalkStartImportInfo: Swift.Equatable {
        /// The CSV file contained in an S3 bucket that's used for adding devices to an import task.
        public var deviceCreationFile: Swift.String?
        /// The IAM role that allows AWS IoT Wireless to access the CSV file in the S3 bucket.
        public var role: Swift.String?

        public init(
            deviceCreationFile: Swift.String? = nil,
            role: Swift.String? = nil
        )
        {
            self.deviceCreationFile = deviceCreationFile
            self.role = role
        }
    }

}

extension IoTWirelessClientTypes.SidewalkUpdateAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appServerPrivateKey = "AppServerPrivateKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appServerPrivateKey = self.appServerPrivateKey {
            try encodeContainer.encode(appServerPrivateKey, forKey: .appServerPrivateKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appServerPrivateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appServerPrivateKey)
        appServerPrivateKey = appServerPrivateKeyDecoded
    }
}

extension IoTWirelessClientTypes.SidewalkUpdateAccount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkUpdateAccount(appServerPrivateKey: \"CONTENT_REDACTED\")"}
}

extension IoTWirelessClientTypes {
    /// Sidewalk update.
    public struct SidewalkUpdateAccount: Swift.Equatable {
        /// The new Sidewalk application server private key.
        public var appServerPrivateKey: Swift.String?

        public init(
            appServerPrivateKey: Swift.String? = nil
        )
        {
            self.appServerPrivateKey = appServerPrivateKey
        }
    }

}

extension IoTWirelessClientTypes.SidewalkUpdateImportInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCreationFile = "DeviceCreationFile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceCreationFile = self.deviceCreationFile {
            try encodeContainer.encode(deviceCreationFile, forKey: .deviceCreationFile)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceCreationFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCreationFile)
        deviceCreationFile = deviceCreationFileDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Sidewalk object information for updating an import task.
    public struct SidewalkUpdateImportInfo: Swift.Equatable {
        /// The CSV file contained in an S3 bucket that's used for appending devices to an existing import task.
        public var deviceCreationFile: Swift.String?

        public init(
            deviceCreationFile: Swift.String? = nil
        )
        {
            self.deviceCreationFile = deviceCreationFile
        }
    }

}

extension IoTWirelessClientTypes {
    /// The certificate chain algorithm provided by sidewalk.
    public enum SigningAlg: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ed25519
        case p256r1
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningAlg] {
            return [
                .ed25519,
                .p256r1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ed25519: return "Ed25519"
            case .p256r1: return "P256r1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SigningAlg(rawValue: rawValue) ?? SigningAlg.sdkUnknown(rawValue)
        }
    }
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryString = "QueryString"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/bulk"
    }
}

public struct StartBulkAssociateWirelessDeviceWithMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// Query string used to search for wireless devices as part of the bulk associate and disassociate process.
    public var queryString: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        id: Swift.String? = nil,
        queryString: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.id = id
        self.queryString = queryString
        self.tags = tags
    }
}

struct StartBulkAssociateWirelessDeviceWithMulticastGroupInputBody: Swift.Equatable {
    let queryString: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryString = "QueryString"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartBulkAssociateWirelessDeviceWithMulticastGroupOutput: Swift.Equatable {

    public init() { }
}

enum StartBulkAssociateWirelessDeviceWithMulticastGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryString = "QueryString"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/bulk"
    }
}

public struct StartBulkDisassociateWirelessDeviceFromMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// Query string used to search for wireless devices as part of the bulk associate and disassociate process.
    public var queryString: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        id: Swift.String? = nil,
        queryString: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.id = id
        self.queryString = queryString
        self.tags = tags
    }
}

struct StartBulkDisassociateWirelessDeviceFromMulticastGroupInputBody: Swift.Equatable {
    let queryString: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryString = "QueryString"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartBulkDisassociateWirelessDeviceFromMulticastGroupOutput: Swift.Equatable {

    public init() { }
}

enum StartBulkDisassociateWirelessDeviceFromMulticastGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }
}

extension StartFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

public struct StartFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information used to start a FUOTA task.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANStartFuotaTask?

    public init(
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANStartFuotaTask? = nil
    )
    {
        self.id = id
        self.loRaWAN = loRaWAN
    }
}

struct StartFuotaTaskInputBody: Swift.Equatable {
    let loRaWAN: IoTWirelessClientTypes.LoRaWANStartFuotaTask?
}

extension StartFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANStartFuotaTask.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension StartFuotaTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartFuotaTaskOutput: Swift.Equatable {

    public init() { }
}

enum StartFuotaTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartMulticastGroupSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }
}

extension StartMulticastGroupSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/session"
    }
}

public struct StartMulticastGroupSessionInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information used with the multicast session.
    /// This member is required.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession?

    public init(
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession? = nil
    )
    {
        self.id = id
        self.loRaWAN = loRaWAN
    }
}

struct StartMulticastGroupSessionInputBody: Swift.Equatable {
    let loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession?
}

extension StartMulticastGroupSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANMulticastSession.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension StartMulticastGroupSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartMulticastGroupSessionOutput: Swift.Equatable {

    public init() { }
}

enum StartMulticastGroupSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartSingleWirelessDeviceImportTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case destinationName = "DestinationName"
        case deviceName = "DeviceName"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension StartSingleWirelessDeviceImportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless_single_device_import_task"
    }
}

public struct StartSingleWirelessDeviceImportTaskInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The name of the Sidewalk destination that describes the IoT rule to route messages from the device in the import task that will be onboarded to AWS IoT Wireless.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The name of the wireless device for which an import task is being started.
    public var deviceName: Swift.String?
    /// The Sidewalk-related parameters for importing a single wireless device.
    /// This member is required.
    public var sidewalk: IoTWirelessClientTypes.SidewalkSingleStartImportInfo?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkSingleStartImportInfo? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.destinationName = destinationName
        self.deviceName = deviceName
        self.sidewalk = sidewalk
        self.tags = tags
    }
}

struct StartSingleWirelessDeviceImportTaskInputBody: Swift.Equatable {
    let destinationName: Swift.String?
    let clientRequestToken: Swift.String?
    let deviceName: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
    let sidewalk: IoTWirelessClientTypes.SidewalkSingleStartImportInfo?
}

extension StartSingleWirelessDeviceImportTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case destinationName = "DestinationName"
        case deviceName = "DeviceName"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkSingleStartImportInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension StartSingleWirelessDeviceImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSingleWirelessDeviceImportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct StartSingleWirelessDeviceImportTaskOutput: Swift.Equatable {
    /// The ARN (Amazon Resource Name) of the import task.
    public var arn: Swift.String?
    /// The import task ID.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct StartSingleWirelessDeviceImportTaskOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension StartSingleWirelessDeviceImportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum StartSingleWirelessDeviceImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartWirelessDeviceImportTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case destinationName = "DestinationName"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension StartWirelessDeviceImportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless_device_import_task"
    }
}

public struct StartWirelessDeviceImportTaskInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The name of the Sidewalk destination that describes the IoT rule to route messages from the devices in the import task that are onboarded to AWS IoT Wireless.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The Sidewalk-related parameters for importing wireless devices that need to be provisioned in bulk.
    /// This member is required.
    public var sidewalk: IoTWirelessClientTypes.SidewalkStartImportInfo?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkStartImportInfo? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.destinationName = destinationName
        self.sidewalk = sidewalk
        self.tags = tags
    }
}

struct StartWirelessDeviceImportTaskInputBody: Swift.Equatable {
    let destinationName: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
    let sidewalk: IoTWirelessClientTypes.SidewalkStartImportInfo?
}

extension StartWirelessDeviceImportTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case destinationName = "DestinationName"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkStartImportInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension StartWirelessDeviceImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartWirelessDeviceImportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct StartWirelessDeviceImportTaskOutput: Swift.Equatable {
    /// The ARN (Amazon Resource Name) of the import task.
    public var arn: Swift.String?
    /// The import task ID.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct StartWirelessDeviceImportTaskOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension StartWirelessDeviceImportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum StartWirelessDeviceImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTWirelessClientTypes {
    /// Supported RfRegions
    public enum SupportedRfRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case as9231
        case as9232
        case as9233
        case as9234
        case au915
        case cn470
        case cn779
        case eu433
        case eu868
        case in865
        case kr920
        case ru864
        case us915
        case sdkUnknown(Swift.String)

        public static var allCases: [SupportedRfRegion] {
            return [
                .as9231,
                .as9232,
                .as9233,
                .as9234,
                .au915,
                .cn470,
                .cn779,
                .eu433,
                .eu868,
                .in865,
                .kr920,
                .ru864,
                .us915,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .as9231: return "AS923-1"
            case .as9232: return "AS923-2"
            case .as9233: return "AS923-3"
            case .as9234: return "AS923-4"
            case .au915: return "AU915"
            case .cn470: return "CN470"
            case .cn779: return "CN779"
            case .eu433: return "EU433"
            case .eu868: return "EU868"
            case .in865: return "IN865"
            case .kr920: return "KR920"
            case .ru864: return "RU864"
            case .us915: return "US915"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SupportedRfRegion(rawValue: rawValue) ?? SupportedRfRegion.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTWirelessClientTypes {
    /// A simple label consisting of a customer-defined key-value pair
    public struct Tag: Swift.Equatable {
        /// The tag's key value.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to add tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Adds to or modifies the tags of the given resource. Tags are metadata that you can use to manage a resource.
    /// This member is required.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTWirelessClientTypes.TdscdmaLocalId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellParams = "CellParams"
        case uarfcn = "Uarfcn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellParams = self.cellParams {
            try encodeContainer.encode(cellParams, forKey: .cellParams)
        }
        if let uarfcn = self.uarfcn {
            try encodeContainer.encode(uarfcn, forKey: .uarfcn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uarfcnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uarfcn)
        uarfcn = uarfcnDecoded
        let cellParamsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cellParams)
        cellParams = cellParamsDecoded
    }
}

extension IoTWirelessClientTypes {
    /// TD-SCDMA local identification (local Id) information.
    public struct TdscdmaLocalId: Swift.Equatable {
        /// Cell parameters for TD-SCDMA.
        /// This member is required.
        public var cellParams: Swift.Int?
        /// TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number (UARFCN).
        /// This member is required.
        public var uarfcn: Swift.Int?

        public init(
            cellParams: Swift.Int? = nil,
            uarfcn: Swift.Int? = nil
        )
        {
            self.cellParams = cellParams
            self.uarfcn = uarfcn
        }
    }

}

extension IoTWirelessClientTypes.TdscdmaNmrObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellParams = "CellParams"
        case pathLoss = "PathLoss"
        case rscp = "Rscp"
        case uarfcn = "Uarfcn"
        case utranCid = "UtranCid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellParams = self.cellParams {
            try encodeContainer.encode(cellParams, forKey: .cellParams)
        }
        if let pathLoss = self.pathLoss {
            try encodeContainer.encode(pathLoss, forKey: .pathLoss)
        }
        if let rscp = self.rscp {
            try encodeContainer.encode(rscp, forKey: .rscp)
        }
        if let uarfcn = self.uarfcn {
            try encodeContainer.encode(uarfcn, forKey: .uarfcn)
        }
        if let utranCid = self.utranCid {
            try encodeContainer.encode(utranCid, forKey: .utranCid)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uarfcnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uarfcn)
        uarfcn = uarfcnDecoded
        let cellParamsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cellParams)
        cellParams = cellParamsDecoded
        let utranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .utranCid)
        utranCid = utranCidDecoded
        let rscpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rscp)
        rscp = rscpDecoded
        let pathLossDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pathLoss)
        pathLoss = pathLossDecoded
    }
}

extension IoTWirelessClientTypes {
    /// TD-SCDMA object for network measurement reports.
    public struct TdscdmaNmrObj: Swift.Equatable {
        /// Cell parameters for TD-SCDMA network measurement reports object.
        /// This member is required.
        public var cellParams: Swift.Int?
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public var pathLoss: Swift.Int?
        /// Code power of the received signal, measured in decibel-milliwatts (dBm).
        public var rscp: Swift.Int?
        /// TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number.
        /// This member is required.
        public var uarfcn: Swift.Int?
        /// UTRAN (UMTS Terrestrial Radio Access Network) cell global identifier.
        public var utranCid: Swift.Int?

        public init(
            cellParams: Swift.Int? = nil,
            pathLoss: Swift.Int? = nil,
            rscp: Swift.Int? = nil,
            uarfcn: Swift.Int? = nil,
            utranCid: Swift.Int? = nil
        )
        {
            self.cellParams = cellParams
            self.pathLoss = pathLoss
            self.rscp = rscp
            self.uarfcn = uarfcn
            self.utranCid = utranCid
        }
    }

}

extension IoTWirelessClientTypes.TdscdmaObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lac = "Lac"
        case mcc = "Mcc"
        case mnc = "Mnc"
        case pathLoss = "PathLoss"
        case rscp = "Rscp"
        case tdscdmaLocalId = "TdscdmaLocalId"
        case tdscdmaNmr = "TdscdmaNmr"
        case tdscdmaTimingAdvance = "TdscdmaTimingAdvance"
        case utranCid = "UtranCid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lac = self.lac {
            try encodeContainer.encode(lac, forKey: .lac)
        }
        if let mcc = self.mcc {
            try encodeContainer.encode(mcc, forKey: .mcc)
        }
        if let mnc = self.mnc {
            try encodeContainer.encode(mnc, forKey: .mnc)
        }
        if let pathLoss = self.pathLoss {
            try encodeContainer.encode(pathLoss, forKey: .pathLoss)
        }
        if let rscp = self.rscp {
            try encodeContainer.encode(rscp, forKey: .rscp)
        }
        if let tdscdmaLocalId = self.tdscdmaLocalId {
            try encodeContainer.encode(tdscdmaLocalId, forKey: .tdscdmaLocalId)
        }
        if let tdscdmaNmr = tdscdmaNmr {
            var tdscdmaNmrContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tdscdmaNmr)
            for tdscdmanmrobj0 in tdscdmaNmr {
                try tdscdmaNmrContainer.encode(tdscdmanmrobj0)
            }
        }
        if let tdscdmaTimingAdvance = self.tdscdmaTimingAdvance {
            try encodeContainer.encode(tdscdmaTimingAdvance, forKey: .tdscdmaTimingAdvance)
        }
        if let utranCid = self.utranCid {
            try encodeContainer.encode(utranCid, forKey: .utranCid)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mccDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mcc)
        mcc = mccDecoded
        let mncDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mnc)
        mnc = mncDecoded
        let lacDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lac)
        lac = lacDecoded
        let utranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .utranCid)
        utranCid = utranCidDecoded
        let tdscdmaLocalIdDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.TdscdmaLocalId.self, forKey: .tdscdmaLocalId)
        tdscdmaLocalId = tdscdmaLocalIdDecoded
        let tdscdmaTimingAdvanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tdscdmaTimingAdvance)
        tdscdmaTimingAdvance = tdscdmaTimingAdvanceDecoded
        let rscpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rscp)
        rscp = rscpDecoded
        let pathLossDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pathLoss)
        pathLoss = pathLossDecoded
        let tdscdmaNmrContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.TdscdmaNmrObj?].self, forKey: .tdscdmaNmr)
        var tdscdmaNmrDecoded0:[IoTWirelessClientTypes.TdscdmaNmrObj]? = nil
        if let tdscdmaNmrContainer = tdscdmaNmrContainer {
            tdscdmaNmrDecoded0 = [IoTWirelessClientTypes.TdscdmaNmrObj]()
            for structure0 in tdscdmaNmrContainer {
                if let structure0 = structure0 {
                    tdscdmaNmrDecoded0?.append(structure0)
                }
            }
        }
        tdscdmaNmr = tdscdmaNmrDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// TD-SCDMA object.
    public struct TdscdmaObj: Swift.Equatable {
        /// Location Area Code.
        public var lac: Swift.Int?
        /// Mobile Country Code.
        /// This member is required.
        public var mcc: Swift.Int?
        /// Mobile Network Code.
        /// This member is required.
        public var mnc: Swift.Int?
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public var pathLoss: Swift.Int?
        /// Signal power of the received signal (Received Signal Code Power), measured in decibel-milliwatts (dBm).
        public var rscp: Swift.Int?
        /// TD-SCDMA local identification (local ID) information.
        public var tdscdmaLocalId: IoTWirelessClientTypes.TdscdmaLocalId?
        /// TD-SCDMA object for network measurement reports.
        public var tdscdmaNmr: [IoTWirelessClientTypes.TdscdmaNmrObj]?
        /// TD-SCDMA Timing advance.
        public var tdscdmaTimingAdvance: Swift.Int?
        /// UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var utranCid: Swift.Int?

        public init(
            lac: Swift.Int? = nil,
            mcc: Swift.Int? = nil,
            mnc: Swift.Int? = nil,
            pathLoss: Swift.Int? = nil,
            rscp: Swift.Int? = nil,
            tdscdmaLocalId: IoTWirelessClientTypes.TdscdmaLocalId? = nil,
            tdscdmaNmr: [IoTWirelessClientTypes.TdscdmaNmrObj]? = nil,
            tdscdmaTimingAdvance: Swift.Int? = nil,
            utranCid: Swift.Int? = nil
        )
        {
            self.lac = lac
            self.mcc = mcc
            self.mnc = mnc
            self.pathLoss = pathLoss
            self.rscp = rscp
            self.tdscdmaLocalId = tdscdmaLocalId
            self.tdscdmaNmr = tdscdmaNmr
            self.tdscdmaTimingAdvance = tdscdmaTimingAdvance
            self.utranCid = utranCid
        }
    }

}

extension TestWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/test"
    }
}

public struct TestWirelessDeviceInput: Swift.Equatable {
    /// The ID of the wireless device to test.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct TestWirelessDeviceInputBody: Swift.Equatable {
}

extension TestWirelessDeviceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension TestWirelessDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestWirelessDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = nil
        }
    }
}

public struct TestWirelessDeviceOutput: Swift.Equatable {
    /// The result returned by the test.
    public var result: Swift.String?

    public init(
        result: Swift.String? = nil
    )
    {
        self.result = result
    }
}

struct TestWirelessDeviceOutputBody: Swift.Equatable {
    let result: Swift.String?
}

extension TestWirelessDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case result = "Result"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .result)
        result = resultDecoded
    }
}

enum TestWirelessDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because it exceeded the allowed API request rate.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because the resource can't have any more tags.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Name of the resource that exceeds maximum number of tags allowed.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension IoTWirelessClientTypes.TraceContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
        case multicastFrameInfo = "MulticastFrameInfo"
        case wirelessDeviceFrameInfo = "WirelessDeviceFrameInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let multicastFrameInfo = self.multicastFrameInfo {
            try encodeContainer.encode(multicastFrameInfo.rawValue, forKey: .multicastFrameInfo)
        }
        if let wirelessDeviceFrameInfo = self.wirelessDeviceFrameInfo {
            try encodeContainer.encode(wirelessDeviceFrameInfo.rawValue, forKey: .wirelessDeviceFrameInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceFrameInfoDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessDeviceFrameInfo.self, forKey: .wirelessDeviceFrameInfo)
        wirelessDeviceFrameInfo = wirelessDeviceFrameInfoDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let multicastFrameInfoDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MulticastFrameInfo.self, forKey: .multicastFrameInfo)
        multicastFrameInfo = multicastFrameInfoDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Trace content for your wireless gateway and wireless device resources.
    public struct TraceContent: Swift.Equatable {
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        public var logLevel: IoTWirelessClientTypes.LogLevel?
        /// FrameInfo of your multicast group resources for the trace content. Use FrameInfo to debug the multicast communication between your LoRaWAN end devices and the network server.
        public var multicastFrameInfo: IoTWirelessClientTypes.MulticastFrameInfo?
        /// FrameInfo of your wireless device resources for the trace content. Use FrameInfo to debug the communication between your LoRaWAN end devices and the network server.
        public var wirelessDeviceFrameInfo: IoTWirelessClientTypes.WirelessDeviceFrameInfo?

        public init(
            logLevel: IoTWirelessClientTypes.LogLevel? = nil,
            multicastFrameInfo: IoTWirelessClientTypes.MulticastFrameInfo? = nil,
            wirelessDeviceFrameInfo: IoTWirelessClientTypes.WirelessDeviceFrameInfo? = nil
        )
        {
            self.logLevel = logLevel
            self.multicastFrameInfo = multicastFrameInfo
            self.wirelessDeviceFrameInfo = wirelessDeviceFrameInfo
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTWirelessClientTypes.UpdateAbpV1_0_x: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fCntStart = "FCntStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fCntStart = self.fCntStart {
            try encodeContainer.encode(fCntStart, forKey: .fCntStart)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fCntStartDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fCntStart)
        fCntStart = fCntStartDecoded
    }
}

extension IoTWirelessClientTypes {
    /// ABP device object for LoRaWAN specification v1.0.x
    public struct UpdateAbpV1_0_x: Swift.Equatable {
        /// The FCnt init value.
        public var fCntStart: Swift.Int?

        public init(
            fCntStart: Swift.Int? = nil
        )
        {
            self.fCntStart = fCntStart
        }
    }

}

extension IoTWirelessClientTypes.UpdateAbpV1_1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fCntStart = "FCntStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fCntStart = self.fCntStart {
            try encodeContainer.encode(fCntStart, forKey: .fCntStart)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fCntStartDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fCntStart)
        fCntStart = fCntStartDecoded
    }
}

extension IoTWirelessClientTypes {
    /// ABP device object for LoRaWAN specification v1.1
    public struct UpdateAbpV1_1: Swift.Equatable {
        /// The FCnt init value.
        public var fCntStart: Swift.Int?

        public init(
            fCntStart: Swift.Int? = nil
        )
        {
            self.fCntStart = fCntStart
        }
    }

}

extension UpdateDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = self.expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

public struct UpdateDestinationInput: Swift.Equatable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The new rule name or topic rule to send messages to.
    public var expression: Swift.String?
    /// The type of value in Expression.
    public var expressionType: IoTWirelessClientTypes.ExpressionType?
    /// The new name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    public var roleArn: Swift.String?

    public init(
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IoTWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
    }
}

struct UpdateDestinationInputBody: Swift.Equatable {
    let expressionType: IoTWirelessClientTypes.ExpressionType?
    let expression: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
}

extension UpdateDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case roleArn = "RoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDestinationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEventConfigurationByResourceTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case deviceRegistrationState = "DeviceRegistrationState"
        case join = "Join"
        case messageDeliveryStatus = "MessageDeliveryStatus"
        case proximity = "Proximity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionStatus = self.connectionStatus {
            try encodeContainer.encode(connectionStatus, forKey: .connectionStatus)
        }
        if let deviceRegistrationState = self.deviceRegistrationState {
            try encodeContainer.encode(deviceRegistrationState, forKey: .deviceRegistrationState)
        }
        if let join = self.join {
            try encodeContainer.encode(join, forKey: .join)
        }
        if let messageDeliveryStatus = self.messageDeliveryStatus {
            try encodeContainer.encode(messageDeliveryStatus, forKey: .messageDeliveryStatus)
        }
        if let proximity = self.proximity {
            try encodeContainer.encode(proximity, forKey: .proximity)
        }
    }
}

extension UpdateEventConfigurationByResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/event-configurations-resource-types"
    }
}

public struct UpdateEventConfigurationByResourceTypesInput: Swift.Equatable {
    /// Connection status resource type event configuration object for enabling and disabling wireless gateway topic.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration?
    /// Device registration state resource type event configuration object for enabling and disabling wireless gateway topic.
    public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration?
    /// Join resource type event configuration object for enabling and disabling wireless device topic.
    public var join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration?
    /// Message delivery status resource type event configuration object for enabling and disabling wireless device topic.
    public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration?
    /// Proximity resource type event configuration object for enabling and disabling wireless gateway topic.
    public var proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration?

    public init(
        connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration? = nil,
        deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration? = nil,
        join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration? = nil,
        messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration? = nil,
        proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.deviceRegistrationState = deviceRegistrationState
        self.join = join
        self.messageDeliveryStatus = messageDeliveryStatus
        self.proximity = proximity
    }
}

struct UpdateEventConfigurationByResourceTypesInputBody: Swift.Equatable {
    let deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration?
    let proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration?
    let join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration?
    let connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration?
    let messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration?
}

extension UpdateEventConfigurationByResourceTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case deviceRegistrationState = "DeviceRegistrationState"
        case join = "Join"
        case messageDeliveryStatus = "MessageDeliveryStatus"
        case proximity = "Proximity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceRegistrationStateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration.self, forKey: .deviceRegistrationState)
        deviceRegistrationState = deviceRegistrationStateDecoded
        let proximityDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration.self, forKey: .proximity)
        proximity = proximityDecoded
        let joinDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.JoinResourceTypeEventConfiguration.self, forKey: .join)
        join = joinDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let messageDeliveryStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration.self, forKey: .messageDeliveryStatus)
        messageDeliveryStatus = messageDeliveryStatusDecoded
    }
}

extension UpdateEventConfigurationByResourceTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateEventConfigurationByResourceTypesOutput: Swift.Equatable {

    public init() { }
}

enum UpdateEventConfigurationByResourceTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTWirelessClientTypes.UpdateFPorts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case positioning = "Positioning"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for applicationconfig0 in applications {
                try applicationsContainer.encode(applicationconfig0)
            }
        }
        if let positioning = self.positioning {
            try encodeContainer.encode(positioning, forKey: .positioning)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positioningDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.Positioning.self, forKey: .positioning)
        positioning = positioningDecoded
        let applicationsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.ApplicationConfig?].self, forKey: .applications)
        var applicationsDecoded0:[IoTWirelessClientTypes.ApplicationConfig]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [IoTWirelessClientTypes.ApplicationConfig]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// Object for updating the FPorts information.
    public struct UpdateFPorts: Swift.Equatable {
        /// LoRaWAN application, which can be used for geolocation by activating positioning.
        public var applications: [IoTWirelessClientTypes.ApplicationConfig]?
        /// Positioning FPorts for the ClockSync, Stream, and GNSS functions.
        public var positioning: IoTWirelessClientTypes.Positioning?

        public init(
            applications: [IoTWirelessClientTypes.ApplicationConfig]? = nil,
            positioning: IoTWirelessClientTypes.Positioning? = nil
        )
        {
            self.applications = applications
            self.positioning = positioning
        }
    }

}

extension UpdateFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case fragmentIntervalMS = "FragmentIntervalMS"
        case fragmentSizeBytes = "FragmentSizeBytes"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case redundancyPercent = "RedundancyPercent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let firmwareUpdateImage = self.firmwareUpdateImage {
            try encodeContainer.encode(firmwareUpdateImage, forKey: .firmwareUpdateImage)
        }
        if let firmwareUpdateRole = self.firmwareUpdateRole {
            try encodeContainer.encode(firmwareUpdateRole, forKey: .firmwareUpdateRole)
        }
        if let fragmentIntervalMS = self.fragmentIntervalMS {
            try encodeContainer.encode(fragmentIntervalMS, forKey: .fragmentIntervalMS)
        }
        if let fragmentSizeBytes = self.fragmentSizeBytes {
            try encodeContainer.encode(fragmentSizeBytes, forKey: .fragmentSizeBytes)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let redundancyPercent = self.redundancyPercent {
            try encodeContainer.encode(redundancyPercent, forKey: .redundancyPercent)
        }
    }
}

extension UpdateFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

public struct UpdateFuotaTaskInput: Swift.Equatable {
    /// The description of the new resource.
    public var description: Swift.String?
    /// The S3 URI points to a firmware update image that is to be used with a FUOTA task.
    public var firmwareUpdateImage: Swift.String?
    /// The firmware update role that is to be used with a FUOTA task.
    public var firmwareUpdateRole: Swift.String?
    /// The interval for sending fragments in milliseconds, rounded to the nearest second. This interval only determines the timing for when the Cloud sends down the fragments to yor device. There can be a delay for when your device will receive these fragments. This delay depends on the device's class and the communication delay with the cloud.
    public var fragmentIntervalMS: Swift.Int?
    /// The size of each fragment in bytes. This parameter is supported only for FUOTA tasks with multicast groups.
    public var fragmentSizeBytes: Swift.Int?
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information used with a FUOTA task.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask?
    /// The name of a FUOTA task.
    public var name: Swift.String?
    /// The percentage of the added fragments that are redundant. For example, if the size of the firmware image file is 100 bytes and the fragment size is 10 bytes, with RedundancyPercent set to 50(%), the final number of encoded fragments is (100 / 10) + (100 / 10 * 50%) = 15.
    public var redundancyPercent: Swift.Int?

    public init(
        description: Swift.String? = nil,
        firmwareUpdateImage: Swift.String? = nil,
        firmwareUpdateRole: Swift.String? = nil,
        fragmentIntervalMS: Swift.Int? = nil,
        fragmentSizeBytes: Swift.Int? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask? = nil,
        name: Swift.String? = nil,
        redundancyPercent: Swift.Int? = nil
    )
    {
        self.description = description
        self.firmwareUpdateImage = firmwareUpdateImage
        self.firmwareUpdateRole = firmwareUpdateRole
        self.fragmentIntervalMS = fragmentIntervalMS
        self.fragmentSizeBytes = fragmentSizeBytes
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.redundancyPercent = redundancyPercent
    }
}

struct UpdateFuotaTaskInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask?
    let firmwareUpdateImage: Swift.String?
    let firmwareUpdateRole: Swift.String?
    let redundancyPercent: Swift.Int?
    let fragmentSizeBytes: Swift.Int?
    let fragmentIntervalMS: Swift.Int?
}

extension UpdateFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case fragmentIntervalMS = "FragmentIntervalMS"
        case fragmentSizeBytes = "FragmentSizeBytes"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case redundancyPercent = "RedundancyPercent"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANFuotaTask.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let firmwareUpdateImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateImage)
        firmwareUpdateImage = firmwareUpdateImageDecoded
        let firmwareUpdateRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateRole)
        firmwareUpdateRole = firmwareUpdateRoleDecoded
        let redundancyPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .redundancyPercent)
        redundancyPercent = redundancyPercentDecoded
        let fragmentSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fragmentSizeBytes)
        fragmentSizeBytes = fragmentSizeBytesDecoded
        let fragmentIntervalMSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fragmentIntervalMS)
        fragmentIntervalMS = fragmentIntervalMSDecoded
    }
}

extension UpdateFuotaTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateFuotaTaskOutput: Swift.Equatable {

    public init() { }
}

enum UpdateFuotaTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLogLevelsByResourceTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultLogLevel = self.defaultLogLevel {
            try encodeContainer.encode(defaultLogLevel.rawValue, forKey: .defaultLogLevel)
        }
        if let wirelessDeviceLogOptions = wirelessDeviceLogOptions {
            var wirelessDeviceLogOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessDeviceLogOptions)
            for wirelessdevicelogoption0 in wirelessDeviceLogOptions {
                try wirelessDeviceLogOptionsContainer.encode(wirelessdevicelogoption0)
            }
        }
        if let wirelessGatewayLogOptions = wirelessGatewayLogOptions {
            var wirelessGatewayLogOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessGatewayLogOptions)
            for wirelessgatewaylogoption0 in wirelessGatewayLogOptions {
                try wirelessGatewayLogOptionsContainer.encode(wirelessgatewaylogoption0)
            }
        }
    }
}

extension UpdateLogLevelsByResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/log-levels"
    }
}

public struct UpdateLogLevelsByResourceTypesInput: Swift.Equatable {
    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    public var defaultLogLevel: IoTWirelessClientTypes.LogLevel?
    /// The list of wireless device log options.
    public var wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]?
    /// The list of wireless gateway log options.
    public var wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]?

    public init(
        defaultLogLevel: IoTWirelessClientTypes.LogLevel? = nil,
        wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]? = nil,
        wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.wirelessDeviceLogOptions = wirelessDeviceLogOptions
        self.wirelessGatewayLogOptions = wirelessGatewayLogOptions
    }
}

struct UpdateLogLevelsByResourceTypesInputBody: Swift.Equatable {
    let defaultLogLevel: IoTWirelessClientTypes.LogLevel?
    let wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]?
    let wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]?
}

extension UpdateLogLevelsByResourceTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultLogLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .defaultLogLevel)
        defaultLogLevel = defaultLogLevelDecoded
        let wirelessDeviceLogOptionsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessDeviceLogOption?].self, forKey: .wirelessDeviceLogOptions)
        var wirelessDeviceLogOptionsDecoded0:[IoTWirelessClientTypes.WirelessDeviceLogOption]? = nil
        if let wirelessDeviceLogOptionsContainer = wirelessDeviceLogOptionsContainer {
            wirelessDeviceLogOptionsDecoded0 = [IoTWirelessClientTypes.WirelessDeviceLogOption]()
            for structure0 in wirelessDeviceLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessDeviceLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceLogOptions = wirelessDeviceLogOptionsDecoded0
        let wirelessGatewayLogOptionsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessGatewayLogOption?].self, forKey: .wirelessGatewayLogOptions)
        var wirelessGatewayLogOptionsDecoded0:[IoTWirelessClientTypes.WirelessGatewayLogOption]? = nil
        if let wirelessGatewayLogOptionsContainer = wirelessGatewayLogOptionsContainer {
            wirelessGatewayLogOptionsDecoded0 = [IoTWirelessClientTypes.WirelessGatewayLogOption]()
            for structure0 in wirelessGatewayLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessGatewayLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayLogOptions = wirelessGatewayLogOptionsDecoded0
    }
}

extension UpdateLogLevelsByResourceTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateLogLevelsByResourceTypesOutput: Swift.Equatable {

    public init() { }
}

enum UpdateLogLevelsByResourceTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())"
    }
}

public struct UpdateMulticastGroupInput: Swift.Equatable {
    /// The description of the new resource.
    public var description: Swift.String?
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information that is to be used with the multicast group.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast?
    /// The name of the multicast group.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct UpdateMulticastGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast?
}

extension UpdateMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANMulticast.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension UpdateMulticastGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateMulticastGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateMulticastGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateNetworkAnalyzerConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case multicastGroupsToAdd = "MulticastGroupsToAdd"
        case multicastGroupsToRemove = "MulticastGroupsToRemove"
        case traceContent = "TraceContent"
        case wirelessDevicesToAdd = "WirelessDevicesToAdd"
        case wirelessDevicesToRemove = "WirelessDevicesToRemove"
        case wirelessGatewaysToAdd = "WirelessGatewaysToAdd"
        case wirelessGatewaysToRemove = "WirelessGatewaysToRemove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let multicastGroupsToAdd = multicastGroupsToAdd {
            var multicastGroupsToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .multicastGroupsToAdd)
            for multicastgroupid0 in multicastGroupsToAdd {
                try multicastGroupsToAddContainer.encode(multicastgroupid0)
            }
        }
        if let multicastGroupsToRemove = multicastGroupsToRemove {
            var multicastGroupsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .multicastGroupsToRemove)
            for multicastgroupid0 in multicastGroupsToRemove {
                try multicastGroupsToRemoveContainer.encode(multicastgroupid0)
            }
        }
        if let traceContent = self.traceContent {
            try encodeContainer.encode(traceContent, forKey: .traceContent)
        }
        if let wirelessDevicesToAdd = wirelessDevicesToAdd {
            var wirelessDevicesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessDevicesToAdd)
            for wirelessdeviceid0 in wirelessDevicesToAdd {
                try wirelessDevicesToAddContainer.encode(wirelessdeviceid0)
            }
        }
        if let wirelessDevicesToRemove = wirelessDevicesToRemove {
            var wirelessDevicesToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessDevicesToRemove)
            for wirelessdeviceid0 in wirelessDevicesToRemove {
                try wirelessDevicesToRemoveContainer.encode(wirelessdeviceid0)
            }
        }
        if let wirelessGatewaysToAdd = wirelessGatewaysToAdd {
            var wirelessGatewaysToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessGatewaysToAdd)
            for wirelessgatewayid0 in wirelessGatewaysToAdd {
                try wirelessGatewaysToAddContainer.encode(wirelessgatewayid0)
            }
        }
        if let wirelessGatewaysToRemove = wirelessGatewaysToRemove {
            var wirelessGatewaysToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessGatewaysToRemove)
            for wirelessgatewayid0 in wirelessGatewaysToRemove {
                try wirelessGatewaysToRemoveContainer.encode(wirelessgatewayid0)
            }
        }
    }
}

extension UpdateNetworkAnalyzerConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationName = configurationName else {
            return nil
        }
        return "/network-analyzer-configurations/\(configurationName.urlPercentEncoding())"
    }
}

public struct UpdateNetworkAnalyzerConfigurationInput: Swift.Equatable {
    /// Name of the network analyzer configuration.
    /// This member is required.
    public var configurationName: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// Multicast group resources to add to the network analyzer configuration. Provide the MulticastGroupId of the resource to add in the input array.
    public var multicastGroupsToAdd: [Swift.String]?
    /// Multicast group resources to remove from the network analyzer configuration. Provide the MulticastGroupId of the resource to remove in the input array.
    public var multicastGroupsToRemove: [Swift.String]?
    /// Trace content for your wireless gateway and wireless device resources.
    public var traceContent: IoTWirelessClientTypes.TraceContent?
    /// Wireless device resources to add to the network analyzer configuration. Provide the WirelessDeviceId of the resource to add in the input array.
    public var wirelessDevicesToAdd: [Swift.String]?
    /// Wireless device resources to remove from the network analyzer configuration. Provide the WirelessDeviceId of the resources to remove in the input array.
    public var wirelessDevicesToRemove: [Swift.String]?
    /// Wireless gateway resources to add to the network analyzer configuration. Provide the WirelessGatewayId of the resource to add in the input array.
    public var wirelessGatewaysToAdd: [Swift.String]?
    /// Wireless gateway resources to remove from the network analyzer configuration. Provide the WirelessGatewayId of the resources to remove in the input array.
    public var wirelessGatewaysToRemove: [Swift.String]?

    public init(
        configurationName: Swift.String? = nil,
        description: Swift.String? = nil,
        multicastGroupsToAdd: [Swift.String]? = nil,
        multicastGroupsToRemove: [Swift.String]? = nil,
        traceContent: IoTWirelessClientTypes.TraceContent? = nil,
        wirelessDevicesToAdd: [Swift.String]? = nil,
        wirelessDevicesToRemove: [Swift.String]? = nil,
        wirelessGatewaysToAdd: [Swift.String]? = nil,
        wirelessGatewaysToRemove: [Swift.String]? = nil
    )
    {
        self.configurationName = configurationName
        self.description = description
        self.multicastGroupsToAdd = multicastGroupsToAdd
        self.multicastGroupsToRemove = multicastGroupsToRemove
        self.traceContent = traceContent
        self.wirelessDevicesToAdd = wirelessDevicesToAdd
        self.wirelessDevicesToRemove = wirelessDevicesToRemove
        self.wirelessGatewaysToAdd = wirelessGatewaysToAdd
        self.wirelessGatewaysToRemove = wirelessGatewaysToRemove
    }
}

struct UpdateNetworkAnalyzerConfigurationInputBody: Swift.Equatable {
    let traceContent: IoTWirelessClientTypes.TraceContent?
    let wirelessDevicesToAdd: [Swift.String]?
    let wirelessDevicesToRemove: [Swift.String]?
    let wirelessGatewaysToAdd: [Swift.String]?
    let wirelessGatewaysToRemove: [Swift.String]?
    let description: Swift.String?
    let multicastGroupsToAdd: [Swift.String]?
    let multicastGroupsToRemove: [Swift.String]?
}

extension UpdateNetworkAnalyzerConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case multicastGroupsToAdd = "MulticastGroupsToAdd"
        case multicastGroupsToRemove = "MulticastGroupsToRemove"
        case traceContent = "TraceContent"
        case wirelessDevicesToAdd = "WirelessDevicesToAdd"
        case wirelessDevicesToRemove = "WirelessDevicesToRemove"
        case wirelessGatewaysToAdd = "WirelessGatewaysToAdd"
        case wirelessGatewaysToRemove = "WirelessGatewaysToRemove"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceContentDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.TraceContent.self, forKey: .traceContent)
        traceContent = traceContentDecoded
        let wirelessDevicesToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessDevicesToAdd)
        var wirelessDevicesToAddDecoded0:[Swift.String]? = nil
        if let wirelessDevicesToAddContainer = wirelessDevicesToAddContainer {
            wirelessDevicesToAddDecoded0 = [Swift.String]()
            for string0 in wirelessDevicesToAddContainer {
                if let string0 = string0 {
                    wirelessDevicesToAddDecoded0?.append(string0)
                }
            }
        }
        wirelessDevicesToAdd = wirelessDevicesToAddDecoded0
        let wirelessDevicesToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessDevicesToRemove)
        var wirelessDevicesToRemoveDecoded0:[Swift.String]? = nil
        if let wirelessDevicesToRemoveContainer = wirelessDevicesToRemoveContainer {
            wirelessDevicesToRemoveDecoded0 = [Swift.String]()
            for string0 in wirelessDevicesToRemoveContainer {
                if let string0 = string0 {
                    wirelessDevicesToRemoveDecoded0?.append(string0)
                }
            }
        }
        wirelessDevicesToRemove = wirelessDevicesToRemoveDecoded0
        let wirelessGatewaysToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessGatewaysToAdd)
        var wirelessGatewaysToAddDecoded0:[Swift.String]? = nil
        if let wirelessGatewaysToAddContainer = wirelessGatewaysToAddContainer {
            wirelessGatewaysToAddDecoded0 = [Swift.String]()
            for string0 in wirelessGatewaysToAddContainer {
                if let string0 = string0 {
                    wirelessGatewaysToAddDecoded0?.append(string0)
                }
            }
        }
        wirelessGatewaysToAdd = wirelessGatewaysToAddDecoded0
        let wirelessGatewaysToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessGatewaysToRemove)
        var wirelessGatewaysToRemoveDecoded0:[Swift.String]? = nil
        if let wirelessGatewaysToRemoveContainer = wirelessGatewaysToRemoveContainer {
            wirelessGatewaysToRemoveDecoded0 = [Swift.String]()
            for string0 in wirelessGatewaysToRemoveContainer {
                if let string0 = string0 {
                    wirelessGatewaysToRemoveDecoded0?.append(string0)
                }
            }
        }
        wirelessGatewaysToRemove = wirelessGatewaysToRemoveDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let multicastGroupsToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .multicastGroupsToAdd)
        var multicastGroupsToAddDecoded0:[Swift.String]? = nil
        if let multicastGroupsToAddContainer = multicastGroupsToAddContainer {
            multicastGroupsToAddDecoded0 = [Swift.String]()
            for string0 in multicastGroupsToAddContainer {
                if let string0 = string0 {
                    multicastGroupsToAddDecoded0?.append(string0)
                }
            }
        }
        multicastGroupsToAdd = multicastGroupsToAddDecoded0
        let multicastGroupsToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .multicastGroupsToRemove)
        var multicastGroupsToRemoveDecoded0:[Swift.String]? = nil
        if let multicastGroupsToRemoveContainer = multicastGroupsToRemoveContainer {
            multicastGroupsToRemoveDecoded0 = [Swift.String]()
            for string0 in multicastGroupsToRemoveContainer {
                if let string0 = string0 {
                    multicastGroupsToRemoveDecoded0?.append(string0)
                }
            }
        }
        multicastGroupsToRemove = multicastGroupsToRemoveDecoded0
    }
}

extension UpdateNetworkAnalyzerConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateNetworkAnalyzerConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateNetworkAnalyzerConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePartnerAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }
}

extension UpdatePartnerAccountInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let partnerType = partnerType else {
                let message = "Creating a URL Query Item failed. partnerType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            items.append(partnerTypeQueryItem)
            return items
        }
    }
}

extension UpdatePartnerAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let partnerAccountId = partnerAccountId else {
            return nil
        }
        return "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
    }
}

public struct UpdatePartnerAccountInput: Swift.Equatable {
    /// The ID of the partner account to update.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IoTWirelessClientTypes.PartnerType?
    /// The Sidewalk account credentials.
    /// This member is required.
    public var sidewalk: IoTWirelessClientTypes.SidewalkUpdateAccount?

    public init(
        partnerAccountId: Swift.String? = nil,
        partnerType: IoTWirelessClientTypes.PartnerType? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkUpdateAccount? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
        self.sidewalk = sidewalk
    }
}

struct UpdatePartnerAccountInputBody: Swift.Equatable {
    let sidewalk: IoTWirelessClientTypes.SidewalkUpdateAccount?
}

extension UpdatePartnerAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkUpdateAccount.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension UpdatePartnerAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePartnerAccountOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePartnerAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePositionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case position = "Position"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for positioncoordinatevalue0 in position {
                try positionContainer.encode(positioncoordinatevalue0)
            }
        }
    }
}

extension UpdatePositionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension UpdatePositionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/positions/\(resourceIdentifier.urlPercentEncoding())"
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct UpdatePositionInput: Swift.Equatable {
    /// The position information of the resource.
    /// This member is required.
    public var position: [Swift.Float]?
    /// Resource identifier of the resource for which position is updated.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// Resource type of the resource for which position is updated.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init(
        position: [Swift.Float]? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.position = position
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct UpdatePositionInputBody: Swift.Equatable {
    let position: [Swift.Float]?
}

extension UpdatePositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case position = "Position"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positionContainer = try containerValues.decodeIfPresent([Swift.Float?].self, forKey: .position)
        var positionDecoded0:[Swift.Float]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Float]()
            for float0 in positionContainer {
                if let float0 = float0 {
                    positionDecoded0?.append(float0)
                }
            }
        }
        position = positionDecoded0
    }
}

extension UpdatePositionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct UpdatePositionOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePositionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResourceEventConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case deviceRegistrationState = "DeviceRegistrationState"
        case join = "Join"
        case messageDeliveryStatus = "MessageDeliveryStatus"
        case proximity = "Proximity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionStatus = self.connectionStatus {
            try encodeContainer.encode(connectionStatus, forKey: .connectionStatus)
        }
        if let deviceRegistrationState = self.deviceRegistrationState {
            try encodeContainer.encode(deviceRegistrationState, forKey: .deviceRegistrationState)
        }
        if let join = self.join {
            try encodeContainer.encode(join, forKey: .join)
        }
        if let messageDeliveryStatus = self.messageDeliveryStatus {
            try encodeContainer.encode(messageDeliveryStatus, forKey: .messageDeliveryStatus)
        }
        if let proximity = self.proximity {
            try encodeContainer.encode(proximity, forKey: .proximity)
        }
    }
}

extension UpdateResourceEventConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let partnerType = partnerType {
                let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
                items.append(partnerTypeQueryItem)
            }
            guard let identifierType = identifierType else {
                let message = "Creating a URL Query Item failed. identifierType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let identifierTypeQueryItem = ClientRuntime.URLQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
            items.append(identifierTypeQueryItem)
            return items
        }
    }
}

extension UpdateResourceEventConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/event-configurations/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateResourceEventConfigurationInput: Swift.Equatable {
    /// Event configuration for the connection status event.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration?
    /// Event configuration for the device registration state event.
    public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
    /// Resource identifier to opt in for event messaging.
    /// This member is required.
    public var identifier: Swift.String?
    /// Identifier type of the particular resource identifier for event configuration.
    /// This member is required.
    public var identifierType: IoTWirelessClientTypes.IdentifierType?
    /// Event configuration for the join event.
    public var join: IoTWirelessClientTypes.JoinEventConfiguration?
    /// Event configuration for the message delivery status event.
    public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration?
    /// Partner type of the resource if the identifier type is PartnerAccountId
    public var partnerType: IoTWirelessClientTypes.EventNotificationPartnerType?
    /// Event configuration for the proximity event.
    public var proximity: IoTWirelessClientTypes.ProximityEventConfiguration?

    public init(
        connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration? = nil,
        deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration? = nil,
        identifier: Swift.String? = nil,
        identifierType: IoTWirelessClientTypes.IdentifierType? = nil,
        join: IoTWirelessClientTypes.JoinEventConfiguration? = nil,
        messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration? = nil,
        partnerType: IoTWirelessClientTypes.EventNotificationPartnerType? = nil,
        proximity: IoTWirelessClientTypes.ProximityEventConfiguration? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.deviceRegistrationState = deviceRegistrationState
        self.identifier = identifier
        self.identifierType = identifierType
        self.join = join
        self.messageDeliveryStatus = messageDeliveryStatus
        self.partnerType = partnerType
        self.proximity = proximity
    }
}

struct UpdateResourceEventConfigurationInputBody: Swift.Equatable {
    let deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
    let proximity: IoTWirelessClientTypes.ProximityEventConfiguration?
    let join: IoTWirelessClientTypes.JoinEventConfiguration?
    let connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration?
    let messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration?
}

extension UpdateResourceEventConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case deviceRegistrationState = "DeviceRegistrationState"
        case join = "Join"
        case messageDeliveryStatus = "MessageDeliveryStatus"
        case proximity = "Proximity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceRegistrationStateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration.self, forKey: .deviceRegistrationState)
        deviceRegistrationState = deviceRegistrationStateDecoded
        let proximityDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ProximityEventConfiguration.self, forKey: .proximity)
        proximity = proximityDecoded
        let joinDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.JoinEventConfiguration.self, forKey: .join)
        join = joinDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ConnectionStatusEventConfiguration.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let messageDeliveryStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration.self, forKey: .messageDeliveryStatus)
        messageDeliveryStatus = messageDeliveryStatusDecoded
    }
}

extension UpdateResourceEventConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateResourceEventConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateResourceEventConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct UpdateResourcePositionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourcePositionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourcePositionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateResourcePositionOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let geoJsonPayload = input.operationInput.geoJsonPayload {
            let geoJsonPayloadData = geoJsonPayload
            let geoJsonPayloadBody = ClientRuntime.HttpBody.data(geoJsonPayloadData)
            input.builder.withBody(geoJsonPayloadBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourcePositionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourcePositionOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateResourcePositionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geoJsonPayload = "GeoJsonPayload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geoJsonPayload = self.geoJsonPayload {
            try encodeContainer.encode(geoJsonPayload.base64EncodedString(), forKey: .geoJsonPayload)
        }
    }
}

extension UpdateResourcePositionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension UpdateResourcePositionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/resource-positions/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateResourcePositionInput: Swift.Equatable {
    /// The position information of the resource, displayed as a JSON payload. The payload uses the GeoJSON format, which a format that's used to encode geographic data structures. For more information, see [GeoJSON](https://geojson.org/).
    public var geoJsonPayload: ClientRuntime.Data?
    /// The identifier of the resource for which position information is updated. It can be the wireless device ID or the wireless gateway ID, depending on the resource type.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of resource for which position information is updated, which can be a wireless device or a wireless gateway.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init(
        geoJsonPayload: ClientRuntime.Data? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.geoJsonPayload = geoJsonPayload
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct UpdateResourcePositionInputBody: Swift.Equatable {
    let geoJsonPayload: ClientRuntime.Data?
}

extension UpdateResourcePositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geoJsonPayload = "GeoJsonPayload"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoJsonPayloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .geoJsonPayload)
        geoJsonPayload = geoJsonPayloadDecoded
    }
}

extension UpdateResourcePositionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateResourcePositionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateResourcePositionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWirelessDeviceImportTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }
}

extension UpdateWirelessDeviceImportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless_device_import_task/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWirelessDeviceImportTaskInput: Swift.Equatable {
    /// The identifier of the import task to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The Sidewalk-related parameters of the import task to be updated.
    /// This member is required.
    public var sidewalk: IoTWirelessClientTypes.SidewalkUpdateImportInfo?

    public init(
        id: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkUpdateImportInfo? = nil
    )
    {
        self.id = id
        self.sidewalk = sidewalk
    }
}

struct UpdateWirelessDeviceImportTaskInputBody: Swift.Equatable {
    let sidewalk: IoTWirelessClientTypes.SidewalkUpdateImportInfo?
}

extension UpdateWirelessDeviceImportTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkUpdateImportInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension UpdateWirelessDeviceImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateWirelessDeviceImportTaskOutput: Swift.Equatable {

    public init() { }
}

enum UpdateWirelessDeviceImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWirelessDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case positioning = "Positioning"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let positioning = self.positioning {
            try encodeContainer.encode(positioning.rawValue, forKey: .positioning)
        }
    }
}

extension UpdateWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWirelessDeviceInput: Swift.Equatable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The name of the new destination for the device.
    public var destinationName: Swift.String?
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The updated wireless device's configuration.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateDevice?
    /// The new name of the resource.
    public var name: Swift.String?
    /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
    public var positioning: IoTWirelessClientTypes.PositioningConfigStatus?

    public init(
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateDevice? = nil,
        name: Swift.String? = nil,
        positioning: IoTWirelessClientTypes.PositioningConfigStatus? = nil
    )
    {
        self.description = description
        self.destinationName = destinationName
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.positioning = positioning
    }
}

struct UpdateWirelessDeviceInputBody: Swift.Equatable {
    let destinationName: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateDevice?
    let positioning: IoTWirelessClientTypes.PositioningConfigStatus?
}

extension UpdateWirelessDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case positioning = "Positioning"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANUpdateDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let positioningDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositioningConfigStatus.self, forKey: .positioning)
        positioning = positioningDecoded
    }
}

extension UpdateWirelessDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateWirelessDeviceOutput: Swift.Equatable {

    public init() { }
}

enum UpdateWirelessDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWirelessGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case joinEuiFilters = "JoinEuiFilters"
        case maxEirp = "MaxEirp"
        case name = "Name"
        case netIdFilters = "NetIdFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let joinEuiFilters = joinEuiFilters {
            var joinEuiFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .joinEuiFilters)
            for joineuirange0 in joinEuiFilters {
                var joineuirange0Container = joinEuiFiltersContainer.nestedUnkeyedContainer()
                for joineui1 in joineuirange0 {
                    try joineuirange0Container.encode(joineui1)
                }
            }
        }
        if let maxEirp = self.maxEirp {
            try encodeContainer.encode(maxEirp, forKey: .maxEirp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let netIdFilters = netIdFilters {
            var netIdFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .netIdFilters)
            for netid0 in netIdFilters {
                try netIdFiltersContainer.encode(netid0)
            }
        }
    }
}

extension UpdateWirelessGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWirelessGatewayInput: Swift.Equatable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.
    public var joinEuiFilters: [[Swift.String]]?
    /// The MaxEIRP value.
    public var maxEirp: Swift.Float?
    /// The new name of the resource.
    public var name: Swift.String?
    /// A list of NetId values that are used by LoRa gateways to filter the uplink frames.
    public var netIdFilters: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        joinEuiFilters: [[Swift.String]]? = nil,
        maxEirp: Swift.Float? = nil,
        name: Swift.String? = nil,
        netIdFilters: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.joinEuiFilters = joinEuiFilters
        self.maxEirp = maxEirp
        self.name = name
        self.netIdFilters = netIdFilters
    }
}

struct UpdateWirelessGatewayInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let joinEuiFilters: [[Swift.String]]?
    let netIdFilters: [Swift.String]?
    let maxEirp: Swift.Float?
}

extension UpdateWirelessGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case joinEuiFilters = "JoinEuiFilters"
        case maxEirp = "MaxEirp"
        case name = "Name"
        case netIdFilters = "NetIdFilters"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let joinEuiFiltersContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .joinEuiFilters)
        var joinEuiFiltersDecoded0:[[Swift.String]]? = nil
        if let joinEuiFiltersContainer = joinEuiFiltersContainer {
            joinEuiFiltersDecoded0 = [[Swift.String]]()
            for list0 in joinEuiFiltersContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    joinEuiFiltersDecoded0?.append(list0Decoded0)
                }
            }
        }
        joinEuiFilters = joinEuiFiltersDecoded0
        let netIdFiltersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .netIdFilters)
        var netIdFiltersDecoded0:[Swift.String]? = nil
        if let netIdFiltersContainer = netIdFiltersContainer {
            netIdFiltersDecoded0 = [Swift.String]()
            for string0 in netIdFiltersContainer {
                if let string0 = string0 {
                    netIdFiltersDecoded0?.append(string0)
                }
            }
        }
        netIdFilters = netIdFiltersDecoded0
        let maxEirpDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .maxEirp)
        maxEirp = maxEirpDecoded
    }
}

extension UpdateWirelessGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateWirelessGatewayOutput: Swift.Equatable {

    public init() { }
}

enum UpdateWirelessGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
        case updateDataRole = "UpdateDataRole"
        case updateDataSource = "UpdateDataSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let updateDataRole = self.updateDataRole {
            try encodeContainer.encode(updateDataRole, forKey: .updateDataRole)
        }
        if let updateDataSource = self.updateDataSource {
            try encodeContainer.encode(updateDataSource, forKey: .updateDataSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateDataSource)
        updateDataSource = updateDataSourceDecoded
        let updateDataRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateDataRole)
        updateDataRole = updateDataRoleDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension IoTWirelessClientTypes {
    /// UpdateWirelessGatewayTaskCreate object.
    public struct UpdateWirelessGatewayTaskCreate: Swift.Equatable {
        /// The properties that relate to the LoRaWAN wireless gateway.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate?
        /// The IAM role used to read data from the S3 bucket.
        public var updateDataRole: Swift.String?
        /// The link to the S3 bucket.
        public var updateDataSource: Swift.String?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate? = nil,
            updateDataRole: Swift.String? = nil,
            updateDataSource: Swift.String? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.updateDataRole = updateDataRole
            self.updateDataSource = updateDataSource
        }
    }

}

extension IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTWirelessClientTypes {
    /// UpdateWirelessGatewayTaskEntry object.
    public struct UpdateWirelessGatewayTaskEntry: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the new wireless gateway task entry.
        public var id: Swift.String?
        /// The properties that relate to the LoRaWAN wireless gateway.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.loRaWAN = loRaWAN
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input did not meet the specified constraints.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTWirelessClientTypes.WcdmaLocalId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case psc = "Psc"
        case uarfcndl = "Uarfcndl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let psc = self.psc {
            try encodeContainer.encode(psc, forKey: .psc)
        }
        if let uarfcndl = self.uarfcndl {
            try encodeContainer.encode(uarfcndl, forKey: .uarfcndl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uarfcndlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uarfcndl)
        uarfcndl = uarfcndlDecoded
        let pscDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .psc)
        psc = pscDecoded
    }
}

extension IoTWirelessClientTypes {
    /// WCDMA local identification (local ID) information.
    public struct WcdmaLocalId: Swift.Equatable {
        /// Primary Scrambling Code.
        /// This member is required.
        public var psc: Swift.Int?
        /// WCDMA UTRA Absolute RF Channel Number downlink.
        /// This member is required.
        public var uarfcndl: Swift.Int?

        public init(
            psc: Swift.Int? = nil,
            uarfcndl: Swift.Int? = nil
        )
        {
            self.psc = psc
            self.uarfcndl = uarfcndl
        }
    }

}

extension IoTWirelessClientTypes.WcdmaNmrObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pathLoss = "PathLoss"
        case psc = "Psc"
        case rscp = "Rscp"
        case uarfcndl = "Uarfcndl"
        case utranCid = "UtranCid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pathLoss = self.pathLoss {
            try encodeContainer.encode(pathLoss, forKey: .pathLoss)
        }
        if let psc = self.psc {
            try encodeContainer.encode(psc, forKey: .psc)
        }
        if let rscp = self.rscp {
            try encodeContainer.encode(rscp, forKey: .rscp)
        }
        if let uarfcndl = self.uarfcndl {
            try encodeContainer.encode(uarfcndl, forKey: .uarfcndl)
        }
        if let utranCid = self.utranCid {
            try encodeContainer.encode(utranCid, forKey: .utranCid)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uarfcndlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uarfcndl)
        uarfcndl = uarfcndlDecoded
        let pscDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .psc)
        psc = pscDecoded
        let utranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .utranCid)
        utranCid = utranCidDecoded
        let rscpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rscp)
        rscp = rscpDecoded
        let pathLossDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pathLoss)
        pathLoss = pathLossDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Network Measurement Reports.
    public struct WcdmaNmrObj: Swift.Equatable {
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public var pathLoss: Swift.Int?
        /// Primary Scrambling Code.
        /// This member is required.
        public var psc: Swift.Int?
        /// Received Signal Code Power (signal power) (dBm)
        public var rscp: Swift.Int?
        /// WCDMA UTRA Absolute RF Channel Number downlink.
        /// This member is required.
        public var uarfcndl: Swift.Int?
        /// UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var utranCid: Swift.Int?

        public init(
            pathLoss: Swift.Int? = nil,
            psc: Swift.Int? = nil,
            rscp: Swift.Int? = nil,
            uarfcndl: Swift.Int? = nil,
            utranCid: Swift.Int? = nil
        )
        {
            self.pathLoss = pathLoss
            self.psc = psc
            self.rscp = rscp
            self.uarfcndl = uarfcndl
            self.utranCid = utranCid
        }
    }

}

extension IoTWirelessClientTypes.WcdmaObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lac = "Lac"
        case mcc = "Mcc"
        case mnc = "Mnc"
        case pathLoss = "PathLoss"
        case rscp = "Rscp"
        case utranCid = "UtranCid"
        case wcdmaLocalId = "WcdmaLocalId"
        case wcdmaNmr = "WcdmaNmr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lac = self.lac {
            try encodeContainer.encode(lac, forKey: .lac)
        }
        if let mcc = self.mcc {
            try encodeContainer.encode(mcc, forKey: .mcc)
        }
        if let mnc = self.mnc {
            try encodeContainer.encode(mnc, forKey: .mnc)
        }
        if let pathLoss = self.pathLoss {
            try encodeContainer.encode(pathLoss, forKey: .pathLoss)
        }
        if let rscp = self.rscp {
            try encodeContainer.encode(rscp, forKey: .rscp)
        }
        if let utranCid = self.utranCid {
            try encodeContainer.encode(utranCid, forKey: .utranCid)
        }
        if let wcdmaLocalId = self.wcdmaLocalId {
            try encodeContainer.encode(wcdmaLocalId, forKey: .wcdmaLocalId)
        }
        if let wcdmaNmr = wcdmaNmr {
            var wcdmaNmrContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wcdmaNmr)
            for wcdmanmrobj0 in wcdmaNmr {
                try wcdmaNmrContainer.encode(wcdmanmrobj0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mccDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mcc)
        mcc = mccDecoded
        let mncDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mnc)
        mnc = mncDecoded
        let lacDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lac)
        lac = lacDecoded
        let utranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .utranCid)
        utranCid = utranCidDecoded
        let wcdmaLocalIdDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WcdmaLocalId.self, forKey: .wcdmaLocalId)
        wcdmaLocalId = wcdmaLocalIdDecoded
        let rscpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rscp)
        rscp = rscpDecoded
        let pathLossDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pathLoss)
        pathLoss = pathLossDecoded
        let wcdmaNmrContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WcdmaNmrObj?].self, forKey: .wcdmaNmr)
        var wcdmaNmrDecoded0:[IoTWirelessClientTypes.WcdmaNmrObj]? = nil
        if let wcdmaNmrContainer = wcdmaNmrContainer {
            wcdmaNmrDecoded0 = [IoTWirelessClientTypes.WcdmaNmrObj]()
            for structure0 in wcdmaNmrContainer {
                if let structure0 = structure0 {
                    wcdmaNmrDecoded0?.append(structure0)
                }
            }
        }
        wcdmaNmr = wcdmaNmrDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// WCDMA.
    public struct WcdmaObj: Swift.Equatable {
        /// Location Area Code.
        public var lac: Swift.Int?
        /// Mobile Country Code.
        /// This member is required.
        public var mcc: Swift.Int?
        /// Mobile Network Code.
        /// This member is required.
        public var mnc: Swift.Int?
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public var pathLoss: Swift.Int?
        /// Received Signal Code Power (signal power) (dBm).
        public var rscp: Swift.Int?
        /// UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var utranCid: Swift.Int?
        /// WCDMA local ID information.
        public var wcdmaLocalId: IoTWirelessClientTypes.WcdmaLocalId?
        /// WCDMA object for network measurement reports.
        public var wcdmaNmr: [IoTWirelessClientTypes.WcdmaNmrObj]?

        public init(
            lac: Swift.Int? = nil,
            mcc: Swift.Int? = nil,
            mnc: Swift.Int? = nil,
            pathLoss: Swift.Int? = nil,
            rscp: Swift.Int? = nil,
            utranCid: Swift.Int? = nil,
            wcdmaLocalId: IoTWirelessClientTypes.WcdmaLocalId? = nil,
            wcdmaNmr: [IoTWirelessClientTypes.WcdmaNmrObj]? = nil
        )
        {
            self.lac = lac
            self.mcc = mcc
            self.mnc = mnc
            self.pathLoss = pathLoss
            self.rscp = rscp
            self.utranCid = utranCid
            self.wcdmaLocalId = wcdmaLocalId
            self.wcdmaNmr = wcdmaNmr
        }
    }

}

extension IoTWirelessClientTypes.WiFiAccessPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case macAddress = "MacAddress"
        case rss = "Rss"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let macAddress = self.macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
        if let rss = self.rss {
            try encodeContainer.encode(rss, forKey: .rss)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let rssDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rss)
        rss = rssDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Wi-Fi access point.
    public struct WiFiAccessPoint: Swift.Equatable {
        /// Wi-Fi MAC Address.
        /// This member is required.
        public var macAddress: Swift.String?
        /// Received signal strength (dBm) of the WLAN measurement data.
        /// This member is required.
        public var rss: Swift.Int?

        public init(
            macAddress: Swift.String? = nil,
            rss: Swift.Int? = nil
        )
        {
            self.macAddress = macAddress
            self.rss = rss
        }
    }

}

extension IoTWirelessClientTypes {
    /// The event for a log message, if the log message is tied to a wireless device.
    public enum WirelessDeviceEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case downlinkData
        case join
        case registration
        case rejoin
        case uplinkData
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceEvent] {
            return [
                .downlinkData,
                .join,
                .registration,
                .rejoin,
                .uplinkData,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .downlinkData: return "Downlink_Data"
            case .join: return "Join"
            case .registration: return "Registration"
            case .rejoin: return "Rejoin"
            case .uplinkData: return "Uplink_Data"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceEvent(rawValue: rawValue) ?? WirelessDeviceEvent.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.WirelessDeviceEventLogOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event = "Event"
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessDeviceEvent.self, forKey: .event)
        event = eventDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The log options for a wireless device event and can be used to set log levels for a specific wireless device event. For a LoRaWAN device, possible events for a log messsage are: Join, Rejoin, Downlink_Data, and Uplink_Data. For a Sidewalk device, possible events for a log message are Registration, Downlink_Data, and Uplink_Data.
    public struct WirelessDeviceEventLogOption: Swift.Equatable {
        /// The event for a log message, if the log message is tied to a wireless device.
        /// This member is required.
        public var event: IoTWirelessClientTypes.WirelessDeviceEvent?
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        /// This member is required.
        public var logLevel: IoTWirelessClientTypes.LogLevel?

        public init(
            event: IoTWirelessClientTypes.WirelessDeviceEvent? = nil,
            logLevel: IoTWirelessClientTypes.LogLevel? = nil
        )
        {
            self.event = event
            self.logLevel = logLevel
        }
    }

}

extension IoTWirelessClientTypes {
    /// FrameInfo of your wireless device resources for the trace content. Use FrameInfo to debug the communication between your LoRaWAN end devices and the network server.
    public enum WirelessDeviceFrameInfo: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceFrameInfo] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceFrameInfo(rawValue: rawValue) ?? WirelessDeviceFrameInfo.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum WirelessDeviceIdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deveui
        case sidewalkmanufacturingsn
        case thingname
        case wirelessdeviceid
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceIdType] {
            return [
                .deveui,
                .sidewalkmanufacturingsn,
                .thingname,
                .wirelessdeviceid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deveui: return "DevEui"
            case .sidewalkmanufacturingsn: return "SidewalkManufacturingSn"
            case .thingname: return "ThingName"
            case .wirelessdeviceid: return "WirelessDeviceId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceIdType(rawValue: rawValue) ?? WirelessDeviceIdType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.WirelessDeviceImportTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case destinationName = "DestinationName"
        case failedImportedDeviceCount = "FailedImportedDeviceCount"
        case id = "Id"
        case initializedImportedDeviceCount = "InitializedImportedDeviceCount"
        case onboardedImportedDeviceCount = "OnboardedImportedDeviceCount"
        case pendingImportedDeviceCount = "PendingImportedDeviceCount"
        case sidewalk = "Sidewalk"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let failedImportedDeviceCount = self.failedImportedDeviceCount {
            try encodeContainer.encode(failedImportedDeviceCount, forKey: .failedImportedDeviceCount)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let initializedImportedDeviceCount = self.initializedImportedDeviceCount {
            try encodeContainer.encode(initializedImportedDeviceCount, forKey: .initializedImportedDeviceCount)
        }
        if let onboardedImportedDeviceCount = self.onboardedImportedDeviceCount {
            try encodeContainer.encode(onboardedImportedDeviceCount, forKey: .onboardedImportedDeviceCount)
        }
        if let pendingImportedDeviceCount = self.pendingImportedDeviceCount {
            try encodeContainer.encode(pendingImportedDeviceCount, forKey: .pendingImportedDeviceCount)
        }
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkGetStartImportInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ImportTaskStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let initializedImportedDeviceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .initializedImportedDeviceCount)
        initializedImportedDeviceCount = initializedImportedDeviceCountDecoded
        let pendingImportedDeviceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pendingImportedDeviceCount)
        pendingImportedDeviceCount = pendingImportedDeviceCountDecoded
        let onboardedImportedDeviceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .onboardedImportedDeviceCount)
        onboardedImportedDeviceCount = onboardedImportedDeviceCountDecoded
        let failedImportedDeviceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedImportedDeviceCount)
        failedImportedDeviceCount = failedImportedDeviceCountDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about an import task for wireless devices.
    public struct WirelessDeviceImportTask: Swift.Equatable {
        /// The ARN (Amazon Resource Name) of the wireless device import task.
        public var arn: Swift.String?
        /// The time at which the import task was created.
        public var creationTime: ClientRuntime.Date?
        /// The name of the Sidewalk destination that that describes the IoT rule to route messages from the device in the import task that will be onboarded to AWS IoT Wireless
        public var destinationName: Swift.String?
        /// The summary information of count of wireless devices in an import task that failed to onboarded to the import task.
        public var failedImportedDeviceCount: Swift.Int?
        /// The ID of the wireless device import task.
        public var id: Swift.String?
        /// The summary information of count of wireless devices that are waiting for the control log to be added to an import task.
        public var initializedImportedDeviceCount: Swift.Int?
        /// The summary information of count of wireless devices in an import task that have been onboarded to the import task.
        public var onboardedImportedDeviceCount: Swift.Int?
        /// The summary information of count of wireless devices in an import task that are waiting in the queue to be onboarded.
        public var pendingImportedDeviceCount: Swift.Int?
        /// The Sidewalk-related information of the wireless device import task.
        public var sidewalk: IoTWirelessClientTypes.SidewalkGetStartImportInfo?
        /// The status information of the wireless device import task.
        public var status: IoTWirelessClientTypes.ImportTaskStatus?
        /// The reason that provides additional information about the import task status.
        public var statusReason: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            destinationName: Swift.String? = nil,
            failedImportedDeviceCount: Swift.Int? = nil,
            id: Swift.String? = nil,
            initializedImportedDeviceCount: Swift.Int? = nil,
            onboardedImportedDeviceCount: Swift.Int? = nil,
            pendingImportedDeviceCount: Swift.Int? = nil,
            sidewalk: IoTWirelessClientTypes.SidewalkGetStartImportInfo? = nil,
            status: IoTWirelessClientTypes.ImportTaskStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.failedImportedDeviceCount = failedImportedDeviceCount
            self.id = id
            self.initializedImportedDeviceCount = initializedImportedDeviceCount
            self.onboardedImportedDeviceCount = onboardedImportedDeviceCount
            self.pendingImportedDeviceCount = pendingImportedDeviceCount
            self.sidewalk = sidewalk
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension IoTWirelessClientTypes.WirelessDeviceLogOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case logLevel = "LogLevel"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for wirelessdeviceeventlogoption0 in events {
                try eventsContainer.encode(wirelessdeviceeventlogoption0)
            }
        }
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let eventsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessDeviceEventLogOption?].self, forKey: .events)
        var eventsDecoded0:[IoTWirelessClientTypes.WirelessDeviceEventLogOption]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IoTWirelessClientTypes.WirelessDeviceEventLogOption]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// The log options for wireless devices and can be used to set log levels for a specific type of wireless device.
    public struct WirelessDeviceLogOption: Swift.Equatable {
        /// The list of wireless device event log options.
        public var events: [IoTWirelessClientTypes.WirelessDeviceEventLogOption]?
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        /// This member is required.
        public var logLevel: IoTWirelessClientTypes.LogLevel?
        /// The wireless device type.
        /// This member is required.
        public var type: IoTWirelessClientTypes.WirelessDeviceType?

        public init(
            events: [IoTWirelessClientTypes.WirelessDeviceEventLogOption]? = nil,
            logLevel: IoTWirelessClientTypes.LogLevel? = nil,
            type: IoTWirelessClientTypes.WirelessDeviceType? = nil
        )
        {
            self.events = events
            self.logLevel = logLevel
            self.type = type
        }
    }

}

extension IoTWirelessClientTypes {
    public enum WirelessDeviceSidewalkStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activated
        case provisioned
        case registered
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceSidewalkStatus] {
            return [
                .activated,
                .provisioned,
                .registered,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .provisioned: return "PROVISIONED"
            case .registered: return "REGISTERED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceSidewalkStatus(rawValue: rawValue) ?? WirelessDeviceSidewalkStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.WirelessDeviceStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case destinationName = "DestinationName"
        case fuotaDeviceStatus = "FuotaDeviceStatus"
        case id = "Id"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case mcGroupId = "McGroupId"
        case multicastDeviceStatus = "MulticastDeviceStatus"
        case name = "Name"
        case sidewalk = "Sidewalk"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let fuotaDeviceStatus = self.fuotaDeviceStatus {
            try encodeContainer.encode(fuotaDeviceStatus.rawValue, forKey: .fuotaDeviceStatus)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUplinkReceivedAt = self.lastUplinkReceivedAt {
            try encodeContainer.encode(lastUplinkReceivedAt, forKey: .lastUplinkReceivedAt)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let mcGroupId = self.mcGroupId {
            try encodeContainer.encode(mcGroupId, forKey: .mcGroupId)
        }
        if let multicastDeviceStatus = self.multicastDeviceStatus {
            try encodeContainer.encode(multicastDeviceStatus, forKey: .multicastDeviceStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANListDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkListDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let fuotaDeviceStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.FuotaDeviceStatus.self, forKey: .fuotaDeviceStatus)
        fuotaDeviceStatus = fuotaDeviceStatusDecoded
        let multicastDeviceStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multicastDeviceStatus)
        multicastDeviceStatus = multicastDeviceStatusDecoded
        let mcGroupIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mcGroupId)
        mcGroupId = mcGroupIdDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about a wireless device's operation.
    public struct WirelessDeviceStatistics: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The name of the destination to which the device is assigned.
        public var destinationName: Swift.String?
        /// The status of a wireless device in a FUOTA task.
        public var fuotaDeviceStatus: IoTWirelessClientTypes.FuotaDeviceStatus?
        /// The ID of the wireless device reporting the data.
        public var id: Swift.String?
        /// The date and time when the most recent uplink was received. Theis value is only valid for 3 months.
        public var lastUplinkReceivedAt: Swift.String?
        /// LoRaWAN device info.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANListDevice?
        /// Id of the multicast group.
        public var mcGroupId: Swift.Int?
        /// The status of the wireless device in the multicast group.
        public var multicastDeviceStatus: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?
        /// The Sidewalk account credentials.
        public var sidewalk: IoTWirelessClientTypes.SidewalkListDevice?
        /// The wireless device type.
        public var type: IoTWirelessClientTypes.WirelessDeviceType?

        public init(
            arn: Swift.String? = nil,
            destinationName: Swift.String? = nil,
            fuotaDeviceStatus: IoTWirelessClientTypes.FuotaDeviceStatus? = nil,
            id: Swift.String? = nil,
            lastUplinkReceivedAt: Swift.String? = nil,
            loRaWAN: IoTWirelessClientTypes.LoRaWANListDevice? = nil,
            mcGroupId: Swift.Int? = nil,
            multicastDeviceStatus: Swift.String? = nil,
            name: Swift.String? = nil,
            sidewalk: IoTWirelessClientTypes.SidewalkListDevice? = nil,
            type: IoTWirelessClientTypes.WirelessDeviceType? = nil
        )
        {
            self.arn = arn
            self.destinationName = destinationName
            self.fuotaDeviceStatus = fuotaDeviceStatus
            self.id = id
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.loRaWAN = loRaWAN
            self.mcGroupId = mcGroupId
            self.multicastDeviceStatus = multicastDeviceStatus
            self.name = name
            self.sidewalk = sidewalk
            self.type = type
        }
    }

}

extension IoTWirelessClientTypes {
    public enum WirelessDeviceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lorawan
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceType] {
            return [
                .lorawan,
                .sidewalk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lorawan: return "LoRaWAN"
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceType(rawValue: rawValue) ?? WirelessDeviceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    /// The event for a log message, if the log message is tied to a wireless gateway.
    public enum WirelessGatewayEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cupsRequest
        case certificate
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayEvent] {
            return [
                .cupsRequest,
                .certificate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cupsRequest: return "CUPS_Request"
            case .certificate: return "Certificate"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayEvent(rawValue: rawValue) ?? WirelessGatewayEvent.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.WirelessGatewayEventLogOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event = "Event"
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessGatewayEvent.self, forKey: .event)
        event = eventDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The log options for a wireless gateway event and can be used to set log levels for a specific wireless gateway event. For a LoRaWAN gateway, possible events for a log message are CUPS_Request and Certificate.
    public struct WirelessGatewayEventLogOption: Swift.Equatable {
        /// The event for a log message, if the log message is tied to a wireless gateway.
        /// This member is required.
        public var event: IoTWirelessClientTypes.WirelessGatewayEvent?
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        /// This member is required.
        public var logLevel: IoTWirelessClientTypes.LogLevel?

        public init(
            event: IoTWirelessClientTypes.WirelessGatewayEvent? = nil,
            logLevel: IoTWirelessClientTypes.LogLevel? = nil
        )
        {
            self.event = event
            self.logLevel = logLevel
        }
    }

}

extension IoTWirelessClientTypes {
    public enum WirelessGatewayIdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gatewayeui
        case thingname
        case wirelessgatewayid
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayIdType] {
            return [
                .gatewayeui,
                .thingname,
                .wirelessgatewayid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gatewayeui: return "GatewayEui"
            case .thingname: return "ThingName"
            case .wirelessgatewayid: return "WirelessGatewayId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayIdType(rawValue: rawValue) ?? WirelessGatewayIdType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.WirelessGatewayLogOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case logLevel = "LogLevel"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for wirelessgatewayeventlogoption0 in events {
                try eventsContainer.encode(wirelessgatewayeventlogoption0)
            }
        }
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessGatewayType.self, forKey: .type)
        type = typeDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let eventsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessGatewayEventLogOption?].self, forKey: .events)
        var eventsDecoded0:[IoTWirelessClientTypes.WirelessGatewayEventLogOption]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IoTWirelessClientTypes.WirelessGatewayEventLogOption]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// The log options for wireless gateways and can be used to set log levels for a specific type of wireless gateway.
    public struct WirelessGatewayLogOption: Swift.Equatable {
        /// The list of wireless gateway event log options.
        public var events: [IoTWirelessClientTypes.WirelessGatewayEventLogOption]?
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        /// This member is required.
        public var logLevel: IoTWirelessClientTypes.LogLevel?
        /// The wireless gateway type.
        /// This member is required.
        public var type: IoTWirelessClientTypes.WirelessGatewayType?

        public init(
            events: [IoTWirelessClientTypes.WirelessGatewayEventLogOption]? = nil,
            logLevel: IoTWirelessClientTypes.LogLevel? = nil,
            type: IoTWirelessClientTypes.WirelessGatewayType? = nil
        )
        {
            self.events = events
            self.logLevel = logLevel
            self.type = type
        }
    }

}

extension IoTWirelessClientTypes {
    public enum WirelessGatewayServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cups
        case lns
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayServiceType] {
            return [
                .cups,
                .lns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cups: return "CUPS"
            case .lns: return "LNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayServiceType(rawValue: rawValue) ?? WirelessGatewayServiceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.WirelessGatewayStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUplinkReceivedAt = self.lastUplinkReceivedAt {
            try encodeContainer.encode(lastUplinkReceivedAt, forKey: .lastUplinkReceivedAt)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about a wireless gateway's operation.
    public struct WirelessGatewayStatistics: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The description of the resource.
        public var description: Swift.String?
        /// The ID of the wireless gateway reporting the data.
        public var id: Swift.String?
        /// The date and time when the most recent uplink was received. This value is only valid for 3 months.
        public var lastUplinkReceivedAt: Swift.String?
        /// LoRaWAN gateway info.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANGateway?
        /// The name of the resource.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUplinkReceivedAt: Swift.String? = nil,
            loRaWAN: IoTWirelessClientTypes.LoRaWANGateway? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.loRaWAN = loRaWAN
            self.name = name
        }
    }

}

extension IoTWirelessClientTypes {
    public enum WirelessGatewayTaskDefinitionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayTaskDefinitionType] {
            return [
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayTaskDefinitionType(rawValue: rawValue) ?? WirelessGatewayTaskDefinitionType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum WirelessGatewayTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case firstRetry
        case inProgress
        case pending
        case secondRetry
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayTaskStatus] {
            return [
                .completed,
                .failed,
                .firstRetry,
                .inProgress,
                .pending,
                .secondRetry,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .firstRetry: return "FIRST_RETRY"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .secondRetry: return "SECOND_RETRY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayTaskStatus(rawValue: rawValue) ?? WirelessGatewayTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    /// The wireless gateway type.
    public enum WirelessGatewayType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lorawan
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayType] {
            return [
                .lorawan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lorawan: return "LoRaWAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayType(rawValue: rawValue) ?? WirelessGatewayType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.WirelessMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANSendDataToDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkSendDataToDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension IoTWirelessClientTypes {
    /// WirelessMetadata object.
    public struct WirelessMetadata: Swift.Equatable {
        /// LoRaWAN device info.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANSendDataToDevice?
        /// The Sidewalk account credentials.
        public var sidewalk: IoTWirelessClientTypes.SidewalkSendDataToDevice?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANSendDataToDevice? = nil,
            sidewalk: IoTWirelessClientTypes.SidewalkSendDataToDevice? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.sidewalk = sidewalk
        }
    }

}
