// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IoTWirelessClientTypes.AbpV1_0_x: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devAddr = "DevAddr"
        case fCntStart = "FCntStart"
        case sessionKeys = "SessionKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devAddr = self.devAddr {
            try encodeContainer.encode(devAddr, forKey: .devAddr)
        }
        if let fCntStart = self.fCntStart {
            try encodeContainer.encode(fCntStart, forKey: .fCntStart)
        }
        if let sessionKeys = self.sessionKeys {
            try encodeContainer.encode(sessionKeys, forKey: .sessionKeys)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devAddrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devAddr)
        devAddr = devAddrDecoded
        let sessionKeysDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SessionKeysAbpV1_0_x.self, forKey: .sessionKeys)
        sessionKeys = sessionKeysDecoded
        let fCntStartDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fCntStart)
        fCntStart = fCntStartDecoded
    }
}

extension IoTWirelessClientTypes {
    /// ABP device object for LoRaWAN specification v1.0.x
    public struct AbpV1_0_x: Swift.Equatable {
        /// The DevAddr value.
        public var devAddr: Swift.String?
        /// The FCnt init value.
        public var fCntStart: Swift.Int?
        /// Session keys for ABP v1.0.x
        public var sessionKeys: IoTWirelessClientTypes.SessionKeysAbpV1_0_x?

        public init (
            devAddr: Swift.String? = nil,
            fCntStart: Swift.Int? = nil,
            sessionKeys: IoTWirelessClientTypes.SessionKeysAbpV1_0_x? = nil
        )
        {
            self.devAddr = devAddr
            self.fCntStart = fCntStart
            self.sessionKeys = sessionKeys
        }
    }

}

extension IoTWirelessClientTypes.AbpV1_1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devAddr = "DevAddr"
        case fCntStart = "FCntStart"
        case sessionKeys = "SessionKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devAddr = self.devAddr {
            try encodeContainer.encode(devAddr, forKey: .devAddr)
        }
        if let fCntStart = self.fCntStart {
            try encodeContainer.encode(fCntStart, forKey: .fCntStart)
        }
        if let sessionKeys = self.sessionKeys {
            try encodeContainer.encode(sessionKeys, forKey: .sessionKeys)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devAddrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devAddr)
        devAddr = devAddrDecoded
        let sessionKeysDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SessionKeysAbpV1_1.self, forKey: .sessionKeys)
        sessionKeys = sessionKeysDecoded
        let fCntStartDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fCntStart)
        fCntStart = fCntStartDecoded
    }
}

extension IoTWirelessClientTypes {
    /// ABP device object for LoRaWAN specification v1.1
    public struct AbpV1_1: Swift.Equatable {
        /// The DevAddr value.
        public var devAddr: Swift.String?
        /// The FCnt init value.
        public var fCntStart: Swift.Int?
        /// Session keys for ABP v1.1
        public var sessionKeys: IoTWirelessClientTypes.SessionKeysAbpV1_1?

        public init (
            devAddr: Swift.String? = nil,
            fCntStart: Swift.Int? = nil,
            sessionKeys: IoTWirelessClientTypes.SessionKeysAbpV1_1? = nil
        )
        {
            self.devAddr = devAddr
            self.fCntStart = fCntStart
            self.sessionKeys = sessionKeys
        }
    }

}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User does not have permission to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTWirelessClientTypes.Accuracy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case horizontalAccuracy = "HorizontalAccuracy"
        case verticalAccuracy = "VerticalAccuracy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let horizontalAccuracy = self.horizontalAccuracy {
            try encodeContainer.encode(horizontalAccuracy, forKey: .horizontalAccuracy)
        }
        if let verticalAccuracy = self.verticalAccuracy {
            try encodeContainer.encode(verticalAccuracy, forKey: .verticalAccuracy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let horizontalAccuracyDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .horizontalAccuracy)
        horizontalAccuracy = horizontalAccuracyDecoded
        let verticalAccuracyDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .verticalAccuracy)
        verticalAccuracy = verticalAccuracyDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The accuracy of the estimated position in meters. An empty value indicates that no position data is available. A value of ‘0.0’ value indicates that position data is available. This data corresponds to the position information that you specified instead of the position computed by solver.
    public struct Accuracy: Swift.Equatable {
        /// The horizontal accuracy of the estimated position, which is the difference between the estimated location and the actual device location.
        public var horizontalAccuracy: Swift.Float?
        /// The vertical accuracy of the estimated position, which is the difference between the estimated altitude and actual device latitude in meters.
        public var verticalAccuracy: Swift.Float?

        public init (
            horizontalAccuracy: Swift.Float? = nil,
            verticalAccuracy: Swift.Float? = nil
        )
        {
            self.horizontalAccuracy = horizontalAccuracy
            self.verticalAccuracy = verticalAccuracy
        }
    }

}

extension IoTWirelessClientTypes.ApplicationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationName = "DestinationName"
        case fPort = "FPort"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let fPort = self.fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fPort)
        fPort = fPortDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ApplicationConfigType.self, forKey: .type)
        type = typeDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWAN application configuration, which can be used to perform geolocation.
    public struct ApplicationConfig: Swift.Equatable {
        /// The name of the position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
        public var destinationName: Swift.String?
        /// The Fport value.
        public var fPort: Swift.Int?
        /// Application type, which can be specified to obtain real-time position information of your LoRaWAN device.
        public var type: IoTWirelessClientTypes.ApplicationConfigType?

        public init (
            destinationName: Swift.String? = nil,
            fPort: Swift.Int? = nil,
            type: IoTWirelessClientTypes.ApplicationConfigType? = nil
        )
        {
            self.destinationName = destinationName
            self.fPort = fPort
            self.type = type
        }
    }

}

extension IoTWirelessClientTypes {
    public enum ApplicationConfigType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case semtechgeolocation
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationConfigType] {
            return [
                .semtechgeolocation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .semtechgeolocation: return "SemtechGeolocation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationConfigType(rawValue: rawValue) ?? ApplicationConfigType.sdkUnknown(rawValue)
        }
    }
}

extension AssociateAwsAccountWithPartnerAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension AssociateAwsAccountWithPartnerAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/partner-accounts"
    }
}

public struct AssociateAwsAccountWithPartnerAccountInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The Sidewalk account credentials.
    /// This member is required.
    public var sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo?
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sidewalk = sidewalk
        self.tags = tags
    }
}

struct AssociateAwsAccountWithPartnerAccountInputBody: Swift.Equatable {
    let sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo?
    let clientRequestToken: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension AssociateAwsAccountWithPartnerAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkAccountInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AssociateAwsAccountWithPartnerAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAwsAccountWithPartnerAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateAwsAccountWithPartnerAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAwsAccountWithPartnerAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateAwsAccountWithPartnerAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.sidewalk = output.sidewalk
        } else {
            self.arn = nil
            self.sidewalk = nil
        }
    }
}

public struct AssociateAwsAccountWithPartnerAccountOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The Sidewalk account credentials.
    public var sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo?

    public init (
        arn: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo? = nil
    )
    {
        self.arn = arn
        self.sidewalk = sidewalk
    }
}

struct AssociateAwsAccountWithPartnerAccountOutputResponseBody: Swift.Equatable {
    let sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo?
    let arn: Swift.String?
}

extension AssociateAwsAccountWithPartnerAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkAccountInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension AssociateMulticastGroupWithFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastGroupId = "MulticastGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let multicastGroupId = self.multicastGroupId {
            try encodeContainer.encode(multicastGroupId, forKey: .multicastGroupId)
        }
    }
}

extension AssociateMulticastGroupWithFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/multicast-group"
    }
}

public struct AssociateMulticastGroupWithFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the multicast group.
    /// This member is required.
    public var multicastGroupId: Swift.String?

    public init (
        id: Swift.String? = nil,
        multicastGroupId: Swift.String? = nil
    )
    {
        self.id = id
        self.multicastGroupId = multicastGroupId
    }
}

struct AssociateMulticastGroupWithFuotaTaskInputBody: Swift.Equatable {
    let multicastGroupId: Swift.String?
}

extension AssociateMulticastGroupWithFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastGroupId = "MulticastGroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multicastGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multicastGroupId)
        multicastGroupId = multicastGroupIdDecoded
    }
}

extension AssociateMulticastGroupWithFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateMulticastGroupWithFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateMulticastGroupWithFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateMulticastGroupWithFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateMulticastGroupWithFuotaTaskOutputResponse: Swift.Equatable {

    public init () { }
}

extension AssociateWirelessDeviceWithFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessDeviceId = self.wirelessDeviceId {
            try encodeContainer.encode(wirelessDeviceId, forKey: .wirelessDeviceId)
        }
    }
}

extension AssociateWirelessDeviceWithFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/wireless-device"
    }
}

public struct AssociateWirelessDeviceWithFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init (
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct AssociateWirelessDeviceWithFuotaTaskInputBody: Swift.Equatable {
    let wirelessDeviceId: Swift.String?
}

extension AssociateWirelessDeviceWithFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessDeviceId)
        wirelessDeviceId = wirelessDeviceIdDecoded
    }
}

extension AssociateWirelessDeviceWithFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessDeviceWithFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateWirelessDeviceWithFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessDeviceWithFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateWirelessDeviceWithFuotaTaskOutputResponse: Swift.Equatable {

    public init () { }
}

extension AssociateWirelessDeviceWithMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessDeviceId = self.wirelessDeviceId {
            try encodeContainer.encode(wirelessDeviceId, forKey: .wirelessDeviceId)
        }
    }
}

extension AssociateWirelessDeviceWithMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/wireless-device"
    }
}

public struct AssociateWirelessDeviceWithMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init (
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct AssociateWirelessDeviceWithMulticastGroupInputBody: Swift.Equatable {
    let wirelessDeviceId: Swift.String?
}

extension AssociateWirelessDeviceWithMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessDeviceId)
        wirelessDeviceId = wirelessDeviceIdDecoded
    }
}

extension AssociateWirelessDeviceWithMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessDeviceWithMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateWirelessDeviceWithMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessDeviceWithMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateWirelessDeviceWithMulticastGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension AssociateWirelessDeviceWithThingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }
}

extension AssociateWirelessDeviceWithThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/thing"
    }
}

public struct AssociateWirelessDeviceWithThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of the thing to associate with the wireless device.
    /// This member is required.
    public var thingArn: Swift.String?

    public init (
        id: Swift.String? = nil,
        thingArn: Swift.String? = nil
    )
    {
        self.id = id
        self.thingArn = thingArn
    }
}

struct AssociateWirelessDeviceWithThingInputBody: Swift.Equatable {
    let thingArn: Swift.String?
}

extension AssociateWirelessDeviceWithThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension AssociateWirelessDeviceWithThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessDeviceWithThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateWirelessDeviceWithThingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessDeviceWithThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateWirelessDeviceWithThingOutputResponse: Swift.Equatable {

    public init () { }
}

extension AssociateWirelessGatewayWithCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotCertificateId = self.iotCertificateId {
            try encodeContainer.encode(iotCertificateId, forKey: .iotCertificateId)
        }
    }
}

extension AssociateWirelessGatewayWithCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
    }
}

public struct AssociateWirelessGatewayWithCertificateInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the certificate to associate with the wireless gateway.
    /// This member is required.
    public var iotCertificateId: Swift.String?

    public init (
        id: Swift.String? = nil,
        iotCertificateId: Swift.String? = nil
    )
    {
        self.id = id
        self.iotCertificateId = iotCertificateId
    }
}

struct AssociateWirelessGatewayWithCertificateInputBody: Swift.Equatable {
    let iotCertificateId: Swift.String?
}

extension AssociateWirelessGatewayWithCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
    }
}

extension AssociateWirelessGatewayWithCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessGatewayWithCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateWirelessGatewayWithCertificateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessGatewayWithCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateWirelessGatewayWithCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.iotCertificateId = output.iotCertificateId
        } else {
            self.iotCertificateId = nil
        }
    }
}

public struct AssociateWirelessGatewayWithCertificateOutputResponse: Swift.Equatable {
    /// The ID of the certificate associated with the wireless gateway.
    public var iotCertificateId: Swift.String?

    public init (
        iotCertificateId: Swift.String? = nil
    )
    {
        self.iotCertificateId = iotCertificateId
    }
}

struct AssociateWirelessGatewayWithCertificateOutputResponseBody: Swift.Equatable {
    let iotCertificateId: Swift.String?
}

extension AssociateWirelessGatewayWithCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
    }
}

extension AssociateWirelessGatewayWithThingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }
}

extension AssociateWirelessGatewayWithThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/thing"
    }
}

public struct AssociateWirelessGatewayWithThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of the thing to associate with the wireless gateway.
    /// This member is required.
    public var thingArn: Swift.String?

    public init (
        id: Swift.String? = nil,
        thingArn: Swift.String? = nil
    )
    {
        self.id = id
        self.thingArn = thingArn
    }
}

struct AssociateWirelessGatewayWithThingInputBody: Swift.Equatable {
    let thingArn: Swift.String?
}

extension AssociateWirelessGatewayWithThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension AssociateWirelessGatewayWithThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessGatewayWithThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateWirelessGatewayWithThingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessGatewayWithThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateWirelessGatewayWithThingOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTWirelessClientTypes {
    /// Sidewalk device battery level.
    public enum BatteryLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case low
        case normal
        case sdkUnknown(Swift.String)

        public static var allCases: [BatteryLevel] {
            return [
                .critical,
                .low,
                .normal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "critical"
            case .low: return "low"
            case .normal: return "normal"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatteryLevel(rawValue: rawValue) ?? BatteryLevel.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.Beaconing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRate = "DataRate"
        case frequencies = "Frequencies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRate = self.dataRate {
            try encodeContainer.encode(dataRate, forKey: .dataRate)
        }
        if let frequencies = frequencies {
            var frequenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .frequencies)
            for beaconingfrequency0 in frequencies {
                try frequenciesContainer.encode(beaconingfrequency0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRate)
        dataRate = dataRateDecoded
        let frequenciesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .frequencies)
        var frequenciesDecoded0:[Swift.Int]? = nil
        if let frequenciesContainer = frequenciesContainer {
            frequenciesDecoded0 = [Swift.Int]()
            for integer0 in frequenciesContainer {
                if let integer0 = integer0 {
                    frequenciesDecoded0?.append(integer0)
                }
            }
        }
        frequencies = frequenciesDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// Beaconing parameters for configuring the wireless gateways.
    public struct Beaconing: Swift.Equatable {
        /// The data rate for gateways that are sending the beacons.
        public var dataRate: Swift.Int?
        /// The frequency list for the gateways to send the beacons.
        public var frequencies: [Swift.Int]?

        public init (
            dataRate: Swift.Int? = nil,
            frequencies: [Swift.Int]? = nil
        )
        {
            self.dataRate = dataRate
            self.frequencies = frequencies
        }
    }

}

extension CancelMulticastGroupSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/session"
    }
}

public struct CancelMulticastGroupSessionInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CancelMulticastGroupSessionInputBody: Swift.Equatable {
}

extension CancelMulticastGroupSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelMulticastGroupSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelMulticastGroupSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelMulticastGroupSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelMulticastGroupSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelMulticastGroupSessionOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTWirelessClientTypes.CdmaLocalId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdmaChannel = "CdmaChannel"
        case pnOffset = "PnOffset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdmaChannel = self.cdmaChannel {
            try encodeContainer.encode(cdmaChannel, forKey: .cdmaChannel)
        }
        if let pnOffset = self.pnOffset {
            try encodeContainer.encode(pnOffset, forKey: .pnOffset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pnOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pnOffset)
        pnOffset = pnOffsetDecoded
        let cdmaChannelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cdmaChannel)
        cdmaChannel = cdmaChannelDecoded
    }
}

extension IoTWirelessClientTypes {
    /// CDMA local ID information, which corresponds to the local identification parameters of a CDMA cell.
    public struct CdmaLocalId: Swift.Equatable {
        /// CDMA channel information.
        /// This member is required.
        public var cdmaChannel: Swift.Int?
        /// Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.
        /// This member is required.
        public var pnOffset: Swift.Int?

        public init (
            cdmaChannel: Swift.Int? = nil,
            pnOffset: Swift.Int? = nil
        )
        {
            self.cdmaChannel = cdmaChannel
            self.pnOffset = pnOffset
        }
    }

}

extension IoTWirelessClientTypes.CdmaNmrObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseStationId = "BaseStationId"
        case cdmaChannel = "CdmaChannel"
        case pilotPower = "PilotPower"
        case pnOffset = "PnOffset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseStationId = self.baseStationId {
            try encodeContainer.encode(baseStationId, forKey: .baseStationId)
        }
        if let cdmaChannel = self.cdmaChannel {
            try encodeContainer.encode(cdmaChannel, forKey: .cdmaChannel)
        }
        if let pilotPower = self.pilotPower {
            try encodeContainer.encode(pilotPower, forKey: .pilotPower)
        }
        if let pnOffset = self.pnOffset {
            try encodeContainer.encode(pnOffset, forKey: .pnOffset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pnOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pnOffset)
        pnOffset = pnOffsetDecoded
        let cdmaChannelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cdmaChannel)
        cdmaChannel = cdmaChannelDecoded
        let pilotPowerDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pilotPower)
        pilotPower = pilotPowerDecoded
        let baseStationIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseStationId)
        baseStationId = baseStationIdDecoded
    }
}

extension IoTWirelessClientTypes {
    /// CDMA object for network measurement reports.
    public struct CdmaNmrObj: Swift.Equatable {
        /// CDMA base station ID (BSID).
        public var baseStationId: Swift.Int?
        /// CDMA channel information.
        /// This member is required.
        public var cdmaChannel: Swift.Int?
        /// Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).
        public var pilotPower: Swift.Int?
        /// Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.
        /// This member is required.
        public var pnOffset: Swift.Int?

        public init (
            baseStationId: Swift.Int? = nil,
            cdmaChannel: Swift.Int? = nil,
            pilotPower: Swift.Int? = nil,
            pnOffset: Swift.Int? = nil
        )
        {
            self.baseStationId = baseStationId
            self.cdmaChannel = cdmaChannel
            self.pilotPower = pilotPower
            self.pnOffset = pnOffset
        }
    }

}

extension IoTWirelessClientTypes.CdmaObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseLat = "BaseLat"
        case baseLng = "BaseLng"
        case baseStationId = "BaseStationId"
        case cdmaLocalId = "CdmaLocalId"
        case cdmaNmr = "CdmaNmr"
        case networkId = "NetworkId"
        case pilotPower = "PilotPower"
        case registrationZone = "RegistrationZone"
        case systemId = "SystemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseLat = self.baseLat {
            try encodeContainer.encode(baseLat, forKey: .baseLat)
        }
        if let baseLng = self.baseLng {
            try encodeContainer.encode(baseLng, forKey: .baseLng)
        }
        if let baseStationId = self.baseStationId {
            try encodeContainer.encode(baseStationId, forKey: .baseStationId)
        }
        if let cdmaLocalId = self.cdmaLocalId {
            try encodeContainer.encode(cdmaLocalId, forKey: .cdmaLocalId)
        }
        if let cdmaNmr = cdmaNmr {
            var cdmaNmrContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cdmaNmr)
            for cdmanmrobj0 in cdmaNmr {
                try cdmaNmrContainer.encode(cdmanmrobj0)
            }
        }
        if let networkId = self.networkId {
            try encodeContainer.encode(networkId, forKey: .networkId)
        }
        if let pilotPower = self.pilotPower {
            try encodeContainer.encode(pilotPower, forKey: .pilotPower)
        }
        if let registrationZone = self.registrationZone {
            try encodeContainer.encode(registrationZone, forKey: .registrationZone)
        }
        if let systemId = self.systemId {
            try encodeContainer.encode(systemId, forKey: .systemId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let systemIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .systemId)
        systemId = systemIdDecoded
        let networkIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .networkId)
        networkId = networkIdDecoded
        let baseStationIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseStationId)
        baseStationId = baseStationIdDecoded
        let registrationZoneDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .registrationZone)
        registrationZone = registrationZoneDecoded
        let cdmaLocalIdDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.CdmaLocalId.self, forKey: .cdmaLocalId)
        cdmaLocalId = cdmaLocalIdDecoded
        let pilotPowerDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pilotPower)
        pilotPower = pilotPowerDecoded
        let baseLatDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .baseLat)
        baseLat = baseLatDecoded
        let baseLngDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .baseLng)
        baseLng = baseLngDecoded
        let cdmaNmrContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.CdmaNmrObj?].self, forKey: .cdmaNmr)
        var cdmaNmrDecoded0:[IoTWirelessClientTypes.CdmaNmrObj]? = nil
        if let cdmaNmrContainer = cdmaNmrContainer {
            cdmaNmrDecoded0 = [IoTWirelessClientTypes.CdmaNmrObj]()
            for structure0 in cdmaNmrContainer {
                if let structure0 = structure0 {
                    cdmaNmrDecoded0?.append(structure0)
                }
            }
        }
        cdmaNmr = cdmaNmrDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// CDMA (Code-division multiple access) object.
    public struct CdmaObj: Swift.Equatable {
        /// CDMA base station latitude in degrees.
        public var baseLat: Swift.Float?
        /// CDMA base station longtitude in degrees.
        public var baseLng: Swift.Float?
        /// CDMA base station ID (BSID).
        /// This member is required.
        public var baseStationId: Swift.Int?
        /// CDMA local identification (local ID) parameters.
        public var cdmaLocalId: IoTWirelessClientTypes.CdmaLocalId?
        /// CDMA network measurement reports.
        public var cdmaNmr: [IoTWirelessClientTypes.CdmaNmrObj]?
        /// CDMA network ID (NID).
        /// This member is required.
        public var networkId: Swift.Int?
        /// Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).
        public var pilotPower: Swift.Int?
        /// CDMA registration zone (RZ).
        public var registrationZone: Swift.Int?
        /// CDMA system ID (SID).
        /// This member is required.
        public var systemId: Swift.Int?

        public init (
            baseLat: Swift.Float? = nil,
            baseLng: Swift.Float? = nil,
            baseStationId: Swift.Int? = nil,
            cdmaLocalId: IoTWirelessClientTypes.CdmaLocalId? = nil,
            cdmaNmr: [IoTWirelessClientTypes.CdmaNmrObj]? = nil,
            networkId: Swift.Int? = nil,
            pilotPower: Swift.Int? = nil,
            registrationZone: Swift.Int? = nil,
            systemId: Swift.Int? = nil
        )
        {
            self.baseLat = baseLat
            self.baseLng = baseLng
            self.baseStationId = baseStationId
            self.cdmaLocalId = cdmaLocalId
            self.cdmaNmr = cdmaNmr
            self.networkId = networkId
            self.pilotPower = pilotPower
            self.registrationZone = registrationZone
            self.systemId = systemId
        }
    }

}

extension IoTWirelessClientTypes.CellTowers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdma = "Cdma"
        case gsm = "Gsm"
        case lte = "Lte"
        case tdscdma = "Tdscdma"
        case wcdma = "Wcdma"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdma = cdma {
            var cdmaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cdma)
            for cdmaobj0 in cdma {
                try cdmaContainer.encode(cdmaobj0)
            }
        }
        if let gsm = gsm {
            var gsmContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gsm)
            for gsmobj0 in gsm {
                try gsmContainer.encode(gsmobj0)
            }
        }
        if let lte = lte {
            var lteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lte)
            for lteobj0 in lte {
                try lteContainer.encode(lteobj0)
            }
        }
        if let tdscdma = tdscdma {
            var tdscdmaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tdscdma)
            for tdscdmaobj0 in tdscdma {
                try tdscdmaContainer.encode(tdscdmaobj0)
            }
        }
        if let wcdma = wcdma {
            var wcdmaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wcdma)
            for wcdmaobj0 in wcdma {
                try wcdmaContainer.encode(wcdmaobj0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gsmContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.GsmObj?].self, forKey: .gsm)
        var gsmDecoded0:[IoTWirelessClientTypes.GsmObj]? = nil
        if let gsmContainer = gsmContainer {
            gsmDecoded0 = [IoTWirelessClientTypes.GsmObj]()
            for structure0 in gsmContainer {
                if let structure0 = structure0 {
                    gsmDecoded0?.append(structure0)
                }
            }
        }
        gsm = gsmDecoded0
        let wcdmaContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WcdmaObj?].self, forKey: .wcdma)
        var wcdmaDecoded0:[IoTWirelessClientTypes.WcdmaObj]? = nil
        if let wcdmaContainer = wcdmaContainer {
            wcdmaDecoded0 = [IoTWirelessClientTypes.WcdmaObj]()
            for structure0 in wcdmaContainer {
                if let structure0 = structure0 {
                    wcdmaDecoded0?.append(structure0)
                }
            }
        }
        wcdma = wcdmaDecoded0
        let tdscdmaContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.TdscdmaObj?].self, forKey: .tdscdma)
        var tdscdmaDecoded0:[IoTWirelessClientTypes.TdscdmaObj]? = nil
        if let tdscdmaContainer = tdscdmaContainer {
            tdscdmaDecoded0 = [IoTWirelessClientTypes.TdscdmaObj]()
            for structure0 in tdscdmaContainer {
                if let structure0 = structure0 {
                    tdscdmaDecoded0?.append(structure0)
                }
            }
        }
        tdscdma = tdscdmaDecoded0
        let lteContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.LteObj?].self, forKey: .lte)
        var lteDecoded0:[IoTWirelessClientTypes.LteObj]? = nil
        if let lteContainer = lteContainer {
            lteDecoded0 = [IoTWirelessClientTypes.LteObj]()
            for structure0 in lteContainer {
                if let structure0 = structure0 {
                    lteDecoded0?.append(structure0)
                }
            }
        }
        lte = lteDecoded0
        let cdmaContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.CdmaObj?].self, forKey: .cdma)
        var cdmaDecoded0:[IoTWirelessClientTypes.CdmaObj]? = nil
        if let cdmaContainer = cdmaContainer {
            cdmaDecoded0 = [IoTWirelessClientTypes.CdmaObj]()
            for structure0 in cdmaContainer {
                if let structure0 = structure0 {
                    cdmaDecoded0?.append(structure0)
                }
            }
        }
        cdma = cdmaDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// The cell towers that were used to perform the measurements.
    public struct CellTowers: Swift.Equatable {
        /// CDMA object information.
        public var cdma: [IoTWirelessClientTypes.CdmaObj]?
        /// GSM object information.
        public var gsm: [IoTWirelessClientTypes.GsmObj]?
        /// LTE object information.
        public var lte: [IoTWirelessClientTypes.LteObj]?
        /// TD-SCDMA object information.
        public var tdscdma: [IoTWirelessClientTypes.TdscdmaObj]?
        /// WCDMA object information.
        public var wcdma: [IoTWirelessClientTypes.WcdmaObj]?

        public init (
            cdma: [IoTWirelessClientTypes.CdmaObj]? = nil,
            gsm: [IoTWirelessClientTypes.GsmObj]? = nil,
            lte: [IoTWirelessClientTypes.LteObj]? = nil,
            tdscdma: [IoTWirelessClientTypes.TdscdmaObj]? = nil,
            wcdma: [IoTWirelessClientTypes.WcdmaObj]? = nil
        )
        {
            self.cdma = cdma
            self.gsm = gsm
            self.lte = lte
            self.tdscdma = tdscdma
            self.wcdma = wcdma
        }
    }

}

extension IoTWirelessClientTypes.CertificateList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingAlg = "SigningAlg"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingAlg = self.signingAlg {
            try encodeContainer.encode(signingAlg.rawValue, forKey: .signingAlg)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingAlgDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SigningAlg.self, forKey: .signingAlg)
        signingAlg = signingAlgDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTWirelessClientTypes {
    /// List of sidewalk certificates.
    public struct CertificateList: Swift.Equatable {
        /// The certificate chain algorithm provided by sidewalk.
        /// This member is required.
        public var signingAlg: IoTWirelessClientTypes.SigningAlg?
        /// The value of the chosen sidewalk certificate.
        /// This member is required.
        public var value: Swift.String?

        public init (
            signingAlg: IoTWirelessClientTypes.SigningAlg? = nil,
            value: Swift.String? = nil
        )
        {
            self.signingAlg = signingAlg
            self.value = value
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Adding, updating, or deleting the resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Id of the resource in the conflicting operation.
    public var resourceId: Swift.String?
    /// Type of the resource in the conflicting operation.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension IoTWirelessClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .connected,
                .disconnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "Connected"
            case .disconnected: return "Disconnected"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.ConnectionStatusEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
        case wirelessGatewayIdEventTopic = "WirelessGatewayIdEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let wirelessGatewayIdEventTopic = self.wirelessGatewayIdEventTopic {
            try encodeContainer.encode(wirelessGatewayIdEventTopic.rawValue, forKey: .wirelessGatewayIdEventTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let wirelessGatewayIdEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessGatewayIdEventTopic)
        wirelessGatewayIdEventTopic = wirelessGatewayIdEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Connection status event configuration object for enabling or disabling topic.
    public struct ConnectionStatusEventConfiguration: Swift.Equatable {
        /// Connection status event configuration object for enabling or disabling LoRaWAN related event topics.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations?
        /// Denotes whether the wireless gateway ID connection status event topic is enabled or disabled.
        public var wirelessGatewayIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init (
            loRaWAN: IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations? = nil,
            wirelessGatewayIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.wirelessGatewayIdEventTopic = wirelessGatewayIdEventTopic
        }
    }

}

extension IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Connection status resource type event configuration object for enabling or disabling topic.
    public struct ConnectionStatusResourceTypeEventConfiguration: Swift.Equatable {
        /// Connection status resource type event configuration object for enabling or disabling LoRaWAN related event topics.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration?

        public init (
            loRaWAN: IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration? = nil
        )
        {
            self.loRaWAN = loRaWAN
        }
    }

}

extension CreateDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = self.expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/destinations"
    }
}

public struct CreateDestinationInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The rule name or topic rule to send messages to.
    /// This member is required.
    public var expression: Swift.String?
    /// The type of value in Expression.
    /// This member is required.
    public var expressionType: IoTWirelessClientTypes.ExpressionType?
    /// The name of the new resource.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags to attach to the new destination. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IoTWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateDestinationInputBody: Swift.Equatable {
    let name: Swift.String?
    let expressionType: IoTWirelessClientTypes.ExpressionType?
    let expression: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateDestinationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The name of the new resource.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateDestinationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
}

extension CreateDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateDeviceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDeviceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/device-profiles"
    }
}

public struct CreateDeviceProfileInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The device profile information to use to create the device profile.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new device profile. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateDeviceProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile?
    let tags: [IoTWirelessClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateDeviceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANDeviceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateDeviceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeviceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDeviceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeviceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDeviceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateDeviceProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new device profile.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateDeviceProfileOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateDeviceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let firmwareUpdateImage = self.firmwareUpdateImage {
            try encodeContainer.encode(firmwareUpdateImage, forKey: .firmwareUpdateImage)
        }
        if let firmwareUpdateRole = self.firmwareUpdateRole {
            try encodeContainer.encode(firmwareUpdateRole, forKey: .firmwareUpdateRole)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/fuota-tasks"
    }
}

public struct CreateFuotaTaskInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The S3 URI points to a firmware update image that is to be used with a FUOTA task.
    /// This member is required.
    public var firmwareUpdateImage: Swift.String?
    /// The firmware update role that is to be used with a FUOTA task.
    /// This member is required.
    public var firmwareUpdateRole: Swift.String?
    /// The LoRaWAN information used with a FUOTA task.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask?
    /// The name of a FUOTA task.
    public var name: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        firmwareUpdateImage: Swift.String? = nil,
        firmwareUpdateRole: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.firmwareUpdateImage = firmwareUpdateImage
        self.firmwareUpdateRole = firmwareUpdateRole
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateFuotaTaskInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask?
    let firmwareUpdateImage: Swift.String?
    let firmwareUpdateRole: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension CreateFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANFuotaTask.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let firmwareUpdateImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateImage)
        firmwareUpdateImage = firmwareUpdateImageDecoded
        let firmwareUpdateRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateRole)
        firmwareUpdateRole = firmwareUpdateRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFuotaTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateFuotaTaskOutputResponse: Swift.Equatable {
    /// The arn of a FUOTA task.
    public var arn: Swift.String?
    /// The ID of a FUOTA task.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateFuotaTaskOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateFuotaTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/multicast-groups"
    }
}

public struct CreateMulticastGroupInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the multicast group.
    public var description: Swift.String?
    /// The LoRaWAN information that is to be used with the multicast group.
    /// This member is required.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast?
    /// The name of the multicast group.
    public var name: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateMulticastGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast?
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension CreateMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANMulticast.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateMulticastGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateMulticastGroupOutputResponse: Swift.Equatable {
    /// The arn of the multicast group.
    public var arn: Swift.String?
    /// The ID of the multicast group.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateMulticastGroupOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateMulticastGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateNetworkAnalyzerConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case traceContent = "TraceContent"
        case wirelessDevices = "WirelessDevices"
        case wirelessGateways = "WirelessGateways"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let traceContent = self.traceContent {
            try encodeContainer.encode(traceContent, forKey: .traceContent)
        }
        if let wirelessDevices = wirelessDevices {
            var wirelessDevicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessDevices)
            for wirelessdeviceid0 in wirelessDevices {
                try wirelessDevicesContainer.encode(wirelessdeviceid0)
            }
        }
        if let wirelessGateways = wirelessGateways {
            var wirelessGatewaysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessGateways)
            for wirelessgatewayid0 in wirelessGateways {
                try wirelessGatewaysContainer.encode(wirelessgatewayid0)
            }
        }
    }
}

extension CreateNetworkAnalyzerConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/network-analyzer-configurations"
    }
}

public struct CreateNetworkAnalyzerConfigurationInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// Name of the network analyzer configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?
    /// Trace content for your wireless gateway and wireless device resources.
    public var traceContent: IoTWirelessClientTypes.TraceContent?
    /// Wireless device resources to add to the network analyzer configuration. Provide the WirelessDeviceId of the resource to add in the input array.
    public var wirelessDevices: [Swift.String]?
    /// Wireless gateway resources to add to the network analyzer configuration. Provide the WirelessGatewayId of the resource to add in the input array.
    public var wirelessGateways: [Swift.String]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil,
        traceContent: IoTWirelessClientTypes.TraceContent? = nil,
        wirelessDevices: [Swift.String]? = nil,
        wirelessGateways: [Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.name = name
        self.tags = tags
        self.traceContent = traceContent
        self.wirelessDevices = wirelessDevices
        self.wirelessGateways = wirelessGateways
    }
}

struct CreateNetworkAnalyzerConfigurationInputBody: Swift.Equatable {
    let name: Swift.String?
    let traceContent: IoTWirelessClientTypes.TraceContent?
    let wirelessDevices: [Swift.String]?
    let wirelessGateways: [Swift.String]?
    let description: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateNetworkAnalyzerConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case traceContent = "TraceContent"
        case wirelessDevices = "WirelessDevices"
        case wirelessGateways = "WirelessGateways"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let traceContentDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.TraceContent.self, forKey: .traceContent)
        traceContent = traceContentDecoded
        let wirelessDevicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessDevices)
        var wirelessDevicesDecoded0:[Swift.String]? = nil
        if let wirelessDevicesContainer = wirelessDevicesContainer {
            wirelessDevicesDecoded0 = [Swift.String]()
            for string0 in wirelessDevicesContainer {
                if let string0 = string0 {
                    wirelessDevicesDecoded0?.append(string0)
                }
            }
        }
        wirelessDevices = wirelessDevicesDecoded0
        let wirelessGatewaysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessGateways)
        var wirelessGatewaysDecoded0:[Swift.String]? = nil
        if let wirelessGatewaysContainer = wirelessGatewaysContainer {
            wirelessGatewaysDecoded0 = [Swift.String]()
            for string0 in wirelessGatewaysContainer {
                if let string0 = string0 {
                    wirelessGatewaysDecoded0?.append(string0)
                }
            }
        }
        wirelessGateways = wirelessGatewaysDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateNetworkAnalyzerConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNetworkAnalyzerConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateNetworkAnalyzerConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNetworkAnalyzerConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateNetworkAnalyzerConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateNetworkAnalyzerConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// Name of the network analyzer configuration.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateNetworkAnalyzerConfigurationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
}

extension CreateNetworkAnalyzerConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateServiceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateServiceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/service-profiles"
    }
}

public struct CreateServiceProfileInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The service profile information to use to create the service profile.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANServiceProfile?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new service profile. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANServiceProfile? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateServiceProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANServiceProfile?
    let tags: [IoTWirelessClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateServiceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANServiceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateServiceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateServiceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateServiceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateServiceProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new service profile.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateServiceProfileOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateServiceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateWirelessDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case positioning = "Positioning"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let positioning = self.positioning {
            try encodeContainer.encode(positioning.rawValue, forKey: .positioning)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-devices"
    }
}

public struct CreateWirelessDeviceInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The name of the destination to assign to the new wireless device.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The device configuration information to use to create the wireless device.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDevice?
    /// The name of the new resource.
    public var name: Swift.String?
    /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
    public var positioning: IoTWirelessClientTypes.PositioningConfigStatus?
    /// The tags to attach to the new wireless device. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?
    /// The wireless device type.
    /// This member is required.
    public var type: IoTWirelessClientTypes.WirelessDeviceType?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDevice? = nil,
        name: Swift.String? = nil,
        positioning: IoTWirelessClientTypes.PositioningConfigStatus? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil,
        type: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.destinationName = destinationName
        self.loRaWAN = loRaWAN
        self.name = name
        self.positioning = positioning
        self.tags = tags
        self.type = type
    }
}

struct CreateWirelessDeviceInputBody: Swift.Equatable {
    let type: IoTWirelessClientTypes.WirelessDeviceType?
    let name: Swift.String?
    let description: Swift.String?
    let destinationName: Swift.String?
    let clientRequestToken: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANDevice?
    let tags: [IoTWirelessClientTypes.Tag]?
    let positioning: IoTWirelessClientTypes.PositioningConfigStatus?
}

extension CreateWirelessDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case positioning = "Positioning"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let positioningDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositioningConfigStatus.self, forKey: .positioning)
        positioning = positioningDecoded
    }
}

extension CreateWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessDeviceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new wireless device.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessDeviceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateWirelessDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateWirelessGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateWirelessGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-gateways"
    }
}

public struct CreateWirelessGatewayInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The gateway configuration information to use to create the wireless gateway.
    /// This member is required.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANGateway?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new wireless gateway. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANGateway? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateWirelessGatewayInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANGateway?
    let tags: [IoTWirelessClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateWirelessGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateWirelessGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWirelessGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWirelessGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new wireless gateway.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessGatewayOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateWirelessGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateWirelessGatewayTaskDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoCreateTasks = "AutoCreateTasks"
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case tags = "Tags"
        case update = "Update"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoCreateTasks != false {
            try encodeContainer.encode(autoCreateTasks, forKey: .autoCreateTasks)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let update = self.update {
            try encodeContainer.encode(update, forKey: .update)
        }
    }
}

extension CreateWirelessGatewayTaskDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-gateway-task-definitions"
    }
}

public struct CreateWirelessGatewayTaskDefinitionInput: Swift.Equatable {
    /// Whether to automatically create tasks using this task definition for all gateways with the specified current version. If false, the task must me created by calling CreateWirelessGatewayTask.
    /// This member is required.
    public var autoCreateTasks: Swift.Bool
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?
    /// Information about the gateways to update.
    public var update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate?

    public init (
        autoCreateTasks: Swift.Bool = false,
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil,
        update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate? = nil
    )
    {
        self.autoCreateTasks = autoCreateTasks
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.tags = tags
        self.update = update
    }
}

struct CreateWirelessGatewayTaskDefinitionInputBody: Swift.Equatable {
    let autoCreateTasks: Swift.Bool
    let name: Swift.String?
    let update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate?
    let clientRequestToken: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension CreateWirelessGatewayTaskDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoCreateTasks = "AutoCreateTasks"
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case tags = "Tags"
        case update = "Update"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoCreateTasksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoCreateTasks) ?? false
        autoCreateTasks = autoCreateTasksDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate.self, forKey: .update)
        update = updateDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWirelessGatewayTaskDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessGatewayTaskDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWirelessGatewayTaskDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessGatewayTaskDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWirelessGatewayTaskDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessGatewayTaskDefinitionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the new wireless gateway task definition.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessGatewayTaskDefinitionOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension CreateWirelessGatewayTaskDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreateWirelessGatewayTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessGatewayTaskDefinitionId = self.wirelessGatewayTaskDefinitionId {
            try encodeContainer.encode(wirelessGatewayTaskDefinitionId, forKey: .wirelessGatewayTaskDefinitionId)
        }
    }
}

extension CreateWirelessGatewayTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
    }
}

public struct CreateWirelessGatewayTaskInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the WirelessGatewayTaskDefinition.
    /// This member is required.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init (
        id: Swift.String? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct CreateWirelessGatewayTaskInputBody: Swift.Equatable {
    let wirelessGatewayTaskDefinitionId: Swift.String?
}

extension CreateWirelessGatewayTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
    }
}

extension CreateWirelessGatewayTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessGatewayTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWirelessGatewayTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessGatewayTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWirelessGatewayTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.wirelessGatewayTaskDefinitionId = output.wirelessGatewayTaskDefinitionId
        } else {
            self.status = nil
            self.wirelessGatewayTaskDefinitionId = nil
        }
    }
}

public struct CreateWirelessGatewayTaskOutputResponse: Swift.Equatable {
    /// The status of the request.
    public var status: IoTWirelessClientTypes.WirelessGatewayTaskStatus?
    /// The ID of the WirelessGatewayTaskDefinition.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init (
        status: IoTWirelessClientTypes.WirelessGatewayTaskStatus? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.status = status
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct CreateWirelessGatewayTaskOutputResponseBody: Swift.Equatable {
    let wirelessGatewayTaskDefinitionId: Swift.String?
    let status: IoTWirelessClientTypes.WirelessGatewayTaskStatus?
}

extension CreateWirelessGatewayTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessGatewayTaskStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

public struct DeleteDestinationInput: Swift.Equatable {
    /// The name of the resource to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDestinationInputBody: Swift.Equatable {
}

extension DeleteDestinationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDestinationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteDeviceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/device-profiles/\(id.urlPercentEncoding())"
    }
}

public struct DeleteDeviceProfileInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteDeviceProfileInputBody: Swift.Equatable {
}

extension DeleteDeviceProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeviceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDeviceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeviceProfileOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

public struct DeleteFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteFuotaTaskInputBody: Swift.Equatable {
}

extension DeleteFuotaTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFuotaTaskOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())"
    }
}

public struct DeleteMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteMulticastGroupInputBody: Swift.Equatable {
}

extension DeleteMulticastGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMulticastGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteNetworkAnalyzerConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationName = configurationName else {
            return nil
        }
        return "/network-analyzer-configurations/\(configurationName.urlPercentEncoding())"
    }
}

public struct DeleteNetworkAnalyzerConfigurationInput: Swift.Equatable {
    /// Name of the network analyzer configuration.
    /// This member is required.
    public var configurationName: Swift.String?

    public init (
        configurationName: Swift.String? = nil
    )
    {
        self.configurationName = configurationName
    }
}

struct DeleteNetworkAnalyzerConfigurationInputBody: Swift.Equatable {
}

extension DeleteNetworkAnalyzerConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNetworkAnalyzerConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNetworkAnalyzerConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteNetworkAnalyzerConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNetworkAnalyzerConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNetworkAnalyzerConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteQueuedMessagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let wirelessDeviceType = wirelessDeviceType {
                let wirelessDeviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "WirelessDeviceType".urlPercentEncoding(), value: Swift.String(wirelessDeviceType.rawValue).urlPercentEncoding())
                items.append(wirelessDeviceTypeQueryItem)
            }
            guard let messageId = messageId else {
                let message = "Creating a URL Query Item failed. messageId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let messageIdQueryItem = ClientRuntime.URLQueryItem(name: "messageId".urlPercentEncoding(), value: Swift.String(messageId).urlPercentEncoding())
            items.append(messageIdQueryItem)
            return items
        }
    }
}

extension DeleteQueuedMessagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/data"
    }
}

public struct DeleteQueuedMessagesInput: Swift.Equatable {
    /// The ID of a given wireless device for which downlink messages will be deleted.
    /// This member is required.
    public var id: Swift.String?
    /// If message ID is "*", it cleares the entire downlink queue for a given device, specified by the wireless device ID. Otherwise, the downlink message with the specified message ID will be deleted.
    /// This member is required.
    public var messageId: Swift.String?
    /// The wireless device type, which can be either Sidewalk or LoRaWAN.
    public var wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType?

    public init (
        id: Swift.String? = nil,
        messageId: Swift.String? = nil,
        wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.id = id
        self.messageId = messageId
        self.wirelessDeviceType = wirelessDeviceType
    }
}

struct DeleteQueuedMessagesInputBody: Swift.Equatable {
}

extension DeleteQueuedMessagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteQueuedMessagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteQueuedMessagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteQueuedMessagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteQueuedMessagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteQueuedMessagesOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteServiceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/service-profiles/\(id.urlPercentEncoding())"
    }
}

public struct DeleteServiceProfileInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteServiceProfileInputBody: Swift.Equatable {
}

extension DeleteServiceProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteServiceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceProfileOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWirelessDeviceInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessDeviceInputBody: Swift.Equatable {
}

extension DeleteWirelessDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessDeviceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWirelessGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWirelessGatewayInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayInputBody: Swift.Equatable {
}

extension DeleteWirelessGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWirelessGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessGatewayOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWirelessGatewayTaskDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateway-task-definitions/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWirelessGatewayTaskDefinitionInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayTaskDefinitionInputBody: Swift.Equatable {
}

extension DeleteWirelessGatewayTaskDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayTaskDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessGatewayTaskDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWirelessGatewayTaskDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessGatewayTaskDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessGatewayTaskDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWirelessGatewayTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
    }
}

public struct DeleteWirelessGatewayTaskInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayTaskInputBody: Swift.Equatable {
}

extension DeleteWirelessGatewayTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessGatewayTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWirelessGatewayTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessGatewayTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessGatewayTaskOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTWirelessClientTypes.Destinations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = self.expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Describes a destination.
    public struct Destinations: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The description of the resource.
        public var description: Swift.String?
        /// The rule name or topic rule to send messages to.
        public var expression: Swift.String?
        /// The type of value in Expression.
        public var expressionType: IoTWirelessClientTypes.ExpressionType?
        /// The name of the resource.
        public var name: Swift.String?
        /// The ARN of the IAM Role that authorizes the destination.
        public var roleArn: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            expression: Swift.String? = nil,
            expressionType: IoTWirelessClientTypes.ExpressionType? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.expression = expression
            self.expressionType = expressionType
            self.name = name
            self.roleArn = roleArn
        }
    }

}

extension IoTWirelessClientTypes.DeviceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Describes a device profile.
    public struct DeviceProfile: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the device profile.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
        case wirelessDeviceIdEventTopic = "WirelessDeviceIdEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let wirelessDeviceIdEventTopic = self.wirelessDeviceIdEventTopic {
            try encodeContainer.encode(wirelessDeviceIdEventTopic.rawValue, forKey: .wirelessDeviceIdEventTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkEventNotificationConfigurations.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let wirelessDeviceIdEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessDeviceIdEventTopic)
        wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Device registration state event configuration object for enabling and disabling relevant topics.
    public struct DeviceRegistrationStateEventConfiguration: Swift.Equatable {
        /// Device registration state event configuration object for enabling or disabling Sidewalk related event topics.
        public var sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations?
        /// Denotes whether the wireless device ID device registration state event topic is enabled or disabled.
        public var wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init (
            sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations? = nil,
            wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.sidewalk = sidewalk
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }
    }

}

extension IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Device registration state resource type event configuration object for enabling or disabling topic.
    public struct DeviceRegistrationStateResourceTypeEventConfiguration: Swift.Equatable {
        /// Device registration resource type state event configuration object for enabling or disabling Sidewalk related event topics.
        public var sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration?

        public init (
            sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration? = nil
        )
        {
            self.sidewalk = sidewalk
        }
    }

}

extension IoTWirelessClientTypes {
    /// Device state defines the device status of sidewalk device.
    public enum DeviceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case provisioned
        case registerednotseen
        case registeredreachable
        case registeredunreachable
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceState] {
            return [
                .provisioned,
                .registerednotseen,
                .registeredreachable,
                .registeredunreachable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .provisioned: return "Provisioned"
            case .registerednotseen: return "RegisteredNotSeen"
            case .registeredreachable: return "RegisteredReachable"
            case .registeredunreachable: return "RegisteredUnreachable"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceState(rawValue: rawValue) ?? DeviceState.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateAwsAccountFromPartnerAccountInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let partnerType = partnerType else {
                let message = "Creating a URL Query Item failed. partnerType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            items.append(partnerTypeQueryItem)
            return items
        }
    }
}

extension DisassociateAwsAccountFromPartnerAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let partnerAccountId = partnerAccountId else {
            return nil
        }
        return "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
    }
}

public struct DisassociateAwsAccountFromPartnerAccountInput: Swift.Equatable {
    /// The partner account ID to disassociate from the AWS account.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IoTWirelessClientTypes.PartnerType?

    public init (
        partnerAccountId: Swift.String? = nil,
        partnerType: IoTWirelessClientTypes.PartnerType? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
    }
}

struct DisassociateAwsAccountFromPartnerAccountInputBody: Swift.Equatable {
}

extension DisassociateAwsAccountFromPartnerAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateAwsAccountFromPartnerAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAwsAccountFromPartnerAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateAwsAccountFromPartnerAccountOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAwsAccountFromPartnerAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateAwsAccountFromPartnerAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateMulticastGroupFromFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        guard let multicastGroupId = multicastGroupId else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/multicast-groups/\(multicastGroupId.urlPercentEncoding())"
    }
}

public struct DisassociateMulticastGroupFromFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the multicast group.
    /// This member is required.
    public var multicastGroupId: Swift.String?

    public init (
        id: Swift.String? = nil,
        multicastGroupId: Swift.String? = nil
    )
    {
        self.id = id
        self.multicastGroupId = multicastGroupId
    }
}

struct DisassociateMulticastGroupFromFuotaTaskInputBody: Swift.Equatable {
}

extension DisassociateMulticastGroupFromFuotaTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateMulticastGroupFromFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMulticastGroupFromFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateMulticastGroupFromFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMulticastGroupFromFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateMulticastGroupFromFuotaTaskOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateWirelessDeviceFromFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        guard let wirelessDeviceId = wirelessDeviceId else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/wireless-devices/\(wirelessDeviceId.urlPercentEncoding())"
    }
}

public struct DisassociateWirelessDeviceFromFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init (
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct DisassociateWirelessDeviceFromFuotaTaskInputBody: Swift.Equatable {
}

extension DisassociateWirelessDeviceFromFuotaTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessDeviceFromFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessDeviceFromFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateWirelessDeviceFromFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessDeviceFromFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessDeviceFromFuotaTaskOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateWirelessDeviceFromMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        guard let wirelessDeviceId = wirelessDeviceId else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/wireless-devices/\(wirelessDeviceId.urlPercentEncoding())"
    }
}

public struct DisassociateWirelessDeviceFromMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init (
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct DisassociateWirelessDeviceFromMulticastGroupInputBody: Swift.Equatable {
}

extension DisassociateWirelessDeviceFromMulticastGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessDeviceFromMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessDeviceFromMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateWirelessDeviceFromMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessDeviceFromMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessDeviceFromMulticastGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateWirelessDeviceFromThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/thing"
    }
}

public struct DisassociateWirelessDeviceFromThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessDeviceFromThingInputBody: Swift.Equatable {
}

extension DisassociateWirelessDeviceFromThingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessDeviceFromThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessDeviceFromThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateWirelessDeviceFromThingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessDeviceFromThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessDeviceFromThingOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateWirelessGatewayFromCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
    }
}

public struct DisassociateWirelessGatewayFromCertificateInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessGatewayFromCertificateInputBody: Swift.Equatable {
}

extension DisassociateWirelessGatewayFromCertificateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessGatewayFromCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessGatewayFromCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateWirelessGatewayFromCertificateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessGatewayFromCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessGatewayFromCertificateOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateWirelessGatewayFromThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/thing"
    }
}

public struct DisassociateWirelessGatewayFromThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessGatewayFromThingInputBody: Swift.Equatable {
}

extension DisassociateWirelessGatewayFromThingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessGatewayFromThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessGatewayFromThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateWirelessGatewayFromThingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessGatewayFromThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessGatewayFromThingOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTWirelessClientTypes {
    /// DlClass for LoRaWAM, valid values are ClassB and ClassC.
    public enum DlClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case classb
        case classc
        case sdkUnknown(Swift.String)

        public static var allCases: [DlClass] {
            return [
                .classb,
                .classc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .classb: return "ClassB"
            case .classc: return "ClassC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DlClass(rawValue: rawValue) ?? DlClass.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum DownlinkMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concurrent
        case sequential
        case usingUplinkGateway
        case sdkUnknown(Swift.String)

        public static var allCases: [DownlinkMode] {
            return [
                .concurrent,
                .sequential,
                .usingUplinkGateway,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concurrent: return "CONCURRENT"
            case .sequential: return "SEQUENTIAL"
            case .usingUplinkGateway: return "USING_UPLINK_GATEWAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DownlinkMode(rawValue: rawValue) ?? DownlinkMode.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.DownlinkQueueMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
        case messageId = "MessageId"
        case receivedAt = "ReceivedAt"
        case transmitMode = "TransmitMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let receivedAt = self.receivedAt {
            try encodeContainer.encode(receivedAt, forKey: .receivedAt)
        }
        if let transmitMode = self.transmitMode {
            try encodeContainer.encode(transmitMode, forKey: .transmitMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let transmitModeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .transmitMode)
        transmitMode = transmitModeDecoded
        let receivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .receivedAt)
        receivedAt = receivedAtDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANSendDataToDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The message in the downlink queue.
    public struct DownlinkQueueMessage: Swift.Equatable {
        /// LoRaWAN router info.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANSendDataToDevice?
        /// The message ID assigned by IoT Wireless to each downlink message, which helps identify the message.
        public var messageId: Swift.String?
        /// The time at which Iot Wireless received the downlink message.
        public var receivedAt: Swift.String?
        /// The transmit mode to use for sending data to the wireless device. This can be 0 for UM (unacknowledge mode) or 1 for AM (acknowledge mode).
        public var transmitMode: Swift.Int?

        public init (
            loRaWAN: IoTWirelessClientTypes.LoRaWANSendDataToDevice? = nil,
            messageId: Swift.String? = nil,
            receivedAt: Swift.String? = nil,
            transmitMode: Swift.Int? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.messageId = messageId
            self.receivedAt = receivedAt
            self.transmitMode = transmitMode
        }
    }

}

extension IoTWirelessClientTypes {
    /// Sidewalk device status notification.
    public enum Event: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ack
        case discovered
        case lost
        case nack
        case passthrough
        case sdkUnknown(Swift.String)

        public static var allCases: [Event] {
            return [
                .ack,
                .discovered,
                .lost,
                .nack,
                .passthrough,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ack: return "ack"
            case .discovered: return "discovered"
            case .lost: return "lost"
            case .nack: return "nack"
            case .passthrough: return "passthrough"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Event(rawValue: rawValue) ?? Event.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.EventConfigurationItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case identifier = "Identifier"
        case identifierType = "IdentifierType"
        case partnerType = "PartnerType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = self.events {
            try encodeContainer.encode(events, forKey: .events)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let identifierType = self.identifierType {
            try encodeContainer.encode(identifierType.rawValue, forKey: .identifierType)
        }
        if let partnerType = self.partnerType {
            try encodeContainer.encode(partnerType.rawValue, forKey: .partnerType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let identifierTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.IdentifierType.self, forKey: .identifierType)
        identifierType = identifierTypeDecoded
        let partnerTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationPartnerType.self, forKey: .partnerType)
        partnerType = partnerTypeDecoded
        let eventsDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationItemConfigurations.self, forKey: .events)
        events = eventsDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Event configuration object for a single resource.
    public struct EventConfigurationItem: Swift.Equatable {
        /// Object of all event configurations and the status of the event topics.
        public var events: IoTWirelessClientTypes.EventNotificationItemConfigurations?
        /// Resource identifier opted in for event messaging.
        public var identifier: Swift.String?
        /// Identifier type of the particular resource identifier for event configuration.
        public var identifierType: IoTWirelessClientTypes.IdentifierType?
        /// Partner type of the resource if the identifier type is PartnerAccountId.
        public var partnerType: IoTWirelessClientTypes.EventNotificationPartnerType?

        public init (
            events: IoTWirelessClientTypes.EventNotificationItemConfigurations? = nil,
            identifier: Swift.String? = nil,
            identifierType: IoTWirelessClientTypes.IdentifierType? = nil,
            partnerType: IoTWirelessClientTypes.EventNotificationPartnerType? = nil
        )
        {
            self.events = events
            self.identifier = identifier
            self.identifierType = identifierType
            self.partnerType = partnerType
        }
    }

}

extension IoTWirelessClientTypes.EventNotificationItemConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case deviceRegistrationState = "DeviceRegistrationState"
        case join = "Join"
        case messageDeliveryStatus = "MessageDeliveryStatus"
        case proximity = "Proximity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionStatus = self.connectionStatus {
            try encodeContainer.encode(connectionStatus, forKey: .connectionStatus)
        }
        if let deviceRegistrationState = self.deviceRegistrationState {
            try encodeContainer.encode(deviceRegistrationState, forKey: .deviceRegistrationState)
        }
        if let join = self.join {
            try encodeContainer.encode(join, forKey: .join)
        }
        if let messageDeliveryStatus = self.messageDeliveryStatus {
            try encodeContainer.encode(messageDeliveryStatus, forKey: .messageDeliveryStatus)
        }
        if let proximity = self.proximity {
            try encodeContainer.encode(proximity, forKey: .proximity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceRegistrationStateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration.self, forKey: .deviceRegistrationState)
        deviceRegistrationState = deviceRegistrationStateDecoded
        let proximityDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ProximityEventConfiguration.self, forKey: .proximity)
        proximity = proximityDecoded
        let joinDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.JoinEventConfiguration.self, forKey: .join)
        join = joinDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ConnectionStatusEventConfiguration.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let messageDeliveryStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration.self, forKey: .messageDeliveryStatus)
        messageDeliveryStatus = messageDeliveryStatusDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Object of all event configurations and the status of the event topics.
    public struct EventNotificationItemConfigurations: Swift.Equatable {
        /// Connection status event configuration for an event configuration item.
        public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration?
        /// Device registration state event configuration for an event configuration item.
        public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
        /// Join event configuration for an event configuration item.
        public var join: IoTWirelessClientTypes.JoinEventConfiguration?
        /// Message delivery status event configuration for an event configuration item.
        public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration?
        /// Proximity event configuration for an event configuration item.
        public var proximity: IoTWirelessClientTypes.ProximityEventConfiguration?

        public init (
            connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration? = nil,
            deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration? = nil,
            join: IoTWirelessClientTypes.JoinEventConfiguration? = nil,
            messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration? = nil,
            proximity: IoTWirelessClientTypes.ProximityEventConfiguration? = nil
        )
        {
            self.connectionStatus = connectionStatus
            self.deviceRegistrationState = deviceRegistrationState
            self.join = join
            self.messageDeliveryStatus = messageDeliveryStatus
            self.proximity = proximity
        }
    }

}

extension IoTWirelessClientTypes {
    public enum EventNotificationPartnerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [EventNotificationPartnerType] {
            return [
                .sidewalk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventNotificationPartnerType(rawValue: rawValue) ?? EventNotificationPartnerType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum EventNotificationResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sidewalkaccount
        case wirelessdevice
        case wirelessgateway
        case sdkUnknown(Swift.String)

        public static var allCases: [EventNotificationResourceType] {
            return [
                .sidewalkaccount,
                .wirelessdevice,
                .wirelessgateway,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sidewalkaccount: return "SidewalkAccount"
            case .wirelessdevice: return "WirelessDevice"
            case .wirelessgateway: return "WirelessGateway"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventNotificationResourceType(rawValue: rawValue) ?? EventNotificationResourceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum EventNotificationTopicStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EventNotificationTopicStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventNotificationTopicStatus(rawValue: rawValue) ?? EventNotificationTopicStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum ExpressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mqtttopic
        case rulename
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpressionType] {
            return [
                .mqtttopic,
                .rulename,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mqtttopic: return "MqttTopic"
            case .rulename: return "RuleName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExpressionType(rawValue: rawValue) ?? ExpressionType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.FPorts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case clockSync = "ClockSync"
        case fuota = "Fuota"
        case multicast = "Multicast"
        case positioning = "Positioning"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for applicationconfig0 in applications {
                try applicationsContainer.encode(applicationconfig0)
            }
        }
        if let clockSync = self.clockSync {
            try encodeContainer.encode(clockSync, forKey: .clockSync)
        }
        if let fuota = self.fuota {
            try encodeContainer.encode(fuota, forKey: .fuota)
        }
        if let multicast = self.multicast {
            try encodeContainer.encode(multicast, forKey: .multicast)
        }
        if let positioning = self.positioning {
            try encodeContainer.encode(positioning, forKey: .positioning)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fuotaDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fuota)
        fuota = fuotaDecoded
        let multicastDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .multicast)
        multicast = multicastDecoded
        let clockSyncDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clockSync)
        clockSync = clockSyncDecoded
        let positioningDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.Positioning.self, forKey: .positioning)
        positioning = positioningDecoded
        let applicationsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.ApplicationConfig?].self, forKey: .applications)
        var applicationsDecoded0:[IoTWirelessClientTypes.ApplicationConfig]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [IoTWirelessClientTypes.ApplicationConfig]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// List of FPort assigned for different LoRaWAN application packages to use
    public struct FPorts: Swift.Equatable {
        /// Optional LoRaWAN application information, which can be used for geolocation.
        public var applications: [IoTWirelessClientTypes.ApplicationConfig]?
        /// The Fport value.
        public var clockSync: Swift.Int?
        /// The Fport value.
        public var fuota: Swift.Int?
        /// The Fport value.
        public var multicast: Swift.Int?
        /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
        public var positioning: IoTWirelessClientTypes.Positioning?

        public init (
            applications: [IoTWirelessClientTypes.ApplicationConfig]? = nil,
            clockSync: Swift.Int? = nil,
            fuota: Swift.Int? = nil,
            multicast: Swift.Int? = nil,
            positioning: IoTWirelessClientTypes.Positioning? = nil
        )
        {
            self.applications = applications
            self.clockSync = clockSync
            self.fuota = fuota
            self.multicast = multicast
            self.positioning = positioning
        }
    }

}

extension IoTWirelessClientTypes {
    /// The status of a wireless device in a FUOTA task.
    public enum FuotaDeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fragalgoUnsupported
        case fragindexUnsupported
        case initial
        case micerror
        case memoryerror
        case missingfrag
        case notEnoughMemory
        case packageNotSupported
        case sessioncntReplay
        case successful
        case wrongDescriptor
        case sdkUnknown(Swift.String)

        public static var allCases: [FuotaDeviceStatus] {
            return [
                .fragalgoUnsupported,
                .fragindexUnsupported,
                .initial,
                .micerror,
                .memoryerror,
                .missingfrag,
                .notEnoughMemory,
                .packageNotSupported,
                .sessioncntReplay,
                .successful,
                .wrongDescriptor,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fragalgoUnsupported: return "FragAlgo_unsupported"
            case .fragindexUnsupported: return "FragIndex_unsupported"
            case .initial: return "Initial"
            case .micerror: return "MICError"
            case .memoryerror: return "MemoryError"
            case .missingfrag: return "MissingFrag"
            case .notEnoughMemory: return "Not_enough_memory"
            case .packageNotSupported: return "Package_Not_Supported"
            case .sessioncntReplay: return "SessionCnt_replay"
            case .successful: return "Successful"
            case .wrongDescriptor: return "Wrong_descriptor"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FuotaDeviceStatus(rawValue: rawValue) ?? FuotaDeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.FuotaTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IoTWirelessClientTypes {
    /// A FUOTA task.
    public struct FuotaTask: Swift.Equatable {
        /// The arn of a FUOTA task.
        public var arn: Swift.String?
        /// The ID of a FUOTA task.
        public var id: Swift.String?
        /// The name of a FUOTA task.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension IoTWirelessClientTypes {
    /// The status of a FUOTA task.
    public enum FuotaTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteWaiting
        case fuotadone
        case fuotasessionWaiting
        case inFuotasession
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [FuotaTaskStatus] {
            return [
                .deleteWaiting,
                .fuotadone,
                .fuotasessionWaiting,
                .inFuotasession,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteWaiting: return "Delete_Waiting"
            case .fuotadone: return "FuotaDone"
            case .fuotasessionWaiting: return "FuotaSession_Waiting"
            case .inFuotasession: return "In_FuotaSession"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FuotaTaskStatus(rawValue: rawValue) ?? FuotaTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.GatewayListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downlinkFrequency = "DownlinkFrequency"
        case gatewayId = "GatewayId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downlinkFrequency = self.downlinkFrequency {
            try encodeContainer.encode(downlinkFrequency, forKey: .downlinkFrequency)
        }
        if let gatewayId = self.gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let downlinkFrequencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkFrequency)
        downlinkFrequency = downlinkFrequencyDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Gateway list item object that specifies the frequency and list of gateways for which the downlink message should be sent.
    public struct GatewayListItem: Swift.Equatable {
        /// The frequency to use for the gateways when sending a downlink message to the wireless device.
        /// This member is required.
        public var downlinkFrequency: Swift.Int?
        /// The ID of the wireless gateways that you want to add to the list of gateways when sending downlink messages.
        /// This member is required.
        public var gatewayId: Swift.String?

        public init (
            downlinkFrequency: Swift.Int? = nil,
            gatewayId: Swift.String? = nil
        )
        {
            self.downlinkFrequency = downlinkFrequency
            self.gatewayId = gatewayId
        }
    }

}

extension GetDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

public struct GetDestinationInput: Swift.Equatable {
    /// The name of the resource to get.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetDestinationInputBody: Swift.Equatable {
}

extension GetDestinationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.expression = output.expression
            self.expressionType = output.expressionType
            self.name = output.name
            self.roleArn = output.roleArn
        } else {
            self.arn = nil
            self.description = nil
            self.expression = nil
            self.expressionType = nil
            self.name = nil
            self.roleArn = nil
        }
    }
}

public struct GetDestinationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The rule name or topic rule to send messages to.
    public var expression: Swift.String?
    /// The type of value in Expression.
    public var expressionType: IoTWirelessClientTypes.ExpressionType?
    /// The name of the resource.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    public var roleArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IoTWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
    }
}

struct GetDestinationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let expression: Swift.String?
    let expressionType: IoTWirelessClientTypes.ExpressionType?
    let description: Swift.String?
    let roleArn: Swift.String?
}

extension GetDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension GetDeviceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/device-profiles/\(id.urlPercentEncoding())"
    }
}

public struct GetDeviceProfileInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDeviceProfileInputBody: Swift.Equatable {
}

extension GetDeviceProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeviceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDeviceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDeviceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
        } else {
            self.arn = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
        }
    }
}

public struct GetDeviceProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the device profile.
    public var id: Swift.String?
    /// Information about the device profile.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile?
    /// The name of the resource.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct GetDeviceProfileOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let id: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile?
}

extension GetDeviceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANDeviceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension GetEventConfigurationByResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/event-configurations-resource-types"
    }
}

public struct GetEventConfigurationByResourceTypesInput: Swift.Equatable {

    public init () { }
}

struct GetEventConfigurationByResourceTypesInputBody: Swift.Equatable {
}

extension GetEventConfigurationByResourceTypesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEventConfigurationByResourceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventConfigurationByResourceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetEventConfigurationByResourceTypesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventConfigurationByResourceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetEventConfigurationByResourceTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionStatus = output.connectionStatus
            self.deviceRegistrationState = output.deviceRegistrationState
            self.join = output.join
            self.messageDeliveryStatus = output.messageDeliveryStatus
            self.proximity = output.proximity
        } else {
            self.connectionStatus = nil
            self.deviceRegistrationState = nil
            self.join = nil
            self.messageDeliveryStatus = nil
            self.proximity = nil
        }
    }
}

public struct GetEventConfigurationByResourceTypesOutputResponse: Swift.Equatable {
    /// Resource type event configuration for the connection status event.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration?
    /// Resource type event configuration for the device registration state event.
    public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration?
    /// Resource type event configuration for the join event.
    public var join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration?
    /// Resource type event configuration object for the message delivery status event.
    public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration?
    /// Resource type event configuration for the proximity event.
    public var proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration?

    public init (
        connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration? = nil,
        deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration? = nil,
        join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration? = nil,
        messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration? = nil,
        proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.deviceRegistrationState = deviceRegistrationState
        self.join = join
        self.messageDeliveryStatus = messageDeliveryStatus
        self.proximity = proximity
    }
}

struct GetEventConfigurationByResourceTypesOutputResponseBody: Swift.Equatable {
    let deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration?
    let proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration?
    let join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration?
    let connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration?
    let messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration?
}

extension GetEventConfigurationByResourceTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case deviceRegistrationState = "DeviceRegistrationState"
        case join = "Join"
        case messageDeliveryStatus = "MessageDeliveryStatus"
        case proximity = "Proximity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceRegistrationStateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration.self, forKey: .deviceRegistrationState)
        deviceRegistrationState = deviceRegistrationStateDecoded
        let proximityDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration.self, forKey: .proximity)
        proximity = proximityDecoded
        let joinDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.JoinResourceTypeEventConfiguration.self, forKey: .join)
        join = joinDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let messageDeliveryStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration.self, forKey: .messageDeliveryStatus)
        messageDeliveryStatus = messageDeliveryStatusDecoded
    }
}

extension GetFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

public struct GetFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFuotaTaskInputBody: Swift.Equatable {
}

extension GetFuotaTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFuotaTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.description = output.description
            self.firmwareUpdateImage = output.firmwareUpdateImage
            self.firmwareUpdateRole = output.firmwareUpdateRole
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.createdAt = nil
            self.description = nil
            self.firmwareUpdateImage = nil
            self.firmwareUpdateRole = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct GetFuotaTaskOutputResponse: Swift.Equatable {
    /// The arn of a FUOTA task.
    public var arn: Swift.String?
    /// Created at timestamp for the resource.
    public var createdAt: ClientRuntime.Date?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The S3 URI points to a firmware update image that is to be used with a FUOTA task.
    public var firmwareUpdateImage: Swift.String?
    /// The firmware update role that is to be used with a FUOTA task.
    public var firmwareUpdateRole: Swift.String?
    /// The ID of a FUOTA task.
    public var id: Swift.String?
    /// The LoRaWAN information returned from getting a FUOTA task.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo?
    /// The name of a FUOTA task.
    public var name: Swift.String?
    /// The status of a FUOTA task.
    public var status: IoTWirelessClientTypes.FuotaTaskStatus?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        firmwareUpdateImage: Swift.String? = nil,
        firmwareUpdateRole: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo? = nil,
        name: Swift.String? = nil,
        status: IoTWirelessClientTypes.FuotaTaskStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.firmwareUpdateImage = firmwareUpdateImage
        self.firmwareUpdateRole = firmwareUpdateRole
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.status = status
    }
}

struct GetFuotaTaskOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let status: IoTWirelessClientTypes.FuotaTaskStatus?
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo?
    let firmwareUpdateImage: Swift.String?
    let firmwareUpdateRole: Swift.String?
    let createdAt: ClientRuntime.Date?
}

extension GetFuotaTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.FuotaTaskStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let firmwareUpdateImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateImage)
        firmwareUpdateImage = firmwareUpdateImageDecoded
        let firmwareUpdateRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateRole)
        firmwareUpdateRole = firmwareUpdateRoleDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension GetLogLevelsByResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/log-levels"
    }
}

public struct GetLogLevelsByResourceTypesInput: Swift.Equatable {

    public init () { }
}

struct GetLogLevelsByResourceTypesInputBody: Swift.Equatable {
}

extension GetLogLevelsByResourceTypesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLogLevelsByResourceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLogLevelsByResourceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetLogLevelsByResourceTypesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLogLevelsByResourceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetLogLevelsByResourceTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.defaultLogLevel = output.defaultLogLevel
            self.wirelessDeviceLogOptions = output.wirelessDeviceLogOptions
            self.wirelessGatewayLogOptions = output.wirelessGatewayLogOptions
        } else {
            self.defaultLogLevel = nil
            self.wirelessDeviceLogOptions = nil
            self.wirelessGatewayLogOptions = nil
        }
    }
}

public struct GetLogLevelsByResourceTypesOutputResponse: Swift.Equatable {
    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    public var defaultLogLevel: IoTWirelessClientTypes.LogLevel?
    /// The list of wireless device log options.
    public var wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]?
    /// The list of wireless gateway log options.
    public var wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]?

    public init (
        defaultLogLevel: IoTWirelessClientTypes.LogLevel? = nil,
        wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]? = nil,
        wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.wirelessDeviceLogOptions = wirelessDeviceLogOptions
        self.wirelessGatewayLogOptions = wirelessGatewayLogOptions
    }
}

struct GetLogLevelsByResourceTypesOutputResponseBody: Swift.Equatable {
    let defaultLogLevel: IoTWirelessClientTypes.LogLevel?
    let wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]?
    let wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]?
}

extension GetLogLevelsByResourceTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultLogLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .defaultLogLevel)
        defaultLogLevel = defaultLogLevelDecoded
        let wirelessGatewayLogOptionsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessGatewayLogOption?].self, forKey: .wirelessGatewayLogOptions)
        var wirelessGatewayLogOptionsDecoded0:[IoTWirelessClientTypes.WirelessGatewayLogOption]? = nil
        if let wirelessGatewayLogOptionsContainer = wirelessGatewayLogOptionsContainer {
            wirelessGatewayLogOptionsDecoded0 = [IoTWirelessClientTypes.WirelessGatewayLogOption]()
            for structure0 in wirelessGatewayLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessGatewayLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayLogOptions = wirelessGatewayLogOptionsDecoded0
        let wirelessDeviceLogOptionsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessDeviceLogOption?].self, forKey: .wirelessDeviceLogOptions)
        var wirelessDeviceLogOptionsDecoded0:[IoTWirelessClientTypes.WirelessDeviceLogOption]? = nil
        if let wirelessDeviceLogOptionsContainer = wirelessDeviceLogOptionsContainer {
            wirelessDeviceLogOptionsDecoded0 = [IoTWirelessClientTypes.WirelessDeviceLogOption]()
            for structure0 in wirelessDeviceLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessDeviceLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceLogOptions = wirelessDeviceLogOptionsDecoded0
    }
}

extension GetMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())"
    }
}

public struct GetMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetMulticastGroupInputBody: Swift.Equatable {
}

extension GetMulticastGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMulticastGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.description = output.description
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.createdAt = nil
            self.description = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct GetMulticastGroupOutputResponse: Swift.Equatable {
    /// The arn of the multicast group.
    public var arn: Swift.String?
    /// Created at timestamp for the resource.
    public var createdAt: ClientRuntime.Date?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The ID of the multicast group.
    public var id: Swift.String?
    /// The LoRaWAN information that is to be returned from getting multicast group information.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastGet?
    /// The name of the multicast group.
    public var name: Swift.String?
    /// The status of the multicast group.
    public var status: Swift.String?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastGet? = nil,
        name: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.status = status
    }
}

struct GetMulticastGroupOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let status: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastGet?
    let createdAt: ClientRuntime.Date?
}

extension GetMulticastGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANMulticastGet.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension GetMulticastGroupSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/session"
    }
}

public struct GetMulticastGroupSessionInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetMulticastGroupSessionInputBody: Swift.Equatable {
}

extension GetMulticastGroupSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMulticastGroupSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMulticastGroupSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMulticastGroupSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMulticastGroupSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMulticastGroupSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loRaWAN = output.loRaWAN
        } else {
            self.loRaWAN = nil
        }
    }
}

public struct GetMulticastGroupSessionOutputResponse: Swift.Equatable {
    /// The LoRaWAN information used with the multicast session.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession?

    public init (
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession? = nil
    )
    {
        self.loRaWAN = loRaWAN
    }
}

struct GetMulticastGroupSessionOutputResponseBody: Swift.Equatable {
    let loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession?
}

extension GetMulticastGroupSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANMulticastSession.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension GetNetworkAnalyzerConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationName = configurationName else {
            return nil
        }
        return "/network-analyzer-configurations/\(configurationName.urlPercentEncoding())"
    }
}

public struct GetNetworkAnalyzerConfigurationInput: Swift.Equatable {
    /// Name of the network analyzer configuration.
    /// This member is required.
    public var configurationName: Swift.String?

    public init (
        configurationName: Swift.String? = nil
    )
    {
        self.configurationName = configurationName
    }
}

struct GetNetworkAnalyzerConfigurationInputBody: Swift.Equatable {
}

extension GetNetworkAnalyzerConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkAnalyzerConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkAnalyzerConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNetworkAnalyzerConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkAnalyzerConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNetworkAnalyzerConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.name = output.name
            self.traceContent = output.traceContent
            self.wirelessDevices = output.wirelessDevices
            self.wirelessGateways = output.wirelessGateways
        } else {
            self.arn = nil
            self.description = nil
            self.name = nil
            self.traceContent = nil
            self.wirelessDevices = nil
            self.wirelessGateways = nil
        }
    }
}

public struct GetNetworkAnalyzerConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// Name of the network analyzer configuration.
    public var name: Swift.String?
    /// Trace content for your wireless gateway and wireless device resources.
    public var traceContent: IoTWirelessClientTypes.TraceContent?
    /// List of wireless gateway resources that have been added to the network analyzer configuration.
    public var wirelessDevices: [Swift.String]?
    /// List of wireless gateway resources that have been added to the network analyzer configuration.
    public var wirelessGateways: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        traceContent: IoTWirelessClientTypes.TraceContent? = nil,
        wirelessDevices: [Swift.String]? = nil,
        wirelessGateways: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.name = name
        self.traceContent = traceContent
        self.wirelessDevices = wirelessDevices
        self.wirelessGateways = wirelessGateways
    }
}

struct GetNetworkAnalyzerConfigurationOutputResponseBody: Swift.Equatable {
    let traceContent: IoTWirelessClientTypes.TraceContent?
    let wirelessDevices: [Swift.String]?
    let wirelessGateways: [Swift.String]?
    let description: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
}

extension GetNetworkAnalyzerConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case name = "Name"
        case traceContent = "TraceContent"
        case wirelessDevices = "WirelessDevices"
        case wirelessGateways = "WirelessGateways"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceContentDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.TraceContent.self, forKey: .traceContent)
        traceContent = traceContentDecoded
        let wirelessDevicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessDevices)
        var wirelessDevicesDecoded0:[Swift.String]? = nil
        if let wirelessDevicesContainer = wirelessDevicesContainer {
            wirelessDevicesDecoded0 = [Swift.String]()
            for string0 in wirelessDevicesContainer {
                if let string0 = string0 {
                    wirelessDevicesDecoded0?.append(string0)
                }
            }
        }
        wirelessDevices = wirelessDevicesDecoded0
        let wirelessGatewaysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessGateways)
        var wirelessGatewaysDecoded0:[Swift.String]? = nil
        if let wirelessGatewaysContainer = wirelessGatewaysContainer {
            wirelessGatewaysDecoded0 = [Swift.String]()
            for string0 in wirelessGatewaysContainer {
                if let string0 = string0 {
                    wirelessGatewaysDecoded0?.append(string0)
                }
            }
        }
        wirelessGateways = wirelessGatewaysDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetPartnerAccountInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let partnerType = partnerType else {
                let message = "Creating a URL Query Item failed. partnerType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            items.append(partnerTypeQueryItem)
            return items
        }
    }
}

extension GetPartnerAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let partnerAccountId = partnerAccountId else {
            return nil
        }
        return "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
    }
}

public struct GetPartnerAccountInput: Swift.Equatable {
    /// The partner account ID to disassociate from the AWS account.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IoTWirelessClientTypes.PartnerType?

    public init (
        partnerAccountId: Swift.String? = nil,
        partnerType: IoTWirelessClientTypes.PartnerType? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
    }
}

struct GetPartnerAccountInputBody: Swift.Equatable {
}

extension GetPartnerAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPartnerAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPartnerAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPartnerAccountOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPartnerAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPartnerAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountLinked = output.accountLinked
            self.sidewalk = output.sidewalk
        } else {
            self.accountLinked = false
            self.sidewalk = nil
        }
    }
}

public struct GetPartnerAccountOutputResponse: Swift.Equatable {
    /// Whether the partner account is linked to the AWS account.
    public var accountLinked: Swift.Bool
    /// The Sidewalk account credentials.
    public var sidewalk: IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint?

    public init (
        accountLinked: Swift.Bool = false,
        sidewalk: IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint? = nil
    )
    {
        self.accountLinked = accountLinked
        self.sidewalk = sidewalk
    }
}

struct GetPartnerAccountOutputResponseBody: Swift.Equatable {
    let sidewalk: IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint?
    let accountLinked: Swift.Bool
}

extension GetPartnerAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLinked = "AccountLinked"
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let accountLinkedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accountLinked) ?? false
        accountLinked = accountLinkedDecoded
    }
}

extension GetPositionConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension GetPositionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/position-configurations/\(resourceIdentifier.urlPercentEncoding())"
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct GetPositionConfigurationInput: Swift.Equatable {
    /// Resource identifier used in a position configuration.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// Resource type of the resource for which position configuration is retrieved.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init (
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct GetPositionConfigurationInputBody: Swift.Equatable {
}

extension GetPositionConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPositionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPositionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPositionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPositionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPositionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destination = output.destination
            self.solvers = output.solvers
        } else {
            self.destination = nil
            self.solvers = nil
        }
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct GetPositionConfigurationOutputResponse: Swift.Equatable {
    /// The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
    public var destination: Swift.String?
    /// The wrapper for the solver configuration details object.
    public var solvers: IoTWirelessClientTypes.PositionSolverDetails?

    public init (
        destination: Swift.String? = nil,
        solvers: IoTWirelessClientTypes.PositionSolverDetails? = nil
    )
    {
        self.destination = destination
        self.solvers = solvers
    }
}

struct GetPositionConfigurationOutputResponseBody: Swift.Equatable {
    let solvers: IoTWirelessClientTypes.PositionSolverDetails?
    let destination: Swift.String?
}

extension GetPositionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case solvers = "Solvers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solversDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionSolverDetails.self, forKey: .solvers)
        solvers = solversDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension GetPositionEstimateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellTowers = "CellTowers"
        case gnss = "Gnss"
        case ip = "Ip"
        case timestamp = "Timestamp"
        case wiFiAccessPoints = "WiFiAccessPoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellTowers = self.cellTowers {
            try encodeContainer.encode(cellTowers, forKey: .cellTowers)
        }
        if let gnss = self.gnss {
            try encodeContainer.encode(gnss, forKey: .gnss)
        }
        if let ip = self.ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let wiFiAccessPoints = wiFiAccessPoints {
            var wiFiAccessPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wiFiAccessPoints)
            for wifiaccesspoint0 in wiFiAccessPoints {
                try wiFiAccessPointsContainer.encode(wifiaccesspoint0)
            }
        }
    }
}

extension GetPositionEstimateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/position-estimate"
    }
}

public struct GetPositionEstimateInput: Swift.Equatable {
    /// Retrieves an estimated device position by resolving measurement data from cellular radio towers. The position is resolved using HERE's cellular-based solver.
    public var cellTowers: IoTWirelessClientTypes.CellTowers?
    /// Retrieves an estimated device position by resolving the global navigation satellite system (GNSS) scan data. The position is resolved using the GNSS solver powered by LoRa Cloud.
    public var gnss: IoTWirelessClientTypes.Gnss?
    /// Retrieves an estimated device position by resolving the IP address information from the device. The position is resolved using MaxMind's IP-based solver.
    public var ip: IoTWirelessClientTypes.Ip?
    /// Optional information that specifies the time when the position information will be resolved. It uses the UNIX timestamp format. If not specified, the time at which the request was received will be used.
    public var timestamp: ClientRuntime.Date?
    /// Retrieves an estimated device position by resolving WLAN measurement data. The position is resolved using HERE's Wi-Fi based solver.
    public var wiFiAccessPoints: [IoTWirelessClientTypes.WiFiAccessPoint]?

    public init (
        cellTowers: IoTWirelessClientTypes.CellTowers? = nil,
        gnss: IoTWirelessClientTypes.Gnss? = nil,
        ip: IoTWirelessClientTypes.Ip? = nil,
        timestamp: ClientRuntime.Date? = nil,
        wiFiAccessPoints: [IoTWirelessClientTypes.WiFiAccessPoint]? = nil
    )
    {
        self.cellTowers = cellTowers
        self.gnss = gnss
        self.ip = ip
        self.timestamp = timestamp
        self.wiFiAccessPoints = wiFiAccessPoints
    }
}

struct GetPositionEstimateInputBody: Swift.Equatable {
    let wiFiAccessPoints: [IoTWirelessClientTypes.WiFiAccessPoint]?
    let cellTowers: IoTWirelessClientTypes.CellTowers?
    let ip: IoTWirelessClientTypes.Ip?
    let gnss: IoTWirelessClientTypes.Gnss?
    let timestamp: ClientRuntime.Date?
}

extension GetPositionEstimateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellTowers = "CellTowers"
        case gnss = "Gnss"
        case ip = "Ip"
        case timestamp = "Timestamp"
        case wiFiAccessPoints = "WiFiAccessPoints"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wiFiAccessPointsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WiFiAccessPoint?].self, forKey: .wiFiAccessPoints)
        var wiFiAccessPointsDecoded0:[IoTWirelessClientTypes.WiFiAccessPoint]? = nil
        if let wiFiAccessPointsContainer = wiFiAccessPointsContainer {
            wiFiAccessPointsDecoded0 = [IoTWirelessClientTypes.WiFiAccessPoint]()
            for structure0 in wiFiAccessPointsContainer {
                if let structure0 = structure0 {
                    wiFiAccessPointsDecoded0?.append(structure0)
                }
            }
        }
        wiFiAccessPoints = wiFiAccessPointsDecoded0
        let cellTowersDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.CellTowers.self, forKey: .cellTowers)
        cellTowers = cellTowersDecoded
        let ipDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.Ip.self, forKey: .ip)
        ip = ipDecoded
        let gnssDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.Gnss.self, forKey: .gnss)
        gnss = gnssDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension GetPositionEstimateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPositionEstimateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPositionEstimateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPositionEstimateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            self.geoJsonPayload = data
        } else {
            self.geoJsonPayload = nil
        }
    }
}

public struct GetPositionEstimateOutputResponse: Swift.Equatable {
    /// The position information of the resource, displayed as a JSON payload. The payload uses the GeoJSON format, which a format that's used to encode geographic data structures. For more information, see [GeoJSON](https://geojson.org/).
    public var geoJsonPayload: ClientRuntime.Data?

    public init (
        geoJsonPayload: ClientRuntime.Data? = nil
    )
    {
        self.geoJsonPayload = geoJsonPayload
    }
}

struct GetPositionEstimateOutputResponseBody: Swift.Equatable {
    let geoJsonPayload: ClientRuntime.Data?
}

extension GetPositionEstimateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geoJsonPayload = "GeoJsonPayload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoJsonPayloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .geoJsonPayload)
        geoJsonPayload = geoJsonPayloadDecoded
    }
}

extension GetPositionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension GetPositionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/positions/\(resourceIdentifier.urlPercentEncoding())"
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct GetPositionInput: Swift.Equatable {
    /// Resource identifier used to retrieve the position information.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// Resource type of the resource for which position information is retrieved.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init (
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct GetPositionInputBody: Swift.Equatable {
}

extension GetPositionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPositionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPositionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPositionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPositionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPositionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accuracy = output.accuracy
            self.position = output.position
            self.solverProvider = output.solverProvider
            self.solverType = output.solverType
            self.solverVersion = output.solverVersion
            self.timestamp = output.timestamp
        } else {
            self.accuracy = nil
            self.position = nil
            self.solverProvider = nil
            self.solverType = nil
            self.solverVersion = nil
            self.timestamp = nil
        }
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct GetPositionOutputResponse: Swift.Equatable {
    /// The accuracy of the estimated position in meters. An empty value indicates that no position data is available. A value of ‘0.0’ value indicates that position data is available. This data corresponds to the position information that you specified instead of the position computed by solver.
    public var accuracy: IoTWirelessClientTypes.Accuracy?
    /// The position information of the resource.
    public var position: [Swift.Float]?
    /// The vendor of the positioning solver.
    public var solverProvider: IoTWirelessClientTypes.PositionSolverProvider?
    /// The type of solver used to identify the position of the resource.
    public var solverType: IoTWirelessClientTypes.PositionSolverType?
    /// The version of the positioning solver.
    public var solverVersion: Swift.String?
    /// The timestamp at which the device's position was determined.
    public var timestamp: Swift.String?

    public init (
        accuracy: IoTWirelessClientTypes.Accuracy? = nil,
        position: [Swift.Float]? = nil,
        solverProvider: IoTWirelessClientTypes.PositionSolverProvider? = nil,
        solverType: IoTWirelessClientTypes.PositionSolverType? = nil,
        solverVersion: Swift.String? = nil,
        timestamp: Swift.String? = nil
    )
    {
        self.accuracy = accuracy
        self.position = position
        self.solverProvider = solverProvider
        self.solverType = solverType
        self.solverVersion = solverVersion
        self.timestamp = timestamp
    }
}

struct GetPositionOutputResponseBody: Swift.Equatable {
    let position: [Swift.Float]?
    let accuracy: IoTWirelessClientTypes.Accuracy?
    let solverType: IoTWirelessClientTypes.PositionSolverType?
    let solverProvider: IoTWirelessClientTypes.PositionSolverProvider?
    let solverVersion: Swift.String?
    let timestamp: Swift.String?
}

extension GetPositionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accuracy = "Accuracy"
        case position = "Position"
        case solverProvider = "SolverProvider"
        case solverType = "SolverType"
        case solverVersion = "SolverVersion"
        case timestamp = "Timestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positionContainer = try containerValues.decodeIfPresent([Swift.Float?].self, forKey: .position)
        var positionDecoded0:[Swift.Float]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Float]()
            for float0 in positionContainer {
                if let float0 = float0 {
                    positionDecoded0?.append(float0)
                }
            }
        }
        position = positionDecoded0
        let accuracyDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.Accuracy.self, forKey: .accuracy)
        accuracy = accuracyDecoded
        let solverTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionSolverType.self, forKey: .solverType)
        solverType = solverTypeDecoded
        let solverProviderDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionSolverProvider.self, forKey: .solverProvider)
        solverProvider = solverProviderDecoded
        let solverVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solverVersion)
        solverVersion = solverVersionDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension GetResourceEventConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let partnerType = partnerType {
                let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
                items.append(partnerTypeQueryItem)
            }
            guard let identifierType = identifierType else {
                let message = "Creating a URL Query Item failed. identifierType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let identifierTypeQueryItem = ClientRuntime.URLQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
            items.append(identifierTypeQueryItem)
            return items
        }
    }
}

extension GetResourceEventConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/event-configurations/\(identifier.urlPercentEncoding())"
    }
}

public struct GetResourceEventConfigurationInput: Swift.Equatable {
    /// Resource identifier to opt in for event messaging.
    /// This member is required.
    public var identifier: Swift.String?
    /// Identifier type of the particular resource identifier for event configuration.
    /// This member is required.
    public var identifierType: IoTWirelessClientTypes.IdentifierType?
    /// Partner type of the resource if the identifier type is PartnerAccountId.
    public var partnerType: IoTWirelessClientTypes.EventNotificationPartnerType?

    public init (
        identifier: Swift.String? = nil,
        identifierType: IoTWirelessClientTypes.IdentifierType? = nil,
        partnerType: IoTWirelessClientTypes.EventNotificationPartnerType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
        self.partnerType = partnerType
    }
}

struct GetResourceEventConfigurationInputBody: Swift.Equatable {
}

extension GetResourceEventConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceEventConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceEventConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceEventConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceEventConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceEventConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionStatus = output.connectionStatus
            self.deviceRegistrationState = output.deviceRegistrationState
            self.join = output.join
            self.messageDeliveryStatus = output.messageDeliveryStatus
            self.proximity = output.proximity
        } else {
            self.connectionStatus = nil
            self.deviceRegistrationState = nil
            self.join = nil
            self.messageDeliveryStatus = nil
            self.proximity = nil
        }
    }
}

public struct GetResourceEventConfigurationOutputResponse: Swift.Equatable {
    /// Event configuration for the connection status event.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration?
    /// Event configuration for the device registration state event.
    public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
    /// Event configuration for the join event.
    public var join: IoTWirelessClientTypes.JoinEventConfiguration?
    /// Event configuration for the message delivery status event.
    public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration?
    /// Event configuration for the proximity event.
    public var proximity: IoTWirelessClientTypes.ProximityEventConfiguration?

    public init (
        connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration? = nil,
        deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration? = nil,
        join: IoTWirelessClientTypes.JoinEventConfiguration? = nil,
        messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration? = nil,
        proximity: IoTWirelessClientTypes.ProximityEventConfiguration? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.deviceRegistrationState = deviceRegistrationState
        self.join = join
        self.messageDeliveryStatus = messageDeliveryStatus
        self.proximity = proximity
    }
}

struct GetResourceEventConfigurationOutputResponseBody: Swift.Equatable {
    let deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
    let proximity: IoTWirelessClientTypes.ProximityEventConfiguration?
    let join: IoTWirelessClientTypes.JoinEventConfiguration?
    let connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration?
    let messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration?
}

extension GetResourceEventConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case deviceRegistrationState = "DeviceRegistrationState"
        case join = "Join"
        case messageDeliveryStatus = "MessageDeliveryStatus"
        case proximity = "Proximity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceRegistrationStateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration.self, forKey: .deviceRegistrationState)
        deviceRegistrationState = deviceRegistrationStateDecoded
        let proximityDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ProximityEventConfiguration.self, forKey: .proximity)
        proximity = proximityDecoded
        let joinDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.JoinEventConfiguration.self, forKey: .join)
        join = joinDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ConnectionStatusEventConfiguration.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let messageDeliveryStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration.self, forKey: .messageDeliveryStatus)
        messageDeliveryStatus = messageDeliveryStatusDecoded
    }
}

extension GetResourceLogLevelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension GetResourceLogLevelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct GetResourceLogLevelInput: Swift.Equatable {
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway, it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct GetResourceLogLevelInputBody: Swift.Equatable {
}

extension GetResourceLogLevelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceLogLevelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceLogLevelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceLogLevelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceLogLevelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceLogLevelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logLevel = output.logLevel
        } else {
            self.logLevel = nil
        }
    }
}

public struct GetResourceLogLevelOutputResponse: Swift.Equatable {
    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    public var logLevel: IoTWirelessClientTypes.LogLevel?

    public init (
        logLevel: IoTWirelessClientTypes.LogLevel? = nil
    )
    {
        self.logLevel = logLevel
    }
}

struct GetResourceLogLevelOutputResponseBody: Swift.Equatable {
    let logLevel: IoTWirelessClientTypes.LogLevel?
}

extension GetResourceLogLevelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension GetResourcePositionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension GetResourcePositionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/resource-positions/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct GetResourcePositionInput: Swift.Equatable {
    /// The identifier of the resource for which position information is retrieved. It can be the wireless device ID or the wireless gateway ID depending on the resource type.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of resource for which position information is retrieved, which can be a wireless device or a wireless gateway.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init (
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct GetResourcePositionInputBody: Swift.Equatable {
}

extension GetResourcePositionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcePositionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePositionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourcePositionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePositionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            self.geoJsonPayload = data
        } else {
            self.geoJsonPayload = nil
        }
    }
}

public struct GetResourcePositionOutputResponse: Swift.Equatable {
    /// The position information of the resource, displayed as a JSON payload. The payload uses the GeoJSON format, which a format that's used to encode geographic data structures. For more information, see [GeoJSON](https://geojson.org/).
    public var geoJsonPayload: ClientRuntime.Data?

    public init (
        geoJsonPayload: ClientRuntime.Data? = nil
    )
    {
        self.geoJsonPayload = geoJsonPayload
    }
}

struct GetResourcePositionOutputResponseBody: Swift.Equatable {
    let geoJsonPayload: ClientRuntime.Data?
}

extension GetResourcePositionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geoJsonPayload = "GeoJsonPayload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoJsonPayloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .geoJsonPayload)
        geoJsonPayload = geoJsonPayloadDecoded
    }
}

extension GetServiceEndpointInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let serviceType = serviceType {
                let serviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "serviceType".urlPercentEncoding(), value: Swift.String(serviceType.rawValue).urlPercentEncoding())
                items.append(serviceTypeQueryItem)
            }
            return items
        }
    }
}

extension GetServiceEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/service-endpoint"
    }
}

public struct GetServiceEndpointInput: Swift.Equatable {
    /// The service type for which to get endpoint information about. Can be CUPS for the Configuration and Update Server endpoint, or LNS for the LoRaWAN Network Server endpoint or CLAIM for the global endpoint.
    public var serviceType: IoTWirelessClientTypes.WirelessGatewayServiceType?

    public init (
        serviceType: IoTWirelessClientTypes.WirelessGatewayServiceType? = nil
    )
    {
        self.serviceType = serviceType
    }
}

struct GetServiceEndpointInputBody: Swift.Equatable {
}

extension GetServiceEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetServiceEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetServiceEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverTrust = output.serverTrust
            self.serviceEndpoint = output.serviceEndpoint
            self.serviceType = output.serviceType
        } else {
            self.serverTrust = nil
            self.serviceEndpoint = nil
            self.serviceType = nil
        }
    }
}

public struct GetServiceEndpointOutputResponse: Swift.Equatable {
    /// The Root CA of the server trust certificate.
    public var serverTrust: Swift.String?
    /// The service endpoint value.
    public var serviceEndpoint: Swift.String?
    /// The endpoint's service type.
    public var serviceType: IoTWirelessClientTypes.WirelessGatewayServiceType?

    public init (
        serverTrust: Swift.String? = nil,
        serviceEndpoint: Swift.String? = nil,
        serviceType: IoTWirelessClientTypes.WirelessGatewayServiceType? = nil
    )
    {
        self.serverTrust = serverTrust
        self.serviceEndpoint = serviceEndpoint
        self.serviceType = serviceType
    }
}

struct GetServiceEndpointOutputResponseBody: Swift.Equatable {
    let serviceType: IoTWirelessClientTypes.WirelessGatewayServiceType?
    let serviceEndpoint: Swift.String?
    let serverTrust: Swift.String?
}

extension GetServiceEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverTrust = "ServerTrust"
        case serviceEndpoint = "ServiceEndpoint"
        case serviceType = "ServiceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessGatewayServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let serviceEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceEndpoint)
        serviceEndpoint = serviceEndpointDecoded
        let serverTrustDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverTrust)
        serverTrust = serverTrustDecoded
    }
}

extension GetServiceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/service-profiles/\(id.urlPercentEncoding())"
    }
}

public struct GetServiceProfileInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetServiceProfileInputBody: Swift.Equatable {
}

extension GetServiceProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetServiceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetServiceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
        } else {
            self.arn = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
        }
    }
}

public struct GetServiceProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the service profile.
    public var id: Swift.String?
    /// Information about the service profile.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo?
    /// The name of the resource.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct GetServiceProfileOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let id: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo?
}

extension GetServiceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension GetWirelessDeviceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let identifierType = identifierType else {
                let message = "Creating a URL Query Item failed. identifierType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let identifierTypeQueryItem = ClientRuntime.URLQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
            items.append(identifierTypeQueryItem)
            return items
        }
    }
}

extension GetWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/wireless-devices/\(identifier.urlPercentEncoding())"
    }
}

public struct GetWirelessDeviceInput: Swift.Equatable {
    /// The identifier of the wireless device to get.
    /// This member is required.
    public var identifier: Swift.String?
    /// The type of identifier used in identifier.
    /// This member is required.
    public var identifierType: IoTWirelessClientTypes.WirelessDeviceIdType?

    public init (
        identifier: Swift.String? = nil,
        identifierType: IoTWirelessClientTypes.WirelessDeviceIdType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
    }
}

struct GetWirelessDeviceInputBody: Swift.Equatable {
}

extension GetWirelessDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.destinationName = output.destinationName
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.positioning = output.positioning
            self.sidewalk = output.sidewalk
            self.thingArn = output.thingArn
            self.thingName = output.thingName
            self.type = output.type
        } else {
            self.arn = nil
            self.description = nil
            self.destinationName = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.positioning = nil
            self.sidewalk = nil
            self.thingArn = nil
            self.thingName = nil
            self.type = nil
        }
    }
}

public struct GetWirelessDeviceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The name of the destination to which the device is assigned.
    public var destinationName: Swift.String?
    /// The ID of the wireless device.
    public var id: Swift.String?
    /// Information about the wireless device.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDevice?
    /// The name of the resource.
    public var name: Swift.String?
    /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
    public var positioning: IoTWirelessClientTypes.PositioningConfigStatus?
    /// Sidewalk device object.
    public var sidewalk: IoTWirelessClientTypes.SidewalkDevice?
    /// The ARN of the thing associated with the wireless device.
    public var thingArn: Swift.String?
    /// The name of the thing associated with the wireless device. The value is empty if a thing isn't associated with the device.
    public var thingName: Swift.String?
    /// The wireless device type.
    public var type: IoTWirelessClientTypes.WirelessDeviceType?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDevice? = nil,
        name: Swift.String? = nil,
        positioning: IoTWirelessClientTypes.PositioningConfigStatus? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkDevice? = nil,
        thingArn: Swift.String? = nil,
        thingName: Swift.String? = nil,
        type: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.destinationName = destinationName
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.positioning = positioning
        self.sidewalk = sidewalk
        self.thingArn = thingArn
        self.thingName = thingName
        self.type = type
    }
}

struct GetWirelessDeviceOutputResponseBody: Swift.Equatable {
    let type: IoTWirelessClientTypes.WirelessDeviceType?
    let name: Swift.String?
    let description: Swift.String?
    let destinationName: Swift.String?
    let id: Swift.String?
    let arn: Swift.String?
    let thingName: Swift.String?
    let thingArn: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANDevice?
    let sidewalk: IoTWirelessClientTypes.SidewalkDevice?
    let positioning: IoTWirelessClientTypes.PositioningConfigStatus?
}

extension GetWirelessDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case destinationName = "DestinationName"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case positioning = "Positioning"
        case sidewalk = "Sidewalk"
        case thingArn = "ThingArn"
        case thingName = "ThingName"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let positioningDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositioningConfigStatus.self, forKey: .positioning)
        positioning = positioningDecoded
    }
}

extension GetWirelessDeviceStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let wirelessDeviceId = wirelessDeviceId else {
            return nil
        }
        return "/wireless-devices/\(wirelessDeviceId.urlPercentEncoding())/statistics"
    }
}

public struct GetWirelessDeviceStatisticsInput: Swift.Equatable {
    /// The ID of the wireless device for which to get the data.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init (
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct GetWirelessDeviceStatisticsInputBody: Swift.Equatable {
}

extension GetWirelessDeviceStatisticsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessDeviceStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessDeviceStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWirelessDeviceStatisticsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessDeviceStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWirelessDeviceStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.loRaWAN = output.loRaWAN
            self.sidewalk = output.sidewalk
            self.wirelessDeviceId = output.wirelessDeviceId
        } else {
            self.lastUplinkReceivedAt = nil
            self.loRaWAN = nil
            self.sidewalk = nil
            self.wirelessDeviceId = nil
        }
    }
}

public struct GetWirelessDeviceStatisticsOutputResponse: Swift.Equatable {
    /// The date and time when the most recent uplink was received.
    public var lastUplinkReceivedAt: Swift.String?
    /// Information about the wireless device's operations.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceMetadata?
    /// MetaData for Sidewalk device.
    public var sidewalk: IoTWirelessClientTypes.SidewalkDeviceMetadata?
    /// The ID of the wireless device.
    public var wirelessDeviceId: Swift.String?

    public init (
        lastUplinkReceivedAt: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceMetadata? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkDeviceMetadata? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.loRaWAN = loRaWAN
        self.sidewalk = sidewalk
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct GetWirelessDeviceStatisticsOutputResponseBody: Swift.Equatable {
    let wirelessDeviceId: Swift.String?
    let lastUplinkReceivedAt: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceMetadata?
    let sidewalk: IoTWirelessClientTypes.SidewalkDeviceMetadata?
}

extension GetWirelessDeviceStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case sidewalk = "Sidewalk"
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessDeviceId)
        wirelessDeviceId = wirelessDeviceIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANDeviceMetadata.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkDeviceMetadata.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension GetWirelessGatewayCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
    }
}

public struct GetWirelessGatewayCertificateInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayCertificateInputBody: Swift.Equatable {
}

extension GetWirelessGatewayCertificateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWirelessGatewayCertificateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWirelessGatewayCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.iotCertificateId = output.iotCertificateId
            self.loRaWANNetworkServerCertificateId = output.loRaWANNetworkServerCertificateId
        } else {
            self.iotCertificateId = nil
            self.loRaWANNetworkServerCertificateId = nil
        }
    }
}

public struct GetWirelessGatewayCertificateOutputResponse: Swift.Equatable {
    /// The ID of the certificate associated with the wireless gateway.
    public var iotCertificateId: Swift.String?
    /// The ID of the certificate that is associated with the wireless gateway and used for the LoRaWANNetworkServer endpoint.
    public var loRaWANNetworkServerCertificateId: Swift.String?

    public init (
        iotCertificateId: Swift.String? = nil,
        loRaWANNetworkServerCertificateId: Swift.String? = nil
    )
    {
        self.iotCertificateId = iotCertificateId
        self.loRaWANNetworkServerCertificateId = loRaWANNetworkServerCertificateId
    }
}

struct GetWirelessGatewayCertificateOutputResponseBody: Swift.Equatable {
    let iotCertificateId: Swift.String?
    let loRaWANNetworkServerCertificateId: Swift.String?
}

extension GetWirelessGatewayCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
        case loRaWANNetworkServerCertificateId = "LoRaWANNetworkServerCertificateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
        let loRaWANNetworkServerCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loRaWANNetworkServerCertificateId)
        loRaWANNetworkServerCertificateId = loRaWANNetworkServerCertificateIdDecoded
    }
}

extension GetWirelessGatewayFirmwareInformationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/firmware-information"
    }
}

public struct GetWirelessGatewayFirmwareInformationInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayFirmwareInformationInputBody: Swift.Equatable {
}

extension GetWirelessGatewayFirmwareInformationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayFirmwareInformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayFirmwareInformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWirelessGatewayFirmwareInformationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayFirmwareInformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWirelessGatewayFirmwareInformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loRaWAN = output.loRaWAN
        } else {
            self.loRaWAN = nil
        }
    }
}

public struct GetWirelessGatewayFirmwareInformationOutputResponse: Swift.Equatable {
    /// Information about the wireless gateway's firmware.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion?

    public init (
        loRaWAN: IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion? = nil
    )
    {
        self.loRaWAN = loRaWAN
    }
}

struct GetWirelessGatewayFirmwareInformationOutputResponseBody: Swift.Equatable {
    let loRaWAN: IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion?
}

extension GetWirelessGatewayFirmwareInformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension GetWirelessGatewayInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let identifierType = identifierType else {
                let message = "Creating a URL Query Item failed. identifierType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let identifierTypeQueryItem = ClientRuntime.URLQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
            items.append(identifierTypeQueryItem)
            return items
        }
    }
}

extension GetWirelessGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/wireless-gateways/\(identifier.urlPercentEncoding())"
    }
}

public struct GetWirelessGatewayInput: Swift.Equatable {
    /// The identifier of the wireless gateway to get.
    /// This member is required.
    public var identifier: Swift.String?
    /// The type of identifier used in identifier.
    /// This member is required.
    public var identifierType: IoTWirelessClientTypes.WirelessGatewayIdType?

    public init (
        identifier: Swift.String? = nil,
        identifierType: IoTWirelessClientTypes.WirelessGatewayIdType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
    }
}

struct GetWirelessGatewayInputBody: Swift.Equatable {
}

extension GetWirelessGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWirelessGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWirelessGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.thingArn = output.thingArn
            self.thingName = output.thingName
        } else {
            self.arn = nil
            self.description = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.thingArn = nil
            self.thingName = nil
        }
    }
}

public struct GetWirelessGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The ID of the wireless gateway.
    public var id: Swift.String?
    /// Information about the wireless gateway.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANGateway?
    /// The name of the resource.
    public var name: Swift.String?
    /// The ARN of the thing associated with the wireless gateway.
    public var thingArn: Swift.String?
    /// The name of the thing associated with the wireless gateway. The value is empty if a thing isn't associated with the gateway.
    public var thingName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANGateway? = nil,
        name: Swift.String? = nil,
        thingArn: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.thingArn = thingArn
        self.thingName = thingName
    }
}

struct GetWirelessGatewayOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let id: Swift.String?
    let description: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANGateway?
    let arn: Swift.String?
    let thingName: Swift.String?
    let thingArn: Swift.String?
}

extension GetWirelessGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case thingArn = "ThingArn"
        case thingName = "ThingName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension GetWirelessGatewayStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let wirelessGatewayId = wirelessGatewayId else {
            return nil
        }
        return "/wireless-gateways/\(wirelessGatewayId.urlPercentEncoding())/statistics"
    }
}

public struct GetWirelessGatewayStatisticsInput: Swift.Equatable {
    /// The ID of the wireless gateway for which to get the data.
    /// This member is required.
    public var wirelessGatewayId: Swift.String?

    public init (
        wirelessGatewayId: Swift.String? = nil
    )
    {
        self.wirelessGatewayId = wirelessGatewayId
    }
}

struct GetWirelessGatewayStatisticsInputBody: Swift.Equatable {
}

extension GetWirelessGatewayStatisticsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWirelessGatewayStatisticsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWirelessGatewayStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionStatus = output.connectionStatus
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.wirelessGatewayId = output.wirelessGatewayId
        } else {
            self.connectionStatus = nil
            self.lastUplinkReceivedAt = nil
            self.wirelessGatewayId = nil
        }
    }
}

public struct GetWirelessGatewayStatisticsOutputResponse: Swift.Equatable {
    /// The connection status of the wireless gateway.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatus?
    /// The date and time when the most recent uplink was received.
    public var lastUplinkReceivedAt: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayId: Swift.String?

    public init (
        connectionStatus: IoTWirelessClientTypes.ConnectionStatus? = nil,
        lastUplinkReceivedAt: Swift.String? = nil,
        wirelessGatewayId: Swift.String? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.wirelessGatewayId = wirelessGatewayId
    }
}

struct GetWirelessGatewayStatisticsOutputResponseBody: Swift.Equatable {
    let wirelessGatewayId: Swift.String?
    let lastUplinkReceivedAt: Swift.String?
    let connectionStatus: IoTWirelessClientTypes.ConnectionStatus?
}

extension GetWirelessGatewayStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case wirelessGatewayId = "WirelessGatewayId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayId)
        wirelessGatewayId = wirelessGatewayIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
    }
}

extension GetWirelessGatewayTaskDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateway-task-definitions/\(id.urlPercentEncoding())"
    }
}

public struct GetWirelessGatewayTaskDefinitionInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayTaskDefinitionInputBody: Swift.Equatable {
}

extension GetWirelessGatewayTaskDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayTaskDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayTaskDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWirelessGatewayTaskDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayTaskDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWirelessGatewayTaskDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.autoCreateTasks = output.autoCreateTasks
            self.name = output.name
            self.update = output.update
        } else {
            self.arn = nil
            self.autoCreateTasks = false
            self.name = nil
            self.update = nil
        }
    }
}

public struct GetWirelessGatewayTaskDefinitionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// Whether to automatically create tasks using this task definition for all gateways with the specified current version. If false, the task must me created by calling CreateWirelessGatewayTask.
    public var autoCreateTasks: Swift.Bool
    /// The name of the resource.
    public var name: Swift.String?
    /// Information about the gateways to update.
    public var update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate?

    public init (
        arn: Swift.String? = nil,
        autoCreateTasks: Swift.Bool = false,
        name: Swift.String? = nil,
        update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate? = nil
    )
    {
        self.arn = arn
        self.autoCreateTasks = autoCreateTasks
        self.name = name
        self.update = update
    }
}

struct GetWirelessGatewayTaskDefinitionOutputResponseBody: Swift.Equatable {
    let autoCreateTasks: Swift.Bool
    let name: Swift.String?
    let update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate?
    let arn: Swift.String?
}

extension GetWirelessGatewayTaskDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case autoCreateTasks = "AutoCreateTasks"
        case name = "Name"
        case update = "Update"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoCreateTasksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoCreateTasks) ?? false
        autoCreateTasks = autoCreateTasksDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate.self, forKey: .update)
        update = updateDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetWirelessGatewayTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
    }
}

public struct GetWirelessGatewayTaskInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayTaskInputBody: Swift.Equatable {
}

extension GetWirelessGatewayTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWirelessGatewayTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWirelessGatewayTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.status = output.status
            self.taskCreatedAt = output.taskCreatedAt
            self.wirelessGatewayId = output.wirelessGatewayId
            self.wirelessGatewayTaskDefinitionId = output.wirelessGatewayTaskDefinitionId
        } else {
            self.lastUplinkReceivedAt = nil
            self.status = nil
            self.taskCreatedAt = nil
            self.wirelessGatewayId = nil
            self.wirelessGatewayTaskDefinitionId = nil
        }
    }
}

public struct GetWirelessGatewayTaskOutputResponse: Swift.Equatable {
    /// The date and time when the most recent uplink was received.
    public var lastUplinkReceivedAt: Swift.String?
    /// The status of the request.
    public var status: IoTWirelessClientTypes.WirelessGatewayTaskStatus?
    /// The date and time when the task was created.
    public var taskCreatedAt: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayId: Swift.String?
    /// The ID of the WirelessGatewayTask.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init (
        lastUplinkReceivedAt: Swift.String? = nil,
        status: IoTWirelessClientTypes.WirelessGatewayTaskStatus? = nil,
        taskCreatedAt: Swift.String? = nil,
        wirelessGatewayId: Swift.String? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.status = status
        self.taskCreatedAt = taskCreatedAt
        self.wirelessGatewayId = wirelessGatewayId
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct GetWirelessGatewayTaskOutputResponseBody: Swift.Equatable {
    let wirelessGatewayId: Swift.String?
    let wirelessGatewayTaskDefinitionId: Swift.String?
    let lastUplinkReceivedAt: Swift.String?
    let taskCreatedAt: Swift.String?
    let status: IoTWirelessClientTypes.WirelessGatewayTaskStatus?
}

extension GetWirelessGatewayTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case status = "Status"
        case taskCreatedAt = "TaskCreatedAt"
        case wirelessGatewayId = "WirelessGatewayId"
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayId)
        wirelessGatewayId = wirelessGatewayIdDecoded
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let taskCreatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskCreatedAt)
        taskCreatedAt = taskCreatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessGatewayTaskStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTWirelessClientTypes.GlobalIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geranCid = "GeranCid"
        case lac = "Lac"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geranCid = self.geranCid {
            try encodeContainer.encode(geranCid, forKey: .geranCid)
        }
        if let lac = self.lac {
            try encodeContainer.encode(lac, forKey: .lac)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lacDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lac)
        lac = lacDecoded
        let geranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .geranCid)
        geranCid = geranCidDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Global identity information.
    public struct GlobalIdentity: Swift.Equatable {
        /// GERAN (GSM EDGE Radio Access Network) cell global identifier.
        /// This member is required.
        public var geranCid: Swift.Int?
        /// Location area code of the global identity.
        /// This member is required.
        public var lac: Swift.Int?

        public init (
            geranCid: Swift.Int? = nil,
            lac: Swift.Int? = nil
        )
        {
            self.geranCid = geranCid
            self.lac = lac
        }
    }

}

extension IoTWirelessClientTypes.Gnss: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistAltitude = "AssistAltitude"
        case assistPosition = "AssistPosition"
        case captureTime = "CaptureTime"
        case captureTimeAccuracy = "CaptureTimeAccuracy"
        case payload = "Payload"
        case use2DSolver = "Use2DSolver"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistAltitude = self.assistAltitude {
            try encodeContainer.encode(assistAltitude, forKey: .assistAltitude)
        }
        if let assistPosition = assistPosition {
            var assistPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assistPosition)
            for coordinate0 in assistPosition {
                try assistPositionContainer.encode(coordinate0)
            }
        }
        if let captureTime = self.captureTime {
            try encodeContainer.encode(captureTime, forKey: .captureTime)
        }
        if let captureTimeAccuracy = self.captureTimeAccuracy {
            try encodeContainer.encode(captureTimeAccuracy, forKey: .captureTimeAccuracy)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if use2DSolver != false {
            try encodeContainer.encode(use2DSolver, forKey: .use2DSolver)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payload)
        payload = payloadDecoded
        let captureTimeDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .captureTime)
        captureTime = captureTimeDecoded
        let captureTimeAccuracyDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .captureTimeAccuracy)
        captureTimeAccuracy = captureTimeAccuracyDecoded
        let assistPositionContainer = try containerValues.decodeIfPresent([Swift.Float?].self, forKey: .assistPosition)
        var assistPositionDecoded0:[Swift.Float]? = nil
        if let assistPositionContainer = assistPositionContainer {
            assistPositionDecoded0 = [Swift.Float]()
            for float0 in assistPositionContainer {
                if let float0 = float0 {
                    assistPositionDecoded0?.append(float0)
                }
            }
        }
        assistPosition = assistPositionDecoded0
        let assistAltitudeDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .assistAltitude)
        assistAltitude = assistAltitudeDecoded
        let use2DSolverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .use2DSolver) ?? false
        use2DSolver = use2DSolverDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Global navigation satellite system (GNSS) object used for positioning.
    public struct Gnss: Swift.Equatable {
        /// Optional assistance altitude, which is the altitude of the device at capture time, specified in meters above the WGS84 reference ellipsoid.
        public var assistAltitude: Swift.Float?
        /// Optional assistance position information, specified using latitude and longitude values in degrees. The co-ordinates are inside the WGS84 reference frame.
        public var assistPosition: [Swift.Float]?
        /// Optional parameter that gives an estimate of the time when the GNSS scan information is taken, in seconds GPS time (GPST). If capture time is not specified, the local server time is used.
        public var captureTime: Swift.Float?
        /// Optional value that gives the capture time estimate accuracy, in seconds. If capture time accuracy is not specified, default value of 300 is used.
        public var captureTimeAccuracy: Swift.Float?
        /// Payload that contains the GNSS scan result, or NAV message, in hexadecimal notation.
        /// This member is required.
        public var payload: Swift.String?
        /// Optional parameter that forces 2D solve, which modifies the positioning algorithm to a 2D solution problem. When this parameter is specified, the assistance altitude should have an accuracy of at least 10 meters.
        public var use2DSolver: Swift.Bool

        public init (
            assistAltitude: Swift.Float? = nil,
            assistPosition: [Swift.Float]? = nil,
            captureTime: Swift.Float? = nil,
            captureTimeAccuracy: Swift.Float? = nil,
            payload: Swift.String? = nil,
            use2DSolver: Swift.Bool = false
        )
        {
            self.assistAltitude = assistAltitude
            self.assistPosition = assistPosition
            self.captureTime = captureTime
            self.captureTimeAccuracy = captureTimeAccuracy
            self.payload = payload
            self.use2DSolver = use2DSolver
        }
    }

}

extension IoTWirelessClientTypes.GsmLocalId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bcch = "Bcch"
        case bsic = "Bsic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bcch = self.bcch {
            try encodeContainer.encode(bcch, forKey: .bcch)
        }
        if let bsic = self.bsic {
            try encodeContainer.encode(bsic, forKey: .bsic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bsicDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bsic)
        bsic = bsicDecoded
        let bcchDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bcch)
        bcch = bcchDecoded
    }
}

extension IoTWirelessClientTypes {
    /// GSM local ID information, which corresponds to the local identification parameters of a GSM cell.
    public struct GsmLocalId: Swift.Equatable {
        /// GSM broadcast control channel.
        /// This member is required.
        public var bcch: Swift.Int?
        /// GSM base station identity code (BSIC).
        /// This member is required.
        public var bsic: Swift.Int?

        public init (
            bcch: Swift.Int? = nil,
            bsic: Swift.Int? = nil
        )
        {
            self.bcch = bcch
            self.bsic = bsic
        }
    }

}

extension IoTWirelessClientTypes.GsmNmrObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bcch = "Bcch"
        case bsic = "Bsic"
        case globalIdentity = "GlobalIdentity"
        case rxLevel = "RxLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bcch = self.bcch {
            try encodeContainer.encode(bcch, forKey: .bcch)
        }
        if let bsic = self.bsic {
            try encodeContainer.encode(bsic, forKey: .bsic)
        }
        if let globalIdentity = self.globalIdentity {
            try encodeContainer.encode(globalIdentity, forKey: .globalIdentity)
        }
        if let rxLevel = self.rxLevel {
            try encodeContainer.encode(rxLevel, forKey: .rxLevel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bsicDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bsic)
        bsic = bsicDecoded
        let bcchDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bcch)
        bcch = bcchDecoded
        let rxLevelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxLevel)
        rxLevel = rxLevelDecoded
        let globalIdentityDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.GlobalIdentity.self, forKey: .globalIdentity)
        globalIdentity = globalIdentityDecoded
    }
}

extension IoTWirelessClientTypes {
    /// GSM object for network measurement reports.
    public struct GsmNmrObj: Swift.Equatable {
        /// GSM broadcast control channel.
        /// This member is required.
        public var bcch: Swift.Int?
        /// GSM base station identity code (BSIC).
        /// This member is required.
        public var bsic: Swift.Int?
        /// Global identity information of the GSM object.
        public var globalIdentity: IoTWirelessClientTypes.GlobalIdentity?
        /// Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).
        public var rxLevel: Swift.Int?

        public init (
            bcch: Swift.Int? = nil,
            bsic: Swift.Int? = nil,
            globalIdentity: IoTWirelessClientTypes.GlobalIdentity? = nil,
            rxLevel: Swift.Int? = nil
        )
        {
            self.bcch = bcch
            self.bsic = bsic
            self.globalIdentity = globalIdentity
            self.rxLevel = rxLevel
        }
    }

}

extension IoTWirelessClientTypes.GsmObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geranCid = "GeranCid"
        case gsmLocalId = "GsmLocalId"
        case gsmNmr = "GsmNmr"
        case gsmTimingAdvance = "GsmTimingAdvance"
        case lac = "Lac"
        case mcc = "Mcc"
        case mnc = "Mnc"
        case rxLevel = "RxLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geranCid = self.geranCid {
            try encodeContainer.encode(geranCid, forKey: .geranCid)
        }
        if let gsmLocalId = self.gsmLocalId {
            try encodeContainer.encode(gsmLocalId, forKey: .gsmLocalId)
        }
        if let gsmNmr = gsmNmr {
            var gsmNmrContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gsmNmr)
            for gsmnmrobj0 in gsmNmr {
                try gsmNmrContainer.encode(gsmnmrobj0)
            }
        }
        if let gsmTimingAdvance = self.gsmTimingAdvance {
            try encodeContainer.encode(gsmTimingAdvance, forKey: .gsmTimingAdvance)
        }
        if let lac = self.lac {
            try encodeContainer.encode(lac, forKey: .lac)
        }
        if let mcc = self.mcc {
            try encodeContainer.encode(mcc, forKey: .mcc)
        }
        if let mnc = self.mnc {
            try encodeContainer.encode(mnc, forKey: .mnc)
        }
        if let rxLevel = self.rxLevel {
            try encodeContainer.encode(rxLevel, forKey: .rxLevel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mccDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mcc)
        mcc = mccDecoded
        let mncDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mnc)
        mnc = mncDecoded
        let lacDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lac)
        lac = lacDecoded
        let geranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .geranCid)
        geranCid = geranCidDecoded
        let gsmLocalIdDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.GsmLocalId.self, forKey: .gsmLocalId)
        gsmLocalId = gsmLocalIdDecoded
        let gsmTimingAdvanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gsmTimingAdvance)
        gsmTimingAdvance = gsmTimingAdvanceDecoded
        let rxLevelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxLevel)
        rxLevel = rxLevelDecoded
        let gsmNmrContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.GsmNmrObj?].self, forKey: .gsmNmr)
        var gsmNmrDecoded0:[IoTWirelessClientTypes.GsmNmrObj]? = nil
        if let gsmNmrContainer = gsmNmrContainer {
            gsmNmrDecoded0 = [IoTWirelessClientTypes.GsmNmrObj]()
            for structure0 in gsmNmrContainer {
                if let structure0 = structure0 {
                    gsmNmrDecoded0?.append(structure0)
                }
            }
        }
        gsmNmr = gsmNmrDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// GSM object.
    public struct GsmObj: Swift.Equatable {
        /// GERAN (GSM EDGE Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var geranCid: Swift.Int?
        /// GSM local identification (local ID) information.
        public var gsmLocalId: IoTWirelessClientTypes.GsmLocalId?
        /// GSM object for network measurement reports.
        public var gsmNmr: [IoTWirelessClientTypes.GsmNmrObj]?
        /// Timing advance value, which corresponds to the length of time a signal takes to reach the base station from a mobile phone.
        public var gsmTimingAdvance: Swift.Int?
        /// Location area code.
        /// This member is required.
        public var lac: Swift.Int?
        /// Mobile Country Code.
        /// This member is required.
        public var mcc: Swift.Int?
        /// Mobile Network Code.
        /// This member is required.
        public var mnc: Swift.Int?
        /// Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).
        public var rxLevel: Swift.Int?

        public init (
            geranCid: Swift.Int? = nil,
            gsmLocalId: IoTWirelessClientTypes.GsmLocalId? = nil,
            gsmNmr: [IoTWirelessClientTypes.GsmNmrObj]? = nil,
            gsmTimingAdvance: Swift.Int? = nil,
            lac: Swift.Int? = nil,
            mcc: Swift.Int? = nil,
            mnc: Swift.Int? = nil,
            rxLevel: Swift.Int? = nil
        )
        {
            self.geranCid = geranCid
            self.gsmLocalId = gsmLocalId
            self.gsmNmr = gsmNmr
            self.gsmTimingAdvance = gsmTimingAdvance
            self.lac = lac
            self.mcc = mcc
            self.mnc = mnc
            self.rxLevel = rxLevel
        }
    }

}

extension IoTWirelessClientTypes {
    public enum IdentifierType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deveui
        case gatewayeui
        case partneraccountid
        case wirelessdeviceid
        case wirelessgatewayid
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentifierType] {
            return [
                .deveui,
                .gatewayeui,
                .partneraccountid,
                .wirelessdeviceid,
                .wirelessgatewayid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deveui: return "DevEui"
            case .gatewayeui: return "GatewayEui"
            case .partneraccountid: return "PartnerAccountId"
            case .wirelessdeviceid: return "WirelessDeviceId"
            case .wirelessgatewayid: return "WirelessGatewayId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentifierType(rawValue: rawValue) ?? IdentifierType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred while processing a request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTWirelessClientTypes.Ip: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension IoTWirelessClientTypes {
    /// IP address used for resolving device location.
    public struct Ip: Swift.Equatable {
        /// IP address information.
        /// This member is required.
        public var ipAddress: Swift.String?

        public init (
            ipAddress: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
        }
    }

}

extension IoTWirelessClientTypes.JoinEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
        case wirelessDeviceIdEventTopic = "WirelessDeviceIdEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let wirelessDeviceIdEventTopic = self.wirelessDeviceIdEventTopic {
            try encodeContainer.encode(wirelessDeviceIdEventTopic.rawValue, forKey: .wirelessDeviceIdEventTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let wirelessDeviceIdEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessDeviceIdEventTopic)
        wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Join event configuration object for enabling or disabling topic.
    public struct JoinEventConfiguration: Swift.Equatable {
        /// Join event configuration object for enabling or disabling LoRaWAN related event topics.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations?
        /// Denotes whether the wireless device ID join event topic is enabled or disabled.
        public var wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init (
            loRaWAN: IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations? = nil,
            wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }
    }

}

extension IoTWirelessClientTypes.JoinResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Join resource type event configuration object for enabling or disabling topic.
    public struct JoinResourceTypeEventConfiguration: Swift.Equatable {
        /// Join resource type event configuration object for enabling or disabling LoRaWAN related event topics.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration?

        public init (
            loRaWAN: IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration? = nil
        )
        {
            self.loRaWAN = loRaWAN
        }
    }

}

extension ListDestinationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDestinationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/destinations"
    }
}

public struct ListDestinationsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDestinationsInputBody: Swift.Equatable {
}

extension ListDestinationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDestinationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDestinationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDestinationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDestinationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationList = output.destinationList
            self.nextToken = output.nextToken
        } else {
            self.destinationList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDestinationsOutputResponse: Swift.Equatable {
    /// The list of destinations.
    public var destinationList: [IoTWirelessClientTypes.Destinations]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        destinationList: [IoTWirelessClientTypes.Destinations]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationList = destinationList
        self.nextToken = nextToken
    }
}

struct ListDestinationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let destinationList: [IoTWirelessClientTypes.Destinations]?
}

extension ListDestinationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationList = "DestinationList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let destinationListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Destinations?].self, forKey: .destinationList)
        var destinationListDecoded0:[IoTWirelessClientTypes.Destinations]? = nil
        if let destinationListContainer = destinationListContainer {
            destinationListDecoded0 = [IoTWirelessClientTypes.Destinations]()
            for structure0 in destinationListContainer {
                if let structure0 = structure0 {
                    destinationListDecoded0?.append(structure0)
                }
            }
        }
        destinationList = destinationListDecoded0
    }
}

extension ListDeviceProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDeviceProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/device-profiles"
    }
}

public struct ListDeviceProfilesInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceProfilesInputBody: Swift.Equatable {
}

extension ListDeviceProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDeviceProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDeviceProfilesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDeviceProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceProfileList = output.deviceProfileList
            self.nextToken = output.nextToken
        } else {
            self.deviceProfileList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceProfilesOutputResponse: Swift.Equatable {
    /// The list of device profiles.
    public var deviceProfileList: [IoTWirelessClientTypes.DeviceProfile]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        deviceProfileList: [IoTWirelessClientTypes.DeviceProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceProfileList = deviceProfileList
        self.nextToken = nextToken
    }
}

struct ListDeviceProfilesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let deviceProfileList: [IoTWirelessClientTypes.DeviceProfile]?
}

extension ListDeviceProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceProfileList = "DeviceProfileList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let deviceProfileListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.DeviceProfile?].self, forKey: .deviceProfileList)
        var deviceProfileListDecoded0:[IoTWirelessClientTypes.DeviceProfile]? = nil
        if let deviceProfileListContainer = deviceProfileListContainer {
            deviceProfileListDecoded0 = [IoTWirelessClientTypes.DeviceProfile]()
            for structure0 in deviceProfileListContainer {
                if let structure0 = structure0 {
                    deviceProfileListDecoded0?.append(structure0)
                }
            }
        }
        deviceProfileList = deviceProfileListDecoded0
    }
}

extension ListEventConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension ListEventConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/event-configurations"
    }
}

public struct ListEventConfigurationsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// Resource type to filter event configurations.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.EventNotificationResourceType?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.EventNotificationResourceType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListEventConfigurationsInputBody: Swift.Equatable {
}

extension ListEventConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEventConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEventConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEventConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventConfigurationsList = output.eventConfigurationsList
            self.nextToken = output.nextToken
        } else {
            self.eventConfigurationsList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventConfigurationsOutputResponse: Swift.Equatable {
    /// Event configurations of all events for a single resource.
    public var eventConfigurationsList: [IoTWirelessClientTypes.EventConfigurationItem]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        eventConfigurationsList: [IoTWirelessClientTypes.EventConfigurationItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventConfigurationsList = eventConfigurationsList
        self.nextToken = nextToken
    }
}

struct ListEventConfigurationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let eventConfigurationsList: [IoTWirelessClientTypes.EventConfigurationItem]?
}

extension ListEventConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventConfigurationsList = "EventConfigurationsList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let eventConfigurationsListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.EventConfigurationItem?].self, forKey: .eventConfigurationsList)
        var eventConfigurationsListDecoded0:[IoTWirelessClientTypes.EventConfigurationItem]? = nil
        if let eventConfigurationsListContainer = eventConfigurationsListContainer {
            eventConfigurationsListDecoded0 = [IoTWirelessClientTypes.EventConfigurationItem]()
            for structure0 in eventConfigurationsListContainer {
                if let structure0 = structure0 {
                    eventConfigurationsListDecoded0?.append(structure0)
                }
            }
        }
        eventConfigurationsList = eventConfigurationsListDecoded0
    }
}

extension ListFuotaTasksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFuotaTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/fuota-tasks"
    }
}

public struct ListFuotaTasksInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFuotaTasksInputBody: Swift.Equatable {
}

extension ListFuotaTasksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFuotaTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFuotaTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFuotaTasksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFuotaTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFuotaTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fuotaTaskList = output.fuotaTaskList
            self.nextToken = output.nextToken
        } else {
            self.fuotaTaskList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFuotaTasksOutputResponse: Swift.Equatable {
    /// Lists the FUOTA tasks registered to your AWS account.
    public var fuotaTaskList: [IoTWirelessClientTypes.FuotaTask]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        fuotaTaskList: [IoTWirelessClientTypes.FuotaTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fuotaTaskList = fuotaTaskList
        self.nextToken = nextToken
    }
}

struct ListFuotaTasksOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let fuotaTaskList: [IoTWirelessClientTypes.FuotaTask]?
}

extension ListFuotaTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fuotaTaskList = "FuotaTaskList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let fuotaTaskListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.FuotaTask?].self, forKey: .fuotaTaskList)
        var fuotaTaskListDecoded0:[IoTWirelessClientTypes.FuotaTask]? = nil
        if let fuotaTaskListContainer = fuotaTaskListContainer {
            fuotaTaskListDecoded0 = [IoTWirelessClientTypes.FuotaTask]()
            for structure0 in fuotaTaskListContainer {
                if let structure0 = structure0 {
                    fuotaTaskListDecoded0?.append(structure0)
                }
            }
        }
        fuotaTaskList = fuotaTaskListDecoded0
    }
}

extension ListMulticastGroupsByFuotaTaskInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMulticastGroupsByFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/multicast-groups"
    }
}

public struct ListMulticastGroupsByFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        id: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMulticastGroupsByFuotaTaskInputBody: Swift.Equatable {
}

extension ListMulticastGroupsByFuotaTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMulticastGroupsByFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMulticastGroupsByFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMulticastGroupsByFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMulticastGroupsByFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMulticastGroupsByFuotaTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.multicastGroupList = output.multicastGroupList
            self.nextToken = output.nextToken
        } else {
            self.multicastGroupList = nil
            self.nextToken = nil
        }
    }
}

public struct ListMulticastGroupsByFuotaTaskOutputResponse: Swift.Equatable {
    /// List of multicast groups associated with a FUOTA task.
    public var multicastGroupList: [IoTWirelessClientTypes.MulticastGroupByFuotaTask]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        multicastGroupList: [IoTWirelessClientTypes.MulticastGroupByFuotaTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.multicastGroupList = multicastGroupList
        self.nextToken = nextToken
    }
}

struct ListMulticastGroupsByFuotaTaskOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let multicastGroupList: [IoTWirelessClientTypes.MulticastGroupByFuotaTask]?
}

extension ListMulticastGroupsByFuotaTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastGroupList = "MulticastGroupList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let multicastGroupListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.MulticastGroupByFuotaTask?].self, forKey: .multicastGroupList)
        var multicastGroupListDecoded0:[IoTWirelessClientTypes.MulticastGroupByFuotaTask]? = nil
        if let multicastGroupListContainer = multicastGroupListContainer {
            multicastGroupListDecoded0 = [IoTWirelessClientTypes.MulticastGroupByFuotaTask]()
            for structure0 in multicastGroupListContainer {
                if let structure0 = structure0 {
                    multicastGroupListDecoded0?.append(structure0)
                }
            }
        }
        multicastGroupList = multicastGroupListDecoded0
    }
}

extension ListMulticastGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMulticastGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/multicast-groups"
    }
}

public struct ListMulticastGroupsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMulticastGroupsInputBody: Swift.Equatable {
}

extension ListMulticastGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMulticastGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMulticastGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMulticastGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMulticastGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMulticastGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.multicastGroupList = output.multicastGroupList
            self.nextToken = output.nextToken
        } else {
            self.multicastGroupList = nil
            self.nextToken = nil
        }
    }
}

public struct ListMulticastGroupsOutputResponse: Swift.Equatable {
    /// List of multicast groups.
    public var multicastGroupList: [IoTWirelessClientTypes.MulticastGroup]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        multicastGroupList: [IoTWirelessClientTypes.MulticastGroup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.multicastGroupList = multicastGroupList
        self.nextToken = nextToken
    }
}

struct ListMulticastGroupsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let multicastGroupList: [IoTWirelessClientTypes.MulticastGroup]?
}

extension ListMulticastGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastGroupList = "MulticastGroupList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let multicastGroupListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.MulticastGroup?].self, forKey: .multicastGroupList)
        var multicastGroupListDecoded0:[IoTWirelessClientTypes.MulticastGroup]? = nil
        if let multicastGroupListContainer = multicastGroupListContainer {
            multicastGroupListDecoded0 = [IoTWirelessClientTypes.MulticastGroup]()
            for structure0 in multicastGroupListContainer {
                if let structure0 = structure0 {
                    multicastGroupListDecoded0?.append(structure0)
                }
            }
        }
        multicastGroupList = multicastGroupListDecoded0
    }
}

extension ListNetworkAnalyzerConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListNetworkAnalyzerConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/network-analyzer-configurations"
    }
}

public struct ListNetworkAnalyzerConfigurationsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNetworkAnalyzerConfigurationsInputBody: Swift.Equatable {
}

extension ListNetworkAnalyzerConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListNetworkAnalyzerConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNetworkAnalyzerConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListNetworkAnalyzerConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNetworkAnalyzerConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListNetworkAnalyzerConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkAnalyzerConfigurationList = output.networkAnalyzerConfigurationList
            self.nextToken = output.nextToken
        } else {
            self.networkAnalyzerConfigurationList = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworkAnalyzerConfigurationsOutputResponse: Swift.Equatable {
    /// The list of network analyzer configurations.
    public var networkAnalyzerConfigurationList: [IoTWirelessClientTypes.NetworkAnalyzerConfigurations]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        networkAnalyzerConfigurationList: [IoTWirelessClientTypes.NetworkAnalyzerConfigurations]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkAnalyzerConfigurationList = networkAnalyzerConfigurationList
        self.nextToken = nextToken
    }
}

struct ListNetworkAnalyzerConfigurationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let networkAnalyzerConfigurationList: [IoTWirelessClientTypes.NetworkAnalyzerConfigurations]?
}

extension ListNetworkAnalyzerConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkAnalyzerConfigurationList = "NetworkAnalyzerConfigurationList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let networkAnalyzerConfigurationListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.NetworkAnalyzerConfigurations?].self, forKey: .networkAnalyzerConfigurationList)
        var networkAnalyzerConfigurationListDecoded0:[IoTWirelessClientTypes.NetworkAnalyzerConfigurations]? = nil
        if let networkAnalyzerConfigurationListContainer = networkAnalyzerConfigurationListContainer {
            networkAnalyzerConfigurationListDecoded0 = [IoTWirelessClientTypes.NetworkAnalyzerConfigurations]()
            for structure0 in networkAnalyzerConfigurationListContainer {
                if let structure0 = structure0 {
                    networkAnalyzerConfigurationListDecoded0?.append(structure0)
                }
            }
        }
        networkAnalyzerConfigurationList = networkAnalyzerConfigurationListDecoded0
    }
}

extension ListPartnerAccountsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPartnerAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/partner-accounts"
    }
}

public struct ListPartnerAccountsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPartnerAccountsInputBody: Swift.Equatable {
}

extension ListPartnerAccountsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPartnerAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPartnerAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPartnerAccountsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartnerAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPartnerAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sidewalk = output.sidewalk
        } else {
            self.nextToken = nil
            self.sidewalk = nil
        }
    }
}

public struct ListPartnerAccountsOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The Sidewalk account credentials.
    public var sidewalk: [IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint]?

    public init (
        nextToken: Swift.String? = nil,
        sidewalk: [IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint]? = nil
    )
    {
        self.nextToken = nextToken
        self.sidewalk = sidewalk
    }
}

struct ListPartnerAccountsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sidewalk: [IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint]?
}

extension ListPartnerAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sidewalkContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint?].self, forKey: .sidewalk)
        var sidewalkDecoded0:[IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint]? = nil
        if let sidewalkContainer = sidewalkContainer {
            sidewalkDecoded0 = [IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint]()
            for structure0 in sidewalkContainer {
                if let structure0 = structure0 {
                    sidewalkDecoded0?.append(structure0)
                }
            }
        }
        sidewalk = sidewalkDecoded0
    }
}

extension ListPositionConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let resourceType = resourceType {
                let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
                items.append(resourceTypeQueryItem)
            }
            return items
        }
    }
}

extension ListPositionConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/position-configurations"
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct ListPositionConfigurationsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// Resource type for which position configurations are listed.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListPositionConfigurationsInputBody: Swift.Equatable {
}

extension ListPositionConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPositionConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPositionConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPositionConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPositionConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPositionConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.positionConfigurationList = output.positionConfigurationList
        } else {
            self.nextToken = nil
            self.positionConfigurationList = nil
        }
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct ListPositionConfigurationsOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of position configurations.
    public var positionConfigurationList: [IoTWirelessClientTypes.PositionConfigurationItem]?

    public init (
        nextToken: Swift.String? = nil,
        positionConfigurationList: [IoTWirelessClientTypes.PositionConfigurationItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.positionConfigurationList = positionConfigurationList
    }
}

struct ListPositionConfigurationsOutputResponseBody: Swift.Equatable {
    let positionConfigurationList: [IoTWirelessClientTypes.PositionConfigurationItem]?
    let nextToken: Swift.String?
}

extension ListPositionConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case positionConfigurationList = "PositionConfigurationList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positionConfigurationListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.PositionConfigurationItem?].self, forKey: .positionConfigurationList)
        var positionConfigurationListDecoded0:[IoTWirelessClientTypes.PositionConfigurationItem]? = nil
        if let positionConfigurationListContainer = positionConfigurationListContainer {
            positionConfigurationListDecoded0 = [IoTWirelessClientTypes.PositionConfigurationItem]()
            for structure0 in positionConfigurationListContainer {
                if let structure0 = structure0 {
                    positionConfigurationListDecoded0?.append(structure0)
                }
            }
        }
        positionConfigurationList = positionConfigurationListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListQueuedMessagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let wirelessDeviceType = wirelessDeviceType {
                let wirelessDeviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "WirelessDeviceType".urlPercentEncoding(), value: Swift.String(wirelessDeviceType.rawValue).urlPercentEncoding())
                items.append(wirelessDeviceTypeQueryItem)
            }
            return items
        }
    }
}

extension ListQueuedMessagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/data"
    }
}

public struct ListQueuedMessagesInput: Swift.Equatable {
    /// The ID of a given wireless device which the downlink message packets are being sent.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The wireless device type, whic can be either Sidewalk or LoRaWAN.
    public var wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType?

    public init (
        id: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.wirelessDeviceType = wirelessDeviceType
    }
}

struct ListQueuedMessagesInputBody: Swift.Equatable {
}

extension ListQueuedMessagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListQueuedMessagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQueuedMessagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListQueuedMessagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQueuedMessagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListQueuedMessagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.downlinkQueueMessagesList = output.downlinkQueueMessagesList
            self.nextToken = output.nextToken
        } else {
            self.downlinkQueueMessagesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListQueuedMessagesOutputResponse: Swift.Equatable {
    /// The messages in the downlink queue.
    public var downlinkQueueMessagesList: [IoTWirelessClientTypes.DownlinkQueueMessage]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        downlinkQueueMessagesList: [IoTWirelessClientTypes.DownlinkQueueMessage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.downlinkQueueMessagesList = downlinkQueueMessagesList
        self.nextToken = nextToken
    }
}

struct ListQueuedMessagesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let downlinkQueueMessagesList: [IoTWirelessClientTypes.DownlinkQueueMessage]?
}

extension ListQueuedMessagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downlinkQueueMessagesList = "DownlinkQueueMessagesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let downlinkQueueMessagesListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.DownlinkQueueMessage?].self, forKey: .downlinkQueueMessagesList)
        var downlinkQueueMessagesListDecoded0:[IoTWirelessClientTypes.DownlinkQueueMessage]? = nil
        if let downlinkQueueMessagesListContainer = downlinkQueueMessagesListContainer {
            downlinkQueueMessagesListDecoded0 = [IoTWirelessClientTypes.DownlinkQueueMessage]()
            for structure0 in downlinkQueueMessagesListContainer {
                if let structure0 = structure0 {
                    downlinkQueueMessagesListDecoded0?.append(structure0)
                }
            }
        }
        downlinkQueueMessagesList = downlinkQueueMessagesListDecoded0
    }
}

extension ListServiceProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListServiceProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/service-profiles"
    }
}

public struct ListServiceProfilesInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServiceProfilesInputBody: Swift.Equatable {
}

extension ListServiceProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListServiceProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListServiceProfilesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListServiceProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceProfileList = output.serviceProfileList
        } else {
            self.nextToken = nil
            self.serviceProfileList = nil
        }
    }
}

public struct ListServiceProfilesOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of service profiles.
    public var serviceProfileList: [IoTWirelessClientTypes.ServiceProfile]?

    public init (
        nextToken: Swift.String? = nil,
        serviceProfileList: [IoTWirelessClientTypes.ServiceProfile]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceProfileList = serviceProfileList
    }
}

struct ListServiceProfilesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serviceProfileList: [IoTWirelessClientTypes.ServiceProfile]?
}

extension ListServiceProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serviceProfileList = "ServiceProfileList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serviceProfileListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.ServiceProfile?].self, forKey: .serviceProfileList)
        var serviceProfileListDecoded0:[IoTWirelessClientTypes.ServiceProfile]? = nil
        if let serviceProfileListContainer = serviceProfileListContainer {
            serviceProfileListDecoded0 = [IoTWirelessClientTypes.ServiceProfile]()
            for structure0 in serviceProfileListContainer {
                if let structure0 = structure0 {
                    serviceProfileListDecoded0?.append(structure0)
                }
            }
        }
        serviceProfileList = serviceProfileListDecoded0
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource for which you want to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init (
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListWirelessDevicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let fuotaTaskId = fuotaTaskId {
                let fuotaTaskIdQueryItem = ClientRuntime.URLQueryItem(name: "fuotaTaskId".urlPercentEncoding(), value: Swift.String(fuotaTaskId).urlPercentEncoding())
                items.append(fuotaTaskIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let deviceProfileId = deviceProfileId {
                let deviceProfileIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceProfileId".urlPercentEncoding(), value: Swift.String(deviceProfileId).urlPercentEncoding())
                items.append(deviceProfileIdQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let multicastGroupId = multicastGroupId {
                let multicastGroupIdQueryItem = ClientRuntime.URLQueryItem(name: "multicastGroupId".urlPercentEncoding(), value: Swift.String(multicastGroupId).urlPercentEncoding())
                items.append(multicastGroupIdQueryItem)
            }
            if let destinationName = destinationName {
                let destinationNameQueryItem = ClientRuntime.URLQueryItem(name: "destinationName".urlPercentEncoding(), value: Swift.String(destinationName).urlPercentEncoding())
                items.append(destinationNameQueryItem)
            }
            if let wirelessDeviceType = wirelessDeviceType {
                let wirelessDeviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "wirelessDeviceType".urlPercentEncoding(), value: Swift.String(wirelessDeviceType.rawValue).urlPercentEncoding())
                items.append(wirelessDeviceTypeQueryItem)
            }
            if let serviceProfileId = serviceProfileId {
                let serviceProfileIdQueryItem = ClientRuntime.URLQueryItem(name: "serviceProfileId".urlPercentEncoding(), value: Swift.String(serviceProfileId).urlPercentEncoding())
                items.append(serviceProfileIdQueryItem)
            }
            return items
        }
    }
}

extension ListWirelessDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-devices"
    }
}

public struct ListWirelessDevicesInput: Swift.Equatable {
    /// A filter to list only the wireless devices that use this destination.
    public var destinationName: Swift.String?
    /// A filter to list only the wireless devices that use this device profile.
    public var deviceProfileId: Swift.String?
    /// The ID of a FUOTA task.
    public var fuotaTaskId: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// The ID of the multicast group.
    public var multicastGroupId: Swift.String?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// A filter to list only the wireless devices that use this service profile.
    public var serviceProfileId: Swift.String?
    /// A filter to list only the wireless devices that use this wireless device type.
    public var wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType?

    public init (
        destinationName: Swift.String? = nil,
        deviceProfileId: Swift.String? = nil,
        fuotaTaskId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        multicastGroupId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceProfileId: Swift.String? = nil,
        wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.destinationName = destinationName
        self.deviceProfileId = deviceProfileId
        self.fuotaTaskId = fuotaTaskId
        self.maxResults = maxResults
        self.multicastGroupId = multicastGroupId
        self.nextToken = nextToken
        self.serviceProfileId = serviceProfileId
        self.wirelessDeviceType = wirelessDeviceType
    }
}

struct ListWirelessDevicesInputBody: Swift.Equatable {
}

extension ListWirelessDevicesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWirelessDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWirelessDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWirelessDevicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWirelessDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWirelessDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.wirelessDeviceList = output.wirelessDeviceList
        } else {
            self.nextToken = nil
            self.wirelessDeviceList = nil
        }
    }
}

public struct ListWirelessDevicesOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the wireless device.
    public var wirelessDeviceList: [IoTWirelessClientTypes.WirelessDeviceStatistics]?

    public init (
        nextToken: Swift.String? = nil,
        wirelessDeviceList: [IoTWirelessClientTypes.WirelessDeviceStatistics]? = nil
    )
    {
        self.nextToken = nextToken
        self.wirelessDeviceList = wirelessDeviceList
    }
}

struct ListWirelessDevicesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let wirelessDeviceList: [IoTWirelessClientTypes.WirelessDeviceStatistics]?
}

extension ListWirelessDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case wirelessDeviceList = "WirelessDeviceList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let wirelessDeviceListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessDeviceStatistics?].self, forKey: .wirelessDeviceList)
        var wirelessDeviceListDecoded0:[IoTWirelessClientTypes.WirelessDeviceStatistics]? = nil
        if let wirelessDeviceListContainer = wirelessDeviceListContainer {
            wirelessDeviceListDecoded0 = [IoTWirelessClientTypes.WirelessDeviceStatistics]()
            for structure0 in wirelessDeviceListContainer {
                if let structure0 = structure0 {
                    wirelessDeviceListDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceList = wirelessDeviceListDecoded0
    }
}

extension ListWirelessGatewayTaskDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let taskDefinitionType = taskDefinitionType {
                let taskDefinitionTypeQueryItem = ClientRuntime.URLQueryItem(name: "taskDefinitionType".urlPercentEncoding(), value: Swift.String(taskDefinitionType.rawValue).urlPercentEncoding())
                items.append(taskDefinitionTypeQueryItem)
            }
            return items
        }
    }
}

extension ListWirelessGatewayTaskDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-gateway-task-definitions"
    }
}

public struct ListWirelessGatewayTaskDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// A filter to list only the wireless gateway task definitions that use this task definition type.
    public var taskDefinitionType: IoTWirelessClientTypes.WirelessGatewayTaskDefinitionType?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        taskDefinitionType: IoTWirelessClientTypes.WirelessGatewayTaskDefinitionType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskDefinitionType = taskDefinitionType
    }
}

struct ListWirelessGatewayTaskDefinitionsInputBody: Swift.Equatable {
}

extension ListWirelessGatewayTaskDefinitionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWirelessGatewayTaskDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWirelessGatewayTaskDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWirelessGatewayTaskDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWirelessGatewayTaskDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWirelessGatewayTaskDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.taskDefinitions = output.taskDefinitions
        } else {
            self.nextToken = nil
            self.taskDefinitions = nil
        }
    }
}

public struct ListWirelessGatewayTaskDefinitionsOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of task definitions.
    public var taskDefinitions: [IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry]?

    public init (
        nextToken: Swift.String? = nil,
        taskDefinitions: [IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskDefinitions = taskDefinitions
    }
}

struct ListWirelessGatewayTaskDefinitionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let taskDefinitions: [IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry]?
}

extension ListWirelessGatewayTaskDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case taskDefinitions = "TaskDefinitions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let taskDefinitionsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry?].self, forKey: .taskDefinitions)
        var taskDefinitionsDecoded0:[IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry]? = nil
        if let taskDefinitionsContainer = taskDefinitionsContainer {
            taskDefinitionsDecoded0 = [IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry]()
            for structure0 in taskDefinitionsContainer {
                if let structure0 = structure0 {
                    taskDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        taskDefinitions = taskDefinitionsDecoded0
    }
}

extension ListWirelessGatewaysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListWirelessGatewaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-gateways"
    }
}

public struct ListWirelessGatewaysInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWirelessGatewaysInputBody: Swift.Equatable {
}

extension ListWirelessGatewaysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWirelessGatewaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWirelessGatewaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWirelessGatewaysOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWirelessGatewaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWirelessGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.wirelessGatewayList = output.wirelessGatewayList
        } else {
            self.nextToken = nil
            self.wirelessGatewayList = nil
        }
    }
}

public struct ListWirelessGatewaysOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayList: [IoTWirelessClientTypes.WirelessGatewayStatistics]?

    public init (
        nextToken: Swift.String? = nil,
        wirelessGatewayList: [IoTWirelessClientTypes.WirelessGatewayStatistics]? = nil
    )
    {
        self.nextToken = nextToken
        self.wirelessGatewayList = wirelessGatewayList
    }
}

struct ListWirelessGatewaysOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let wirelessGatewayList: [IoTWirelessClientTypes.WirelessGatewayStatistics]?
}

extension ListWirelessGatewaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case wirelessGatewayList = "WirelessGatewayList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let wirelessGatewayListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessGatewayStatistics?].self, forKey: .wirelessGatewayList)
        var wirelessGatewayListDecoded0:[IoTWirelessClientTypes.WirelessGatewayStatistics]? = nil
        if let wirelessGatewayListContainer = wirelessGatewayListContainer {
            wirelessGatewayListDecoded0 = [IoTWirelessClientTypes.WirelessGatewayStatistics]()
            for structure0 in wirelessGatewayListContainer {
                if let structure0 = structure0 {
                    wirelessGatewayListDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayList = wirelessGatewayListDecoded0
    }
}

extension IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayEuiEventTopic = "GatewayEuiEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayEuiEventTopic = self.gatewayEuiEventTopic {
            try encodeContainer.encode(gatewayEuiEventTopic.rawValue, forKey: .gatewayEuiEventTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayEuiEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .gatewayEuiEventTopic)
        gatewayEuiEventTopic = gatewayEuiEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Object for LoRaWAN connection status resource type event configuration.
    public struct LoRaWANConnectionStatusEventNotificationConfigurations: Swift.Equatable {
        /// Denotes whether the gateway EUI connection status event topic is enabled or disabled.
        public var gatewayEuiEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init (
            gatewayEuiEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.gatewayEuiEventTopic = gatewayEuiEventTopic
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessGatewayEventTopic = "WirelessGatewayEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessGatewayEventTopic = self.wirelessGatewayEventTopic {
            try encodeContainer.encode(wirelessGatewayEventTopic.rawValue, forKey: .wirelessGatewayEventTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessGatewayEventTopic)
        wirelessGatewayEventTopic = wirelessGatewayEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Object for LoRaWAN connection status resource type event configuration.
    public struct LoRaWANConnectionStatusResourceTypeEventConfiguration: Swift.Equatable {
        /// Denotes whether the wireless gateway connection status event topic is enabled or disabled.
        public var wirelessGatewayEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init (
            wirelessGatewayEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.wirelessGatewayEventTopic = wirelessGatewayEventTopic
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abpV1_0_x = "AbpV1_0_x"
        case abpV1_1 = "AbpV1_1"
        case devEui = "DevEui"
        case deviceProfileId = "DeviceProfileId"
        case fPorts = "FPorts"
        case otaaV1_0_x = "OtaaV1_0_x"
        case otaaV1_1 = "OtaaV1_1"
        case serviceProfileId = "ServiceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abpV1_0_x = self.abpV1_0_x {
            try encodeContainer.encode(abpV1_0_x, forKey: .abpV1_0_x)
        }
        if let abpV1_1 = self.abpV1_1 {
            try encodeContainer.encode(abpV1_1, forKey: .abpV1_1)
        }
        if let devEui = self.devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
        if let deviceProfileId = self.deviceProfileId {
            try encodeContainer.encode(deviceProfileId, forKey: .deviceProfileId)
        }
        if let fPorts = self.fPorts {
            try encodeContainer.encode(fPorts, forKey: .fPorts)
        }
        if let otaaV1_0_x = self.otaaV1_0_x {
            try encodeContainer.encode(otaaV1_0_x, forKey: .otaaV1_0_x)
        }
        if let otaaV1_1 = self.otaaV1_1 {
            try encodeContainer.encode(otaaV1_1, forKey: .otaaV1_1)
        }
        if let serviceProfileId = self.serviceProfileId {
            try encodeContainer.encode(serviceProfileId, forKey: .serviceProfileId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devEui)
        devEui = devEuiDecoded
        let deviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceProfileId)
        deviceProfileId = deviceProfileIdDecoded
        let serviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProfileId)
        serviceProfileId = serviceProfileIdDecoded
        let otaaV1_1Decoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.OtaaV1_1.self, forKey: .otaaV1_1)
        otaaV1_1 = otaaV1_1Decoded
        let otaaV1_0_xDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.OtaaV1_0_x.self, forKey: .otaaV1_0_x)
        otaaV1_0_x = otaaV1_0_xDecoded
        let abpV1_1Decoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.AbpV1_1.self, forKey: .abpV1_1)
        abpV1_1 = abpV1_1Decoded
        let abpV1_0_xDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.AbpV1_0_x.self, forKey: .abpV1_0_x)
        abpV1_0_x = abpV1_0_xDecoded
        let fPortsDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.FPorts.self, forKey: .fPorts)
        fPorts = fPortsDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWAN object for create functions.
    public struct LoRaWANDevice: Swift.Equatable {
        /// LoRaWAN object for create APIs
        public var abpV1_0_x: IoTWirelessClientTypes.AbpV1_0_x?
        /// ABP device object for create APIs for v1.1
        public var abpV1_1: IoTWirelessClientTypes.AbpV1_1?
        /// The DevEUI value.
        public var devEui: Swift.String?
        /// The ID of the device profile for the new wireless device.
        public var deviceProfileId: Swift.String?
        /// List of FPort assigned for different LoRaWAN application packages to use
        public var fPorts: IoTWirelessClientTypes.FPorts?
        /// OTAA device object for create APIs for v1.0.x
        public var otaaV1_0_x: IoTWirelessClientTypes.OtaaV1_0_x?
        /// OTAA device object for v1.1 for create APIs
        public var otaaV1_1: IoTWirelessClientTypes.OtaaV1_1?
        /// The ID of the service profile.
        public var serviceProfileId: Swift.String?

        public init (
            abpV1_0_x: IoTWirelessClientTypes.AbpV1_0_x? = nil,
            abpV1_1: IoTWirelessClientTypes.AbpV1_1? = nil,
            devEui: Swift.String? = nil,
            deviceProfileId: Swift.String? = nil,
            fPorts: IoTWirelessClientTypes.FPorts? = nil,
            otaaV1_0_x: IoTWirelessClientTypes.OtaaV1_0_x? = nil,
            otaaV1_1: IoTWirelessClientTypes.OtaaV1_1? = nil,
            serviceProfileId: Swift.String? = nil
        )
        {
            self.abpV1_0_x = abpV1_0_x
            self.abpV1_1 = abpV1_1
            self.devEui = devEui
            self.deviceProfileId = deviceProfileId
            self.fPorts = fPorts
            self.otaaV1_0_x = otaaV1_0_x
            self.otaaV1_1 = otaaV1_1
            self.serviceProfileId = serviceProfileId
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANDeviceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRate = "DataRate"
        case devEui = "DevEui"
        case fPort = "FPort"
        case frequency = "Frequency"
        case gateways = "Gateways"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRate = self.dataRate {
            try encodeContainer.encode(dataRate, forKey: .dataRate)
        }
        if let devEui = self.devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
        if let fPort = self.fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
        if let gateways = gateways {
            var gatewaysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gateways)
            for lorawangatewaymetadata0 in gateways {
                try gatewaysContainer.encode(lorawangatewaymetadata0)
            }
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devEui)
        devEui = devEuiDecoded
        let fPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fPort)
        fPort = fPortDecoded
        let dataRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRate)
        dataRate = dataRateDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .frequency)
        frequency = frequencyDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let gatewaysContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.LoRaWANGatewayMetadata?].self, forKey: .gateways)
        var gatewaysDecoded0:[IoTWirelessClientTypes.LoRaWANGatewayMetadata]? = nil
        if let gatewaysContainer = gatewaysContainer {
            gatewaysDecoded0 = [IoTWirelessClientTypes.LoRaWANGatewayMetadata]()
            for structure0 in gatewaysContainer {
                if let structure0 = structure0 {
                    gatewaysDecoded0?.append(structure0)
                }
            }
        }
        gateways = gatewaysDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWAN device metatdata.
    public struct LoRaWANDeviceMetadata: Swift.Equatable {
        /// The DataRate value.
        public var dataRate: Swift.Int?
        /// The DevEUI value.
        public var devEui: Swift.String?
        /// The FPort value.
        public var fPort: Swift.Int?
        /// The device's channel frequency in Hz.
        public var frequency: Swift.Int?
        /// Information about the gateways accessed by the device.
        public var gateways: [IoTWirelessClientTypes.LoRaWANGatewayMetadata]?
        /// The date and time of the metadata.
        public var timestamp: Swift.String?

        public init (
            dataRate: Swift.Int? = nil,
            devEui: Swift.String? = nil,
            fPort: Swift.Int? = nil,
            frequency: Swift.Int? = nil,
            gateways: [IoTWirelessClientTypes.LoRaWANGatewayMetadata]? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.dataRate = dataRate
            self.devEui = devEui
            self.fPort = fPort
            self.frequency = frequency
            self.gateways = gateways
            self.timestamp = timestamp
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANDeviceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classBTimeout = "ClassBTimeout"
        case classCTimeout = "ClassCTimeout"
        case factoryPresetFreqsList = "FactoryPresetFreqsList"
        case macVersion = "MacVersion"
        case maxDutyCycle = "MaxDutyCycle"
        case maxEirp = "MaxEirp"
        case pingSlotDr = "PingSlotDr"
        case pingSlotFreq = "PingSlotFreq"
        case pingSlotPeriod = "PingSlotPeriod"
        case regParamsRevision = "RegParamsRevision"
        case rfRegion = "RfRegion"
        case rxDataRate2 = "RxDataRate2"
        case rxDelay1 = "RxDelay1"
        case rxDrOffset1 = "RxDrOffset1"
        case rxFreq2 = "RxFreq2"
        case supports32BitFCnt = "Supports32BitFCnt"
        case supportsClassB = "SupportsClassB"
        case supportsClassC = "SupportsClassC"
        case supportsJoin = "SupportsJoin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classBTimeout = self.classBTimeout {
            try encodeContainer.encode(classBTimeout, forKey: .classBTimeout)
        }
        if let classCTimeout = self.classCTimeout {
            try encodeContainer.encode(classCTimeout, forKey: .classCTimeout)
        }
        if let factoryPresetFreqsList = factoryPresetFreqsList {
            var factoryPresetFreqsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .factoryPresetFreqsList)
            for presetfreq0 in factoryPresetFreqsList {
                try factoryPresetFreqsListContainer.encode(presetfreq0)
            }
        }
        if let macVersion = self.macVersion {
            try encodeContainer.encode(macVersion, forKey: .macVersion)
        }
        if let maxDutyCycle = self.maxDutyCycle {
            try encodeContainer.encode(maxDutyCycle, forKey: .maxDutyCycle)
        }
        if let maxEirp = self.maxEirp {
            try encodeContainer.encode(maxEirp, forKey: .maxEirp)
        }
        if let pingSlotDr = self.pingSlotDr {
            try encodeContainer.encode(pingSlotDr, forKey: .pingSlotDr)
        }
        if let pingSlotFreq = self.pingSlotFreq {
            try encodeContainer.encode(pingSlotFreq, forKey: .pingSlotFreq)
        }
        if let pingSlotPeriod = self.pingSlotPeriod {
            try encodeContainer.encode(pingSlotPeriod, forKey: .pingSlotPeriod)
        }
        if let regParamsRevision = self.regParamsRevision {
            try encodeContainer.encode(regParamsRevision, forKey: .regParamsRevision)
        }
        if let rfRegion = self.rfRegion {
            try encodeContainer.encode(rfRegion, forKey: .rfRegion)
        }
        if let rxDataRate2 = self.rxDataRate2 {
            try encodeContainer.encode(rxDataRate2, forKey: .rxDataRate2)
        }
        if let rxDelay1 = self.rxDelay1 {
            try encodeContainer.encode(rxDelay1, forKey: .rxDelay1)
        }
        if let rxDrOffset1 = self.rxDrOffset1 {
            try encodeContainer.encode(rxDrOffset1, forKey: .rxDrOffset1)
        }
        if let rxFreq2 = self.rxFreq2 {
            try encodeContainer.encode(rxFreq2, forKey: .rxFreq2)
        }
        if supports32BitFCnt != false {
            try encodeContainer.encode(supports32BitFCnt, forKey: .supports32BitFCnt)
        }
        if supportsClassB != false {
            try encodeContainer.encode(supportsClassB, forKey: .supportsClassB)
        }
        if supportsClassC != false {
            try encodeContainer.encode(supportsClassC, forKey: .supportsClassC)
        }
        if let supportsJoin = self.supportsJoin {
            try encodeContainer.encode(supportsJoin, forKey: .supportsJoin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportsClassBDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsClassB) ?? false
        supportsClassB = supportsClassBDecoded
        let classBTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classBTimeout)
        classBTimeout = classBTimeoutDecoded
        let pingSlotPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pingSlotPeriod)
        pingSlotPeriod = pingSlotPeriodDecoded
        let pingSlotDrDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pingSlotDr)
        pingSlotDr = pingSlotDrDecoded
        let pingSlotFreqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pingSlotFreq)
        pingSlotFreq = pingSlotFreqDecoded
        let supportsClassCDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsClassC) ?? false
        supportsClassC = supportsClassCDecoded
        let classCTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classCTimeout)
        classCTimeout = classCTimeoutDecoded
        let macVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macVersion)
        macVersion = macVersionDecoded
        let regParamsRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regParamsRevision)
        regParamsRevision = regParamsRevisionDecoded
        let rxDelay1Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxDelay1)
        rxDelay1 = rxDelay1Decoded
        let rxDrOffset1Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxDrOffset1)
        rxDrOffset1 = rxDrOffset1Decoded
        let rxDataRate2Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxDataRate2)
        rxDataRate2 = rxDataRate2Decoded
        let rxFreq2Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxFreq2)
        rxFreq2 = rxFreq2Decoded
        let factoryPresetFreqsListContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .factoryPresetFreqsList)
        var factoryPresetFreqsListDecoded0:[Swift.Int]? = nil
        if let factoryPresetFreqsListContainer = factoryPresetFreqsListContainer {
            factoryPresetFreqsListDecoded0 = [Swift.Int]()
            for integer0 in factoryPresetFreqsListContainer {
                if let integer0 = integer0 {
                    factoryPresetFreqsListDecoded0?.append(integer0)
                }
            }
        }
        factoryPresetFreqsList = factoryPresetFreqsListDecoded0
        let maxEirpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxEirp)
        maxEirp = maxEirpDecoded
        let maxDutyCycleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDutyCycle)
        maxDutyCycle = maxDutyCycleDecoded
        let rfRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let supportsJoinDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsJoin)
        supportsJoin = supportsJoinDecoded
        let supports32BitFCntDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supports32BitFCnt) ?? false
        supports32BitFCnt = supports32BitFCntDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANDeviceProfile object.
    public struct LoRaWANDeviceProfile: Swift.Equatable {
        /// The ClassBTimeout value.
        public var classBTimeout: Swift.Int?
        /// The ClassCTimeout value.
        public var classCTimeout: Swift.Int?
        /// The list of values that make up the FactoryPresetFreqs value.
        public var factoryPresetFreqsList: [Swift.Int]?
        /// The MAC version (such as OTAA 1.1 or OTAA 1.0.3) to use with this device profile.
        public var macVersion: Swift.String?
        /// The MaxDutyCycle value.
        public var maxDutyCycle: Swift.Int?
        /// The MaxEIRP value.
        public var maxEirp: Swift.Int?
        /// The PingSlotDR value.
        public var pingSlotDr: Swift.Int?
        /// The PingSlotFreq value.
        public var pingSlotFreq: Swift.Int?
        /// The PingSlotPeriod value.
        public var pingSlotPeriod: Swift.Int?
        /// The version of regional parameters.
        public var regParamsRevision: Swift.String?
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// The RXDataRate2 value.
        public var rxDataRate2: Swift.Int?
        /// The RXDelay1 value.
        public var rxDelay1: Swift.Int?
        /// The RXDROffset1 value.
        public var rxDrOffset1: Swift.Int?
        /// The RXFreq2 value.
        public var rxFreq2: Swift.Int?
        /// The Supports32BitFCnt value.
        public var supports32BitFCnt: Swift.Bool
        /// The SupportsClassB value.
        public var supportsClassB: Swift.Bool
        /// The SupportsClassC value.
        public var supportsClassC: Swift.Bool
        /// The SupportsJoin value.
        public var supportsJoin: Swift.Bool?

        public init (
            classBTimeout: Swift.Int? = nil,
            classCTimeout: Swift.Int? = nil,
            factoryPresetFreqsList: [Swift.Int]? = nil,
            macVersion: Swift.String? = nil,
            maxDutyCycle: Swift.Int? = nil,
            maxEirp: Swift.Int? = nil,
            pingSlotDr: Swift.Int? = nil,
            pingSlotFreq: Swift.Int? = nil,
            pingSlotPeriod: Swift.Int? = nil,
            regParamsRevision: Swift.String? = nil,
            rfRegion: Swift.String? = nil,
            rxDataRate2: Swift.Int? = nil,
            rxDelay1: Swift.Int? = nil,
            rxDrOffset1: Swift.Int? = nil,
            rxFreq2: Swift.Int? = nil,
            supports32BitFCnt: Swift.Bool = false,
            supportsClassB: Swift.Bool = false,
            supportsClassC: Swift.Bool = false,
            supportsJoin: Swift.Bool? = nil
        )
        {
            self.classBTimeout = classBTimeout
            self.classCTimeout = classCTimeout
            self.factoryPresetFreqsList = factoryPresetFreqsList
            self.macVersion = macVersion
            self.maxDutyCycle = maxDutyCycle
            self.maxEirp = maxEirp
            self.pingSlotDr = pingSlotDr
            self.pingSlotFreq = pingSlotFreq
            self.pingSlotPeriod = pingSlotPeriod
            self.regParamsRevision = regParamsRevision
            self.rfRegion = rfRegion
            self.rxDataRate2 = rxDataRate2
            self.rxDelay1 = rxDelay1
            self.rxDrOffset1 = rxDrOffset1
            self.rxFreq2 = rxFreq2
            self.supports32BitFCnt = supports32BitFCnt
            self.supportsClassB = supportsClassB
            self.supportsClassC = supportsClassC
            self.supportsJoin = supportsJoin
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANFuotaTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rfRegion = "RfRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rfRegion = self.rfRegion {
            try encodeContainer.encode(rfRegion.rawValue, forKey: .rfRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rfRegionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SupportedRfRegion.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The LoRaWAN information used with a FUOTA task.
    public struct LoRaWANFuotaTask: Swift.Equatable {
        /// Supported RfRegions
        public var rfRegion: IoTWirelessClientTypes.SupportedRfRegion?

        public init (
            rfRegion: IoTWirelessClientTypes.SupportedRfRegion? = nil
        )
        {
            self.rfRegion = rfRegion
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rfRegion = "RfRegion"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rfRegion = self.rfRegion {
            try encodeContainer.encode(rfRegion, forKey: .rfRegion)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rfRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The LoRaWAN information returned from getting a FUOTA task.
    public struct LoRaWANFuotaTaskGetInfo: Swift.Equatable {
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// Start time of a FUOTA task.
        public var startTime: ClientRuntime.Date?

        public init (
            rfRegion: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.rfRegion = rfRegion
            self.startTime = startTime
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANGateway: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beaconing = "Beaconing"
        case gatewayEui = "GatewayEui"
        case joinEuiFilters = "JoinEuiFilters"
        case netIdFilters = "NetIdFilters"
        case rfRegion = "RfRegion"
        case subBands = "SubBands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beaconing = self.beaconing {
            try encodeContainer.encode(beaconing, forKey: .beaconing)
        }
        if let gatewayEui = self.gatewayEui {
            try encodeContainer.encode(gatewayEui, forKey: .gatewayEui)
        }
        if let joinEuiFilters = joinEuiFilters {
            var joinEuiFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .joinEuiFilters)
            for joineuirange0 in joinEuiFilters {
                var joineuirange0Container = joinEuiFiltersContainer.nestedUnkeyedContainer()
                for joineui1 in joineuirange0 {
                    try joineuirange0Container.encode(joineui1)
                }
            }
        }
        if let netIdFilters = netIdFilters {
            var netIdFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .netIdFilters)
            for netid0 in netIdFilters {
                try netIdFiltersContainer.encode(netid0)
            }
        }
        if let rfRegion = self.rfRegion {
            try encodeContainer.encode(rfRegion, forKey: .rfRegion)
        }
        if let subBands = subBands {
            var subBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subBands)
            for subband0 in subBands {
                try subBandsContainer.encode(subband0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayEui)
        gatewayEui = gatewayEuiDecoded
        let rfRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let joinEuiFiltersContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .joinEuiFilters)
        var joinEuiFiltersDecoded0:[[Swift.String]]? = nil
        if let joinEuiFiltersContainer = joinEuiFiltersContainer {
            joinEuiFiltersDecoded0 = [[Swift.String]]()
            for list0 in joinEuiFiltersContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    joinEuiFiltersDecoded0?.append(list0Decoded0)
                }
            }
        }
        joinEuiFilters = joinEuiFiltersDecoded0
        let netIdFiltersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .netIdFilters)
        var netIdFiltersDecoded0:[Swift.String]? = nil
        if let netIdFiltersContainer = netIdFiltersContainer {
            netIdFiltersDecoded0 = [Swift.String]()
            for string0 in netIdFiltersContainer {
                if let string0 = string0 {
                    netIdFiltersDecoded0?.append(string0)
                }
            }
        }
        netIdFilters = netIdFiltersDecoded0
        let subBandsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .subBands)
        var subBandsDecoded0:[Swift.Int]? = nil
        if let subBandsContainer = subBandsContainer {
            subBandsDecoded0 = [Swift.Int]()
            for integer0 in subBandsContainer {
                if let integer0 = integer0 {
                    subBandsDecoded0?.append(integer0)
                }
            }
        }
        subBands = subBandsDecoded0
        let beaconingDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.Beaconing.self, forKey: .beaconing)
        beaconing = beaconingDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANGateway object.
    public struct LoRaWANGateway: Swift.Equatable {
        /// Beaconing object information, which consists of the data rate and frequency parameters.
        public var beaconing: IoTWirelessClientTypes.Beaconing?
        /// The gateway's EUI value.
        public var gatewayEui: Swift.String?
        /// A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.
        public var joinEuiFilters: [[Swift.String]]?
        /// A list of NetId values that are used by LoRa gateways to filter the uplink frames.
        public var netIdFilters: [Swift.String]?
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// A list of integer indicating which sub bands are supported by LoRa gateway.
        public var subBands: [Swift.Int]?

        public init (
            beaconing: IoTWirelessClientTypes.Beaconing? = nil,
            gatewayEui: Swift.String? = nil,
            joinEuiFilters: [[Swift.String]]? = nil,
            netIdFilters: [Swift.String]? = nil,
            rfRegion: Swift.String? = nil,
            subBands: [Swift.Int]? = nil
        )
        {
            self.beaconing = beaconing
            self.gatewayEui = gatewayEui
            self.joinEuiFilters = joinEuiFilters
            self.netIdFilters = netIdFilters
            self.rfRegion = rfRegion
            self.subBands = subBands
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANGatewayCurrentVersion object.
    public struct LoRaWANGatewayCurrentVersion: Swift.Equatable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?

        public init (
            currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANGatewayMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayEui = "GatewayEui"
        case rssi = "Rssi"
        case snr = "Snr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayEui = self.gatewayEui {
            try encodeContainer.encode(gatewayEui, forKey: .gatewayEui)
        }
        if let rssi = self.rssi {
            try encodeContainer.encode(rssi, forKey: .rssi)
        }
        if let snr = self.snr {
            try encodeContainer.encode(snr, forKey: .snr)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayEui)
        gatewayEui = gatewayEuiDecoded
        let snrDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .snr)
        snr = snrDecoded
        let rssiDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .rssi)
        rssi = rssiDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWAN gateway metatdata.
    public struct LoRaWANGatewayMetadata: Swift.Equatable {
        /// The gateway's EUI value.
        public var gatewayEui: Swift.String?
        /// The RSSI value.
        public var rssi: Swift.Double?
        /// The SNR value.
        public var snr: Swift.Double?

        public init (
            gatewayEui: Swift.String? = nil,
            rssi: Swift.Double? = nil,
            snr: Swift.Double? = nil
        )
        {
            self.gatewayEui = gatewayEui
            self.rssi = rssi
            self.snr = snr
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANGatewayVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case model = "Model"
        case packageVersion = "PackageVersion"
        case station = "Station"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
        if let station = self.station {
            try encodeContainer.encode(station, forKey: .station)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let stationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .station)
        station = stationDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANGatewayVersion object.
    public struct LoRaWANGatewayVersion: Swift.Equatable {
        /// The model number of the wireless gateway.
        public var model: Swift.String?
        /// The version of the wireless gateway firmware.
        public var packageVersion: Swift.String?
        /// The basic station version of the wireless gateway.
        public var station: Swift.String?

        public init (
            model: Swift.String? = nil,
            packageVersion: Swift.String? = nil,
            station: Swift.String? = nil
        )
        {
            self.model = model
            self.packageVersion = packageVersion
            self.station = station
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addGwMetadata = "AddGwMetadata"
        case channelMask = "ChannelMask"
        case devStatusReqFreq = "DevStatusReqFreq"
        case dlBucketSize = "DlBucketSize"
        case dlRate = "DlRate"
        case dlRatePolicy = "DlRatePolicy"
        case drMax = "DrMax"
        case drMin = "DrMin"
        case hrAllowed = "HrAllowed"
        case minGwDiversity = "MinGwDiversity"
        case nwkGeoLoc = "NwkGeoLoc"
        case prAllowed = "PrAllowed"
        case raAllowed = "RaAllowed"
        case reportDevStatusBattery = "ReportDevStatusBattery"
        case reportDevStatusMargin = "ReportDevStatusMargin"
        case targetPer = "TargetPer"
        case ulBucketSize = "UlBucketSize"
        case ulRate = "UlRate"
        case ulRatePolicy = "UlRatePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if addGwMetadata != false {
            try encodeContainer.encode(addGwMetadata, forKey: .addGwMetadata)
        }
        if let channelMask = self.channelMask {
            try encodeContainer.encode(channelMask, forKey: .channelMask)
        }
        if let devStatusReqFreq = self.devStatusReqFreq {
            try encodeContainer.encode(devStatusReqFreq, forKey: .devStatusReqFreq)
        }
        if let dlBucketSize = self.dlBucketSize {
            try encodeContainer.encode(dlBucketSize, forKey: .dlBucketSize)
        }
        if let dlRate = self.dlRate {
            try encodeContainer.encode(dlRate, forKey: .dlRate)
        }
        if let dlRatePolicy = self.dlRatePolicy {
            try encodeContainer.encode(dlRatePolicy, forKey: .dlRatePolicy)
        }
        if drMax != 0 {
            try encodeContainer.encode(drMax, forKey: .drMax)
        }
        if drMin != 0 {
            try encodeContainer.encode(drMin, forKey: .drMin)
        }
        if hrAllowed != false {
            try encodeContainer.encode(hrAllowed, forKey: .hrAllowed)
        }
        if let minGwDiversity = self.minGwDiversity {
            try encodeContainer.encode(minGwDiversity, forKey: .minGwDiversity)
        }
        if nwkGeoLoc != false {
            try encodeContainer.encode(nwkGeoLoc, forKey: .nwkGeoLoc)
        }
        if prAllowed != false {
            try encodeContainer.encode(prAllowed, forKey: .prAllowed)
        }
        if raAllowed != false {
            try encodeContainer.encode(raAllowed, forKey: .raAllowed)
        }
        if reportDevStatusBattery != false {
            try encodeContainer.encode(reportDevStatusBattery, forKey: .reportDevStatusBattery)
        }
        if reportDevStatusMargin != false {
            try encodeContainer.encode(reportDevStatusMargin, forKey: .reportDevStatusMargin)
        }
        if targetPer != 0 {
            try encodeContainer.encode(targetPer, forKey: .targetPer)
        }
        if let ulBucketSize = self.ulBucketSize {
            try encodeContainer.encode(ulBucketSize, forKey: .ulBucketSize)
        }
        if let ulRate = self.ulRate {
            try encodeContainer.encode(ulRate, forKey: .ulRate)
        }
        if let ulRatePolicy = self.ulRatePolicy {
            try encodeContainer.encode(ulRatePolicy, forKey: .ulRatePolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ulRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ulRate)
        ulRate = ulRateDecoded
        let ulBucketSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ulBucketSize)
        ulBucketSize = ulBucketSizeDecoded
        let ulRatePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ulRatePolicy)
        ulRatePolicy = ulRatePolicyDecoded
        let dlRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dlRate)
        dlRate = dlRateDecoded
        let dlBucketSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dlBucketSize)
        dlBucketSize = dlBucketSizeDecoded
        let dlRatePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dlRatePolicy)
        dlRatePolicy = dlRatePolicyDecoded
        let addGwMetadataDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addGwMetadata) ?? false
        addGwMetadata = addGwMetadataDecoded
        let devStatusReqFreqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .devStatusReqFreq)
        devStatusReqFreq = devStatusReqFreqDecoded
        let reportDevStatusBatteryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .reportDevStatusBattery) ?? false
        reportDevStatusBattery = reportDevStatusBatteryDecoded
        let reportDevStatusMarginDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .reportDevStatusMargin) ?? false
        reportDevStatusMargin = reportDevStatusMarginDecoded
        let drMinDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .drMin) ?? 0
        drMin = drMinDecoded
        let drMaxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .drMax) ?? 0
        drMax = drMaxDecoded
        let channelMaskDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelMask)
        channelMask = channelMaskDecoded
        let prAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .prAllowed) ?? false
        prAllowed = prAllowedDecoded
        let hrAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hrAllowed) ?? false
        hrAllowed = hrAllowedDecoded
        let raAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .raAllowed) ?? false
        raAllowed = raAllowedDecoded
        let nwkGeoLocDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .nwkGeoLoc) ?? false
        nwkGeoLoc = nwkGeoLocDecoded
        let targetPerDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetPer) ?? 0
        targetPer = targetPerDecoded
        let minGwDiversityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minGwDiversity)
        minGwDiversity = minGwDiversityDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANGetServiceProfileInfo object.
    public struct LoRaWANGetServiceProfileInfo: Swift.Equatable {
        /// The AddGWMetaData value.
        public var addGwMetadata: Swift.Bool
        /// The ChannelMask value.
        public var channelMask: Swift.String?
        /// The DevStatusReqFreq value.
        public var devStatusReqFreq: Swift.Int?
        /// The DLBucketSize value.
        public var dlBucketSize: Swift.Int?
        /// The DLRate value.
        public var dlRate: Swift.Int?
        /// The DLRatePolicy value.
        public var dlRatePolicy: Swift.String?
        /// The DRMax value.
        public var drMax: Swift.Int
        /// The DRMin value.
        public var drMin: Swift.Int
        /// The HRAllowed value that describes whether handover roaming is allowed.
        public var hrAllowed: Swift.Bool
        /// The MinGwDiversity value.
        public var minGwDiversity: Swift.Int?
        /// The NwkGeoLoc value.
        public var nwkGeoLoc: Swift.Bool
        /// The PRAllowed value that describes whether passive roaming is allowed.
        public var prAllowed: Swift.Bool
        /// The RAAllowed value that describes whether roaming activation is allowed.
        public var raAllowed: Swift.Bool
        /// The ReportDevStatusBattery value.
        public var reportDevStatusBattery: Swift.Bool
        /// The ReportDevStatusMargin value.
        public var reportDevStatusMargin: Swift.Bool
        /// The TargetPER value.
        public var targetPer: Swift.Int
        /// The ULBucketSize value.
        public var ulBucketSize: Swift.Int?
        /// The ULRate value.
        public var ulRate: Swift.Int?
        /// The ULRatePolicy value.
        public var ulRatePolicy: Swift.String?

        public init (
            addGwMetadata: Swift.Bool = false,
            channelMask: Swift.String? = nil,
            devStatusReqFreq: Swift.Int? = nil,
            dlBucketSize: Swift.Int? = nil,
            dlRate: Swift.Int? = nil,
            dlRatePolicy: Swift.String? = nil,
            drMax: Swift.Int = 0,
            drMin: Swift.Int = 0,
            hrAllowed: Swift.Bool = false,
            minGwDiversity: Swift.Int? = nil,
            nwkGeoLoc: Swift.Bool = false,
            prAllowed: Swift.Bool = false,
            raAllowed: Swift.Bool = false,
            reportDevStatusBattery: Swift.Bool = false,
            reportDevStatusMargin: Swift.Bool = false,
            targetPer: Swift.Int = 0,
            ulBucketSize: Swift.Int? = nil,
            ulRate: Swift.Int? = nil,
            ulRatePolicy: Swift.String? = nil
        )
        {
            self.addGwMetadata = addGwMetadata
            self.channelMask = channelMask
            self.devStatusReqFreq = devStatusReqFreq
            self.dlBucketSize = dlBucketSize
            self.dlRate = dlRate
            self.dlRatePolicy = dlRatePolicy
            self.drMax = drMax
            self.drMin = drMin
            self.hrAllowed = hrAllowed
            self.minGwDiversity = minGwDiversity
            self.nwkGeoLoc = nwkGeoLoc
            self.prAllowed = prAllowed
            self.raAllowed = raAllowed
            self.reportDevStatusBattery = reportDevStatusBattery
            self.reportDevStatusMargin = reportDevStatusMargin
            self.targetPer = targetPer
            self.ulBucketSize = ulBucketSize
            self.ulRate = ulRate
            self.ulRatePolicy = ulRatePolicy
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devEuiEventTopic = "DevEuiEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devEuiEventTopic = self.devEuiEventTopic {
            try encodeContainer.encode(devEuiEventTopic.rawValue, forKey: .devEuiEventTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .devEuiEventTopic)
        devEuiEventTopic = devEuiEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Object for LoRaWAN join resource type event configuration.
    public struct LoRaWANJoinEventNotificationConfigurations: Swift.Equatable {
        /// Denotes whether the Dev EUI join event topic is enabled or disabled.
        public var devEuiEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init (
            devEuiEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.devEuiEventTopic = devEuiEventTopic
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceEventTopic = "WirelessDeviceEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessDeviceEventTopic = self.wirelessDeviceEventTopic {
            try encodeContainer.encode(wirelessDeviceEventTopic.rawValue, forKey: .wirelessDeviceEventTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessDeviceEventTopic)
        wirelessDeviceEventTopic = wirelessDeviceEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Object for LoRaWAN join resource type event configuration.
    public struct LoRaWANJoinResourceTypeEventConfiguration: Swift.Equatable {
        /// Denotes whether the wireless device join event topic is enabled or disabled.
        public var wirelessDeviceEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init (
            wirelessDeviceEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.wirelessDeviceEventTopic = wirelessDeviceEventTopic
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANListDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devEui = "DevEui"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devEui = self.devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devEui)
        devEui = devEuiDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWAN object for list functions.
    public struct LoRaWANListDevice: Swift.Equatable {
        /// The DevEUI value.
        public var devEui: Swift.String?

        public init (
            devEui: Swift.String? = nil
        )
        {
            self.devEui = devEui
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANMulticast: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dlClass = "DlClass"
        case rfRegion = "RfRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dlClass = self.dlClass {
            try encodeContainer.encode(dlClass.rawValue, forKey: .dlClass)
        }
        if let rfRegion = self.rfRegion {
            try encodeContainer.encode(rfRegion.rawValue, forKey: .rfRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rfRegionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SupportedRfRegion.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let dlClassDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DlClass.self, forKey: .dlClass)
        dlClass = dlClassDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The LoRaWAN information that is to be used with the multicast group.
    public struct LoRaWANMulticast: Swift.Equatable {
        /// DlClass for LoRaWAM, valid values are ClassB and ClassC.
        public var dlClass: IoTWirelessClientTypes.DlClass?
        /// Supported RfRegions
        public var rfRegion: IoTWirelessClientTypes.SupportedRfRegion?

        public init (
            dlClass: IoTWirelessClientTypes.DlClass? = nil,
            rfRegion: IoTWirelessClientTypes.SupportedRfRegion? = nil
        )
        {
            self.dlClass = dlClass
            self.rfRegion = rfRegion
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANMulticastGet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dlClass = "DlClass"
        case numberOfDevicesInGroup = "NumberOfDevicesInGroup"
        case numberOfDevicesRequested = "NumberOfDevicesRequested"
        case rfRegion = "RfRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dlClass = self.dlClass {
            try encodeContainer.encode(dlClass.rawValue, forKey: .dlClass)
        }
        if let numberOfDevicesInGroup = self.numberOfDevicesInGroup {
            try encodeContainer.encode(numberOfDevicesInGroup, forKey: .numberOfDevicesInGroup)
        }
        if let numberOfDevicesRequested = self.numberOfDevicesRequested {
            try encodeContainer.encode(numberOfDevicesRequested, forKey: .numberOfDevicesRequested)
        }
        if let rfRegion = self.rfRegion {
            try encodeContainer.encode(rfRegion.rawValue, forKey: .rfRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rfRegionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SupportedRfRegion.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let dlClassDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DlClass.self, forKey: .dlClass)
        dlClass = dlClassDecoded
        let numberOfDevicesRequestedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDevicesRequested)
        numberOfDevicesRequested = numberOfDevicesRequestedDecoded
        let numberOfDevicesInGroupDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDevicesInGroup)
        numberOfDevicesInGroup = numberOfDevicesInGroupDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The LoRaWAN information that is to be returned from getting multicast group information.
    public struct LoRaWANMulticastGet: Swift.Equatable {
        /// DlClass for LoRaWAM, valid values are ClassB and ClassC.
        public var dlClass: IoTWirelessClientTypes.DlClass?
        /// Number of devices that are associated to the multicast group.
        public var numberOfDevicesInGroup: Swift.Int?
        /// Number of devices that are requested to be associated with the multicast group.
        public var numberOfDevicesRequested: Swift.Int?
        /// Supported RfRegions
        public var rfRegion: IoTWirelessClientTypes.SupportedRfRegion?

        public init (
            dlClass: IoTWirelessClientTypes.DlClass? = nil,
            numberOfDevicesInGroup: Swift.Int? = nil,
            numberOfDevicesRequested: Swift.Int? = nil,
            rfRegion: IoTWirelessClientTypes.SupportedRfRegion? = nil
        )
        {
            self.dlClass = dlClass
            self.numberOfDevicesInGroup = numberOfDevicesInGroup
            self.numberOfDevicesRequested = numberOfDevicesRequested
            self.rfRegion = rfRegion
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANMulticastMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fPort = "FPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fPort = self.fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fPort)
        fPort = fPortDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The metadata information of the LoRaWAN multicast group.
    public struct LoRaWANMulticastMetadata: Swift.Equatable {
        /// The Fport value.
        public var fPort: Swift.Int?

        public init (
            fPort: Swift.Int? = nil
        )
        {
            self.fPort = fPort
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANMulticastSession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dlDr = "DlDr"
        case dlFreq = "DlFreq"
        case sessionStartTime = "SessionStartTime"
        case sessionTimeout = "SessionTimeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dlDr = self.dlDr {
            try encodeContainer.encode(dlDr, forKey: .dlDr)
        }
        if let dlFreq = self.dlFreq {
            try encodeContainer.encode(dlFreq, forKey: .dlFreq)
        }
        if let sessionStartTime = self.sessionStartTime {
            try encodeContainer.encodeTimestamp(sessionStartTime, format: .dateTime, forKey: .sessionStartTime)
        }
        if let sessionTimeout = self.sessionTimeout {
            try encodeContainer.encode(sessionTimeout, forKey: .sessionTimeout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dlDrDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dlDr)
        dlDr = dlDrDecoded
        let dlFreqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dlFreq)
        dlFreq = dlFreqDecoded
        let sessionStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sessionStartTime)
        sessionStartTime = sessionStartTimeDecoded
        let sessionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionTimeout)
        sessionTimeout = sessionTimeoutDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The LoRaWAN information used with the multicast session.
    public struct LoRaWANMulticastSession: Swift.Equatable {
        /// Downlink data rate.
        public var dlDr: Swift.Int?
        /// Downlink frequency.
        public var dlFreq: Swift.Int?
        /// Timestamp of when the multicast group session is to start.
        public var sessionStartTime: ClientRuntime.Date?
        /// How long before a multicast group session is to timeout.
        public var sessionTimeout: Swift.Int?

        public init (
            dlDr: Swift.Int? = nil,
            dlFreq: Swift.Int? = nil,
            sessionStartTime: ClientRuntime.Date? = nil,
            sessionTimeout: Swift.Int? = nil
        )
        {
            self.dlDr = dlDr
            self.dlFreq = dlFreq
            self.sessionStartTime = sessionStartTime
            self.sessionTimeout = sessionTimeout
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANSendDataToDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fPort = "FPort"
        case participatingGateways = "ParticipatingGateways"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fPort = self.fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
        if let participatingGateways = self.participatingGateways {
            try encodeContainer.encode(participatingGateways, forKey: .participatingGateways)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fPort)
        fPort = fPortDecoded
        let participatingGatewaysDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ParticipatingGateways.self, forKey: .participatingGateways)
        participatingGateways = participatingGatewaysDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWAN router info.
    public struct LoRaWANSendDataToDevice: Swift.Equatable {
        /// The Fport value.
        public var fPort: Swift.Int?
        /// Choose the gateways that you want to use for the downlink data traffic when the wireless device is running in class B or class C mode.
        public var participatingGateways: IoTWirelessClientTypes.ParticipatingGateways?

        public init (
            fPort: Swift.Int? = nil,
            participatingGateways: IoTWirelessClientTypes.ParticipatingGateways? = nil
        )
        {
            self.fPort = fPort
            self.participatingGateways = participatingGateways
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANServiceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addGwMetadata = "AddGwMetadata"
        case drMax = "DrMax"
        case drMin = "DrMin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if addGwMetadata != false {
            try encodeContainer.encode(addGwMetadata, forKey: .addGwMetadata)
        }
        if let drMax = self.drMax {
            try encodeContainer.encode(drMax, forKey: .drMax)
        }
        if let drMin = self.drMin {
            try encodeContainer.encode(drMin, forKey: .drMin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addGwMetadataDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addGwMetadata) ?? false
        addGwMetadata = addGwMetadataDecoded
        let drMinDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .drMin)
        drMin = drMinDecoded
        let drMaxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .drMax)
        drMax = drMaxDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANServiceProfile object.
    public struct LoRaWANServiceProfile: Swift.Equatable {
        /// The AddGWMetaData value.
        public var addGwMetadata: Swift.Bool
        /// The DrMax value.
        public var drMax: Swift.Int?
        /// The DrMin value.
        public var drMin: Swift.Int?

        public init (
            addGwMetadata: Swift.Bool = false,
            drMax: Swift.Int? = nil,
            drMin: Swift.Int? = nil
        )
        {
            self.addGwMetadata = addGwMetadata
            self.drMax = drMax
            self.drMin = drMin
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANStartFuotaTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The LoRaWAN information used to start a FUOTA task.
    public struct LoRaWANStartFuotaTask: Swift.Equatable {
        /// Start time of a FUOTA task.
        public var startTime: ClientRuntime.Date?

        public init (
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.startTime = startTime
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANUpdateDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abpV1_0_x = "AbpV1_0_x"
        case abpV1_1 = "AbpV1_1"
        case deviceProfileId = "DeviceProfileId"
        case fPorts = "FPorts"
        case serviceProfileId = "ServiceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abpV1_0_x = self.abpV1_0_x {
            try encodeContainer.encode(abpV1_0_x, forKey: .abpV1_0_x)
        }
        if let abpV1_1 = self.abpV1_1 {
            try encodeContainer.encode(abpV1_1, forKey: .abpV1_1)
        }
        if let deviceProfileId = self.deviceProfileId {
            try encodeContainer.encode(deviceProfileId, forKey: .deviceProfileId)
        }
        if let fPorts = self.fPorts {
            try encodeContainer.encode(fPorts, forKey: .fPorts)
        }
        if let serviceProfileId = self.serviceProfileId {
            try encodeContainer.encode(serviceProfileId, forKey: .serviceProfileId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceProfileId)
        deviceProfileId = deviceProfileIdDecoded
        let serviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProfileId)
        serviceProfileId = serviceProfileIdDecoded
        let abpV1_1Decoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.UpdateAbpV1_1.self, forKey: .abpV1_1)
        abpV1_1 = abpV1_1Decoded
        let abpV1_0_xDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.UpdateAbpV1_0_x.self, forKey: .abpV1_0_x)
        abpV1_0_x = abpV1_0_xDecoded
        let fPortsDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.UpdateFPorts.self, forKey: .fPorts)
        fPorts = fPortsDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWAN object for update functions.
    public struct LoRaWANUpdateDevice: Swift.Equatable {
        /// ABP device object for update APIs for v1.0.x
        public var abpV1_0_x: IoTWirelessClientTypes.UpdateAbpV1_0_x?
        /// ABP device object for update APIs for v1.1
        public var abpV1_1: IoTWirelessClientTypes.UpdateAbpV1_1?
        /// The ID of the device profile for the wireless device.
        public var deviceProfileId: Swift.String?
        /// FPorts object for the positioning information of the device.
        public var fPorts: IoTWirelessClientTypes.UpdateFPorts?
        /// The ID of the service profile.
        public var serviceProfileId: Swift.String?

        public init (
            abpV1_0_x: IoTWirelessClientTypes.UpdateAbpV1_0_x? = nil,
            abpV1_1: IoTWirelessClientTypes.UpdateAbpV1_1? = nil,
            deviceProfileId: Swift.String? = nil,
            fPorts: IoTWirelessClientTypes.UpdateFPorts? = nil,
            serviceProfileId: Swift.String? = nil
        )
        {
            self.abpV1_0_x = abpV1_0_x
            self.abpV1_1 = abpV1_1
            self.deviceProfileId = deviceProfileId
            self.fPorts = fPorts
            self.serviceProfileId = serviceProfileId
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case sigKeyCrc = "SigKeyCrc"
        case updateSignature = "UpdateSignature"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let sigKeyCrc = self.sigKeyCrc {
            try encodeContainer.encode(sigKeyCrc, forKey: .sigKeyCrc)
        }
        if let updateSignature = self.updateSignature {
            try encodeContainer.encode(updateSignature, forKey: .updateSignature)
        }
        if let updateVersion = self.updateVersion {
            try encodeContainer.encode(updateVersion, forKey: .updateVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateSignature)
        updateSignature = updateSignatureDecoded
        let sigKeyCrcDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sigKeyCrc)
        sigKeyCrc = sigKeyCrcDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let updateVersionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .updateVersion)
        updateVersion = updateVersionDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANUpdateGatewayTaskCreate object.
    public struct LoRaWANUpdateGatewayTaskCreate: Swift.Equatable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?
        /// The CRC of the signature private key to check.
        public var sigKeyCrc: Swift.Int?
        /// The signature used to verify the update firmware.
        public var updateSignature: Swift.String?
        /// The firmware version to update the gateway to.
        public var updateVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?

        public init (
            currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil,
            sigKeyCrc: Swift.Int? = nil,
            updateSignature: Swift.String? = nil,
            updateVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
            self.sigKeyCrc = sigKeyCrc
            self.updateSignature = updateSignature
            self.updateVersion = updateVersion
        }
    }

}

extension IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let updateVersion = self.updateVersion {
            try encodeContainer.encode(updateVersion, forKey: .updateVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let updateVersionDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .updateVersion)
        updateVersion = updateVersionDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LoRaWANUpdateGatewayTaskEntry object.
    public struct LoRaWANUpdateGatewayTaskEntry: Swift.Equatable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?
        /// The firmware version to update the gateway to.
        public var updateVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?

        public init (
            currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil,
            updateVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
            self.updateVersion = updateVersion
        }
    }

}

extension IoTWirelessClientTypes {
    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    public enum LogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case error
        case info
        case sdkUnknown(Swift.String)

        public static var allCases: [LogLevel] {
            return [
                .disabled,
                .error,
                .info,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .error: return "ERROR"
            case .info: return "INFO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogLevel(rawValue: rawValue) ?? LogLevel.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.LteLocalId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case earfcn = "Earfcn"
        case pci = "Pci"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let earfcn = self.earfcn {
            try encodeContainer.encode(earfcn, forKey: .earfcn)
        }
        if let pci = self.pci {
            try encodeContainer.encode(pci, forKey: .pci)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pciDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pci)
        pci = pciDecoded
        let earfcnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .earfcn)
        earfcn = earfcnDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LTE local identification (local ID) information.
    public struct LteLocalId: Swift.Equatable {
        /// Evolved universal terrestrial radio access (E-UTRA) absolute radio frequency channel number (FCN).
        /// This member is required.
        public var earfcn: Swift.Int?
        /// Physical cell ID.
        /// This member is required.
        public var pci: Swift.Int?

        public init (
            earfcn: Swift.Int? = nil,
            pci: Swift.Int? = nil
        )
        {
            self.earfcn = earfcn
            self.pci = pci
        }
    }

}

extension IoTWirelessClientTypes.LteNmrObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case earfcn = "Earfcn"
        case eutranCid = "EutranCid"
        case pci = "Pci"
        case rsrp = "Rsrp"
        case rsrq = "Rsrq"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let earfcn = self.earfcn {
            try encodeContainer.encode(earfcn, forKey: .earfcn)
        }
        if let eutranCid = self.eutranCid {
            try encodeContainer.encode(eutranCid, forKey: .eutranCid)
        }
        if let pci = self.pci {
            try encodeContainer.encode(pci, forKey: .pci)
        }
        if let rsrp = self.rsrp {
            try encodeContainer.encode(rsrp, forKey: .rsrp)
        }
        if let rsrq = self.rsrq {
            try encodeContainer.encode(rsrq, forKey: .rsrq)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pciDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pci)
        pci = pciDecoded
        let earfcnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .earfcn)
        earfcn = earfcnDecoded
        let eutranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eutranCid)
        eutranCid = eutranCidDecoded
        let rsrpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rsrp)
        rsrp = rsrpDecoded
        let rsrqDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .rsrq)
        rsrq = rsrqDecoded
    }
}

extension IoTWirelessClientTypes {
    /// LTE object for network measurement reports.
    public struct LteNmrObj: Swift.Equatable {
        /// E-UTRA (Evolved universal terrestrial Radio Access) absolute radio frequency channel Number (EARFCN).
        /// This member is required.
        public var earfcn: Swift.Int?
        /// E-UTRAN (Evolved Universal Terrestrial Radio Access Network) cell global identifier (EUTRANCID).
        /// This member is required.
        public var eutranCid: Swift.Int?
        /// Physical cell ID.
        /// This member is required.
        public var pci: Swift.Int?
        /// Signal power of the reference signal received, measured in dBm (decibel-milliwatts).
        public var rsrp: Swift.Int?
        /// Signal quality of the reference Signal received, measured in decibels (dB).
        public var rsrq: Swift.Float?

        public init (
            earfcn: Swift.Int? = nil,
            eutranCid: Swift.Int? = nil,
            pci: Swift.Int? = nil,
            rsrp: Swift.Int? = nil,
            rsrq: Swift.Float? = nil
        )
        {
            self.earfcn = earfcn
            self.eutranCid = eutranCid
            self.pci = pci
            self.rsrp = rsrp
            self.rsrq = rsrq
        }
    }

}

extension IoTWirelessClientTypes.LteObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eutranCid = "EutranCid"
        case lteLocalId = "LteLocalId"
        case lteNmr = "LteNmr"
        case lteTimingAdvance = "LteTimingAdvance"
        case mcc = "Mcc"
        case mnc = "Mnc"
        case nrCapable = "NrCapable"
        case rsrp = "Rsrp"
        case rsrq = "Rsrq"
        case tac = "Tac"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eutranCid = self.eutranCid {
            try encodeContainer.encode(eutranCid, forKey: .eutranCid)
        }
        if let lteLocalId = self.lteLocalId {
            try encodeContainer.encode(lteLocalId, forKey: .lteLocalId)
        }
        if let lteNmr = lteNmr {
            var lteNmrContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lteNmr)
            for ltenmrobj0 in lteNmr {
                try lteNmrContainer.encode(ltenmrobj0)
            }
        }
        if let lteTimingAdvance = self.lteTimingAdvance {
            try encodeContainer.encode(lteTimingAdvance, forKey: .lteTimingAdvance)
        }
        if let mcc = self.mcc {
            try encodeContainer.encode(mcc, forKey: .mcc)
        }
        if let mnc = self.mnc {
            try encodeContainer.encode(mnc, forKey: .mnc)
        }
        if nrCapable != false {
            try encodeContainer.encode(nrCapable, forKey: .nrCapable)
        }
        if let rsrp = self.rsrp {
            try encodeContainer.encode(rsrp, forKey: .rsrp)
        }
        if let rsrq = self.rsrq {
            try encodeContainer.encode(rsrq, forKey: .rsrq)
        }
        if let tac = self.tac {
            try encodeContainer.encode(tac, forKey: .tac)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mccDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mcc)
        mcc = mccDecoded
        let mncDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mnc)
        mnc = mncDecoded
        let eutranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eutranCid)
        eutranCid = eutranCidDecoded
        let tacDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tac)
        tac = tacDecoded
        let lteLocalIdDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LteLocalId.self, forKey: .lteLocalId)
        lteLocalId = lteLocalIdDecoded
        let lteTimingAdvanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lteTimingAdvance)
        lteTimingAdvance = lteTimingAdvanceDecoded
        let rsrpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rsrp)
        rsrp = rsrpDecoded
        let rsrqDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .rsrq)
        rsrq = rsrqDecoded
        let nrCapableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .nrCapable) ?? false
        nrCapable = nrCapableDecoded
        let lteNmrContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.LteNmrObj?].self, forKey: .lteNmr)
        var lteNmrDecoded0:[IoTWirelessClientTypes.LteNmrObj]? = nil
        if let lteNmrContainer = lteNmrContainer {
            lteNmrDecoded0 = [IoTWirelessClientTypes.LteNmrObj]()
            for structure0 in lteNmrContainer {
                if let structure0 = structure0 {
                    lteNmrDecoded0?.append(structure0)
                }
            }
        }
        lteNmr = lteNmrDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// LTE object.
    public struct LteObj: Swift.Equatable {
        /// E-UTRAN (Evolved Universal Terrestrial Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var eutranCid: Swift.Int?
        /// LTE local identification (local ID) information.
        public var lteLocalId: IoTWirelessClientTypes.LteLocalId?
        /// LTE object for network measurement reports.
        public var lteNmr: [IoTWirelessClientTypes.LteNmrObj]?
        /// LTE timing advance.
        public var lteTimingAdvance: Swift.Int?
        /// Mobile Country Code.
        /// This member is required.
        public var mcc: Swift.Int?
        /// Mobile Network Code.
        /// This member is required.
        public var mnc: Swift.Int?
        /// Parameter that determines whether the LTE object is capable of supporting NR (new radio).
        public var nrCapable: Swift.Bool
        /// Signal power of the reference signal received, measured in dBm (decibel-milliwatts).
        public var rsrp: Swift.Int?
        /// Signal quality of the reference Signal received, measured in decibels (dB).
        public var rsrq: Swift.Float?
        /// LTE tracking area code.
        public var tac: Swift.Int?

        public init (
            eutranCid: Swift.Int? = nil,
            lteLocalId: IoTWirelessClientTypes.LteLocalId? = nil,
            lteNmr: [IoTWirelessClientTypes.LteNmrObj]? = nil,
            lteTimingAdvance: Swift.Int? = nil,
            mcc: Swift.Int? = nil,
            mnc: Swift.Int? = nil,
            nrCapable: Swift.Bool = false,
            rsrp: Swift.Int? = nil,
            rsrq: Swift.Float? = nil,
            tac: Swift.Int? = nil
        )
        {
            self.eutranCid = eutranCid
            self.lteLocalId = lteLocalId
            self.lteNmr = lteNmr
            self.lteTimingAdvance = lteTimingAdvance
            self.mcc = mcc
            self.mnc = mnc
            self.nrCapable = nrCapable
            self.rsrp = rsrp
            self.rsrq = rsrq
            self.tac = tac
        }
    }

}

extension IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
        case wirelessDeviceIdEventTopic = "WirelessDeviceIdEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let wirelessDeviceIdEventTopic = self.wirelessDeviceIdEventTopic {
            try encodeContainer.encode(wirelessDeviceIdEventTopic.rawValue, forKey: .wirelessDeviceIdEventTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkEventNotificationConfigurations.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let wirelessDeviceIdEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessDeviceIdEventTopic)
        wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Message delivery status event configuration object for enabling and disabling relevant topics.
    public struct MessageDeliveryStatusEventConfiguration: Swift.Equatable {
        /// SidewalkEventNotificationConfigurations object, which is the event configuration object for Sidewalk-related event topics.
        public var sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations?
        /// Denotes whether the wireless device ID message delivery status event topic is enabled or disabled.
        public var wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init (
            sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations? = nil,
            wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.sidewalk = sidewalk
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }
    }

}

extension IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Message delivery status resource type event configuration object for enabling or disabling relevant topic.
    public struct MessageDeliveryStatusResourceTypeEventConfiguration: Swift.Equatable {
        /// Sidewalk resource type event configuration object for enabling or disabling topic.
        public var sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration?

        public init (
            sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration? = nil
        )
        {
            self.sidewalk = sidewalk
        }
    }

}

extension IoTWirelessClientTypes {
    /// Sidewalk device message type. Default value is CUSTOM_COMMAND_ID_NOTIFY.
    public enum MessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customCommandIdGet
        case customCommandIdNotify
        case customCommandIdResp
        case customCommandIdSet
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .customCommandIdGet,
                .customCommandIdNotify,
                .customCommandIdResp,
                .customCommandIdSet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customCommandIdGet: return "CUSTOM_COMMAND_ID_GET"
            case .customCommandIdNotify: return "CUSTOM_COMMAND_ID_NOTIFY"
            case .customCommandIdResp: return "CUSTOM_COMMAND_ID_RESP"
            case .customCommandIdSet: return "CUSTOM_COMMAND_ID_SET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.MulticastGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IoTWirelessClientTypes {
    /// A multicast group.
    public struct MulticastGroup: Swift.Equatable {
        /// The arn of the multicast group.
        public var arn: Swift.String?
        /// The ID of the multicast group.
        public var id: Swift.String?
        /// The name of the multicast group.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension IoTWirelessClientTypes.MulticastGroupByFuotaTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTWirelessClientTypes {
    /// A multicast group that is associated with a FUOTA task.
    public struct MulticastGroupByFuotaTask: Swift.Equatable {
        /// The ID of the multicast group.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IoTWirelessClientTypes.MulticastWirelessMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANMulticastMetadata.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Wireless metadata that is to be sent to multicast group.
    public struct MulticastWirelessMetadata: Swift.Equatable {
        /// The metadata information of the LoRaWAN multicast group.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastMetadata?

        public init (
            loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastMetadata? = nil
        )
        {
            self.loRaWAN = loRaWAN
        }
    }

}

extension IoTWirelessClientTypes.NetworkAnalyzerConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Network analyzer configurations.
    public struct NetworkAnalyzerConfigurations: Swift.Equatable {
        /// The Amazon Resource Name of the new resource.
        public var arn: Swift.String?
        /// Name of the network analyzer configuration.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension IoTWirelessClientTypes.OtaaV1_0_x: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appEui = "AppEui"
        case appKey = "AppKey"
        case genAppKey = "GenAppKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appEui = self.appEui {
            try encodeContainer.encode(appEui, forKey: .appEui)
        }
        if let appKey = self.appKey {
            try encodeContainer.encode(appKey, forKey: .appKey)
        }
        if let genAppKey = self.genAppKey {
            try encodeContainer.encode(genAppKey, forKey: .genAppKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appKey)
        appKey = appKeyDecoded
        let appEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appEui)
        appEui = appEuiDecoded
        let genAppKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .genAppKey)
        genAppKey = genAppKeyDecoded
    }
}

extension IoTWirelessClientTypes {
    /// OTAA device object for v1.0.x
    public struct OtaaV1_0_x: Swift.Equatable {
        /// The AppEUI value.
        public var appEui: Swift.String?
        /// The AppKey value.
        public var appKey: Swift.String?
        /// The GenAppKey value.
        public var genAppKey: Swift.String?

        public init (
            appEui: Swift.String? = nil,
            appKey: Swift.String? = nil,
            genAppKey: Swift.String? = nil
        )
        {
            self.appEui = appEui
            self.appKey = appKey
            self.genAppKey = genAppKey
        }
    }

}

extension IoTWirelessClientTypes.OtaaV1_1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appKey = "AppKey"
        case joinEui = "JoinEui"
        case nwkKey = "NwkKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appKey = self.appKey {
            try encodeContainer.encode(appKey, forKey: .appKey)
        }
        if let joinEui = self.joinEui {
            try encodeContainer.encode(joinEui, forKey: .joinEui)
        }
        if let nwkKey = self.nwkKey {
            try encodeContainer.encode(nwkKey, forKey: .nwkKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appKey)
        appKey = appKeyDecoded
        let nwkKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nwkKey)
        nwkKey = nwkKeyDecoded
        let joinEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .joinEui)
        joinEui = joinEuiDecoded
    }
}

extension IoTWirelessClientTypes {
    /// OTAA device object for v1.1
    public struct OtaaV1_1: Swift.Equatable {
        /// The AppKey value.
        public var appKey: Swift.String?
        /// The JoinEUI value.
        public var joinEui: Swift.String?
        /// The NwkKey value.
        public var nwkKey: Swift.String?

        public init (
            appKey: Swift.String? = nil,
            joinEui: Swift.String? = nil,
            nwkKey: Swift.String? = nil
        )
        {
            self.appKey = appKey
            self.joinEui = joinEui
            self.nwkKey = nwkKey
        }
    }

}

extension IoTWirelessClientTypes.ParticipatingGateways: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downlinkMode = "DownlinkMode"
        case gatewayList = "GatewayList"
        case transmissionInterval = "TransmissionInterval"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downlinkMode = self.downlinkMode {
            try encodeContainer.encode(downlinkMode.rawValue, forKey: .downlinkMode)
        }
        if let gatewayList = gatewayList {
            var gatewayListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gatewayList)
            for gatewaylistitem0 in gatewayList {
                try gatewayListContainer.encode(gatewaylistitem0)
            }
        }
        if let transmissionInterval = self.transmissionInterval {
            try encodeContainer.encode(transmissionInterval, forKey: .transmissionInterval)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let downlinkModeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DownlinkMode.self, forKey: .downlinkMode)
        downlinkMode = downlinkModeDecoded
        let gatewayListContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.GatewayListItem?].self, forKey: .gatewayList)
        var gatewayListDecoded0:[IoTWirelessClientTypes.GatewayListItem]? = nil
        if let gatewayListContainer = gatewayListContainer {
            gatewayListDecoded0 = [IoTWirelessClientTypes.GatewayListItem]()
            for structure0 in gatewayListContainer {
                if let structure0 = structure0 {
                    gatewayListDecoded0?.append(structure0)
                }
            }
        }
        gatewayList = gatewayListDecoded0
        let transmissionIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .transmissionInterval)
        transmissionInterval = transmissionIntervalDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Specify the list of gateways to which you want to send downlink data traffic when the wireless device is running in class B or class C mode.
    public struct ParticipatingGateways: Swift.Equatable {
        /// Indicates whether to send the downlink message in sequential mode or concurrent mode, or to use only the chosen gateways from the previous uplink message transmission.
        /// This member is required.
        public var downlinkMode: IoTWirelessClientTypes.DownlinkMode?
        /// The list of gateways that you want to use for sending the downlink data traffic.
        /// This member is required.
        public var gatewayList: [IoTWirelessClientTypes.GatewayListItem]?
        /// The duration of time for which AWS IoT Core for LoRaWAN will wait before transmitting the payload to the next gateway.
        /// This member is required.
        public var transmissionInterval: Swift.Int?

        public init (
            downlinkMode: IoTWirelessClientTypes.DownlinkMode? = nil,
            gatewayList: [IoTWirelessClientTypes.GatewayListItem]? = nil,
            transmissionInterval: Swift.Int? = nil
        )
        {
            self.downlinkMode = downlinkMode
            self.gatewayList = gatewayList
            self.transmissionInterval = transmissionInterval
        }
    }

}

extension IoTWirelessClientTypes {
    public enum PartnerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [PartnerType] {
            return [
                .sidewalk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PartnerType(rawValue: rawValue) ?? PartnerType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum PositionConfigurationFec: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case rose
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionConfigurationFec] {
            return [
                .none,
                .rose,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .rose: return "ROSE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PositionConfigurationFec(rawValue: rawValue) ?? PositionConfigurationFec.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.PositionConfigurationItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case resourceIdentifier = "ResourceIdentifier"
        case resourceType = "ResourceType"
        case solvers = "Solvers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let solvers = self.solvers {
            try encodeContainer.encode(solvers, forKey: .solvers)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let solversDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionSolverDetails.self, forKey: .solvers)
        solvers = solversDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The wrapper for a position configuration.
    public struct PositionConfigurationItem: Swift.Equatable {
        /// The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
        public var destination: Swift.String?
        /// Resource identifier for the position configuration.
        public var resourceIdentifier: Swift.String?
        /// Resource type of the resource for the position configuration.
        public var resourceType: IoTWirelessClientTypes.PositionResourceType?
        /// The details of the positioning solver object used to compute the location.
        public var solvers: IoTWirelessClientTypes.PositionSolverDetails?

        public init (
            destination: Swift.String? = nil,
            resourceIdentifier: Swift.String? = nil,
            resourceType: IoTWirelessClientTypes.PositionResourceType? = nil,
            solvers: IoTWirelessClientTypes.PositionSolverDetails? = nil
        )
        {
            self.destination = destination
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
            self.solvers = solvers
        }
    }

}

extension IoTWirelessClientTypes {
    public enum PositionConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionConfigurationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PositionConfigurationStatus(rawValue: rawValue) ?? PositionConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum PositionResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case wirelessdevice
        case wirelessgateway
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionResourceType] {
            return [
                .wirelessdevice,
                .wirelessgateway,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .wirelessdevice: return "WirelessDevice"
            case .wirelessgateway: return "WirelessGateway"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PositionResourceType(rawValue: rawValue) ?? PositionResourceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.PositionSolverConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case semtechGnss = "SemtechGnss"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let semtechGnss = self.semtechGnss {
            try encodeContainer.encode(semtechGnss, forKey: .semtechGnss)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let semtechGnssDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SemtechGnssConfiguration.self, forKey: .semtechGnss)
        semtechGnss = semtechGnssDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The wrapper for position solver configurations.
    public struct PositionSolverConfigurations: Swift.Equatable {
        /// The Semtech GNSS solver configuration object.
        public var semtechGnss: IoTWirelessClientTypes.SemtechGnssConfiguration?

        public init (
            semtechGnss: IoTWirelessClientTypes.SemtechGnssConfiguration? = nil
        )
        {
            self.semtechGnss = semtechGnss
        }
    }

}

extension IoTWirelessClientTypes.PositionSolverDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case semtechGnss = "SemtechGnss"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let semtechGnss = self.semtechGnss {
            try encodeContainer.encode(semtechGnss, forKey: .semtechGnss)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let semtechGnssDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SemtechGnssDetail.self, forKey: .semtechGnss)
        semtechGnss = semtechGnssDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The wrapper for position solver details.
    public struct PositionSolverDetails: Swift.Equatable {
        /// The Semtech GNSS solver object details.
        public var semtechGnss: IoTWirelessClientTypes.SemtechGnssDetail?

        public init (
            semtechGnss: IoTWirelessClientTypes.SemtechGnssDetail? = nil
        )
        {
            self.semtechGnss = semtechGnss
        }
    }

}

extension IoTWirelessClientTypes {
    public enum PositionSolverProvider: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case semtech
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionSolverProvider] {
            return [
                .semtech,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .semtech: return "Semtech"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PositionSolverProvider(rawValue: rawValue) ?? PositionSolverProvider.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum PositionSolverType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gnss
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionSolverType] {
            return [
                .gnss,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gnss: return "GNSS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PositionSolverType(rawValue: rawValue) ?? PositionSolverType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.Positioning: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clockSync = "ClockSync"
        case gnss = "Gnss"
        case stream = "Stream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clockSync = self.clockSync {
            try encodeContainer.encode(clockSync, forKey: .clockSync)
        }
        if let gnss = self.gnss {
            try encodeContainer.encode(gnss, forKey: .gnss)
        }
        if let stream = self.stream {
            try encodeContainer.encode(stream, forKey: .stream)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clockSyncDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clockSync)
        clockSync = clockSyncDecoded
        let streamDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stream)
        stream = streamDecoded
        let gnssDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gnss)
        gnss = gnssDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The FPorts for the position information.
    public struct Positioning: Swift.Equatable {
        /// The Fport value.
        public var clockSync: Swift.Int?
        /// The Fport value.
        public var gnss: Swift.Int?
        /// The Fport value.
        public var stream: Swift.Int?

        public init (
            clockSync: Swift.Int? = nil,
            gnss: Swift.Int? = nil,
            stream: Swift.Int? = nil
        )
        {
            self.clockSync = clockSync
            self.gnss = gnss
            self.stream = stream
        }
    }

}

extension IoTWirelessClientTypes {
    public enum PositioningConfigStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PositioningConfigStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PositioningConfigStatus(rawValue: rawValue) ?? PositioningConfigStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.ProximityEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
        case wirelessDeviceIdEventTopic = "WirelessDeviceIdEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let wirelessDeviceIdEventTopic = self.wirelessDeviceIdEventTopic {
            try encodeContainer.encode(wirelessDeviceIdEventTopic.rawValue, forKey: .wirelessDeviceIdEventTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkEventNotificationConfigurations.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let wirelessDeviceIdEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessDeviceIdEventTopic)
        wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Proximity event configuration object for enabling and disabling relevant topics.
    public struct ProximityEventConfiguration: Swift.Equatable {
        /// Proximity event configuration object for enabling or disabling Sidewalk related event topics.
        public var sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations?
        /// Denotes whether the wireless device ID proximity event topic is enabled or disabled.
        public var wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init (
            sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations? = nil,
            wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.sidewalk = sidewalk
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }
    }

}

extension IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Proximity resource type event configuration object for enabling or disabling topic.
    public struct ProximityResourceTypeEventConfiguration: Swift.Equatable {
        /// Proximity resource type event configuration object for enabling and disabling wireless device topic.
        public var sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration?

        public init (
            sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration? = nil
        )
        {
            self.sidewalk = sidewalk
        }
    }

}

extension PutPositionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case solvers = "Solvers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let solvers = self.solvers {
            try encodeContainer.encode(solvers, forKey: .solvers)
        }
    }
}

extension PutPositionConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension PutPositionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/position-configurations/\(resourceIdentifier.urlPercentEncoding())"
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct PutPositionConfigurationInput: Swift.Equatable {
    /// The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
    public var destination: Swift.String?
    /// Resource identifier used to update the position configuration.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// Resource type of the resource for which you want to update the position configuration.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?
    /// The positioning solvers used to update the position configuration of the resource.
    public var solvers: IoTWirelessClientTypes.PositionSolverConfigurations?

    public init (
        destination: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil,
        solvers: IoTWirelessClientTypes.PositionSolverConfigurations? = nil
    )
    {
        self.destination = destination
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
        self.solvers = solvers
    }
}

struct PutPositionConfigurationInputBody: Swift.Equatable {
    let solvers: IoTWirelessClientTypes.PositionSolverConfigurations?
    let destination: Swift.String?
}

extension PutPositionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case solvers = "Solvers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solversDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionSolverConfigurations.self, forKey: .solvers)
        solvers = solversDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension PutPositionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPositionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutPositionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPositionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct PutPositionConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutResourceLogLevelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }
}

extension PutResourceLogLevelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension PutResourceLogLevelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct PutResourceLogLevelInput: Swift.Equatable {
    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    /// This member is required.
    public var logLevel: IoTWirelessClientTypes.LogLevel?
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway, it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        logLevel: IoTWirelessClientTypes.LogLevel? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.logLevel = logLevel
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct PutResourceLogLevelInputBody: Swift.Equatable {
    let logLevel: IoTWirelessClientTypes.LogLevel?
}

extension PutResourceLogLevelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension PutResourceLogLevelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourceLogLevelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutResourceLogLevelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourceLogLevelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutResourceLogLevelOutputResponse: Swift.Equatable {

    public init () { }
}

extension ResetAllResourceLogLevelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/log-levels"
    }
}

public struct ResetAllResourceLogLevelsInput: Swift.Equatable {

    public init () { }
}

struct ResetAllResourceLogLevelsInputBody: Swift.Equatable {
}

extension ResetAllResourceLogLevelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResetAllResourceLogLevelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetAllResourceLogLevelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ResetAllResourceLogLevelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetAllResourceLogLevelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ResetAllResourceLogLevelsOutputResponse: Swift.Equatable {

    public init () { }
}

extension ResetResourceLogLevelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension ResetResourceLogLevelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct ResetResourceLogLevelInput: Swift.Equatable {
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway, it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct ResetResourceLogLevelInputBody: Swift.Equatable {
}

extension ResetResourceLogLevelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResetResourceLogLevelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetResourceLogLevelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ResetResourceLogLevelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetResourceLogLevelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ResetResourceLogLevelOutputResponse: Swift.Equatable {

    public init () { }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Resource does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Id of the not found resource.
    public var resourceId: Swift.String?
    /// Type of the font found resource.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension IoTWirelessClientTypes.SemtechGnssConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fec = "Fec"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fec = self.fec {
            try encodeContainer.encode(fec.rawValue, forKey: .fec)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let fecDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionConfigurationFec.self, forKey: .fec)
        fec = fecDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about the Semtech GNSS solver configuration.
    public struct SemtechGnssConfiguration: Swift.Equatable {
        /// Whether forward error correction is enabled.
        /// This member is required.
        public var fec: IoTWirelessClientTypes.PositionConfigurationFec?
        /// The status indicating whether the solver is enabled.
        /// This member is required.
        public var status: IoTWirelessClientTypes.PositionConfigurationStatus?

        public init (
            fec: IoTWirelessClientTypes.PositionConfigurationFec? = nil,
            status: IoTWirelessClientTypes.PositionConfigurationStatus? = nil
        )
        {
            self.fec = fec
            self.status = status
        }
    }

}

extension IoTWirelessClientTypes.SemtechGnssDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fec = "Fec"
        case provider = "Provider"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fec = self.fec {
            try encodeContainer.encode(fec.rawValue, forKey: .fec)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionSolverProvider.self, forKey: .provider)
        provider = providerDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionSolverType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let fecDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositionConfigurationFec.self, forKey: .fec)
        fec = fecDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Details of the Semtech GNSS solver object.
    public struct SemtechGnssDetail: Swift.Equatable {
        /// Whether forward error correction is enabled.
        public var fec: IoTWirelessClientTypes.PositionConfigurationFec?
        /// The vendor of the solver object.
        public var provider: IoTWirelessClientTypes.PositionSolverProvider?
        /// The status indicating whether the solver is enabled.
        public var status: IoTWirelessClientTypes.PositionConfigurationStatus?
        /// The type of positioning solver used.
        public var type: IoTWirelessClientTypes.PositionSolverType?

        public init (
            fec: IoTWirelessClientTypes.PositionConfigurationFec? = nil,
            provider: IoTWirelessClientTypes.PositionSolverProvider? = nil,
            status: IoTWirelessClientTypes.PositionConfigurationStatus? = nil,
            type: IoTWirelessClientTypes.PositionSolverType? = nil
        )
        {
            self.fec = fec
            self.provider = provider
            self.status = status
            self.type = type
        }
    }

}

extension SendDataToMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadData = "PayloadData"
        case wirelessMetadata = "WirelessMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payloadData = self.payloadData {
            try encodeContainer.encode(payloadData, forKey: .payloadData)
        }
        if let wirelessMetadata = self.wirelessMetadata {
            try encodeContainer.encode(wirelessMetadata, forKey: .wirelessMetadata)
        }
    }
}

extension SendDataToMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/data"
    }
}

public struct SendDataToMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The binary to be sent to the end device, encoded in base64.
    /// This member is required.
    public var payloadData: Swift.String?
    /// Wireless metadata that is to be sent to multicast group.
    /// This member is required.
    public var wirelessMetadata: IoTWirelessClientTypes.MulticastWirelessMetadata?

    public init (
        id: Swift.String? = nil,
        payloadData: Swift.String? = nil,
        wirelessMetadata: IoTWirelessClientTypes.MulticastWirelessMetadata? = nil
    )
    {
        self.id = id
        self.payloadData = payloadData
        self.wirelessMetadata = wirelessMetadata
    }
}

struct SendDataToMulticastGroupInputBody: Swift.Equatable {
    let payloadData: Swift.String?
    let wirelessMetadata: IoTWirelessClientTypes.MulticastWirelessMetadata?
}

extension SendDataToMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadData = "PayloadData"
        case wirelessMetadata = "WirelessMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadData)
        payloadData = payloadDataDecoded
        let wirelessMetadataDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MulticastWirelessMetadata.self, forKey: .wirelessMetadata)
        wirelessMetadata = wirelessMetadataDecoded
    }
}

extension SendDataToMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendDataToMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SendDataToMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendDataToMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SendDataToMulticastGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

public struct SendDataToMulticastGroupOutputResponse: Swift.Equatable {
    /// ID of a multicast group message.
    public var messageId: Swift.String?

    public init (
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendDataToMulticastGroupOutputResponseBody: Swift.Equatable {
    let messageId: Swift.String?
}

extension SendDataToMulticastGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension SendDataToWirelessDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadData = "PayloadData"
        case transmitMode = "TransmitMode"
        case wirelessMetadata = "WirelessMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payloadData = self.payloadData {
            try encodeContainer.encode(payloadData, forKey: .payloadData)
        }
        if let transmitMode = self.transmitMode {
            try encodeContainer.encode(transmitMode, forKey: .transmitMode)
        }
        if let wirelessMetadata = self.wirelessMetadata {
            try encodeContainer.encode(wirelessMetadata, forKey: .wirelessMetadata)
        }
    }
}

extension SendDataToWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/data"
    }
}

public struct SendDataToWirelessDeviceInput: Swift.Equatable {
    /// The ID of the wireless device to receive the data.
    /// This member is required.
    public var id: Swift.String?
    /// The binary to be sent to the end device, encoded in base64.
    /// This member is required.
    public var payloadData: Swift.String?
    /// The transmit mode to use to send data to the wireless device. Can be: 0 for UM (unacknowledge mode) or 1 for AM (acknowledge mode).
    /// This member is required.
    public var transmitMode: Swift.Int?
    /// Metadata about the message request.
    public var wirelessMetadata: IoTWirelessClientTypes.WirelessMetadata?

    public init (
        id: Swift.String? = nil,
        payloadData: Swift.String? = nil,
        transmitMode: Swift.Int? = nil,
        wirelessMetadata: IoTWirelessClientTypes.WirelessMetadata? = nil
    )
    {
        self.id = id
        self.payloadData = payloadData
        self.transmitMode = transmitMode
        self.wirelessMetadata = wirelessMetadata
    }
}

struct SendDataToWirelessDeviceInputBody: Swift.Equatable {
    let transmitMode: Swift.Int?
    let payloadData: Swift.String?
    let wirelessMetadata: IoTWirelessClientTypes.WirelessMetadata?
}

extension SendDataToWirelessDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadData = "PayloadData"
        case transmitMode = "TransmitMode"
        case wirelessMetadata = "WirelessMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transmitModeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .transmitMode)
        transmitMode = transmitModeDecoded
        let payloadDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadData)
        payloadData = payloadDataDecoded
        let wirelessMetadataDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessMetadata.self, forKey: .wirelessMetadata)
        wirelessMetadata = wirelessMetadataDecoded
    }
}

extension SendDataToWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendDataToWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SendDataToWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendDataToWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SendDataToWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

public struct SendDataToWirelessDeviceOutputResponse: Swift.Equatable {
    /// The ID of the message sent to the wireless device.
    public var messageId: Swift.String?

    public init (
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendDataToWirelessDeviceOutputResponseBody: Swift.Equatable {
    let messageId: Swift.String?
}

extension SendDataToWirelessDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension IoTWirelessClientTypes.ServiceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about a service profile.
    public struct ServiceProfile: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the service profile.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension IoTWirelessClientTypes.SessionKeysAbpV1_0_x: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSKey = "AppSKey"
        case nwkSKey = "NwkSKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appSKey = self.appSKey {
            try encodeContainer.encode(appSKey, forKey: .appSKey)
        }
        if let nwkSKey = self.nwkSKey {
            try encodeContainer.encode(nwkSKey, forKey: .nwkSKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nwkSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nwkSKey)
        nwkSKey = nwkSKeyDecoded
        let appSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appSKey)
        appSKey = appSKeyDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Session keys for ABP v1.1
    public struct SessionKeysAbpV1_0_x: Swift.Equatable {
        /// The AppSKey value.
        public var appSKey: Swift.String?
        /// The NwkSKey value.
        public var nwkSKey: Swift.String?

        public init (
            appSKey: Swift.String? = nil,
            nwkSKey: Swift.String? = nil
        )
        {
            self.appSKey = appSKey
            self.nwkSKey = nwkSKey
        }
    }

}

extension IoTWirelessClientTypes.SessionKeysAbpV1_1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSKey = "AppSKey"
        case fNwkSIntKey = "FNwkSIntKey"
        case nwkSEncKey = "NwkSEncKey"
        case sNwkSIntKey = "SNwkSIntKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appSKey = self.appSKey {
            try encodeContainer.encode(appSKey, forKey: .appSKey)
        }
        if let fNwkSIntKey = self.fNwkSIntKey {
            try encodeContainer.encode(fNwkSIntKey, forKey: .fNwkSIntKey)
        }
        if let nwkSEncKey = self.nwkSEncKey {
            try encodeContainer.encode(nwkSEncKey, forKey: .nwkSEncKey)
        }
        if let sNwkSIntKey = self.sNwkSIntKey {
            try encodeContainer.encode(sNwkSIntKey, forKey: .sNwkSIntKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fNwkSIntKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fNwkSIntKey)
        fNwkSIntKey = fNwkSIntKeyDecoded
        let sNwkSIntKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sNwkSIntKey)
        sNwkSIntKey = sNwkSIntKeyDecoded
        let nwkSEncKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nwkSEncKey)
        nwkSEncKey = nwkSEncKeyDecoded
        let appSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appSKey)
        appSKey = appSKeyDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Session keys for ABP v1.1
    public struct SessionKeysAbpV1_1: Swift.Equatable {
        /// The AppSKey value.
        public var appSKey: Swift.String?
        /// The FNwkSIntKey value.
        public var fNwkSIntKey: Swift.String?
        /// The NwkSEncKey value.
        public var nwkSEncKey: Swift.String?
        /// The SNwkSIntKey value.
        public var sNwkSIntKey: Swift.String?

        public init (
            appSKey: Swift.String? = nil,
            fNwkSIntKey: Swift.String? = nil,
            nwkSEncKey: Swift.String? = nil,
            sNwkSIntKey: Swift.String? = nil
        )
        {
            self.appSKey = appSKey
            self.fNwkSIntKey = fNwkSIntKey
            self.nwkSEncKey = nwkSEncKey
            self.sNwkSIntKey = sNwkSIntKey
        }
    }

}

extension IoTWirelessClientTypes.SidewalkAccountInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case appServerPrivateKey = "AppServerPrivateKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = self.amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let appServerPrivateKey = self.appServerPrivateKey {
            try encodeContainer.encode(appServerPrivateKey, forKey: .appServerPrivateKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let appServerPrivateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appServerPrivateKey)
        appServerPrivateKey = appServerPrivateKeyDecoded
    }
}

extension IoTWirelessClientTypes.SidewalkAccountInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkAccountInfo(amazonId: \(Swift.String(describing: amazonId)), appServerPrivateKey: \"CONTENT_REDACTED\")"}
}

extension IoTWirelessClientTypes {
    /// Information about a Sidewalk account.
    public struct SidewalkAccountInfo: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The Sidewalk application server private key.
        public var appServerPrivateKey: Swift.String?

        public init (
            amazonId: Swift.String? = nil,
            appServerPrivateKey: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.appServerPrivateKey = appServerPrivateKey
        }
    }

}

extension IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case arn = "Arn"
        case fingerprint = "Fingerprint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = self.amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let fingerprint = self.fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkAccountInfoWithFingerprint(amazonId: \(Swift.String(describing: amazonId)), arn: \(Swift.String(describing: arn)), fingerprint: \"CONTENT_REDACTED\")"}
}

extension IoTWirelessClientTypes {
    /// Information about a Sidewalk account.
    public struct SidewalkAccountInfoWithFingerprint: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The fingerprint of the Sidewalk application server private key.
        public var fingerprint: Swift.String?

        public init (
            amazonId: Swift.String? = nil,
            arn: Swift.String? = nil,
            fingerprint: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.arn = arn
            self.fingerprint = fingerprint
        }
    }

}

extension IoTWirelessClientTypes.SidewalkDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case deviceCertificates = "DeviceCertificates"
        case sidewalkId = "SidewalkId"
        case sidewalkManufacturingSn = "SidewalkManufacturingSn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = self.amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let deviceCertificates = deviceCertificates {
            var deviceCertificatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceCertificates)
            for certificatelist0 in deviceCertificates {
                try deviceCertificatesContainer.encode(certificatelist0)
            }
        }
        if let sidewalkId = self.sidewalkId {
            try encodeContainer.encode(sidewalkId, forKey: .sidewalkId)
        }
        if let sidewalkManufacturingSn = self.sidewalkManufacturingSn {
            try encodeContainer.encode(sidewalkManufacturingSn, forKey: .sidewalkManufacturingSn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let sidewalkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkId)
        sidewalkId = sidewalkIdDecoded
        let sidewalkManufacturingSnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkManufacturingSn)
        sidewalkManufacturingSn = sidewalkManufacturingSnDecoded
        let deviceCertificatesContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.CertificateList?].self, forKey: .deviceCertificates)
        var deviceCertificatesDecoded0:[IoTWirelessClientTypes.CertificateList]? = nil
        if let deviceCertificatesContainer = deviceCertificatesContainer {
            deviceCertificatesDecoded0 = [IoTWirelessClientTypes.CertificateList]()
            for structure0 in deviceCertificatesContainer {
                if let structure0 = structure0 {
                    deviceCertificatesDecoded0?.append(structure0)
                }
            }
        }
        deviceCertificates = deviceCertificatesDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// Sidewalk device object.
    public struct SidewalkDevice: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The sidewalk device certificates for Ed25519 and P256r1.
        public var deviceCertificates: [IoTWirelessClientTypes.CertificateList]?
        /// The sidewalk device identification.
        public var sidewalkId: Swift.String?
        /// The Sidewalk manufacturing series number.
        public var sidewalkManufacturingSn: Swift.String?

        public init (
            amazonId: Swift.String? = nil,
            deviceCertificates: [IoTWirelessClientTypes.CertificateList]? = nil,
            sidewalkId: Swift.String? = nil,
            sidewalkManufacturingSn: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.deviceCertificates = deviceCertificates
            self.sidewalkId = sidewalkId
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
        }
    }

}

extension IoTWirelessClientTypes.SidewalkDeviceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batteryLevel = "BatteryLevel"
        case deviceState = "DeviceState"
        case event = "Event"
        case rssi = "Rssi"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batteryLevel = self.batteryLevel {
            try encodeContainer.encode(batteryLevel.rawValue, forKey: .batteryLevel)
        }
        if let deviceState = self.deviceState {
            try encodeContainer.encode(deviceState.rawValue, forKey: .deviceState)
        }
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let rssi = self.rssi {
            try encodeContainer.encode(rssi, forKey: .rssi)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rssiDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rssi)
        rssi = rssiDecoded
        let batteryLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.BatteryLevel.self, forKey: .batteryLevel)
        batteryLevel = batteryLevelDecoded
        let eventDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let deviceStateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DeviceState.self, forKey: .deviceState)
        deviceState = deviceStateDecoded
    }
}

extension IoTWirelessClientTypes {
    /// MetaData for Sidewalk device.
    public struct SidewalkDeviceMetadata: Swift.Equatable {
        /// Sidewalk device battery level.
        public var batteryLevel: IoTWirelessClientTypes.BatteryLevel?
        /// Device state defines the device status of sidewalk device.
        public var deviceState: IoTWirelessClientTypes.DeviceState?
        /// Sidewalk device status notification.
        public var event: IoTWirelessClientTypes.Event?
        /// The RSSI value.
        public var rssi: Swift.Int?

        public init (
            batteryLevel: IoTWirelessClientTypes.BatteryLevel? = nil,
            deviceState: IoTWirelessClientTypes.DeviceState? = nil,
            event: IoTWirelessClientTypes.Event? = nil,
            rssi: Swift.Int? = nil
        )
        {
            self.batteryLevel = batteryLevel
            self.deviceState = deviceState
            self.event = event
            self.rssi = rssi
        }
    }

}

extension IoTWirelessClientTypes.SidewalkEventNotificationConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonIdEventTopic = "AmazonIdEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonIdEventTopic = self.amazonIdEventTopic {
            try encodeContainer.encode(amazonIdEventTopic.rawValue, forKey: .amazonIdEventTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .amazonIdEventTopic)
        amazonIdEventTopic = amazonIdEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// SidewalkEventNotificationConfigurations object, which is the event configuration object for Sidewalk-related event topics.
    public struct SidewalkEventNotificationConfigurations: Swift.Equatable {
        /// Denotes whether the Amazon ID event topic is enabled or disabled.
        public var amazonIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init (
            amazonIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.amazonIdEventTopic = amazonIdEventTopic
        }
    }

}

extension IoTWirelessClientTypes.SidewalkListDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case deviceCertificates = "DeviceCertificates"
        case sidewalkId = "SidewalkId"
        case sidewalkManufacturingSn = "SidewalkManufacturingSn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = self.amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let deviceCertificates = deviceCertificates {
            var deviceCertificatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceCertificates)
            for certificatelist0 in deviceCertificates {
                try deviceCertificatesContainer.encode(certificatelist0)
            }
        }
        if let sidewalkId = self.sidewalkId {
            try encodeContainer.encode(sidewalkId, forKey: .sidewalkId)
        }
        if let sidewalkManufacturingSn = self.sidewalkManufacturingSn {
            try encodeContainer.encode(sidewalkManufacturingSn, forKey: .sidewalkManufacturingSn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let sidewalkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkId)
        sidewalkId = sidewalkIdDecoded
        let sidewalkManufacturingSnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkManufacturingSn)
        sidewalkManufacturingSn = sidewalkManufacturingSnDecoded
        let deviceCertificatesContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.CertificateList?].self, forKey: .deviceCertificates)
        var deviceCertificatesDecoded0:[IoTWirelessClientTypes.CertificateList]? = nil
        if let deviceCertificatesContainer = deviceCertificatesContainer {
            deviceCertificatesDecoded0 = [IoTWirelessClientTypes.CertificateList]()
            for structure0 in deviceCertificatesContainer {
                if let structure0 = structure0 {
                    deviceCertificatesDecoded0?.append(structure0)
                }
            }
        }
        deviceCertificates = deviceCertificatesDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// Sidewalk object used by list functions.
    public struct SidewalkListDevice: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The sidewalk device certificates for Ed25519 and P256r1.
        public var deviceCertificates: [IoTWirelessClientTypes.CertificateList]?
        /// The sidewalk device identification.
        public var sidewalkId: Swift.String?
        /// The Sidewalk manufacturing series number.
        public var sidewalkManufacturingSn: Swift.String?

        public init (
            amazonId: Swift.String? = nil,
            deviceCertificates: [IoTWirelessClientTypes.CertificateList]? = nil,
            sidewalkId: Swift.String? = nil,
            sidewalkManufacturingSn: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.deviceCertificates = deviceCertificates
            self.sidewalkId = sidewalkId
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
        }
    }

}

extension IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceEventTopic = "WirelessDeviceEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessDeviceEventTopic = self.wirelessDeviceEventTopic {
            try encodeContainer.encode(wirelessDeviceEventTopic.rawValue, forKey: .wirelessDeviceEventTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceEventTopicDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .wirelessDeviceEventTopic)
        wirelessDeviceEventTopic = wirelessDeviceEventTopicDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Sidewalk resource type event configuration object for enabling or disabling topic.
    public struct SidewalkResourceTypeEventConfiguration: Swift.Equatable {
        /// Denotes whether the wireless device join event topic is enabled or disabled.
        public var wirelessDeviceEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init (
            wirelessDeviceEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.wirelessDeviceEventTopic = wirelessDeviceEventTopic
        }
    }

}

extension IoTWirelessClientTypes.SidewalkSendDataToDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ackModeRetryDurationSecs = "AckModeRetryDurationSecs"
        case messageType = "MessageType"
        case seq = "Seq"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ackModeRetryDurationSecs = self.ackModeRetryDurationSecs {
            try encodeContainer.encode(ackModeRetryDurationSecs, forKey: .ackModeRetryDurationSecs)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let seq = self.seq {
            try encodeContainer.encode(seq, forKey: .seq)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let seqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .seq)
        seq = seqDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let ackModeRetryDurationSecsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ackModeRetryDurationSecs)
        ackModeRetryDurationSecs = ackModeRetryDurationSecsDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about a Sidewalk router.
    public struct SidewalkSendDataToDevice: Swift.Equatable {
        /// The duration of time in seconds to retry sending the ACK.
        public var ackModeRetryDurationSecs: Swift.Int?
        /// Sidewalk device message type. Default value is CUSTOM_COMMAND_ID_NOTIFY.
        public var messageType: IoTWirelessClientTypes.MessageType?
        /// The sequence number.
        public var seq: Swift.Int?

        public init (
            ackModeRetryDurationSecs: Swift.Int? = nil,
            messageType: IoTWirelessClientTypes.MessageType? = nil,
            seq: Swift.Int? = nil
        )
        {
            self.ackModeRetryDurationSecs = ackModeRetryDurationSecs
            self.messageType = messageType
            self.seq = seq
        }
    }

}

extension IoTWirelessClientTypes.SidewalkUpdateAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appServerPrivateKey = "AppServerPrivateKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appServerPrivateKey = self.appServerPrivateKey {
            try encodeContainer.encode(appServerPrivateKey, forKey: .appServerPrivateKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appServerPrivateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appServerPrivateKey)
        appServerPrivateKey = appServerPrivateKeyDecoded
    }
}

extension IoTWirelessClientTypes.SidewalkUpdateAccount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkUpdateAccount(appServerPrivateKey: \"CONTENT_REDACTED\")"}
}

extension IoTWirelessClientTypes {
    /// Sidewalk update.
    public struct SidewalkUpdateAccount: Swift.Equatable {
        /// The new Sidewalk application server private key.
        public var appServerPrivateKey: Swift.String?

        public init (
            appServerPrivateKey: Swift.String? = nil
        )
        {
            self.appServerPrivateKey = appServerPrivateKey
        }
    }

}

extension IoTWirelessClientTypes {
    /// The certificate chain algorithm provided by sidewalk.
    public enum SigningAlg: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ed25519
        case p256r1
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningAlg] {
            return [
                .ed25519,
                .p256r1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ed25519: return "Ed25519"
            case .p256r1: return "P256r1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SigningAlg(rawValue: rawValue) ?? SigningAlg.sdkUnknown(rawValue)
        }
    }
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryString = "QueryString"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/bulk"
    }
}

public struct StartBulkAssociateWirelessDeviceWithMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// Query string used to search for wireless devices as part of the bulk associate and disassociate process.
    public var queryString: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init (
        id: Swift.String? = nil,
        queryString: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.id = id
        self.queryString = queryString
        self.tags = tags
    }
}

struct StartBulkAssociateWirelessDeviceWithMulticastGroupInputBody: Swift.Equatable {
    let queryString: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryString = "QueryString"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartBulkAssociateWirelessDeviceWithMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartBulkAssociateWirelessDeviceWithMulticastGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryString = "QueryString"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/bulk"
    }
}

public struct StartBulkDisassociateWirelessDeviceFromMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// Query string used to search for wireless devices as part of the bulk associate and disassociate process.
    public var queryString: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init (
        id: Swift.String? = nil,
        queryString: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.id = id
        self.queryString = queryString
        self.tags = tags
    }
}

struct StartBulkDisassociateWirelessDeviceFromMulticastGroupInputBody: Swift.Equatable {
    let queryString: Swift.String?
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryString = "QueryString"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartBulkDisassociateWirelessDeviceFromMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartBulkDisassociateWirelessDeviceFromMulticastGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension StartFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }
}

extension StartFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

public struct StartFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information used to start a FUOTA task.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANStartFuotaTask?

    public init (
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANStartFuotaTask? = nil
    )
    {
        self.id = id
        self.loRaWAN = loRaWAN
    }
}

struct StartFuotaTaskInputBody: Swift.Equatable {
    let loRaWAN: IoTWirelessClientTypes.LoRaWANStartFuotaTask?
}

extension StartFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANStartFuotaTask.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension StartFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartFuotaTaskOutputResponse: Swift.Equatable {

    public init () { }
}

extension StartMulticastGroupSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }
}

extension StartMulticastGroupSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/session"
    }
}

public struct StartMulticastGroupSessionInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information used with the multicast session.
    /// This member is required.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession?

    public init (
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession? = nil
    )
    {
        self.id = id
        self.loRaWAN = loRaWAN
    }
}

struct StartMulticastGroupSessionInputBody: Swift.Equatable {
    let loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession?
}

extension StartMulticastGroupSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANMulticastSession.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension StartMulticastGroupSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMulticastGroupSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartMulticastGroupSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMulticastGroupSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartMulticastGroupSessionOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTWirelessClientTypes {
    /// Supported RfRegions
    public enum SupportedRfRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case as9231
        case au915
        case eu868
        case us915
        case sdkUnknown(Swift.String)

        public static var allCases: [SupportedRfRegion] {
            return [
                .as9231,
                .au915,
                .eu868,
                .us915,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .as9231: return "AS923-1"
            case .au915: return "AU915"
            case .eu868: return "EU868"
            case .us915: return "US915"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SupportedRfRegion(rawValue: rawValue) ?? SupportedRfRegion.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTWirelessClientTypes {
    /// A simple label consisting of a customer-defined key-value pair
    public struct Tag: Swift.Equatable {
        /// The tag's key value.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to add tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Adds to or modifies the tags of the given resource. Tags are metadata that you can use to manage a resource.
    /// This member is required.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [IoTWirelessClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTWirelessClientTypes.TdscdmaLocalId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellParams = "CellParams"
        case uarfcn = "Uarfcn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellParams = self.cellParams {
            try encodeContainer.encode(cellParams, forKey: .cellParams)
        }
        if let uarfcn = self.uarfcn {
            try encodeContainer.encode(uarfcn, forKey: .uarfcn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uarfcnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uarfcn)
        uarfcn = uarfcnDecoded
        let cellParamsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cellParams)
        cellParams = cellParamsDecoded
    }
}

extension IoTWirelessClientTypes {
    /// TD-SCDMA local identification (local Id) information.
    public struct TdscdmaLocalId: Swift.Equatable {
        /// Cell parameters for TD-SCDMA.
        /// This member is required.
        public var cellParams: Swift.Int?
        /// TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number (UARFCN).
        /// This member is required.
        public var uarfcn: Swift.Int?

        public init (
            cellParams: Swift.Int? = nil,
            uarfcn: Swift.Int? = nil
        )
        {
            self.cellParams = cellParams
            self.uarfcn = uarfcn
        }
    }

}

extension IoTWirelessClientTypes.TdscdmaNmrObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellParams = "CellParams"
        case pathLoss = "PathLoss"
        case rscp = "Rscp"
        case uarfcn = "Uarfcn"
        case utranCid = "UtranCid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellParams = self.cellParams {
            try encodeContainer.encode(cellParams, forKey: .cellParams)
        }
        if let pathLoss = self.pathLoss {
            try encodeContainer.encode(pathLoss, forKey: .pathLoss)
        }
        if let rscp = self.rscp {
            try encodeContainer.encode(rscp, forKey: .rscp)
        }
        if let uarfcn = self.uarfcn {
            try encodeContainer.encode(uarfcn, forKey: .uarfcn)
        }
        if let utranCid = self.utranCid {
            try encodeContainer.encode(utranCid, forKey: .utranCid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uarfcnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uarfcn)
        uarfcn = uarfcnDecoded
        let cellParamsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cellParams)
        cellParams = cellParamsDecoded
        let utranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .utranCid)
        utranCid = utranCidDecoded
        let rscpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rscp)
        rscp = rscpDecoded
        let pathLossDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pathLoss)
        pathLoss = pathLossDecoded
    }
}

extension IoTWirelessClientTypes {
    /// TD-SCDMA object for network measurement reports.
    public struct TdscdmaNmrObj: Swift.Equatable {
        /// Cell parameters for TD-SCDMA network measurement reports object.
        /// This member is required.
        public var cellParams: Swift.Int?
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public var pathLoss: Swift.Int?
        /// Code power of the received signal, measured in decibel-milliwatts (dBm).
        public var rscp: Swift.Int?
        /// TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number.
        /// This member is required.
        public var uarfcn: Swift.Int?
        /// UTRAN (UMTS Terrestrial Radio Access Network) cell global identifier.
        public var utranCid: Swift.Int?

        public init (
            cellParams: Swift.Int? = nil,
            pathLoss: Swift.Int? = nil,
            rscp: Swift.Int? = nil,
            uarfcn: Swift.Int? = nil,
            utranCid: Swift.Int? = nil
        )
        {
            self.cellParams = cellParams
            self.pathLoss = pathLoss
            self.rscp = rscp
            self.uarfcn = uarfcn
            self.utranCid = utranCid
        }
    }

}

extension IoTWirelessClientTypes.TdscdmaObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lac = "Lac"
        case mcc = "Mcc"
        case mnc = "Mnc"
        case pathLoss = "PathLoss"
        case rscp = "Rscp"
        case tdscdmaLocalId = "TdscdmaLocalId"
        case tdscdmaNmr = "TdscdmaNmr"
        case tdscdmaTimingAdvance = "TdscdmaTimingAdvance"
        case utranCid = "UtranCid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lac = self.lac {
            try encodeContainer.encode(lac, forKey: .lac)
        }
        if let mcc = self.mcc {
            try encodeContainer.encode(mcc, forKey: .mcc)
        }
        if let mnc = self.mnc {
            try encodeContainer.encode(mnc, forKey: .mnc)
        }
        if let pathLoss = self.pathLoss {
            try encodeContainer.encode(pathLoss, forKey: .pathLoss)
        }
        if let rscp = self.rscp {
            try encodeContainer.encode(rscp, forKey: .rscp)
        }
        if let tdscdmaLocalId = self.tdscdmaLocalId {
            try encodeContainer.encode(tdscdmaLocalId, forKey: .tdscdmaLocalId)
        }
        if let tdscdmaNmr = tdscdmaNmr {
            var tdscdmaNmrContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tdscdmaNmr)
            for tdscdmanmrobj0 in tdscdmaNmr {
                try tdscdmaNmrContainer.encode(tdscdmanmrobj0)
            }
        }
        if let tdscdmaTimingAdvance = self.tdscdmaTimingAdvance {
            try encodeContainer.encode(tdscdmaTimingAdvance, forKey: .tdscdmaTimingAdvance)
        }
        if let utranCid = self.utranCid {
            try encodeContainer.encode(utranCid, forKey: .utranCid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mccDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mcc)
        mcc = mccDecoded
        let mncDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mnc)
        mnc = mncDecoded
        let lacDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lac)
        lac = lacDecoded
        let utranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .utranCid)
        utranCid = utranCidDecoded
        let tdscdmaLocalIdDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.TdscdmaLocalId.self, forKey: .tdscdmaLocalId)
        tdscdmaLocalId = tdscdmaLocalIdDecoded
        let tdscdmaTimingAdvanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tdscdmaTimingAdvance)
        tdscdmaTimingAdvance = tdscdmaTimingAdvanceDecoded
        let rscpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rscp)
        rscp = rscpDecoded
        let pathLossDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pathLoss)
        pathLoss = pathLossDecoded
        let tdscdmaNmrContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.TdscdmaNmrObj?].self, forKey: .tdscdmaNmr)
        var tdscdmaNmrDecoded0:[IoTWirelessClientTypes.TdscdmaNmrObj]? = nil
        if let tdscdmaNmrContainer = tdscdmaNmrContainer {
            tdscdmaNmrDecoded0 = [IoTWirelessClientTypes.TdscdmaNmrObj]()
            for structure0 in tdscdmaNmrContainer {
                if let structure0 = structure0 {
                    tdscdmaNmrDecoded0?.append(structure0)
                }
            }
        }
        tdscdmaNmr = tdscdmaNmrDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// TD-SCDMA object.
    public struct TdscdmaObj: Swift.Equatable {
        /// Location Area Code.
        public var lac: Swift.Int?
        /// Mobile Country Code.
        /// This member is required.
        public var mcc: Swift.Int?
        /// Mobile Network Code.
        /// This member is required.
        public var mnc: Swift.Int?
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public var pathLoss: Swift.Int?
        /// Signal power of the received signal (Received Signal Code Power), measured in decibel-milliwatts (dBm).
        public var rscp: Swift.Int?
        /// TD-SCDMA local identification (local ID) information.
        public var tdscdmaLocalId: IoTWirelessClientTypes.TdscdmaLocalId?
        /// TD-SCDMA object for network measurement reports.
        public var tdscdmaNmr: [IoTWirelessClientTypes.TdscdmaNmrObj]?
        /// TD-SCDMA Timing advance.
        public var tdscdmaTimingAdvance: Swift.Int?
        /// UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var utranCid: Swift.Int?

        public init (
            lac: Swift.Int? = nil,
            mcc: Swift.Int? = nil,
            mnc: Swift.Int? = nil,
            pathLoss: Swift.Int? = nil,
            rscp: Swift.Int? = nil,
            tdscdmaLocalId: IoTWirelessClientTypes.TdscdmaLocalId? = nil,
            tdscdmaNmr: [IoTWirelessClientTypes.TdscdmaNmrObj]? = nil,
            tdscdmaTimingAdvance: Swift.Int? = nil,
            utranCid: Swift.Int? = nil
        )
        {
            self.lac = lac
            self.mcc = mcc
            self.mnc = mnc
            self.pathLoss = pathLoss
            self.rscp = rscp
            self.tdscdmaLocalId = tdscdmaLocalId
            self.tdscdmaNmr = tdscdmaNmr
            self.tdscdmaTimingAdvance = tdscdmaTimingAdvance
            self.utranCid = utranCid
        }
    }

}

extension TestWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/test"
    }
}

public struct TestWirelessDeviceInput: Swift.Equatable {
    /// The ID of the wireless device to test.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct TestWirelessDeviceInputBody: Swift.Equatable {
}

extension TestWirelessDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TestWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TestWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TestWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = nil
        }
    }
}

public struct TestWirelessDeviceOutputResponse: Swift.Equatable {
    /// The result returned by the test.
    public var result: Swift.String?

    public init (
        result: Swift.String? = nil
    )
    {
        self.result = result
    }
}

struct TestWirelessDeviceOutputResponseBody: Swift.Equatable {
    let result: Swift.String?
}

extension TestWirelessDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case result = "Result"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .result)
        result = resultDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because it exceeded the allowed API request rate.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because the resource can't have any more tags.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Name of the resource that exceeds maximum number of tags allowed.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension IoTWirelessClientTypes.TraceContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
        case wirelessDeviceFrameInfo = "WirelessDeviceFrameInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let wirelessDeviceFrameInfo = self.wirelessDeviceFrameInfo {
            try encodeContainer.encode(wirelessDeviceFrameInfo.rawValue, forKey: .wirelessDeviceFrameInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceFrameInfoDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessDeviceFrameInfo.self, forKey: .wirelessDeviceFrameInfo)
        wirelessDeviceFrameInfo = wirelessDeviceFrameInfoDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Trace content for your wireless gateway and wireless device resources.
    public struct TraceContent: Swift.Equatable {
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        public var logLevel: IoTWirelessClientTypes.LogLevel?
        /// FrameInfo of your wireless device resources for the trace content. Use FrameInfo to debug the communication between your LoRaWAN end devices and the network server.
        public var wirelessDeviceFrameInfo: IoTWirelessClientTypes.WirelessDeviceFrameInfo?

        public init (
            logLevel: IoTWirelessClientTypes.LogLevel? = nil,
            wirelessDeviceFrameInfo: IoTWirelessClientTypes.WirelessDeviceFrameInfo? = nil
        )
        {
            self.logLevel = logLevel
            self.wirelessDeviceFrameInfo = wirelessDeviceFrameInfo
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTWirelessClientTypes.UpdateAbpV1_0_x: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fCntStart = "FCntStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fCntStart = self.fCntStart {
            try encodeContainer.encode(fCntStart, forKey: .fCntStart)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fCntStartDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fCntStart)
        fCntStart = fCntStartDecoded
    }
}

extension IoTWirelessClientTypes {
    /// ABP device object for LoRaWAN specification v1.0.x
    public struct UpdateAbpV1_0_x: Swift.Equatable {
        /// The FCnt init value.
        public var fCntStart: Swift.Int?

        public init (
            fCntStart: Swift.Int? = nil
        )
        {
            self.fCntStart = fCntStart
        }
    }

}

extension IoTWirelessClientTypes.UpdateAbpV1_1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fCntStart = "FCntStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fCntStart = self.fCntStart {
            try encodeContainer.encode(fCntStart, forKey: .fCntStart)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fCntStartDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fCntStart)
        fCntStart = fCntStartDecoded
    }
}

extension IoTWirelessClientTypes {
    /// ABP device object for LoRaWAN specification v1.1
    public struct UpdateAbpV1_1: Swift.Equatable {
        /// The FCnt init value.
        public var fCntStart: Swift.Int?

        public init (
            fCntStart: Swift.Int? = nil
        )
        {
            self.fCntStart = fCntStart
        }
    }

}

extension UpdateDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = self.expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

public struct UpdateDestinationInput: Swift.Equatable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The new rule name or topic rule to send messages to.
    public var expression: Swift.String?
    /// The type of value in Expression.
    public var expressionType: IoTWirelessClientTypes.ExpressionType?
    /// The new name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    public var roleArn: Swift.String?

    public init (
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IoTWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
    }
}

struct UpdateDestinationInputBody: Swift.Equatable {
    let expressionType: IoTWirelessClientTypes.ExpressionType?
    let expression: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
}

extension UpdateDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDestinationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateEventConfigurationByResourceTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case deviceRegistrationState = "DeviceRegistrationState"
        case join = "Join"
        case messageDeliveryStatus = "MessageDeliveryStatus"
        case proximity = "Proximity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionStatus = self.connectionStatus {
            try encodeContainer.encode(connectionStatus, forKey: .connectionStatus)
        }
        if let deviceRegistrationState = self.deviceRegistrationState {
            try encodeContainer.encode(deviceRegistrationState, forKey: .deviceRegistrationState)
        }
        if let join = self.join {
            try encodeContainer.encode(join, forKey: .join)
        }
        if let messageDeliveryStatus = self.messageDeliveryStatus {
            try encodeContainer.encode(messageDeliveryStatus, forKey: .messageDeliveryStatus)
        }
        if let proximity = self.proximity {
            try encodeContainer.encode(proximity, forKey: .proximity)
        }
    }
}

extension UpdateEventConfigurationByResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/event-configurations-resource-types"
    }
}

public struct UpdateEventConfigurationByResourceTypesInput: Swift.Equatable {
    /// Connection status resource type event configuration object for enabling and disabling wireless gateway topic.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration?
    /// Device registration state resource type event configuration object for enabling and disabling wireless gateway topic.
    public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration?
    /// Join resource type event configuration object for enabling and disabling wireless device topic.
    public var join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration?
    /// Message delivery status resource type event configuration object for enabling and disabling wireless device topic.
    public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration?
    /// Proximity resource type event configuration object for enabling and disabling wireless gateway topic.
    public var proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration?

    public init (
        connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration? = nil,
        deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration? = nil,
        join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration? = nil,
        messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration? = nil,
        proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.deviceRegistrationState = deviceRegistrationState
        self.join = join
        self.messageDeliveryStatus = messageDeliveryStatus
        self.proximity = proximity
    }
}

struct UpdateEventConfigurationByResourceTypesInputBody: Swift.Equatable {
    let deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration?
    let proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration?
    let join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration?
    let connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration?
    let messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration?
}

extension UpdateEventConfigurationByResourceTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case deviceRegistrationState = "DeviceRegistrationState"
        case join = "Join"
        case messageDeliveryStatus = "MessageDeliveryStatus"
        case proximity = "Proximity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceRegistrationStateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration.self, forKey: .deviceRegistrationState)
        deviceRegistrationState = deviceRegistrationStateDecoded
        let proximityDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration.self, forKey: .proximity)
        proximity = proximityDecoded
        let joinDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.JoinResourceTypeEventConfiguration.self, forKey: .join)
        join = joinDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let messageDeliveryStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration.self, forKey: .messageDeliveryStatus)
        messageDeliveryStatus = messageDeliveryStatusDecoded
    }
}

extension UpdateEventConfigurationByResourceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEventConfigurationByResourceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateEventConfigurationByResourceTypesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEventConfigurationByResourceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateEventConfigurationByResourceTypesOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTWirelessClientTypes.UpdateFPorts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case positioning = "Positioning"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for applicationconfig0 in applications {
                try applicationsContainer.encode(applicationconfig0)
            }
        }
        if let positioning = self.positioning {
            try encodeContainer.encode(positioning, forKey: .positioning)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positioningDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.Positioning.self, forKey: .positioning)
        positioning = positioningDecoded
        let applicationsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.ApplicationConfig?].self, forKey: .applications)
        var applicationsDecoded0:[IoTWirelessClientTypes.ApplicationConfig]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [IoTWirelessClientTypes.ApplicationConfig]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// Object for updating the FPorts information.
    public struct UpdateFPorts: Swift.Equatable {
        /// LoRaWAN application, which can be used for geolocation by activating positioning.
        public var applications: [IoTWirelessClientTypes.ApplicationConfig]?
        /// Positioning FPorts for the ClockSync, Stream, and GNSS functions.
        public var positioning: IoTWirelessClientTypes.Positioning?

        public init (
            applications: [IoTWirelessClientTypes.ApplicationConfig]? = nil,
            positioning: IoTWirelessClientTypes.Positioning? = nil
        )
        {
            self.applications = applications
            self.positioning = positioning
        }
    }

}

extension UpdateFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let firmwareUpdateImage = self.firmwareUpdateImage {
            try encodeContainer.encode(firmwareUpdateImage, forKey: .firmwareUpdateImage)
        }
        if let firmwareUpdateRole = self.firmwareUpdateRole {
            try encodeContainer.encode(firmwareUpdateRole, forKey: .firmwareUpdateRole)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

public struct UpdateFuotaTaskInput: Swift.Equatable {
    /// The description of the new resource.
    public var description: Swift.String?
    /// The S3 URI points to a firmware update image that is to be used with a FUOTA task.
    public var firmwareUpdateImage: Swift.String?
    /// The firmware update role that is to be used with a FUOTA task.
    public var firmwareUpdateRole: Swift.String?
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information used with a FUOTA task.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask?
    /// The name of a FUOTA task.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        firmwareUpdateImage: Swift.String? = nil,
        firmwareUpdateRole: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.firmwareUpdateImage = firmwareUpdateImage
        self.firmwareUpdateRole = firmwareUpdateRole
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct UpdateFuotaTaskInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask?
    let firmwareUpdateImage: Swift.String?
    let firmwareUpdateRole: Swift.String?
}

extension UpdateFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANFuotaTask.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let firmwareUpdateImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateImage)
        firmwareUpdateImage = firmwareUpdateImageDecoded
        let firmwareUpdateRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateRole)
        firmwareUpdateRole = firmwareUpdateRoleDecoded
    }
}

extension UpdateFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFuotaTaskOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateLogLevelsByResourceTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultLogLevel = self.defaultLogLevel {
            try encodeContainer.encode(defaultLogLevel.rawValue, forKey: .defaultLogLevel)
        }
        if let wirelessDeviceLogOptions = wirelessDeviceLogOptions {
            var wirelessDeviceLogOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessDeviceLogOptions)
            for wirelessdevicelogoption0 in wirelessDeviceLogOptions {
                try wirelessDeviceLogOptionsContainer.encode(wirelessdevicelogoption0)
            }
        }
        if let wirelessGatewayLogOptions = wirelessGatewayLogOptions {
            var wirelessGatewayLogOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessGatewayLogOptions)
            for wirelessgatewaylogoption0 in wirelessGatewayLogOptions {
                try wirelessGatewayLogOptionsContainer.encode(wirelessgatewaylogoption0)
            }
        }
    }
}

extension UpdateLogLevelsByResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/log-levels"
    }
}

public struct UpdateLogLevelsByResourceTypesInput: Swift.Equatable {
    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    public var defaultLogLevel: IoTWirelessClientTypes.LogLevel?
    /// The list of wireless device log options.
    public var wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]?
    /// The list of wireless gateway log options.
    public var wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]?

    public init (
        defaultLogLevel: IoTWirelessClientTypes.LogLevel? = nil,
        wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]? = nil,
        wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.wirelessDeviceLogOptions = wirelessDeviceLogOptions
        self.wirelessGatewayLogOptions = wirelessGatewayLogOptions
    }
}

struct UpdateLogLevelsByResourceTypesInputBody: Swift.Equatable {
    let defaultLogLevel: IoTWirelessClientTypes.LogLevel?
    let wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]?
    let wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]?
}

extension UpdateLogLevelsByResourceTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultLogLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .defaultLogLevel)
        defaultLogLevel = defaultLogLevelDecoded
        let wirelessDeviceLogOptionsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessDeviceLogOption?].self, forKey: .wirelessDeviceLogOptions)
        var wirelessDeviceLogOptionsDecoded0:[IoTWirelessClientTypes.WirelessDeviceLogOption]? = nil
        if let wirelessDeviceLogOptionsContainer = wirelessDeviceLogOptionsContainer {
            wirelessDeviceLogOptionsDecoded0 = [IoTWirelessClientTypes.WirelessDeviceLogOption]()
            for structure0 in wirelessDeviceLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessDeviceLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceLogOptions = wirelessDeviceLogOptionsDecoded0
        let wirelessGatewayLogOptionsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessGatewayLogOption?].self, forKey: .wirelessGatewayLogOptions)
        var wirelessGatewayLogOptionsDecoded0:[IoTWirelessClientTypes.WirelessGatewayLogOption]? = nil
        if let wirelessGatewayLogOptionsContainer = wirelessGatewayLogOptionsContainer {
            wirelessGatewayLogOptionsDecoded0 = [IoTWirelessClientTypes.WirelessGatewayLogOption]()
            for structure0 in wirelessGatewayLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessGatewayLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayLogOptions = wirelessGatewayLogOptionsDecoded0
    }
}

extension UpdateLogLevelsByResourceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLogLevelsByResourceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateLogLevelsByResourceTypesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLogLevelsByResourceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLogLevelsByResourceTypesOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())"
    }
}

public struct UpdateMulticastGroupInput: Swift.Equatable {
    /// The description of the new resource.
    public var description: Swift.String?
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information that is to be used with the multicast group.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast?
    /// The name of the multicast group.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct UpdateMulticastGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast?
}

extension UpdateMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANMulticast.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension UpdateMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateMulticastGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateNetworkAnalyzerConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case traceContent = "TraceContent"
        case wirelessDevicesToAdd = "WirelessDevicesToAdd"
        case wirelessDevicesToRemove = "WirelessDevicesToRemove"
        case wirelessGatewaysToAdd = "WirelessGatewaysToAdd"
        case wirelessGatewaysToRemove = "WirelessGatewaysToRemove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let traceContent = self.traceContent {
            try encodeContainer.encode(traceContent, forKey: .traceContent)
        }
        if let wirelessDevicesToAdd = wirelessDevicesToAdd {
            var wirelessDevicesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessDevicesToAdd)
            for wirelessdeviceid0 in wirelessDevicesToAdd {
                try wirelessDevicesToAddContainer.encode(wirelessdeviceid0)
            }
        }
        if let wirelessDevicesToRemove = wirelessDevicesToRemove {
            var wirelessDevicesToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessDevicesToRemove)
            for wirelessdeviceid0 in wirelessDevicesToRemove {
                try wirelessDevicesToRemoveContainer.encode(wirelessdeviceid0)
            }
        }
        if let wirelessGatewaysToAdd = wirelessGatewaysToAdd {
            var wirelessGatewaysToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessGatewaysToAdd)
            for wirelessgatewayid0 in wirelessGatewaysToAdd {
                try wirelessGatewaysToAddContainer.encode(wirelessgatewayid0)
            }
        }
        if let wirelessGatewaysToRemove = wirelessGatewaysToRemove {
            var wirelessGatewaysToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessGatewaysToRemove)
            for wirelessgatewayid0 in wirelessGatewaysToRemove {
                try wirelessGatewaysToRemoveContainer.encode(wirelessgatewayid0)
            }
        }
    }
}

extension UpdateNetworkAnalyzerConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationName = configurationName else {
            return nil
        }
        return "/network-analyzer-configurations/\(configurationName.urlPercentEncoding())"
    }
}

public struct UpdateNetworkAnalyzerConfigurationInput: Swift.Equatable {
    /// Name of the network analyzer configuration.
    /// This member is required.
    public var configurationName: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// Trace content for your wireless gateway and wireless device resources.
    public var traceContent: IoTWirelessClientTypes.TraceContent?
    /// Wireless device resources to add to the network analyzer configuration. Provide the WirelessDeviceId of the resource to add in the input array.
    public var wirelessDevicesToAdd: [Swift.String]?
    /// Wireless device resources to remove from the network analyzer configuration. Provide the WirelessDeviceId of the resources to remove in the input array.
    public var wirelessDevicesToRemove: [Swift.String]?
    /// Wireless gateway resources to add to the network analyzer configuration. Provide the WirelessGatewayId of the resource to add in the input array.
    public var wirelessGatewaysToAdd: [Swift.String]?
    /// Wireless gateway resources to remove from the network analyzer configuration. Provide the WirelessGatewayId of the resources to remove in the input array.
    public var wirelessGatewaysToRemove: [Swift.String]?

    public init (
        configurationName: Swift.String? = nil,
        description: Swift.String? = nil,
        traceContent: IoTWirelessClientTypes.TraceContent? = nil,
        wirelessDevicesToAdd: [Swift.String]? = nil,
        wirelessDevicesToRemove: [Swift.String]? = nil,
        wirelessGatewaysToAdd: [Swift.String]? = nil,
        wirelessGatewaysToRemove: [Swift.String]? = nil
    )
    {
        self.configurationName = configurationName
        self.description = description
        self.traceContent = traceContent
        self.wirelessDevicesToAdd = wirelessDevicesToAdd
        self.wirelessDevicesToRemove = wirelessDevicesToRemove
        self.wirelessGatewaysToAdd = wirelessGatewaysToAdd
        self.wirelessGatewaysToRemove = wirelessGatewaysToRemove
    }
}

struct UpdateNetworkAnalyzerConfigurationInputBody: Swift.Equatable {
    let traceContent: IoTWirelessClientTypes.TraceContent?
    let wirelessDevicesToAdd: [Swift.String]?
    let wirelessDevicesToRemove: [Swift.String]?
    let wirelessGatewaysToAdd: [Swift.String]?
    let wirelessGatewaysToRemove: [Swift.String]?
    let description: Swift.String?
}

extension UpdateNetworkAnalyzerConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case traceContent = "TraceContent"
        case wirelessDevicesToAdd = "WirelessDevicesToAdd"
        case wirelessDevicesToRemove = "WirelessDevicesToRemove"
        case wirelessGatewaysToAdd = "WirelessGatewaysToAdd"
        case wirelessGatewaysToRemove = "WirelessGatewaysToRemove"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceContentDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.TraceContent.self, forKey: .traceContent)
        traceContent = traceContentDecoded
        let wirelessDevicesToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessDevicesToAdd)
        var wirelessDevicesToAddDecoded0:[Swift.String]? = nil
        if let wirelessDevicesToAddContainer = wirelessDevicesToAddContainer {
            wirelessDevicesToAddDecoded0 = [Swift.String]()
            for string0 in wirelessDevicesToAddContainer {
                if let string0 = string0 {
                    wirelessDevicesToAddDecoded0?.append(string0)
                }
            }
        }
        wirelessDevicesToAdd = wirelessDevicesToAddDecoded0
        let wirelessDevicesToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessDevicesToRemove)
        var wirelessDevicesToRemoveDecoded0:[Swift.String]? = nil
        if let wirelessDevicesToRemoveContainer = wirelessDevicesToRemoveContainer {
            wirelessDevicesToRemoveDecoded0 = [Swift.String]()
            for string0 in wirelessDevicesToRemoveContainer {
                if let string0 = string0 {
                    wirelessDevicesToRemoveDecoded0?.append(string0)
                }
            }
        }
        wirelessDevicesToRemove = wirelessDevicesToRemoveDecoded0
        let wirelessGatewaysToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessGatewaysToAdd)
        var wirelessGatewaysToAddDecoded0:[Swift.String]? = nil
        if let wirelessGatewaysToAddContainer = wirelessGatewaysToAddContainer {
            wirelessGatewaysToAddDecoded0 = [Swift.String]()
            for string0 in wirelessGatewaysToAddContainer {
                if let string0 = string0 {
                    wirelessGatewaysToAddDecoded0?.append(string0)
                }
            }
        }
        wirelessGatewaysToAdd = wirelessGatewaysToAddDecoded0
        let wirelessGatewaysToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessGatewaysToRemove)
        var wirelessGatewaysToRemoveDecoded0:[Swift.String]? = nil
        if let wirelessGatewaysToRemoveContainer = wirelessGatewaysToRemoveContainer {
            wirelessGatewaysToRemoveDecoded0 = [Swift.String]()
            for string0 in wirelessGatewaysToRemoveContainer {
                if let string0 = string0 {
                    wirelessGatewaysToRemoveDecoded0?.append(string0)
                }
            }
        }
        wirelessGatewaysToRemove = wirelessGatewaysToRemoveDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateNetworkAnalyzerConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNetworkAnalyzerConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateNetworkAnalyzerConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNetworkAnalyzerConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateNetworkAnalyzerConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdatePartnerAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }
}

extension UpdatePartnerAccountInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let partnerType = partnerType else {
                let message = "Creating a URL Query Item failed. partnerType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            items.append(partnerTypeQueryItem)
            return items
        }
    }
}

extension UpdatePartnerAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let partnerAccountId = partnerAccountId else {
            return nil
        }
        return "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
    }
}

public struct UpdatePartnerAccountInput: Swift.Equatable {
    /// The ID of the partner account to update.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IoTWirelessClientTypes.PartnerType?
    /// The Sidewalk account credentials.
    /// This member is required.
    public var sidewalk: IoTWirelessClientTypes.SidewalkUpdateAccount?

    public init (
        partnerAccountId: Swift.String? = nil,
        partnerType: IoTWirelessClientTypes.PartnerType? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkUpdateAccount? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
        self.sidewalk = sidewalk
    }
}

struct UpdatePartnerAccountInputBody: Swift.Equatable {
    let sidewalk: IoTWirelessClientTypes.SidewalkUpdateAccount?
}

extension UpdatePartnerAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkUpdateAccount.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension UpdatePartnerAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePartnerAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePartnerAccountOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePartnerAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePartnerAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdatePositionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case position = "Position"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for positioncoordinatevalue0 in position {
                try positionContainer.encode(positioncoordinatevalue0)
            }
        }
    }
}

extension UpdatePositionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension UpdatePositionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/positions/\(resourceIdentifier.urlPercentEncoding())"
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct UpdatePositionInput: Swift.Equatable {
    /// The position information of the resource.
    /// This member is required.
    public var position: [Swift.Float]?
    /// Resource identifier of the resource for which position is updated.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// Resource type of the resource for which position is updated.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init (
        position: [Swift.Float]? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.position = position
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct UpdatePositionInputBody: Swift.Equatable {
    let position: [Swift.Float]?
}

extension UpdatePositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case position = "Position"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positionContainer = try containerValues.decodeIfPresent([Swift.Float?].self, forKey: .position)
        var positionDecoded0:[Swift.Float]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Float]()
            for float0 in positionContainer {
                if let float0 = float0 {
                    positionDecoded0?.append(float0)
                }
            }
        }
        position = positionDecoded0
    }
}

extension UpdatePositionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePositionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePositionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePositionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct UpdatePositionOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateResourceEventConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case deviceRegistrationState = "DeviceRegistrationState"
        case join = "Join"
        case messageDeliveryStatus = "MessageDeliveryStatus"
        case proximity = "Proximity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionStatus = self.connectionStatus {
            try encodeContainer.encode(connectionStatus, forKey: .connectionStatus)
        }
        if let deviceRegistrationState = self.deviceRegistrationState {
            try encodeContainer.encode(deviceRegistrationState, forKey: .deviceRegistrationState)
        }
        if let join = self.join {
            try encodeContainer.encode(join, forKey: .join)
        }
        if let messageDeliveryStatus = self.messageDeliveryStatus {
            try encodeContainer.encode(messageDeliveryStatus, forKey: .messageDeliveryStatus)
        }
        if let proximity = self.proximity {
            try encodeContainer.encode(proximity, forKey: .proximity)
        }
    }
}

extension UpdateResourceEventConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let partnerType = partnerType {
                let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
                items.append(partnerTypeQueryItem)
            }
            guard let identifierType = identifierType else {
                let message = "Creating a URL Query Item failed. identifierType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let identifierTypeQueryItem = ClientRuntime.URLQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
            items.append(identifierTypeQueryItem)
            return items
        }
    }
}

extension UpdateResourceEventConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/event-configurations/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateResourceEventConfigurationInput: Swift.Equatable {
    /// Event configuration for the connection status event.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration?
    /// Event configuration for the device registration state event.
    public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
    /// Resource identifier to opt in for event messaging.
    /// This member is required.
    public var identifier: Swift.String?
    /// Identifier type of the particular resource identifier for event configuration.
    /// This member is required.
    public var identifierType: IoTWirelessClientTypes.IdentifierType?
    /// Event configuration for the join event.
    public var join: IoTWirelessClientTypes.JoinEventConfiguration?
    /// Event configuration for the message delivery status event.
    public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration?
    /// Partner type of the resource if the identifier type is PartnerAccountId
    public var partnerType: IoTWirelessClientTypes.EventNotificationPartnerType?
    /// Event configuration for the proximity event.
    public var proximity: IoTWirelessClientTypes.ProximityEventConfiguration?

    public init (
        connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration? = nil,
        deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration? = nil,
        identifier: Swift.String? = nil,
        identifierType: IoTWirelessClientTypes.IdentifierType? = nil,
        join: IoTWirelessClientTypes.JoinEventConfiguration? = nil,
        messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration? = nil,
        partnerType: IoTWirelessClientTypes.EventNotificationPartnerType? = nil,
        proximity: IoTWirelessClientTypes.ProximityEventConfiguration? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.deviceRegistrationState = deviceRegistrationState
        self.identifier = identifier
        self.identifierType = identifierType
        self.join = join
        self.messageDeliveryStatus = messageDeliveryStatus
        self.partnerType = partnerType
        self.proximity = proximity
    }
}

struct UpdateResourceEventConfigurationInputBody: Swift.Equatable {
    let deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
    let proximity: IoTWirelessClientTypes.ProximityEventConfiguration?
    let join: IoTWirelessClientTypes.JoinEventConfiguration?
    let connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration?
    let messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration?
}

extension UpdateResourceEventConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case deviceRegistrationState = "DeviceRegistrationState"
        case join = "Join"
        case messageDeliveryStatus = "MessageDeliveryStatus"
        case proximity = "Proximity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceRegistrationStateDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration.self, forKey: .deviceRegistrationState)
        deviceRegistrationState = deviceRegistrationStateDecoded
        let proximityDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ProximityEventConfiguration.self, forKey: .proximity)
        proximity = proximityDecoded
        let joinDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.JoinEventConfiguration.self, forKey: .join)
        join = joinDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.ConnectionStatusEventConfiguration.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let messageDeliveryStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration.self, forKey: .messageDeliveryStatus)
        messageDeliveryStatus = messageDeliveryStatusDecoded
    }
}

extension UpdateResourceEventConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceEventConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateResourceEventConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceEventConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResourceEventConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

public struct UpdateResourcePositionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourcePositionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourcePositionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateResourcePositionOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let geoJsonPayload = input.operationInput.geoJsonPayload {
            let geoJsonPayloaddata = geoJsonPayload
            let geoJsonPayloadbody = ClientRuntime.HttpBody.data(geoJsonPayloaddata)
            input.builder.withBody(geoJsonPayloadbody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourcePositionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourcePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateResourcePositionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geoJsonPayload = "GeoJsonPayload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geoJsonPayload = self.geoJsonPayload {
            try encodeContainer.encode(geoJsonPayload.base64EncodedString(), forKey: .geoJsonPayload)
        }
    }
}

extension UpdateResourcePositionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension UpdateResourcePositionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/resource-positions/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateResourcePositionInput: Swift.Equatable {
    /// The position information of the resource, displayed as a JSON payload. The payload uses the GeoJSON format, which a format that's used to encode geographic data structures. For more information, see [GeoJSON](https://geojson.org/).
    public var geoJsonPayload: ClientRuntime.Data?
    /// The identifier of the resource for which position information is updated. It can be the wireless device ID or the wireless gateway ID depending on the resource type.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of resource for which position information is updated, which can be a wireless device or a wireless gateway.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init (
        geoJsonPayload: ClientRuntime.Data? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.geoJsonPayload = geoJsonPayload
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct UpdateResourcePositionInputBody: Swift.Equatable {
    let geoJsonPayload: ClientRuntime.Data?
}

extension UpdateResourcePositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geoJsonPayload = "GeoJsonPayload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoJsonPayloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .geoJsonPayload)
        geoJsonPayload = geoJsonPayloadDecoded
    }
}

extension UpdateResourcePositionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourcePositionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateResourcePositionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourcePositionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResourcePositionOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateWirelessDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case positioning = "Positioning"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let positioning = self.positioning {
            try encodeContainer.encode(positioning.rawValue, forKey: .positioning)
        }
    }
}

extension UpdateWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWirelessDeviceInput: Swift.Equatable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The name of the new destination for the device.
    public var destinationName: Swift.String?
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The updated wireless device's configuration.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateDevice?
    /// The new name of the resource.
    public var name: Swift.String?
    /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
    public var positioning: IoTWirelessClientTypes.PositioningConfigStatus?

    public init (
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateDevice? = nil,
        name: Swift.String? = nil,
        positioning: IoTWirelessClientTypes.PositioningConfigStatus? = nil
    )
    {
        self.description = description
        self.destinationName = destinationName
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.positioning = positioning
    }
}

struct UpdateWirelessDeviceInputBody: Swift.Equatable {
    let destinationName: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateDevice?
    let positioning: IoTWirelessClientTypes.PositioningConfigStatus?
}

extension UpdateWirelessDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case positioning = "Positioning"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANUpdateDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let positioningDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.PositioningConfigStatus.self, forKey: .positioning)
        positioning = positioningDecoded
    }
}

extension UpdateWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWirelessDeviceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateWirelessGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case joinEuiFilters = "JoinEuiFilters"
        case name = "Name"
        case netIdFilters = "NetIdFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let joinEuiFilters = joinEuiFilters {
            var joinEuiFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .joinEuiFilters)
            for joineuirange0 in joinEuiFilters {
                var joineuirange0Container = joinEuiFiltersContainer.nestedUnkeyedContainer()
                for joineui1 in joineuirange0 {
                    try joineuirange0Container.encode(joineui1)
                }
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let netIdFilters = netIdFilters {
            var netIdFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .netIdFilters)
            for netid0 in netIdFilters {
                try netIdFiltersContainer.encode(netid0)
            }
        }
    }
}

extension UpdateWirelessGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWirelessGatewayInput: Swift.Equatable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.
    public var joinEuiFilters: [[Swift.String]]?
    /// The new name of the resource.
    public var name: Swift.String?
    /// A list of NetId values that are used by LoRa gateways to filter the uplink frames.
    public var netIdFilters: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        joinEuiFilters: [[Swift.String]]? = nil,
        name: Swift.String? = nil,
        netIdFilters: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.joinEuiFilters = joinEuiFilters
        self.name = name
        self.netIdFilters = netIdFilters
    }
}

struct UpdateWirelessGatewayInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let joinEuiFilters: [[Swift.String]]?
    let netIdFilters: [Swift.String]?
}

extension UpdateWirelessGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case joinEuiFilters = "JoinEuiFilters"
        case name = "Name"
        case netIdFilters = "NetIdFilters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let joinEuiFiltersContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .joinEuiFilters)
        var joinEuiFiltersDecoded0:[[Swift.String]]? = nil
        if let joinEuiFiltersContainer = joinEuiFiltersContainer {
            joinEuiFiltersDecoded0 = [[Swift.String]]()
            for list0 in joinEuiFiltersContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    joinEuiFiltersDecoded0?.append(list0Decoded0)
                }
            }
        }
        joinEuiFilters = joinEuiFiltersDecoded0
        let netIdFiltersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .netIdFilters)
        var netIdFiltersDecoded0:[Swift.String]? = nil
        if let netIdFiltersContainer = netIdFiltersContainer {
            netIdFiltersDecoded0 = [Swift.String]()
            for string0 in netIdFiltersContainer {
                if let string0 = string0 {
                    netIdFiltersDecoded0?.append(string0)
                }
            }
        }
        netIdFilters = netIdFiltersDecoded0
    }
}

extension UpdateWirelessGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWirelessGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWirelessGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWirelessGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWirelessGatewayOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
        case updateDataRole = "UpdateDataRole"
        case updateDataSource = "UpdateDataSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let updateDataRole = self.updateDataRole {
            try encodeContainer.encode(updateDataRole, forKey: .updateDataRole)
        }
        if let updateDataSource = self.updateDataSource {
            try encodeContainer.encode(updateDataSource, forKey: .updateDataSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateDataSource)
        updateDataSource = updateDataSourceDecoded
        let updateDataRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateDataRole)
        updateDataRole = updateDataRoleDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension IoTWirelessClientTypes {
    /// UpdateWirelessGatewayTaskCreate object.
    public struct UpdateWirelessGatewayTaskCreate: Swift.Equatable {
        /// The properties that relate to the LoRaWAN wireless gateway.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate?
        /// The IAM role used to read data from the S3 bucket.
        public var updateDataRole: Swift.String?
        /// The link to the S3 bucket.
        public var updateDataSource: Swift.String?

        public init (
            loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate? = nil,
            updateDataRole: Swift.String? = nil,
            updateDataSource: Swift.String? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.updateDataRole = updateDataRole
            self.updateDataSource = updateDataSource
        }
    }

}

extension IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTWirelessClientTypes {
    /// UpdateWirelessGatewayTaskEntry object.
    public struct UpdateWirelessGatewayTaskEntry: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the new wireless gateway task entry.
        public var id: Swift.String?
        /// The properties that relate to the LoRaWAN wireless gateway.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.loRaWAN = loRaWAN
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input did not meet the specified constraints.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTWirelessClientTypes.WcdmaLocalId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case psc = "Psc"
        case uarfcndl = "Uarfcndl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let psc = self.psc {
            try encodeContainer.encode(psc, forKey: .psc)
        }
        if let uarfcndl = self.uarfcndl {
            try encodeContainer.encode(uarfcndl, forKey: .uarfcndl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uarfcndlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uarfcndl)
        uarfcndl = uarfcndlDecoded
        let pscDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .psc)
        psc = pscDecoded
    }
}

extension IoTWirelessClientTypes {
    /// WCDMA local identification (local ID) information.
    public struct WcdmaLocalId: Swift.Equatable {
        /// Primary Scrambling Code.
        /// This member is required.
        public var psc: Swift.Int?
        /// WCDMA UTRA Absolute RF Channel Number downlink.
        /// This member is required.
        public var uarfcndl: Swift.Int?

        public init (
            psc: Swift.Int? = nil,
            uarfcndl: Swift.Int? = nil
        )
        {
            self.psc = psc
            self.uarfcndl = uarfcndl
        }
    }

}

extension IoTWirelessClientTypes.WcdmaNmrObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pathLoss = "PathLoss"
        case psc = "Psc"
        case rscp = "Rscp"
        case uarfcndl = "Uarfcndl"
        case utranCid = "UtranCid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pathLoss = self.pathLoss {
            try encodeContainer.encode(pathLoss, forKey: .pathLoss)
        }
        if let psc = self.psc {
            try encodeContainer.encode(psc, forKey: .psc)
        }
        if let rscp = self.rscp {
            try encodeContainer.encode(rscp, forKey: .rscp)
        }
        if let uarfcndl = self.uarfcndl {
            try encodeContainer.encode(uarfcndl, forKey: .uarfcndl)
        }
        if let utranCid = self.utranCid {
            try encodeContainer.encode(utranCid, forKey: .utranCid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uarfcndlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uarfcndl)
        uarfcndl = uarfcndlDecoded
        let pscDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .psc)
        psc = pscDecoded
        let utranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .utranCid)
        utranCid = utranCidDecoded
        let rscpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rscp)
        rscp = rscpDecoded
        let pathLossDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pathLoss)
        pathLoss = pathLossDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Network Measurement Reports.
    public struct WcdmaNmrObj: Swift.Equatable {
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public var pathLoss: Swift.Int?
        /// Primary Scrambling Code.
        /// This member is required.
        public var psc: Swift.Int?
        /// Received Signal Code Power (signal power) (dBm)
        public var rscp: Swift.Int?
        /// WCDMA UTRA Absolute RF Channel Number downlink.
        /// This member is required.
        public var uarfcndl: Swift.Int?
        /// UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var utranCid: Swift.Int?

        public init (
            pathLoss: Swift.Int? = nil,
            psc: Swift.Int? = nil,
            rscp: Swift.Int? = nil,
            uarfcndl: Swift.Int? = nil,
            utranCid: Swift.Int? = nil
        )
        {
            self.pathLoss = pathLoss
            self.psc = psc
            self.rscp = rscp
            self.uarfcndl = uarfcndl
            self.utranCid = utranCid
        }
    }

}

extension IoTWirelessClientTypes.WcdmaObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lac = "Lac"
        case mcc = "Mcc"
        case mnc = "Mnc"
        case pathLoss = "PathLoss"
        case rscp = "Rscp"
        case utranCid = "UtranCid"
        case wcdmaLocalId = "WcdmaLocalId"
        case wcdmaNmr = "WcdmaNmr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lac = self.lac {
            try encodeContainer.encode(lac, forKey: .lac)
        }
        if let mcc = self.mcc {
            try encodeContainer.encode(mcc, forKey: .mcc)
        }
        if let mnc = self.mnc {
            try encodeContainer.encode(mnc, forKey: .mnc)
        }
        if let pathLoss = self.pathLoss {
            try encodeContainer.encode(pathLoss, forKey: .pathLoss)
        }
        if let rscp = self.rscp {
            try encodeContainer.encode(rscp, forKey: .rscp)
        }
        if let utranCid = self.utranCid {
            try encodeContainer.encode(utranCid, forKey: .utranCid)
        }
        if let wcdmaLocalId = self.wcdmaLocalId {
            try encodeContainer.encode(wcdmaLocalId, forKey: .wcdmaLocalId)
        }
        if let wcdmaNmr = wcdmaNmr {
            var wcdmaNmrContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wcdmaNmr)
            for wcdmanmrobj0 in wcdmaNmr {
                try wcdmaNmrContainer.encode(wcdmanmrobj0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mccDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mcc)
        mcc = mccDecoded
        let mncDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mnc)
        mnc = mncDecoded
        let lacDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lac)
        lac = lacDecoded
        let utranCidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .utranCid)
        utranCid = utranCidDecoded
        let wcdmaLocalIdDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WcdmaLocalId.self, forKey: .wcdmaLocalId)
        wcdmaLocalId = wcdmaLocalIdDecoded
        let rscpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rscp)
        rscp = rscpDecoded
        let pathLossDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pathLoss)
        pathLoss = pathLossDecoded
        let wcdmaNmrContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WcdmaNmrObj?].self, forKey: .wcdmaNmr)
        var wcdmaNmrDecoded0:[IoTWirelessClientTypes.WcdmaNmrObj]? = nil
        if let wcdmaNmrContainer = wcdmaNmrContainer {
            wcdmaNmrDecoded0 = [IoTWirelessClientTypes.WcdmaNmrObj]()
            for structure0 in wcdmaNmrContainer {
                if let structure0 = structure0 {
                    wcdmaNmrDecoded0?.append(structure0)
                }
            }
        }
        wcdmaNmr = wcdmaNmrDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// WCDMA.
    public struct WcdmaObj: Swift.Equatable {
        /// Location Area Code.
        public var lac: Swift.Int?
        /// Mobile Country Code.
        /// This member is required.
        public var mcc: Swift.Int?
        /// Mobile Network Code.
        /// This member is required.
        public var mnc: Swift.Int?
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public var pathLoss: Swift.Int?
        /// Received Signal Code Power (signal power) (dBm).
        public var rscp: Swift.Int?
        /// UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var utranCid: Swift.Int?
        /// WCDMA local ID information.
        public var wcdmaLocalId: IoTWirelessClientTypes.WcdmaLocalId?
        /// WCDMA object for network measurement reports.
        public var wcdmaNmr: [IoTWirelessClientTypes.WcdmaNmrObj]?

        public init (
            lac: Swift.Int? = nil,
            mcc: Swift.Int? = nil,
            mnc: Swift.Int? = nil,
            pathLoss: Swift.Int? = nil,
            rscp: Swift.Int? = nil,
            utranCid: Swift.Int? = nil,
            wcdmaLocalId: IoTWirelessClientTypes.WcdmaLocalId? = nil,
            wcdmaNmr: [IoTWirelessClientTypes.WcdmaNmrObj]? = nil
        )
        {
            self.lac = lac
            self.mcc = mcc
            self.mnc = mnc
            self.pathLoss = pathLoss
            self.rscp = rscp
            self.utranCid = utranCid
            self.wcdmaLocalId = wcdmaLocalId
            self.wcdmaNmr = wcdmaNmr
        }
    }

}

extension IoTWirelessClientTypes.WiFiAccessPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case macAddress = "MacAddress"
        case rss = "Rss"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let macAddress = self.macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
        if let rss = self.rss {
            try encodeContainer.encode(rss, forKey: .rss)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let rssDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rss)
        rss = rssDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Wi-Fi access point.
    public struct WiFiAccessPoint: Swift.Equatable {
        /// Wi-Fi MAC Address.
        /// This member is required.
        public var macAddress: Swift.String?
        /// Recived signal strength of the WLAN measurement data.
        /// This member is required.
        public var rss: Swift.Int?

        public init (
            macAddress: Swift.String? = nil,
            rss: Swift.Int? = nil
        )
        {
            self.macAddress = macAddress
            self.rss = rss
        }
    }

}

extension IoTWirelessClientTypes {
    /// The event for a log message, if the log message is tied to a wireless device.
    public enum WirelessDeviceEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case downlinkData
        case join
        case registration
        case rejoin
        case uplinkData
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceEvent] {
            return [
                .downlinkData,
                .join,
                .registration,
                .rejoin,
                .uplinkData,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .downlinkData: return "Downlink_Data"
            case .join: return "Join"
            case .registration: return "Registration"
            case .rejoin: return "Rejoin"
            case .uplinkData: return "Uplink_Data"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceEvent(rawValue: rawValue) ?? WirelessDeviceEvent.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.WirelessDeviceEventLogOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event = "Event"
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessDeviceEvent.self, forKey: .event)
        event = eventDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The log options for a wireless device event and can be used to set log levels for a specific wireless device event. For a LoRaWAN device, possible events for a log messsage are: Join, Rejoin, Downlink_Data, and Uplink_Data. For a Sidewalk device, possible events for a log message are Registration, Downlink_Data, and Uplink_Data.
    public struct WirelessDeviceEventLogOption: Swift.Equatable {
        /// The event for a log message, if the log message is tied to a wireless device.
        /// This member is required.
        public var event: IoTWirelessClientTypes.WirelessDeviceEvent?
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        /// This member is required.
        public var logLevel: IoTWirelessClientTypes.LogLevel?

        public init (
            event: IoTWirelessClientTypes.WirelessDeviceEvent? = nil,
            logLevel: IoTWirelessClientTypes.LogLevel? = nil
        )
        {
            self.event = event
            self.logLevel = logLevel
        }
    }

}

extension IoTWirelessClientTypes {
    /// FrameInfo of your wireless device resources for the trace content. Use FrameInfo to debug the communication between your LoRaWAN end devices and the network server.
    public enum WirelessDeviceFrameInfo: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceFrameInfo] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceFrameInfo(rawValue: rawValue) ?? WirelessDeviceFrameInfo.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum WirelessDeviceIdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deveui
        case sidewalkmanufacturingsn
        case thingname
        case wirelessdeviceid
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceIdType] {
            return [
                .deveui,
                .sidewalkmanufacturingsn,
                .thingname,
                .wirelessdeviceid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deveui: return "DevEui"
            case .sidewalkmanufacturingsn: return "SidewalkManufacturingSn"
            case .thingname: return "ThingName"
            case .wirelessdeviceid: return "WirelessDeviceId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceIdType(rawValue: rawValue) ?? WirelessDeviceIdType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.WirelessDeviceLogOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case logLevel = "LogLevel"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for wirelessdeviceeventlogoption0 in events {
                try eventsContainer.encode(wirelessdeviceeventlogoption0)
            }
        }
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let eventsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessDeviceEventLogOption?].self, forKey: .events)
        var eventsDecoded0:[IoTWirelessClientTypes.WirelessDeviceEventLogOption]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IoTWirelessClientTypes.WirelessDeviceEventLogOption]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// The log options for wireless devices and can be used to set log levels for a specific type of wireless device.
    public struct WirelessDeviceLogOption: Swift.Equatable {
        /// The list of wireless device event log options.
        public var events: [IoTWirelessClientTypes.WirelessDeviceEventLogOption]?
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        /// This member is required.
        public var logLevel: IoTWirelessClientTypes.LogLevel?
        /// The wireless device type.
        /// This member is required.
        public var type: IoTWirelessClientTypes.WirelessDeviceType?

        public init (
            events: [IoTWirelessClientTypes.WirelessDeviceEventLogOption]? = nil,
            logLevel: IoTWirelessClientTypes.LogLevel? = nil,
            type: IoTWirelessClientTypes.WirelessDeviceType? = nil
        )
        {
            self.events = events
            self.logLevel = logLevel
            self.type = type
        }
    }

}

extension IoTWirelessClientTypes.WirelessDeviceStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case destinationName = "DestinationName"
        case fuotaDeviceStatus = "FuotaDeviceStatus"
        case id = "Id"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case mcGroupId = "McGroupId"
        case multicastDeviceStatus = "MulticastDeviceStatus"
        case name = "Name"
        case sidewalk = "Sidewalk"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let fuotaDeviceStatus = self.fuotaDeviceStatus {
            try encodeContainer.encode(fuotaDeviceStatus.rawValue, forKey: .fuotaDeviceStatus)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUplinkReceivedAt = self.lastUplinkReceivedAt {
            try encodeContainer.encode(lastUplinkReceivedAt, forKey: .lastUplinkReceivedAt)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let mcGroupId = self.mcGroupId {
            try encodeContainer.encode(mcGroupId, forKey: .mcGroupId)
        }
        if let multicastDeviceStatus = self.multicastDeviceStatus {
            try encodeContainer.encode(multicastDeviceStatus, forKey: .multicastDeviceStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANListDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkListDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let fuotaDeviceStatusDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.FuotaDeviceStatus.self, forKey: .fuotaDeviceStatus)
        fuotaDeviceStatus = fuotaDeviceStatusDecoded
        let multicastDeviceStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multicastDeviceStatus)
        multicastDeviceStatus = multicastDeviceStatusDecoded
        let mcGroupIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mcGroupId)
        mcGroupId = mcGroupIdDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about a wireless device's operation.
    public struct WirelessDeviceStatistics: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The name of the destination to which the device is assigned.
        public var destinationName: Swift.String?
        /// The status of a wireless device in a FUOTA task.
        public var fuotaDeviceStatus: IoTWirelessClientTypes.FuotaDeviceStatus?
        /// The ID of the wireless device reporting the data.
        public var id: Swift.String?
        /// The date and time when the most recent uplink was received.
        public var lastUplinkReceivedAt: Swift.String?
        /// LoRaWAN device info.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANListDevice?
        /// Id of the multicast group.
        public var mcGroupId: Swift.Int?
        /// The status of the wireless device in the multicast group.
        public var multicastDeviceStatus: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?
        /// The Sidewalk account credentials.
        public var sidewalk: IoTWirelessClientTypes.SidewalkListDevice?
        /// The wireless device type.
        public var type: IoTWirelessClientTypes.WirelessDeviceType?

        public init (
            arn: Swift.String? = nil,
            destinationName: Swift.String? = nil,
            fuotaDeviceStatus: IoTWirelessClientTypes.FuotaDeviceStatus? = nil,
            id: Swift.String? = nil,
            lastUplinkReceivedAt: Swift.String? = nil,
            loRaWAN: IoTWirelessClientTypes.LoRaWANListDevice? = nil,
            mcGroupId: Swift.Int? = nil,
            multicastDeviceStatus: Swift.String? = nil,
            name: Swift.String? = nil,
            sidewalk: IoTWirelessClientTypes.SidewalkListDevice? = nil,
            type: IoTWirelessClientTypes.WirelessDeviceType? = nil
        )
        {
            self.arn = arn
            self.destinationName = destinationName
            self.fuotaDeviceStatus = fuotaDeviceStatus
            self.id = id
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.loRaWAN = loRaWAN
            self.mcGroupId = mcGroupId
            self.multicastDeviceStatus = multicastDeviceStatus
            self.name = name
            self.sidewalk = sidewalk
            self.type = type
        }
    }

}

extension IoTWirelessClientTypes {
    public enum WirelessDeviceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lorawan
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceType] {
            return [
                .lorawan,
                .sidewalk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lorawan: return "LoRaWAN"
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceType(rawValue: rawValue) ?? WirelessDeviceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    /// The event for a log message, if the log message is tied to a wireless gateway.
    public enum WirelessGatewayEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cupsRequest
        case certificate
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayEvent] {
            return [
                .cupsRequest,
                .certificate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cupsRequest: return "CUPS_Request"
            case .certificate: return "Certificate"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayEvent(rawValue: rawValue) ?? WirelessGatewayEvent.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.WirelessGatewayEventLogOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event = "Event"
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessGatewayEvent.self, forKey: .event)
        event = eventDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension IoTWirelessClientTypes {
    /// The log options for a wireless gateway event and can be used to set log levels for a specific wireless gateway event. For a LoRaWAN gateway, possible events for a log message are CUPS_Request and Certificate.
    public struct WirelessGatewayEventLogOption: Swift.Equatable {
        /// The event for a log message, if the log message is tied to a wireless gateway.
        /// This member is required.
        public var event: IoTWirelessClientTypes.WirelessGatewayEvent?
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        /// This member is required.
        public var logLevel: IoTWirelessClientTypes.LogLevel?

        public init (
            event: IoTWirelessClientTypes.WirelessGatewayEvent? = nil,
            logLevel: IoTWirelessClientTypes.LogLevel? = nil
        )
        {
            self.event = event
            self.logLevel = logLevel
        }
    }

}

extension IoTWirelessClientTypes {
    public enum WirelessGatewayIdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gatewayeui
        case thingname
        case wirelessgatewayid
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayIdType] {
            return [
                .gatewayeui,
                .thingname,
                .wirelessgatewayid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gatewayeui: return "GatewayEui"
            case .thingname: return "ThingName"
            case .wirelessgatewayid: return "WirelessGatewayId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayIdType(rawValue: rawValue) ?? WirelessGatewayIdType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.WirelessGatewayLogOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case logLevel = "LogLevel"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for wirelessgatewayeventlogoption0 in events {
                try eventsContainer.encode(wirelessgatewayeventlogoption0)
            }
        }
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.WirelessGatewayType.self, forKey: .type)
        type = typeDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let eventsContainer = try containerValues.decodeIfPresent([IoTWirelessClientTypes.WirelessGatewayEventLogOption?].self, forKey: .events)
        var eventsDecoded0:[IoTWirelessClientTypes.WirelessGatewayEventLogOption]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IoTWirelessClientTypes.WirelessGatewayEventLogOption]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension IoTWirelessClientTypes {
    /// The log options for wireless gateways and can be used to set log levels for a specific type of wireless gateway.
    public struct WirelessGatewayLogOption: Swift.Equatable {
        /// The list of wireless gateway event log options.
        public var events: [IoTWirelessClientTypes.WirelessGatewayEventLogOption]?
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        /// This member is required.
        public var logLevel: IoTWirelessClientTypes.LogLevel?
        /// The wireless gateway type.
        /// This member is required.
        public var type: IoTWirelessClientTypes.WirelessGatewayType?

        public init (
            events: [IoTWirelessClientTypes.WirelessGatewayEventLogOption]? = nil,
            logLevel: IoTWirelessClientTypes.LogLevel? = nil,
            type: IoTWirelessClientTypes.WirelessGatewayType? = nil
        )
        {
            self.events = events
            self.logLevel = logLevel
            self.type = type
        }
    }

}

extension IoTWirelessClientTypes {
    public enum WirelessGatewayServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cups
        case lns
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayServiceType] {
            return [
                .cups,
                .lns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cups: return "CUPS"
            case .lns: return "LNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayServiceType(rawValue: rawValue) ?? WirelessGatewayServiceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.WirelessGatewayStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUplinkReceivedAt = self.lastUplinkReceivedAt {
            try encodeContainer.encode(lastUplinkReceivedAt, forKey: .lastUplinkReceivedAt)
        }
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
    }
}

extension IoTWirelessClientTypes {
    /// Information about a wireless gateway's operation.
    public struct WirelessGatewayStatistics: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The description of the resource.
        public var description: Swift.String?
        /// The ID of the wireless gateway reporting the data.
        public var id: Swift.String?
        /// The date and time when the most recent uplink was received.
        public var lastUplinkReceivedAt: Swift.String?
        /// LoRaWAN gateway info.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANGateway?
        /// The name of the resource.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUplinkReceivedAt: Swift.String? = nil,
            loRaWAN: IoTWirelessClientTypes.LoRaWANGateway? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.loRaWAN = loRaWAN
            self.name = name
        }
    }

}

extension IoTWirelessClientTypes {
    public enum WirelessGatewayTaskDefinitionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayTaskDefinitionType] {
            return [
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayTaskDefinitionType(rawValue: rawValue) ?? WirelessGatewayTaskDefinitionType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    public enum WirelessGatewayTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case firstRetry
        case inProgress
        case pending
        case secondRetry
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayTaskStatus] {
            return [
                .completed,
                .failed,
                .firstRetry,
                .inProgress,
                .pending,
                .secondRetry,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .firstRetry: return "FIRST_RETRY"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .secondRetry: return "SECOND_RETRY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayTaskStatus(rawValue: rawValue) ?? WirelessGatewayTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes {
    /// The wireless gateway type.
    public enum WirelessGatewayType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lorawan
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayType] {
            return [
                .lorawan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lorawan: return "LoRaWAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayType(rawValue: rawValue) ?? WirelessGatewayType.sdkUnknown(rawValue)
        }
    }
}

extension IoTWirelessClientTypes.WirelessMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = self.loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let sidewalk = self.sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.LoRaWANSendDataToDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IoTWirelessClientTypes.SidewalkSendDataToDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension IoTWirelessClientTypes {
    /// WirelessMetadata object.
    public struct WirelessMetadata: Swift.Equatable {
        /// LoRaWAN device info.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANSendDataToDevice?
        /// The Sidewalk account credentials.
        public var sidewalk: IoTWirelessClientTypes.SidewalkSendDataToDevice?

        public init (
            loRaWAN: IoTWirelessClientTypes.LoRaWANSendDataToDevice? = nil,
            sidewalk: IoTWirelessClientTypes.SidewalkSendDataToDevice? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.sidewalk = sidewalk
        }
    }

}
