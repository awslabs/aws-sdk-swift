//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.timestampReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

extension IoTWirelessClientTypes {

    /// Session keys for ABP v1.1
    public struct SessionKeysAbpV1_0_x: Swift.Sendable {
        /// The AppSKey value.
        public var appSKey: Swift.String?
        /// The NwkSKey value.
        public var nwkSKey: Swift.String?

        public init(
            appSKey: Swift.String? = nil,
            nwkSKey: Swift.String? = nil
        )
        {
            self.appSKey = appSKey
            self.nwkSKey = nwkSKey
        }
    }
}

extension IoTWirelessClientTypes {

    /// ABP device object for LoRaWAN specification v1.0.x
    public struct AbpV1_0_x: Swift.Sendable {
        /// The DevAddr value.
        public var devAddr: Swift.String?
        /// The FCnt init value.
        public var fCntStart: Swift.Int?
        /// Session keys for ABP v1.0.x
        public var sessionKeys: IoTWirelessClientTypes.SessionKeysAbpV1_0_x?

        public init(
            devAddr: Swift.String? = nil,
            fCntStart: Swift.Int? = nil,
            sessionKeys: IoTWirelessClientTypes.SessionKeysAbpV1_0_x? = nil
        )
        {
            self.devAddr = devAddr
            self.fCntStart = fCntStart
            self.sessionKeys = sessionKeys
        }
    }
}

extension IoTWirelessClientTypes {

    /// Session keys for ABP v1.1
    public struct SessionKeysAbpV1_1: Swift.Sendable {
        /// The AppSKey value.
        public var appSKey: Swift.String?
        /// The FNwkSIntKey value.
        public var fNwkSIntKey: Swift.String?
        /// The NwkSEncKey value.
        public var nwkSEncKey: Swift.String?
        /// The SNwkSIntKey value.
        public var sNwkSIntKey: Swift.String?

        public init(
            appSKey: Swift.String? = nil,
            fNwkSIntKey: Swift.String? = nil,
            nwkSEncKey: Swift.String? = nil,
            sNwkSIntKey: Swift.String? = nil
        )
        {
            self.appSKey = appSKey
            self.fNwkSIntKey = fNwkSIntKey
            self.nwkSEncKey = nwkSEncKey
            self.sNwkSIntKey = sNwkSIntKey
        }
    }
}

extension IoTWirelessClientTypes {

    /// ABP device object for LoRaWAN specification v1.1
    public struct AbpV1_1: Swift.Sendable {
        /// The DevAddr value.
        public var devAddr: Swift.String?
        /// The FCnt init value.
        public var fCntStart: Swift.Int?
        /// Session keys for ABP v1.1
        public var sessionKeys: IoTWirelessClientTypes.SessionKeysAbpV1_1?

        public init(
            devAddr: Swift.String? = nil,
            fCntStart: Swift.Int? = nil,
            sessionKeys: IoTWirelessClientTypes.SessionKeysAbpV1_1? = nil
        )
        {
            self.devAddr = devAddr
            self.fCntStart = fCntStart
            self.sessionKeys = sessionKeys
        }
    }
}

/// User does not have permission to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTWirelessClientTypes {

    /// The accuracy of the estimated position in meters. An empty value indicates that no position data is available. A value of ‘0.0’ value indicates that position data is available. This data corresponds to the position information that you specified instead of the position computed by solver.
    public struct Accuracy: Swift.Sendable {
        /// The horizontal accuracy of the estimated position, which is the difference between the estimated location and the actual device location.
        public var horizontalAccuracy: Swift.Float?
        /// The vertical accuracy of the estimated position, which is the difference between the estimated altitude and actual device latitude in meters.
        public var verticalAccuracy: Swift.Float?

        public init(
            horizontalAccuracy: Swift.Float? = nil,
            verticalAccuracy: Swift.Float? = nil
        )
        {
            self.horizontalAccuracy = horizontalAccuracy
            self.verticalAccuracy = verticalAccuracy
        }
    }
}

extension IoTWirelessClientTypes {

    public enum AggregationPeriod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oneday
        case onehour
        case oneweek
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationPeriod] {
            return [
                .oneday,
                .onehour,
                .oneweek
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oneday: return "OneDay"
            case .onehour: return "OneHour"
            case .oneweek: return "OneWeek"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    public enum ApplicationConfigType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case semtechgeolocation
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationConfigType] {
            return [
                .semtechgeolocation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .semtechgeolocation: return "SemtechGeolocation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWAN application configuration, which can be used to perform geolocation.
    public struct ApplicationConfig: Swift.Sendable {
        /// The name of the position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
        public var destinationName: Swift.String?
        /// The Fport value.
        public var fPort: Swift.Int?
        /// Application type, which can be specified to obtain real-time position information of your LoRaWAN device.
        public var type: IoTWirelessClientTypes.ApplicationConfigType?

        public init(
            destinationName: Swift.String? = nil,
            fPort: Swift.Int? = nil,
            type: IoTWirelessClientTypes.ApplicationConfigType? = nil
        )
        {
            self.destinationName = destinationName
            self.fPort = fPort
            self.type = type
        }
    }
}

/// Adding, updating, or deleting the resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Id of the resource in the conflicting operation.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource in the conflicting operation.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// An unexpected error occurred while processing a request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Id of the not found resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the font found resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request was denied because it exceeded the allowed API request rate.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input did not meet the specified constraints.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTWirelessClientTypes {

    /// Information about a Sidewalk account.
    public struct SidewalkAccountInfo: Swift.Sendable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The Sidewalk application server private key.
        public var appServerPrivateKey: Swift.String?

        public init(
            amazonId: Swift.String? = nil,
            appServerPrivateKey: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.appServerPrivateKey = appServerPrivateKey
        }
    }
}

extension IoTWirelessClientTypes.SidewalkAccountInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkAccountInfo(amazonId: \(Swift.String(describing: amazonId)), appServerPrivateKey: \"CONTENT_REDACTED\")"}
}

extension IoTWirelessClientTypes {

    /// A simple label consisting of a customer-defined key-value pair
    public struct Tag: Swift.Sendable {
        /// The tag's key value.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct AssociateAwsAccountWithPartnerAccountInput: Swift.Sendable {
    /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see [Ensuring idempotency in Amazon EC2 API requests](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The Sidewalk account credentials.
    /// This member is required.
    public var sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo?
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sidewalk = sidewalk
        self.tags = tags
    }
}

public struct AssociateAwsAccountWithPartnerAccountOutput: Swift.Sendable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The Sidewalk account credentials.
    public var sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo?

    public init(
        arn: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkAccountInfo? = nil
    )
    {
        self.arn = arn
        self.sidewalk = sidewalk
    }
}

public struct AssociateMulticastGroupWithFuotaTaskInput: Swift.Sendable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the multicast group.
    /// This member is required.
    public var multicastGroupId: Swift.String?

    public init(
        id: Swift.String? = nil,
        multicastGroupId: Swift.String? = nil
    )
    {
        self.id = id
        self.multicastGroupId = multicastGroupId
    }
}

public struct AssociateMulticastGroupWithFuotaTaskOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateWirelessDeviceWithFuotaTaskInput: Swift.Sendable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init(
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

public struct AssociateWirelessDeviceWithFuotaTaskOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateWirelessDeviceWithMulticastGroupInput: Swift.Sendable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init(
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

public struct AssociateWirelessDeviceWithMulticastGroupOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateWirelessDeviceWithThingInput: Swift.Sendable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of the thing to associate with the wireless device.
    /// This member is required.
    public var thingArn: Swift.String?

    public init(
        id: Swift.String? = nil,
        thingArn: Swift.String? = nil
    )
    {
        self.id = id
        self.thingArn = thingArn
    }
}

public struct AssociateWirelessDeviceWithThingOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateWirelessGatewayWithCertificateInput: Swift.Sendable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the certificate to associate with the wireless gateway.
    /// This member is required.
    public var iotCertificateId: Swift.String?

    public init(
        id: Swift.String? = nil,
        iotCertificateId: Swift.String? = nil
    )
    {
        self.id = id
        self.iotCertificateId = iotCertificateId
    }
}

public struct AssociateWirelessGatewayWithCertificateOutput: Swift.Sendable {
    /// The ID of the certificate associated with the wireless gateway.
    public var iotCertificateId: Swift.String?

    public init(
        iotCertificateId: Swift.String? = nil
    )
    {
        self.iotCertificateId = iotCertificateId
    }
}

public struct AssociateWirelessGatewayWithThingInput: Swift.Sendable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of the thing to associate with the wireless gateway.
    /// This member is required.
    public var thingArn: Swift.String?

    public init(
        id: Swift.String? = nil,
        thingArn: Swift.String? = nil
    )
    {
        self.id = id
        self.thingArn = thingArn
    }
}

public struct AssociateWirelessGatewayWithThingOutput: Swift.Sendable {

    public init() { }
}

extension IoTWirelessClientTypes {

    /// Sidewalk device battery level.
    public enum BatteryLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case critical
        case low
        case normal
        case sdkUnknown(Swift.String)

        public static var allCases: [BatteryLevel] {
            return [
                .critical,
                .low,
                .normal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .critical: return "critical"
            case .low: return "low"
            case .normal: return "normal"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// Beaconing parameters for configuring the wireless gateways.
    public struct Beaconing: Swift.Sendable {
        /// The data rate for gateways that are sending the beacons.
        public var dataRate: Swift.Int?
        /// The frequency list for the gateways to send the beacons.
        public var frequencies: [Swift.Int]?

        public init(
            dataRate: Swift.Int? = nil,
            frequencies: [Swift.Int]? = nil
        )
        {
            self.dataRate = dataRate
            self.frequencies = frequencies
        }
    }
}

public struct CancelMulticastGroupSessionInput: Swift.Sendable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct CancelMulticastGroupSessionOutput: Swift.Sendable {

    public init() { }
}

extension IoTWirelessClientTypes {

    /// CDMA local ID information, which corresponds to the local identification parameters of a CDMA cell.
    public struct CdmaLocalId: Swift.Sendable {
        /// CDMA channel information.
        /// This member is required.
        public var cdmaChannel: Swift.Int?
        /// Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.
        /// This member is required.
        public var pnOffset: Swift.Int?

        public init(
            cdmaChannel: Swift.Int? = nil,
            pnOffset: Swift.Int? = nil
        )
        {
            self.cdmaChannel = cdmaChannel
            self.pnOffset = pnOffset
        }
    }
}

extension IoTWirelessClientTypes {

    /// CDMA object for network measurement reports.
    public struct CdmaNmrObj: Swift.Sendable {
        /// CDMA base station ID (BSID).
        public var baseStationId: Swift.Int?
        /// CDMA channel information.
        /// This member is required.
        public var cdmaChannel: Swift.Int?
        /// Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).
        public var pilotPower: Swift.Int?
        /// Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.
        /// This member is required.
        public var pnOffset: Swift.Int?

        public init(
            baseStationId: Swift.Int? = nil,
            cdmaChannel: Swift.Int? = nil,
            pilotPower: Swift.Int? = nil,
            pnOffset: Swift.Int? = nil
        )
        {
            self.baseStationId = baseStationId
            self.cdmaChannel = cdmaChannel
            self.pilotPower = pilotPower
            self.pnOffset = pnOffset
        }
    }
}

extension IoTWirelessClientTypes {

    /// CDMA (Code-division multiple access) object.
    public struct CdmaObj: Swift.Sendable {
        /// CDMA base station latitude in degrees.
        public var baseLat: Swift.Float?
        /// CDMA base station longitude in degrees.
        public var baseLng: Swift.Float?
        /// CDMA base station ID (BSID).
        /// This member is required.
        public var baseStationId: Swift.Int?
        /// CDMA local identification (local ID) parameters.
        public var cdmaLocalId: IoTWirelessClientTypes.CdmaLocalId?
        /// CDMA network measurement reports.
        public var cdmaNmr: [IoTWirelessClientTypes.CdmaNmrObj]?
        /// CDMA network ID (NID).
        /// This member is required.
        public var networkId: Swift.Int?
        /// Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).
        public var pilotPower: Swift.Int?
        /// CDMA registration zone (RZ).
        public var registrationZone: Swift.Int?
        /// CDMA system ID (SID).
        /// This member is required.
        public var systemId: Swift.Int?

        public init(
            baseLat: Swift.Float? = nil,
            baseLng: Swift.Float? = nil,
            baseStationId: Swift.Int? = nil,
            cdmaLocalId: IoTWirelessClientTypes.CdmaLocalId? = nil,
            cdmaNmr: [IoTWirelessClientTypes.CdmaNmrObj]? = nil,
            networkId: Swift.Int? = nil,
            pilotPower: Swift.Int? = nil,
            registrationZone: Swift.Int? = nil,
            systemId: Swift.Int? = nil
        )
        {
            self.baseLat = baseLat
            self.baseLng = baseLng
            self.baseStationId = baseStationId
            self.cdmaLocalId = cdmaLocalId
            self.cdmaNmr = cdmaNmr
            self.networkId = networkId
            self.pilotPower = pilotPower
            self.registrationZone = registrationZone
            self.systemId = systemId
        }
    }
}

extension IoTWirelessClientTypes {

    /// GSM local ID information, which corresponds to the local identification parameters of a GSM cell.
    public struct GsmLocalId: Swift.Sendable {
        /// GSM broadcast control channel.
        /// This member is required.
        public var bcch: Swift.Int?
        /// GSM base station identity code (BSIC).
        /// This member is required.
        public var bsic: Swift.Int?

        public init(
            bcch: Swift.Int? = nil,
            bsic: Swift.Int? = nil
        )
        {
            self.bcch = bcch
            self.bsic = bsic
        }
    }
}

extension IoTWirelessClientTypes {

    /// Global identity information.
    public struct GlobalIdentity: Swift.Sendable {
        /// GERAN (GSM EDGE Radio Access Network) cell global identifier.
        /// This member is required.
        public var geranCid: Swift.Int?
        /// Location area code of the global identity.
        /// This member is required.
        public var lac: Swift.Int?

        public init(
            geranCid: Swift.Int? = nil,
            lac: Swift.Int? = nil
        )
        {
            self.geranCid = geranCid
            self.lac = lac
        }
    }
}

extension IoTWirelessClientTypes {

    /// GSM object for network measurement reports.
    public struct GsmNmrObj: Swift.Sendable {
        /// GSM broadcast control channel.
        /// This member is required.
        public var bcch: Swift.Int?
        /// GSM base station identity code (BSIC).
        /// This member is required.
        public var bsic: Swift.Int?
        /// Global identity information of the GSM object.
        public var globalIdentity: IoTWirelessClientTypes.GlobalIdentity?
        /// Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).
        public var rxLevel: Swift.Int?

        public init(
            bcch: Swift.Int? = nil,
            bsic: Swift.Int? = nil,
            globalIdentity: IoTWirelessClientTypes.GlobalIdentity? = nil,
            rxLevel: Swift.Int? = nil
        )
        {
            self.bcch = bcch
            self.bsic = bsic
            self.globalIdentity = globalIdentity
            self.rxLevel = rxLevel
        }
    }
}

extension IoTWirelessClientTypes {

    /// GSM object.
    public struct GsmObj: Swift.Sendable {
        /// GERAN (GSM EDGE Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var geranCid: Swift.Int?
        /// GSM local identification (local ID) information.
        public var gsmLocalId: IoTWirelessClientTypes.GsmLocalId?
        /// GSM object for network measurement reports.
        public var gsmNmr: [IoTWirelessClientTypes.GsmNmrObj]?
        /// Timing advance value, which corresponds to the length of time a signal takes to reach the base station from a mobile phone.
        public var gsmTimingAdvance: Swift.Int?
        /// Location area code.
        /// This member is required.
        public var lac: Swift.Int?
        /// Mobile Country Code.
        /// This member is required.
        public var mcc: Swift.Int?
        /// Mobile Network Code.
        /// This member is required.
        public var mnc: Swift.Int?
        /// Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).
        public var rxLevel: Swift.Int?

        public init(
            geranCid: Swift.Int? = nil,
            gsmLocalId: IoTWirelessClientTypes.GsmLocalId? = nil,
            gsmNmr: [IoTWirelessClientTypes.GsmNmrObj]? = nil,
            gsmTimingAdvance: Swift.Int? = nil,
            lac: Swift.Int? = nil,
            mcc: Swift.Int? = nil,
            mnc: Swift.Int? = nil,
            rxLevel: Swift.Int? = nil
        )
        {
            self.geranCid = geranCid
            self.gsmLocalId = gsmLocalId
            self.gsmNmr = gsmNmr
            self.gsmTimingAdvance = gsmTimingAdvance
            self.lac = lac
            self.mcc = mcc
            self.mnc = mnc
            self.rxLevel = rxLevel
        }
    }
}

extension IoTWirelessClientTypes {

    /// LTE local identification (local ID) information.
    public struct LteLocalId: Swift.Sendable {
        /// Evolved universal terrestrial radio access (E-UTRA) absolute radio frequency channel number (FCN).
        /// This member is required.
        public var earfcn: Swift.Int?
        /// Physical cell ID.
        /// This member is required.
        public var pci: Swift.Int?

        public init(
            earfcn: Swift.Int? = nil,
            pci: Swift.Int? = nil
        )
        {
            self.earfcn = earfcn
            self.pci = pci
        }
    }
}

extension IoTWirelessClientTypes {

    /// LTE object for network measurement reports.
    public struct LteNmrObj: Swift.Sendable {
        /// E-UTRA (Evolved universal terrestrial Radio Access) absolute radio frequency channel Number (EARFCN).
        /// This member is required.
        public var earfcn: Swift.Int?
        /// E-UTRAN (Evolved Universal Terrestrial Radio Access Network) cell global identifier (EUTRANCID).
        /// This member is required.
        public var eutranCid: Swift.Int?
        /// Physical cell ID.
        /// This member is required.
        public var pci: Swift.Int?
        /// Signal power of the reference signal received, measured in dBm (decibel-milliwatts).
        public var rsrp: Swift.Int?
        /// Signal quality of the reference Signal received, measured in decibels (dB).
        public var rsrq: Swift.Float?

        public init(
            earfcn: Swift.Int? = nil,
            eutranCid: Swift.Int? = nil,
            pci: Swift.Int? = nil,
            rsrp: Swift.Int? = nil,
            rsrq: Swift.Float? = nil
        )
        {
            self.earfcn = earfcn
            self.eutranCid = eutranCid
            self.pci = pci
            self.rsrp = rsrp
            self.rsrq = rsrq
        }
    }
}

extension IoTWirelessClientTypes {

    /// LTE object.
    public struct LteObj: Swift.Sendable {
        /// E-UTRAN (Evolved Universal Terrestrial Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var eutranCid: Swift.Int?
        /// LTE local identification (local ID) information.
        public var lteLocalId: IoTWirelessClientTypes.LteLocalId?
        /// LTE object for network measurement reports.
        public var lteNmr: [IoTWirelessClientTypes.LteNmrObj]?
        /// LTE timing advance.
        public var lteTimingAdvance: Swift.Int?
        /// Mobile Country Code.
        /// This member is required.
        public var mcc: Swift.Int?
        /// Mobile Network Code.
        /// This member is required.
        public var mnc: Swift.Int?
        /// Parameter that determines whether the LTE object is capable of supporting NR (new radio).
        public var nrCapable: Swift.Bool
        /// Signal power of the reference signal received, measured in dBm (decibel-milliwatts).
        public var rsrp: Swift.Int?
        /// Signal quality of the reference Signal received, measured in decibels (dB).
        public var rsrq: Swift.Float?
        /// LTE tracking area code.
        public var tac: Swift.Int?

        public init(
            eutranCid: Swift.Int? = nil,
            lteLocalId: IoTWirelessClientTypes.LteLocalId? = nil,
            lteNmr: [IoTWirelessClientTypes.LteNmrObj]? = nil,
            lteTimingAdvance: Swift.Int? = nil,
            mcc: Swift.Int? = nil,
            mnc: Swift.Int? = nil,
            nrCapable: Swift.Bool = false,
            rsrp: Swift.Int? = nil,
            rsrq: Swift.Float? = nil,
            tac: Swift.Int? = nil
        )
        {
            self.eutranCid = eutranCid
            self.lteLocalId = lteLocalId
            self.lteNmr = lteNmr
            self.lteTimingAdvance = lteTimingAdvance
            self.mcc = mcc
            self.mnc = mnc
            self.nrCapable = nrCapable
            self.rsrp = rsrp
            self.rsrq = rsrq
            self.tac = tac
        }
    }
}

extension IoTWirelessClientTypes {

    /// TD-SCDMA local identification (local Id) information.
    public struct TdscdmaLocalId: Swift.Sendable {
        /// Cell parameters for TD-SCDMA.
        /// This member is required.
        public var cellParams: Swift.Int?
        /// TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number (UARFCN).
        /// This member is required.
        public var uarfcn: Swift.Int?

        public init(
            cellParams: Swift.Int? = nil,
            uarfcn: Swift.Int? = nil
        )
        {
            self.cellParams = cellParams
            self.uarfcn = uarfcn
        }
    }
}

extension IoTWirelessClientTypes {

    /// TD-SCDMA object for network measurement reports.
    public struct TdscdmaNmrObj: Swift.Sendable {
        /// Cell parameters for TD-SCDMA network measurement reports object.
        /// This member is required.
        public var cellParams: Swift.Int?
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public var pathLoss: Swift.Int?
        /// Code power of the received signal, measured in decibel-milliwatts (dBm).
        public var rscp: Swift.Int?
        /// TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number.
        /// This member is required.
        public var uarfcn: Swift.Int?
        /// UTRAN (UMTS Terrestrial Radio Access Network) cell global identifier.
        public var utranCid: Swift.Int?

        public init(
            cellParams: Swift.Int? = nil,
            pathLoss: Swift.Int? = nil,
            rscp: Swift.Int? = nil,
            uarfcn: Swift.Int? = nil,
            utranCid: Swift.Int? = nil
        )
        {
            self.cellParams = cellParams
            self.pathLoss = pathLoss
            self.rscp = rscp
            self.uarfcn = uarfcn
            self.utranCid = utranCid
        }
    }
}

extension IoTWirelessClientTypes {

    /// TD-SCDMA object.
    public struct TdscdmaObj: Swift.Sendable {
        /// Location Area Code.
        public var lac: Swift.Int?
        /// Mobile Country Code.
        /// This member is required.
        public var mcc: Swift.Int?
        /// Mobile Network Code.
        /// This member is required.
        public var mnc: Swift.Int?
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public var pathLoss: Swift.Int?
        /// Signal power of the received signal (Received Signal Code Power), measured in decibel-milliwatts (dBm).
        public var rscp: Swift.Int?
        /// TD-SCDMA local identification (local ID) information.
        public var tdscdmaLocalId: IoTWirelessClientTypes.TdscdmaLocalId?
        /// TD-SCDMA object for network measurement reports.
        public var tdscdmaNmr: [IoTWirelessClientTypes.TdscdmaNmrObj]?
        /// TD-SCDMA Timing advance.
        public var tdscdmaTimingAdvance: Swift.Int?
        /// UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var utranCid: Swift.Int?

        public init(
            lac: Swift.Int? = nil,
            mcc: Swift.Int? = nil,
            mnc: Swift.Int? = nil,
            pathLoss: Swift.Int? = nil,
            rscp: Swift.Int? = nil,
            tdscdmaLocalId: IoTWirelessClientTypes.TdscdmaLocalId? = nil,
            tdscdmaNmr: [IoTWirelessClientTypes.TdscdmaNmrObj]? = nil,
            tdscdmaTimingAdvance: Swift.Int? = nil,
            utranCid: Swift.Int? = nil
        )
        {
            self.lac = lac
            self.mcc = mcc
            self.mnc = mnc
            self.pathLoss = pathLoss
            self.rscp = rscp
            self.tdscdmaLocalId = tdscdmaLocalId
            self.tdscdmaNmr = tdscdmaNmr
            self.tdscdmaTimingAdvance = tdscdmaTimingAdvance
            self.utranCid = utranCid
        }
    }
}

extension IoTWirelessClientTypes {

    /// WCDMA local identification (local ID) information.
    public struct WcdmaLocalId: Swift.Sendable {
        /// Primary Scrambling Code.
        /// This member is required.
        public var psc: Swift.Int?
        /// WCDMA UTRA Absolute RF Channel Number downlink.
        /// This member is required.
        public var uarfcndl: Swift.Int?

        public init(
            psc: Swift.Int? = nil,
            uarfcndl: Swift.Int? = nil
        )
        {
            self.psc = psc
            self.uarfcndl = uarfcndl
        }
    }
}

extension IoTWirelessClientTypes {

    /// Network Measurement Reports.
    public struct WcdmaNmrObj: Swift.Sendable {
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public var pathLoss: Swift.Int?
        /// Primary Scrambling Code.
        /// This member is required.
        public var psc: Swift.Int?
        /// Received Signal Code Power (signal power) (dBm)
        public var rscp: Swift.Int?
        /// WCDMA UTRA Absolute RF Channel Number downlink.
        /// This member is required.
        public var uarfcndl: Swift.Int?
        /// UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var utranCid: Swift.Int?

        public init(
            pathLoss: Swift.Int? = nil,
            psc: Swift.Int? = nil,
            rscp: Swift.Int? = nil,
            uarfcndl: Swift.Int? = nil,
            utranCid: Swift.Int? = nil
        )
        {
            self.pathLoss = pathLoss
            self.psc = psc
            self.rscp = rscp
            self.uarfcndl = uarfcndl
            self.utranCid = utranCid
        }
    }
}

extension IoTWirelessClientTypes {

    /// WCDMA.
    public struct WcdmaObj: Swift.Sendable {
        /// Location Area Code.
        public var lac: Swift.Int?
        /// Mobile Country Code.
        /// This member is required.
        public var mcc: Swift.Int?
        /// Mobile Network Code.
        /// This member is required.
        public var mnc: Swift.Int?
        /// Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.
        public var pathLoss: Swift.Int?
        /// Received Signal Code Power (signal power) (dBm).
        public var rscp: Swift.Int?
        /// UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.
        /// This member is required.
        public var utranCid: Swift.Int?
        /// WCDMA local ID information.
        public var wcdmaLocalId: IoTWirelessClientTypes.WcdmaLocalId?
        /// WCDMA object for network measurement reports.
        public var wcdmaNmr: [IoTWirelessClientTypes.WcdmaNmrObj]?

        public init(
            lac: Swift.Int? = nil,
            mcc: Swift.Int? = nil,
            mnc: Swift.Int? = nil,
            pathLoss: Swift.Int? = nil,
            rscp: Swift.Int? = nil,
            utranCid: Swift.Int? = nil,
            wcdmaLocalId: IoTWirelessClientTypes.WcdmaLocalId? = nil,
            wcdmaNmr: [IoTWirelessClientTypes.WcdmaNmrObj]? = nil
        )
        {
            self.lac = lac
            self.mcc = mcc
            self.mnc = mnc
            self.pathLoss = pathLoss
            self.rscp = rscp
            self.utranCid = utranCid
            self.wcdmaLocalId = wcdmaLocalId
            self.wcdmaNmr = wcdmaNmr
        }
    }
}

extension IoTWirelessClientTypes {

    /// The cell towers that were used to perform the measurements.
    public struct CellTowers: Swift.Sendable {
        /// CDMA object information.
        public var cdma: [IoTWirelessClientTypes.CdmaObj]?
        /// GSM object information.
        public var gsm: [IoTWirelessClientTypes.GsmObj]?
        /// LTE object information.
        public var lte: [IoTWirelessClientTypes.LteObj]?
        /// TD-SCDMA object information.
        public var tdscdma: [IoTWirelessClientTypes.TdscdmaObj]?
        /// WCDMA object information.
        public var wcdma: [IoTWirelessClientTypes.WcdmaObj]?

        public init(
            cdma: [IoTWirelessClientTypes.CdmaObj]? = nil,
            gsm: [IoTWirelessClientTypes.GsmObj]? = nil,
            lte: [IoTWirelessClientTypes.LteObj]? = nil,
            tdscdma: [IoTWirelessClientTypes.TdscdmaObj]? = nil,
            wcdma: [IoTWirelessClientTypes.WcdmaObj]? = nil
        )
        {
            self.cdma = cdma
            self.gsm = gsm
            self.lte = lte
            self.tdscdma = tdscdma
            self.wcdma = wcdma
        }
    }
}

extension IoTWirelessClientTypes {

    /// The certificate chain algorithm provided by sidewalk.
    public enum SigningAlg: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ed25519
        case p256r1
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningAlg] {
            return [
                .ed25519,
                .p256r1
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ed25519: return "Ed25519"
            case .p256r1: return "P256r1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// List of sidewalk certificates.
    public struct CertificateList: Swift.Sendable {
        /// The certificate chain algorithm provided by sidewalk.
        /// This member is required.
        public var signingAlg: IoTWirelessClientTypes.SigningAlg?
        /// The value of the chosen sidewalk certificate.
        /// This member is required.
        public var value: Swift.String?

        public init(
            signingAlg: IoTWirelessClientTypes.SigningAlg? = nil,
            value: Swift.String? = nil
        )
        {
            self.signingAlg = signingAlg
            self.value = value
        }
    }
}

extension IoTWirelessClientTypes {

    public enum ConnectionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .connected,
                .disconnected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "Connected"
            case .disconnected: return "Disconnected"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    public enum EventNotificationTopicStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EventNotificationTopicStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// Object for LoRaWAN connection status resource type event configuration.
    public struct LoRaWANConnectionStatusEventNotificationConfigurations: Swift.Sendable {
        /// Denotes whether the gateway EUI connection status event topic is enabled or disabled.
        public var gatewayEuiEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            gatewayEuiEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.gatewayEuiEventTopic = gatewayEuiEventTopic
        }
    }
}

extension IoTWirelessClientTypes {

    /// Connection status event configuration object for enabling or disabling topic.
    public struct ConnectionStatusEventConfiguration: Swift.Sendable {
        /// Connection status event configuration object for enabling or disabling LoRaWAN related event topics.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations?
        /// Denotes whether the wireless gateway ID connection status event topic is enabled or disabled.
        public var wirelessGatewayIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations? = nil,
            wirelessGatewayIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.wirelessGatewayIdEventTopic = wirelessGatewayIdEventTopic
        }
    }
}

extension IoTWirelessClientTypes {

    /// Object for LoRaWAN connection status resource type event configuration.
    public struct LoRaWANConnectionStatusResourceTypeEventConfiguration: Swift.Sendable {
        /// Denotes whether the wireless gateway connection status event topic is enabled or disabled.
        public var wirelessGatewayEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            wirelessGatewayEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.wirelessGatewayEventTopic = wirelessGatewayEventTopic
        }
    }
}

extension IoTWirelessClientTypes {

    /// Connection status resource type event configuration object for enabling or disabling topic.
    public struct ConnectionStatusResourceTypeEventConfiguration: Swift.Sendable {
        /// Connection status resource type event configuration object for enabling or disabling LoRaWAN related event topics.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration? = nil
        )
        {
            self.loRaWAN = loRaWAN
        }
    }
}

extension IoTWirelessClientTypes {

    public enum ExpressionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mqtttopic
        case rulename
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpressionType] {
            return [
                .mqtttopic,
                .rulename
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mqtttopic: return "MqttTopic"
            case .rulename: return "RuleName"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDestinationInput: Swift.Sendable {
    /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see [Ensuring idempotency in Amazon EC2 API requests](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The rule name or topic rule to send messages to.
    /// This member is required.
    public var expression: Swift.String?
    /// The type of value in Expression.
    /// This member is required.
    public var expressionType: IoTWirelessClientTypes.ExpressionType?
    /// The name of the new resource.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags to attach to the new destination. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IoTWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

public struct CreateDestinationOutput: Swift.Sendable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The name of the new resource.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWANDeviceProfile object.
    public struct LoRaWANDeviceProfile: Swift.Sendable {
        /// The ClassBTimeout value.
        public var classBTimeout: Swift.Int?
        /// The ClassCTimeout value.
        public var classCTimeout: Swift.Int?
        /// The list of values that make up the FactoryPresetFreqs value.
        public var factoryPresetFreqsList: [Swift.Int]?
        /// The MAC version (such as OTAA 1.1 or OTAA 1.0.3) to use with this device profile.
        public var macVersion: Swift.String?
        /// The MaxDutyCycle value. It ranges from 0 to 15.
        public var maxDutyCycle: Swift.Int?
        /// The MaxEIRP value.
        public var maxEirp: Swift.Int?
        /// The PingSlotDR value.
        public var pingSlotDr: Swift.Int?
        /// The PingSlotFreq value.
        public var pingSlotFreq: Swift.Int?
        /// The PingSlotPeriod value.
        public var pingSlotPeriod: Swift.Int?
        /// The version of regional parameters.
        public var regParamsRevision: Swift.String?
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// The RXDataRate2 value.
        public var rxDataRate2: Swift.Int?
        /// The RXDelay1 value.
        public var rxDelay1: Swift.Int?
        /// The RXDROffset1 value.
        public var rxDrOffset1: Swift.Int?
        /// The RXFreq2 value.
        public var rxFreq2: Swift.Int?
        /// The Supports32BitFCnt value.
        public var supports32BitFCnt: Swift.Bool
        /// The SupportsClassB value.
        public var supportsClassB: Swift.Bool
        /// The SupportsClassC value.
        public var supportsClassC: Swift.Bool
        /// The SupportsJoin value.
        public var supportsJoin: Swift.Bool?

        public init(
            classBTimeout: Swift.Int? = nil,
            classCTimeout: Swift.Int? = nil,
            factoryPresetFreqsList: [Swift.Int]? = nil,
            macVersion: Swift.String? = nil,
            maxDutyCycle: Swift.Int? = nil,
            maxEirp: Swift.Int? = nil,
            pingSlotDr: Swift.Int? = nil,
            pingSlotFreq: Swift.Int? = nil,
            pingSlotPeriod: Swift.Int? = nil,
            regParamsRevision: Swift.String? = nil,
            rfRegion: Swift.String? = nil,
            rxDataRate2: Swift.Int? = nil,
            rxDelay1: Swift.Int? = nil,
            rxDrOffset1: Swift.Int? = nil,
            rxFreq2: Swift.Int? = nil,
            supports32BitFCnt: Swift.Bool = false,
            supportsClassB: Swift.Bool = false,
            supportsClassC: Swift.Bool = false,
            supportsJoin: Swift.Bool? = nil
        )
        {
            self.classBTimeout = classBTimeout
            self.classCTimeout = classCTimeout
            self.factoryPresetFreqsList = factoryPresetFreqsList
            self.macVersion = macVersion
            self.maxDutyCycle = maxDutyCycle
            self.maxEirp = maxEirp
            self.pingSlotDr = pingSlotDr
            self.pingSlotFreq = pingSlotFreq
            self.pingSlotPeriod = pingSlotPeriod
            self.regParamsRevision = regParamsRevision
            self.rfRegion = rfRegion
            self.rxDataRate2 = rxDataRate2
            self.rxDelay1 = rxDelay1
            self.rxDrOffset1 = rxDrOffset1
            self.rxFreq2 = rxFreq2
            self.supports32BitFCnt = supports32BitFCnt
            self.supportsClassB = supportsClassB
            self.supportsClassC = supportsClassC
            self.supportsJoin = supportsJoin
        }
    }
}

extension IoTWirelessClientTypes {

    /// Sidewalk object for creating a device profile.
    public struct SidewalkCreateDeviceProfile: Swift.Sendable {

        public init() { }
    }
}

public struct CreateDeviceProfileInput: Swift.Sendable {
    /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see [Ensuring idempotency in Amazon EC2 API requests](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The device profile information to use to create the device profile.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The Sidewalk-related information for creating the Sidewalk device profile.
    public var sidewalk: IoTWirelessClientTypes.SidewalkCreateDeviceProfile?
    /// The tags to attach to the new device profile. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile? = nil,
        name: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkCreateDeviceProfile? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.loRaWAN = loRaWAN
        self.name = name
        self.sidewalk = sidewalk
        self.tags = tags
    }
}

public struct CreateDeviceProfileOutput: Swift.Sendable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new device profile.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

extension IoTWirelessClientTypes {

    /// Supported RfRegions
    public enum SupportedRfRegion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case as9231
        case as9232
        case as9233
        case as9234
        case au915
        case cn470
        case cn779
        case eu433
        case eu868
        case in865
        case kr920
        case ru864
        case us915
        case sdkUnknown(Swift.String)

        public static var allCases: [SupportedRfRegion] {
            return [
                .as9231,
                .as9232,
                .as9233,
                .as9234,
                .au915,
                .cn470,
                .cn779,
                .eu433,
                .eu868,
                .in865,
                .kr920,
                .ru864,
                .us915
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .as9231: return "AS923-1"
            case .as9232: return "AS923-2"
            case .as9233: return "AS923-3"
            case .as9234: return "AS923-4"
            case .au915: return "AU915"
            case .cn470: return "CN470"
            case .cn779: return "CN779"
            case .eu433: return "EU433"
            case .eu868: return "EU868"
            case .in865: return "IN865"
            case .kr920: return "KR920"
            case .ru864: return "RU864"
            case .us915: return "US915"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// The LoRaWAN information used with a FUOTA task.
    public struct LoRaWANFuotaTask: Swift.Sendable {
        /// Supported RfRegions
        public var rfRegion: IoTWirelessClientTypes.SupportedRfRegion?

        public init(
            rfRegion: IoTWirelessClientTypes.SupportedRfRegion? = nil
        )
        {
            self.rfRegion = rfRegion
        }
    }
}

public struct CreateFuotaTaskInput: Swift.Sendable {
    /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see [Ensuring idempotency in Amazon EC2 API requests](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The S3 URI points to a firmware update image that is to be used with a FUOTA task.
    /// This member is required.
    public var firmwareUpdateImage: Swift.String?
    /// The firmware update role that is to be used with a FUOTA task.
    /// This member is required.
    public var firmwareUpdateRole: Swift.String?
    /// The interval for sending fragments in milliseconds, rounded to the nearest second. This interval only determines the timing for when the Cloud sends down the fragments to yor device. There can be a delay for when your device will receive these fragments. This delay depends on the device's class and the communication delay with the cloud.
    public var fragmentIntervalMS: Swift.Int?
    /// The size of each fragment in bytes. This parameter is supported only for FUOTA tasks with multicast groups.
    public var fragmentSizeBytes: Swift.Int?
    /// The LoRaWAN information used with a FUOTA task.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask?
    /// The name of a FUOTA task.
    public var name: Swift.String?
    /// The percentage of the added fragments that are redundant. For example, if the size of the firmware image file is 100 bytes and the fragment size is 10 bytes, with RedundancyPercent set to 50(%), the final number of encoded fragments is (100 / 10) + (100 / 10 * 50%) = 15.
    public var redundancyPercent: Swift.Int?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        firmwareUpdateImage: Swift.String? = nil,
        firmwareUpdateRole: Swift.String? = nil,
        fragmentIntervalMS: Swift.Int? = nil,
        fragmentSizeBytes: Swift.Int? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask? = nil,
        name: Swift.String? = nil,
        redundancyPercent: Swift.Int? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.firmwareUpdateImage = firmwareUpdateImage
        self.firmwareUpdateRole = firmwareUpdateRole
        self.fragmentIntervalMS = fragmentIntervalMS
        self.fragmentSizeBytes = fragmentSizeBytes
        self.loRaWAN = loRaWAN
        self.name = name
        self.redundancyPercent = redundancyPercent
        self.tags = tags
    }
}

public struct CreateFuotaTaskOutput: Swift.Sendable {
    /// The arn of a FUOTA task.
    public var arn: Swift.String?
    /// The ID of a FUOTA task.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

extension IoTWirelessClientTypes {

    /// DlClass for LoRaWAM, valid values are ClassB and ClassC.
    public enum DlClass: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case classb
        case classc
        case sdkUnknown(Swift.String)

        public static var allCases: [DlClass] {
            return [
                .classb,
                .classc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .classb: return "ClassB"
            case .classc: return "ClassC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// The LoRaWAN information that is to be used with the multicast group.
    public struct LoRaWANMulticast: Swift.Sendable {
        /// DlClass for LoRaWAM, valid values are ClassB and ClassC.
        public var dlClass: IoTWirelessClientTypes.DlClass?
        /// Supported RfRegions
        public var rfRegion: IoTWirelessClientTypes.SupportedRfRegion?

        public init(
            dlClass: IoTWirelessClientTypes.DlClass? = nil,
            rfRegion: IoTWirelessClientTypes.SupportedRfRegion? = nil
        )
        {
            self.dlClass = dlClass
            self.rfRegion = rfRegion
        }
    }
}

public struct CreateMulticastGroupInput: Swift.Sendable {
    /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see [Ensuring idempotency in Amazon EC2 API requests](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The description of the multicast group.
    public var description: Swift.String?
    /// The LoRaWAN information that is to be used with the multicast group.
    /// This member is required.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast?
    /// The name of the multicast group.
    public var name: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

public struct CreateMulticastGroupOutput: Swift.Sendable {
    /// The arn of the multicast group.
    public var arn: Swift.String?
    /// The ID of the multicast group.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

extension IoTWirelessClientTypes {

    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    public enum LogLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case error
        case info
        case sdkUnknown(Swift.String)

        public static var allCases: [LogLevel] {
            return [
                .disabled,
                .error,
                .info
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .error: return "ERROR"
            case .info: return "INFO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// FrameInfo of your multicast group resources for the trace content. Use FrameInfo to debug the multicast communication between your multicast groups and the network server.
    public enum MulticastFrameInfo: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MulticastFrameInfo] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// FrameInfo of your wireless device resources for the trace content. Use FrameInfo to debug the communication between your LoRaWAN end devices and the network server.
    public enum WirelessDeviceFrameInfo: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceFrameInfo] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// Trace content for your wireless devices, gateways, and multicast groups.
    public struct TraceContent: Swift.Sendable {
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        public var logLevel: IoTWirelessClientTypes.LogLevel?
        /// FrameInfo of your multicast group resources for the trace content. Use FrameInfo to debug the multicast communication between your multicast groups and the network server.
        public var multicastFrameInfo: IoTWirelessClientTypes.MulticastFrameInfo?
        /// FrameInfo of your wireless device resources for the trace content. Use FrameInfo to debug the communication between your LoRaWAN end devices and the network server.
        public var wirelessDeviceFrameInfo: IoTWirelessClientTypes.WirelessDeviceFrameInfo?

        public init(
            logLevel: IoTWirelessClientTypes.LogLevel? = nil,
            multicastFrameInfo: IoTWirelessClientTypes.MulticastFrameInfo? = nil,
            wirelessDeviceFrameInfo: IoTWirelessClientTypes.WirelessDeviceFrameInfo? = nil
        )
        {
            self.logLevel = logLevel
            self.multicastFrameInfo = multicastFrameInfo
            self.wirelessDeviceFrameInfo = wirelessDeviceFrameInfo
        }
    }
}

public struct CreateNetworkAnalyzerConfigurationInput: Swift.Sendable {
    /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see [Ensuring idempotency in Amazon EC2 API requests](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// Multicast Group resources to add to the network analyzer configruation. Provide the MulticastGroupId of the resource to add in the input array.
    public var multicastGroups: [Swift.String]?
    /// Name of the network analyzer configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?
    /// Trace content for your wireless devices, gateways, and multicast groups.
    public var traceContent: IoTWirelessClientTypes.TraceContent?
    /// Wireless device resources to add to the network analyzer configuration. Provide the WirelessDeviceId of the resource to add in the input array.
    public var wirelessDevices: [Swift.String]?
    /// Wireless gateway resources to add to the network analyzer configuration. Provide the WirelessGatewayId of the resource to add in the input array.
    public var wirelessGateways: [Swift.String]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        multicastGroups: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil,
        traceContent: IoTWirelessClientTypes.TraceContent? = nil,
        wirelessDevices: [Swift.String]? = nil,
        wirelessGateways: [Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.multicastGroups = multicastGroups
        self.name = name
        self.tags = tags
        self.traceContent = traceContent
        self.wirelessDevices = wirelessDevices
        self.wirelessGateways = wirelessGateways
    }
}

public struct CreateNetworkAnalyzerConfigurationOutput: Swift.Sendable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// Name of the network analyzer configuration.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWANServiceProfile object.
    public struct LoRaWANServiceProfile: Swift.Sendable {
        /// The AddGWMetaData value.
        public var addGwMetadata: Swift.Bool
        /// The DrMax value.
        public var drMax: Swift.Int?
        /// The DrMin value.
        public var drMin: Swift.Int?
        /// The PRAllowed value that describes whether passive roaming is allowed.
        public var prAllowed: Swift.Bool
        /// The RAAllowed value that describes whether roaming activation is allowed.
        public var raAllowed: Swift.Bool

        public init(
            addGwMetadata: Swift.Bool = false,
            drMax: Swift.Int? = nil,
            drMin: Swift.Int? = nil,
            prAllowed: Swift.Bool = false,
            raAllowed: Swift.Bool = false
        )
        {
            self.addGwMetadata = addGwMetadata
            self.drMax = drMax
            self.drMin = drMin
            self.prAllowed = prAllowed
            self.raAllowed = raAllowed
        }
    }
}

public struct CreateServiceProfileInput: Swift.Sendable {
    /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see [Ensuring idempotency in Amazon EC2 API requests](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The service profile information to use to create the service profile.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANServiceProfile?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new service profile. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANServiceProfile? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

public struct CreateServiceProfileOutput: Swift.Sendable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new service profile.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

extension IoTWirelessClientTypes {

    /// The FPorts for the position information.
    public struct Positioning: Swift.Sendable {
        /// The Fport value.
        public var clockSync: Swift.Int?
        /// The Fport value.
        public var gnss: Swift.Int?
        /// The Fport value.
        public var stream: Swift.Int?

        public init(
            clockSync: Swift.Int? = nil,
            gnss: Swift.Int? = nil,
            stream: Swift.Int? = nil
        )
        {
            self.clockSync = clockSync
            self.gnss = gnss
            self.stream = stream
        }
    }
}

extension IoTWirelessClientTypes {

    /// List of FPort assigned for different LoRaWAN application packages to use
    public struct FPorts: Swift.Sendable {
        /// Optional LoRaWAN application information, which can be used for geolocation.
        public var applications: [IoTWirelessClientTypes.ApplicationConfig]?
        /// The Fport value.
        public var clockSync: Swift.Int?
        /// The Fport value.
        public var fuota: Swift.Int?
        /// The Fport value.
        public var multicast: Swift.Int?
        /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
        public var positioning: IoTWirelessClientTypes.Positioning?

        public init(
            applications: [IoTWirelessClientTypes.ApplicationConfig]? = nil,
            clockSync: Swift.Int? = nil,
            fuota: Swift.Int? = nil,
            multicast: Swift.Int? = nil,
            positioning: IoTWirelessClientTypes.Positioning? = nil
        )
        {
            self.applications = applications
            self.clockSync = clockSync
            self.fuota = fuota
            self.multicast = multicast
            self.positioning = positioning
        }
    }
}

extension IoTWirelessClientTypes {

    /// OTAA device object for v1.0.x
    public struct OtaaV1_0_x: Swift.Sendable {
        /// The AppEUI value. You specify this value when using LoRaWAN versions v1.0.2 or v1.0.3.
        public var appEui: Swift.String?
        /// The AppKey value.
        public var appKey: Swift.String?
        /// The GenAppKey value.
        public var genAppKey: Swift.String?
        /// The JoinEUI value. You specify this value instead of the AppEUI when using LoRaWAN version v1.0.4.
        public var joinEui: Swift.String?

        public init(
            appEui: Swift.String? = nil,
            appKey: Swift.String? = nil,
            genAppKey: Swift.String? = nil,
            joinEui: Swift.String? = nil
        )
        {
            self.appEui = appEui
            self.appKey = appKey
            self.genAppKey = genAppKey
            self.joinEui = joinEui
        }
    }
}

extension IoTWirelessClientTypes {

    /// OTAA device object for v1.1
    public struct OtaaV1_1: Swift.Sendable {
        /// The AppKey value.
        public var appKey: Swift.String?
        /// The JoinEUI value.
        public var joinEui: Swift.String?
        /// The NwkKey value.
        public var nwkKey: Swift.String?

        public init(
            appKey: Swift.String? = nil,
            joinEui: Swift.String? = nil,
            nwkKey: Swift.String? = nil
        )
        {
            self.appKey = appKey
            self.joinEui = joinEui
            self.nwkKey = nwkKey
        }
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWAN object for create functions.
    public struct LoRaWANDevice: Swift.Sendable {
        /// LoRaWAN object for create APIs
        public var abpV1_0_x: IoTWirelessClientTypes.AbpV1_0_x?
        /// ABP device object for create APIs for v1.1
        public var abpV1_1: IoTWirelessClientTypes.AbpV1_1?
        /// The DevEUI value.
        public var devEui: Swift.String?
        /// The ID of the device profile for the new wireless device.
        public var deviceProfileId: Swift.String?
        /// List of FPort assigned for different LoRaWAN application packages to use
        public var fPorts: IoTWirelessClientTypes.FPorts?
        /// OTAA device object for create APIs for v1.0.x
        public var otaaV1_0_x: IoTWirelessClientTypes.OtaaV1_0_x?
        /// OTAA device object for v1.1 for create APIs
        public var otaaV1_1: IoTWirelessClientTypes.OtaaV1_1?
        /// The ID of the service profile.
        public var serviceProfileId: Swift.String?

        public init(
            abpV1_0_x: IoTWirelessClientTypes.AbpV1_0_x? = nil,
            abpV1_1: IoTWirelessClientTypes.AbpV1_1? = nil,
            devEui: Swift.String? = nil,
            deviceProfileId: Swift.String? = nil,
            fPorts: IoTWirelessClientTypes.FPorts? = nil,
            otaaV1_0_x: IoTWirelessClientTypes.OtaaV1_0_x? = nil,
            otaaV1_1: IoTWirelessClientTypes.OtaaV1_1? = nil,
            serviceProfileId: Swift.String? = nil
        )
        {
            self.abpV1_0_x = abpV1_0_x
            self.abpV1_1 = abpV1_1
            self.devEui = devEui
            self.deviceProfileId = deviceProfileId
            self.fPorts = fPorts
            self.otaaV1_0_x = otaaV1_0_x
            self.otaaV1_1 = otaaV1_1
            self.serviceProfileId = serviceProfileId
        }
    }
}

extension IoTWirelessClientTypes {

    public enum PositioningConfigStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PositioningConfigStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// Sidewalk object for creating a wireless device.
    public struct SidewalkCreateWirelessDevice: Swift.Sendable {
        /// The ID of the Sidewalk device profile.
        public var deviceProfileId: Swift.String?

        public init(
            deviceProfileId: Swift.String? = nil
        )
        {
            self.deviceProfileId = deviceProfileId
        }
    }
}

extension IoTWirelessClientTypes {

    public enum WirelessDeviceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lorawan
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceType] {
            return [
                .lorawan,
                .sidewalk
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lorawan: return "LoRaWAN"
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateWirelessDeviceInput: Swift.Sendable {
    /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see [Ensuring idempotency in Amazon EC2 API requests](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The name of the destination to assign to the new wireless device.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The device configuration information to use to create the wireless device.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDevice?
    /// The name of the new resource.
    public var name: Swift.String?
    /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
    public var positioning: IoTWirelessClientTypes.PositioningConfigStatus?
    /// The device configuration information to use to create the Sidewalk device.
    public var sidewalk: IoTWirelessClientTypes.SidewalkCreateWirelessDevice?
    /// The tags to attach to the new wireless device. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?
    /// The wireless device type.
    /// This member is required.
    public var type: IoTWirelessClientTypes.WirelessDeviceType?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDevice? = nil,
        name: Swift.String? = nil,
        positioning: IoTWirelessClientTypes.PositioningConfigStatus? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkCreateWirelessDevice? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil,
        type: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.destinationName = destinationName
        self.loRaWAN = loRaWAN
        self.name = name
        self.positioning = positioning
        self.sidewalk = sidewalk
        self.tags = tags
        self.type = type
    }
}

public struct CreateWirelessDeviceOutput: Swift.Sendable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new wireless device.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWANGateway object.
    public struct LoRaWANGateway: Swift.Sendable {
        /// Beaconing object information, which consists of the data rate and frequency parameters.
        public var beaconing: IoTWirelessClientTypes.Beaconing?
        /// The gateway's EUI value.
        public var gatewayEui: Swift.String?
        /// A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.
        public var joinEuiFilters: [[Swift.String]]?
        /// The MaxEIRP value.
        public var maxEirp: Swift.Float?
        /// A list of NetId values that are used by LoRa gateways to filter the uplink frames.
        public var netIdFilters: [Swift.String]?
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// A list of integer indicating which sub bands are supported by LoRa gateway.
        public var subBands: [Swift.Int]?

        public init(
            beaconing: IoTWirelessClientTypes.Beaconing? = nil,
            gatewayEui: Swift.String? = nil,
            joinEuiFilters: [[Swift.String]]? = nil,
            maxEirp: Swift.Float? = nil,
            netIdFilters: [Swift.String]? = nil,
            rfRegion: Swift.String? = nil,
            subBands: [Swift.Int]? = nil
        )
        {
            self.beaconing = beaconing
            self.gatewayEui = gatewayEui
            self.joinEuiFilters = joinEuiFilters
            self.maxEirp = maxEirp
            self.netIdFilters = netIdFilters
            self.rfRegion = rfRegion
            self.subBands = subBands
        }
    }
}

public struct CreateWirelessGatewayInput: Swift.Sendable {
    /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see [Ensuring idempotency in Amazon EC2 API requests](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The gateway configuration information to use to create the wireless gateway.
    /// This member is required.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANGateway?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new wireless gateway. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANGateway? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

public struct CreateWirelessGatewayOutput: Swift.Sendable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new wireless gateway.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

public struct CreateWirelessGatewayTaskInput: Swift.Sendable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the WirelessGatewayTaskDefinition.
    /// This member is required.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init(
        id: Swift.String? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

extension IoTWirelessClientTypes {

    public enum WirelessGatewayTaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case firstRetry
        case inProgress
        case pending
        case secondRetry
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayTaskStatus] {
            return [
                .completed,
                .failed,
                .firstRetry,
                .inProgress,
                .pending,
                .secondRetry
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .firstRetry: return "FIRST_RETRY"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .secondRetry: return "SECOND_RETRY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateWirelessGatewayTaskOutput: Swift.Sendable {
    /// The status of the request.
    public var status: IoTWirelessClientTypes.WirelessGatewayTaskStatus?
    /// The ID of the WirelessGatewayTaskDefinition.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init(
        status: IoTWirelessClientTypes.WirelessGatewayTaskStatus? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.status = status
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWANGatewayVersion object.
    public struct LoRaWANGatewayVersion: Swift.Sendable {
        /// The model number of the wireless gateway.
        public var model: Swift.String?
        /// The version of the wireless gateway firmware.
        public var packageVersion: Swift.String?
        /// The basic station version of the wireless gateway.
        public var station: Swift.String?

        public init(
            model: Swift.String? = nil,
            packageVersion: Swift.String? = nil,
            station: Swift.String? = nil
        )
        {
            self.model = model
            self.packageVersion = packageVersion
            self.station = station
        }
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWANUpdateGatewayTaskCreate object.
    public struct LoRaWANUpdateGatewayTaskCreate: Swift.Sendable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?
        /// The CRC of the signature private key to check.
        public var sigKeyCrc: Swift.Int?
        /// The signature used to verify the update firmware.
        public var updateSignature: Swift.String?
        /// The firmware version to update the gateway to.
        public var updateVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?

        public init(
            currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil,
            sigKeyCrc: Swift.Int? = nil,
            updateSignature: Swift.String? = nil,
            updateVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
            self.sigKeyCrc = sigKeyCrc
            self.updateSignature = updateSignature
            self.updateVersion = updateVersion
        }
    }
}

extension IoTWirelessClientTypes {

    /// UpdateWirelessGatewayTaskCreate object.
    public struct UpdateWirelessGatewayTaskCreate: Swift.Sendable {
        /// The properties that relate to the LoRaWAN wireless gateway.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate?
        /// The IAM role used to read data from the S3 bucket.
        public var updateDataRole: Swift.String?
        /// The link to the S3 bucket.
        public var updateDataSource: Swift.String?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate? = nil,
            updateDataRole: Swift.String? = nil,
            updateDataSource: Swift.String? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.updateDataRole = updateDataRole
            self.updateDataSource = updateDataSource
        }
    }
}

public struct CreateWirelessGatewayTaskDefinitionInput: Swift.Sendable {
    /// Whether to automatically create tasks using this task definition for all gateways with the specified current version. If false, the task must me created by calling CreateWirelessGatewayTask.
    /// This member is required.
    public var autoCreateTasks: Swift.Bool?
    /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see [Ensuring idempotency in Amazon EC2 API requests](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?
    /// Information about the gateways to update.
    public var update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate?

    public init(
        autoCreateTasks: Swift.Bool? = false,
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil,
        update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate? = nil
    )
    {
        self.autoCreateTasks = autoCreateTasks
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.tags = tags
        self.update = update
    }
}

public struct CreateWirelessGatewayTaskDefinitionOutput: Swift.Sendable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the new wireless gateway task definition.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

extension IoTWirelessClientTypes {

    /// The device attestation key (DAK) information.
    public struct DakCertificateMetadata: Swift.Sendable {
        /// The advertised product ID (APID) that's used for pre-production and production applications.
        public var apId: Swift.String?
        /// The certificate ID for the DAK.
        /// This member is required.
        public var certificateId: Swift.String?
        /// The device type ID that's used for prototyping applications.
        public var deviceTypeId: Swift.String?
        /// Whether factory support has been enabled.
        public var factorySupport: Swift.Bool?
        /// The maximum number of signatures that the DAK can sign. A value of -1 indicates that there's no device limit.
        public var maxAllowedSignature: Swift.Int?

        public init(
            apId: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            deviceTypeId: Swift.String? = nil,
            factorySupport: Swift.Bool? = nil,
            maxAllowedSignature: Swift.Int? = nil
        )
        {
            self.apId = apId
            self.certificateId = certificateId
            self.deviceTypeId = deviceTypeId
            self.factorySupport = factorySupport
            self.maxAllowedSignature = maxAllowedSignature
        }
    }
}

public struct DeleteDestinationInput: Swift.Sendable {
    /// The name of the resource to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteDestinationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDeviceProfileInput: Swift.Sendable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteDeviceProfileOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFuotaTaskInput: Swift.Sendable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteFuotaTaskOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteMulticastGroupInput: Swift.Sendable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteMulticastGroupOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteNetworkAnalyzerConfigurationInput: Swift.Sendable {
    /// Name of the network analyzer configuration.
    /// This member is required.
    public var configurationName: Swift.String?

    public init(
        configurationName: Swift.String? = nil
    )
    {
        self.configurationName = configurationName
    }
}

public struct DeleteNetworkAnalyzerConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteQueuedMessagesInput: Swift.Sendable {
    /// The ID of a given wireless device for which downlink messages will be deleted.
    /// This member is required.
    public var id: Swift.String?
    /// If message ID is "*", it cleares the entire downlink queue for a given device, specified by the wireless device ID. Otherwise, the downlink message with the specified message ID will be deleted.
    /// This member is required.
    public var messageId: Swift.String?
    /// The wireless device type, which can be either Sidewalk or LoRaWAN.
    public var wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType?

    public init(
        id: Swift.String? = nil,
        messageId: Swift.String? = nil,
        wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.id = id
        self.messageId = messageId
        self.wirelessDeviceType = wirelessDeviceType
    }
}

public struct DeleteQueuedMessagesOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteServiceProfileInput: Swift.Sendable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteServiceProfileOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteWirelessDeviceInput: Swift.Sendable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteWirelessDeviceOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteWirelessDeviceImportTaskInput: Swift.Sendable {
    /// The unique identifier of the import task to be deleted.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteWirelessDeviceImportTaskOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteWirelessGatewayInput: Swift.Sendable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteWirelessGatewayOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteWirelessGatewayTaskInput: Swift.Sendable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteWirelessGatewayTaskOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteWirelessGatewayTaskDefinitionInput: Swift.Sendable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteWirelessGatewayTaskDefinitionOutput: Swift.Sendable {

    public init() { }
}

public struct DeregisterWirelessDeviceInput: Swift.Sendable {
    /// The identifier of the wireless device to deregister from AWS IoT Wireless.
    /// This member is required.
    public var identifier: Swift.String?
    /// The type of wireless device to deregister from AWS IoT Wireless, which can be LoRaWAN or Sidewalk.
    public var wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType?

    public init(
        identifier: Swift.String? = nil,
        wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.identifier = identifier
        self.wirelessDeviceType = wirelessDeviceType
    }
}

public struct DeregisterWirelessDeviceOutput: Swift.Sendable {

    public init() { }
}

extension IoTWirelessClientTypes {

    /// Describes a destination.
    public struct Destinations: Swift.Sendable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The description of the resource.
        public var description: Swift.String?
        /// The rule name or topic rule to send messages to.
        public var expression: Swift.String?
        /// The type of value in Expression.
        public var expressionType: IoTWirelessClientTypes.ExpressionType?
        /// The name of the resource.
        public var name: Swift.String?
        /// The ARN of the IAM Role that authorizes the destination.
        public var roleArn: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            expression: Swift.String? = nil,
            expressionType: IoTWirelessClientTypes.ExpressionType? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.expression = expression
            self.expressionType = expressionType
            self.name = name
            self.roleArn = roleArn
        }
    }
}

extension IoTWirelessClientTypes {

    /// Describes a device profile.
    public struct DeviceProfile: Swift.Sendable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the device profile.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }
}

extension IoTWirelessClientTypes {

    public enum DeviceProfileType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lorawan
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceProfileType] {
            return [
                .lorawan,
                .sidewalk
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lorawan: return "LoRaWAN"
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// SidewalkEventNotificationConfigurations object, which is the event configuration object for Sidewalk-related event topics.
    public struct SidewalkEventNotificationConfigurations: Swift.Sendable {
        /// Denotes whether the Amazon ID event topic is enabled or disabled.
        public var amazonIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            amazonIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.amazonIdEventTopic = amazonIdEventTopic
        }
    }
}

extension IoTWirelessClientTypes {

    /// Device registration state event configuration object for enabling and disabling relevant topics.
    public struct DeviceRegistrationStateEventConfiguration: Swift.Sendable {
        /// Device registration state event configuration object for enabling or disabling Sidewalk related event topics.
        public var sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations?
        /// Denotes whether the wireless device ID device registration state event topic is enabled or disabled.
        public var wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations? = nil,
            wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.sidewalk = sidewalk
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }
    }
}

extension IoTWirelessClientTypes {

    /// Sidewalk resource type event configuration object for enabling or disabling topic.
    public struct SidewalkResourceTypeEventConfiguration: Swift.Sendable {
        /// Denotes whether the wireless device join event topic is enabled or disabled.
        public var wirelessDeviceEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            wirelessDeviceEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.wirelessDeviceEventTopic = wirelessDeviceEventTopic
        }
    }
}

extension IoTWirelessClientTypes {

    /// Device registration state resource type event configuration object for enabling or disabling topic.
    public struct DeviceRegistrationStateResourceTypeEventConfiguration: Swift.Sendable {
        /// Device registration resource type state event configuration object for enabling or disabling Sidewalk related event topics.
        public var sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration?

        public init(
            sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration? = nil
        )
        {
            self.sidewalk = sidewalk
        }
    }
}

extension IoTWirelessClientTypes {

    /// Device state defines the device status of sidewalk device.
    public enum DeviceState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case provisioned
        case registerednotseen
        case registeredreachable
        case registeredunreachable
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceState] {
            return [
                .provisioned,
                .registerednotseen,
                .registeredreachable,
                .registeredunreachable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .provisioned: return "Provisioned"
            case .registerednotseen: return "RegisteredNotSeen"
            case .registeredreachable: return "RegisteredReachable"
            case .registeredunreachable: return "RegisteredUnreachable"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    public enum DimensionName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deviceid
        case gatewayid
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionName] {
            return [
                .deviceid,
                .gatewayid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deviceid: return "DeviceId"
            case .gatewayid: return "GatewayId"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// The required list of dimensions for the metric.
    public struct Dimension: Swift.Sendable {
        /// The name of the dimension.
        public var name: IoTWirelessClientTypes.DimensionName?
        /// The dimension's value.
        public var value: Swift.String?

        public init(
            name: IoTWirelessClientTypes.DimensionName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension IoTWirelessClientTypes {

    public enum PartnerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [PartnerType] {
            return [
                .sidewalk
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DisassociateAwsAccountFromPartnerAccountInput: Swift.Sendable {
    /// The partner account ID to disassociate from the AWS account.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IoTWirelessClientTypes.PartnerType?

    public init(
        partnerAccountId: Swift.String? = nil,
        partnerType: IoTWirelessClientTypes.PartnerType? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
    }
}

public struct DisassociateAwsAccountFromPartnerAccountOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateMulticastGroupFromFuotaTaskInput: Swift.Sendable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the multicast group.
    /// This member is required.
    public var multicastGroupId: Swift.String?

    public init(
        id: Swift.String? = nil,
        multicastGroupId: Swift.String? = nil
    )
    {
        self.id = id
        self.multicastGroupId = multicastGroupId
    }
}

public struct DisassociateMulticastGroupFromFuotaTaskOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateWirelessDeviceFromFuotaTaskInput: Swift.Sendable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init(
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

public struct DisassociateWirelessDeviceFromFuotaTaskOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateWirelessDeviceFromMulticastGroupInput: Swift.Sendable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init(
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

public struct DisassociateWirelessDeviceFromMulticastGroupOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateWirelessDeviceFromThingInput: Swift.Sendable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DisassociateWirelessDeviceFromThingOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateWirelessGatewayFromCertificateInput: Swift.Sendable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DisassociateWirelessGatewayFromCertificateOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateWirelessGatewayFromThingInput: Swift.Sendable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DisassociateWirelessGatewayFromThingOutput: Swift.Sendable {

    public init() { }
}

extension IoTWirelessClientTypes {

    public enum DownlinkMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case concurrent
        case sequential
        case usingUplinkGateway
        case sdkUnknown(Swift.String)

        public static var allCases: [DownlinkMode] {
            return [
                .concurrent,
                .sequential,
                .usingUplinkGateway
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .concurrent: return "CONCURRENT"
            case .sequential: return "SEQUENTIAL"
            case .usingUplinkGateway: return "USING_UPLINK_GATEWAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// Gateway list item object that specifies the frequency and list of gateways for which the downlink message should be sent.
    public struct GatewayListItem: Swift.Sendable {
        /// The frequency to use for the gateways when sending a downlink message to the wireless device.
        /// This member is required.
        public var downlinkFrequency: Swift.Int?
        /// The ID of the wireless gateways that you want to add to the list of gateways when sending downlink messages.
        /// This member is required.
        public var gatewayId: Swift.String?

        public init(
            downlinkFrequency: Swift.Int? = nil,
            gatewayId: Swift.String? = nil
        )
        {
            self.downlinkFrequency = downlinkFrequency
            self.gatewayId = gatewayId
        }
    }
}

extension IoTWirelessClientTypes {

    /// Specify the list of gateways to which you want to send downlink data traffic when the wireless device is running in class B or class C mode.
    public struct ParticipatingGateways: Swift.Sendable {
        /// Indicates whether to send the downlink message in sequential mode or concurrent mode, or to use only the chosen gateways from the previous uplink message transmission.
        /// This member is required.
        public var downlinkMode: IoTWirelessClientTypes.DownlinkMode?
        /// The list of gateways that you want to use for sending the downlink data traffic.
        /// This member is required.
        public var gatewayList: [IoTWirelessClientTypes.GatewayListItem]?
        /// The duration of time for which AWS IoT Core for LoRaWAN will wait before transmitting the payload to the next gateway.
        /// This member is required.
        public var transmissionInterval: Swift.Int?

        public init(
            downlinkMode: IoTWirelessClientTypes.DownlinkMode? = nil,
            gatewayList: [IoTWirelessClientTypes.GatewayListItem]? = nil,
            transmissionInterval: Swift.Int? = nil
        )
        {
            self.downlinkMode = downlinkMode
            self.gatewayList = gatewayList
            self.transmissionInterval = transmissionInterval
        }
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWAN router info.
    public struct LoRaWANSendDataToDevice: Swift.Sendable {
        /// The Fport value.
        public var fPort: Swift.Int?
        /// Choose the gateways that you want to use for the downlink data traffic when the wireless device is running in class B or class C mode.
        public var participatingGateways: IoTWirelessClientTypes.ParticipatingGateways?

        public init(
            fPort: Swift.Int? = nil,
            participatingGateways: IoTWirelessClientTypes.ParticipatingGateways? = nil
        )
        {
            self.fPort = fPort
            self.participatingGateways = participatingGateways
        }
    }
}

extension IoTWirelessClientTypes {

    /// The message in the downlink queue.
    public struct DownlinkQueueMessage: Swift.Sendable {
        /// LoRaWAN router info.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANSendDataToDevice?
        /// The message ID assigned by IoT Wireless to each downlink message, which helps identify the message.
        public var messageId: Swift.String?
        /// The time at which Iot Wireless received the downlink message.
        public var receivedAt: Swift.String?
        /// The transmit mode to use for sending data to the wireless device. This can be 0 for UM (unacknowledge mode) or 1 for AM (acknowledge mode).
        public var transmitMode: Swift.Int?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANSendDataToDevice? = nil,
            messageId: Swift.String? = nil,
            receivedAt: Swift.String? = nil,
            transmitMode: Swift.Int? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.messageId = messageId
            self.receivedAt = receivedAt
            self.transmitMode = transmitMode
        }
    }
}

extension IoTWirelessClientTypes {

    /// Sidewalk device status notification.
    public enum Event: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ack
        case discovered
        case lost
        case nack
        case passthrough
        case sdkUnknown(Swift.String)

        public static var allCases: [Event] {
            return [
                .ack,
                .discovered,
                .lost,
                .nack,
                .passthrough
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ack: return "ack"
            case .discovered: return "discovered"
            case .lost: return "lost"
            case .nack: return "nack"
            case .passthrough: return "passthrough"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// Object for LoRaWAN join resource type event configuration.
    public struct LoRaWANJoinEventNotificationConfigurations: Swift.Sendable {
        /// Denotes whether the Dev EUI join event topic is enabled or disabled.
        public var devEuiEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            devEuiEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.devEuiEventTopic = devEuiEventTopic
        }
    }
}

extension IoTWirelessClientTypes {

    /// Join event configuration object for enabling or disabling topic.
    public struct JoinEventConfiguration: Swift.Sendable {
        /// Join event configuration object for enabling or disabling LoRaWAN related event topics.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations?
        /// Denotes whether the wireless device ID join event topic is enabled or disabled.
        public var wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations? = nil,
            wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }
    }
}

extension IoTWirelessClientTypes {

    /// Message delivery status event configuration object for enabling and disabling relevant topics.
    public struct MessageDeliveryStatusEventConfiguration: Swift.Sendable {
        /// SidewalkEventNotificationConfigurations object, which is the event configuration object for Sidewalk-related event topics.
        public var sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations?
        /// Denotes whether the wireless device ID message delivery status event topic is enabled or disabled.
        public var wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations? = nil,
            wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.sidewalk = sidewalk
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }
    }
}

extension IoTWirelessClientTypes {

    /// Proximity event configuration object for enabling and disabling relevant topics.
    public struct ProximityEventConfiguration: Swift.Sendable {
        /// Proximity event configuration object for enabling or disabling Sidewalk related event topics.
        public var sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations?
        /// Denotes whether the wireless device ID proximity event topic is enabled or disabled.
        public var wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            sidewalk: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations? = nil,
            wirelessDeviceIdEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.sidewalk = sidewalk
            self.wirelessDeviceIdEventTopic = wirelessDeviceIdEventTopic
        }
    }
}

extension IoTWirelessClientTypes {

    /// Object of all event configurations and the status of the event topics.
    public struct EventNotificationItemConfigurations: Swift.Sendable {
        /// Connection status event configuration for an event configuration item.
        public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration?
        /// Device registration state event configuration for an event configuration item.
        public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
        /// Join event configuration for an event configuration item.
        public var join: IoTWirelessClientTypes.JoinEventConfiguration?
        /// Message delivery status event configuration for an event configuration item.
        public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration?
        /// Proximity event configuration for an event configuration item.
        public var proximity: IoTWirelessClientTypes.ProximityEventConfiguration?

        public init(
            connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration? = nil,
            deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration? = nil,
            join: IoTWirelessClientTypes.JoinEventConfiguration? = nil,
            messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration? = nil,
            proximity: IoTWirelessClientTypes.ProximityEventConfiguration? = nil
        )
        {
            self.connectionStatus = connectionStatus
            self.deviceRegistrationState = deviceRegistrationState
            self.join = join
            self.messageDeliveryStatus = messageDeliveryStatus
            self.proximity = proximity
        }
    }
}

extension IoTWirelessClientTypes {

    public enum IdentifierType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deveui
        case gatewayeui
        case partneraccountid
        case wirelessdeviceid
        case wirelessgatewayid
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentifierType] {
            return [
                .deveui,
                .gatewayeui,
                .partneraccountid,
                .wirelessdeviceid,
                .wirelessgatewayid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deveui: return "DevEui"
            case .gatewayeui: return "GatewayEui"
            case .partneraccountid: return "PartnerAccountId"
            case .wirelessdeviceid: return "WirelessDeviceId"
            case .wirelessgatewayid: return "WirelessGatewayId"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    public enum EventNotificationPartnerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [EventNotificationPartnerType] {
            return [
                .sidewalk
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// Event configuration object for a single resource.
    public struct EventConfigurationItem: Swift.Sendable {
        /// Object of all event configurations and the status of the event topics.
        public var events: IoTWirelessClientTypes.EventNotificationItemConfigurations?
        /// Resource identifier opted in for event messaging.
        public var identifier: Swift.String?
        /// Identifier type of the particular resource identifier for event configuration.
        public var identifierType: IoTWirelessClientTypes.IdentifierType?
        /// Partner type of the resource if the identifier type is PartnerAccountId.
        public var partnerType: IoTWirelessClientTypes.EventNotificationPartnerType?

        public init(
            events: IoTWirelessClientTypes.EventNotificationItemConfigurations? = nil,
            identifier: Swift.String? = nil,
            identifierType: IoTWirelessClientTypes.IdentifierType? = nil,
            partnerType: IoTWirelessClientTypes.EventNotificationPartnerType? = nil
        )
        {
            self.events = events
            self.identifier = identifier
            self.identifierType = identifierType
            self.partnerType = partnerType
        }
    }
}

extension IoTWirelessClientTypes {

    public enum EventNotificationResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sidewalkaccount
        case wirelessdevice
        case wirelessgateway
        case sdkUnknown(Swift.String)

        public static var allCases: [EventNotificationResourceType] {
            return [
                .sidewalkaccount,
                .wirelessdevice,
                .wirelessgateway
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sidewalkaccount: return "SidewalkAccount"
            case .wirelessdevice: return "WirelessDevice"
            case .wirelessgateway: return "WirelessGateway"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// The status of a wireless device in a FUOTA task.
    public enum FuotaDeviceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deviceExistInConflictFuotaTask
        case fragalgoUnsupported
        case fragindexUnsupported
        case initial
        case micerror
        case memoryerror
        case missingfrag
        case notEnoughMemory
        case packageNotSupported
        case sessioncntReplay
        case successful
        case wrongDescriptor
        case sdkUnknown(Swift.String)

        public static var allCases: [FuotaDeviceStatus] {
            return [
                .deviceExistInConflictFuotaTask,
                .fragalgoUnsupported,
                .fragindexUnsupported,
                .initial,
                .micerror,
                .memoryerror,
                .missingfrag,
                .notEnoughMemory,
                .packageNotSupported,
                .sessioncntReplay,
                .successful,
                .wrongDescriptor
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deviceExistInConflictFuotaTask: return "Device_exist_in_conflict_fuota_task"
            case .fragalgoUnsupported: return "FragAlgo_unsupported"
            case .fragindexUnsupported: return "FragIndex_unsupported"
            case .initial: return "Initial"
            case .micerror: return "MICError"
            case .memoryerror: return "MemoryError"
            case .missingfrag: return "MissingFrag"
            case .notEnoughMemory: return "Not_enough_memory"
            case .packageNotSupported: return "Package_Not_Supported"
            case .sessioncntReplay: return "SessionCnt_replay"
            case .successful: return "Successful"
            case .wrongDescriptor: return "Wrong_descriptor"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// A FUOTA task.
    public struct FuotaTask: Swift.Sendable {
        /// The arn of a FUOTA task.
        public var arn: Swift.String?
        /// The ID of a FUOTA task.
        public var id: Swift.String?
        /// The name of a FUOTA task.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }
}

extension IoTWirelessClientTypes {

    /// The status of a FUOTA task.
    public enum FuotaTaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleteWaiting
        case fuotadone
        case fuotasessionWaiting
        case inFuotasession
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [FuotaTaskStatus] {
            return [
                .deleteWaiting,
                .fuotadone,
                .fuotasessionWaiting,
                .inFuotasession,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleteWaiting: return "Delete_Waiting"
            case .fuotadone: return "FuotaDone"
            case .fuotasessionWaiting: return "FuotaSession_Waiting"
            case .inFuotasession: return "In_FuotaSession"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetDestinationInput: Swift.Sendable {
    /// The name of the resource to get.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct GetDestinationOutput: Swift.Sendable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The rule name or topic rule to send messages to.
    public var expression: Swift.String?
    /// The type of value in Expression.
    public var expressionType: IoTWirelessClientTypes.ExpressionType?
    /// The name of the resource.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    public var roleArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IoTWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
    }
}

public struct GetDeviceProfileInput: Swift.Sendable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension IoTWirelessClientTypes {

    /// Gets information about a Sidewalk device profile.
    public struct SidewalkGetDeviceProfile: Swift.Sendable {
        /// The Sidewalk application server public key.
        public var applicationServerPublicKey: Swift.String?
        /// The DAK certificate information of the Sidewalk device profile.
        public var dakCertificateMetadata: [IoTWirelessClientTypes.DakCertificateMetadata]?
        /// Gets information about the certification status of a Sidewalk device profile.
        public var qualificationStatus: Swift.Bool?

        public init(
            applicationServerPublicKey: Swift.String? = nil,
            dakCertificateMetadata: [IoTWirelessClientTypes.DakCertificateMetadata]? = nil,
            qualificationStatus: Swift.Bool? = nil
        )
        {
            self.applicationServerPublicKey = applicationServerPublicKey
            self.dakCertificateMetadata = dakCertificateMetadata
            self.qualificationStatus = qualificationStatus
        }
    }
}

extension IoTWirelessClientTypes.SidewalkGetDeviceProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkGetDeviceProfile(dakCertificateMetadata: \(Swift.String(describing: dakCertificateMetadata)), qualificationStatus: \(Swift.String(describing: qualificationStatus)), applicationServerPublicKey: \"CONTENT_REDACTED\")"}
}

public struct GetDeviceProfileOutput: Swift.Sendable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the device profile.
    public var id: Swift.String?
    /// Information about the device profile.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile?
    /// The name of the resource.
    public var name: Swift.String?
    /// Information about the Sidewalk parameters in the device profile.
    public var sidewalk: IoTWirelessClientTypes.SidewalkGetDeviceProfile?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceProfile? = nil,
        name: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkGetDeviceProfile? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.sidewalk = sidewalk
    }
}

public struct GetEventConfigurationByResourceTypesInput: Swift.Sendable {

    public init() { }
}

extension IoTWirelessClientTypes {

    /// Object for LoRaWAN join resource type event configuration.
    public struct LoRaWANJoinResourceTypeEventConfiguration: Swift.Sendable {
        /// Denotes whether the wireless device join event topic is enabled or disabled.
        public var wirelessDeviceEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus?

        public init(
            wirelessDeviceEventTopic: IoTWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.wirelessDeviceEventTopic = wirelessDeviceEventTopic
        }
    }
}

extension IoTWirelessClientTypes {

    /// Join resource type event configuration object for enabling or disabling topic.
    public struct JoinResourceTypeEventConfiguration: Swift.Sendable {
        /// Join resource type event configuration object for enabling or disabling LoRaWAN related event topics.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration? = nil
        )
        {
            self.loRaWAN = loRaWAN
        }
    }
}

extension IoTWirelessClientTypes {

    /// Message delivery status resource type event configuration object for enabling or disabling relevant topic.
    public struct MessageDeliveryStatusResourceTypeEventConfiguration: Swift.Sendable {
        /// Sidewalk resource type event configuration object for enabling or disabling topic.
        public var sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration?

        public init(
            sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration? = nil
        )
        {
            self.sidewalk = sidewalk
        }
    }
}

extension IoTWirelessClientTypes {

    /// Proximity resource type event configuration object for enabling or disabling topic.
    public struct ProximityResourceTypeEventConfiguration: Swift.Sendable {
        /// Proximity resource type event configuration object for enabling and disabling wireless device topic.
        public var sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration?

        public init(
            sidewalk: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration? = nil
        )
        {
            self.sidewalk = sidewalk
        }
    }
}

public struct GetEventConfigurationByResourceTypesOutput: Swift.Sendable {
    /// Resource type event configuration for the connection status event.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration?
    /// Resource type event configuration for the device registration state event.
    public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration?
    /// Resource type event configuration for the join event.
    public var join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration?
    /// Resource type event configuration object for the message delivery status event.
    public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration?
    /// Resource type event configuration for the proximity event.
    public var proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration?

    public init(
        connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration? = nil,
        deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration? = nil,
        join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration? = nil,
        messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration? = nil,
        proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.deviceRegistrationState = deviceRegistrationState
        self.join = join
        self.messageDeliveryStatus = messageDeliveryStatus
        self.proximity = proximity
    }
}

public struct GetFuotaTaskInput: Swift.Sendable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension IoTWirelessClientTypes {

    /// The LoRaWAN information returned from getting a FUOTA task.
    public struct LoRaWANFuotaTaskGetInfo: Swift.Sendable {
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// Start time of a FUOTA task.
        public var startTime: Foundation.Date?

        public init(
            rfRegion: Swift.String? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.rfRegion = rfRegion
            self.startTime = startTime
        }
    }
}

public struct GetFuotaTaskOutput: Swift.Sendable {
    /// The arn of a FUOTA task.
    public var arn: Swift.String?
    /// Created at timestamp for the resource.
    public var createdAt: Foundation.Date?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The S3 URI points to a firmware update image that is to be used with a FUOTA task.
    public var firmwareUpdateImage: Swift.String?
    /// The firmware update role that is to be used with a FUOTA task.
    public var firmwareUpdateRole: Swift.String?
    /// The interval for sending fragments in milliseconds, rounded to the nearest second. This interval only determines the timing for when the Cloud sends down the fragments to yor device. There can be a delay for when your device will receive these fragments. This delay depends on the device's class and the communication delay with the cloud.
    public var fragmentIntervalMS: Swift.Int?
    /// The size of each fragment in bytes. This parameter is supported only for FUOTA tasks with multicast groups.
    public var fragmentSizeBytes: Swift.Int?
    /// The ID of a FUOTA task.
    public var id: Swift.String?
    /// The LoRaWAN information returned from getting a FUOTA task.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo?
    /// The name of a FUOTA task.
    public var name: Swift.String?
    /// The percentage of the added fragments that are redundant. For example, if the size of the firmware image file is 100 bytes and the fragment size is 10 bytes, with RedundancyPercent set to 50(%), the final number of encoded fragments is (100 / 10) + (100 / 10 * 50%) = 15.
    public var redundancyPercent: Swift.Int?
    /// The status of a FUOTA task.
    public var status: IoTWirelessClientTypes.FuotaTaskStatus?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        firmwareUpdateImage: Swift.String? = nil,
        firmwareUpdateRole: Swift.String? = nil,
        fragmentIntervalMS: Swift.Int? = nil,
        fragmentSizeBytes: Swift.Int? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo? = nil,
        name: Swift.String? = nil,
        redundancyPercent: Swift.Int? = nil,
        status: IoTWirelessClientTypes.FuotaTaskStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.firmwareUpdateImage = firmwareUpdateImage
        self.firmwareUpdateRole = firmwareUpdateRole
        self.fragmentIntervalMS = fragmentIntervalMS
        self.fragmentSizeBytes = fragmentSizeBytes
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.redundancyPercent = redundancyPercent
        self.status = status
    }
}

public struct GetLogLevelsByResourceTypesInput: Swift.Sendable {

    public init() { }
}

extension IoTWirelessClientTypes {

    /// The event for a log message, if the log message is tied to a wireless device.
    public enum WirelessDeviceEvent: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case downlinkData
        case join
        case registration
        case rejoin
        case uplinkData
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceEvent] {
            return [
                .downlinkData,
                .join,
                .registration,
                .rejoin,
                .uplinkData
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .downlinkData: return "Downlink_Data"
            case .join: return "Join"
            case .registration: return "Registration"
            case .rejoin: return "Rejoin"
            case .uplinkData: return "Uplink_Data"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// The log options for a wireless device event and can be used to set log levels for a specific wireless device event. For a LoRaWAN device, possible events for a log messsage are: Join, Rejoin, Downlink_Data, and Uplink_Data. For a Sidewalk device, possible events for a log message are Registration, Downlink_Data, and Uplink_Data.
    public struct WirelessDeviceEventLogOption: Swift.Sendable {
        /// The event for a log message, if the log message is tied to a wireless device.
        /// This member is required.
        public var event: IoTWirelessClientTypes.WirelessDeviceEvent?
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        /// This member is required.
        public var logLevel: IoTWirelessClientTypes.LogLevel?

        public init(
            event: IoTWirelessClientTypes.WirelessDeviceEvent? = nil,
            logLevel: IoTWirelessClientTypes.LogLevel? = nil
        )
        {
            self.event = event
            self.logLevel = logLevel
        }
    }
}

extension IoTWirelessClientTypes {

    /// The log options for wireless devices and can be used to set log levels for a specific type of wireless device.
    public struct WirelessDeviceLogOption: Swift.Sendable {
        /// The list of wireless device event log options.
        public var events: [IoTWirelessClientTypes.WirelessDeviceEventLogOption]?
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        /// This member is required.
        public var logLevel: IoTWirelessClientTypes.LogLevel?
        /// The wireless device type.
        /// This member is required.
        public var type: IoTWirelessClientTypes.WirelessDeviceType?

        public init(
            events: [IoTWirelessClientTypes.WirelessDeviceEventLogOption]? = nil,
            logLevel: IoTWirelessClientTypes.LogLevel? = nil,
            type: IoTWirelessClientTypes.WirelessDeviceType? = nil
        )
        {
            self.events = events
            self.logLevel = logLevel
            self.type = type
        }
    }
}

extension IoTWirelessClientTypes {

    /// The event for a log message, if the log message is tied to a wireless gateway.
    public enum WirelessGatewayEvent: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cupsRequest
        case certificate
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayEvent] {
            return [
                .cupsRequest,
                .certificate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cupsRequest: return "CUPS_Request"
            case .certificate: return "Certificate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// The log options for a wireless gateway event and can be used to set log levels for a specific wireless gateway event. For a LoRaWAN gateway, possible events for a log message are CUPS_Request and Certificate.
    public struct WirelessGatewayEventLogOption: Swift.Sendable {
        /// The event for a log message, if the log message is tied to a wireless gateway.
        /// This member is required.
        public var event: IoTWirelessClientTypes.WirelessGatewayEvent?
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        /// This member is required.
        public var logLevel: IoTWirelessClientTypes.LogLevel?

        public init(
            event: IoTWirelessClientTypes.WirelessGatewayEvent? = nil,
            logLevel: IoTWirelessClientTypes.LogLevel? = nil
        )
        {
            self.event = event
            self.logLevel = logLevel
        }
    }
}

extension IoTWirelessClientTypes {

    /// The wireless gateway type.
    public enum WirelessGatewayType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lorawan
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayType] {
            return [
                .lorawan
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lorawan: return "LoRaWAN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// The log options for wireless gateways and can be used to set log levels for a specific type of wireless gateway.
    public struct WirelessGatewayLogOption: Swift.Sendable {
        /// The list of wireless gateway event log options.
        public var events: [IoTWirelessClientTypes.WirelessGatewayEventLogOption]?
        /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
        /// This member is required.
        public var logLevel: IoTWirelessClientTypes.LogLevel?
        /// The wireless gateway type.
        /// This member is required.
        public var type: IoTWirelessClientTypes.WirelessGatewayType?

        public init(
            events: [IoTWirelessClientTypes.WirelessGatewayEventLogOption]? = nil,
            logLevel: IoTWirelessClientTypes.LogLevel? = nil,
            type: IoTWirelessClientTypes.WirelessGatewayType? = nil
        )
        {
            self.events = events
            self.logLevel = logLevel
            self.type = type
        }
    }
}

public struct GetLogLevelsByResourceTypesOutput: Swift.Sendable {
    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    public var defaultLogLevel: IoTWirelessClientTypes.LogLevel?
    /// The list of wireless device log options.
    public var wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]?
    /// The list of wireless gateway log options.
    public var wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]?

    public init(
        defaultLogLevel: IoTWirelessClientTypes.LogLevel? = nil,
        wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]? = nil,
        wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.wirelessDeviceLogOptions = wirelessDeviceLogOptions
        self.wirelessGatewayLogOptions = wirelessGatewayLogOptions
    }
}

public struct GetMetricConfigurationInput: Swift.Sendable {

    public init() { }
}

extension IoTWirelessClientTypes {

    public enum SummaryMetricConfigurationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [SummaryMetricConfigurationStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// The configuration of summary metrics.
    public struct SummaryMetricConfiguration: Swift.Sendable {
        /// The status of the configuration of summary metrics.
        public var status: IoTWirelessClientTypes.SummaryMetricConfigurationStatus?

        public init(
            status: IoTWirelessClientTypes.SummaryMetricConfigurationStatus? = nil
        )
        {
            self.status = status
        }
    }
}

public struct GetMetricConfigurationOutput: Swift.Sendable {
    /// The configuration status of the AWS account for summary metric aggregation.
    public var summaryMetric: IoTWirelessClientTypes.SummaryMetricConfiguration?

    public init(
        summaryMetric: IoTWirelessClientTypes.SummaryMetricConfiguration? = nil
    )
    {
        self.summaryMetric = summaryMetric
    }
}

extension IoTWirelessClientTypes {

    public enum MetricName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsaccountactivedevicecount
        case awsaccountactivegatewaycount
        case awsaccountdevicecount
        case awsaccountdownlinkcount
        case awsaccountgatewaycount
        case awsaccountjoinacceptcount
        case awsaccountjoinrequestcount
        case awsaccountroamingdownlinkcount
        case awsaccountroaminguplinkcount
        case awsaccountuplinkcount
        case awsaccountuplinklostcount
        case awsaccountuplinklostrate
        case devicedownlinkcount
        case devicejoinacceptcount
        case devicejoinrequestcount
        case devicerssi
        case deviceroamingdownlinkcount
        case deviceroamingrssi
        case deviceroamingsnr
        case deviceroaminguplinkcount
        case devicesnr
        case deviceuplinkcount
        case deviceuplinklostcount
        case deviceuplinklostrate
        case gatewaydowntime
        case gatewaydownlinkcount
        case gatewayjoinacceptcount
        case gatewayjoinrequestcount
        case gatewayrssi
        case gatewaysnr
        case gatewayuptime
        case gatewayuplinkcount
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricName] {
            return [
                .awsaccountactivedevicecount,
                .awsaccountactivegatewaycount,
                .awsaccountdevicecount,
                .awsaccountdownlinkcount,
                .awsaccountgatewaycount,
                .awsaccountjoinacceptcount,
                .awsaccountjoinrequestcount,
                .awsaccountroamingdownlinkcount,
                .awsaccountroaminguplinkcount,
                .awsaccountuplinkcount,
                .awsaccountuplinklostcount,
                .awsaccountuplinklostrate,
                .devicedownlinkcount,
                .devicejoinacceptcount,
                .devicejoinrequestcount,
                .devicerssi,
                .deviceroamingdownlinkcount,
                .deviceroamingrssi,
                .deviceroamingsnr,
                .deviceroaminguplinkcount,
                .devicesnr,
                .deviceuplinkcount,
                .deviceuplinklostcount,
                .deviceuplinklostrate,
                .gatewaydowntime,
                .gatewaydownlinkcount,
                .gatewayjoinacceptcount,
                .gatewayjoinrequestcount,
                .gatewayrssi,
                .gatewaysnr,
                .gatewayuptime,
                .gatewayuplinkcount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsaccountactivedevicecount: return "AwsAccountActiveDeviceCount"
            case .awsaccountactivegatewaycount: return "AwsAccountActiveGatewayCount"
            case .awsaccountdevicecount: return "AwsAccountDeviceCount"
            case .awsaccountdownlinkcount: return "AwsAccountDownlinkCount"
            case .awsaccountgatewaycount: return "AwsAccountGatewayCount"
            case .awsaccountjoinacceptcount: return "AwsAccountJoinAcceptCount"
            case .awsaccountjoinrequestcount: return "AwsAccountJoinRequestCount"
            case .awsaccountroamingdownlinkcount: return "AwsAccountRoamingDownlinkCount"
            case .awsaccountroaminguplinkcount: return "AwsAccountRoamingUplinkCount"
            case .awsaccountuplinkcount: return "AwsAccountUplinkCount"
            case .awsaccountuplinklostcount: return "AwsAccountUplinkLostCount"
            case .awsaccountuplinklostrate: return "AwsAccountUplinkLostRate"
            case .devicedownlinkcount: return "DeviceDownlinkCount"
            case .devicejoinacceptcount: return "DeviceJoinAcceptCount"
            case .devicejoinrequestcount: return "DeviceJoinRequestCount"
            case .devicerssi: return "DeviceRSSI"
            case .deviceroamingdownlinkcount: return "DeviceRoamingDownlinkCount"
            case .deviceroamingrssi: return "DeviceRoamingRSSI"
            case .deviceroamingsnr: return "DeviceRoamingSNR"
            case .deviceroaminguplinkcount: return "DeviceRoamingUplinkCount"
            case .devicesnr: return "DeviceSNR"
            case .deviceuplinkcount: return "DeviceUplinkCount"
            case .deviceuplinklostcount: return "DeviceUplinkLostCount"
            case .deviceuplinklostrate: return "DeviceUplinkLostRate"
            case .gatewaydowntime: return "GatewayDownTime"
            case .gatewaydownlinkcount: return "GatewayDownlinkCount"
            case .gatewayjoinacceptcount: return "GatewayJoinAcceptCount"
            case .gatewayjoinrequestcount: return "GatewayJoinRequestCount"
            case .gatewayrssi: return "GatewayRSSI"
            case .gatewaysnr: return "GatewaySNR"
            case .gatewayuptime: return "GatewayUpTime"
            case .gatewayuplinkcount: return "GatewayUplinkCount"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// The summary metric query object.
    public struct SummaryMetricQuery: Swift.Sendable {
        /// The aggregation period of the summary metric.
        public var aggregationPeriod: IoTWirelessClientTypes.AggregationPeriod?
        /// The dimensions of the summary metric.
        public var dimensions: [IoTWirelessClientTypes.Dimension]?
        /// The end timestamp for the summary metric query.
        public var endTimestamp: Foundation.Date?
        /// The name of the metric.
        public var metricName: IoTWirelessClientTypes.MetricName?
        /// The id of the summary metric query.
        public var queryId: Swift.String?
        /// The start timestamp for the summary metric query.
        public var startTimestamp: Foundation.Date?

        public init(
            aggregationPeriod: IoTWirelessClientTypes.AggregationPeriod? = nil,
            dimensions: [IoTWirelessClientTypes.Dimension]? = nil,
            endTimestamp: Foundation.Date? = nil,
            metricName: IoTWirelessClientTypes.MetricName? = nil,
            queryId: Swift.String? = nil,
            startTimestamp: Foundation.Date? = nil
        )
        {
            self.aggregationPeriod = aggregationPeriod
            self.dimensions = dimensions
            self.endTimestamp = endTimestamp
            self.metricName = metricName
            self.queryId = queryId
            self.startTimestamp = startTimestamp
        }
    }
}

public struct GetMetricsInput: Swift.Sendable {
    /// The list of queries to retrieve the summary metrics.
    public var summaryMetricQueries: [IoTWirelessClientTypes.SummaryMetricQuery]?

    public init(
        summaryMetricQueries: [IoTWirelessClientTypes.SummaryMetricQuery]? = nil
    )
    {
        self.summaryMetricQueries = summaryMetricQueries
    }
}

extension IoTWirelessClientTypes {

    public enum MetricQueryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricQueryStatus] {
            return [
                .failed,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// The aggregated values of the metric.
    public struct MetricQueryValue: Swift.Sendable {
        /// The average of the values of all data points collected during the aggregation period.
        public var avg: Swift.Double?
        /// The maximum of the values of all the data points collected during the aggregation period.
        public var max: Swift.Double?
        /// The minimum of the values of all data points collected during the aggregation period.
        public var min: Swift.Double?
        /// The 90th percentile of the values of all data points collected during the aggregation period.
        public var p90: Swift.Double?
        /// The standard deviation of the values of all data points collected during the aggregation period.
        public var std: Swift.Double?
        /// The sum of the values of all data points collected during the aggregation period.
        public var sum: Swift.Double?

        public init(
            avg: Swift.Double? = nil,
            max: Swift.Double? = nil,
            min: Swift.Double? = nil,
            p90: Swift.Double? = nil,
            std: Swift.Double? = nil,
            sum: Swift.Double? = nil
        )
        {
            self.avg = avg
            self.max = max
            self.min = min
            self.p90 = p90
            self.std = std
            self.sum = sum
        }
    }
}

extension IoTWirelessClientTypes {

    /// The result of the summary metrics aggregation operation.
    public struct SummaryMetricQueryResult: Swift.Sendable {
        /// The aggregation period of the metric.
        public var aggregationPeriod: IoTWirelessClientTypes.AggregationPeriod?
        /// The dimensions of the metric.
        public var dimensions: [IoTWirelessClientTypes.Dimension]?
        /// The end timestamp for the summary metric query.
        public var endTimestamp: Foundation.Date?
        /// The error message for the summary metric query result.
        public var error: Swift.String?
        /// The name of the summary metric query result.
        public var metricName: IoTWirelessClientTypes.MetricName?
        /// The ID of the summary metric results query operation.
        public var queryId: Swift.String?
        /// The status of the summary metric query result.
        public var queryStatus: IoTWirelessClientTypes.MetricQueryStatus?
        /// The start timestamp for the summary metric query.
        public var startTimestamp: Foundation.Date?
        /// The timestamp of each aggregation result.
        public var timestamps: [Foundation.Date]?
        /// The units of measurement to be used for interpreting the aggregation result.
        public var unit: Swift.String?
        /// The list of aggregated summary metric query results.
        public var values: [IoTWirelessClientTypes.MetricQueryValue]?

        public init(
            aggregationPeriod: IoTWirelessClientTypes.AggregationPeriod? = nil,
            dimensions: [IoTWirelessClientTypes.Dimension]? = nil,
            endTimestamp: Foundation.Date? = nil,
            error: Swift.String? = nil,
            metricName: IoTWirelessClientTypes.MetricName? = nil,
            queryId: Swift.String? = nil,
            queryStatus: IoTWirelessClientTypes.MetricQueryStatus? = nil,
            startTimestamp: Foundation.Date? = nil,
            timestamps: [Foundation.Date]? = nil,
            unit: Swift.String? = nil,
            values: [IoTWirelessClientTypes.MetricQueryValue]? = nil
        )
        {
            self.aggregationPeriod = aggregationPeriod
            self.dimensions = dimensions
            self.endTimestamp = endTimestamp
            self.error = error
            self.metricName = metricName
            self.queryId = queryId
            self.queryStatus = queryStatus
            self.startTimestamp = startTimestamp
            self.timestamps = timestamps
            self.unit = unit
            self.values = values
        }
    }
}

public struct GetMetricsOutput: Swift.Sendable {
    /// The list of summary metrics that were retrieved.
    public var summaryMetricQueryResults: [IoTWirelessClientTypes.SummaryMetricQueryResult]?

    public init(
        summaryMetricQueryResults: [IoTWirelessClientTypes.SummaryMetricQueryResult]? = nil
    )
    {
        self.summaryMetricQueryResults = summaryMetricQueryResults
    }
}

public struct GetMulticastGroupInput: Swift.Sendable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension IoTWirelessClientTypes {

    /// The LoRaWAN information that is to be returned from getting multicast group information.
    public struct LoRaWANMulticastGet: Swift.Sendable {
        /// DlClass for LoRaWAM, valid values are ClassB and ClassC.
        public var dlClass: IoTWirelessClientTypes.DlClass?
        /// Number of devices that are associated to the multicast group.
        public var numberOfDevicesInGroup: Swift.Int?
        /// Number of devices that are requested to be associated with the multicast group.
        public var numberOfDevicesRequested: Swift.Int?
        /// Supported RfRegions
        public var rfRegion: IoTWirelessClientTypes.SupportedRfRegion?

        public init(
            dlClass: IoTWirelessClientTypes.DlClass? = nil,
            numberOfDevicesInGroup: Swift.Int? = nil,
            numberOfDevicesRequested: Swift.Int? = nil,
            rfRegion: IoTWirelessClientTypes.SupportedRfRegion? = nil
        )
        {
            self.dlClass = dlClass
            self.numberOfDevicesInGroup = numberOfDevicesInGroup
            self.numberOfDevicesRequested = numberOfDevicesRequested
            self.rfRegion = rfRegion
        }
    }
}

public struct GetMulticastGroupOutput: Swift.Sendable {
    /// The arn of the multicast group.
    public var arn: Swift.String?
    /// Created at timestamp for the resource.
    public var createdAt: Foundation.Date?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The ID of the multicast group.
    public var id: Swift.String?
    /// The LoRaWAN information that is to be returned from getting multicast group information.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastGet?
    /// The name of the multicast group.
    public var name: Swift.String?
    /// The status of the multicast group.
    public var status: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastGet? = nil,
        name: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.status = status
    }
}

public struct GetMulticastGroupSessionInput: Swift.Sendable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension IoTWirelessClientTypes {

    /// The LoRaWAN information used with the multicast session.
    public struct LoRaWANMulticastSession: Swift.Sendable {
        /// Downlink data rate.
        public var dlDr: Swift.Int?
        /// Downlink frequency.
        public var dlFreq: Swift.Int?
        /// The PingSlotPeriod value.
        public var pingSlotPeriod: Swift.Int?
        /// Timestamp of when the multicast group session is to start.
        public var sessionStartTime: Foundation.Date?
        /// How long before a multicast group session is to timeout.
        public var sessionTimeout: Swift.Int?

        public init(
            dlDr: Swift.Int? = nil,
            dlFreq: Swift.Int? = nil,
            pingSlotPeriod: Swift.Int? = nil,
            sessionStartTime: Foundation.Date? = nil,
            sessionTimeout: Swift.Int? = nil
        )
        {
            self.dlDr = dlDr
            self.dlFreq = dlFreq
            self.pingSlotPeriod = pingSlotPeriod
            self.sessionStartTime = sessionStartTime
            self.sessionTimeout = sessionTimeout
        }
    }
}

public struct GetMulticastGroupSessionOutput: Swift.Sendable {
    /// The LoRaWAN information used with the multicast session.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession?

    public init(
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession? = nil
    )
    {
        self.loRaWAN = loRaWAN
    }
}

public struct GetNetworkAnalyzerConfigurationInput: Swift.Sendable {
    /// Name of the network analyzer configuration.
    /// This member is required.
    public var configurationName: Swift.String?

    public init(
        configurationName: Swift.String? = nil
    )
    {
        self.configurationName = configurationName
    }
}

public struct GetNetworkAnalyzerConfigurationOutput: Swift.Sendable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// List of multicast group resources that have been added to the network analyzer configuration.
    public var multicastGroups: [Swift.String]?
    /// Name of the network analyzer configuration.
    public var name: Swift.String?
    /// Trace content for your wireless devices, gateways, and multicast groups.
    public var traceContent: IoTWirelessClientTypes.TraceContent?
    /// List of wireless device resources that have been added to the network analyzer configuration.
    public var wirelessDevices: [Swift.String]?
    /// List of wireless gateway resources that have been added to the network analyzer configuration.
    public var wirelessGateways: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        multicastGroups: [Swift.String]? = nil,
        name: Swift.String? = nil,
        traceContent: IoTWirelessClientTypes.TraceContent? = nil,
        wirelessDevices: [Swift.String]? = nil,
        wirelessGateways: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.multicastGroups = multicastGroups
        self.name = name
        self.traceContent = traceContent
        self.wirelessDevices = wirelessDevices
        self.wirelessGateways = wirelessGateways
    }
}

public struct GetPartnerAccountInput: Swift.Sendable {
    /// The partner account ID to disassociate from the AWS account.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IoTWirelessClientTypes.PartnerType?

    public init(
        partnerAccountId: Swift.String? = nil,
        partnerType: IoTWirelessClientTypes.PartnerType? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
    }
}

extension IoTWirelessClientTypes {

    /// Information about a Sidewalk account.
    public struct SidewalkAccountInfoWithFingerprint: Swift.Sendable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The fingerprint of the Sidewalk application server private key.
        public var fingerprint: Swift.String?

        public init(
            amazonId: Swift.String? = nil,
            arn: Swift.String? = nil,
            fingerprint: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.arn = arn
            self.fingerprint = fingerprint
        }
    }
}

extension IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkAccountInfoWithFingerprint(amazonId: \(Swift.String(describing: amazonId)), arn: \(Swift.String(describing: arn)), fingerprint: \"CONTENT_REDACTED\")"}
}

public struct GetPartnerAccountOutput: Swift.Sendable {
    /// Whether the partner account is linked to the AWS account.
    public var accountLinked: Swift.Bool
    /// The Sidewalk account credentials.
    public var sidewalk: IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint?

    public init(
        accountLinked: Swift.Bool = false,
        sidewalk: IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint? = nil
    )
    {
        self.accountLinked = accountLinked
        self.sidewalk = sidewalk
    }
}

extension IoTWirelessClientTypes {

    public enum PositionResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case wirelessdevice
        case wirelessgateway
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionResourceType] {
            return [
                .wirelessdevice,
                .wirelessgateway
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .wirelessdevice: return "WirelessDevice"
            case .wirelessgateway: return "WirelessGateway"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct GetPositionInput: Swift.Sendable {
    /// Resource identifier used to retrieve the position information.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// Resource type of the resource for which position information is retrieved.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init(
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

extension IoTWirelessClientTypes {

    public enum PositionSolverProvider: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case semtech
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionSolverProvider] {
            return [
                .semtech
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .semtech: return "Semtech"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    public enum PositionSolverType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gnss
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionSolverType] {
            return [
                .gnss
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gnss: return "GNSS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct GetPositionOutput: Swift.Sendable {
    /// The accuracy of the estimated position in meters. An empty value indicates that no position data is available. A value of ‘0.0’ value indicates that position data is available. This data corresponds to the position information that you specified instead of the position computed by solver.
    public var accuracy: IoTWirelessClientTypes.Accuracy?
    /// The position information of the resource.
    public var position: [Swift.Float]?
    /// The vendor of the positioning solver.
    public var solverProvider: IoTWirelessClientTypes.PositionSolverProvider?
    /// The type of solver used to identify the position of the resource.
    public var solverType: IoTWirelessClientTypes.PositionSolverType?
    /// The version of the positioning solver.
    public var solverVersion: Swift.String?
    /// The timestamp at which the device's position was determined.
    public var timestamp: Swift.String?

    public init(
        accuracy: IoTWirelessClientTypes.Accuracy? = nil,
        position: [Swift.Float]? = nil,
        solverProvider: IoTWirelessClientTypes.PositionSolverProvider? = nil,
        solverType: IoTWirelessClientTypes.PositionSolverType? = nil,
        solverVersion: Swift.String? = nil,
        timestamp: Swift.String? = nil
    )
    {
        self.accuracy = accuracy
        self.position = position
        self.solverProvider = solverProvider
        self.solverType = solverType
        self.solverVersion = solverVersion
        self.timestamp = timestamp
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct GetPositionConfigurationInput: Swift.Sendable {
    /// Resource identifier used in a position configuration.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// Resource type of the resource for which position configuration is retrieved.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init(
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

extension IoTWirelessClientTypes {

    public enum PositionConfigurationFec: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case rose
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionConfigurationFec] {
            return [
                .none,
                .rose
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .rose: return "ROSE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    public enum PositionConfigurationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PositionConfigurationStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// Details of the Semtech GNSS solver object.
    public struct SemtechGnssDetail: Swift.Sendable {
        /// Whether forward error correction is enabled.
        public var fec: IoTWirelessClientTypes.PositionConfigurationFec?
        /// The vendor of the solver object.
        public var provider: IoTWirelessClientTypes.PositionSolverProvider?
        /// The status indicating whether the solver is enabled.
        public var status: IoTWirelessClientTypes.PositionConfigurationStatus?
        /// The type of positioning solver used.
        public var type: IoTWirelessClientTypes.PositionSolverType?

        public init(
            fec: IoTWirelessClientTypes.PositionConfigurationFec? = nil,
            provider: IoTWirelessClientTypes.PositionSolverProvider? = nil,
            status: IoTWirelessClientTypes.PositionConfigurationStatus? = nil,
            type: IoTWirelessClientTypes.PositionSolverType? = nil
        )
        {
            self.fec = fec
            self.provider = provider
            self.status = status
            self.type = type
        }
    }
}

extension IoTWirelessClientTypes {

    /// The wrapper for position solver details.
    public struct PositionSolverDetails: Swift.Sendable {
        /// The Semtech GNSS solver object details.
        public var semtechGnss: IoTWirelessClientTypes.SemtechGnssDetail?

        public init(
            semtechGnss: IoTWirelessClientTypes.SemtechGnssDetail? = nil
        )
        {
            self.semtechGnss = semtechGnss
        }
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct GetPositionConfigurationOutput: Swift.Sendable {
    /// The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
    public var destination: Swift.String?
    /// The wrapper for the solver configuration details object.
    public var solvers: IoTWirelessClientTypes.PositionSolverDetails?

    public init(
        destination: Swift.String? = nil,
        solvers: IoTWirelessClientTypes.PositionSolverDetails? = nil
    )
    {
        self.destination = destination
        self.solvers = solvers
    }
}

extension IoTWirelessClientTypes {

    /// Global navigation satellite system (GNSS) object used for positioning.
    public struct Gnss: Swift.Sendable {
        /// Optional assistance altitude, which is the altitude of the device at capture time, specified in meters above the WGS84 reference ellipsoid.
        public var assistAltitude: Swift.Float?
        /// Optional assistance position information, specified using latitude and longitude values in degrees. The coordinates are inside the WGS84 reference frame.
        public var assistPosition: [Swift.Float]?
        /// Optional parameter that gives an estimate of the time when the GNSS scan information is taken, in seconds GPS time (GPST). If capture time is not specified, the local server time is used.
        public var captureTime: Swift.Float?
        /// Optional value that gives the capture time estimate accuracy, in seconds. If capture time accuracy is not specified, default value of 300 is used.
        public var captureTimeAccuracy: Swift.Float?
        /// Payload that contains the GNSS scan result, or NAV message, in hexadecimal notation.
        /// This member is required.
        public var payload: Swift.String?
        /// Optional parameter that forces 2D solve, which modifies the positioning algorithm to a 2D solution problem. When this parameter is specified, the assistance altitude should have an accuracy of at least 10 meters.
        public var use2DSolver: Swift.Bool

        public init(
            assistAltitude: Swift.Float? = nil,
            assistPosition: [Swift.Float]? = nil,
            captureTime: Swift.Float? = nil,
            captureTimeAccuracy: Swift.Float? = nil,
            payload: Swift.String? = nil,
            use2DSolver: Swift.Bool = false
        )
        {
            self.assistAltitude = assistAltitude
            self.assistPosition = assistPosition
            self.captureTime = captureTime
            self.captureTimeAccuracy = captureTimeAccuracy
            self.payload = payload
            self.use2DSolver = use2DSolver
        }
    }
}

extension IoTWirelessClientTypes {

    /// IP address used for resolving device location.
    public struct Ip: Swift.Sendable {
        /// IP address information.
        /// This member is required.
        public var ipAddress: Swift.String?

        public init(
            ipAddress: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
        }
    }
}

extension IoTWirelessClientTypes {

    /// Wi-Fi access point.
    public struct WiFiAccessPoint: Swift.Sendable {
        /// Wi-Fi MAC Address.
        /// This member is required.
        public var macAddress: Swift.String?
        /// Received signal strength (dBm) of the WLAN measurement data.
        /// This member is required.
        public var rss: Swift.Int?

        public init(
            macAddress: Swift.String? = nil,
            rss: Swift.Int? = nil
        )
        {
            self.macAddress = macAddress
            self.rss = rss
        }
    }
}

public struct GetPositionEstimateInput: Swift.Sendable {
    /// Retrieves an estimated device position by resolving measurement data from cellular radio towers. The position is resolved using HERE's cellular-based solver.
    public var cellTowers: IoTWirelessClientTypes.CellTowers?
    /// Retrieves an estimated device position by resolving the global navigation satellite system (GNSS) scan data. The position is resolved using the GNSS solver powered by LoRa Cloud.
    public var gnss: IoTWirelessClientTypes.Gnss?
    /// Retrieves an estimated device position by resolving the IP address information from the device. The position is resolved using MaxMind's IP-based solver.
    public var ip: IoTWirelessClientTypes.Ip?
    /// Optional information that specifies the time when the position information will be resolved. It uses the Unix timestamp format. If not specified, the time at which the request was received will be used.
    public var timestamp: Foundation.Date?
    /// Retrieves an estimated device position by resolving WLAN measurement data. The position is resolved using HERE's Wi-Fi based solver.
    public var wiFiAccessPoints: [IoTWirelessClientTypes.WiFiAccessPoint]?

    public init(
        cellTowers: IoTWirelessClientTypes.CellTowers? = nil,
        gnss: IoTWirelessClientTypes.Gnss? = nil,
        ip: IoTWirelessClientTypes.Ip? = nil,
        timestamp: Foundation.Date? = nil,
        wiFiAccessPoints: [IoTWirelessClientTypes.WiFiAccessPoint]? = nil
    )
    {
        self.cellTowers = cellTowers
        self.gnss = gnss
        self.ip = ip
        self.timestamp = timestamp
        self.wiFiAccessPoints = wiFiAccessPoints
    }
}

public struct GetPositionEstimateOutput: Swift.Sendable {
    /// The position information of the resource, displayed as a JSON payload. The payload is of type blob and uses the [GeoJSON](https://geojson.org/) format, which a format that's used to encode geographic data structures. A sample payload contains the timestamp information, the WGS84 coordinates of the location, and the accuracy and confidence level. For more information and examples, see [Resolve device location (console)](https://docs.aws.amazon.com/iot/latest/developerguide/location-resolve-console.html).
    public var geoJsonPayload: Foundation.Data?

    public init(
        geoJsonPayload: Foundation.Data? = nil
    )
    {
        self.geoJsonPayload = geoJsonPayload
    }
}

public struct GetResourceEventConfigurationInput: Swift.Sendable {
    /// Resource identifier to opt in for event messaging.
    /// This member is required.
    public var identifier: Swift.String?
    /// Identifier type of the particular resource identifier for event configuration.
    /// This member is required.
    public var identifierType: IoTWirelessClientTypes.IdentifierType?
    /// Partner type of the resource if the identifier type is PartnerAccountId.
    public var partnerType: IoTWirelessClientTypes.EventNotificationPartnerType?

    public init(
        identifier: Swift.String? = nil,
        identifierType: IoTWirelessClientTypes.IdentifierType? = nil,
        partnerType: IoTWirelessClientTypes.EventNotificationPartnerType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
        self.partnerType = partnerType
    }
}

public struct GetResourceEventConfigurationOutput: Swift.Sendable {
    /// Event configuration for the connection status event.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration?
    /// Event configuration for the device registration state event.
    public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
    /// Event configuration for the join event.
    public var join: IoTWirelessClientTypes.JoinEventConfiguration?
    /// Event configuration for the message delivery status event.
    public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration?
    /// Event configuration for the proximity event.
    public var proximity: IoTWirelessClientTypes.ProximityEventConfiguration?

    public init(
        connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration? = nil,
        deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration? = nil,
        join: IoTWirelessClientTypes.JoinEventConfiguration? = nil,
        messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration? = nil,
        proximity: IoTWirelessClientTypes.ProximityEventConfiguration? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.deviceRegistrationState = deviceRegistrationState
        self.join = join
        self.messageDeliveryStatus = messageDeliveryStatus
        self.proximity = proximity
    }
}

public struct GetResourceLogLevelInput: Swift.Sendable {
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway, it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

public struct GetResourceLogLevelOutput: Swift.Sendable {
    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    public var logLevel: IoTWirelessClientTypes.LogLevel?

    public init(
        logLevel: IoTWirelessClientTypes.LogLevel? = nil
    )
    {
        self.logLevel = logLevel
    }
}

public struct GetResourcePositionInput: Swift.Sendable {
    /// The identifier of the resource for which position information is retrieved. It can be the wireless device ID or the wireless gateway ID, depending on the resource type.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of resource for which position information is retrieved, which can be a wireless device or a wireless gateway.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init(
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

public struct GetResourcePositionOutput: Swift.Sendable {
    /// The position information of the resource, displayed as a JSON payload. The payload uses the GeoJSON format, which a format that's used to encode geographic data structures. For more information, see [GeoJSON](https://geojson.org/).
    public var geoJsonPayload: Foundation.Data?

    public init(
        geoJsonPayload: Foundation.Data? = nil
    )
    {
        self.geoJsonPayload = geoJsonPayload
    }
}

extension IoTWirelessClientTypes {

    public enum WirelessGatewayServiceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cups
        case lns
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayServiceType] {
            return [
                .cups,
                .lns
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cups: return "CUPS"
            case .lns: return "LNS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetServiceEndpointInput: Swift.Sendable {
    /// The service type for which to get endpoint information about. Can be CUPS for the Configuration and Update Server endpoint, or LNS for the LoRaWAN Network Server endpoint or CLAIM for the global endpoint.
    public var serviceType: IoTWirelessClientTypes.WirelessGatewayServiceType?

    public init(
        serviceType: IoTWirelessClientTypes.WirelessGatewayServiceType? = nil
    )
    {
        self.serviceType = serviceType
    }
}

public struct GetServiceEndpointOutput: Swift.Sendable {
    /// The Root CA of the server trust certificate.
    public var serverTrust: Swift.String?
    /// The service endpoint value.
    public var serviceEndpoint: Swift.String?
    /// The endpoint's service type.
    public var serviceType: IoTWirelessClientTypes.WirelessGatewayServiceType?

    public init(
        serverTrust: Swift.String? = nil,
        serviceEndpoint: Swift.String? = nil,
        serviceType: IoTWirelessClientTypes.WirelessGatewayServiceType? = nil
    )
    {
        self.serverTrust = serverTrust
        self.serviceEndpoint = serviceEndpoint
        self.serviceType = serviceType
    }
}

public struct GetServiceProfileInput: Swift.Sendable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWANGetServiceProfileInfo object.
    public struct LoRaWANGetServiceProfileInfo: Swift.Sendable {
        /// The AddGWMetaData value.
        public var addGwMetadata: Swift.Bool
        /// The ChannelMask value.
        public var channelMask: Swift.String?
        /// The DevStatusReqFreq value.
        public var devStatusReqFreq: Swift.Int?
        /// The DLBucketSize value.
        public var dlBucketSize: Swift.Int?
        /// The DLRate value.
        public var dlRate: Swift.Int?
        /// The DLRatePolicy value.
        public var dlRatePolicy: Swift.String?
        /// The DRMax value.
        public var drMax: Swift.Int
        /// The DRMin value.
        public var drMin: Swift.Int
        /// The HRAllowed value that describes whether handover roaming is allowed.
        public var hrAllowed: Swift.Bool
        /// The MinGwDiversity value.
        public var minGwDiversity: Swift.Int?
        /// The NwkGeoLoc value.
        public var nwkGeoLoc: Swift.Bool
        /// The PRAllowed value that describes whether passive roaming is allowed.
        public var prAllowed: Swift.Bool
        /// The RAAllowed value that describes whether roaming activation is allowed.
        public var raAllowed: Swift.Bool
        /// The ReportDevStatusBattery value.
        public var reportDevStatusBattery: Swift.Bool
        /// The ReportDevStatusMargin value.
        public var reportDevStatusMargin: Swift.Bool
        /// The TargetPER value.
        public var targetPer: Swift.Int
        /// The ULBucketSize value.
        public var ulBucketSize: Swift.Int?
        /// The ULRate value.
        public var ulRate: Swift.Int?
        /// The ULRatePolicy value.
        public var ulRatePolicy: Swift.String?

        public init(
            addGwMetadata: Swift.Bool = false,
            channelMask: Swift.String? = nil,
            devStatusReqFreq: Swift.Int? = nil,
            dlBucketSize: Swift.Int? = nil,
            dlRate: Swift.Int? = nil,
            dlRatePolicy: Swift.String? = nil,
            drMax: Swift.Int = 0,
            drMin: Swift.Int = 0,
            hrAllowed: Swift.Bool = false,
            minGwDiversity: Swift.Int? = nil,
            nwkGeoLoc: Swift.Bool = false,
            prAllowed: Swift.Bool = false,
            raAllowed: Swift.Bool = false,
            reportDevStatusBattery: Swift.Bool = false,
            reportDevStatusMargin: Swift.Bool = false,
            targetPer: Swift.Int = 0,
            ulBucketSize: Swift.Int? = nil,
            ulRate: Swift.Int? = nil,
            ulRatePolicy: Swift.String? = nil
        )
        {
            self.addGwMetadata = addGwMetadata
            self.channelMask = channelMask
            self.devStatusReqFreq = devStatusReqFreq
            self.dlBucketSize = dlBucketSize
            self.dlRate = dlRate
            self.dlRatePolicy = dlRatePolicy
            self.drMax = drMax
            self.drMin = drMin
            self.hrAllowed = hrAllowed
            self.minGwDiversity = minGwDiversity
            self.nwkGeoLoc = nwkGeoLoc
            self.prAllowed = prAllowed
            self.raAllowed = raAllowed
            self.reportDevStatusBattery = reportDevStatusBattery
            self.reportDevStatusMargin = reportDevStatusMargin
            self.targetPer = targetPer
            self.ulBucketSize = ulBucketSize
            self.ulRate = ulRate
            self.ulRatePolicy = ulRatePolicy
        }
    }
}

public struct GetServiceProfileOutput: Swift.Sendable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the service profile.
    public var id: Swift.String?
    /// Information about the service profile.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo?
    /// The name of the resource.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

extension IoTWirelessClientTypes {

    public enum WirelessDeviceIdType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deveui
        case sidewalkmanufacturingsn
        case thingname
        case wirelessdeviceid
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceIdType] {
            return [
                .deveui,
                .sidewalkmanufacturingsn,
                .thingname,
                .wirelessdeviceid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deveui: return "DevEui"
            case .sidewalkmanufacturingsn: return "SidewalkManufacturingSn"
            case .thingname: return "ThingName"
            case .wirelessdeviceid: return "WirelessDeviceId"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetWirelessDeviceInput: Swift.Sendable {
    /// The identifier of the wireless device to get.
    /// This member is required.
    public var identifier: Swift.String?
    /// The type of identifier used in identifier.
    /// This member is required.
    public var identifierType: IoTWirelessClientTypes.WirelessDeviceIdType?

    public init(
        identifier: Swift.String? = nil,
        identifierType: IoTWirelessClientTypes.WirelessDeviceIdType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
    }
}

extension IoTWirelessClientTypes {

    public enum WirelessDeviceSidewalkStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activated
        case provisioned
        case registered
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceSidewalkStatus] {
            return [
                .activated,
                .provisioned,
                .registered,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .provisioned: return "PROVISIONED"
            case .registered: return "REGISTERED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// Sidewalk device object.
    public struct SidewalkDevice: Swift.Sendable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The ID of the Sidewalk device profile.
        public var certificateId: Swift.String?
        /// The sidewalk device certificates for Ed25519 and P256r1.
        public var deviceCertificates: [IoTWirelessClientTypes.CertificateList]?
        /// The ID of the Sidewalk device profile.
        public var deviceProfileId: Swift.String?
        /// The Sidewalk device private keys that will be used for onboarding the device.
        public var privateKeys: [IoTWirelessClientTypes.CertificateList]?
        /// The sidewalk device identification.
        public var sidewalkId: Swift.String?
        /// The Sidewalk manufacturing series number.
        public var sidewalkManufacturingSn: Swift.String?
        /// The Sidewalk device status, such as provisioned or registered.
        public var status: IoTWirelessClientTypes.WirelessDeviceSidewalkStatus?

        public init(
            amazonId: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            deviceCertificates: [IoTWirelessClientTypes.CertificateList]? = nil,
            deviceProfileId: Swift.String? = nil,
            privateKeys: [IoTWirelessClientTypes.CertificateList]? = nil,
            sidewalkId: Swift.String? = nil,
            sidewalkManufacturingSn: Swift.String? = nil,
            status: IoTWirelessClientTypes.WirelessDeviceSidewalkStatus? = nil
        )
        {
            self.amazonId = amazonId
            self.certificateId = certificateId
            self.deviceCertificates = deviceCertificates
            self.deviceProfileId = deviceProfileId
            self.privateKeys = privateKeys
            self.sidewalkId = sidewalkId
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
            self.status = status
        }
    }
}

public struct GetWirelessDeviceOutput: Swift.Sendable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The name of the destination to which the device is assigned.
    public var destinationName: Swift.String?
    /// The ID of the wireless device.
    public var id: Swift.String?
    /// Information about the wireless device.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDevice?
    /// The name of the resource.
    public var name: Swift.String?
    /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
    public var positioning: IoTWirelessClientTypes.PositioningConfigStatus?
    /// Sidewalk device object.
    public var sidewalk: IoTWirelessClientTypes.SidewalkDevice?
    /// The ARN of the thing associated with the wireless device.
    public var thingArn: Swift.String?
    /// The name of the thing associated with the wireless device. The value is empty if a thing isn't associated with the device.
    public var thingName: Swift.String?
    /// The wireless device type.
    public var type: IoTWirelessClientTypes.WirelessDeviceType?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDevice? = nil,
        name: Swift.String? = nil,
        positioning: IoTWirelessClientTypes.PositioningConfigStatus? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkDevice? = nil,
        thingArn: Swift.String? = nil,
        thingName: Swift.String? = nil,
        type: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.destinationName = destinationName
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.positioning = positioning
        self.sidewalk = sidewalk
        self.thingArn = thingArn
        self.thingName = thingName
        self.type = type
    }
}

public struct GetWirelessDeviceImportTaskInput: Swift.Sendable {
    /// The identifier of the import task for which information is requested.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension IoTWirelessClientTypes {

    /// Sidewalk-related information for devices in an import task that are being onboarded.
    public struct SidewalkGetStartImportInfo: Swift.Sendable {
        /// List of Sidewalk devices that are added to the import task.
        public var deviceCreationFileList: [Swift.String]?
        /// The IAM role that allows AWS IoT Wireless to access the CSV file in the S3 bucket.
        public var role: Swift.String?

        public init(
            deviceCreationFileList: [Swift.String]? = nil,
            role: Swift.String? = nil
        )
        {
            self.deviceCreationFileList = deviceCreationFileList
            self.role = role
        }
    }
}

extension IoTWirelessClientTypes {

    public enum ImportTaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case deleting
        case failed
        case initialized
        case initializing
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportTaskStatus] {
            return [
                .complete,
                .deleting,
                .failed,
                .initialized,
                .initializing,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .initialized: return "INITIALIZED"
            case .initializing: return "INITIALIZING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetWirelessDeviceImportTaskOutput: Swift.Sendable {
    /// The ARN (Amazon Resource Name) of the import task.
    public var arn: Swift.String?
    /// The time at which the import task was created.
    public var creationTime: Foundation.Date?
    /// The name of the destination that's assigned to the wireless devices in the import task.
    public var destinationName: Swift.String?
    /// The number of devices in the import task that failed to onboard to the import task.
    public var failedImportedDeviceCount: Swift.Int?
    /// The identifier of the import task for which information is retrieved.
    public var id: Swift.String?
    /// The number of devices in the import task that are waiting for the control log to start processing.
    public var initializedImportedDeviceCount: Swift.Int?
    /// The number of devices in the import task that have been onboarded to the import task.
    public var onboardedImportedDeviceCount: Swift.Int?
    /// The number of devices in the import task that are waiting in the import task queue to be onboarded.
    public var pendingImportedDeviceCount: Swift.Int?
    /// The Sidewalk-related information about an import task.
    public var sidewalk: IoTWirelessClientTypes.SidewalkGetStartImportInfo?
    /// The import task status.
    public var status: IoTWirelessClientTypes.ImportTaskStatus?
    /// The reason for the provided status information, such as a validation error that causes the import task to fail.
    public var statusReason: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        destinationName: Swift.String? = nil,
        failedImportedDeviceCount: Swift.Int? = nil,
        id: Swift.String? = nil,
        initializedImportedDeviceCount: Swift.Int? = nil,
        onboardedImportedDeviceCount: Swift.Int? = nil,
        pendingImportedDeviceCount: Swift.Int? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkGetStartImportInfo? = nil,
        status: IoTWirelessClientTypes.ImportTaskStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.destinationName = destinationName
        self.failedImportedDeviceCount = failedImportedDeviceCount
        self.id = id
        self.initializedImportedDeviceCount = initializedImportedDeviceCount
        self.onboardedImportedDeviceCount = onboardedImportedDeviceCount
        self.pendingImportedDeviceCount = pendingImportedDeviceCount
        self.sidewalk = sidewalk
        self.status = status
        self.statusReason = statusReason
    }
}

public struct GetWirelessDeviceStatisticsInput: Swift.Sendable {
    /// The ID of the wireless device for which to get the data.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init(
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.wirelessDeviceId = wirelessDeviceId
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWAN gateway metatdata.
    public struct LoRaWANGatewayMetadata: Swift.Sendable {
        /// The gateway's EUI value.
        public var gatewayEui: Swift.String?
        /// The RSSI value.
        public var rssi: Swift.Double?
        /// The SNR value.
        public var snr: Swift.Double?

        public init(
            gatewayEui: Swift.String? = nil,
            rssi: Swift.Double? = nil,
            snr: Swift.Double? = nil
        )
        {
            self.gatewayEui = gatewayEui
            self.rssi = rssi
            self.snr = snr
        }
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWAN public gateway metadata.
    public struct LoRaWANPublicGatewayMetadata: Swift.Sendable {
        /// Boolean that indicates whether downlink is allowed using the network.
        public var dlAllowed: Swift.Bool?
        /// The ID of the gateways that are operated by the network provider.
        public var id: Swift.String?
        /// The ID of the LoRaWAN public network provider.
        public var providerNetId: Swift.String?
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// The RSSI (received signal strength indicator) value.
        public var rssi: Swift.Double?
        /// The SNR (signal to noise ratio) value.
        public var snr: Swift.Double?

        public init(
            dlAllowed: Swift.Bool? = nil,
            id: Swift.String? = nil,
            providerNetId: Swift.String? = nil,
            rfRegion: Swift.String? = nil,
            rssi: Swift.Double? = nil,
            snr: Swift.Double? = nil
        )
        {
            self.dlAllowed = dlAllowed
            self.id = id
            self.providerNetId = providerNetId
            self.rfRegion = rfRegion
            self.rssi = rssi
            self.snr = snr
        }
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWAN device metatdata.
    public struct LoRaWANDeviceMetadata: Swift.Sendable {
        /// The DataRate value.
        public var dataRate: Swift.Int?
        /// The DevEUI value.
        public var devEui: Swift.String?
        /// The FPort value.
        public var fPort: Swift.Int?
        /// The device's channel frequency in Hz.
        public var frequency: Swift.Int?
        /// Information about the gateways accessed by the device.
        public var gateways: [IoTWirelessClientTypes.LoRaWANGatewayMetadata]?
        /// Information about the LoRaWAN public network accessed by the device.
        public var publicGateways: [IoTWirelessClientTypes.LoRaWANPublicGatewayMetadata]?
        /// The date and time of the metadata.
        public var timestamp: Swift.String?

        public init(
            dataRate: Swift.Int? = nil,
            devEui: Swift.String? = nil,
            fPort: Swift.Int? = nil,
            frequency: Swift.Int? = nil,
            gateways: [IoTWirelessClientTypes.LoRaWANGatewayMetadata]? = nil,
            publicGateways: [IoTWirelessClientTypes.LoRaWANPublicGatewayMetadata]? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.dataRate = dataRate
            self.devEui = devEui
            self.fPort = fPort
            self.frequency = frequency
            self.gateways = gateways
            self.publicGateways = publicGateways
            self.timestamp = timestamp
        }
    }
}

extension IoTWirelessClientTypes {

    /// MetaData for Sidewalk device.
    public struct SidewalkDeviceMetadata: Swift.Sendable {
        /// Sidewalk device battery level.
        public var batteryLevel: IoTWirelessClientTypes.BatteryLevel?
        /// Device state defines the device status of sidewalk device.
        public var deviceState: IoTWirelessClientTypes.DeviceState?
        /// Sidewalk device status notification.
        public var event: IoTWirelessClientTypes.Event?
        /// The RSSI value.
        public var rssi: Swift.Int?

        public init(
            batteryLevel: IoTWirelessClientTypes.BatteryLevel? = nil,
            deviceState: IoTWirelessClientTypes.DeviceState? = nil,
            event: IoTWirelessClientTypes.Event? = nil,
            rssi: Swift.Int? = nil
        )
        {
            self.batteryLevel = batteryLevel
            self.deviceState = deviceState
            self.event = event
            self.rssi = rssi
        }
    }
}

public struct GetWirelessDeviceStatisticsOutput: Swift.Sendable {
    /// The date and time when the most recent uplink was received. This value is only valid for 3 months.
    public var lastUplinkReceivedAt: Swift.String?
    /// Information about the wireless device's operations.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceMetadata?
    /// MetaData for Sidewalk device.
    public var sidewalk: IoTWirelessClientTypes.SidewalkDeviceMetadata?
    /// The ID of the wireless device.
    public var wirelessDeviceId: Swift.String?

    public init(
        lastUplinkReceivedAt: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANDeviceMetadata? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkDeviceMetadata? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.loRaWAN = loRaWAN
        self.sidewalk = sidewalk
        self.wirelessDeviceId = wirelessDeviceId
    }
}

extension IoTWirelessClientTypes {

    public enum WirelessGatewayIdType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gatewayeui
        case thingname
        case wirelessgatewayid
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayIdType] {
            return [
                .gatewayeui,
                .thingname,
                .wirelessgatewayid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gatewayeui: return "GatewayEui"
            case .thingname: return "ThingName"
            case .wirelessgatewayid: return "WirelessGatewayId"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetWirelessGatewayInput: Swift.Sendable {
    /// The identifier of the wireless gateway to get.
    /// This member is required.
    public var identifier: Swift.String?
    /// The type of identifier used in identifier.
    /// This member is required.
    public var identifierType: IoTWirelessClientTypes.WirelessGatewayIdType?

    public init(
        identifier: Swift.String? = nil,
        identifierType: IoTWirelessClientTypes.WirelessGatewayIdType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
    }
}

public struct GetWirelessGatewayOutput: Swift.Sendable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The ID of the wireless gateway.
    public var id: Swift.String?
    /// Information about the wireless gateway.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANGateway?
    /// The name of the resource.
    public var name: Swift.String?
    /// The ARN of the thing associated with the wireless gateway.
    public var thingArn: Swift.String?
    /// The name of the thing associated with the wireless gateway. The value is empty if a thing isn't associated with the gateway.
    public var thingName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANGateway? = nil,
        name: Swift.String? = nil,
        thingArn: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.thingArn = thingArn
        self.thingName = thingName
    }
}

public struct GetWirelessGatewayCertificateInput: Swift.Sendable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetWirelessGatewayCertificateOutput: Swift.Sendable {
    /// The ID of the certificate associated with the wireless gateway.
    public var iotCertificateId: Swift.String?
    /// The ID of the certificate that is associated with the wireless gateway and used for the LoRaWANNetworkServer endpoint.
    public var loRaWANNetworkServerCertificateId: Swift.String?

    public init(
        iotCertificateId: Swift.String? = nil,
        loRaWANNetworkServerCertificateId: Swift.String? = nil
    )
    {
        self.iotCertificateId = iotCertificateId
        self.loRaWANNetworkServerCertificateId = loRaWANNetworkServerCertificateId
    }
}

public struct GetWirelessGatewayFirmwareInformationInput: Swift.Sendable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWANGatewayCurrentVersion object.
    public struct LoRaWANGatewayCurrentVersion: Swift.Sendable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?

        public init(
            currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
        }
    }
}

public struct GetWirelessGatewayFirmwareInformationOutput: Swift.Sendable {
    /// Information about the wireless gateway's firmware.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion?

    public init(
        loRaWAN: IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion? = nil
    )
    {
        self.loRaWAN = loRaWAN
    }
}

public struct GetWirelessGatewayStatisticsInput: Swift.Sendable {
    /// The ID of the wireless gateway for which to get the data.
    /// This member is required.
    public var wirelessGatewayId: Swift.String?

    public init(
        wirelessGatewayId: Swift.String? = nil
    )
    {
        self.wirelessGatewayId = wirelessGatewayId
    }
}

public struct GetWirelessGatewayStatisticsOutput: Swift.Sendable {
    /// The connection status of the wireless gateway.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatus?
    /// The date and time when the most recent uplink was received. This value is only valid for 3 months.
    public var lastUplinkReceivedAt: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayId: Swift.String?

    public init(
        connectionStatus: IoTWirelessClientTypes.ConnectionStatus? = nil,
        lastUplinkReceivedAt: Swift.String? = nil,
        wirelessGatewayId: Swift.String? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.wirelessGatewayId = wirelessGatewayId
    }
}

public struct GetWirelessGatewayTaskInput: Swift.Sendable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetWirelessGatewayTaskOutput: Swift.Sendable {
    /// The date and time when the most recent uplink was received. This value is only valid for 3 months.
    public var lastUplinkReceivedAt: Swift.String?
    /// The status of the request.
    public var status: IoTWirelessClientTypes.WirelessGatewayTaskStatus?
    /// The date and time when the task was created.
    public var taskCreatedAt: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayId: Swift.String?
    /// The ID of the WirelessGatewayTask.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init(
        lastUplinkReceivedAt: Swift.String? = nil,
        status: IoTWirelessClientTypes.WirelessGatewayTaskStatus? = nil,
        taskCreatedAt: Swift.String? = nil,
        wirelessGatewayId: Swift.String? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.status = status
        self.taskCreatedAt = taskCreatedAt
        self.wirelessGatewayId = wirelessGatewayId
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

public struct GetWirelessGatewayTaskDefinitionInput: Swift.Sendable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetWirelessGatewayTaskDefinitionOutput: Swift.Sendable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// Whether to automatically create tasks using this task definition for all gateways with the specified current version. If false, the task must me created by calling CreateWirelessGatewayTask.
    public var autoCreateTasks: Swift.Bool
    /// The name of the resource.
    public var name: Swift.String?
    /// Information about the gateways to update.
    public var update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate?

    public init(
        arn: Swift.String? = nil,
        autoCreateTasks: Swift.Bool = false,
        name: Swift.String? = nil,
        update: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate? = nil
    )
    {
        self.arn = arn
        self.autoCreateTasks = autoCreateTasks
        self.name = name
        self.update = update
    }
}

extension IoTWirelessClientTypes {

    public enum OnboardStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case initialized
        case onboarded
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [OnboardStatus] {
            return [
                .failed,
                .initialized,
                .onboarded,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .initialized: return "INITIALIZED"
            case .onboarded: return "ONBOARDED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// Information about a Sidewalk device that has been added to an import task.
    public struct ImportedSidewalkDevice: Swift.Sendable {
        /// The time at which the status information was last updated.
        public var lastUpdateTime: Foundation.Date?
        /// The onboarding status of the Sidewalk device in the import task.
        public var onboardingStatus: IoTWirelessClientTypes.OnboardStatus?
        /// The reason for the onboarding status information for the Sidewalk device.
        public var onboardingStatusReason: Swift.String?
        /// The Sidewalk manufacturing serial number (SMSN) of the Sidewalk device.
        public var sidewalkManufacturingSn: Swift.String?

        public init(
            lastUpdateTime: Foundation.Date? = nil,
            onboardingStatus: IoTWirelessClientTypes.OnboardStatus? = nil,
            onboardingStatusReason: Swift.String? = nil,
            sidewalkManufacturingSn: Swift.String? = nil
        )
        {
            self.lastUpdateTime = lastUpdateTime
            self.onboardingStatus = onboardingStatus
            self.onboardingStatusReason = onboardingStatusReason
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
        }
    }
}

extension IoTWirelessClientTypes {

    /// Information about a wireless device that has been added to an import task.
    public struct ImportedWirelessDevice: Swift.Sendable {
        /// The Sidewalk-related information about a device that has been added to an import task.
        public var sidewalk: IoTWirelessClientTypes.ImportedSidewalkDevice?

        public init(
            sidewalk: IoTWirelessClientTypes.ImportedSidewalkDevice? = nil
        )
        {
            self.sidewalk = sidewalk
        }
    }
}

public struct ListDestinationsInput: Swift.Sendable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDestinationsOutput: Swift.Sendable {
    /// The list of destinations.
    public var destinationList: [IoTWirelessClientTypes.Destinations]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        destinationList: [IoTWirelessClientTypes.Destinations]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationList = destinationList
        self.nextToken = nextToken
    }
}

public struct ListDeviceProfilesInput: Swift.Sendable {
    /// A filter to list only device profiles that use this type, which can be LoRaWAN or Sidewalk.
    public var deviceProfileType: IoTWirelessClientTypes.DeviceProfileType?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        deviceProfileType: IoTWirelessClientTypes.DeviceProfileType? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceProfileType = deviceProfileType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDeviceProfilesOutput: Swift.Sendable {
    /// The list of device profiles.
    public var deviceProfileList: [IoTWirelessClientTypes.DeviceProfile]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deviceProfileList: [IoTWirelessClientTypes.DeviceProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceProfileList = deviceProfileList
        self.nextToken = nextToken
    }
}

public struct ListDevicesForWirelessDeviceImportTaskInput: Swift.Sendable {
    /// The identifier of the import task for which wireless devices are listed.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The status of the devices in the import task.
    public var status: IoTWirelessClientTypes.OnboardStatus?

    public init(
        id: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        status: IoTWirelessClientTypes.OnboardStatus? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

public struct ListDevicesForWirelessDeviceImportTaskOutput: Swift.Sendable {
    /// The name of the Sidewalk destination that describes the IoT rule to route messages received from devices in an import task that are onboarded to AWS IoT Wireless.
    public var destinationName: Swift.String?
    /// List of wireless devices in an import task and their onboarding status.
    public var importedWirelessDeviceList: [IoTWirelessClientTypes.ImportedWirelessDevice]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        destinationName: Swift.String? = nil,
        importedWirelessDeviceList: [IoTWirelessClientTypes.ImportedWirelessDevice]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationName = destinationName
        self.importedWirelessDeviceList = importedWirelessDeviceList
        self.nextToken = nextToken
    }
}

public struct ListEventConfigurationsInput: Swift.Sendable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// Resource type to filter event configurations.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.EventNotificationResourceType?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.EventNotificationResourceType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

public struct ListEventConfigurationsOutput: Swift.Sendable {
    /// Event configurations of all events for a single resource.
    public var eventConfigurationsList: [IoTWirelessClientTypes.EventConfigurationItem]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        eventConfigurationsList: [IoTWirelessClientTypes.EventConfigurationItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventConfigurationsList = eventConfigurationsList
        self.nextToken = nextToken
    }
}

public struct ListFuotaTasksInput: Swift.Sendable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFuotaTasksOutput: Swift.Sendable {
    /// Lists the FUOTA tasks registered to your AWS account.
    public var fuotaTaskList: [IoTWirelessClientTypes.FuotaTask]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        fuotaTaskList: [IoTWirelessClientTypes.FuotaTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fuotaTaskList = fuotaTaskList
        self.nextToken = nextToken
    }
}

public struct ListMulticastGroupsInput: Swift.Sendable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTWirelessClientTypes {

    /// A multicast group.
    public struct MulticastGroup: Swift.Sendable {
        /// The arn of the multicast group.
        public var arn: Swift.String?
        /// The ID of the multicast group.
        public var id: Swift.String?
        /// The name of the multicast group.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }
}

public struct ListMulticastGroupsOutput: Swift.Sendable {
    /// List of multicast groups.
    public var multicastGroupList: [IoTWirelessClientTypes.MulticastGroup]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        multicastGroupList: [IoTWirelessClientTypes.MulticastGroup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.multicastGroupList = multicastGroupList
        self.nextToken = nextToken
    }
}

public struct ListMulticastGroupsByFuotaTaskInput: Swift.Sendable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        id: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTWirelessClientTypes {

    /// A multicast group that is associated with a FUOTA task.
    public struct MulticastGroupByFuotaTask: Swift.Sendable {
        /// The ID of the multicast group.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }
}

public struct ListMulticastGroupsByFuotaTaskOutput: Swift.Sendable {
    /// List of multicast groups associated with a FUOTA task.
    public var multicastGroupList: [IoTWirelessClientTypes.MulticastGroupByFuotaTask]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        multicastGroupList: [IoTWirelessClientTypes.MulticastGroupByFuotaTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.multicastGroupList = multicastGroupList
        self.nextToken = nextToken
    }
}

public struct ListNetworkAnalyzerConfigurationsInput: Swift.Sendable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTWirelessClientTypes {

    /// Network analyzer configurations.
    public struct NetworkAnalyzerConfigurations: Swift.Sendable {
        /// The Amazon Resource Name of the new resource.
        public var arn: Swift.String?
        /// Name of the network analyzer configuration.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }
}

public struct ListNetworkAnalyzerConfigurationsOutput: Swift.Sendable {
    /// The list of network analyzer configurations.
    public var networkAnalyzerConfigurationList: [IoTWirelessClientTypes.NetworkAnalyzerConfigurations]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        networkAnalyzerConfigurationList: [IoTWirelessClientTypes.NetworkAnalyzerConfigurations]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkAnalyzerConfigurationList = networkAnalyzerConfigurationList
        self.nextToken = nextToken
    }
}

public struct ListPartnerAccountsInput: Swift.Sendable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListPartnerAccountsOutput: Swift.Sendable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The Sidewalk account credentials.
    public var sidewalk: [IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint]?

    public init(
        nextToken: Swift.String? = nil,
        sidewalk: [IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint]? = nil
    )
    {
        self.nextToken = nextToken
        self.sidewalk = sidewalk
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct ListPositionConfigurationsInput: Swift.Sendable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// Resource type for which position configurations are listed.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

extension IoTWirelessClientTypes {

    /// The wrapper for a position configuration.
    public struct PositionConfigurationItem: Swift.Sendable {
        /// The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
        public var destination: Swift.String?
        /// Resource identifier for the position configuration.
        public var resourceIdentifier: Swift.String?
        /// Resource type of the resource for the position configuration.
        public var resourceType: IoTWirelessClientTypes.PositionResourceType?
        /// The details of the positioning solver object used to compute the location.
        public var solvers: IoTWirelessClientTypes.PositionSolverDetails?

        public init(
            destination: Swift.String? = nil,
            resourceIdentifier: Swift.String? = nil,
            resourceType: IoTWirelessClientTypes.PositionResourceType? = nil,
            solvers: IoTWirelessClientTypes.PositionSolverDetails? = nil
        )
        {
            self.destination = destination
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
            self.solvers = solvers
        }
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct ListPositionConfigurationsOutput: Swift.Sendable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of position configurations.
    public var positionConfigurationList: [IoTWirelessClientTypes.PositionConfigurationItem]?

    public init(
        nextToken: Swift.String? = nil,
        positionConfigurationList: [IoTWirelessClientTypes.PositionConfigurationItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.positionConfigurationList = positionConfigurationList
    }
}

public struct ListQueuedMessagesInput: Swift.Sendable {
    /// The ID of a given wireless device which the downlink message packets are being sent.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The wireless device type, whic can be either Sidewalk or LoRaWAN.
    public var wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType?

    public init(
        id: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.wirelessDeviceType = wirelessDeviceType
    }
}

public struct ListQueuedMessagesOutput: Swift.Sendable {
    /// The messages in the downlink queue.
    public var downlinkQueueMessagesList: [IoTWirelessClientTypes.DownlinkQueueMessage]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        downlinkQueueMessagesList: [IoTWirelessClientTypes.DownlinkQueueMessage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.downlinkQueueMessagesList = downlinkQueueMessagesList
        self.nextToken = nextToken
    }
}

public struct ListServiceProfilesInput: Swift.Sendable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTWirelessClientTypes {

    /// Information about a service profile.
    public struct ServiceProfile: Swift.Sendable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the service profile.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }
}

public struct ListServiceProfilesOutput: Swift.Sendable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of service profiles.
    public var serviceProfileList: [IoTWirelessClientTypes.ServiceProfile]?

    public init(
        nextToken: Swift.String? = nil,
        serviceProfileList: [IoTWirelessClientTypes.ServiceProfile]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceProfileList = serviceProfileList
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource for which you want to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListWirelessDeviceImportTasksInput: Swift.Sendable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTWirelessClientTypes {

    /// Information about an import task for wireless devices.
    public struct WirelessDeviceImportTask: Swift.Sendable {
        /// The ARN (Amazon Resource Name) of the wireless device import task.
        public var arn: Swift.String?
        /// The time at which the import task was created.
        public var creationTime: Foundation.Date?
        /// The name of the Sidewalk destination that that describes the IoT rule to route messages from the device in the import task that will be onboarded to AWS IoT Wireless
        public var destinationName: Swift.String?
        /// The summary information of count of wireless devices in an import task that failed to onboarded to the import task.
        public var failedImportedDeviceCount: Swift.Int?
        /// The ID of the wireless device import task.
        public var id: Swift.String?
        /// The summary information of count of wireless devices that are waiting for the control log to be added to an import task.
        public var initializedImportedDeviceCount: Swift.Int?
        /// The summary information of count of wireless devices in an import task that have been onboarded to the import task.
        public var onboardedImportedDeviceCount: Swift.Int?
        /// The summary information of count of wireless devices in an import task that are waiting in the queue to be onboarded.
        public var pendingImportedDeviceCount: Swift.Int?
        /// The Sidewalk-related information of the wireless device import task.
        public var sidewalk: IoTWirelessClientTypes.SidewalkGetStartImportInfo?
        /// The status information of the wireless device import task.
        public var status: IoTWirelessClientTypes.ImportTaskStatus?
        /// The reason that provides additional information about the import task status.
        public var statusReason: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            destinationName: Swift.String? = nil,
            failedImportedDeviceCount: Swift.Int? = nil,
            id: Swift.String? = nil,
            initializedImportedDeviceCount: Swift.Int? = nil,
            onboardedImportedDeviceCount: Swift.Int? = nil,
            pendingImportedDeviceCount: Swift.Int? = nil,
            sidewalk: IoTWirelessClientTypes.SidewalkGetStartImportInfo? = nil,
            status: IoTWirelessClientTypes.ImportTaskStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.failedImportedDeviceCount = failedImportedDeviceCount
            self.id = id
            self.initializedImportedDeviceCount = initializedImportedDeviceCount
            self.onboardedImportedDeviceCount = onboardedImportedDeviceCount
            self.pendingImportedDeviceCount = pendingImportedDeviceCount
            self.sidewalk = sidewalk
            self.status = status
            self.statusReason = statusReason
        }
    }
}

public struct ListWirelessDeviceImportTasksOutput: Swift.Sendable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// List of import tasks and summary information of onboarding status of devices in each import task.
    public var wirelessDeviceImportTaskList: [IoTWirelessClientTypes.WirelessDeviceImportTask]?

    public init(
        nextToken: Swift.String? = nil,
        wirelessDeviceImportTaskList: [IoTWirelessClientTypes.WirelessDeviceImportTask]? = nil
    )
    {
        self.nextToken = nextToken
        self.wirelessDeviceImportTaskList = wirelessDeviceImportTaskList
    }
}

public struct ListWirelessDevicesInput: Swift.Sendable {
    /// A filter to list only the wireless devices that use this destination.
    public var destinationName: Swift.String?
    /// A filter to list only the wireless devices that use this device profile.
    public var deviceProfileId: Swift.String?
    /// The ID of a FUOTA task.
    public var fuotaTaskId: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// The ID of the multicast group.
    public var multicastGroupId: Swift.String?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// A filter to list only the wireless devices that use this service profile.
    public var serviceProfileId: Swift.String?
    /// A filter to list only the wireless devices that use this wireless device type.
    public var wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType?

    public init(
        destinationName: Swift.String? = nil,
        deviceProfileId: Swift.String? = nil,
        fuotaTaskId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        multicastGroupId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceProfileId: Swift.String? = nil,
        wirelessDeviceType: IoTWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.destinationName = destinationName
        self.deviceProfileId = deviceProfileId
        self.fuotaTaskId = fuotaTaskId
        self.maxResults = maxResults
        self.multicastGroupId = multicastGroupId
        self.nextToken = nextToken
        self.serviceProfileId = serviceProfileId
        self.wirelessDeviceType = wirelessDeviceType
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWAN object for list functions.
    public struct LoRaWANListDevice: Swift.Sendable {
        /// The DevEUI value.
        public var devEui: Swift.String?

        public init(
            devEui: Swift.String? = nil
        )
        {
            self.devEui = devEui
        }
    }
}

extension IoTWirelessClientTypes {

    /// Sidewalk object used by list functions.
    public struct SidewalkListDevice: Swift.Sendable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The sidewalk device certificates for Ed25519 and P256r1.
        public var deviceCertificates: [IoTWirelessClientTypes.CertificateList]?
        /// Sidewalk object used by list functions.
        public var deviceProfileId: Swift.String?
        /// The sidewalk device identification.
        public var sidewalkId: Swift.String?
        /// The Sidewalk manufacturing series number.
        public var sidewalkManufacturingSn: Swift.String?
        /// The status of the Sidewalk devices, such as provisioned or registered.
        public var status: IoTWirelessClientTypes.WirelessDeviceSidewalkStatus?

        public init(
            amazonId: Swift.String? = nil,
            deviceCertificates: [IoTWirelessClientTypes.CertificateList]? = nil,
            deviceProfileId: Swift.String? = nil,
            sidewalkId: Swift.String? = nil,
            sidewalkManufacturingSn: Swift.String? = nil,
            status: IoTWirelessClientTypes.WirelessDeviceSidewalkStatus? = nil
        )
        {
            self.amazonId = amazonId
            self.deviceCertificates = deviceCertificates
            self.deviceProfileId = deviceProfileId
            self.sidewalkId = sidewalkId
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
            self.status = status
        }
    }
}

extension IoTWirelessClientTypes {

    /// Information about a wireless device's operation.
    public struct WirelessDeviceStatistics: Swift.Sendable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The name of the destination to which the device is assigned.
        public var destinationName: Swift.String?
        /// The status of a wireless device in a FUOTA task.
        public var fuotaDeviceStatus: IoTWirelessClientTypes.FuotaDeviceStatus?
        /// The ID of the wireless device reporting the data.
        public var id: Swift.String?
        /// The date and time when the most recent uplink was received. Theis value is only valid for 3 months.
        public var lastUplinkReceivedAt: Swift.String?
        /// LoRaWAN device info.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANListDevice?
        /// Id of the multicast group.
        public var mcGroupId: Swift.Int?
        /// The status of the wireless device in the multicast group.
        public var multicastDeviceStatus: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?
        /// The Sidewalk account credentials.
        public var sidewalk: IoTWirelessClientTypes.SidewalkListDevice?
        /// The wireless device type.
        public var type: IoTWirelessClientTypes.WirelessDeviceType?

        public init(
            arn: Swift.String? = nil,
            destinationName: Swift.String? = nil,
            fuotaDeviceStatus: IoTWirelessClientTypes.FuotaDeviceStatus? = nil,
            id: Swift.String? = nil,
            lastUplinkReceivedAt: Swift.String? = nil,
            loRaWAN: IoTWirelessClientTypes.LoRaWANListDevice? = nil,
            mcGroupId: Swift.Int? = nil,
            multicastDeviceStatus: Swift.String? = nil,
            name: Swift.String? = nil,
            sidewalk: IoTWirelessClientTypes.SidewalkListDevice? = nil,
            type: IoTWirelessClientTypes.WirelessDeviceType? = nil
        )
        {
            self.arn = arn
            self.destinationName = destinationName
            self.fuotaDeviceStatus = fuotaDeviceStatus
            self.id = id
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.loRaWAN = loRaWAN
            self.mcGroupId = mcGroupId
            self.multicastDeviceStatus = multicastDeviceStatus
            self.name = name
            self.sidewalk = sidewalk
            self.type = type
        }
    }
}

public struct ListWirelessDevicesOutput: Swift.Sendable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the wireless device.
    public var wirelessDeviceList: [IoTWirelessClientTypes.WirelessDeviceStatistics]?

    public init(
        nextToken: Swift.String? = nil,
        wirelessDeviceList: [IoTWirelessClientTypes.WirelessDeviceStatistics]? = nil
    )
    {
        self.nextToken = nextToken
        self.wirelessDeviceList = wirelessDeviceList
    }
}

public struct ListWirelessGatewaysInput: Swift.Sendable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTWirelessClientTypes {

    /// Information about a wireless gateway's operation.
    public struct WirelessGatewayStatistics: Swift.Sendable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The description of the resource.
        public var description: Swift.String?
        /// The ID of the wireless gateway reporting the data.
        public var id: Swift.String?
        /// The date and time when the most recent uplink was received. This value is only valid for 3 months.
        public var lastUplinkReceivedAt: Swift.String?
        /// LoRaWAN gateway info.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANGateway?
        /// The name of the resource.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUplinkReceivedAt: Swift.String? = nil,
            loRaWAN: IoTWirelessClientTypes.LoRaWANGateway? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.loRaWAN = loRaWAN
            self.name = name
        }
    }
}

public struct ListWirelessGatewaysOutput: Swift.Sendable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayList: [IoTWirelessClientTypes.WirelessGatewayStatistics]?

    public init(
        nextToken: Swift.String? = nil,
        wirelessGatewayList: [IoTWirelessClientTypes.WirelessGatewayStatistics]? = nil
    )
    {
        self.nextToken = nextToken
        self.wirelessGatewayList = wirelessGatewayList
    }
}

extension IoTWirelessClientTypes {

    public enum WirelessGatewayTaskDefinitionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayTaskDefinitionType] {
            return [
                .update
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListWirelessGatewayTaskDefinitionsInput: Swift.Sendable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// A filter to list only the wireless gateway task definitions that use this task definition type.
    public var taskDefinitionType: IoTWirelessClientTypes.WirelessGatewayTaskDefinitionType?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        taskDefinitionType: IoTWirelessClientTypes.WirelessGatewayTaskDefinitionType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskDefinitionType = taskDefinitionType
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWANUpdateGatewayTaskEntry object.
    public struct LoRaWANUpdateGatewayTaskEntry: Swift.Sendable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?
        /// The firmware version to update the gateway to.
        public var updateVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion?

        public init(
            currentVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil,
            updateVersion: IoTWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
            self.updateVersion = updateVersion
        }
    }
}

extension IoTWirelessClientTypes {

    /// UpdateWirelessGatewayTaskEntry object.
    public struct UpdateWirelessGatewayTaskEntry: Swift.Sendable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the new wireless gateway task entry.
        public var id: Swift.String?
        /// The properties that relate to the LoRaWAN wireless gateway.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.loRaWAN = loRaWAN
        }
    }
}

public struct ListWirelessGatewayTaskDefinitionsOutput: Swift.Sendable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of task definitions.
    public var taskDefinitions: [IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry]?

    public init(
        nextToken: Swift.String? = nil,
        taskDefinitions: [IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskDefinitions = taskDefinitions
    }
}

extension IoTWirelessClientTypes {

    /// Information about the Semtech GNSS solver configuration.
    public struct SemtechGnssConfiguration: Swift.Sendable {
        /// Whether forward error correction is enabled.
        /// This member is required.
        public var fec: IoTWirelessClientTypes.PositionConfigurationFec?
        /// The status indicating whether the solver is enabled.
        /// This member is required.
        public var status: IoTWirelessClientTypes.PositionConfigurationStatus?

        public init(
            fec: IoTWirelessClientTypes.PositionConfigurationFec? = nil,
            status: IoTWirelessClientTypes.PositionConfigurationStatus? = nil
        )
        {
            self.fec = fec
            self.status = status
        }
    }
}

extension IoTWirelessClientTypes {

    /// The wrapper for position solver configurations.
    public struct PositionSolverConfigurations: Swift.Sendable {
        /// The Semtech GNSS solver configuration object.
        public var semtechGnss: IoTWirelessClientTypes.SemtechGnssConfiguration?

        public init(
            semtechGnss: IoTWirelessClientTypes.SemtechGnssConfiguration? = nil
        )
        {
            self.semtechGnss = semtechGnss
        }
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct PutPositionConfigurationInput: Swift.Sendable {
    /// The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.
    public var destination: Swift.String?
    /// Resource identifier used to update the position configuration.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// Resource type of the resource for which you want to update the position configuration.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?
    /// The positioning solvers used to update the position configuration of the resource.
    public var solvers: IoTWirelessClientTypes.PositionSolverConfigurations?

    public init(
        destination: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil,
        solvers: IoTWirelessClientTypes.PositionSolverConfigurations? = nil
    )
    {
        self.destination = destination
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
        self.solvers = solvers
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct PutPositionConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct PutResourceLogLevelInput: Swift.Sendable {
    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    /// This member is required.
    public var logLevel: IoTWirelessClientTypes.LogLevel?
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway, it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        logLevel: IoTWirelessClientTypes.LogLevel? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.logLevel = logLevel
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

public struct PutResourceLogLevelOutput: Swift.Sendable {

    public init() { }
}

public struct ResetAllResourceLogLevelsInput: Swift.Sendable {

    public init() { }
}

public struct ResetAllResourceLogLevelsOutput: Swift.Sendable {

    public init() { }
}

public struct ResetResourceLogLevelInput: Swift.Sendable {
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway, it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

public struct ResetResourceLogLevelOutput: Swift.Sendable {

    public init() { }
}

extension IoTWirelessClientTypes {

    /// The metadata information of the LoRaWAN multicast group.
    public struct LoRaWANMulticastMetadata: Swift.Sendable {
        /// The Fport value.
        public var fPort: Swift.Int?

        public init(
            fPort: Swift.Int? = nil
        )
        {
            self.fPort = fPort
        }
    }
}

extension IoTWirelessClientTypes {

    /// Wireless metadata that is to be sent to multicast group.
    public struct MulticastWirelessMetadata: Swift.Sendable {
        /// The metadata information of the LoRaWAN multicast group.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastMetadata?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastMetadata? = nil
        )
        {
            self.loRaWAN = loRaWAN
        }
    }
}

public struct SendDataToMulticastGroupInput: Swift.Sendable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The binary to be sent to the end device, encoded in base64.
    /// This member is required.
    public var payloadData: Swift.String?
    /// Wireless metadata that is to be sent to multicast group.
    /// This member is required.
    public var wirelessMetadata: IoTWirelessClientTypes.MulticastWirelessMetadata?

    public init(
        id: Swift.String? = nil,
        payloadData: Swift.String? = nil,
        wirelessMetadata: IoTWirelessClientTypes.MulticastWirelessMetadata? = nil
    )
    {
        self.id = id
        self.payloadData = payloadData
        self.wirelessMetadata = wirelessMetadata
    }
}

public struct SendDataToMulticastGroupOutput: Swift.Sendable {
    /// ID of a multicast group message.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

extension IoTWirelessClientTypes {

    /// Sidewalk device message type. Default value is CUSTOM_COMMAND_ID_NOTIFY.
    public enum MessageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customCommandIdGet
        case customCommandIdNotify
        case customCommandIdResp
        case customCommandIdSet
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .customCommandIdGet,
                .customCommandIdNotify,
                .customCommandIdResp,
                .customCommandIdSet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customCommandIdGet: return "CUSTOM_COMMAND_ID_GET"
            case .customCommandIdNotify: return "CUSTOM_COMMAND_ID_NOTIFY"
            case .customCommandIdResp: return "CUSTOM_COMMAND_ID_RESP"
            case .customCommandIdSet: return "CUSTOM_COMMAND_ID_SET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTWirelessClientTypes {

    /// Information about a Sidewalk router.
    public struct SidewalkSendDataToDevice: Swift.Sendable {
        /// The duration of time in seconds to retry sending the ACK.
        public var ackModeRetryDurationSecs: Swift.Int?
        /// Sidewalk device message type. Default value is CUSTOM_COMMAND_ID_NOTIFY.
        public var messageType: IoTWirelessClientTypes.MessageType?
        /// The sequence number.
        public var seq: Swift.Int?

        public init(
            ackModeRetryDurationSecs: Swift.Int? = nil,
            messageType: IoTWirelessClientTypes.MessageType? = nil,
            seq: Swift.Int? = nil
        )
        {
            self.ackModeRetryDurationSecs = ackModeRetryDurationSecs
            self.messageType = messageType
            self.seq = seq
        }
    }
}

extension IoTWirelessClientTypes {

    /// WirelessMetadata object.
    public struct WirelessMetadata: Swift.Sendable {
        /// LoRaWAN device info.
        public var loRaWAN: IoTWirelessClientTypes.LoRaWANSendDataToDevice?
        /// The Sidewalk account credentials.
        public var sidewalk: IoTWirelessClientTypes.SidewalkSendDataToDevice?

        public init(
            loRaWAN: IoTWirelessClientTypes.LoRaWANSendDataToDevice? = nil,
            sidewalk: IoTWirelessClientTypes.SidewalkSendDataToDevice? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.sidewalk = sidewalk
        }
    }
}

public struct SendDataToWirelessDeviceInput: Swift.Sendable {
    /// The ID of the wireless device to receive the data.
    /// This member is required.
    public var id: Swift.String?
    /// The binary to be sent to the end device, encoded in base64.
    /// This member is required.
    public var payloadData: Swift.String?
    /// The transmit mode to use to send data to the wireless device. Can be: 0 for UM (unacknowledge mode) or 1 for AM (acknowledge mode).
    /// This member is required.
    public var transmitMode: Swift.Int?
    /// Metadata about the message request.
    public var wirelessMetadata: IoTWirelessClientTypes.WirelessMetadata?

    public init(
        id: Swift.String? = nil,
        payloadData: Swift.String? = nil,
        transmitMode: Swift.Int? = nil,
        wirelessMetadata: IoTWirelessClientTypes.WirelessMetadata? = nil
    )
    {
        self.id = id
        self.payloadData = payloadData
        self.transmitMode = transmitMode
        self.wirelessMetadata = wirelessMetadata
    }
}

public struct SendDataToWirelessDeviceOutput: Swift.Sendable {
    /// The ID of the message sent to the wireless device.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

public struct StartBulkAssociateWirelessDeviceWithMulticastGroupInput: Swift.Sendable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// Query string used to search for wireless devices as part of the bulk associate and disassociate process.
    public var queryString: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        id: Swift.String? = nil,
        queryString: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.id = id
        self.queryString = queryString
        self.tags = tags
    }
}

public struct StartBulkAssociateWirelessDeviceWithMulticastGroupOutput: Swift.Sendable {

    public init() { }
}

public struct StartBulkDisassociateWirelessDeviceFromMulticastGroupInput: Swift.Sendable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// Query string used to search for wireless devices as part of the bulk associate and disassociate process.
    public var queryString: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        id: Swift.String? = nil,
        queryString: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.id = id
        self.queryString = queryString
        self.tags = tags
    }
}

public struct StartBulkDisassociateWirelessDeviceFromMulticastGroupOutput: Swift.Sendable {

    public init() { }
}

extension IoTWirelessClientTypes {

    /// The LoRaWAN information used to start a FUOTA task.
    public struct LoRaWANStartFuotaTask: Swift.Sendable {
        /// Start time of a FUOTA task.
        public var startTime: Foundation.Date?

        public init(
            startTime: Foundation.Date? = nil
        )
        {
            self.startTime = startTime
        }
    }
}

public struct StartFuotaTaskInput: Swift.Sendable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information used to start a FUOTA task.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANStartFuotaTask?

    public init(
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANStartFuotaTask? = nil
    )
    {
        self.id = id
        self.loRaWAN = loRaWAN
    }
}

public struct StartFuotaTaskOutput: Swift.Sendable {

    public init() { }
}

public struct StartMulticastGroupSessionInput: Swift.Sendable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information used with the multicast session.
    /// This member is required.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession?

    public init(
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticastSession? = nil
    )
    {
        self.id = id
        self.loRaWAN = loRaWAN
    }
}

public struct StartMulticastGroupSessionOutput: Swift.Sendable {

    public init() { }
}

extension IoTWirelessClientTypes {

    /// Information about an import task created for an individual Sidewalk device.
    public struct SidewalkSingleStartImportInfo: Swift.Sendable {
        /// The Sidewalk manufacturing serial number (SMSN) of the device added to the import task.
        public var sidewalkManufacturingSn: Swift.String?

        public init(
            sidewalkManufacturingSn: Swift.String? = nil
        )
        {
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
        }
    }
}

public struct StartSingleWirelessDeviceImportTaskInput: Swift.Sendable {
    /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see [Ensuring idempotency in Amazon EC2 API requests](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The name of the Sidewalk destination that describes the IoT rule to route messages from the device in the import task that will be onboarded to AWS IoT Wireless.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The name of the wireless device for which an import task is being started.
    public var deviceName: Swift.String?
    /// The Sidewalk-related parameters for importing a single wireless device.
    /// This member is required.
    public var sidewalk: IoTWirelessClientTypes.SidewalkSingleStartImportInfo?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkSingleStartImportInfo? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.destinationName = destinationName
        self.deviceName = deviceName
        self.sidewalk = sidewalk
        self.tags = tags
    }
}

public struct StartSingleWirelessDeviceImportTaskOutput: Swift.Sendable {
    /// The ARN (Amazon Resource Name) of the import task.
    public var arn: Swift.String?
    /// The import task ID.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

extension IoTWirelessClientTypes {

    /// Information about an import task created for bulk provisioning.
    public struct SidewalkStartImportInfo: Swift.Sendable {
        /// The CSV file contained in an S3 bucket that's used for adding devices to an import task.
        public var deviceCreationFile: Swift.String?
        /// The IAM role that allows AWS IoT Wireless to access the CSV file in the S3 bucket.
        public var role: Swift.String?

        public init(
            deviceCreationFile: Swift.String? = nil,
            role: Swift.String? = nil
        )
        {
            self.deviceCreationFile = deviceCreationFile
            self.role = role
        }
    }
}

public struct StartWirelessDeviceImportTaskInput: Swift.Sendable {
    /// Each resource must have a unique client request token. The client token is used to implement idempotency. It ensures that the request completes no more than one time. If you retry a request with the same token and the same parameters, the request will complete successfully. However, if you try to create a new resource using the same token but different parameters, an HTTP 409 conflict occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. For more information about idempotency, see [Ensuring idempotency in Amazon EC2 API requests](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The name of the Sidewalk destination that describes the IoT rule to route messages from the devices in the import task that are onboarded to AWS IoT Wireless.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The Sidewalk-related parameters for importing wireless devices that need to be provisioned in bulk.
    /// This member is required.
    public var sidewalk: IoTWirelessClientTypes.SidewalkStartImportInfo?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkStartImportInfo? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.destinationName = destinationName
        self.sidewalk = sidewalk
        self.tags = tags
    }
}

public struct StartWirelessDeviceImportTaskOutput: Swift.Sendable {
    /// The ARN (Amazon Resource Name) of the import task.
    public var arn: Swift.String?
    /// The import task ID.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

/// The request was denied because the resource can't have any more tags.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Name of the resource that exceeds maximum number of tags allowed.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource to add tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Adds to or modifies the tags of the given resource. Tags are metadata that you can use to manage a resource.
    /// This member is required.
    public var tags: [IoTWirelessClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [IoTWirelessClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct TestWirelessDeviceInput: Swift.Sendable {
    /// The ID of the wireless device to test.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct TestWirelessDeviceOutput: Swift.Sendable {
    /// The result returned by the test.
    public var result: Swift.String?

    public init(
        result: Swift.String? = nil
    )
    {
        self.result = result
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDestinationInput: Swift.Sendable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The new rule name or topic rule to send messages to.
    public var expression: Swift.String?
    /// The type of value in Expression.
    public var expressionType: IoTWirelessClientTypes.ExpressionType?
    /// The new name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    public var roleArn: Swift.String?

    public init(
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IoTWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
    }
}

public struct UpdateDestinationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateEventConfigurationByResourceTypesInput: Swift.Sendable {
    /// Connection status resource type event configuration object for enabling and disabling wireless gateway topic.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration?
    /// Device registration state resource type event configuration object for enabling and disabling wireless gateway topic.
    public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration?
    /// Join resource type event configuration object for enabling and disabling wireless device topic.
    public var join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration?
    /// Message delivery status resource type event configuration object for enabling and disabling wireless device topic.
    public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration?
    /// Proximity resource type event configuration object for enabling and disabling wireless gateway topic.
    public var proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration?

    public init(
        connectionStatus: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration? = nil,
        deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration? = nil,
        join: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration? = nil,
        messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration? = nil,
        proximity: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.deviceRegistrationState = deviceRegistrationState
        self.join = join
        self.messageDeliveryStatus = messageDeliveryStatus
        self.proximity = proximity
    }
}

public struct UpdateEventConfigurationByResourceTypesOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateFuotaTaskInput: Swift.Sendable {
    /// The description of the new resource.
    public var description: Swift.String?
    /// The S3 URI points to a firmware update image that is to be used with a FUOTA task.
    public var firmwareUpdateImage: Swift.String?
    /// The firmware update role that is to be used with a FUOTA task.
    public var firmwareUpdateRole: Swift.String?
    /// The interval for sending fragments in milliseconds, rounded to the nearest second. This interval only determines the timing for when the Cloud sends down the fragments to yor device. There can be a delay for when your device will receive these fragments. This delay depends on the device's class and the communication delay with the cloud.
    public var fragmentIntervalMS: Swift.Int?
    /// The size of each fragment in bytes. This parameter is supported only for FUOTA tasks with multicast groups.
    public var fragmentSizeBytes: Swift.Int?
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information used with a FUOTA task.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask?
    /// The name of a FUOTA task.
    public var name: Swift.String?
    /// The percentage of the added fragments that are redundant. For example, if the size of the firmware image file is 100 bytes and the fragment size is 10 bytes, with RedundancyPercent set to 50(%), the final number of encoded fragments is (100 / 10) + (100 / 10 * 50%) = 15.
    public var redundancyPercent: Swift.Int?

    public init(
        description: Swift.String? = nil,
        firmwareUpdateImage: Swift.String? = nil,
        firmwareUpdateRole: Swift.String? = nil,
        fragmentIntervalMS: Swift.Int? = nil,
        fragmentSizeBytes: Swift.Int? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANFuotaTask? = nil,
        name: Swift.String? = nil,
        redundancyPercent: Swift.Int? = nil
    )
    {
        self.description = description
        self.firmwareUpdateImage = firmwareUpdateImage
        self.firmwareUpdateRole = firmwareUpdateRole
        self.fragmentIntervalMS = fragmentIntervalMS
        self.fragmentSizeBytes = fragmentSizeBytes
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.redundancyPercent = redundancyPercent
    }
}

public struct UpdateFuotaTaskOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateLogLevelsByResourceTypesInput: Swift.Sendable {
    /// The log level for a log message. The log levels can be disabled, or set to ERROR to display less verbose logs containing only error information, or to INFO for more detailed logs.
    public var defaultLogLevel: IoTWirelessClientTypes.LogLevel?
    /// The list of wireless device log options.
    public var wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]?
    /// The list of wireless gateway log options.
    public var wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]?

    public init(
        defaultLogLevel: IoTWirelessClientTypes.LogLevel? = nil,
        wirelessDeviceLogOptions: [IoTWirelessClientTypes.WirelessDeviceLogOption]? = nil,
        wirelessGatewayLogOptions: [IoTWirelessClientTypes.WirelessGatewayLogOption]? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.wirelessDeviceLogOptions = wirelessDeviceLogOptions
        self.wirelessGatewayLogOptions = wirelessGatewayLogOptions
    }
}

public struct UpdateLogLevelsByResourceTypesOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateMetricConfigurationInput: Swift.Sendable {
    /// The value to be used to set summary metric configuration.
    public var summaryMetric: IoTWirelessClientTypes.SummaryMetricConfiguration?

    public init(
        summaryMetric: IoTWirelessClientTypes.SummaryMetricConfiguration? = nil
    )
    {
        self.summaryMetric = summaryMetric
    }
}

public struct UpdateMetricConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateMulticastGroupInput: Swift.Sendable {
    /// The description of the new resource.
    public var description: Swift.String?
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information that is to be used with the multicast group.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast?
    /// The name of the multicast group.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANMulticast? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

public struct UpdateMulticastGroupOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateNetworkAnalyzerConfigurationInput: Swift.Sendable {
    /// Name of the network analyzer configuration.
    /// This member is required.
    public var configurationName: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// Multicast group resources to add to the network analyzer configuration. Provide the MulticastGroupId of the resource to add in the input array.
    public var multicastGroupsToAdd: [Swift.String]?
    /// Multicast group resources to remove from the network analyzer configuration. Provide the MulticastGroupId of the resources to remove in the input array.
    public var multicastGroupsToRemove: [Swift.String]?
    /// Trace content for your wireless devices, gateways, and multicast groups.
    public var traceContent: IoTWirelessClientTypes.TraceContent?
    /// Wireless device resources to add to the network analyzer configuration. Provide the WirelessDeviceId of the resource to add in the input array.
    public var wirelessDevicesToAdd: [Swift.String]?
    /// Wireless device resources to remove from the network analyzer configuration. Provide the WirelessDeviceId of the resources to remove in the input array.
    public var wirelessDevicesToRemove: [Swift.String]?
    /// Wireless gateway resources to add to the network analyzer configuration. Provide the WirelessGatewayId of the resource to add in the input array.
    public var wirelessGatewaysToAdd: [Swift.String]?
    /// Wireless gateway resources to remove from the network analyzer configuration. Provide the WirelessGatewayId of the resources to remove in the input array.
    public var wirelessGatewaysToRemove: [Swift.String]?

    public init(
        configurationName: Swift.String? = nil,
        description: Swift.String? = nil,
        multicastGroupsToAdd: [Swift.String]? = nil,
        multicastGroupsToRemove: [Swift.String]? = nil,
        traceContent: IoTWirelessClientTypes.TraceContent? = nil,
        wirelessDevicesToAdd: [Swift.String]? = nil,
        wirelessDevicesToRemove: [Swift.String]? = nil,
        wirelessGatewaysToAdd: [Swift.String]? = nil,
        wirelessGatewaysToRemove: [Swift.String]? = nil
    )
    {
        self.configurationName = configurationName
        self.description = description
        self.multicastGroupsToAdd = multicastGroupsToAdd
        self.multicastGroupsToRemove = multicastGroupsToRemove
        self.traceContent = traceContent
        self.wirelessDevicesToAdd = wirelessDevicesToAdd
        self.wirelessDevicesToRemove = wirelessDevicesToRemove
        self.wirelessGatewaysToAdd = wirelessGatewaysToAdd
        self.wirelessGatewaysToRemove = wirelessGatewaysToRemove
    }
}

public struct UpdateNetworkAnalyzerConfigurationOutput: Swift.Sendable {

    public init() { }
}

extension IoTWirelessClientTypes {

    /// Sidewalk update.
    public struct SidewalkUpdateAccount: Swift.Sendable {
        /// The new Sidewalk application server private key.
        public var appServerPrivateKey: Swift.String?

        public init(
            appServerPrivateKey: Swift.String? = nil
        )
        {
            self.appServerPrivateKey = appServerPrivateKey
        }
    }
}

extension IoTWirelessClientTypes.SidewalkUpdateAccount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkUpdateAccount(appServerPrivateKey: \"CONTENT_REDACTED\")"}
}

public struct UpdatePartnerAccountInput: Swift.Sendable {
    /// The ID of the partner account to update.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IoTWirelessClientTypes.PartnerType?
    /// The Sidewalk account credentials.
    /// This member is required.
    public var sidewalk: IoTWirelessClientTypes.SidewalkUpdateAccount?

    public init(
        partnerAccountId: Swift.String? = nil,
        partnerType: IoTWirelessClientTypes.PartnerType? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkUpdateAccount? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
        self.sidewalk = sidewalk
    }
}

public struct UpdatePartnerAccountOutput: Swift.Sendable {

    public init() { }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct UpdatePositionInput: Swift.Sendable {
    /// The position information of the resource.
    /// This member is required.
    public var position: [Swift.Float]?
    /// Resource identifier of the resource for which position is updated.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// Resource type of the resource for which position is updated.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init(
        position: [Swift.Float]? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.position = position
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

@available(*, deprecated, message: "This operation is no longer supported.")
public struct UpdatePositionOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateResourceEventConfigurationInput: Swift.Sendable {
    /// Event configuration for the connection status event.
    public var connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration?
    /// Event configuration for the device registration state event.
    public var deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
    /// Resource identifier to opt in for event messaging.
    /// This member is required.
    public var identifier: Swift.String?
    /// Identifier type of the particular resource identifier for event configuration.
    /// This member is required.
    public var identifierType: IoTWirelessClientTypes.IdentifierType?
    /// Event configuration for the join event.
    public var join: IoTWirelessClientTypes.JoinEventConfiguration?
    /// Event configuration for the message delivery status event.
    public var messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration?
    /// Partner type of the resource if the identifier type is PartnerAccountId
    public var partnerType: IoTWirelessClientTypes.EventNotificationPartnerType?
    /// Event configuration for the proximity event.
    public var proximity: IoTWirelessClientTypes.ProximityEventConfiguration?

    public init(
        connectionStatus: IoTWirelessClientTypes.ConnectionStatusEventConfiguration? = nil,
        deviceRegistrationState: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration? = nil,
        identifier: Swift.String? = nil,
        identifierType: IoTWirelessClientTypes.IdentifierType? = nil,
        join: IoTWirelessClientTypes.JoinEventConfiguration? = nil,
        messageDeliveryStatus: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration? = nil,
        partnerType: IoTWirelessClientTypes.EventNotificationPartnerType? = nil,
        proximity: IoTWirelessClientTypes.ProximityEventConfiguration? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.deviceRegistrationState = deviceRegistrationState
        self.identifier = identifier
        self.identifierType = identifierType
        self.join = join
        self.messageDeliveryStatus = messageDeliveryStatus
        self.partnerType = partnerType
        self.proximity = proximity
    }
}

public struct UpdateResourceEventConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateResourcePositionInput: Swift.Sendable {
    /// The position information of the resource, displayed as a JSON payload. The payload uses the GeoJSON format, which a format that's used to encode geographic data structures. For more information, see [GeoJSON](https://geojson.org/).
    public var geoJsonPayload: Foundation.Data?
    /// The identifier of the resource for which position information is updated. It can be the wireless device ID or the wireless gateway ID, depending on the resource type.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of resource for which position information is updated, which can be a wireless device or a wireless gateway.
    /// This member is required.
    public var resourceType: IoTWirelessClientTypes.PositionResourceType?

    public init(
        geoJsonPayload: Foundation.Data? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: IoTWirelessClientTypes.PositionResourceType? = nil
    )
    {
        self.geoJsonPayload = geoJsonPayload
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

public struct UpdateResourcePositionOutput: Swift.Sendable {

    public init() { }
}

extension IoTWirelessClientTypes {

    /// ABP device object for LoRaWAN specification v1.0.x
    public struct UpdateAbpV1_0_x: Swift.Sendable {
        /// The FCnt init value.
        public var fCntStart: Swift.Int?

        public init(
            fCntStart: Swift.Int? = nil
        )
        {
            self.fCntStart = fCntStart
        }
    }
}

extension IoTWirelessClientTypes {

    /// ABP device object for LoRaWAN specification v1.1
    public struct UpdateAbpV1_1: Swift.Sendable {
        /// The FCnt init value.
        public var fCntStart: Swift.Int?

        public init(
            fCntStart: Swift.Int? = nil
        )
        {
            self.fCntStart = fCntStart
        }
    }
}

extension IoTWirelessClientTypes {

    /// Object for updating the FPorts information.
    public struct UpdateFPorts: Swift.Sendable {
        /// LoRaWAN application, which can be used for geolocation by activating positioning.
        public var applications: [IoTWirelessClientTypes.ApplicationConfig]?
        /// Positioning FPorts for the ClockSync, Stream, and GNSS functions.
        public var positioning: IoTWirelessClientTypes.Positioning?

        public init(
            applications: [IoTWirelessClientTypes.ApplicationConfig]? = nil,
            positioning: IoTWirelessClientTypes.Positioning? = nil
        )
        {
            self.applications = applications
            self.positioning = positioning
        }
    }
}

extension IoTWirelessClientTypes {

    /// LoRaWAN object for update functions.
    public struct LoRaWANUpdateDevice: Swift.Sendable {
        /// ABP device object for update APIs for v1.0.x
        public var abpV1_0_x: IoTWirelessClientTypes.UpdateAbpV1_0_x?
        /// ABP device object for update APIs for v1.1
        public var abpV1_1: IoTWirelessClientTypes.UpdateAbpV1_1?
        /// The ID of the device profile for the wireless device.
        public var deviceProfileId: Swift.String?
        /// FPorts object for the positioning information of the device.
        public var fPorts: IoTWirelessClientTypes.UpdateFPorts?
        /// The ID of the service profile.
        public var serviceProfileId: Swift.String?

        public init(
            abpV1_0_x: IoTWirelessClientTypes.UpdateAbpV1_0_x? = nil,
            abpV1_1: IoTWirelessClientTypes.UpdateAbpV1_1? = nil,
            deviceProfileId: Swift.String? = nil,
            fPorts: IoTWirelessClientTypes.UpdateFPorts? = nil,
            serviceProfileId: Swift.String? = nil
        )
        {
            self.abpV1_0_x = abpV1_0_x
            self.abpV1_1 = abpV1_1
            self.deviceProfileId = deviceProfileId
            self.fPorts = fPorts
            self.serviceProfileId = serviceProfileId
        }
    }
}

public struct UpdateWirelessDeviceInput: Swift.Sendable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The name of the new destination for the device.
    public var destinationName: Swift.String?
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The updated wireless device's configuration.
    public var loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateDevice?
    /// The new name of the resource.
    public var name: Swift.String?
    /// FPort values for the GNSS, stream, and ClockSync functions of the positioning information.
    public var positioning: IoTWirelessClientTypes.PositioningConfigStatus?

    public init(
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IoTWirelessClientTypes.LoRaWANUpdateDevice? = nil,
        name: Swift.String? = nil,
        positioning: IoTWirelessClientTypes.PositioningConfigStatus? = nil
    )
    {
        self.description = description
        self.destinationName = destinationName
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.positioning = positioning
    }
}

public struct UpdateWirelessDeviceOutput: Swift.Sendable {

    public init() { }
}

extension IoTWirelessClientTypes {

    /// Sidewalk object information for updating an import task.
    public struct SidewalkUpdateImportInfo: Swift.Sendable {
        /// The CSV file contained in an S3 bucket that's used for appending devices to an existing import task.
        public var deviceCreationFile: Swift.String?

        public init(
            deviceCreationFile: Swift.String? = nil
        )
        {
            self.deviceCreationFile = deviceCreationFile
        }
    }
}

public struct UpdateWirelessDeviceImportTaskInput: Swift.Sendable {
    /// The identifier of the import task to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The Sidewalk-related parameters of the import task to be updated.
    /// This member is required.
    public var sidewalk: IoTWirelessClientTypes.SidewalkUpdateImportInfo?

    public init(
        id: Swift.String? = nil,
        sidewalk: IoTWirelessClientTypes.SidewalkUpdateImportInfo? = nil
    )
    {
        self.id = id
        self.sidewalk = sidewalk
    }
}

public struct UpdateWirelessDeviceImportTaskOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateWirelessGatewayInput: Swift.Sendable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.
    public var joinEuiFilters: [[Swift.String]]?
    /// The MaxEIRP value.
    public var maxEirp: Swift.Float?
    /// The new name of the resource.
    public var name: Swift.String?
    /// A list of NetId values that are used by LoRa gateways to filter the uplink frames.
    public var netIdFilters: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        joinEuiFilters: [[Swift.String]]? = nil,
        maxEirp: Swift.Float? = nil,
        name: Swift.String? = nil,
        netIdFilters: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.joinEuiFilters = joinEuiFilters
        self.maxEirp = maxEirp
        self.name = name
        self.netIdFilters = netIdFilters
    }
}

public struct UpdateWirelessGatewayOutput: Swift.Sendable {

    public init() { }
}

extension AssociateAwsAccountWithPartnerAccountInput {

    static func urlPathProvider(_ value: AssociateAwsAccountWithPartnerAccountInput) -> Swift.String? {
        return "/partner-accounts"
    }
}

extension AssociateMulticastGroupWithFuotaTaskInput {

    static func urlPathProvider(_ value: AssociateMulticastGroupWithFuotaTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/multicast-group"
    }
}

extension AssociateWirelessDeviceWithFuotaTaskInput {

    static func urlPathProvider(_ value: AssociateWirelessDeviceWithFuotaTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/wireless-device"
    }
}

extension AssociateWirelessDeviceWithMulticastGroupInput {

    static func urlPathProvider(_ value: AssociateWirelessDeviceWithMulticastGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/wireless-device"
    }
}

extension AssociateWirelessDeviceWithThingInput {

    static func urlPathProvider(_ value: AssociateWirelessDeviceWithThingInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/thing"
    }
}

extension AssociateWirelessGatewayWithCertificateInput {

    static func urlPathProvider(_ value: AssociateWirelessGatewayWithCertificateInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
    }
}

extension AssociateWirelessGatewayWithThingInput {

    static func urlPathProvider(_ value: AssociateWirelessGatewayWithThingInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/thing"
    }
}

extension CancelMulticastGroupSessionInput {

    static func urlPathProvider(_ value: CancelMulticastGroupSessionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/session"
    }
}

extension CreateDestinationInput {

    static func urlPathProvider(_ value: CreateDestinationInput) -> Swift.String? {
        return "/destinations"
    }
}

extension CreateDeviceProfileInput {

    static func urlPathProvider(_ value: CreateDeviceProfileInput) -> Swift.String? {
        return "/device-profiles"
    }
}

extension CreateFuotaTaskInput {

    static func urlPathProvider(_ value: CreateFuotaTaskInput) -> Swift.String? {
        return "/fuota-tasks"
    }
}

extension CreateMulticastGroupInput {

    static func urlPathProvider(_ value: CreateMulticastGroupInput) -> Swift.String? {
        return "/multicast-groups"
    }
}

extension CreateNetworkAnalyzerConfigurationInput {

    static func urlPathProvider(_ value: CreateNetworkAnalyzerConfigurationInput) -> Swift.String? {
        return "/network-analyzer-configurations"
    }
}

extension CreateServiceProfileInput {

    static func urlPathProvider(_ value: CreateServiceProfileInput) -> Swift.String? {
        return "/service-profiles"
    }
}

extension CreateWirelessDeviceInput {

    static func urlPathProvider(_ value: CreateWirelessDeviceInput) -> Swift.String? {
        return "/wireless-devices"
    }
}

extension CreateWirelessGatewayInput {

    static func urlPathProvider(_ value: CreateWirelessGatewayInput) -> Swift.String? {
        return "/wireless-gateways"
    }
}

extension CreateWirelessGatewayTaskInput {

    static func urlPathProvider(_ value: CreateWirelessGatewayTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
    }
}

extension CreateWirelessGatewayTaskDefinitionInput {

    static func urlPathProvider(_ value: CreateWirelessGatewayTaskDefinitionInput) -> Swift.String? {
        return "/wireless-gateway-task-definitions"
    }
}

extension DeleteDestinationInput {

    static func urlPathProvider(_ value: DeleteDestinationInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

extension DeleteDeviceProfileInput {

    static func urlPathProvider(_ value: DeleteDeviceProfileInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/device-profiles/\(id.urlPercentEncoding())"
    }
}

extension DeleteFuotaTaskInput {

    static func urlPathProvider(_ value: DeleteFuotaTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

extension DeleteMulticastGroupInput {

    static func urlPathProvider(_ value: DeleteMulticastGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())"
    }
}

extension DeleteNetworkAnalyzerConfigurationInput {

    static func urlPathProvider(_ value: DeleteNetworkAnalyzerConfigurationInput) -> Swift.String? {
        guard let configurationName = value.configurationName else {
            return nil
        }
        return "/network-analyzer-configurations/\(configurationName.urlPercentEncoding())"
    }
}

extension DeleteQueuedMessagesInput {

    static func urlPathProvider(_ value: DeleteQueuedMessagesInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/data"
    }
}

extension DeleteQueuedMessagesInput {

    static func queryItemProvider(_ value: DeleteQueuedMessagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let wirelessDeviceType = value.wirelessDeviceType {
            let wirelessDeviceTypeQueryItem = Smithy.URIQueryItem(name: "WirelessDeviceType".urlPercentEncoding(), value: Swift.String(wirelessDeviceType.rawValue).urlPercentEncoding())
            items.append(wirelessDeviceTypeQueryItem)
        }
        guard let messageId = value.messageId else {
            let message = "Creating a URL Query Item failed. messageId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let messageIdQueryItem = Smithy.URIQueryItem(name: "messageId".urlPercentEncoding(), value: Swift.String(messageId).urlPercentEncoding())
        items.append(messageIdQueryItem)
        return items
    }
}

extension DeleteServiceProfileInput {

    static func urlPathProvider(_ value: DeleteServiceProfileInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/service-profiles/\(id.urlPercentEncoding())"
    }
}

extension DeleteWirelessDeviceInput {

    static func urlPathProvider(_ value: DeleteWirelessDeviceInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())"
    }
}

extension DeleteWirelessDeviceImportTaskInput {

    static func urlPathProvider(_ value: DeleteWirelessDeviceImportTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless_device_import_task/\(id.urlPercentEncoding())"
    }
}

extension DeleteWirelessGatewayInput {

    static func urlPathProvider(_ value: DeleteWirelessGatewayInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())"
    }
}

extension DeleteWirelessGatewayTaskInput {

    static func urlPathProvider(_ value: DeleteWirelessGatewayTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
    }
}

extension DeleteWirelessGatewayTaskDefinitionInput {

    static func urlPathProvider(_ value: DeleteWirelessGatewayTaskDefinitionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-gateway-task-definitions/\(id.urlPercentEncoding())"
    }
}

extension DeregisterWirelessDeviceInput {

    static func urlPathProvider(_ value: DeregisterWirelessDeviceInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/wireless-devices/\(identifier.urlPercentEncoding())/deregister"
    }
}

extension DeregisterWirelessDeviceInput {

    static func queryItemProvider(_ value: DeregisterWirelessDeviceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let wirelessDeviceType = value.wirelessDeviceType {
            let wirelessDeviceTypeQueryItem = Smithy.URIQueryItem(name: "WirelessDeviceType".urlPercentEncoding(), value: Swift.String(wirelessDeviceType.rawValue).urlPercentEncoding())
            items.append(wirelessDeviceTypeQueryItem)
        }
        return items
    }
}

extension DisassociateAwsAccountFromPartnerAccountInput {

    static func urlPathProvider(_ value: DisassociateAwsAccountFromPartnerAccountInput) -> Swift.String? {
        guard let partnerAccountId = value.partnerAccountId else {
            return nil
        }
        return "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
    }
}

extension DisassociateAwsAccountFromPartnerAccountInput {

    static func queryItemProvider(_ value: DisassociateAwsAccountFromPartnerAccountInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let partnerType = value.partnerType else {
            let message = "Creating a URL Query Item failed. partnerType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let partnerTypeQueryItem = Smithy.URIQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
        items.append(partnerTypeQueryItem)
        return items
    }
}

extension DisassociateMulticastGroupFromFuotaTaskInput {

    static func urlPathProvider(_ value: DisassociateMulticastGroupFromFuotaTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        guard let multicastGroupId = value.multicastGroupId else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/multicast-groups/\(multicastGroupId.urlPercentEncoding())"
    }
}

extension DisassociateWirelessDeviceFromFuotaTaskInput {

    static func urlPathProvider(_ value: DisassociateWirelessDeviceFromFuotaTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        guard let wirelessDeviceId = value.wirelessDeviceId else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/wireless-devices/\(wirelessDeviceId.urlPercentEncoding())"
    }
}

extension DisassociateWirelessDeviceFromMulticastGroupInput {

    static func urlPathProvider(_ value: DisassociateWirelessDeviceFromMulticastGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        guard let wirelessDeviceId = value.wirelessDeviceId else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/wireless-devices/\(wirelessDeviceId.urlPercentEncoding())"
    }
}

extension DisassociateWirelessDeviceFromThingInput {

    static func urlPathProvider(_ value: DisassociateWirelessDeviceFromThingInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/thing"
    }
}

extension DisassociateWirelessGatewayFromCertificateInput {

    static func urlPathProvider(_ value: DisassociateWirelessGatewayFromCertificateInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
    }
}

extension DisassociateWirelessGatewayFromThingInput {

    static func urlPathProvider(_ value: DisassociateWirelessGatewayFromThingInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/thing"
    }
}

extension GetDestinationInput {

    static func urlPathProvider(_ value: GetDestinationInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

extension GetDeviceProfileInput {

    static func urlPathProvider(_ value: GetDeviceProfileInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/device-profiles/\(id.urlPercentEncoding())"
    }
}

extension GetEventConfigurationByResourceTypesInput {

    static func urlPathProvider(_ value: GetEventConfigurationByResourceTypesInput) -> Swift.String? {
        return "/event-configurations-resource-types"
    }
}

extension GetFuotaTaskInput {

    static func urlPathProvider(_ value: GetFuotaTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

extension GetLogLevelsByResourceTypesInput {

    static func urlPathProvider(_ value: GetLogLevelsByResourceTypesInput) -> Swift.String? {
        return "/log-levels"
    }
}

extension GetMetricConfigurationInput {

    static func urlPathProvider(_ value: GetMetricConfigurationInput) -> Swift.String? {
        return "/metric-configuration"
    }
}

extension GetMetricsInput {

    static func urlPathProvider(_ value: GetMetricsInput) -> Swift.String? {
        return "/metrics"
    }
}

extension GetMulticastGroupInput {

    static func urlPathProvider(_ value: GetMulticastGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())"
    }
}

extension GetMulticastGroupSessionInput {

    static func urlPathProvider(_ value: GetMulticastGroupSessionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/session"
    }
}

extension GetNetworkAnalyzerConfigurationInput {

    static func urlPathProvider(_ value: GetNetworkAnalyzerConfigurationInput) -> Swift.String? {
        guard let configurationName = value.configurationName else {
            return nil
        }
        return "/network-analyzer-configurations/\(configurationName.urlPercentEncoding())"
    }
}

extension GetPartnerAccountInput {

    static func urlPathProvider(_ value: GetPartnerAccountInput) -> Swift.String? {
        guard let partnerAccountId = value.partnerAccountId else {
            return nil
        }
        return "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
    }
}

extension GetPartnerAccountInput {

    static func queryItemProvider(_ value: GetPartnerAccountInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let partnerType = value.partnerType else {
            let message = "Creating a URL Query Item failed. partnerType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let partnerTypeQueryItem = Smithy.URIQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
        items.append(partnerTypeQueryItem)
        return items
    }
}

extension GetPositionInput {

    static func urlPathProvider(_ value: GetPositionInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/positions/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension GetPositionInput {

    static func queryItemProvider(_ value: GetPositionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension GetPositionConfigurationInput {

    static func urlPathProvider(_ value: GetPositionConfigurationInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/position-configurations/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension GetPositionConfigurationInput {

    static func queryItemProvider(_ value: GetPositionConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension GetPositionEstimateInput {

    static func urlPathProvider(_ value: GetPositionEstimateInput) -> Swift.String? {
        return "/position-estimate"
    }
}

extension GetResourceEventConfigurationInput {

    static func urlPathProvider(_ value: GetResourceEventConfigurationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/event-configurations/\(identifier.urlPercentEncoding())"
    }
}

extension GetResourceEventConfigurationInput {

    static func queryItemProvider(_ value: GetResourceEventConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let partnerType = value.partnerType {
            let partnerTypeQueryItem = Smithy.URIQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            items.append(partnerTypeQueryItem)
        }
        guard let identifierType = value.identifierType else {
            let message = "Creating a URL Query Item failed. identifierType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let identifierTypeQueryItem = Smithy.URIQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
        items.append(identifierTypeQueryItem)
        return items
    }
}

extension GetResourceLogLevelInput {

    static func urlPathProvider(_ value: GetResourceLogLevelInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension GetResourceLogLevelInput {

    static func queryItemProvider(_ value: GetResourceLogLevelInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension GetResourcePositionInput {

    static func urlPathProvider(_ value: GetResourcePositionInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/resource-positions/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension GetResourcePositionInput {

    static func queryItemProvider(_ value: GetResourcePositionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension GetServiceEndpointInput {

    static func urlPathProvider(_ value: GetServiceEndpointInput) -> Swift.String? {
        return "/service-endpoint"
    }
}

extension GetServiceEndpointInput {

    static func queryItemProvider(_ value: GetServiceEndpointInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let serviceType = value.serviceType {
            let serviceTypeQueryItem = Smithy.URIQueryItem(name: "serviceType".urlPercentEncoding(), value: Swift.String(serviceType.rawValue).urlPercentEncoding())
            items.append(serviceTypeQueryItem)
        }
        return items
    }
}

extension GetServiceProfileInput {

    static func urlPathProvider(_ value: GetServiceProfileInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/service-profiles/\(id.urlPercentEncoding())"
    }
}

extension GetWirelessDeviceInput {

    static func urlPathProvider(_ value: GetWirelessDeviceInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/wireless-devices/\(identifier.urlPercentEncoding())"
    }
}

extension GetWirelessDeviceInput {

    static func queryItemProvider(_ value: GetWirelessDeviceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let identifierType = value.identifierType else {
            let message = "Creating a URL Query Item failed. identifierType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let identifierTypeQueryItem = Smithy.URIQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
        items.append(identifierTypeQueryItem)
        return items
    }
}

extension GetWirelessDeviceImportTaskInput {

    static func urlPathProvider(_ value: GetWirelessDeviceImportTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless_device_import_task/\(id.urlPercentEncoding())"
    }
}

extension GetWirelessDeviceStatisticsInput {

    static func urlPathProvider(_ value: GetWirelessDeviceStatisticsInput) -> Swift.String? {
        guard let wirelessDeviceId = value.wirelessDeviceId else {
            return nil
        }
        return "/wireless-devices/\(wirelessDeviceId.urlPercentEncoding())/statistics"
    }
}

extension GetWirelessGatewayInput {

    static func urlPathProvider(_ value: GetWirelessGatewayInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/wireless-gateways/\(identifier.urlPercentEncoding())"
    }
}

extension GetWirelessGatewayInput {

    static func queryItemProvider(_ value: GetWirelessGatewayInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let identifierType = value.identifierType else {
            let message = "Creating a URL Query Item failed. identifierType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let identifierTypeQueryItem = Smithy.URIQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
        items.append(identifierTypeQueryItem)
        return items
    }
}

extension GetWirelessGatewayCertificateInput {

    static func urlPathProvider(_ value: GetWirelessGatewayCertificateInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
    }
}

extension GetWirelessGatewayFirmwareInformationInput {

    static func urlPathProvider(_ value: GetWirelessGatewayFirmwareInformationInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/firmware-information"
    }
}

extension GetWirelessGatewayStatisticsInput {

    static func urlPathProvider(_ value: GetWirelessGatewayStatisticsInput) -> Swift.String? {
        guard let wirelessGatewayId = value.wirelessGatewayId else {
            return nil
        }
        return "/wireless-gateways/\(wirelessGatewayId.urlPercentEncoding())/statistics"
    }
}

extension GetWirelessGatewayTaskInput {

    static func urlPathProvider(_ value: GetWirelessGatewayTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
    }
}

extension GetWirelessGatewayTaskDefinitionInput {

    static func urlPathProvider(_ value: GetWirelessGatewayTaskDefinitionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-gateway-task-definitions/\(id.urlPercentEncoding())"
    }
}

extension ListDestinationsInput {

    static func urlPathProvider(_ value: ListDestinationsInput) -> Swift.String? {
        return "/destinations"
    }
}

extension ListDestinationsInput {

    static func queryItemProvider(_ value: ListDestinationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDeviceProfilesInput {

    static func urlPathProvider(_ value: ListDeviceProfilesInput) -> Swift.String? {
        return "/device-profiles"
    }
}

extension ListDeviceProfilesInput {

    static func queryItemProvider(_ value: ListDeviceProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let deviceProfileType = value.deviceProfileType {
            let deviceProfileTypeQueryItem = Smithy.URIQueryItem(name: "deviceProfileType".urlPercentEncoding(), value: Swift.String(deviceProfileType.rawValue).urlPercentEncoding())
            items.append(deviceProfileTypeQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDevicesForWirelessDeviceImportTaskInput {

    static func urlPathProvider(_ value: ListDevicesForWirelessDeviceImportTaskInput) -> Swift.String? {
        return "/wireless_device_import_task"
    }
}

extension ListDevicesForWirelessDeviceImportTaskInput {

    static func queryItemProvider(_ value: ListDevicesForWirelessDeviceImportTaskInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let id = value.id else {
            let message = "Creating a URL Query Item failed. id is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let idQueryItem = Smithy.URIQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
        items.append(idQueryItem)
        return items
    }
}

extension ListEventConfigurationsInput {

    static func urlPathProvider(_ value: ListEventConfigurationsInput) -> Swift.String? {
        return "/event-configurations"
    }
}

extension ListEventConfigurationsInput {

    static func queryItemProvider(_ value: ListEventConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension ListFuotaTasksInput {

    static func urlPathProvider(_ value: ListFuotaTasksInput) -> Swift.String? {
        return "/fuota-tasks"
    }
}

extension ListFuotaTasksInput {

    static func queryItemProvider(_ value: ListFuotaTasksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMulticastGroupsInput {

    static func urlPathProvider(_ value: ListMulticastGroupsInput) -> Swift.String? {
        return "/multicast-groups"
    }
}

extension ListMulticastGroupsInput {

    static func queryItemProvider(_ value: ListMulticastGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMulticastGroupsByFuotaTaskInput {

    static func urlPathProvider(_ value: ListMulticastGroupsByFuotaTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/multicast-groups"
    }
}

extension ListMulticastGroupsByFuotaTaskInput {

    static func queryItemProvider(_ value: ListMulticastGroupsByFuotaTaskInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListNetworkAnalyzerConfigurationsInput {

    static func urlPathProvider(_ value: ListNetworkAnalyzerConfigurationsInput) -> Swift.String? {
        return "/network-analyzer-configurations"
    }
}

extension ListNetworkAnalyzerConfigurationsInput {

    static func queryItemProvider(_ value: ListNetworkAnalyzerConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPartnerAccountsInput {

    static func urlPathProvider(_ value: ListPartnerAccountsInput) -> Swift.String? {
        return "/partner-accounts"
    }
}

extension ListPartnerAccountsInput {

    static func queryItemProvider(_ value: ListPartnerAccountsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPositionConfigurationsInput {

    static func urlPathProvider(_ value: ListPositionConfigurationsInput) -> Swift.String? {
        return "/position-configurations"
    }
}

extension ListPositionConfigurationsInput {

    static func queryItemProvider(_ value: ListPositionConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let resourceType = value.resourceType {
            let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension ListQueuedMessagesInput {

    static func urlPathProvider(_ value: ListQueuedMessagesInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/data"
    }
}

extension ListQueuedMessagesInput {

    static func queryItemProvider(_ value: ListQueuedMessagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let wirelessDeviceType = value.wirelessDeviceType {
            let wirelessDeviceTypeQueryItem = Smithy.URIQueryItem(name: "WirelessDeviceType".urlPercentEncoding(), value: Swift.String(wirelessDeviceType.rawValue).urlPercentEncoding())
            items.append(wirelessDeviceTypeQueryItem)
        }
        return items
    }
}

extension ListServiceProfilesInput {

    static func urlPathProvider(_ value: ListServiceProfilesInput) -> Swift.String? {
        return "/service-profiles"
    }
}

extension ListServiceProfilesInput {

    static func queryItemProvider(_ value: ListServiceProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension ListWirelessDeviceImportTasksInput {

    static func urlPathProvider(_ value: ListWirelessDeviceImportTasksInput) -> Swift.String? {
        return "/wireless_device_import_tasks"
    }
}

extension ListWirelessDeviceImportTasksInput {

    static func queryItemProvider(_ value: ListWirelessDeviceImportTasksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListWirelessDevicesInput {

    static func urlPathProvider(_ value: ListWirelessDevicesInput) -> Swift.String? {
        return "/wireless-devices"
    }
}

extension ListWirelessDevicesInput {

    static func queryItemProvider(_ value: ListWirelessDevicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let fuotaTaskId = value.fuotaTaskId {
            let fuotaTaskIdQueryItem = Smithy.URIQueryItem(name: "fuotaTaskId".urlPercentEncoding(), value: Swift.String(fuotaTaskId).urlPercentEncoding())
            items.append(fuotaTaskIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let deviceProfileId = value.deviceProfileId {
            let deviceProfileIdQueryItem = Smithy.URIQueryItem(name: "deviceProfileId".urlPercentEncoding(), value: Swift.String(deviceProfileId).urlPercentEncoding())
            items.append(deviceProfileIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let multicastGroupId = value.multicastGroupId {
            let multicastGroupIdQueryItem = Smithy.URIQueryItem(name: "multicastGroupId".urlPercentEncoding(), value: Swift.String(multicastGroupId).urlPercentEncoding())
            items.append(multicastGroupIdQueryItem)
        }
        if let destinationName = value.destinationName {
            let destinationNameQueryItem = Smithy.URIQueryItem(name: "destinationName".urlPercentEncoding(), value: Swift.String(destinationName).urlPercentEncoding())
            items.append(destinationNameQueryItem)
        }
        if let wirelessDeviceType = value.wirelessDeviceType {
            let wirelessDeviceTypeQueryItem = Smithy.URIQueryItem(name: "wirelessDeviceType".urlPercentEncoding(), value: Swift.String(wirelessDeviceType.rawValue).urlPercentEncoding())
            items.append(wirelessDeviceTypeQueryItem)
        }
        if let serviceProfileId = value.serviceProfileId {
            let serviceProfileIdQueryItem = Smithy.URIQueryItem(name: "serviceProfileId".urlPercentEncoding(), value: Swift.String(serviceProfileId).urlPercentEncoding())
            items.append(serviceProfileIdQueryItem)
        }
        return items
    }
}

extension ListWirelessGatewaysInput {

    static func urlPathProvider(_ value: ListWirelessGatewaysInput) -> Swift.String? {
        return "/wireless-gateways"
    }
}

extension ListWirelessGatewaysInput {

    static func queryItemProvider(_ value: ListWirelessGatewaysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListWirelessGatewayTaskDefinitionsInput {

    static func urlPathProvider(_ value: ListWirelessGatewayTaskDefinitionsInput) -> Swift.String? {
        return "/wireless-gateway-task-definitions"
    }
}

extension ListWirelessGatewayTaskDefinitionsInput {

    static func queryItemProvider(_ value: ListWirelessGatewayTaskDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let taskDefinitionType = value.taskDefinitionType {
            let taskDefinitionTypeQueryItem = Smithy.URIQueryItem(name: "taskDefinitionType".urlPercentEncoding(), value: Swift.String(taskDefinitionType.rawValue).urlPercentEncoding())
            items.append(taskDefinitionTypeQueryItem)
        }
        return items
    }
}

extension PutPositionConfigurationInput {

    static func urlPathProvider(_ value: PutPositionConfigurationInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/position-configurations/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension PutPositionConfigurationInput {

    static func queryItemProvider(_ value: PutPositionConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension PutResourceLogLevelInput {

    static func urlPathProvider(_ value: PutResourceLogLevelInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension PutResourceLogLevelInput {

    static func queryItemProvider(_ value: PutResourceLogLevelInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension ResetAllResourceLogLevelsInput {

    static func urlPathProvider(_ value: ResetAllResourceLogLevelsInput) -> Swift.String? {
        return "/log-levels"
    }
}

extension ResetResourceLogLevelInput {

    static func urlPathProvider(_ value: ResetResourceLogLevelInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension ResetResourceLogLevelInput {

    static func queryItemProvider(_ value: ResetResourceLogLevelInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension SendDataToMulticastGroupInput {

    static func urlPathProvider(_ value: SendDataToMulticastGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/data"
    }
}

extension SendDataToWirelessDeviceInput {

    static func urlPathProvider(_ value: SendDataToWirelessDeviceInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/data"
    }
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupInput {

    static func urlPathProvider(_ value: StartBulkAssociateWirelessDeviceWithMulticastGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/bulk"
    }
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupInput {

    static func urlPathProvider(_ value: StartBulkDisassociateWirelessDeviceFromMulticastGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/bulk"
    }
}

extension StartFuotaTaskInput {

    static func urlPathProvider(_ value: StartFuotaTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

extension StartMulticastGroupSessionInput {

    static func urlPathProvider(_ value: StartMulticastGroupSessionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/session"
    }
}

extension StartSingleWirelessDeviceImportTaskInput {

    static func urlPathProvider(_ value: StartSingleWirelessDeviceImportTaskInput) -> Swift.String? {
        return "/wireless_single_device_import_task"
    }
}

extension StartWirelessDeviceImportTaskInput {

    static func urlPathProvider(_ value: StartWirelessDeviceImportTaskInput) -> Swift.String? {
        return "/wireless_device_import_task"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension TagResourceInput {

    static func queryItemProvider(_ value: TagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension TestWirelessDeviceInput {

    static func urlPathProvider(_ value: TestWirelessDeviceInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/test"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateDestinationInput {

    static func urlPathProvider(_ value: UpdateDestinationInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

extension UpdateEventConfigurationByResourceTypesInput {

    static func urlPathProvider(_ value: UpdateEventConfigurationByResourceTypesInput) -> Swift.String? {
        return "/event-configurations-resource-types"
    }
}

extension UpdateFuotaTaskInput {

    static func urlPathProvider(_ value: UpdateFuotaTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

extension UpdateLogLevelsByResourceTypesInput {

    static func urlPathProvider(_ value: UpdateLogLevelsByResourceTypesInput) -> Swift.String? {
        return "/log-levels"
    }
}

extension UpdateMetricConfigurationInput {

    static func urlPathProvider(_ value: UpdateMetricConfigurationInput) -> Swift.String? {
        return "/metric-configuration"
    }
}

extension UpdateMulticastGroupInput {

    static func urlPathProvider(_ value: UpdateMulticastGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())"
    }
}

extension UpdateNetworkAnalyzerConfigurationInput {

    static func urlPathProvider(_ value: UpdateNetworkAnalyzerConfigurationInput) -> Swift.String? {
        guard let configurationName = value.configurationName else {
            return nil
        }
        return "/network-analyzer-configurations/\(configurationName.urlPercentEncoding())"
    }
}

extension UpdatePartnerAccountInput {

    static func urlPathProvider(_ value: UpdatePartnerAccountInput) -> Swift.String? {
        guard let partnerAccountId = value.partnerAccountId else {
            return nil
        }
        return "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
    }
}

extension UpdatePartnerAccountInput {

    static func queryItemProvider(_ value: UpdatePartnerAccountInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let partnerType = value.partnerType else {
            let message = "Creating a URL Query Item failed. partnerType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let partnerTypeQueryItem = Smithy.URIQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
        items.append(partnerTypeQueryItem)
        return items
    }
}

extension UpdatePositionInput {

    static func urlPathProvider(_ value: UpdatePositionInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/positions/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension UpdatePositionInput {

    static func queryItemProvider(_ value: UpdatePositionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension UpdateResourceEventConfigurationInput {

    static func urlPathProvider(_ value: UpdateResourceEventConfigurationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/event-configurations/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateResourceEventConfigurationInput {

    static func queryItemProvider(_ value: UpdateResourceEventConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let partnerType = value.partnerType {
            let partnerTypeQueryItem = Smithy.URIQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            items.append(partnerTypeQueryItem)
        }
        guard let identifierType = value.identifierType else {
            let message = "Creating a URL Query Item failed. identifierType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let identifierTypeQueryItem = Smithy.URIQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
        items.append(identifierTypeQueryItem)
        return items
    }
}

extension UpdateResourcePositionInput {

    static func urlPathProvider(_ value: UpdateResourcePositionInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/resource-positions/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension UpdateResourcePositionInput {

    static func queryItemProvider(_ value: UpdateResourcePositionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension UpdateWirelessDeviceInput {

    static func urlPathProvider(_ value: UpdateWirelessDeviceInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())"
    }
}

extension UpdateWirelessDeviceImportTaskInput {

    static func urlPathProvider(_ value: UpdateWirelessDeviceImportTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless_device_import_task/\(id.urlPercentEncoding())"
    }
}

extension UpdateWirelessGatewayInput {

    static func urlPathProvider(_ value: UpdateWirelessGatewayInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())"
    }
}

extension AssociateAwsAccountWithPartnerAccountInput {

    static func write(value: AssociateAwsAccountWithPartnerAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Sidewalk"].write(value.sidewalk, with: IoTWirelessClientTypes.SidewalkAccountInfo.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssociateMulticastGroupWithFuotaTaskInput {

    static func write(value: AssociateMulticastGroupWithFuotaTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MulticastGroupId"].write(value.multicastGroupId)
    }
}

extension AssociateWirelessDeviceWithFuotaTaskInput {

    static func write(value: AssociateWirelessDeviceWithFuotaTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WirelessDeviceId"].write(value.wirelessDeviceId)
    }
}

extension AssociateWirelessDeviceWithMulticastGroupInput {

    static func write(value: AssociateWirelessDeviceWithMulticastGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WirelessDeviceId"].write(value.wirelessDeviceId)
    }
}

extension AssociateWirelessDeviceWithThingInput {

    static func write(value: AssociateWirelessDeviceWithThingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ThingArn"].write(value.thingArn)
    }
}

extension AssociateWirelessGatewayWithCertificateInput {

    static func write(value: AssociateWirelessGatewayWithCertificateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IotCertificateId"].write(value.iotCertificateId)
    }
}

extension AssociateWirelessGatewayWithThingInput {

    static func write(value: AssociateWirelessGatewayWithThingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ThingArn"].write(value.thingArn)
    }
}

extension CreateDestinationInput {

    static func write(value: CreateDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Description"].write(value.description)
        try writer["Expression"].write(value.expression)
        try writer["ExpressionType"].write(value.expressionType)
        try writer["Name"].write(value.name)
        try writer["RoleArn"].write(value.roleArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDeviceProfileInput {

    static func write(value: CreateDeviceProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANDeviceProfile.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Sidewalk"].write(value.sidewalk, with: IoTWirelessClientTypes.SidewalkCreateDeviceProfile.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateFuotaTaskInput {

    static func write(value: CreateFuotaTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Description"].write(value.description)
        try writer["FirmwareUpdateImage"].write(value.firmwareUpdateImage)
        try writer["FirmwareUpdateRole"].write(value.firmwareUpdateRole)
        try writer["FragmentIntervalMS"].write(value.fragmentIntervalMS)
        try writer["FragmentSizeBytes"].write(value.fragmentSizeBytes)
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANFuotaTask.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["RedundancyPercent"].write(value.redundancyPercent)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMulticastGroupInput {

    static func write(value: CreateMulticastGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Description"].write(value.description)
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANMulticast.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateNetworkAnalyzerConfigurationInput {

    static func write(value: CreateNetworkAnalyzerConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Description"].write(value.description)
        try writer["MulticastGroups"].writeList(value.multicastGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TraceContent"].write(value.traceContent, with: IoTWirelessClientTypes.TraceContent.write(value:to:))
        try writer["WirelessDevices"].writeList(value.wirelessDevices, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WirelessGateways"].writeList(value.wirelessGateways, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateServiceProfileInput {

    static func write(value: CreateServiceProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANServiceProfile.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateWirelessDeviceInput {

    static func write(value: CreateWirelessDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Description"].write(value.description)
        try writer["DestinationName"].write(value.destinationName)
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANDevice.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Positioning"].write(value.positioning)
        try writer["Sidewalk"].write(value.sidewalk, with: IoTWirelessClientTypes.SidewalkCreateWirelessDevice.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension CreateWirelessGatewayInput {

    static func write(value: CreateWirelessGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Description"].write(value.description)
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANGateway.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateWirelessGatewayTaskInput {

    static func write(value: CreateWirelessGatewayTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WirelessGatewayTaskDefinitionId"].write(value.wirelessGatewayTaskDefinitionId)
    }
}

extension CreateWirelessGatewayTaskDefinitionInput {

    static func write(value: CreateWirelessGatewayTaskDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoCreateTasks"].write(value.autoCreateTasks)
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Update"].write(value.update, with: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate.write(value:to:))
    }
}

extension GetMetricsInput {

    static func write(value: GetMetricsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SummaryMetricQueries"].writeList(value.summaryMetricQueries, memberWritingClosure: IoTWirelessClientTypes.SummaryMetricQuery.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetPositionEstimateInput {

    static func write(value: GetPositionEstimateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CellTowers"].write(value.cellTowers, with: IoTWirelessClientTypes.CellTowers.write(value:to:))
        try writer["Gnss"].write(value.gnss, with: IoTWirelessClientTypes.Gnss.write(value:to:))
        try writer["Ip"].write(value.ip, with: IoTWirelessClientTypes.Ip.write(value:to:))
        try writer["Timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["WiFiAccessPoints"].writeList(value.wiFiAccessPoints, memberWritingClosure: IoTWirelessClientTypes.WiFiAccessPoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutPositionConfigurationInput {

    static func write(value: PutPositionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination)
        try writer["Solvers"].write(value.solvers, with: IoTWirelessClientTypes.PositionSolverConfigurations.write(value:to:))
    }
}

extension PutResourceLogLevelInput {

    static func write(value: PutResourceLogLevelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogLevel"].write(value.logLevel)
    }
}

extension SendDataToMulticastGroupInput {

    static func write(value: SendDataToMulticastGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PayloadData"].write(value.payloadData)
        try writer["WirelessMetadata"].write(value.wirelessMetadata, with: IoTWirelessClientTypes.MulticastWirelessMetadata.write(value:to:))
    }
}

extension SendDataToWirelessDeviceInput {

    static func write(value: SendDataToWirelessDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PayloadData"].write(value.payloadData)
        try writer["TransmitMode"].write(value.transmitMode)
        try writer["WirelessMetadata"].write(value.wirelessMetadata, with: IoTWirelessClientTypes.WirelessMetadata.write(value:to:))
    }
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupInput {

    static func write(value: StartBulkAssociateWirelessDeviceWithMulticastGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryString"].write(value.queryString)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupInput {

    static func write(value: StartBulkDisassociateWirelessDeviceFromMulticastGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryString"].write(value.queryString)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartFuotaTaskInput {

    static func write(value: StartFuotaTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANStartFuotaTask.write(value:to:))
    }
}

extension StartMulticastGroupSessionInput {

    static func write(value: StartMulticastGroupSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANMulticastSession.write(value:to:))
    }
}

extension StartSingleWirelessDeviceImportTaskInput {

    static func write(value: StartSingleWirelessDeviceImportTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["DestinationName"].write(value.destinationName)
        try writer["DeviceName"].write(value.deviceName)
        try writer["Sidewalk"].write(value.sidewalk, with: IoTWirelessClientTypes.SidewalkSingleStartImportInfo.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartWirelessDeviceImportTaskInput {

    static func write(value: StartWirelessDeviceImportTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["DestinationName"].write(value.destinationName)
        try writer["Sidewalk"].write(value.sidewalk, with: IoTWirelessClientTypes.SidewalkStartImportInfo.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTWirelessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDestinationInput {

    static func write(value: UpdateDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Expression"].write(value.expression)
        try writer["ExpressionType"].write(value.expressionType)
        try writer["RoleArn"].write(value.roleArn)
    }
}

extension UpdateEventConfigurationByResourceTypesInput {

    static func write(value: UpdateEventConfigurationByResourceTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionStatus"].write(value.connectionStatus, with: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration.write(value:to:))
        try writer["DeviceRegistrationState"].write(value.deviceRegistrationState, with: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration.write(value:to:))
        try writer["Join"].write(value.join, with: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration.write(value:to:))
        try writer["MessageDeliveryStatus"].write(value.messageDeliveryStatus, with: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration.write(value:to:))
        try writer["Proximity"].write(value.proximity, with: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration.write(value:to:))
    }
}

extension UpdateFuotaTaskInput {

    static func write(value: UpdateFuotaTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["FirmwareUpdateImage"].write(value.firmwareUpdateImage)
        try writer["FirmwareUpdateRole"].write(value.firmwareUpdateRole)
        try writer["FragmentIntervalMS"].write(value.fragmentIntervalMS)
        try writer["FragmentSizeBytes"].write(value.fragmentSizeBytes)
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANFuotaTask.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["RedundancyPercent"].write(value.redundancyPercent)
    }
}

extension UpdateLogLevelsByResourceTypesInput {

    static func write(value: UpdateLogLevelsByResourceTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultLogLevel"].write(value.defaultLogLevel)
        try writer["WirelessDeviceLogOptions"].writeList(value.wirelessDeviceLogOptions, memberWritingClosure: IoTWirelessClientTypes.WirelessDeviceLogOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WirelessGatewayLogOptions"].writeList(value.wirelessGatewayLogOptions, memberWritingClosure: IoTWirelessClientTypes.WirelessGatewayLogOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateMetricConfigurationInput {

    static func write(value: UpdateMetricConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SummaryMetric"].write(value.summaryMetric, with: IoTWirelessClientTypes.SummaryMetricConfiguration.write(value:to:))
    }
}

extension UpdateMulticastGroupInput {

    static func write(value: UpdateMulticastGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANMulticast.write(value:to:))
        try writer["Name"].write(value.name)
    }
}

extension UpdateNetworkAnalyzerConfigurationInput {

    static func write(value: UpdateNetworkAnalyzerConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["MulticastGroupsToAdd"].writeList(value.multicastGroupsToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MulticastGroupsToRemove"].writeList(value.multicastGroupsToRemove, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TraceContent"].write(value.traceContent, with: IoTWirelessClientTypes.TraceContent.write(value:to:))
        try writer["WirelessDevicesToAdd"].writeList(value.wirelessDevicesToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WirelessDevicesToRemove"].writeList(value.wirelessDevicesToRemove, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WirelessGatewaysToAdd"].writeList(value.wirelessGatewaysToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WirelessGatewaysToRemove"].writeList(value.wirelessGatewaysToRemove, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdatePartnerAccountInput {

    static func write(value: UpdatePartnerAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Sidewalk"].write(value.sidewalk, with: IoTWirelessClientTypes.SidewalkUpdateAccount.write(value:to:))
    }
}

extension UpdatePositionInput {

    static func write(value: UpdatePositionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeFloat(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateResourceEventConfigurationInput {

    static func write(value: UpdateResourceEventConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionStatus"].write(value.connectionStatus, with: IoTWirelessClientTypes.ConnectionStatusEventConfiguration.write(value:to:))
        try writer["DeviceRegistrationState"].write(value.deviceRegistrationState, with: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration.write(value:to:))
        try writer["Join"].write(value.join, with: IoTWirelessClientTypes.JoinEventConfiguration.write(value:to:))
        try writer["MessageDeliveryStatus"].write(value.messageDeliveryStatus, with: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration.write(value:to:))
        try writer["Proximity"].write(value.proximity, with: IoTWirelessClientTypes.ProximityEventConfiguration.write(value:to:))
    }
}

extension UpdateResourcePositionInput {

    static func write(value: UpdateResourcePositionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GeoJsonPayload"].write(value.geoJsonPayload)
    }
}

extension UpdateWirelessDeviceInput {

    static func write(value: UpdateWirelessDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DestinationName"].write(value.destinationName)
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANUpdateDevice.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Positioning"].write(value.positioning)
    }
}

extension UpdateWirelessDeviceImportTaskInput {

    static func write(value: UpdateWirelessDeviceImportTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Sidewalk"].write(value.sidewalk, with: IoTWirelessClientTypes.SidewalkUpdateImportInfo.write(value:to:))
    }
}

extension UpdateWirelessGatewayInput {

    static func write(value: UpdateWirelessGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["JoinEuiFilters"].writeList(value.joinEuiFilters, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxEirp"].write(value.maxEirp)
        try writer["Name"].write(value.name)
        try writer["NetIdFilters"].writeList(value.netIdFilters, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssociateAwsAccountWithPartnerAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateAwsAccountWithPartnerAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateAwsAccountWithPartnerAccountOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.SidewalkAccountInfo.read(from:))
        return value
    }
}

extension AssociateMulticastGroupWithFuotaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateMulticastGroupWithFuotaTaskOutput {
        return AssociateMulticastGroupWithFuotaTaskOutput()
    }
}

extension AssociateWirelessDeviceWithFuotaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateWirelessDeviceWithFuotaTaskOutput {
        return AssociateWirelessDeviceWithFuotaTaskOutput()
    }
}

extension AssociateWirelessDeviceWithMulticastGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateWirelessDeviceWithMulticastGroupOutput {
        return AssociateWirelessDeviceWithMulticastGroupOutput()
    }
}

extension AssociateWirelessDeviceWithThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateWirelessDeviceWithThingOutput {
        return AssociateWirelessDeviceWithThingOutput()
    }
}

extension AssociateWirelessGatewayWithCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateWirelessGatewayWithCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateWirelessGatewayWithCertificateOutput()
        value.iotCertificateId = try reader["IotCertificateId"].readIfPresent()
        return value
    }
}

extension AssociateWirelessGatewayWithThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateWirelessGatewayWithThingOutput {
        return AssociateWirelessGatewayWithThingOutput()
    }
}

extension CancelMulticastGroupSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelMulticastGroupSessionOutput {
        return CancelMulticastGroupSessionOutput()
    }
}

extension CreateDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDestinationOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateDeviceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDeviceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeviceProfileOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateFuotaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFuotaTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFuotaTaskOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateMulticastGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMulticastGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMulticastGroupOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateNetworkAnalyzerConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNetworkAnalyzerConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNetworkAnalyzerConfigurationOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateServiceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceProfileOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateWirelessDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWirelessDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWirelessDeviceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateWirelessGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWirelessGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWirelessGatewayOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateWirelessGatewayTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWirelessGatewayTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWirelessGatewayTaskOutput()
        value.status = try reader["Status"].readIfPresent()
        value.wirelessGatewayTaskDefinitionId = try reader["WirelessGatewayTaskDefinitionId"].readIfPresent()
        return value
    }
}

extension CreateWirelessGatewayTaskDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWirelessGatewayTaskDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWirelessGatewayTaskDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension DeleteDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDestinationOutput {
        return DeleteDestinationOutput()
    }
}

extension DeleteDeviceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDeviceProfileOutput {
        return DeleteDeviceProfileOutput()
    }
}

extension DeleteFuotaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFuotaTaskOutput {
        return DeleteFuotaTaskOutput()
    }
}

extension DeleteMulticastGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMulticastGroupOutput {
        return DeleteMulticastGroupOutput()
    }
}

extension DeleteNetworkAnalyzerConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNetworkAnalyzerConfigurationOutput {
        return DeleteNetworkAnalyzerConfigurationOutput()
    }
}

extension DeleteQueuedMessagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteQueuedMessagesOutput {
        return DeleteQueuedMessagesOutput()
    }
}

extension DeleteServiceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceProfileOutput {
        return DeleteServiceProfileOutput()
    }
}

extension DeleteWirelessDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWirelessDeviceOutput {
        return DeleteWirelessDeviceOutput()
    }
}

extension DeleteWirelessDeviceImportTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWirelessDeviceImportTaskOutput {
        return DeleteWirelessDeviceImportTaskOutput()
    }
}

extension DeleteWirelessGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWirelessGatewayOutput {
        return DeleteWirelessGatewayOutput()
    }
}

extension DeleteWirelessGatewayTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWirelessGatewayTaskOutput {
        return DeleteWirelessGatewayTaskOutput()
    }
}

extension DeleteWirelessGatewayTaskDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWirelessGatewayTaskDefinitionOutput {
        return DeleteWirelessGatewayTaskDefinitionOutput()
    }
}

extension DeregisterWirelessDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterWirelessDeviceOutput {
        return DeregisterWirelessDeviceOutput()
    }
}

extension DisassociateAwsAccountFromPartnerAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateAwsAccountFromPartnerAccountOutput {
        return DisassociateAwsAccountFromPartnerAccountOutput()
    }
}

extension DisassociateMulticastGroupFromFuotaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateMulticastGroupFromFuotaTaskOutput {
        return DisassociateMulticastGroupFromFuotaTaskOutput()
    }
}

extension DisassociateWirelessDeviceFromFuotaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateWirelessDeviceFromFuotaTaskOutput {
        return DisassociateWirelessDeviceFromFuotaTaskOutput()
    }
}

extension DisassociateWirelessDeviceFromMulticastGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateWirelessDeviceFromMulticastGroupOutput {
        return DisassociateWirelessDeviceFromMulticastGroupOutput()
    }
}

extension DisassociateWirelessDeviceFromThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateWirelessDeviceFromThingOutput {
        return DisassociateWirelessDeviceFromThingOutput()
    }
}

extension DisassociateWirelessGatewayFromCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateWirelessGatewayFromCertificateOutput {
        return DisassociateWirelessGatewayFromCertificateOutput()
    }
}

extension DisassociateWirelessGatewayFromThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateWirelessGatewayFromThingOutput {
        return DisassociateWirelessGatewayFromThingOutput()
    }
}

extension GetDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDestinationOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.expression = try reader["Expression"].readIfPresent()
        value.expressionType = try reader["ExpressionType"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension GetDeviceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeviceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceProfileOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANDeviceProfile.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.SidewalkGetDeviceProfile.read(from:))
        return value
    }
}

extension GetEventConfigurationByResourceTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventConfigurationByResourceTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventConfigurationByResourceTypesOutput()
        value.connectionStatus = try reader["ConnectionStatus"].readIfPresent(with: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration.read(from:))
        value.deviceRegistrationState = try reader["DeviceRegistrationState"].readIfPresent(with: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration.read(from:))
        value.join = try reader["Join"].readIfPresent(with: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration.read(from:))
        value.messageDeliveryStatus = try reader["MessageDeliveryStatus"].readIfPresent(with: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration.read(from:))
        value.proximity = try reader["Proximity"].readIfPresent(with: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration.read(from:))
        return value
    }
}

extension GetFuotaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFuotaTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFuotaTaskOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.firmwareUpdateImage = try reader["FirmwareUpdateImage"].readIfPresent()
        value.firmwareUpdateRole = try reader["FirmwareUpdateRole"].readIfPresent()
        value.fragmentIntervalMS = try reader["FragmentIntervalMS"].readIfPresent()
        value.fragmentSizeBytes = try reader["FragmentSizeBytes"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.redundancyPercent = try reader["RedundancyPercent"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GetLogLevelsByResourceTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLogLevelsByResourceTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLogLevelsByResourceTypesOutput()
        value.defaultLogLevel = try reader["DefaultLogLevel"].readIfPresent()
        value.wirelessDeviceLogOptions = try reader["WirelessDeviceLogOptions"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.WirelessDeviceLogOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.wirelessGatewayLogOptions = try reader["WirelessGatewayLogOptions"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.WirelessGatewayLogOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetMetricConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMetricConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMetricConfigurationOutput()
        value.summaryMetric = try reader["SummaryMetric"].readIfPresent(with: IoTWirelessClientTypes.SummaryMetricConfiguration.read(from:))
        return value
    }
}

extension GetMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMetricsOutput()
        value.summaryMetricQueryResults = try reader["SummaryMetricQueryResults"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.SummaryMetricQueryResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetMulticastGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMulticastGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMulticastGroupOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANMulticastGet.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GetMulticastGroupSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMulticastGroupSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMulticastGroupSessionOutput()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANMulticastSession.read(from:))
        return value
    }
}

extension GetNetworkAnalyzerConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNetworkAnalyzerConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNetworkAnalyzerConfigurationOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.multicastGroups = try reader["MulticastGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.traceContent = try reader["TraceContent"].readIfPresent(with: IoTWirelessClientTypes.TraceContent.read(from:))
        value.wirelessDevices = try reader["WirelessDevices"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.wirelessGateways = try reader["WirelessGateways"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetPartnerAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPartnerAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPartnerAccountOutput()
        value.accountLinked = try reader["AccountLinked"].readIfPresent() ?? false
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint.read(from:))
        return value
    }
}

extension GetPositionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPositionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPositionOutput()
        value.accuracy = try reader["Accuracy"].readIfPresent(with: IoTWirelessClientTypes.Accuracy.read(from:))
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readFloat(from:), memberNodeInfo: "member", isFlattened: false)
        value.solverProvider = try reader["SolverProvider"].readIfPresent()
        value.solverType = try reader["SolverType"].readIfPresent()
        value.solverVersion = try reader["SolverVersion"].readIfPresent()
        value.timestamp = try reader["Timestamp"].readIfPresent()
        return value
    }
}

extension GetPositionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPositionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPositionConfigurationOutput()
        value.destination = try reader["Destination"].readIfPresent()
        value.solvers = try reader["Solvers"].readIfPresent(with: IoTWirelessClientTypes.PositionSolverDetails.read(from:))
        return value
    }
}

extension GetPositionEstimateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPositionEstimateOutput {
        var value = GetPositionEstimateOutput()
        switch httpResponse.body {
        case .data(let data):
            value.geoJsonPayload = data
        case .stream(let stream):
            value.geoJsonPayload = try stream.readToEnd()
        case .noStream:
            value.geoJsonPayload = nil
        }
        return value
    }
}

extension GetResourceEventConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceEventConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceEventConfigurationOutput()
        value.connectionStatus = try reader["ConnectionStatus"].readIfPresent(with: IoTWirelessClientTypes.ConnectionStatusEventConfiguration.read(from:))
        value.deviceRegistrationState = try reader["DeviceRegistrationState"].readIfPresent(with: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration.read(from:))
        value.join = try reader["Join"].readIfPresent(with: IoTWirelessClientTypes.JoinEventConfiguration.read(from:))
        value.messageDeliveryStatus = try reader["MessageDeliveryStatus"].readIfPresent(with: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration.read(from:))
        value.proximity = try reader["Proximity"].readIfPresent(with: IoTWirelessClientTypes.ProximityEventConfiguration.read(from:))
        return value
    }
}

extension GetResourceLogLevelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceLogLevelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceLogLevelOutput()
        value.logLevel = try reader["LogLevel"].readIfPresent()
        return value
    }
}

extension GetResourcePositionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePositionOutput {
        var value = GetResourcePositionOutput()
        switch httpResponse.body {
        case .data(let data):
            value.geoJsonPayload = data
        case .stream(let stream):
            value.geoJsonPayload = try stream.readToEnd()
        case .noStream:
            value.geoJsonPayload = nil
        }
        return value
    }
}

extension GetServiceEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceEndpointOutput()
        value.serverTrust = try reader["ServerTrust"].readIfPresent()
        value.serviceEndpoint = try reader["ServiceEndpoint"].readIfPresent()
        value.serviceType = try reader["ServiceType"].readIfPresent()
        return value
    }
}

extension GetServiceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceProfileOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo.read(from:))
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GetWirelessDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWirelessDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWirelessDeviceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.destinationName = try reader["DestinationName"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANDevice.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.positioning = try reader["Positioning"].readIfPresent()
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.SidewalkDevice.read(from:))
        value.thingArn = try reader["ThingArn"].readIfPresent()
        value.thingName = try reader["ThingName"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension GetWirelessDeviceImportTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWirelessDeviceImportTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWirelessDeviceImportTaskOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.destinationName = try reader["DestinationName"].readIfPresent()
        value.failedImportedDeviceCount = try reader["FailedImportedDeviceCount"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.initializedImportedDeviceCount = try reader["InitializedImportedDeviceCount"].readIfPresent()
        value.onboardedImportedDeviceCount = try reader["OnboardedImportedDeviceCount"].readIfPresent()
        value.pendingImportedDeviceCount = try reader["PendingImportedDeviceCount"].readIfPresent()
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.SidewalkGetStartImportInfo.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        return value
    }
}

extension GetWirelessDeviceStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWirelessDeviceStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWirelessDeviceStatisticsOutput()
        value.lastUplinkReceivedAt = try reader["LastUplinkReceivedAt"].readIfPresent()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANDeviceMetadata.read(from:))
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.SidewalkDeviceMetadata.read(from:))
        value.wirelessDeviceId = try reader["WirelessDeviceId"].readIfPresent()
        return value
    }
}

extension GetWirelessGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWirelessGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWirelessGatewayOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANGateway.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.thingArn = try reader["ThingArn"].readIfPresent()
        value.thingName = try reader["ThingName"].readIfPresent()
        return value
    }
}

extension GetWirelessGatewayCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWirelessGatewayCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWirelessGatewayCertificateOutput()
        value.iotCertificateId = try reader["IotCertificateId"].readIfPresent()
        value.loRaWANNetworkServerCertificateId = try reader["LoRaWANNetworkServerCertificateId"].readIfPresent()
        return value
    }
}

extension GetWirelessGatewayFirmwareInformationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWirelessGatewayFirmwareInformationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWirelessGatewayFirmwareInformationOutput()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion.read(from:))
        return value
    }
}

extension GetWirelessGatewayStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWirelessGatewayStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWirelessGatewayStatisticsOutput()
        value.connectionStatus = try reader["ConnectionStatus"].readIfPresent()
        value.lastUplinkReceivedAt = try reader["LastUplinkReceivedAt"].readIfPresent()
        value.wirelessGatewayId = try reader["WirelessGatewayId"].readIfPresent()
        return value
    }
}

extension GetWirelessGatewayTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWirelessGatewayTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWirelessGatewayTaskOutput()
        value.lastUplinkReceivedAt = try reader["LastUplinkReceivedAt"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.taskCreatedAt = try reader["TaskCreatedAt"].readIfPresent()
        value.wirelessGatewayId = try reader["WirelessGatewayId"].readIfPresent()
        value.wirelessGatewayTaskDefinitionId = try reader["WirelessGatewayTaskDefinitionId"].readIfPresent()
        return value
    }
}

extension GetWirelessGatewayTaskDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWirelessGatewayTaskDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWirelessGatewayTaskDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.autoCreateTasks = try reader["AutoCreateTasks"].readIfPresent() ?? false
        value.name = try reader["Name"].readIfPresent()
        value.update = try reader["Update"].readIfPresent(with: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate.read(from:))
        return value
    }
}

extension ListDestinationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDestinationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDestinationsOutput()
        value.destinationList = try reader["DestinationList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.Destinations.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDeviceProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDeviceProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeviceProfilesOutput()
        value.deviceProfileList = try reader["DeviceProfileList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.DeviceProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDevicesForWirelessDeviceImportTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDevicesForWirelessDeviceImportTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDevicesForWirelessDeviceImportTaskOutput()
        value.destinationName = try reader["DestinationName"].readIfPresent()
        value.importedWirelessDeviceList = try reader["ImportedWirelessDeviceList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.ImportedWirelessDevice.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEventConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventConfigurationsOutput()
        value.eventConfigurationsList = try reader["EventConfigurationsList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.EventConfigurationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFuotaTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFuotaTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFuotaTasksOutput()
        value.fuotaTaskList = try reader["FuotaTaskList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.FuotaTask.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMulticastGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMulticastGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMulticastGroupsOutput()
        value.multicastGroupList = try reader["MulticastGroupList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.MulticastGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMulticastGroupsByFuotaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMulticastGroupsByFuotaTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMulticastGroupsByFuotaTaskOutput()
        value.multicastGroupList = try reader["MulticastGroupList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.MulticastGroupByFuotaTask.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListNetworkAnalyzerConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNetworkAnalyzerConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNetworkAnalyzerConfigurationsOutput()
        value.networkAnalyzerConfigurationList = try reader["NetworkAnalyzerConfigurationList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.NetworkAnalyzerConfigurations.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPartnerAccountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPartnerAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPartnerAccountsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.sidewalk = try reader["Sidewalk"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPositionConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPositionConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPositionConfigurationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.positionConfigurationList = try reader["PositionConfigurationList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.PositionConfigurationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListQueuedMessagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQueuedMessagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQueuedMessagesOutput()
        value.downlinkQueueMessagesList = try reader["DownlinkQueueMessagesList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.DownlinkQueueMessage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListServiceProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceProfilesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serviceProfileList = try reader["ServiceProfileList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.ServiceProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWirelessDeviceImportTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWirelessDeviceImportTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWirelessDeviceImportTasksOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.wirelessDeviceImportTaskList = try reader["WirelessDeviceImportTaskList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.WirelessDeviceImportTask.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWirelessDevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWirelessDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWirelessDevicesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.wirelessDeviceList = try reader["WirelessDeviceList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.WirelessDeviceStatistics.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWirelessGatewaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWirelessGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWirelessGatewaysOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.wirelessGatewayList = try reader["WirelessGatewayList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.WirelessGatewayStatistics.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWirelessGatewayTaskDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWirelessGatewayTaskDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWirelessGatewayTaskDefinitionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.taskDefinitions = try reader["TaskDefinitions"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutPositionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutPositionConfigurationOutput {
        return PutPositionConfigurationOutput()
    }
}

extension PutResourceLogLevelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourceLogLevelOutput {
        return PutResourceLogLevelOutput()
    }
}

extension ResetAllResourceLogLevelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetAllResourceLogLevelsOutput {
        return ResetAllResourceLogLevelsOutput()
    }
}

extension ResetResourceLogLevelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetResourceLogLevelOutput {
        return ResetResourceLogLevelOutput()
    }
}

extension SendDataToMulticastGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendDataToMulticastGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendDataToMulticastGroupOutput()
        value.messageId = try reader["MessageId"].readIfPresent()
        return value
    }
}

extension SendDataToWirelessDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendDataToWirelessDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendDataToWirelessDeviceOutput()
        value.messageId = try reader["MessageId"].readIfPresent()
        return value
    }
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartBulkAssociateWirelessDeviceWithMulticastGroupOutput {
        return StartBulkAssociateWirelessDeviceWithMulticastGroupOutput()
    }
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartBulkDisassociateWirelessDeviceFromMulticastGroupOutput {
        return StartBulkDisassociateWirelessDeviceFromMulticastGroupOutput()
    }
}

extension StartFuotaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartFuotaTaskOutput {
        return StartFuotaTaskOutput()
    }
}

extension StartMulticastGroupSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMulticastGroupSessionOutput {
        return StartMulticastGroupSessionOutput()
    }
}

extension StartSingleWirelessDeviceImportTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSingleWirelessDeviceImportTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSingleWirelessDeviceImportTaskOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension StartWirelessDeviceImportTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartWirelessDeviceImportTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartWirelessDeviceImportTaskOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TestWirelessDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestWirelessDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestWirelessDeviceOutput()
        value.result = try reader["Result"].readIfPresent()
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDestinationOutput {
        return UpdateDestinationOutput()
    }
}

extension UpdateEventConfigurationByResourceTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEventConfigurationByResourceTypesOutput {
        return UpdateEventConfigurationByResourceTypesOutput()
    }
}

extension UpdateFuotaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFuotaTaskOutput {
        return UpdateFuotaTaskOutput()
    }
}

extension UpdateLogLevelsByResourceTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLogLevelsByResourceTypesOutput {
        return UpdateLogLevelsByResourceTypesOutput()
    }
}

extension UpdateMetricConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMetricConfigurationOutput {
        return UpdateMetricConfigurationOutput()
    }
}

extension UpdateMulticastGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMulticastGroupOutput {
        return UpdateMulticastGroupOutput()
    }
}

extension UpdateNetworkAnalyzerConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNetworkAnalyzerConfigurationOutput {
        return UpdateNetworkAnalyzerConfigurationOutput()
    }
}

extension UpdatePartnerAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePartnerAccountOutput {
        return UpdatePartnerAccountOutput()
    }
}

extension UpdatePositionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePositionOutput {
        return UpdatePositionOutput()
    }
}

extension UpdateResourceEventConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResourceEventConfigurationOutput {
        return UpdateResourceEventConfigurationOutput()
    }
}

extension UpdateResourcePositionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResourcePositionOutput {
        return UpdateResourcePositionOutput()
    }
}

extension UpdateWirelessDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWirelessDeviceOutput {
        return UpdateWirelessDeviceOutput()
    }
}

extension UpdateWirelessDeviceImportTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWirelessDeviceImportTaskOutput {
        return UpdateWirelessDeviceImportTaskOutput()
    }
}

extension UpdateWirelessGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWirelessGatewayOutput {
        return UpdateWirelessGatewayOutput()
    }
}

enum AssociateAwsAccountWithPartnerAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateMulticastGroupWithFuotaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateWirelessDeviceWithFuotaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateWirelessDeviceWithMulticastGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateWirelessDeviceWithThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateWirelessGatewayWithCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateWirelessGatewayWithThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelMulticastGroupSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDeviceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFuotaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMulticastGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNetworkAnalyzerConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWirelessDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWirelessGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWirelessGatewayTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWirelessGatewayTaskDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDeviceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFuotaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMulticastGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNetworkAnalyzerConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteQueuedMessagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWirelessDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWirelessDeviceImportTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWirelessGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWirelessGatewayTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWirelessGatewayTaskDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterWirelessDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateAwsAccountFromPartnerAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateMulticastGroupFromFuotaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateWirelessDeviceFromFuotaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateWirelessDeviceFromMulticastGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateWirelessDeviceFromThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateWirelessGatewayFromCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateWirelessGatewayFromThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeviceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventConfigurationByResourceTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFuotaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLogLevelsByResourceTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMetricConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMulticastGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMulticastGroupSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNetworkAnalyzerConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPartnerAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPositionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPositionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPositionEstimateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceEventConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceLogLevelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePositionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWirelessDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWirelessDeviceImportTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWirelessDeviceStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWirelessGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWirelessGatewayCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWirelessGatewayFirmwareInformationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWirelessGatewayStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWirelessGatewayTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWirelessGatewayTaskDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDestinationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDeviceProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDevicesForWirelessDeviceImportTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFuotaTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMulticastGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMulticastGroupsByFuotaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNetworkAnalyzerConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPartnerAccountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPositionConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQueuedMessagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWirelessDeviceImportTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWirelessDevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWirelessGatewaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWirelessGatewayTaskDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutPositionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourceLogLevelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetAllResourceLogLevelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetResourceLogLevelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendDataToMulticastGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendDataToWirelessDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartBulkAssociateWirelessDeviceWithMulticastGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartBulkDisassociateWirelessDeviceFromMulticastGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartFuotaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMulticastGroupSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSingleWirelessDeviceImportTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartWirelessDeviceImportTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestWirelessDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEventConfigurationByResourceTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFuotaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLogLevelsByResourceTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMetricConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMulticastGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNetworkAnalyzerConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePartnerAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePositionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResourceEventConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResourcePositionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWirelessDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWirelessDeviceImportTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWirelessGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IoTWirelessClientTypes.SidewalkAccountInfo {

    static func write(value: IoTWirelessClientTypes.SidewalkAccountInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AmazonId"].write(value.amazonId)
        try writer["AppServerPrivateKey"].write(value.appServerPrivateKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.SidewalkAccountInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.SidewalkAccountInfo()
        value.amazonId = try reader["AmazonId"].readIfPresent()
        value.appServerPrivateKey = try reader["AppServerPrivateKey"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANDeviceProfile {

    static func write(value: IoTWirelessClientTypes.LoRaWANDeviceProfile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClassBTimeout"].write(value.classBTimeout)
        try writer["ClassCTimeout"].write(value.classCTimeout)
        try writer["FactoryPresetFreqsList"].writeList(value.factoryPresetFreqsList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MacVersion"].write(value.macVersion)
        try writer["MaxDutyCycle"].write(value.maxDutyCycle)
        try writer["MaxEirp"].write(value.maxEirp)
        try writer["PingSlotDr"].write(value.pingSlotDr)
        try writer["PingSlotFreq"].write(value.pingSlotFreq)
        try writer["PingSlotPeriod"].write(value.pingSlotPeriod)
        try writer["RegParamsRevision"].write(value.regParamsRevision)
        try writer["RfRegion"].write(value.rfRegion)
        try writer["RxDataRate2"].write(value.rxDataRate2)
        try writer["RxDelay1"].write(value.rxDelay1)
        try writer["RxDrOffset1"].write(value.rxDrOffset1)
        try writer["RxFreq2"].write(value.rxFreq2)
        try writer["Supports32BitFCnt"].write(value.supports32BitFCnt)
        try writer["SupportsClassB"].write(value.supportsClassB)
        try writer["SupportsClassC"].write(value.supportsClassC)
        try writer["SupportsJoin"].write(value.supportsJoin)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANDeviceProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANDeviceProfile()
        value.supportsClassB = try reader["SupportsClassB"].readIfPresent() ?? false
        value.classBTimeout = try reader["ClassBTimeout"].readIfPresent()
        value.pingSlotPeriod = try reader["PingSlotPeriod"].readIfPresent()
        value.pingSlotDr = try reader["PingSlotDr"].readIfPresent()
        value.pingSlotFreq = try reader["PingSlotFreq"].readIfPresent()
        value.supportsClassC = try reader["SupportsClassC"].readIfPresent() ?? false
        value.classCTimeout = try reader["ClassCTimeout"].readIfPresent()
        value.macVersion = try reader["MacVersion"].readIfPresent()
        value.regParamsRevision = try reader["RegParamsRevision"].readIfPresent()
        value.rxDelay1 = try reader["RxDelay1"].readIfPresent()
        value.rxDrOffset1 = try reader["RxDrOffset1"].readIfPresent()
        value.rxDataRate2 = try reader["RxDataRate2"].readIfPresent()
        value.rxFreq2 = try reader["RxFreq2"].readIfPresent()
        value.factoryPresetFreqsList = try reader["FactoryPresetFreqsList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxEirp = try reader["MaxEirp"].readIfPresent()
        value.maxDutyCycle = try reader["MaxDutyCycle"].readIfPresent()
        value.rfRegion = try reader["RfRegion"].readIfPresent()
        value.supportsJoin = try reader["SupportsJoin"].readIfPresent()
        value.supports32BitFCnt = try reader["Supports32BitFCnt"].readIfPresent() ?? false
        return value
    }
}

extension IoTWirelessClientTypes.SidewalkGetDeviceProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.SidewalkGetDeviceProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.SidewalkGetDeviceProfile()
        value.applicationServerPublicKey = try reader["ApplicationServerPublicKey"].readIfPresent()
        value.qualificationStatus = try reader["QualificationStatus"].readIfPresent()
        value.dakCertificateMetadata = try reader["DakCertificateMetadata"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.DakCertificateMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTWirelessClientTypes.DakCertificateMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.DakCertificateMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.DakCertificateMetadata()
        value.certificateId = try reader["CertificateId"].readIfPresent() ?? ""
        value.maxAllowedSignature = try reader["MaxAllowedSignature"].readIfPresent()
        value.factorySupport = try reader["FactorySupport"].readIfPresent()
        value.apId = try reader["ApId"].readIfPresent()
        value.deviceTypeId = try reader["DeviceTypeId"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration {

    static func write(value: IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Sidewalk"].write(value.sidewalk, with: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.DeviceRegistrationStateResourceTypeEventConfiguration()
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration {

    static func write(value: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WirelessDeviceEventTopic"].write(value.wirelessDeviceEventTopic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration()
        value.wirelessDeviceEventTopic = try reader["WirelessDeviceEventTopic"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration {

    static func write(value: IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Sidewalk"].write(value.sidewalk, with: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.ProximityResourceTypeEventConfiguration()
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.JoinResourceTypeEventConfiguration {

    static func write(value: IoTWirelessClientTypes.JoinResourceTypeEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.JoinResourceTypeEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.JoinResourceTypeEventConfiguration()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration {

    static func write(value: IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WirelessDeviceEventTopic"].write(value.wirelessDeviceEventTopic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANJoinResourceTypeEventConfiguration()
        value.wirelessDeviceEventTopic = try reader["WirelessDeviceEventTopic"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration {

    static func write(value: IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.ConnectionStatusResourceTypeEventConfiguration()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration {

    static func write(value: IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WirelessGatewayEventTopic"].write(value.wirelessGatewayEventTopic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANConnectionStatusResourceTypeEventConfiguration()
        value.wirelessGatewayEventTopic = try reader["WirelessGatewayEventTopic"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration {

    static func write(value: IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Sidewalk"].write(value.sidewalk, with: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.MessageDeliveryStatusResourceTypeEventConfiguration()
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.SidewalkResourceTypeEventConfiguration.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANFuotaTaskGetInfo()
        value.rfRegion = try reader["RfRegion"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IoTWirelessClientTypes.WirelessGatewayLogOption {

    static func write(value: IoTWirelessClientTypes.WirelessGatewayLogOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Events"].writeList(value.events, memberWritingClosure: IoTWirelessClientTypes.WirelessGatewayEventLogOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LogLevel"].write(value.logLevel)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.WirelessGatewayLogOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.WirelessGatewayLogOption()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.logLevel = try reader["LogLevel"].readIfPresent() ?? .sdkUnknown("")
        value.events = try reader["Events"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.WirelessGatewayEventLogOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTWirelessClientTypes.WirelessGatewayEventLogOption {

    static func write(value: IoTWirelessClientTypes.WirelessGatewayEventLogOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Event"].write(value.event)
        try writer["LogLevel"].write(value.logLevel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.WirelessGatewayEventLogOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.WirelessGatewayEventLogOption()
        value.event = try reader["Event"].readIfPresent() ?? .sdkUnknown("")
        value.logLevel = try reader["LogLevel"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTWirelessClientTypes.WirelessDeviceLogOption {

    static func write(value: IoTWirelessClientTypes.WirelessDeviceLogOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Events"].writeList(value.events, memberWritingClosure: IoTWirelessClientTypes.WirelessDeviceEventLogOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LogLevel"].write(value.logLevel)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.WirelessDeviceLogOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.WirelessDeviceLogOption()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.logLevel = try reader["LogLevel"].readIfPresent() ?? .sdkUnknown("")
        value.events = try reader["Events"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.WirelessDeviceEventLogOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTWirelessClientTypes.WirelessDeviceEventLogOption {

    static func write(value: IoTWirelessClientTypes.WirelessDeviceEventLogOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Event"].write(value.event)
        try writer["LogLevel"].write(value.logLevel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.WirelessDeviceEventLogOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.WirelessDeviceEventLogOption()
        value.event = try reader["Event"].readIfPresent() ?? .sdkUnknown("")
        value.logLevel = try reader["LogLevel"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTWirelessClientTypes.SummaryMetricConfiguration {

    static func write(value: IoTWirelessClientTypes.SummaryMetricConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.SummaryMetricConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.SummaryMetricConfiguration()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.SummaryMetricQueryResult {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.SummaryMetricQueryResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.SummaryMetricQueryResult()
        value.queryId = try reader["QueryId"].readIfPresent()
        value.queryStatus = try reader["QueryStatus"].readIfPresent()
        value.error = try reader["Error"].readIfPresent()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.dimensions = try reader["Dimensions"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.Dimension.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.aggregationPeriod = try reader["AggregationPeriod"].readIfPresent()
        value.startTimestamp = try reader["StartTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTimestamp = try reader["EndTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.timestamps = try reader["Timestamps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.timestampReadingClosure(format: SmithyTimestamps.TimestampFormat.epochSeconds), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.MetricQueryValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unit = try reader["Unit"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.MetricQueryValue {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.MetricQueryValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.MetricQueryValue()
        value.min = try reader["Min"].readIfPresent()
        value.max = try reader["Max"].readIfPresent()
        value.sum = try reader["Sum"].readIfPresent()
        value.avg = try reader["Avg"].readIfPresent()
        value.std = try reader["Std"].readIfPresent()
        value.p90 = try reader["P90"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.Dimension {

    static func write(value: IoTWirelessClientTypes.Dimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.Dimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.Dimension()
        value.name = try reader["name"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANMulticastGet {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANMulticastGet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANMulticastGet()
        value.rfRegion = try reader["RfRegion"].readIfPresent()
        value.dlClass = try reader["DlClass"].readIfPresent()
        value.numberOfDevicesRequested = try reader["NumberOfDevicesRequested"].readIfPresent()
        value.numberOfDevicesInGroup = try reader["NumberOfDevicesInGroup"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANMulticastSession {

    static func write(value: IoTWirelessClientTypes.LoRaWANMulticastSession?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DlDr"].write(value.dlDr)
        try writer["DlFreq"].write(value.dlFreq)
        try writer["PingSlotPeriod"].write(value.pingSlotPeriod)
        try writer["SessionStartTime"].writeTimestamp(value.sessionStartTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["SessionTimeout"].write(value.sessionTimeout)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANMulticastSession {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANMulticastSession()
        value.dlDr = try reader["DlDr"].readIfPresent()
        value.dlFreq = try reader["DlFreq"].readIfPresent()
        value.sessionStartTime = try reader["SessionStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.sessionTimeout = try reader["SessionTimeout"].readIfPresent()
        value.pingSlotPeriod = try reader["PingSlotPeriod"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.TraceContent {

    static func write(value: IoTWirelessClientTypes.TraceContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogLevel"].write(value.logLevel)
        try writer["MulticastFrameInfo"].write(value.multicastFrameInfo)
        try writer["WirelessDeviceFrameInfo"].write(value.wirelessDeviceFrameInfo)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.TraceContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.TraceContent()
        value.wirelessDeviceFrameInfo = try reader["WirelessDeviceFrameInfo"].readIfPresent()
        value.logLevel = try reader["LogLevel"].readIfPresent()
        value.multicastFrameInfo = try reader["MulticastFrameInfo"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.SidewalkAccountInfoWithFingerprint()
        value.amazonId = try reader["AmazonId"].readIfPresent()
        value.fingerprint = try reader["Fingerprint"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.Accuracy {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.Accuracy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.Accuracy()
        value.horizontalAccuracy = try reader["HorizontalAccuracy"].readIfPresent()
        value.verticalAccuracy = try reader["VerticalAccuracy"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.PositionSolverDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.PositionSolverDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.PositionSolverDetails()
        value.semtechGnss = try reader["SemtechGnss"].readIfPresent(with: IoTWirelessClientTypes.SemtechGnssDetail.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.SemtechGnssDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.SemtechGnssDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.SemtechGnssDetail()
        value.provider = try reader["Provider"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.fec = try reader["Fec"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration {

    static func write(value: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Sidewalk"].write(value.sidewalk, with: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations.write(value:to:))
        try writer["WirelessDeviceIdEventTopic"].write(value.wirelessDeviceIdEventTopic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration()
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations.read(from:))
        value.wirelessDeviceIdEventTopic = try reader["WirelessDeviceIdEventTopic"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.SidewalkEventNotificationConfigurations {

    static func write(value: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AmazonIdEventTopic"].write(value.amazonIdEventTopic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.SidewalkEventNotificationConfigurations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.SidewalkEventNotificationConfigurations()
        value.amazonIdEventTopic = try reader["AmazonIdEventTopic"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.ProximityEventConfiguration {

    static func write(value: IoTWirelessClientTypes.ProximityEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Sidewalk"].write(value.sidewalk, with: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations.write(value:to:))
        try writer["WirelessDeviceIdEventTopic"].write(value.wirelessDeviceIdEventTopic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.ProximityEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.ProximityEventConfiguration()
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations.read(from:))
        value.wirelessDeviceIdEventTopic = try reader["WirelessDeviceIdEventTopic"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.JoinEventConfiguration {

    static func write(value: IoTWirelessClientTypes.JoinEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations.write(value:to:))
        try writer["WirelessDeviceIdEventTopic"].write(value.wirelessDeviceIdEventTopic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.JoinEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.JoinEventConfiguration()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations.read(from:))
        value.wirelessDeviceIdEventTopic = try reader["WirelessDeviceIdEventTopic"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations {

    static func write(value: IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DevEuiEventTopic"].write(value.devEuiEventTopic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANJoinEventNotificationConfigurations()
        value.devEuiEventTopic = try reader["DevEuiEventTopic"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.ConnectionStatusEventConfiguration {

    static func write(value: IoTWirelessClientTypes.ConnectionStatusEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations.write(value:to:))
        try writer["WirelessGatewayIdEventTopic"].write(value.wirelessGatewayIdEventTopic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.ConnectionStatusEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.ConnectionStatusEventConfiguration()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations.read(from:))
        value.wirelessGatewayIdEventTopic = try reader["WirelessGatewayIdEventTopic"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations {

    static func write(value: IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayEuiEventTopic"].write(value.gatewayEuiEventTopic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANConnectionStatusEventNotificationConfigurations()
        value.gatewayEuiEventTopic = try reader["GatewayEuiEventTopic"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration {

    static func write(value: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Sidewalk"].write(value.sidewalk, with: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations.write(value:to:))
        try writer["WirelessDeviceIdEventTopic"].write(value.wirelessDeviceIdEventTopic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration()
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.SidewalkEventNotificationConfigurations.read(from:))
        value.wirelessDeviceIdEventTopic = try reader["WirelessDeviceIdEventTopic"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANGetServiceProfileInfo()
        value.ulRate = try reader["UlRate"].readIfPresent()
        value.ulBucketSize = try reader["UlBucketSize"].readIfPresent()
        value.ulRatePolicy = try reader["UlRatePolicy"].readIfPresent()
        value.dlRate = try reader["DlRate"].readIfPresent()
        value.dlBucketSize = try reader["DlBucketSize"].readIfPresent()
        value.dlRatePolicy = try reader["DlRatePolicy"].readIfPresent()
        value.addGwMetadata = try reader["AddGwMetadata"].readIfPresent() ?? false
        value.devStatusReqFreq = try reader["DevStatusReqFreq"].readIfPresent()
        value.reportDevStatusBattery = try reader["ReportDevStatusBattery"].readIfPresent() ?? false
        value.reportDevStatusMargin = try reader["ReportDevStatusMargin"].readIfPresent() ?? false
        value.drMin = try reader["DrMin"].readIfPresent() ?? 0
        value.drMax = try reader["DrMax"].readIfPresent() ?? 0
        value.channelMask = try reader["ChannelMask"].readIfPresent()
        value.prAllowed = try reader["PrAllowed"].readIfPresent() ?? false
        value.hrAllowed = try reader["HrAllowed"].readIfPresent() ?? false
        value.raAllowed = try reader["RaAllowed"].readIfPresent() ?? false
        value.nwkGeoLoc = try reader["NwkGeoLoc"].readIfPresent() ?? false
        value.targetPer = try reader["TargetPer"].readIfPresent() ?? 0
        value.minGwDiversity = try reader["MinGwDiversity"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANDevice {

    static func write(value: IoTWirelessClientTypes.LoRaWANDevice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AbpV1_0_x"].write(value.abpV1_0_x, with: IoTWirelessClientTypes.AbpV1_0_x.write(value:to:))
        try writer["AbpV1_1"].write(value.abpV1_1, with: IoTWirelessClientTypes.AbpV1_1.write(value:to:))
        try writer["DevEui"].write(value.devEui)
        try writer["DeviceProfileId"].write(value.deviceProfileId)
        try writer["FPorts"].write(value.fPorts, with: IoTWirelessClientTypes.FPorts.write(value:to:))
        try writer["OtaaV1_0_x"].write(value.otaaV1_0_x, with: IoTWirelessClientTypes.OtaaV1_0_x.write(value:to:))
        try writer["OtaaV1_1"].write(value.otaaV1_1, with: IoTWirelessClientTypes.OtaaV1_1.write(value:to:))
        try writer["ServiceProfileId"].write(value.serviceProfileId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANDevice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANDevice()
        value.devEui = try reader["DevEui"].readIfPresent()
        value.deviceProfileId = try reader["DeviceProfileId"].readIfPresent()
        value.serviceProfileId = try reader["ServiceProfileId"].readIfPresent()
        value.otaaV1_1 = try reader["OtaaV1_1"].readIfPresent(with: IoTWirelessClientTypes.OtaaV1_1.read(from:))
        value.otaaV1_0_x = try reader["OtaaV1_0_x"].readIfPresent(with: IoTWirelessClientTypes.OtaaV1_0_x.read(from:))
        value.abpV1_1 = try reader["AbpV1_1"].readIfPresent(with: IoTWirelessClientTypes.AbpV1_1.read(from:))
        value.abpV1_0_x = try reader["AbpV1_0_x"].readIfPresent(with: IoTWirelessClientTypes.AbpV1_0_x.read(from:))
        value.fPorts = try reader["FPorts"].readIfPresent(with: IoTWirelessClientTypes.FPorts.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.FPorts {

    static func write(value: IoTWirelessClientTypes.FPorts?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Applications"].writeList(value.applications, memberWritingClosure: IoTWirelessClientTypes.ApplicationConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClockSync"].write(value.clockSync)
        try writer["Fuota"].write(value.fuota)
        try writer["Multicast"].write(value.multicast)
        try writer["Positioning"].write(value.positioning, with: IoTWirelessClientTypes.Positioning.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.FPorts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.FPorts()
        value.fuota = try reader["Fuota"].readIfPresent()
        value.multicast = try reader["Multicast"].readIfPresent()
        value.clockSync = try reader["ClockSync"].readIfPresent()
        value.positioning = try reader["Positioning"].readIfPresent(with: IoTWirelessClientTypes.Positioning.read(from:))
        value.applications = try reader["Applications"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.ApplicationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTWirelessClientTypes.ApplicationConfig {

    static func write(value: IoTWirelessClientTypes.ApplicationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationName"].write(value.destinationName)
        try writer["FPort"].write(value.fPort)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.ApplicationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.ApplicationConfig()
        value.fPort = try reader["FPort"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.destinationName = try reader["DestinationName"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.Positioning {

    static func write(value: IoTWirelessClientTypes.Positioning?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClockSync"].write(value.clockSync)
        try writer["Gnss"].write(value.gnss)
        try writer["Stream"].write(value.stream)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.Positioning {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.Positioning()
        value.clockSync = try reader["ClockSync"].readIfPresent()
        value.stream = try reader["Stream"].readIfPresent()
        value.gnss = try reader["Gnss"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.AbpV1_0_x {

    static func write(value: IoTWirelessClientTypes.AbpV1_0_x?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DevAddr"].write(value.devAddr)
        try writer["FCntStart"].write(value.fCntStart)
        try writer["SessionKeys"].write(value.sessionKeys, with: IoTWirelessClientTypes.SessionKeysAbpV1_0_x.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.AbpV1_0_x {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.AbpV1_0_x()
        value.devAddr = try reader["DevAddr"].readIfPresent()
        value.sessionKeys = try reader["SessionKeys"].readIfPresent(with: IoTWirelessClientTypes.SessionKeysAbpV1_0_x.read(from:))
        value.fCntStart = try reader["FCntStart"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.SessionKeysAbpV1_0_x {

    static func write(value: IoTWirelessClientTypes.SessionKeysAbpV1_0_x?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppSKey"].write(value.appSKey)
        try writer["NwkSKey"].write(value.nwkSKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.SessionKeysAbpV1_0_x {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.SessionKeysAbpV1_0_x()
        value.nwkSKey = try reader["NwkSKey"].readIfPresent()
        value.appSKey = try reader["AppSKey"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.AbpV1_1 {

    static func write(value: IoTWirelessClientTypes.AbpV1_1?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DevAddr"].write(value.devAddr)
        try writer["FCntStart"].write(value.fCntStart)
        try writer["SessionKeys"].write(value.sessionKeys, with: IoTWirelessClientTypes.SessionKeysAbpV1_1.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.AbpV1_1 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.AbpV1_1()
        value.devAddr = try reader["DevAddr"].readIfPresent()
        value.sessionKeys = try reader["SessionKeys"].readIfPresent(with: IoTWirelessClientTypes.SessionKeysAbpV1_1.read(from:))
        value.fCntStart = try reader["FCntStart"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.SessionKeysAbpV1_1 {

    static func write(value: IoTWirelessClientTypes.SessionKeysAbpV1_1?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppSKey"].write(value.appSKey)
        try writer["FNwkSIntKey"].write(value.fNwkSIntKey)
        try writer["NwkSEncKey"].write(value.nwkSEncKey)
        try writer["SNwkSIntKey"].write(value.sNwkSIntKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.SessionKeysAbpV1_1 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.SessionKeysAbpV1_1()
        value.fNwkSIntKey = try reader["FNwkSIntKey"].readIfPresent()
        value.sNwkSIntKey = try reader["SNwkSIntKey"].readIfPresent()
        value.nwkSEncKey = try reader["NwkSEncKey"].readIfPresent()
        value.appSKey = try reader["AppSKey"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.OtaaV1_0_x {

    static func write(value: IoTWirelessClientTypes.OtaaV1_0_x?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppEui"].write(value.appEui)
        try writer["AppKey"].write(value.appKey)
        try writer["GenAppKey"].write(value.genAppKey)
        try writer["JoinEui"].write(value.joinEui)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.OtaaV1_0_x {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.OtaaV1_0_x()
        value.appKey = try reader["AppKey"].readIfPresent()
        value.appEui = try reader["AppEui"].readIfPresent()
        value.joinEui = try reader["JoinEui"].readIfPresent()
        value.genAppKey = try reader["GenAppKey"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.OtaaV1_1 {

    static func write(value: IoTWirelessClientTypes.OtaaV1_1?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppKey"].write(value.appKey)
        try writer["JoinEui"].write(value.joinEui)
        try writer["NwkKey"].write(value.nwkKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.OtaaV1_1 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.OtaaV1_1()
        value.appKey = try reader["AppKey"].readIfPresent()
        value.nwkKey = try reader["NwkKey"].readIfPresent()
        value.joinEui = try reader["JoinEui"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.SidewalkDevice {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.SidewalkDevice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.SidewalkDevice()
        value.amazonId = try reader["AmazonId"].readIfPresent()
        value.sidewalkId = try reader["SidewalkId"].readIfPresent()
        value.sidewalkManufacturingSn = try reader["SidewalkManufacturingSn"].readIfPresent()
        value.deviceCertificates = try reader["DeviceCertificates"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.CertificateList.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.privateKeys = try reader["PrivateKeys"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.CertificateList.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.deviceProfileId = try reader["DeviceProfileId"].readIfPresent()
        value.certificateId = try reader["CertificateId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.CertificateList {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.CertificateList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.CertificateList()
        value.signingAlg = try reader["SigningAlg"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension IoTWirelessClientTypes.SidewalkGetStartImportInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.SidewalkGetStartImportInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.SidewalkGetStartImportInfo()
        value.deviceCreationFileList = try reader["DeviceCreationFileList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.role = try reader["Role"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANDeviceMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANDeviceMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANDeviceMetadata()
        value.devEui = try reader["DevEui"].readIfPresent()
        value.fPort = try reader["FPort"].readIfPresent()
        value.dataRate = try reader["DataRate"].readIfPresent()
        value.frequency = try reader["Frequency"].readIfPresent()
        value.timestamp = try reader["Timestamp"].readIfPresent()
        value.gateways = try reader["Gateways"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.LoRaWANGatewayMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.publicGateways = try reader["PublicGateways"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.LoRaWANPublicGatewayMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANPublicGatewayMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANPublicGatewayMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANPublicGatewayMetadata()
        value.providerNetId = try reader["ProviderNetId"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.rssi = try reader["Rssi"].readIfPresent()
        value.snr = try reader["Snr"].readIfPresent()
        value.rfRegion = try reader["RfRegion"].readIfPresent()
        value.dlAllowed = try reader["DlAllowed"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANGatewayMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANGatewayMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANGatewayMetadata()
        value.gatewayEui = try reader["GatewayEui"].readIfPresent()
        value.snr = try reader["Snr"].readIfPresent()
        value.rssi = try reader["Rssi"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.SidewalkDeviceMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.SidewalkDeviceMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.SidewalkDeviceMetadata()
        value.rssi = try reader["Rssi"].readIfPresent()
        value.batteryLevel = try reader["BatteryLevel"].readIfPresent()
        value.event = try reader["Event"].readIfPresent()
        value.deviceState = try reader["DeviceState"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANGateway {

    static func write(value: IoTWirelessClientTypes.LoRaWANGateway?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Beaconing"].write(value.beaconing, with: IoTWirelessClientTypes.Beaconing.write(value:to:))
        try writer["GatewayEui"].write(value.gatewayEui)
        try writer["JoinEuiFilters"].writeList(value.joinEuiFilters, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxEirp"].write(value.maxEirp)
        try writer["NetIdFilters"].writeList(value.netIdFilters, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RfRegion"].write(value.rfRegion)
        try writer["SubBands"].writeList(value.subBands, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANGateway {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANGateway()
        value.gatewayEui = try reader["GatewayEui"].readIfPresent()
        value.rfRegion = try reader["RfRegion"].readIfPresent()
        value.joinEuiFilters = try reader["JoinEuiFilters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.netIdFilters = try reader["NetIdFilters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subBands = try reader["SubBands"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.beaconing = try reader["Beaconing"].readIfPresent(with: IoTWirelessClientTypes.Beaconing.read(from:))
        value.maxEirp = try reader["MaxEirp"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.Beaconing {

    static func write(value: IoTWirelessClientTypes.Beaconing?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataRate"].write(value.dataRate)
        try writer["Frequencies"].writeList(value.frequencies, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.Beaconing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.Beaconing()
        value.dataRate = try reader["DataRate"].readIfPresent()
        value.frequencies = try reader["Frequencies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANGatewayCurrentVersion()
        value.currentVersion = try reader["CurrentVersion"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANGatewayVersion.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANGatewayVersion {

    static func write(value: IoTWirelessClientTypes.LoRaWANGatewayVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Model"].write(value.model)
        try writer["PackageVersion"].write(value.packageVersion)
        try writer["Station"].write(value.station)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANGatewayVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANGatewayVersion()
        value.packageVersion = try reader["PackageVersion"].readIfPresent()
        value.model = try reader["Model"].readIfPresent()
        value.station = try reader["Station"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate {

    static func write(value: IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate.write(value:to:))
        try writer["UpdateDataRole"].write(value.updateDataRole)
        try writer["UpdateDataSource"].write(value.updateDataSource)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.UpdateWirelessGatewayTaskCreate()
        value.updateDataSource = try reader["UpdateDataSource"].readIfPresent()
        value.updateDataRole = try reader["UpdateDataRole"].readIfPresent()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate {

    static func write(value: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CurrentVersion"].write(value.currentVersion, with: IoTWirelessClientTypes.LoRaWANGatewayVersion.write(value:to:))
        try writer["SigKeyCrc"].write(value.sigKeyCrc)
        try writer["UpdateSignature"].write(value.updateSignature)
        try writer["UpdateVersion"].write(value.updateVersion, with: IoTWirelessClientTypes.LoRaWANGatewayVersion.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate()
        value.updateSignature = try reader["UpdateSignature"].readIfPresent()
        value.sigKeyCrc = try reader["SigKeyCrc"].readIfPresent()
        value.currentVersion = try reader["CurrentVersion"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANGatewayVersion.read(from:))
        value.updateVersion = try reader["UpdateVersion"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANGatewayVersion.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.Destinations {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.Destinations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.Destinations()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.expressionType = try reader["ExpressionType"].readIfPresent()
        value.expression = try reader["Expression"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.DeviceProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.DeviceProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.DeviceProfile()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.ImportedWirelessDevice {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.ImportedWirelessDevice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.ImportedWirelessDevice()
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.ImportedSidewalkDevice.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.ImportedSidewalkDevice {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.ImportedSidewalkDevice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.ImportedSidewalkDevice()
        value.sidewalkManufacturingSn = try reader["SidewalkManufacturingSn"].readIfPresent()
        value.onboardingStatus = try reader["OnboardingStatus"].readIfPresent()
        value.onboardingStatusReason = try reader["OnboardingStatusReason"].readIfPresent()
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IoTWirelessClientTypes.EventConfigurationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.EventConfigurationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.EventConfigurationItem()
        value.identifier = try reader["Identifier"].readIfPresent()
        value.identifierType = try reader["IdentifierType"].readIfPresent()
        value.partnerType = try reader["PartnerType"].readIfPresent()
        value.events = try reader["Events"].readIfPresent(with: IoTWirelessClientTypes.EventNotificationItemConfigurations.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.EventNotificationItemConfigurations {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.EventNotificationItemConfigurations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.EventNotificationItemConfigurations()
        value.deviceRegistrationState = try reader["DeviceRegistrationState"].readIfPresent(with: IoTWirelessClientTypes.DeviceRegistrationStateEventConfiguration.read(from:))
        value.proximity = try reader["Proximity"].readIfPresent(with: IoTWirelessClientTypes.ProximityEventConfiguration.read(from:))
        value.join = try reader["Join"].readIfPresent(with: IoTWirelessClientTypes.JoinEventConfiguration.read(from:))
        value.connectionStatus = try reader["ConnectionStatus"].readIfPresent(with: IoTWirelessClientTypes.ConnectionStatusEventConfiguration.read(from:))
        value.messageDeliveryStatus = try reader["MessageDeliveryStatus"].readIfPresent(with: IoTWirelessClientTypes.MessageDeliveryStatusEventConfiguration.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.FuotaTask {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.FuotaTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.FuotaTask()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.MulticastGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.MulticastGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.MulticastGroup()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.MulticastGroupByFuotaTask {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.MulticastGroupByFuotaTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.MulticastGroupByFuotaTask()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.NetworkAnalyzerConfigurations {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.NetworkAnalyzerConfigurations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.NetworkAnalyzerConfigurations()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.PositionConfigurationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.PositionConfigurationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.PositionConfigurationItem()
        value.resourceIdentifier = try reader["ResourceIdentifier"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.solvers = try reader["Solvers"].readIfPresent(with: IoTWirelessClientTypes.PositionSolverDetails.read(from:))
        value.destination = try reader["Destination"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.DownlinkQueueMessage {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.DownlinkQueueMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.DownlinkQueueMessage()
        value.messageId = try reader["MessageId"].readIfPresent()
        value.transmitMode = try reader["TransmitMode"].readIfPresent()
        value.receivedAt = try reader["ReceivedAt"].readIfPresent()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANSendDataToDevice.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANSendDataToDevice {

    static func write(value: IoTWirelessClientTypes.LoRaWANSendDataToDevice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FPort"].write(value.fPort)
        try writer["ParticipatingGateways"].write(value.participatingGateways, with: IoTWirelessClientTypes.ParticipatingGateways.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANSendDataToDevice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANSendDataToDevice()
        value.fPort = try reader["FPort"].readIfPresent()
        value.participatingGateways = try reader["ParticipatingGateways"].readIfPresent(with: IoTWirelessClientTypes.ParticipatingGateways.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.ParticipatingGateways {

    static func write(value: IoTWirelessClientTypes.ParticipatingGateways?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DownlinkMode"].write(value.downlinkMode)
        try writer["GatewayList"].writeList(value.gatewayList, memberWritingClosure: IoTWirelessClientTypes.GatewayListItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TransmissionInterval"].write(value.transmissionInterval)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.ParticipatingGateways {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.ParticipatingGateways()
        value.downlinkMode = try reader["DownlinkMode"].readIfPresent() ?? .sdkUnknown("")
        value.gatewayList = try reader["GatewayList"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.GatewayListItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.transmissionInterval = try reader["TransmissionInterval"].readIfPresent() ?? 0
        return value
    }
}

extension IoTWirelessClientTypes.GatewayListItem {

    static func write(value: IoTWirelessClientTypes.GatewayListItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DownlinkFrequency"].write(value.downlinkFrequency)
        try writer["GatewayId"].write(value.gatewayId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.GatewayListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.GatewayListItem()
        value.gatewayId = try reader["GatewayId"].readIfPresent() ?? ""
        value.downlinkFrequency = try reader["DownlinkFrequency"].readIfPresent() ?? 0
        return value
    }
}

extension IoTWirelessClientTypes.ServiceProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.ServiceProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.ServiceProfile()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.Tag {

    static func write(value: IoTWirelessClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension IoTWirelessClientTypes.WirelessDeviceImportTask {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.WirelessDeviceImportTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.WirelessDeviceImportTask()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.destinationName = try reader["DestinationName"].readIfPresent()
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.SidewalkGetStartImportInfo.read(from:))
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.initializedImportedDeviceCount = try reader["InitializedImportedDeviceCount"].readIfPresent()
        value.pendingImportedDeviceCount = try reader["PendingImportedDeviceCount"].readIfPresent()
        value.onboardedImportedDeviceCount = try reader["OnboardedImportedDeviceCount"].readIfPresent()
        value.failedImportedDeviceCount = try reader["FailedImportedDeviceCount"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.WirelessDeviceStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.WirelessDeviceStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.WirelessDeviceStatistics()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.destinationName = try reader["DestinationName"].readIfPresent()
        value.lastUplinkReceivedAt = try reader["LastUplinkReceivedAt"].readIfPresent()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANListDevice.read(from:))
        value.sidewalk = try reader["Sidewalk"].readIfPresent(with: IoTWirelessClientTypes.SidewalkListDevice.read(from:))
        value.fuotaDeviceStatus = try reader["FuotaDeviceStatus"].readIfPresent()
        value.multicastDeviceStatus = try reader["MulticastDeviceStatus"].readIfPresent()
        value.mcGroupId = try reader["McGroupId"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.SidewalkListDevice {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.SidewalkListDevice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.SidewalkListDevice()
        value.amazonId = try reader["AmazonId"].readIfPresent()
        value.sidewalkId = try reader["SidewalkId"].readIfPresent()
        value.sidewalkManufacturingSn = try reader["SidewalkManufacturingSn"].readIfPresent()
        value.deviceCertificates = try reader["DeviceCertificates"].readListIfPresent(memberReadingClosure: IoTWirelessClientTypes.CertificateList.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.deviceProfileId = try reader["DeviceProfileId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANListDevice {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANListDevice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANListDevice()
        value.devEui = try reader["DevEui"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.WirelessGatewayStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.WirelessGatewayStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.WirelessGatewayStatistics()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANGateway.read(from:))
        value.lastUplinkReceivedAt = try reader["LastUplinkReceivedAt"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.UpdateWirelessGatewayTaskEntry()
        value.id = try reader["Id"].readIfPresent()
        value.loRaWAN = try reader["LoRaWAN"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry.read(from:))
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry()
        value.currentVersion = try reader["CurrentVersion"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANGatewayVersion.read(from:))
        value.updateVersion = try reader["UpdateVersion"].readIfPresent(with: IoTWirelessClientTypes.LoRaWANGatewayVersion.read(from:))
        return value
    }
}

extension IoTWirelessClientTypes.SidewalkCreateDeviceProfile {

    static func write(value: IoTWirelessClientTypes.SidewalkCreateDeviceProfile?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension IoTWirelessClientTypes.LoRaWANFuotaTask {

    static func write(value: IoTWirelessClientTypes.LoRaWANFuotaTask?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RfRegion"].write(value.rfRegion)
    }
}

extension IoTWirelessClientTypes.LoRaWANMulticast {

    static func write(value: IoTWirelessClientTypes.LoRaWANMulticast?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DlClass"].write(value.dlClass)
        try writer["RfRegion"].write(value.rfRegion)
    }
}

extension IoTWirelessClientTypes.LoRaWANServiceProfile {

    static func write(value: IoTWirelessClientTypes.LoRaWANServiceProfile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddGwMetadata"].write(value.addGwMetadata)
        try writer["DrMax"].write(value.drMax)
        try writer["DrMin"].write(value.drMin)
        try writer["PrAllowed"].write(value.prAllowed)
        try writer["RaAllowed"].write(value.raAllowed)
    }
}

extension IoTWirelessClientTypes.SidewalkCreateWirelessDevice {

    static func write(value: IoTWirelessClientTypes.SidewalkCreateWirelessDevice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceProfileId"].write(value.deviceProfileId)
    }
}

extension IoTWirelessClientTypes.SummaryMetricQuery {

    static func write(value: IoTWirelessClientTypes.SummaryMetricQuery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggregationPeriod"].write(value.aggregationPeriod)
        try writer["Dimensions"].writeList(value.dimensions, memberWritingClosure: IoTWirelessClientTypes.Dimension.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndTimestamp"].writeTimestamp(value.endTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["MetricName"].write(value.metricName)
        try writer["QueryId"].write(value.queryId)
        try writer["StartTimestamp"].writeTimestamp(value.startTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension IoTWirelessClientTypes.WiFiAccessPoint {

    static func write(value: IoTWirelessClientTypes.WiFiAccessPoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MacAddress"].write(value.macAddress)
        try writer["Rss"].write(value.rss)
    }
}

extension IoTWirelessClientTypes.CellTowers {

    static func write(value: IoTWirelessClientTypes.CellTowers?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cdma"].writeList(value.cdma, memberWritingClosure: IoTWirelessClientTypes.CdmaObj.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Gsm"].writeList(value.gsm, memberWritingClosure: IoTWirelessClientTypes.GsmObj.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Lte"].writeList(value.lte, memberWritingClosure: IoTWirelessClientTypes.LteObj.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tdscdma"].writeList(value.tdscdma, memberWritingClosure: IoTWirelessClientTypes.TdscdmaObj.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Wcdma"].writeList(value.wcdma, memberWritingClosure: IoTWirelessClientTypes.WcdmaObj.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension IoTWirelessClientTypes.CdmaObj {

    static func write(value: IoTWirelessClientTypes.CdmaObj?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaseLat"].write(value.baseLat)
        try writer["BaseLng"].write(value.baseLng)
        try writer["BaseStationId"].write(value.baseStationId)
        try writer["CdmaLocalId"].write(value.cdmaLocalId, with: IoTWirelessClientTypes.CdmaLocalId.write(value:to:))
        try writer["CdmaNmr"].writeList(value.cdmaNmr, memberWritingClosure: IoTWirelessClientTypes.CdmaNmrObj.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkId"].write(value.networkId)
        try writer["PilotPower"].write(value.pilotPower)
        try writer["RegistrationZone"].write(value.registrationZone)
        try writer["SystemId"].write(value.systemId)
    }
}

extension IoTWirelessClientTypes.CdmaNmrObj {

    static func write(value: IoTWirelessClientTypes.CdmaNmrObj?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaseStationId"].write(value.baseStationId)
        try writer["CdmaChannel"].write(value.cdmaChannel)
        try writer["PilotPower"].write(value.pilotPower)
        try writer["PnOffset"].write(value.pnOffset)
    }
}

extension IoTWirelessClientTypes.CdmaLocalId {

    static func write(value: IoTWirelessClientTypes.CdmaLocalId?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CdmaChannel"].write(value.cdmaChannel)
        try writer["PnOffset"].write(value.pnOffset)
    }
}

extension IoTWirelessClientTypes.LteObj {

    static func write(value: IoTWirelessClientTypes.LteObj?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EutranCid"].write(value.eutranCid)
        try writer["LteLocalId"].write(value.lteLocalId, with: IoTWirelessClientTypes.LteLocalId.write(value:to:))
        try writer["LteNmr"].writeList(value.lteNmr, memberWritingClosure: IoTWirelessClientTypes.LteNmrObj.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LteTimingAdvance"].write(value.lteTimingAdvance)
        try writer["Mcc"].write(value.mcc)
        try writer["Mnc"].write(value.mnc)
        try writer["NrCapable"].write(value.nrCapable)
        try writer["Rsrp"].write(value.rsrp)
        try writer["Rsrq"].write(value.rsrq)
        try writer["Tac"].write(value.tac)
    }
}

extension IoTWirelessClientTypes.LteNmrObj {

    static func write(value: IoTWirelessClientTypes.LteNmrObj?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Earfcn"].write(value.earfcn)
        try writer["EutranCid"].write(value.eutranCid)
        try writer["Pci"].write(value.pci)
        try writer["Rsrp"].write(value.rsrp)
        try writer["Rsrq"].write(value.rsrq)
    }
}

extension IoTWirelessClientTypes.LteLocalId {

    static func write(value: IoTWirelessClientTypes.LteLocalId?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Earfcn"].write(value.earfcn)
        try writer["Pci"].write(value.pci)
    }
}

extension IoTWirelessClientTypes.TdscdmaObj {

    static func write(value: IoTWirelessClientTypes.TdscdmaObj?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Lac"].write(value.lac)
        try writer["Mcc"].write(value.mcc)
        try writer["Mnc"].write(value.mnc)
        try writer["PathLoss"].write(value.pathLoss)
        try writer["Rscp"].write(value.rscp)
        try writer["TdscdmaLocalId"].write(value.tdscdmaLocalId, with: IoTWirelessClientTypes.TdscdmaLocalId.write(value:to:))
        try writer["TdscdmaNmr"].writeList(value.tdscdmaNmr, memberWritingClosure: IoTWirelessClientTypes.TdscdmaNmrObj.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TdscdmaTimingAdvance"].write(value.tdscdmaTimingAdvance)
        try writer["UtranCid"].write(value.utranCid)
    }
}

extension IoTWirelessClientTypes.TdscdmaNmrObj {

    static func write(value: IoTWirelessClientTypes.TdscdmaNmrObj?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CellParams"].write(value.cellParams)
        try writer["PathLoss"].write(value.pathLoss)
        try writer["Rscp"].write(value.rscp)
        try writer["Uarfcn"].write(value.uarfcn)
        try writer["UtranCid"].write(value.utranCid)
    }
}

extension IoTWirelessClientTypes.TdscdmaLocalId {

    static func write(value: IoTWirelessClientTypes.TdscdmaLocalId?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CellParams"].write(value.cellParams)
        try writer["Uarfcn"].write(value.uarfcn)
    }
}

extension IoTWirelessClientTypes.WcdmaObj {

    static func write(value: IoTWirelessClientTypes.WcdmaObj?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Lac"].write(value.lac)
        try writer["Mcc"].write(value.mcc)
        try writer["Mnc"].write(value.mnc)
        try writer["PathLoss"].write(value.pathLoss)
        try writer["Rscp"].write(value.rscp)
        try writer["UtranCid"].write(value.utranCid)
        try writer["WcdmaLocalId"].write(value.wcdmaLocalId, with: IoTWirelessClientTypes.WcdmaLocalId.write(value:to:))
        try writer["WcdmaNmr"].writeList(value.wcdmaNmr, memberWritingClosure: IoTWirelessClientTypes.WcdmaNmrObj.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension IoTWirelessClientTypes.WcdmaNmrObj {

    static func write(value: IoTWirelessClientTypes.WcdmaNmrObj?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PathLoss"].write(value.pathLoss)
        try writer["Psc"].write(value.psc)
        try writer["Rscp"].write(value.rscp)
        try writer["Uarfcndl"].write(value.uarfcndl)
        try writer["UtranCid"].write(value.utranCid)
    }
}

extension IoTWirelessClientTypes.WcdmaLocalId {

    static func write(value: IoTWirelessClientTypes.WcdmaLocalId?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Psc"].write(value.psc)
        try writer["Uarfcndl"].write(value.uarfcndl)
    }
}

extension IoTWirelessClientTypes.GsmObj {

    static func write(value: IoTWirelessClientTypes.GsmObj?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GeranCid"].write(value.geranCid)
        try writer["GsmLocalId"].write(value.gsmLocalId, with: IoTWirelessClientTypes.GsmLocalId.write(value:to:))
        try writer["GsmNmr"].writeList(value.gsmNmr, memberWritingClosure: IoTWirelessClientTypes.GsmNmrObj.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GsmTimingAdvance"].write(value.gsmTimingAdvance)
        try writer["Lac"].write(value.lac)
        try writer["Mcc"].write(value.mcc)
        try writer["Mnc"].write(value.mnc)
        try writer["RxLevel"].write(value.rxLevel)
    }
}

extension IoTWirelessClientTypes.GsmNmrObj {

    static func write(value: IoTWirelessClientTypes.GsmNmrObj?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bcch"].write(value.bcch)
        try writer["Bsic"].write(value.bsic)
        try writer["GlobalIdentity"].write(value.globalIdentity, with: IoTWirelessClientTypes.GlobalIdentity.write(value:to:))
        try writer["RxLevel"].write(value.rxLevel)
    }
}

extension IoTWirelessClientTypes.GlobalIdentity {

    static func write(value: IoTWirelessClientTypes.GlobalIdentity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GeranCid"].write(value.geranCid)
        try writer["Lac"].write(value.lac)
    }
}

extension IoTWirelessClientTypes.GsmLocalId {

    static func write(value: IoTWirelessClientTypes.GsmLocalId?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bcch"].write(value.bcch)
        try writer["Bsic"].write(value.bsic)
    }
}

extension IoTWirelessClientTypes.Ip {

    static func write(value: IoTWirelessClientTypes.Ip?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IpAddress"].write(value.ipAddress)
    }
}

extension IoTWirelessClientTypes.Gnss {

    static func write(value: IoTWirelessClientTypes.Gnss?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssistAltitude"].write(value.assistAltitude)
        try writer["AssistPosition"].writeList(value.assistPosition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeFloat(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CaptureTime"].write(value.captureTime)
        try writer["CaptureTimeAccuracy"].write(value.captureTimeAccuracy)
        try writer["Payload"].write(value.payload)
        try writer["Use2DSolver"].write(value.use2DSolver)
    }
}

extension IoTWirelessClientTypes.PositionSolverConfigurations {

    static func write(value: IoTWirelessClientTypes.PositionSolverConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SemtechGnss"].write(value.semtechGnss, with: IoTWirelessClientTypes.SemtechGnssConfiguration.write(value:to:))
    }
}

extension IoTWirelessClientTypes.SemtechGnssConfiguration {

    static func write(value: IoTWirelessClientTypes.SemtechGnssConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Fec"].write(value.fec)
        try writer["Status"].write(value.status)
    }
}

extension IoTWirelessClientTypes.MulticastWirelessMetadata {

    static func write(value: IoTWirelessClientTypes.MulticastWirelessMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANMulticastMetadata.write(value:to:))
    }
}

extension IoTWirelessClientTypes.LoRaWANMulticastMetadata {

    static func write(value: IoTWirelessClientTypes.LoRaWANMulticastMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FPort"].write(value.fPort)
    }
}

extension IoTWirelessClientTypes.WirelessMetadata {

    static func write(value: IoTWirelessClientTypes.WirelessMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LoRaWAN"].write(value.loRaWAN, with: IoTWirelessClientTypes.LoRaWANSendDataToDevice.write(value:to:))
        try writer["Sidewalk"].write(value.sidewalk, with: IoTWirelessClientTypes.SidewalkSendDataToDevice.write(value:to:))
    }
}

extension IoTWirelessClientTypes.SidewalkSendDataToDevice {

    static func write(value: IoTWirelessClientTypes.SidewalkSendDataToDevice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AckModeRetryDurationSecs"].write(value.ackModeRetryDurationSecs)
        try writer["MessageType"].write(value.messageType)
        try writer["Seq"].write(value.seq)
    }
}

extension IoTWirelessClientTypes.LoRaWANStartFuotaTask {

    static func write(value: IoTWirelessClientTypes.LoRaWANStartFuotaTask?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.dateTime)
    }
}

extension IoTWirelessClientTypes.SidewalkSingleStartImportInfo {

    static func write(value: IoTWirelessClientTypes.SidewalkSingleStartImportInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SidewalkManufacturingSn"].write(value.sidewalkManufacturingSn)
    }
}

extension IoTWirelessClientTypes.SidewalkStartImportInfo {

    static func write(value: IoTWirelessClientTypes.SidewalkStartImportInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceCreationFile"].write(value.deviceCreationFile)
        try writer["Role"].write(value.role)
    }
}

extension IoTWirelessClientTypes.SidewalkUpdateAccount {

    static func write(value: IoTWirelessClientTypes.SidewalkUpdateAccount?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppServerPrivateKey"].write(value.appServerPrivateKey)
    }
}

extension IoTWirelessClientTypes.LoRaWANUpdateDevice {

    static func write(value: IoTWirelessClientTypes.LoRaWANUpdateDevice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AbpV1_0_x"].write(value.abpV1_0_x, with: IoTWirelessClientTypes.UpdateAbpV1_0_x.write(value:to:))
        try writer["AbpV1_1"].write(value.abpV1_1, with: IoTWirelessClientTypes.UpdateAbpV1_1.write(value:to:))
        try writer["DeviceProfileId"].write(value.deviceProfileId)
        try writer["FPorts"].write(value.fPorts, with: IoTWirelessClientTypes.UpdateFPorts.write(value:to:))
        try writer["ServiceProfileId"].write(value.serviceProfileId)
    }
}

extension IoTWirelessClientTypes.UpdateFPorts {

    static func write(value: IoTWirelessClientTypes.UpdateFPorts?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Applications"].writeList(value.applications, memberWritingClosure: IoTWirelessClientTypes.ApplicationConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Positioning"].write(value.positioning, with: IoTWirelessClientTypes.Positioning.write(value:to:))
    }
}

extension IoTWirelessClientTypes.UpdateAbpV1_0_x {

    static func write(value: IoTWirelessClientTypes.UpdateAbpV1_0_x?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FCntStart"].write(value.fCntStart)
    }
}

extension IoTWirelessClientTypes.UpdateAbpV1_1 {

    static func write(value: IoTWirelessClientTypes.UpdateAbpV1_1?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FCntStart"].write(value.fCntStart)
    }
}

extension IoTWirelessClientTypes.SidewalkUpdateImportInfo {

    static func write(value: IoTWirelessClientTypes.SidewalkUpdateImportInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceCreationFile"].write(value.deviceCreationFile)
    }
}

public enum IoTWirelessClientTypes {}
