//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class ClientRuntime.Indirect
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

public struct AssociateLibraryItemReviewOutput {

    public init() { }
}

public struct AssociateQAppWithUserOutput {

    public init() { }
}

public struct DeleteLibraryItemOutput {

    public init() { }
}

public struct DeleteQAppOutput {

    public init() { }
}

public struct DisassociateLibraryItemReviewOutput {

    public init() { }
}

public struct DisassociateQAppFromUserOutput {

    public init() { }
}

public struct StopQAppSessionOutput {

    public init() { }
}

public struct UpdateLibraryItemMetadataOutput {

    public init() { }
}

/// The client is not authorized to perform the requested operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension QAppsClientTypes {

    public enum CardType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fileUpload
        case qPlugin
        case qQuery
        case textInput
        case sdkUnknown(Swift.String)

        public static var allCases: [CardType] {
            return [
                .fileUpload,
                .qPlugin,
                .qQuery,
                .textInput
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fileUpload: return "file-upload"
            case .qPlugin: return "q-plugin"
            case .qQuery: return "q-query"
            case .textInput: return "text-input"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {
    /// A card in an Amazon Q App that allows the user to upload a file.
    public struct FileUploadCard {
        /// A flag indicating if the user can override the default file for the upload card.
        public var allowOverride: Swift.Bool?
        /// Any dependencies or requirements for the file upload card.
        /// This member is required.
        public var dependencies: [Swift.String]?
        /// The unique identifier of the file associated with the card.
        public var fileId: Swift.String?
        /// The name of the file being uploaded.
        public var filename: Swift.String?
        /// The unique identifier of the file upload card.
        /// This member is required.
        public var id: Swift.String?
        /// The title of the file upload card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            allowOverride: Swift.Bool? = nil,
            dependencies: [Swift.String]? = nil,
            fileId: Swift.String? = nil,
            filename: Swift.String? = nil,
            id: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = nil
        )
        {
            self.allowOverride = allowOverride
            self.dependencies = dependencies
            self.fileId = fileId
            self.filename = filename
            self.id = id
            self.title = title
            self.type = type
        }
    }

}

extension QAppsClientTypes {

    public enum PluginType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case jira
        case salesforce
        case serviceNow
        case zendesk
        case sdkUnknown(Swift.String)

        public static var allCases: [PluginType] {
            return [
                .custom,
                .jira,
                .salesforce,
                .serviceNow,
                .zendesk
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .jira: return "JIRA"
            case .salesforce: return "SALESFORCE"
            case .serviceNow: return "SERVICE_NOW"
            case .zendesk: return "ZENDESK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {
    /// A card in an Q App that integrates with a third-party plugin or service.
    public struct QPluginCard {
        /// Any dependencies or requirements for the plugin card.
        /// This member is required.
        public var dependencies: [Swift.String]?
        /// The unique identifier of the plugin card.
        /// This member is required.
        public var id: Swift.String?
        /// The unique identifier of the plugin used by the card.
        /// This member is required.
        public var pluginId: Swift.String?
        /// The type or category of the plugin used by the card.
        /// This member is required.
        public var pluginType: QAppsClientTypes.PluginType?
        /// The prompt or instructions displayed for the plugin card.
        /// This member is required.
        public var prompt: Swift.String?
        /// The title or label of the plugin card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            dependencies: [Swift.String]? = nil,
            id: Swift.String? = nil,
            pluginId: Swift.String? = nil,
            pluginType: QAppsClientTypes.PluginType? = nil,
            prompt: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = nil
        )
        {
            self.dependencies = dependencies
            self.id = id
            self.pluginId = pluginId
            self.pluginType = pluginType
            self.prompt = prompt
            self.title = title
            self.type = type
        }
    }

}

extension QAppsClientTypes {
    /// The value of a document attribute. You can only provide one value for a document attribute.
    public enum DocumentAttributeValue {
        /// A string.
        case stringvalue(Swift.String)
        /// A list of strings.
        case stringlistvalue([Swift.String])
        /// A long integer value.
        case longvalue(Swift.Int)
        /// A date expressed as an ISO 8601 string. It's important for the time zone to be included in the ISO 8601 date-time format. For example, 2012-03-25T12:30:10+01:00 is the ISO 8601 date-time format for March 25th 2012 at 12:30PM (plus 10 seconds) in Central European Time.
        case datevalue(Foundation.Date)
        case sdkUnknown(Swift.String)
    }

}

extension QAppsClientTypes {
    /// A document attribute or metadata field.
    public struct DocumentAttribute {
        /// The identifier for the attribute.
        /// This member is required.
        public var name: Swift.String?
        /// The value of the attribute.
        /// This member is required.
        public var value: QAppsClientTypes.DocumentAttributeValue?

        public init(
            name: Swift.String? = nil,
            value: QAppsClientTypes.DocumentAttributeValue? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension QAppsClientTypes {

    public enum CardOutputSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approvedSources
        case llm
        case sdkUnknown(Swift.String)

        public static var allCases: [CardOutputSource] {
            return [
                .approvedSources,
                .llm
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approvedSources: return "approved-sources"
            case .llm: return "llm"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {
    /// A card in an Amazon Q App that allows the user to input text.
    public struct TextInputCard {
        /// The default value to pre-populate in the text input field.
        public var defaultValue: Swift.String?
        /// Any dependencies or requirements for the text input card.
        /// This member is required.
        public var dependencies: [Swift.String]?
        /// The unique identifier of the text input card.
        /// This member is required.
        public var id: Swift.String?
        /// The placeholder text to display in the text input field.
        public var placeholder: Swift.String?
        /// The title or label of the text input card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            defaultValue: Swift.String? = nil,
            dependencies: [Swift.String]? = nil,
            id: Swift.String? = nil,
            placeholder: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.dependencies = dependencies
            self.id = id
            self.placeholder = placeholder
            self.title = title
            self.type = type
        }
    }

}

extension QAppsClientTypes {
    /// Represents a file upload card. It can optionally receive a filename and fileId to set a default file. If not received, the user must provide the file when the Q App runs.
    public struct FileUploadCardInput {
        /// A flag indicating if the user can override the default file for the upload card.
        public var allowOverride: Swift.Bool?
        /// The identifier of a pre-uploaded file associated with the card.
        public var fileId: Swift.String?
        /// The default filename to use for the file upload card.
        public var filename: Swift.String?
        /// The unique identifier of the file upload card.
        /// This member is required.
        public var id: Swift.String?
        /// The title or label of the file upload card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            allowOverride: Swift.Bool? = nil,
            fileId: Swift.String? = nil,
            filename: Swift.String? = nil,
            id: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = .fileUpload
        )
        {
            self.allowOverride = allowOverride
            self.fileId = fileId
            self.filename = filename
            self.id = id
            self.title = title
            self.type = type
        }
    }

}

extension QAppsClientTypes {
    /// The input shape for defining a plugin card in an Amazon Q App.
    public struct QPluginCardInput {
        /// The unique identifier of the plugin card.
        /// This member is required.
        public var id: Swift.String?
        /// The unique identifier of the plugin used by the card.
        /// This member is required.
        public var pluginId: Swift.String?
        /// The prompt or instructions displayed for the plugin card.
        /// This member is required.
        public var prompt: Swift.String?
        /// The title or label of the plugin card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            id: Swift.String? = nil,
            pluginId: Swift.String? = nil,
            prompt: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = .qPlugin
        )
        {
            self.id = id
            self.pluginId = pluginId
            self.prompt = prompt
            self.title = title
            self.type = type
        }
    }

}

extension QAppsClientTypes {
    /// The input shape for defining a text input card in an Amazon Q App.
    public struct TextInputCardInput {
        /// The default value to pre-populate in the text input field.
        public var defaultValue: Swift.String?
        /// The unique identifier of the text input card.
        /// This member is required.
        public var id: Swift.String?
        /// The placeholder text to display in the text input field.
        public var placeholder: Swift.String?
        /// The title or label of the text input card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            defaultValue: Swift.String? = nil,
            id: Swift.String? = nil,
            placeholder: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = .textInput
        )
        {
            self.defaultValue = defaultValue
            self.id = id
            self.placeholder = placeholder
            self.title = title
            self.type = type
        }
    }

}

extension QAppsClientTypes {

    public enum AppRequiredCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creatorMode
        case fileUpload
        case pluginMode
        case retrievalMode
        case sdkUnknown(Swift.String)

        public static var allCases: [AppRequiredCapability] {
            return [
                .creatorMode,
                .fileUpload,
                .pluginMode,
                .retrievalMode
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creatorMode: return "CreatorMode"
            case .fileUpload: return "FileUpload"
            case .pluginMode: return "PluginMode"
            case .retrievalMode: return "RetrievalMode"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {

    public enum AppStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case draft
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [AppStatus] {
            return [
                .deleted,
                .draft,
                .published
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The requested operation could not be completed due to a conflict with the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier of the resource
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// An internal service error occurred while processing the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the operation
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The requested resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier of the resource
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The requested operation could not be completed because it would exceed the service's quota or limit.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code of the quota that was exceeded
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The unique identifier of the resource
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code for the service where the quota was exceeded
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The requested operation could not be completed because too many requests were sent at once. Wait a bit and try again later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code of the quota that was exceeded
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying the operation
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The code for the service where the quota was exceeded
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

/// The client is not authenticated or authorized to perform the requested operation.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input failed to satisfy the constraints specified by the service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateLibraryItemReviewInput {
    /// The unique identifier for the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the library item to associate the review with.
    /// This member is required.
    public var libraryItemId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        libraryItemId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.libraryItemId = libraryItemId
    }
}

public struct AssociateQAppWithUserInput {
    /// The ID of the Amazon Q App to associate with the user.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.instanceId = instanceId
    }
}

extension QAppsClientTypes {

    public enum ExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case inProgress
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .completed,
                .inProgress,
                .waiting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case .waiting: return "WAITING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {
    /// The current status and value of a card in an active Amazon Q App session.
    public struct CardStatus {
        /// The current state of the card.
        /// This member is required.
        public var currentState: QAppsClientTypes.ExecutionStatus?
        /// The current value or result associated with the card.
        /// This member is required.
        public var currentValue: Swift.String?

        public init(
            currentState: QAppsClientTypes.ExecutionStatus? = nil,
            currentValue: Swift.String? = nil
        )
        {
            self.currentState = currentState
            self.currentValue = currentValue
        }
    }

}

extension QAppsClientTypes {
    /// The value or result associated with a card in a Amazon Q App session.
    public struct CardValue {
        /// The unique identifier of the card.
        /// This member is required.
        public var cardId: Swift.String?
        /// The value or result associated with the card.
        /// This member is required.
        public var value: Swift.String?

        public init(
            cardId: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.cardId = cardId
            self.value = value
        }
    }

}

extension QAppsClientTypes {
    /// A category used to classify and filter library items for Amazon Q Apps.
    public struct Category {
        /// The unique identifier of the category.
        /// This member is required.
        public var id: Swift.String?
        /// The title or name of the category.
        /// This member is required.
        public var title: Swift.String?

        public init(
            id: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.id = id
            self.title = title
        }
    }

}

/// The requested operation could not be completed because the content exceeds the maximum allowed size.
public struct ContentTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier of the resource
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContentTooLargeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension QAppsClientTypes {

    public enum Sender: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case system
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [Sender] {
            return [
                .system,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .system: return "SYSTEM"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {
    /// A message in a conversation, used as input for generating an Amazon Q App definition.
    public struct ConversationMessage {
        /// The text content of the conversation message.
        /// This member is required.
        public var body: Swift.String?
        /// The type of the conversation message.
        /// This member is required.
        public var type: QAppsClientTypes.Sender?

        public init(
            body: Swift.String? = nil,
            type: QAppsClientTypes.Sender? = nil
        )
        {
            self.body = body
            self.type = type
        }
    }

}

public struct CreateLibraryItemInput {
    /// The unique identifier of the Amazon Q App to publish to the library.
    /// This member is required.
    public var appId: Swift.String?
    /// The version of the Amazon Q App to publish to the library.
    /// This member is required.
    public var appVersion: Swift.Int?
    /// The categories to associate with the library item for easier discovery.
    /// This member is required.
    public var categories: [Swift.String]?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        categories: [Swift.String]? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.appVersion = appVersion
        self.categories = categories
        self.instanceId = instanceId
    }
}

public struct CreateLibraryItemOutput {
    /// The date and time the library item was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user who created the library item.
    /// This member is required.
    public var createdBy: Swift.String?
    /// Indicates whether the library item has been verified.
    public var isVerified: Swift.Bool?
    /// The unique identifier of the new library item.
    /// This member is required.
    public var libraryItemId: Swift.String?
    /// The number of ratings the library item has received from users.
    /// This member is required.
    public var ratingCount: Swift.Int?
    /// The status of the new library item, such as "Published".
    /// This member is required.
    public var status: Swift.String?
    /// The date and time the library item was last updated.
    public var updatedAt: Foundation.Date?
    /// The user who last updated the library item.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        isVerified: Swift.Bool? = nil,
        libraryItemId: Swift.String? = nil,
        ratingCount: Swift.Int? = nil,
        status: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.isVerified = isVerified
        self.libraryItemId = libraryItemId
        self.ratingCount = ratingCount
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

public struct CreateQAppOutput {
    /// The Amazon Resource Name (ARN) of the new Q App.
    /// This member is required.
    public var appArn: Swift.String?
    /// The unique identifier of the new Q App.
    /// This member is required.
    public var appId: Swift.String?
    /// The version of the new Q App.
    /// This member is required.
    public var appVersion: Swift.Int?
    /// The date and time the Q App was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user who created the Q App.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the new Q App.
    public var description: Swift.String?
    /// The initial prompt displayed when the Q App is started.
    public var initialPrompt: Swift.String?
    /// The capabilities required to run the Q App, such as file upload or third-party integrations.
    public var requiredCapabilities: [QAppsClientTypes.AppRequiredCapability]?
    /// The status of the new Q App, such as "Created".
    /// This member is required.
    public var status: QAppsClientTypes.AppStatus?
    /// The title of the new Q App.
    /// This member is required.
    public var title: Swift.String?
    /// The date and time the Q App was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The user who last updated the Q App.
    /// This member is required.
    public var updatedBy: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        initialPrompt: Swift.String? = nil,
        requiredCapabilities: [QAppsClientTypes.AppRequiredCapability]? = nil,
        status: QAppsClientTypes.AppStatus? = nil,
        title: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appId = appId
        self.appVersion = appVersion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.initialPrompt = initialPrompt
        self.requiredCapabilities = requiredCapabilities
        self.status = status
        self.title = title
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

public struct DeleteLibraryItemInput {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the library item to delete.
    /// This member is required.
    public var libraryItemId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        libraryItemId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.libraryItemId = libraryItemId
    }
}

public struct DeleteQAppInput {
    /// The unique identifier of the Q App to delete.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.instanceId = instanceId
    }
}

public struct DisassociateLibraryItemReviewInput {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the library item to remove the review from.
    /// This member is required.
    public var libraryItemId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        libraryItemId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.libraryItemId = libraryItemId
    }
}

public struct DisassociateQAppFromUserInput {
    /// The unique identifier of the Q App to disassociate from the user.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.instanceId = instanceId
    }
}

extension QAppsClientTypes {

    public enum DocumentScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case application
        case session
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentScope] {
            return [
                .application,
                .session
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .session: return "SESSION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetLibraryItemInput {
    /// The unique identifier of the Amazon Q App associated with the library item.
    public var appId: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the library item to retrieve.
    /// This member is required.
    public var libraryItemId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        libraryItemId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.instanceId = instanceId
        self.libraryItemId = libraryItemId
    }
}

public struct GetLibraryItemOutput {
    /// The unique identifier of the Q App associated with the library item.
    /// This member is required.
    public var appId: Swift.String?
    /// The version of the Q App associated with the library item.
    /// This member is required.
    public var appVersion: Swift.Int?
    /// The categories associated with the library item for discovery.
    /// This member is required.
    public var categories: [QAppsClientTypes.Category]?
    /// The date and time the library item was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user who created the library item.
    /// This member is required.
    public var createdBy: Swift.String?
    /// Whether the current user has rated the library item.
    public var isRatedByUser: Swift.Bool?
    /// Indicates whether the library item has been verified.
    public var isVerified: Swift.Bool?
    /// The unique identifier of the library item.
    /// This member is required.
    public var libraryItemId: Swift.String?
    /// The number of ratings the library item has received from users.
    /// This member is required.
    public var ratingCount: Swift.Int?
    /// The status of the library item, such as "Published".
    /// This member is required.
    public var status: Swift.String?
    /// The date and time the library item was last updated.
    public var updatedAt: Foundation.Date?
    /// The user who last updated the library item.
    public var updatedBy: Swift.String?
    /// The number of users who have associated the Q App with their account.
    public var userCount: Swift.Int?

    public init(
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        categories: [QAppsClientTypes.Category]? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        isRatedByUser: Swift.Bool? = nil,
        isVerified: Swift.Bool? = nil,
        libraryItemId: Swift.String? = nil,
        ratingCount: Swift.Int? = nil,
        status: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil,
        userCount: Swift.Int? = nil
    )
    {
        self.appId = appId
        self.appVersion = appVersion
        self.categories = categories
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.isRatedByUser = isRatedByUser
        self.isVerified = isVerified
        self.libraryItemId = libraryItemId
        self.ratingCount = ratingCount
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.userCount = userCount
    }
}

public struct GetQAppInput {
    /// The unique identifier of the Q App to retrieve.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.instanceId = instanceId
    }
}

public struct GetQAppSessionInput {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the Q App session to retrieve.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.sessionId = sessionId
    }
}

public struct GetQAppSessionOutput {
    /// The current status for each card in the Q App session.
    /// This member is required.
    public var cardStatus: [Swift.String: QAppsClientTypes.CardStatus]?
    /// The Amazon Resource Name (ARN) of the Q App session.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// The unique identifier of the Q App session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The current status of the Q App session.
    /// This member is required.
    public var status: QAppsClientTypes.ExecutionStatus?

    public init(
        cardStatus: [Swift.String: QAppsClientTypes.CardStatus]? = nil,
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        status: QAppsClientTypes.ExecutionStatus? = nil
    )
    {
        self.cardStatus = cardStatus
        self.sessionArn = sessionArn
        self.sessionId = sessionId
        self.status = status
    }
}

public struct ImportDocumentInput {
    /// The unique identifier of the Q App the file is associated with.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique identifier of the card the file is associated with, if applicable.
    /// This member is required.
    public var cardId: Swift.String?
    /// The base64-encoded contents of the file to upload.
    /// This member is required.
    public var fileContentsBase64: Swift.String?
    /// The name of the file being uploaded.
    /// This member is required.
    public var fileName: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Whether the file is associated with an Q App definition or a specific Q App session.
    /// This member is required.
    public var scope: QAppsClientTypes.DocumentScope?
    /// The unique identifier of the Q App session the file is associated with, if applicable.
    public var sessionId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        cardId: Swift.String? = nil,
        fileContentsBase64: Swift.String? = nil,
        fileName: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        scope: QAppsClientTypes.DocumentScope? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.cardId = cardId
        self.fileContentsBase64 = fileContentsBase64
        self.fileName = fileName
        self.instanceId = instanceId
        self.scope = scope
        self.sessionId = sessionId
    }
}

public struct ImportDocumentOutput {
    /// The unique identifier assigned to the uploaded file.
    public var fileId: Swift.String?

    public init(
        fileId: Swift.String? = nil
    )
    {
        self.fileId = fileId
    }
}

extension QAppsClientTypes {
    /// A library item is a snapshot of an Amazon Q App that can be published so the users in their Amazon Q Apps library can discover it, clone it, and run it.
    public struct LibraryItemMember {
        /// The unique identifier of the Q App associated with the library item.
        /// This member is required.
        public var appId: Swift.String?
        /// The version of the Q App associated with the library item.
        /// This member is required.
        public var appVersion: Swift.Int?
        /// The categories associated with the library item.
        /// This member is required.
        public var categories: [QAppsClientTypes.Category]?
        /// The date and time the library item was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The user who created the library item.
        /// This member is required.
        public var createdBy: Swift.String?
        /// Whether the current user has rated the library item.
        public var isRatedByUser: Swift.Bool?
        /// Indicates whether the library item has been verified.
        public var isVerified: Swift.Bool?
        /// The unique identifier of the library item.
        /// This member is required.
        public var libraryItemId: Swift.String?
        /// The number of ratings the library item has received.
        /// This member is required.
        public var ratingCount: Swift.Int?
        /// The status of the library item.
        /// This member is required.
        public var status: Swift.String?
        /// The date and time the library item was last updated.
        public var updatedAt: Foundation.Date?
        /// The user who last updated the library item.
        public var updatedBy: Swift.String?
        /// The number of users who have the associated Q App.
        public var userCount: Swift.Int?

        public init(
            appId: Swift.String? = nil,
            appVersion: Swift.Int? = nil,
            categories: [QAppsClientTypes.Category]? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            isRatedByUser: Swift.Bool? = nil,
            isVerified: Swift.Bool? = nil,
            libraryItemId: Swift.String? = nil,
            ratingCount: Swift.Int? = nil,
            status: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil,
            userCount: Swift.Int? = nil
        )
        {
            self.appId = appId
            self.appVersion = appVersion
            self.categories = categories
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.isRatedByUser = isRatedByUser
            self.isVerified = isVerified
            self.libraryItemId = libraryItemId
            self.ratingCount = ratingCount
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.userCount = userCount
        }
    }

}

extension QAppsClientTypes {

    public enum LibraryItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [LibraryItemStatus] {
            return [
                .disabled,
                .published
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListLibraryItemsInput {
    /// Optional category to filter the library items by.
    public var categoryId: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of library items to return in the response.
    public var limit: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        categoryId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.categoryId = categoryId
        self.instanceId = instanceId
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct ListLibraryItemsOutput {
    /// The list of library items meeting the request criteria.
    public var libraryItems: [QAppsClientTypes.LibraryItemMember]?
    /// The token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        libraryItems: [QAppsClientTypes.LibraryItemMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.libraryItems = libraryItems
        self.nextToken = nextToken
    }
}

public struct ListQAppsInput {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of Q Apps to return in the response.
    public var limit: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.limit = limit
        self.nextToken = nextToken
    }
}

extension QAppsClientTypes {
    /// An Amazon Q App associated with a user, either owned by the user or favorited.
    public struct UserAppItem {
        /// The Amazon Resource Name (ARN) of the Q App.
        /// This member is required.
        public var appArn: Swift.String?
        /// The unique identifier of the Q App.
        /// This member is required.
        public var appId: Swift.String?
        /// A flag indicating whether the user can edit the Q App.
        public var canEdit: Swift.Bool?
        /// The date and time the user's association with the Q App was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the Q App.
        public var description: Swift.String?
        /// Indicates whether the Q App has been verified.
        public var isVerified: Swift.Bool
        /// The status of the user's association with the Q App.
        public var status: Swift.String?
        /// The title of the Q App.
        /// This member is required.
        public var title: Swift.String?

        public init(
            appArn: Swift.String? = nil,
            appId: Swift.String? = nil,
            canEdit: Swift.Bool? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            isVerified: Swift.Bool = false,
            status: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.appArn = appArn
            self.appId = appId
            self.canEdit = canEdit
            self.createdAt = createdAt
            self.description = description
            self.isVerified = isVerified
            self.status = status
            self.title = title
        }
    }

}

public struct ListQAppsOutput {
    /// The list of Amazon Q Apps meeting the request criteria.
    /// This member is required.
    public var apps: [QAppsClientTypes.UserAppItem]?
    /// The token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        apps: [QAppsClientTypes.UserAppItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apps = apps
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource whose tags should be listed.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput {
    /// The list of tags that are assigned to the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension QAppsClientTypes {
    /// The input options for generating an Q App definition.
    public enum PredictQAppInputOptions {
        /// A conversation to use as input for generating the Q App definition.
        case conversation([QAppsClientTypes.ConversationMessage])
        /// A problem statement to use as input for generating the Q App definition.
        case problemstatement(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

public struct PredictQAppInput {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The input to generate the Q App definition from, either a conversation or problem statement.
    public var options: QAppsClientTypes.PredictQAppInputOptions?

    public init(
        instanceId: Swift.String? = nil,
        options: QAppsClientTypes.PredictQAppInputOptions? = nil
    )
    {
        self.instanceId = instanceId
        self.options = options
    }
}

public struct StartQAppSessionInput {
    /// The unique identifier of the Q App to start a session for.
    /// This member is required.
    public var appId: Swift.String?
    /// The version of the Q App to use for the session.
    /// This member is required.
    public var appVersion: Swift.Int?
    /// Optional initial input values to provide for the Q App session.
    public var initialValues: [QAppsClientTypes.CardValue]?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Optional tags to associate with the new Q App session.
    public var tags: [Swift.String: Swift.String]?

    public init(
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        initialValues: [QAppsClientTypes.CardValue]? = nil,
        instanceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.appId = appId
        self.appVersion = appVersion
        self.initialValues = initialValues
        self.instanceId = instanceId
        self.tags = tags
    }
}

public struct StartQAppSessionOutput {
    /// The Amazon Resource Name (ARN) of the new Q App session.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// The unique identifier of the new Q App session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.sessionArn = sessionArn
        self.sessionId = sessionId
    }
}

public struct StopQAppSessionInput {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the Q App session to stop.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.sessionId = sessionId
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags to associate with the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to disassociate the tag from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys of the tags to disassociate from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateLibraryItemInput {
    /// The new categories to associate with the library item.
    public var categories: [Swift.String]?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the library item to update.
    /// This member is required.
    public var libraryItemId: Swift.String?
    /// The new status to set for the library item, such as "Published" or "Hidden".
    public var status: QAppsClientTypes.LibraryItemStatus?

    public init(
        categories: [Swift.String]? = nil,
        instanceId: Swift.String? = nil,
        libraryItemId: Swift.String? = nil,
        status: QAppsClientTypes.LibraryItemStatus? = nil
    )
    {
        self.categories = categories
        self.instanceId = instanceId
        self.libraryItemId = libraryItemId
        self.status = status
    }
}

public struct UpdateLibraryItemOutput {
    /// The unique identifier of the Q App associated with the library item.
    /// This member is required.
    public var appId: Swift.String?
    /// The version of the Q App associated with the library item.
    /// This member is required.
    public var appVersion: Swift.Int?
    /// The categories associated with the updated library item.
    /// This member is required.
    public var categories: [QAppsClientTypes.Category]?
    /// The date and time the library item was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user who originally created the library item.
    /// This member is required.
    public var createdBy: Swift.String?
    /// Whether the current user has rated the library item.
    public var isRatedByUser: Swift.Bool?
    /// Indicates whether the library item has been verified.
    public var isVerified: Swift.Bool?
    /// The unique identifier of the updated library item.
    /// This member is required.
    public var libraryItemId: Swift.String?
    /// The number of ratings the library item has received.
    /// This member is required.
    public var ratingCount: Swift.Int?
    /// The new status of the updated library item.
    /// This member is required.
    public var status: Swift.String?
    /// The date and time the library item was last updated.
    public var updatedAt: Foundation.Date?
    /// The user who last updated the library item.
    public var updatedBy: Swift.String?
    /// The number of users who have the associated Q App.
    public var userCount: Swift.Int?

    public init(
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        categories: [QAppsClientTypes.Category]? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        isRatedByUser: Swift.Bool? = nil,
        isVerified: Swift.Bool? = nil,
        libraryItemId: Swift.String? = nil,
        ratingCount: Swift.Int? = nil,
        status: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil,
        userCount: Swift.Int? = nil
    )
    {
        self.appId = appId
        self.appVersion = appVersion
        self.categories = categories
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.isRatedByUser = isRatedByUser
        self.isVerified = isVerified
        self.libraryItemId = libraryItemId
        self.ratingCount = ratingCount
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.userCount = userCount
    }
}

public struct UpdateLibraryItemMetadataInput {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The verification status of the library item
    public var isVerified: Swift.Bool?
    /// The unique identifier of the updated library item.
    /// This member is required.
    public var libraryItemId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        isVerified: Swift.Bool? = nil,
        libraryItemId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.isVerified = isVerified
        self.libraryItemId = libraryItemId
    }
}

public struct UpdateQAppOutput {
    /// The Amazon Resource Name (ARN) of the updated Q App.
    /// This member is required.
    public var appArn: Swift.String?
    /// The unique identifier of the updated Q App.
    /// This member is required.
    public var appId: Swift.String?
    /// The new version of the updated Q App.
    /// This member is required.
    public var appVersion: Swift.Int?
    /// The date and time the Q App was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user who originally created the Q App.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The new description of the updated Q App.
    public var description: Swift.String?
    /// The initial prompt for the updated Q App.
    public var initialPrompt: Swift.String?
    /// The capabilities required for the updated Q App.
    public var requiredCapabilities: [QAppsClientTypes.AppRequiredCapability]?
    /// The status of the updated Q App.
    /// This member is required.
    public var status: QAppsClientTypes.AppStatus?
    /// The new title of the updated Q App.
    /// This member is required.
    public var title: Swift.String?
    /// The date and time the Q App was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The user who last updated the Q App.
    /// This member is required.
    public var updatedBy: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        initialPrompt: Swift.String? = nil,
        requiredCapabilities: [QAppsClientTypes.AppRequiredCapability]? = nil,
        status: QAppsClientTypes.AppStatus? = nil,
        title: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appId = appId
        self.appVersion = appVersion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.initialPrompt = initialPrompt
        self.requiredCapabilities = requiredCapabilities
        self.status = status
        self.title = title
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

public struct UpdateQAppSessionInput {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the Q App session to provide input for.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The input values to provide for the current state of the Q App session.
    public var values: [QAppsClientTypes.CardValue]?

    public init(
        instanceId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        values: [QAppsClientTypes.CardValue]? = nil
    )
    {
        self.instanceId = instanceId
        self.sessionId = sessionId
        self.values = values
    }
}

public struct UpdateQAppSessionOutput {
    /// The Amazon Resource Name (ARN) of the updated Q App session.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// The unique identifier of the updated Q App session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.sessionArn = sessionArn
        self.sessionId = sessionId
    }
}

extension QAppsClientTypes {
    /// The filter criteria used on responses based on document attributes or metadata fields.
    public struct AttributeFilter {
        /// Performs a logical AND operation on all supplied filters.
        public var andAllFilters: [QAppsClientTypes.AttributeFilter]?
        /// Returns true when a document contains all the specified document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): stringListValue.
        public var containsAll: QAppsClientTypes.DocumentAttribute?
        /// Returns true when a document contains any of the specified document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): stringListValue.
        public var containsAny: QAppsClientTypes.DocumentAttribute?
        /// Performs an equals operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue, longValue, stringListValue and stringValue.
        public var equalsTo: QAppsClientTypes.DocumentAttribute?
        /// Performs a greater than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue and longValue.
        public var greaterThan: QAppsClientTypes.DocumentAttribute?
        /// Performs a greater than or equals operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue and longValue.
        public var greaterThanOrEquals: QAppsClientTypes.DocumentAttribute?
        /// Performs a less than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue and longValue.
        public var lessThan: QAppsClientTypes.DocumentAttribute?
        /// Performs a less than or equals operation on two document attributes or metadata fields.Supported for the following [document attribute value type](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue and longValue.
        public var lessThanOrEquals: QAppsClientTypes.DocumentAttribute?
        /// Performs a logical NOT operation on all supplied filters.
        @Indirect public var notFilter: QAppsClientTypes.AttributeFilter?
        /// Performs a logical OR operation on all supplied filters.
        public var orAllFilters: [QAppsClientTypes.AttributeFilter]?

        public init(
            andAllFilters: [QAppsClientTypes.AttributeFilter]? = nil,
            containsAll: QAppsClientTypes.DocumentAttribute? = nil,
            containsAny: QAppsClientTypes.DocumentAttribute? = nil,
            equalsTo: QAppsClientTypes.DocumentAttribute? = nil,
            greaterThan: QAppsClientTypes.DocumentAttribute? = nil,
            greaterThanOrEquals: QAppsClientTypes.DocumentAttribute? = nil,
            lessThan: QAppsClientTypes.DocumentAttribute? = nil,
            lessThanOrEquals: QAppsClientTypes.DocumentAttribute? = nil,
            notFilter: QAppsClientTypes.AttributeFilter? = nil,
            orAllFilters: [QAppsClientTypes.AttributeFilter]? = nil
        )
        {
            self.andAllFilters = andAllFilters
            self.containsAll = containsAll
            self.containsAny = containsAny
            self.equalsTo = equalsTo
            self.greaterThan = greaterThan
            self.greaterThanOrEquals = greaterThanOrEquals
            self.lessThan = lessThan
            self.lessThanOrEquals = lessThanOrEquals
            self.notFilter = notFilter
            self.orAllFilters = orAllFilters
        }
    }

}

extension QAppsClientTypes {
    /// A card in a Amazon Q App that generates a response based on the Amazon Q Business service.
    public struct QQueryCard {
        /// The Amazon Q Business filters applied in this query card when resolving data sources
        public var attributeFilter: QAppsClientTypes.AttributeFilter?
        /// Any dependencies or requirements for the query card.
        /// This member is required.
        public var dependencies: [Swift.String]?
        /// The unique identifier of the query card.
        /// This member is required.
        public var id: Swift.String?
        /// The source or type of output generated by the query card.
        /// This member is required.
        public var outputSource: QAppsClientTypes.CardOutputSource?
        /// The prompt or instructions displayed for the query card.
        /// This member is required.
        public var prompt: Swift.String?
        /// The title or label of the query card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            attributeFilter: QAppsClientTypes.AttributeFilter? = nil,
            dependencies: [Swift.String]? = nil,
            id: Swift.String? = nil,
            outputSource: QAppsClientTypes.CardOutputSource? = nil,
            prompt: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = nil
        )
        {
            self.attributeFilter = attributeFilter
            self.dependencies = dependencies
            self.id = id
            self.outputSource = outputSource
            self.prompt = prompt
            self.title = title
            self.type = type
        }
    }

}

extension QAppsClientTypes {
    /// The input shape for defining a query card in an Amazon Q App.
    public struct QQueryCardInput {
        /// Turns on filtering of responses based on document attributes or metadata fields.
        public var attributeFilter: QAppsClientTypes.AttributeFilter?
        /// The unique identifier of the query card.
        /// This member is required.
        public var id: Swift.String?
        /// The source or type of output to generate for the query card.
        public var outputSource: QAppsClientTypes.CardOutputSource?
        /// The prompt or instructions displayed for the query card.
        /// This member is required.
        public var prompt: Swift.String?
        /// The title or label of the query card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            attributeFilter: QAppsClientTypes.AttributeFilter? = nil,
            id: Swift.String? = nil,
            outputSource: QAppsClientTypes.CardOutputSource? = .approvedSources,
            prompt: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = .qQuery
        )
        {
            self.attributeFilter = attributeFilter
            self.id = id
            self.outputSource = outputSource
            self.prompt = prompt
            self.title = title
            self.type = type
        }
    }

}

extension QAppsClientTypes {
    /// A card representing a component or step in an Amazon Q App's flow.
    public indirect enum Card {
        /// A container for the properties of the text input card.
        case textinput(QAppsClientTypes.TextInputCard)
        /// A container for the properties of the query card.
        case qquery(QAppsClientTypes.QQueryCard)
        /// A container for the properties of the plugin card.
        case qplugin(QAppsClientTypes.QPluginCard)
        /// A container for the properties of the file upload card.
        case fileupload(QAppsClientTypes.FileUploadCard)
        case sdkUnknown(Swift.String)
    }

}

extension QAppsClientTypes {
    /// The properties defining an input card in an Amazon Q App.
    public indirect enum CardInput {
        /// A container for the properties of the text input card.
        case textinput(QAppsClientTypes.TextInputCardInput)
        /// A container for the properties of the query input card.
        case qquery(QAppsClientTypes.QQueryCardInput)
        /// A container for the properties of the plugin input card.
        case qplugin(QAppsClientTypes.QPluginCardInput)
        /// A container for the properties of the file upload input card.
        case fileupload(QAppsClientTypes.FileUploadCardInput)
        case sdkUnknown(Swift.String)
    }

}

extension QAppsClientTypes {
    /// The definition of the Q App, specifying the cards and flow.
    public struct AppDefinition {
        /// The version of the app definition schema or specification.
        /// This member is required.
        public var appDefinitionVersion: Swift.String?
        /// A flag indicating whether the Q App's definition can be edited by the user.
        public var canEdit: Swift.Bool?
        /// The cards that make up the Q App, such as text input, file upload, or query cards.
        /// This member is required.
        public var cards: [QAppsClientTypes.Card]?

        public init(
            appDefinitionVersion: Swift.String? = nil,
            canEdit: Swift.Bool? = nil,
            cards: [QAppsClientTypes.Card]? = nil
        )
        {
            self.appDefinitionVersion = appDefinitionVersion
            self.canEdit = canEdit
            self.cards = cards
        }
    }

}

extension QAppsClientTypes {
    /// The input for defining an Q App.
    public struct AppDefinitionInput {
        /// The cards that make up the Q App definition.
        /// This member is required.
        public var cards: [QAppsClientTypes.CardInput]?
        /// The initial prompt displayed when the Q App is started.
        public var initialPrompt: Swift.String?

        public init(
            cards: [QAppsClientTypes.CardInput]? = nil,
            initialPrompt: Swift.String? = nil
        )
        {
            self.cards = cards
            self.initialPrompt = initialPrompt
        }
    }

}

extension QAppsClientTypes {
    /// The definition of an Amazon Q App generated based on input such as a conversation or problem statement.
    public struct PredictAppDefinition {
        /// The definition specifying the cards and flow of the generated Q App.
        /// This member is required.
        public var appDefinition: QAppsClientTypes.AppDefinitionInput?
        /// The description of the generated Q App definition.
        public var description: Swift.String?
        /// The title of the generated Q App definition.
        /// This member is required.
        public var title: Swift.String?

        public init(
            appDefinition: QAppsClientTypes.AppDefinitionInput? = nil,
            description: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.appDefinition = appDefinition
            self.description = description
            self.title = title
        }
    }

}

public struct CreateQAppInput {
    /// The definition of the new Q App, specifying the cards and flow.
    /// This member is required.
    public var appDefinition: QAppsClientTypes.AppDefinitionInput?
    /// The description of the new Q App.
    public var description: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Optional tags to associate with the new Q App.
    public var tags: [Swift.String: Swift.String]?
    /// The title of the new Q App.
    /// This member is required.
    public var title: Swift.String?

    public init(
        appDefinition: QAppsClientTypes.AppDefinitionInput? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        title: Swift.String? = nil
    )
    {
        self.appDefinition = appDefinition
        self.description = description
        self.instanceId = instanceId
        self.tags = tags
        self.title = title
    }
}

public struct GetQAppOutput {
    /// The Amazon Resource Name (ARN) of the Q App.
    /// This member is required.
    public var appArn: Swift.String?
    /// The full definition of the Q App, specifying the cards and flow.
    /// This member is required.
    public var appDefinition: QAppsClientTypes.AppDefinition?
    /// The unique identifier of the Q App.
    /// This member is required.
    public var appId: Swift.String?
    /// The version of the Q App.
    /// This member is required.
    public var appVersion: Swift.Int?
    /// The date and time the Q App was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user who created the Q App.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the Q App.
    public var description: Swift.String?
    /// The initial prompt displayed when the Q App is started.
    public var initialPrompt: Swift.String?
    /// The capabilities required to run the Q App, such as file upload or third-party integrations.
    public var requiredCapabilities: [QAppsClientTypes.AppRequiredCapability]?
    /// The status of the Q App.
    /// This member is required.
    public var status: QAppsClientTypes.AppStatus?
    /// The title of the Q App.
    /// This member is required.
    public var title: Swift.String?
    /// The date and time the Q App was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The user who last updated the Q App.
    /// This member is required.
    public var updatedBy: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appDefinition: QAppsClientTypes.AppDefinition? = nil,
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        initialPrompt: Swift.String? = nil,
        requiredCapabilities: [QAppsClientTypes.AppRequiredCapability]? = nil,
        status: QAppsClientTypes.AppStatus? = nil,
        title: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appDefinition = appDefinition
        self.appId = appId
        self.appVersion = appVersion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.initialPrompt = initialPrompt
        self.requiredCapabilities = requiredCapabilities
        self.status = status
        self.title = title
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

public struct UpdateQAppInput {
    /// The new definition specifying the cards and flow for the Q App.
    public var appDefinition: QAppsClientTypes.AppDefinitionInput?
    /// The unique identifier of the Q App to update.
    /// This member is required.
    public var appId: Swift.String?
    /// The new description for the Q App.
    public var description: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The new title for the Q App.
    public var title: Swift.String?

    public init(
        appDefinition: QAppsClientTypes.AppDefinitionInput? = nil,
        appId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        title: Swift.String? = nil
    )
    {
        self.appDefinition = appDefinition
        self.appId = appId
        self.description = description
        self.instanceId = instanceId
        self.title = title
    }
}

public struct PredictQAppOutput {
    /// The generated Q App definition.
    /// This member is required.
    public var app: QAppsClientTypes.PredictAppDefinition?
    /// The problem statement extracted from the input conversation, if provided.
    /// This member is required.
    public var problemStatement: Swift.String?

    public init(
        app: QAppsClientTypes.PredictAppDefinition? = nil,
        problemStatement: Swift.String? = nil
    )
    {
        self.app = app
        self.problemStatement = problemStatement
    }
}

extension AssociateLibraryItemReviewInput {

    static func urlPathProvider(_ value: AssociateLibraryItemReviewInput) -> Swift.String? {
        return "/catalog.associateItemRating"
    }
}

extension AssociateLibraryItemReviewInput {

    static func headerProvider(_ value: AssociateLibraryItemReviewInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension AssociateQAppWithUserInput {

    static func urlPathProvider(_ value: AssociateQAppWithUserInput) -> Swift.String? {
        return "/apps.install"
    }
}

extension AssociateQAppWithUserInput {

    static func headerProvider(_ value: AssociateQAppWithUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension CreateLibraryItemInput {

    static func urlPathProvider(_ value: CreateLibraryItemInput) -> Swift.String? {
        return "/catalog.createItem"
    }
}

extension CreateLibraryItemInput {

    static func headerProvider(_ value: CreateLibraryItemInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension CreateQAppInput {

    static func urlPathProvider(_ value: CreateQAppInput) -> Swift.String? {
        return "/apps.create"
    }
}

extension CreateQAppInput {

    static func headerProvider(_ value: CreateQAppInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension DeleteLibraryItemInput {

    static func urlPathProvider(_ value: DeleteLibraryItemInput) -> Swift.String? {
        return "/catalog.deleteItem"
    }
}

extension DeleteLibraryItemInput {

    static func headerProvider(_ value: DeleteLibraryItemInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension DeleteQAppInput {

    static func urlPathProvider(_ value: DeleteQAppInput) -> Swift.String? {
        return "/apps.delete"
    }
}

extension DeleteQAppInput {

    static func headerProvider(_ value: DeleteQAppInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension DisassociateLibraryItemReviewInput {

    static func urlPathProvider(_ value: DisassociateLibraryItemReviewInput) -> Swift.String? {
        return "/catalog.disassociateItemRating"
    }
}

extension DisassociateLibraryItemReviewInput {

    static func headerProvider(_ value: DisassociateLibraryItemReviewInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension DisassociateQAppFromUserInput {

    static func urlPathProvider(_ value: DisassociateQAppFromUserInput) -> Swift.String? {
        return "/apps.uninstall"
    }
}

extension DisassociateQAppFromUserInput {

    static func headerProvider(_ value: DisassociateQAppFromUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension GetLibraryItemInput {

    static func urlPathProvider(_ value: GetLibraryItemInput) -> Swift.String? {
        return "/catalog.getItem"
    }
}

extension GetLibraryItemInput {

    static func headerProvider(_ value: GetLibraryItemInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension GetLibraryItemInput {

    static func queryItemProvider(_ value: GetLibraryItemInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let libraryItemId = value.libraryItemId else {
            let message = "Creating a URL Query Item failed. libraryItemId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let libraryItemIdQueryItem = Smithy.URIQueryItem(name: "libraryItemId".urlPercentEncoding(), value: Swift.String(libraryItemId).urlPercentEncoding())
        items.append(libraryItemIdQueryItem)
        if let appId = value.appId {
            let appIdQueryItem = Smithy.URIQueryItem(name: "appId".urlPercentEncoding(), value: Swift.String(appId).urlPercentEncoding())
            items.append(appIdQueryItem)
        }
        return items
    }
}

extension GetQAppInput {

    static func urlPathProvider(_ value: GetQAppInput) -> Swift.String? {
        return "/apps.get"
    }
}

extension GetQAppInput {

    static func headerProvider(_ value: GetQAppInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension GetQAppInput {

    static func queryItemProvider(_ value: GetQAppInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let appId = value.appId else {
            let message = "Creating a URL Query Item failed. appId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let appIdQueryItem = Smithy.URIQueryItem(name: "appId".urlPercentEncoding(), value: Swift.String(appId).urlPercentEncoding())
        items.append(appIdQueryItem)
        return items
    }
}

extension GetQAppSessionInput {

    static func urlPathProvider(_ value: GetQAppSessionInput) -> Swift.String? {
        return "/runtime.getQAppSession"
    }
}

extension GetQAppSessionInput {

    static func headerProvider(_ value: GetQAppSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension GetQAppSessionInput {

    static func queryItemProvider(_ value: GetQAppSessionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let sessionId = value.sessionId else {
            let message = "Creating a URL Query Item failed. sessionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
        items.append(sessionIdQueryItem)
        return items
    }
}

extension ImportDocumentInput {

    static func urlPathProvider(_ value: ImportDocumentInput) -> Swift.String? {
        return "/apps.importDocument"
    }
}

extension ImportDocumentInput {

    static func headerProvider(_ value: ImportDocumentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension ListLibraryItemsInput {

    static func urlPathProvider(_ value: ListLibraryItemsInput) -> Swift.String? {
        return "/catalog.list"
    }
}

extension ListLibraryItemsInput {

    static func headerProvider(_ value: ListLibraryItemsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension ListLibraryItemsInput {

    static func queryItemProvider(_ value: ListLibraryItemsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let categoryId = value.categoryId {
            let categoryIdQueryItem = Smithy.URIQueryItem(name: "categoryId".urlPercentEncoding(), value: Swift.String(categoryId).urlPercentEncoding())
            items.append(categoryIdQueryItem)
        }
        return items
    }
}

extension ListQAppsInput {

    static func urlPathProvider(_ value: ListQAppsInput) -> Swift.String? {
        return "/apps.list"
    }
}

extension ListQAppsInput {

    static func headerProvider(_ value: ListQAppsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension ListQAppsInput {

    static func queryItemProvider(_ value: ListQAppsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceARN = value.resourceARN else {
            return nil
        }
        return "/tags/\(resourceARN.urlPercentEncoding())"
    }
}

extension PredictQAppInput {

    static func urlPathProvider(_ value: PredictQAppInput) -> Swift.String? {
        return "/apps.predictQApp"
    }
}

extension PredictQAppInput {

    static func headerProvider(_ value: PredictQAppInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension StartQAppSessionInput {

    static func urlPathProvider(_ value: StartQAppSessionInput) -> Swift.String? {
        return "/runtime.startQAppSession"
    }
}

extension StartQAppSessionInput {

    static func headerProvider(_ value: StartQAppSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension StopQAppSessionInput {

    static func urlPathProvider(_ value: StopQAppSessionInput) -> Swift.String? {
        return "/runtime.deleteMiniAppRun"
    }
}

extension StopQAppSessionInput {

    static func headerProvider(_ value: StopQAppSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceARN = value.resourceARN else {
            return nil
        }
        return "/tags/\(resourceARN.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceARN = value.resourceARN else {
            return nil
        }
        return "/tags/\(resourceARN.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateLibraryItemInput {

    static func urlPathProvider(_ value: UpdateLibraryItemInput) -> Swift.String? {
        return "/catalog.updateItem"
    }
}

extension UpdateLibraryItemInput {

    static func headerProvider(_ value: UpdateLibraryItemInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension UpdateLibraryItemMetadataInput {

    static func urlPathProvider(_ value: UpdateLibraryItemMetadataInput) -> Swift.String? {
        return "/catalog.updateItemMetadata"
    }
}

extension UpdateLibraryItemMetadataInput {

    static func headerProvider(_ value: UpdateLibraryItemMetadataInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension UpdateQAppInput {

    static func urlPathProvider(_ value: UpdateQAppInput) -> Swift.String? {
        return "/apps.update"
    }
}

extension UpdateQAppInput {

    static func headerProvider(_ value: UpdateQAppInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension UpdateQAppSessionInput {

    static func urlPathProvider(_ value: UpdateQAppSessionInput) -> Swift.String? {
        return "/runtime.updateQAppSession"
    }
}

extension UpdateQAppSessionInput {

    static func headerProvider(_ value: UpdateQAppSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension AssociateLibraryItemReviewInput {

    static func write(value: AssociateLibraryItemReviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["libraryItemId"].write(value.libraryItemId)
    }
}

extension AssociateQAppWithUserInput {

    static func write(value: AssociateQAppWithUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension CreateLibraryItemInput {

    static func write(value: CreateLibraryItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["appVersion"].write(value.appVersion)
        try writer["categories"].writeList(value.categories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateQAppInput {

    static func write(value: CreateQAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appDefinition"].write(value.appDefinition, with: QAppsClientTypes.AppDefinitionInput.write(value:to:))
        try writer["description"].write(value.description)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["title"].write(value.title)
    }
}

extension DeleteLibraryItemInput {

    static func write(value: DeleteLibraryItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["libraryItemId"].write(value.libraryItemId)
    }
}

extension DeleteQAppInput {

    static func write(value: DeleteQAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension DisassociateLibraryItemReviewInput {

    static func write(value: DisassociateLibraryItemReviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["libraryItemId"].write(value.libraryItemId)
    }
}

extension DisassociateQAppFromUserInput {

    static func write(value: DisassociateQAppFromUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension ImportDocumentInput {

    static func write(value: ImportDocumentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["cardId"].write(value.cardId)
        try writer["fileContentsBase64"].write(value.fileContentsBase64)
        try writer["fileName"].write(value.fileName)
        try writer["scope"].write(value.scope)
        try writer["sessionId"].write(value.sessionId)
    }
}

extension PredictQAppInput {

    static func write(value: PredictQAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["options"].write(value.options, with: QAppsClientTypes.PredictQAppInputOptions.write(value:to:))
    }
}

extension StartQAppSessionInput {

    static func write(value: StartQAppSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["appVersion"].write(value.appVersion)
        try writer["initialValues"].writeList(value.initialValues, memberWritingClosure: QAppsClientTypes.CardValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StopQAppSessionInput {

    static func write(value: StopQAppSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sessionId"].write(value.sessionId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateLibraryItemInput {

    static func write(value: UpdateLibraryItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["categories"].writeList(value.categories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["libraryItemId"].write(value.libraryItemId)
        try writer["status"].write(value.status)
    }
}

extension UpdateLibraryItemMetadataInput {

    static func write(value: UpdateLibraryItemMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["isVerified"].write(value.isVerified)
        try writer["libraryItemId"].write(value.libraryItemId)
    }
}

extension UpdateQAppInput {

    static func write(value: UpdateQAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appDefinition"].write(value.appDefinition, with: QAppsClientTypes.AppDefinitionInput.write(value:to:))
        try writer["appId"].write(value.appId)
        try writer["description"].write(value.description)
        try writer["title"].write(value.title)
    }
}

extension UpdateQAppSessionInput {

    static func write(value: UpdateQAppSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sessionId"].write(value.sessionId)
        try writer["values"].writeList(value.values, memberWritingClosure: QAppsClientTypes.CardValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssociateLibraryItemReviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateLibraryItemReviewOutput {
        return AssociateLibraryItemReviewOutput()
    }
}

extension AssociateQAppWithUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateQAppWithUserOutput {
        return AssociateQAppWithUserOutput()
    }
}

extension CreateLibraryItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLibraryItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLibraryItemOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.isVerified = try reader["isVerified"].readIfPresent()
        value.libraryItemId = try reader["libraryItemId"].readIfPresent() ?? ""
        value.ratingCount = try reader["ratingCount"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension CreateQAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateQAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateQAppOutput()
        value.appArn = try reader["appArn"].readIfPresent() ?? ""
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appVersion = try reader["appVersion"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.initialPrompt = try reader["initialPrompt"].readIfPresent()
        value.requiredCapabilities = try reader["requiredCapabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QAppsClientTypes.AppRequiredCapability>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["title"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteLibraryItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLibraryItemOutput {
        return DeleteLibraryItemOutput()
    }
}

extension DeleteQAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteQAppOutput {
        return DeleteQAppOutput()
    }
}

extension DisassociateLibraryItemReviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateLibraryItemReviewOutput {
        return DisassociateLibraryItemReviewOutput()
    }
}

extension DisassociateQAppFromUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateQAppFromUserOutput {
        return DisassociateQAppFromUserOutput()
    }
}

extension GetLibraryItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLibraryItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLibraryItemOutput()
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appVersion = try reader["appVersion"].readIfPresent() ?? 0
        value.categories = try reader["categories"].readListIfPresent(memberReadingClosure: QAppsClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.isRatedByUser = try reader["isRatedByUser"].readIfPresent()
        value.isVerified = try reader["isVerified"].readIfPresent()
        value.libraryItemId = try reader["libraryItemId"].readIfPresent() ?? ""
        value.ratingCount = try reader["ratingCount"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.userCount = try reader["userCount"].readIfPresent()
        return value
    }
}

extension GetQAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQAppOutput()
        value.appArn = try reader["appArn"].readIfPresent() ?? ""
        value.appDefinition = try reader["appDefinition"].readIfPresent(with: QAppsClientTypes.AppDefinition.read(from:))
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appVersion = try reader["appVersion"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.initialPrompt = try reader["initialPrompt"].readIfPresent()
        value.requiredCapabilities = try reader["requiredCapabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QAppsClientTypes.AppRequiredCapability>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["title"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent() ?? ""
        return value
    }
}

extension GetQAppSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQAppSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQAppSessionOutput()
        value.cardStatus = try reader["cardStatus"].readMapIfPresent(valueReadingClosure: QAppsClientTypes.CardStatus.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ImportDocumentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportDocumentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportDocumentOutput()
        value.fileId = try reader["fileId"].readIfPresent()
        return value
    }
}

extension ListLibraryItemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLibraryItemsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLibraryItemsOutput()
        value.libraryItems = try reader["libraryItems"].readListIfPresent(memberReadingClosure: QAppsClientTypes.LibraryItemMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListQAppsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQAppsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQAppsOutput()
        value.apps = try reader["apps"].readListIfPresent(memberReadingClosure: QAppsClientTypes.UserAppItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PredictQAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PredictQAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PredictQAppOutput()
        value.app = try reader["app"].readIfPresent(with: QAppsClientTypes.PredictAppDefinition.read(from:))
        value.problemStatement = try reader["problemStatement"].readIfPresent() ?? ""
        return value
    }
}

extension StartQAppSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartQAppSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartQAppSessionOutput()
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension StopQAppSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopQAppSessionOutput {
        return StopQAppSessionOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateLibraryItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLibraryItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLibraryItemOutput()
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appVersion = try reader["appVersion"].readIfPresent() ?? 0
        value.categories = try reader["categories"].readListIfPresent(memberReadingClosure: QAppsClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.isRatedByUser = try reader["isRatedByUser"].readIfPresent()
        value.isVerified = try reader["isVerified"].readIfPresent()
        value.libraryItemId = try reader["libraryItemId"].readIfPresent() ?? ""
        value.ratingCount = try reader["ratingCount"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.userCount = try reader["userCount"].readIfPresent()
        return value
    }
}

extension UpdateLibraryItemMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLibraryItemMetadataOutput {
        return UpdateLibraryItemMetadataOutput()
    }
}

extension UpdateQAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateQAppOutput()
        value.appArn = try reader["appArn"].readIfPresent() ?? ""
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appVersion = try reader["appVersion"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.initialPrompt = try reader["initialPrompt"].readIfPresent()
        value.requiredCapabilities = try reader["requiredCapabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QAppsClientTypes.AppRequiredCapability>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["title"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateQAppSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQAppSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateQAppSessionOutput()
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

enum AssociateLibraryItemReviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateQAppWithUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLibraryItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateQAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ContentTooLargeException": return try ContentTooLargeException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLibraryItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteQAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateLibraryItemReviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateQAppFromUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLibraryItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQAppSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportDocumentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ContentTooLargeException": return try ContentTooLargeException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLibraryItemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQAppsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PredictQAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartQAppSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopQAppSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLibraryItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLibraryItemMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ContentTooLargeException": return try ContentTooLargeException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQAppSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ContentTooLargeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ContentTooLargeException {
        let reader = baseError.errorBodyReader
        var value = ContentTooLargeException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QAppsClientTypes.Category {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.Category {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.Category()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        return value
    }
}

extension QAppsClientTypes.AppDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.AppDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.AppDefinition()
        value.appDefinitionVersion = try reader["appDefinitionVersion"].readIfPresent() ?? ""
        value.cards = try reader["cards"].readListIfPresent(memberReadingClosure: QAppsClientTypes.Card.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.canEdit = try reader["canEdit"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.Card {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.Card {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "textInput":
                return .textinput(try reader["textInput"].read(with: QAppsClientTypes.TextInputCard.read(from:)))
            case "qQuery":
                return .qquery(try reader["qQuery"].read(with: QAppsClientTypes.QQueryCard.read(from:)))
            case "qPlugin":
                return .qplugin(try reader["qPlugin"].read(with: QAppsClientTypes.QPluginCard.read(from:)))
            case "fileUpload":
                return .fileupload(try reader["fileUpload"].read(with: QAppsClientTypes.FileUploadCard.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QAppsClientTypes.FileUploadCard {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.FileUploadCard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.FileUploadCard()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.dependencies = try reader["dependencies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.filename = try reader["filename"].readIfPresent()
        value.fileId = try reader["fileId"].readIfPresent()
        value.allowOverride = try reader["allowOverride"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.QPluginCard {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.QPluginCard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.QPluginCard()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.dependencies = try reader["dependencies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.prompt = try reader["prompt"].readIfPresent() ?? ""
        value.pluginType = try reader["pluginType"].readIfPresent() ?? .sdkUnknown("")
        value.pluginId = try reader["pluginId"].readIfPresent() ?? ""
        return value
    }
}

extension QAppsClientTypes.QQueryCard {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.QQueryCard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.QQueryCard()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.dependencies = try reader["dependencies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.prompt = try reader["prompt"].readIfPresent() ?? ""
        value.outputSource = try reader["outputSource"].readIfPresent() ?? .sdkUnknown("")
        value.attributeFilter = try reader["attributeFilter"].readIfPresent(with: QAppsClientTypes.AttributeFilter.read(from:))
        return value
    }
}

extension QAppsClientTypes.AttributeFilter {

    static func write(value: QAppsClientTypes.AttributeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["andAllFilters"].writeList(value.andAllFilters, memberWritingClosure: QAppsClientTypes.AttributeFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["containsAll"].write(value.containsAll, with: QAppsClientTypes.DocumentAttribute.write(value:to:))
        try writer["containsAny"].write(value.containsAny, with: QAppsClientTypes.DocumentAttribute.write(value:to:))
        try writer["equalsTo"].write(value.equalsTo, with: QAppsClientTypes.DocumentAttribute.write(value:to:))
        try writer["greaterThan"].write(value.greaterThan, with: QAppsClientTypes.DocumentAttribute.write(value:to:))
        try writer["greaterThanOrEquals"].write(value.greaterThanOrEquals, with: QAppsClientTypes.DocumentAttribute.write(value:to:))
        try writer["lessThan"].write(value.lessThan, with: QAppsClientTypes.DocumentAttribute.write(value:to:))
        try writer["lessThanOrEquals"].write(value.lessThanOrEquals, with: QAppsClientTypes.DocumentAttribute.write(value:to:))
        try writer["notFilter"].write(value.notFilter, with: QAppsClientTypes.AttributeFilter.write(value:to:))
        try writer["orAllFilters"].writeList(value.orAllFilters, memberWritingClosure: QAppsClientTypes.AttributeFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.AttributeFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.AttributeFilter()
        value.andAllFilters = try reader["andAllFilters"].readListIfPresent(memberReadingClosure: QAppsClientTypes.AttributeFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.orAllFilters = try reader["orAllFilters"].readListIfPresent(memberReadingClosure: QAppsClientTypes.AttributeFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.notFilter = try reader["notFilter"].readIfPresent(with: QAppsClientTypes.AttributeFilter.read(from:))
        value.equalsTo = try reader["equalsTo"].readIfPresent(with: QAppsClientTypes.DocumentAttribute.read(from:))
        value.containsAll = try reader["containsAll"].readIfPresent(with: QAppsClientTypes.DocumentAttribute.read(from:))
        value.containsAny = try reader["containsAny"].readIfPresent(with: QAppsClientTypes.DocumentAttribute.read(from:))
        value.greaterThan = try reader["greaterThan"].readIfPresent(with: QAppsClientTypes.DocumentAttribute.read(from:))
        value.greaterThanOrEquals = try reader["greaterThanOrEquals"].readIfPresent(with: QAppsClientTypes.DocumentAttribute.read(from:))
        value.lessThan = try reader["lessThan"].readIfPresent(with: QAppsClientTypes.DocumentAttribute.read(from:))
        value.lessThanOrEquals = try reader["lessThanOrEquals"].readIfPresent(with: QAppsClientTypes.DocumentAttribute.read(from:))
        return value
    }
}

extension QAppsClientTypes.DocumentAttribute {

    static func write(value: QAppsClientTypes.DocumentAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value, with: QAppsClientTypes.DocumentAttributeValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.DocumentAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.DocumentAttribute()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent(with: QAppsClientTypes.DocumentAttributeValue.read(from:))
        return value
    }
}

extension QAppsClientTypes.DocumentAttributeValue {

    static func write(value: QAppsClientTypes.DocumentAttributeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .datevalue(datevalue):
                try writer["dateValue"].writeTimestamp(datevalue, format: SmithyTimestamps.TimestampFormat.epochSeconds)
            case let .longvalue(longvalue):
                try writer["longValue"].write(longvalue)
            case let .stringlistvalue(stringlistvalue):
                try writer["stringListValue"].writeList(stringlistvalue, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .stringvalue(stringvalue):
                try writer["stringValue"].write(stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.DocumentAttributeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "stringValue":
                return .stringvalue(try reader["stringValue"].read())
            case "stringListValue":
                return .stringlistvalue(try reader["stringListValue"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false))
            case "longValue":
                return .longvalue(try reader["longValue"].read())
            case "dateValue":
                return .datevalue(try reader["dateValue"].readTimestamp(format: SmithyTimestamps.TimestampFormat.epochSeconds))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QAppsClientTypes.TextInputCard {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.TextInputCard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.TextInputCard()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.dependencies = try reader["dependencies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.placeholder = try reader["placeholder"].readIfPresent()
        value.defaultValue = try reader["defaultValue"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.CardStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.CardStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.CardStatus()
        value.currentState = try reader["currentState"].readIfPresent() ?? .sdkUnknown("")
        value.currentValue = try reader["currentValue"].readIfPresent() ?? ""
        return value
    }
}

extension QAppsClientTypes.LibraryItemMember {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.LibraryItemMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.LibraryItemMember()
        value.libraryItemId = try reader["libraryItemId"].readIfPresent() ?? ""
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appVersion = try reader["appVersion"].readIfPresent() ?? 0
        value.categories = try reader["categories"].readListIfPresent(memberReadingClosure: QAppsClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.ratingCount = try reader["ratingCount"].readIfPresent() ?? 0
        value.isRatedByUser = try reader["isRatedByUser"].readIfPresent()
        value.userCount = try reader["userCount"].readIfPresent()
        value.isVerified = try reader["isVerified"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.UserAppItem {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.UserAppItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.UserAppItem()
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appArn = try reader["appArn"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.canEdit = try reader["canEdit"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.isVerified = try reader["isVerified"].readIfPresent() ?? false
        return value
    }
}

extension QAppsClientTypes.PredictAppDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.PredictAppDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.PredictAppDefinition()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.appDefinition = try reader["appDefinition"].readIfPresent(with: QAppsClientTypes.AppDefinitionInput.read(from:))
        return value
    }
}

extension QAppsClientTypes.AppDefinitionInput {

    static func write(value: QAppsClientTypes.AppDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cards"].writeList(value.cards, memberWritingClosure: QAppsClientTypes.CardInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["initialPrompt"].write(value.initialPrompt)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.AppDefinitionInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.AppDefinitionInput()
        value.cards = try reader["cards"].readListIfPresent(memberReadingClosure: QAppsClientTypes.CardInput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.initialPrompt = try reader["initialPrompt"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.CardInput {

    static func write(value: QAppsClientTypes.CardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .fileupload(fileupload):
                try writer["fileUpload"].write(fileupload, with: QAppsClientTypes.FileUploadCardInput.write(value:to:))
            case let .qplugin(qplugin):
                try writer["qPlugin"].write(qplugin, with: QAppsClientTypes.QPluginCardInput.write(value:to:))
            case let .qquery(qquery):
                try writer["qQuery"].write(qquery, with: QAppsClientTypes.QQueryCardInput.write(value:to:))
            case let .textinput(textinput):
                try writer["textInput"].write(textinput, with: QAppsClientTypes.TextInputCardInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.CardInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "textInput":
                return .textinput(try reader["textInput"].read(with: QAppsClientTypes.TextInputCardInput.read(from:)))
            case "qQuery":
                return .qquery(try reader["qQuery"].read(with: QAppsClientTypes.QQueryCardInput.read(from:)))
            case "qPlugin":
                return .qplugin(try reader["qPlugin"].read(with: QAppsClientTypes.QPluginCardInput.read(from:)))
            case "fileUpload":
                return .fileupload(try reader["fileUpload"].read(with: QAppsClientTypes.FileUploadCardInput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QAppsClientTypes.FileUploadCardInput {

    static func write(value: QAppsClientTypes.FileUploadCardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowOverride"].write(value.allowOverride)
        try writer["fileId"].write(value.fileId)
        try writer["filename"].write(value.filename)
        try writer["id"].write(value.id)
        try writer["title"].write(value.title)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.FileUploadCardInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.FileUploadCardInput()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .fileUpload
        value.filename = try reader["filename"].readIfPresent()
        value.fileId = try reader["fileId"].readIfPresent()
        value.allowOverride = try reader["allowOverride"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.QPluginCardInput {

    static func write(value: QAppsClientTypes.QPluginCardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["pluginId"].write(value.pluginId)
        try writer["prompt"].write(value.prompt)
        try writer["title"].write(value.title)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.QPluginCardInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.QPluginCardInput()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .qPlugin
        value.prompt = try reader["prompt"].readIfPresent() ?? ""
        value.pluginId = try reader["pluginId"].readIfPresent() ?? ""
        return value
    }
}

extension QAppsClientTypes.QQueryCardInput {

    static func write(value: QAppsClientTypes.QQueryCardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributeFilter"].write(value.attributeFilter, with: QAppsClientTypes.AttributeFilter.write(value:to:))
        try writer["id"].write(value.id)
        try writer["outputSource"].write(value.outputSource)
        try writer["prompt"].write(value.prompt)
        try writer["title"].write(value.title)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.QQueryCardInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.QQueryCardInput()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .qQuery
        value.prompt = try reader["prompt"].readIfPresent() ?? ""
        value.outputSource = try reader["outputSource"].readIfPresent() ?? .approvedSources
        value.attributeFilter = try reader["attributeFilter"].readIfPresent(with: QAppsClientTypes.AttributeFilter.read(from:))
        return value
    }
}

extension QAppsClientTypes.TextInputCardInput {

    static func write(value: QAppsClientTypes.TextInputCardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultValue"].write(value.defaultValue)
        try writer["id"].write(value.id)
        try writer["placeholder"].write(value.placeholder)
        try writer["title"].write(value.title)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.TextInputCardInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.TextInputCardInput()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .textInput
        value.placeholder = try reader["placeholder"].readIfPresent()
        value.defaultValue = try reader["defaultValue"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.PredictQAppInputOptions {

    static func write(value: QAppsClientTypes.PredictQAppInputOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .conversation(conversation):
                try writer["conversation"].writeList(conversation, memberWritingClosure: QAppsClientTypes.ConversationMessage.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .problemstatement(problemstatement):
                try writer["problemStatement"].write(problemstatement)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension QAppsClientTypes.ConversationMessage {

    static func write(value: QAppsClientTypes.ConversationMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
        try writer["type"].write(value.type)
    }
}

extension QAppsClientTypes.CardValue {

    static func write(value: QAppsClientTypes.CardValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cardId"].write(value.cardId)
        try writer["value"].write(value.value)
    }
}

public enum QAppsClientTypes {}
