//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import SmithyJSON
import class ClientRuntime.Indirect
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct AssociateLibraryItemReviewOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateQAppWithUserOutput: Swift.Sendable {

    public init() { }
}

public struct BatchCreateCategoryOutput: Swift.Sendable {

    public init() { }
}

public struct BatchDeleteCategoryOutput: Swift.Sendable {

    public init() { }
}

public struct BatchUpdateCategoryOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteLibraryItemOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteQAppOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateLibraryItemReviewOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateQAppFromUserOutput: Swift.Sendable {

    public init() { }
}

public struct StopQAppSessionOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateLibraryItemMetadataOutput: Swift.Sendable {

    public init() { }
}

/// The client is not authorized to perform the requested operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension QAppsClientTypes {

    public enum Action: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case read
        case write
        case sdkUnknown(Swift.String)

        public static var allCases: [Action] {
            return [
                .read,
                .write
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .read: return "read"
            case .write: return "write"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {

    public enum CardType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fileUpload
        case formInput
        case qPlugin
        case qQuery
        case textInput
        case sdkUnknown(Swift.String)

        public static var allCases: [CardType] {
            return [
                .fileUpload,
                .formInput,
                .qPlugin,
                .qQuery,
                .textInput
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fileUpload: return "file-upload"
            case .formInput: return "form-input"
            case .qPlugin: return "q-plugin"
            case .qQuery: return "q-query"
            case .textInput: return "text-input"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {

    /// A card in an Amazon Q App that allows the user to upload a file.
    public struct FileUploadCard: Swift.Sendable {
        /// A flag indicating if the user can override the default file for the upload card.
        public var allowOverride: Swift.Bool?
        /// Any dependencies or requirements for the file upload card.
        /// This member is required.
        public var dependencies: [Swift.String]?
        /// The unique identifier of the file associated with the card.
        public var fileId: Swift.String?
        /// The name of the file being uploaded.
        public var filename: Swift.String?
        /// The unique identifier of the file upload card.
        /// This member is required.
        public var id: Swift.String?
        /// The title of the file upload card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            allowOverride: Swift.Bool? = nil,
            dependencies: [Swift.String]? = nil,
            fileId: Swift.String? = nil,
            filename: Swift.String? = nil,
            id: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = nil
        ) {
            self.allowOverride = allowOverride
            self.dependencies = dependencies
            self.fileId = fileId
            self.filename = filename
            self.id = id
            self.title = title
            self.type = type
        }
    }
}

extension QAppsClientTypes {

    public enum InputCardComputeMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case append
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [InputCardComputeMode] {
            return [
                .append,
                .replace
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .append: return "append"
            case .replace: return "replace"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {

    /// The metadata of the form input card.
    public struct FormInputCardMetadata: Swift.Sendable {
        /// The JSON schema that defines the shape of the response data.
        /// This member is required.
        public var schema: Smithy.Document?

        public init(
            schema: Smithy.Document? = nil
        ) {
            self.schema = schema
        }
    }
}

extension QAppsClientTypes {

    /// A card in an Amazon Q App that allows the user to submit a response.
    public struct FormInputCard: Swift.Sendable {
        /// The compute mode of the form input card. This property determines whether individual participants of a data collection session can submit multiple response or one response. A compute mode of append shall allow participants to submit the same form multiple times with different values. A compute mode of replacecode> shall overwrite the current value for each participant.
        public var computeMode: QAppsClientTypes.InputCardComputeMode?
        /// Any dependencies or requirements for the form input card.
        /// This member is required.
        public var dependencies: [Swift.String]?
        /// The unique identifier of the form input card.
        /// This member is required.
        public var id: Swift.String?
        /// The metadata that defines the form input card data.
        /// This member is required.
        public var metadata: QAppsClientTypes.FormInputCardMetadata?
        /// The title of the form input card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            computeMode: QAppsClientTypes.InputCardComputeMode? = nil,
            dependencies: [Swift.String]? = nil,
            id: Swift.String? = nil,
            metadata: QAppsClientTypes.FormInputCardMetadata? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = nil
        ) {
            self.computeMode = computeMode
            self.dependencies = dependencies
            self.id = id
            self.metadata = metadata
            self.title = title
            self.type = type
        }
    }
}

extension QAppsClientTypes {

    public enum PluginType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asana
        case atlassianConfluence
        case custom
        case googleCalendar
        case jira
        case jiraCloud
        case microsoftExchange
        case microsoftTeams
        case pagerdutyAdvance
        case salesforce
        case salesforceCrm
        case servicenowNowPlatform
        case serviceNow
        case smartsheet
        case zendesk
        case zendeskSuite
        case sdkUnknown(Swift.String)

        public static var allCases: [PluginType] {
            return [
                .asana,
                .atlassianConfluence,
                .custom,
                .googleCalendar,
                .jira,
                .jiraCloud,
                .microsoftExchange,
                .microsoftTeams,
                .pagerdutyAdvance,
                .salesforce,
                .salesforceCrm,
                .servicenowNowPlatform,
                .serviceNow,
                .smartsheet,
                .zendesk,
                .zendeskSuite
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asana: return "ASANA"
            case .atlassianConfluence: return "ATLASSIAN_CONFLUENCE"
            case .custom: return "CUSTOM"
            case .googleCalendar: return "GOOGLE_CALENDAR"
            case .jira: return "JIRA"
            case .jiraCloud: return "JIRA_CLOUD"
            case .microsoftExchange: return "MICROSOFT_EXCHANGE"
            case .microsoftTeams: return "MICROSOFT_TEAMS"
            case .pagerdutyAdvance: return "PAGERDUTY_ADVANCE"
            case .salesforce: return "SALESFORCE"
            case .salesforceCrm: return "SALESFORCE_CRM"
            case .servicenowNowPlatform: return "SERVICENOW_NOW_PLATFORM"
            case .serviceNow: return "SERVICE_NOW"
            case .smartsheet: return "SMARTSHEET"
            case .zendesk: return "ZENDESK"
            case .zendeskSuite: return "ZENDESK_SUITE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {

    /// A card in an Q App that integrates with a third-party plugin or service.
    public struct QPluginCard: Swift.Sendable {
        /// The action identifier of the action to be performed by the plugin card.
        public var actionIdentifier: Swift.String?
        /// Any dependencies or requirements for the plugin card.
        /// This member is required.
        public var dependencies: [Swift.String]?
        /// The unique identifier of the plugin card.
        /// This member is required.
        public var id: Swift.String?
        /// The unique identifier of the plugin used by the card.
        /// This member is required.
        public var pluginId: Swift.String?
        /// The type or category of the plugin used by the card.
        /// This member is required.
        public var pluginType: QAppsClientTypes.PluginType?
        /// The prompt or instructions displayed for the plugin card.
        /// This member is required.
        public var prompt: Swift.String?
        /// The title or label of the plugin card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            actionIdentifier: Swift.String? = nil,
            dependencies: [Swift.String]? = nil,
            id: Swift.String? = nil,
            pluginId: Swift.String? = nil,
            pluginType: QAppsClientTypes.PluginType? = nil,
            prompt: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = nil
        ) {
            self.actionIdentifier = actionIdentifier
            self.dependencies = dependencies
            self.id = id
            self.pluginId = pluginId
            self.pluginType = pluginType
            self.prompt = prompt
            self.title = title
            self.type = type
        }
    }
}

extension QAppsClientTypes {

    /// The value of a document attribute. You can only provide one value for a document attribute.
    public enum DocumentAttributeValue: Swift.Sendable {
        /// A string.
        case stringvalue(Swift.String)
        /// A list of strings.
        case stringlistvalue([Swift.String])
        /// A long integer value.
        case longvalue(Swift.Int)
        /// A date expressed as an ISO 8601 string. It's important for the time zone to be included in the ISO 8601 date-time format. For example, 2012-03-25T12:30:10+01:00 is the ISO 8601 date-time format for March 25th 2012 at 12:30PM (plus 10 seconds) in Central European Time.
        case datevalue(Foundation.Date)
        case sdkUnknown(Swift.String)
    }
}

extension QAppsClientTypes {

    /// A document attribute or metadata field.
    public struct DocumentAttribute: Swift.Sendable {
        /// The identifier for the attribute.
        /// This member is required.
        public var name: Swift.String?
        /// The value of the attribute.
        /// This member is required.
        public var value: QAppsClientTypes.DocumentAttributeValue?

        public init(
            name: Swift.String? = nil,
            value: QAppsClientTypes.DocumentAttributeValue? = nil
        ) {
            self.name = name
            self.value = value
        }
    }
}

extension QAppsClientTypes {

    public enum CardOutputSource: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approvedSources
        case llm
        case sdkUnknown(Swift.String)

        public static var allCases: [CardOutputSource] {
            return [
                .approvedSources,
                .llm
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approvedSources: return "approved-sources"
            case .llm: return "llm"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {

    /// A card in an Amazon Q App that allows the user to input text.
    public struct TextInputCard: Swift.Sendable {
        /// The default value to pre-populate in the text input field.
        public var defaultValue: Swift.String?
        /// Any dependencies or requirements for the text input card.
        /// This member is required.
        public var dependencies: [Swift.String]?
        /// The unique identifier of the text input card.
        /// This member is required.
        public var id: Swift.String?
        /// The placeholder text to display in the text input field.
        public var placeholder: Swift.String?
        /// The title or label of the text input card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            defaultValue: Swift.String? = nil,
            dependencies: [Swift.String]? = nil,
            id: Swift.String? = nil,
            placeholder: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = nil
        ) {
            self.defaultValue = defaultValue
            self.dependencies = dependencies
            self.id = id
            self.placeholder = placeholder
            self.title = title
            self.type = type
        }
    }
}

extension QAppsClientTypes {

    /// Represents a file upload card. It can optionally receive a filename and fileId to set a default file. If not received, the user must provide the file when the Q App runs.
    public struct FileUploadCardInput: Swift.Sendable {
        /// A flag indicating if the user can override the default file for the upload card.
        public var allowOverride: Swift.Bool?
        /// The identifier of a pre-uploaded file associated with the card.
        public var fileId: Swift.String?
        /// The default filename to use for the file upload card.
        public var filename: Swift.String?
        /// The unique identifier of the file upload card.
        /// This member is required.
        public var id: Swift.String?
        /// The title or label of the file upload card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            allowOverride: Swift.Bool? = nil,
            fileId: Swift.String? = nil,
            filename: Swift.String? = nil,
            id: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = .fileUpload
        ) {
            self.allowOverride = allowOverride
            self.fileId = fileId
            self.filename = filename
            self.id = id
            self.title = title
            self.type = type
        }
    }
}

extension QAppsClientTypes {

    /// Represents a form input card for an Amazon Q App.
    public struct FormInputCardInput: Swift.Sendable {
        /// The compute mode of the form input card. This property determines whether individual participants of a data collection session can submit multiple response or one response. A compute mode of append shall allow participants to submit the same form multiple times with different values. A compute mode of replacecode> shall overwrite the current value for each participant.
        public var computeMode: QAppsClientTypes.InputCardComputeMode?
        /// The unique identifier of the form input card.
        /// This member is required.
        public var id: Swift.String?
        /// The metadata that defines the form input card data.
        /// This member is required.
        public var metadata: QAppsClientTypes.FormInputCardMetadata?
        /// The title or label of the form input card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            computeMode: QAppsClientTypes.InputCardComputeMode? = nil,
            id: Swift.String? = nil,
            metadata: QAppsClientTypes.FormInputCardMetadata? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = .formInput
        ) {
            self.computeMode = computeMode
            self.id = id
            self.metadata = metadata
            self.title = title
            self.type = type
        }
    }
}

extension QAppsClientTypes {

    /// The input shape for defining a plugin card in an Amazon Q App.
    public struct QPluginCardInput: Swift.Sendable {
        /// The action identifier of the action to be performed by the plugin card.
        public var actionIdentifier: Swift.String?
        /// The unique identifier of the plugin card.
        /// This member is required.
        public var id: Swift.String?
        /// The unique identifier of the plugin used by the card.
        /// This member is required.
        public var pluginId: Swift.String?
        /// The prompt or instructions displayed for the plugin card.
        /// This member is required.
        public var prompt: Swift.String?
        /// The title or label of the plugin card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            actionIdentifier: Swift.String? = nil,
            id: Swift.String? = nil,
            pluginId: Swift.String? = nil,
            prompt: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = .qPlugin
        ) {
            self.actionIdentifier = actionIdentifier
            self.id = id
            self.pluginId = pluginId
            self.prompt = prompt
            self.title = title
            self.type = type
        }
    }
}

extension QAppsClientTypes {

    /// The input shape for defining a text input card in an Amazon Q App.
    public struct TextInputCardInput: Swift.Sendable {
        /// The default value to pre-populate in the text input field.
        public var defaultValue: Swift.String?
        /// The unique identifier of the text input card.
        /// This member is required.
        public var id: Swift.String?
        /// The placeholder text to display in the text input field.
        public var placeholder: Swift.String?
        /// The title or label of the text input card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            defaultValue: Swift.String? = nil,
            id: Swift.String? = nil,
            placeholder: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = .textInput
        ) {
            self.defaultValue = defaultValue
            self.id = id
            self.placeholder = placeholder
            self.title = title
            self.type = type
        }
    }
}

extension QAppsClientTypes {

    public enum AppRequiredCapability: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creatorMode
        case fileUpload
        case pluginMode
        case retrievalMode
        case sdkUnknown(Swift.String)

        public static var allCases: [AppRequiredCapability] {
            return [
                .creatorMode,
                .fileUpload,
                .pluginMode,
                .retrievalMode
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creatorMode: return "CreatorMode"
            case .fileUpload: return "FileUpload"
            case .pluginMode: return "PluginMode"
            case .retrievalMode: return "RetrievalMode"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {

    public enum AppStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case draft
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [AppStatus] {
            return [
                .deleted,
                .draft,
                .published
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The requested operation could not be completed due to a conflict with the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier of the resource
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// An internal service error occurred while processing the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the operation
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    ) {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The requested resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier of the resource
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The requested operation could not be completed because it would exceed the service's quota or limit.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code of the quota that was exceeded
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The unique identifier of the resource
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code for the service where the quota was exceeded
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The requested operation could not be completed because too many requests were sent at once. Wait a bit and try again later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code of the quota that was exceeded
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying the operation
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The code for the service where the quota was exceeded
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

/// The client is not authenticated or authorized to perform the requested operation.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The input failed to satisfy the constraints specified by the service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct AssociateLibraryItemReviewInput: Swift.Sendable {
    /// The unique identifier for the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the library item to associate the review with.
    /// This member is required.
    public var libraryItemId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        libraryItemId: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.libraryItemId = libraryItemId
    }
}

public struct AssociateQAppWithUserInput: Swift.Sendable {
    /// The ID of the Amazon Q App to associate with the user.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    ) {
        self.appId = appId
        self.instanceId = instanceId
    }
}

extension QAppsClientTypes {

    /// The category object to be created.
    public struct BatchCreateCategoryInputCategory: Swift.Sendable {
        /// The color to be associated with a category. The color must be a hexadecimal value of either 3 or 6 digits.
        public var color: Swift.String?
        /// The unique identifier to be associated with a category. If you don't include a value, the category is automatically assigned a unique identifier.
        public var id: Swift.String?
        /// The name of the category.
        /// This member is required.
        public var title: Swift.String?

        public init(
            color: Swift.String? = nil,
            id: Swift.String? = nil,
            title: Swift.String? = nil
        ) {
            self.color = color
            self.id = id
            self.title = title
        }
    }
}

public struct BatchCreateCategoryInput: Swift.Sendable {
    /// The list of category objects to be created
    /// This member is required.
    public var categories: [QAppsClientTypes.BatchCreateCategoryInputCategory]?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        categories: [QAppsClientTypes.BatchCreateCategoryInputCategory]? = nil,
        instanceId: Swift.String? = nil
    ) {
        self.categories = categories
        self.instanceId = instanceId
    }
}

public struct BatchDeleteCategoryInput: Swift.Sendable {
    /// The list of IDs of the categories to be deleted.
    /// This member is required.
    public var categories: [Swift.String]?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        categories: [Swift.String]? = nil,
        instanceId: Swift.String? = nil
    ) {
        self.categories = categories
        self.instanceId = instanceId
    }
}

extension QAppsClientTypes {

    /// A label that web experience users associate with a library item. Web experience users use Categories to tag and filter library items.
    public struct CategoryInput: Swift.Sendable {
        /// The color of the category, represented as a hexadecimal value of either 3 or 6 digits.
        public var color: Swift.String?
        /// The unique identifier of the category.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the category.
        /// This member is required.
        public var title: Swift.String?

        public init(
            color: Swift.String? = nil,
            id: Swift.String? = nil,
            title: Swift.String? = nil
        ) {
            self.color = color
            self.id = id
            self.title = title
        }
    }
}

public struct BatchUpdateCategoryInput: Swift.Sendable {
    /// The list of categories to be updated with their new values.
    /// This member is required.
    public var categories: [QAppsClientTypes.CategoryInput]?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        categories: [QAppsClientTypes.CategoryInput]? = nil,
        instanceId: Swift.String? = nil
    ) {
        self.categories = categories
        self.instanceId = instanceId
    }
}

extension QAppsClientTypes {

    public enum ExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case error
        case inProgress
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .completed,
                .error,
                .inProgress,
                .waiting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case .waiting: return "WAITING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {

    /// A record created when a user submits a form card.
    public struct Submission: Swift.Sendable {
        /// The unique identifier of the submission.
        public var submissionId: Swift.String?
        /// The date and time when the card is submitted.
        public var timestamp: Foundation.Date?
        /// The data submitted by the user.
        public var value: Smithy.Document?

        public init(
            submissionId: Swift.String? = nil,
            timestamp: Foundation.Date? = nil,
            value: Smithy.Document? = nil
        ) {
            self.submissionId = submissionId
            self.timestamp = timestamp
            self.value = value
        }
    }
}

extension QAppsClientTypes {

    /// The current status and value of a card in an active Amazon Q App session.
    public struct CardStatus: Swift.Sendable {
        /// The current state of the card.
        /// This member is required.
        public var currentState: QAppsClientTypes.ExecutionStatus?
        /// The current value or result associated with the card.
        /// This member is required.
        public var currentValue: Swift.String?
        /// A list of previous submissions, if the card is a form card.
        public var submissions: [QAppsClientTypes.Submission]?

        public init(
            currentState: QAppsClientTypes.ExecutionStatus? = nil,
            currentValue: Swift.String? = nil,
            submissions: [QAppsClientTypes.Submission]? = nil
        ) {
            self.currentState = currentState
            self.currentValue = currentValue
            self.submissions = submissions
        }
    }
}

extension QAppsClientTypes {

    public enum SubmissionMutationKind: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case add
        case delete
        case edit
        case sdkUnknown(Swift.String)

        public static var allCases: [SubmissionMutationKind] {
            return [
                .add,
                .delete,
                .edit
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .add: return "add"
            case .delete: return "delete"
            case .edit: return "edit"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {

    /// Represents an action performed on a submission.
    public struct SubmissionMutation: Swift.Sendable {
        /// The operation that is performed on a submission.
        /// This member is required.
        public var mutationType: QAppsClientTypes.SubmissionMutationKind?
        /// The unique identifier of the submission.
        /// This member is required.
        public var submissionId: Swift.String?

        public init(
            mutationType: QAppsClientTypes.SubmissionMutationKind? = nil,
            submissionId: Swift.String? = nil
        ) {
            self.mutationType = mutationType
            self.submissionId = submissionId
        }
    }
}

extension QAppsClientTypes {

    /// The value or result associated with a card in a Amazon Q App session.
    public struct CardValue: Swift.Sendable {
        /// The unique identifier of the card.
        /// This member is required.
        public var cardId: Swift.String?
        /// The structure that describes how the current form card value is mutated. Only applies for form cards when multiple responses are allowed.
        public var submissionMutation: QAppsClientTypes.SubmissionMutation?
        /// The value or result associated with the card.
        /// This member is required.
        public var value: Swift.String?

        public init(
            cardId: Swift.String? = nil,
            submissionMutation: QAppsClientTypes.SubmissionMutation? = nil,
            value: Swift.String? = nil
        ) {
            self.cardId = cardId
            self.submissionMutation = submissionMutation
            self.value = value
        }
    }
}

extension QAppsClientTypes {

    /// A category used to classify and filter library items for Amazon Q Apps.
    public struct Category: Swift.Sendable {
        /// The number of published Amazon Q Apps associated with a category
        public var appCount: Swift.Int?
        /// The color of the category
        public var color: Swift.String?
        /// The unique identifier of the category.
        /// This member is required.
        public var id: Swift.String?
        /// The title or name of the category.
        /// This member is required.
        public var title: Swift.String?

        public init(
            appCount: Swift.Int? = nil,
            color: Swift.String? = nil,
            id: Swift.String? = nil,
            title: Swift.String? = nil
        ) {
            self.appCount = appCount
            self.color = color
            self.id = id
            self.title = title
        }
    }
}

/// The requested operation could not be completed because the content exceeds the maximum allowed size.
public struct ContentTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier of the resource
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContentTooLargeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension QAppsClientTypes {

    public enum Sender: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case system
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [Sender] {
            return [
                .system,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .system: return "SYSTEM"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {

    /// A message in a conversation, used as input for generating an Amazon Q App definition.
    public struct ConversationMessage: Swift.Sendable {
        /// The text content of the conversation message.
        /// This member is required.
        public var body: Swift.String?
        /// The type of the conversation message.
        /// This member is required.
        public var type: QAppsClientTypes.Sender?

        public init(
            body: Swift.String? = nil,
            type: QAppsClientTypes.Sender? = nil
        ) {
            self.body = body
            self.type = type
        }
    }
}

public struct CreateLibraryItemInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q App to publish to the library.
    /// This member is required.
    public var appId: Swift.String?
    /// The version of the Amazon Q App to publish to the library.
    /// This member is required.
    public var appVersion: Swift.Int?
    /// The categories to associate with the library item for easier discovery.
    /// This member is required.
    public var categories: [Swift.String]?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        categories: [Swift.String]? = nil,
        instanceId: Swift.String? = nil
    ) {
        self.appId = appId
        self.appVersion = appVersion
        self.categories = categories
        self.instanceId = instanceId
    }
}

public struct CreateLibraryItemOutput: Swift.Sendable {
    /// The date and time the library item was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user who created the library item.
    /// This member is required.
    public var createdBy: Swift.String?
    /// Indicates whether the library item has been verified.
    public var isVerified: Swift.Bool?
    /// The unique identifier of the new library item.
    /// This member is required.
    public var libraryItemId: Swift.String?
    /// The number of ratings the library item has received from users.
    /// This member is required.
    public var ratingCount: Swift.Int?
    /// The status of the new library item, such as "Published".
    /// This member is required.
    public var status: Swift.String?
    /// The date and time the library item was last updated.
    public var updatedAt: Foundation.Date?
    /// The user who last updated the library item.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        isVerified: Swift.Bool? = nil,
        libraryItemId: Swift.String? = nil,
        ratingCount: Swift.Int? = nil,
        status: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.isVerified = isVerified
        self.libraryItemId = libraryItemId
        self.ratingCount = ratingCount
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension QAppsClientTypes {

    public enum DocumentScope: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case application
        case session
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentScope] {
            return [
                .application,
                .session
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .session: return "SESSION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreatePresignedUrlInput: Swift.Sendable {
    /// The unique identifier of the Q App the file is associated with.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique identifier of the card the file is associated with.
    /// This member is required.
    public var cardId: Swift.String?
    /// The Base64-encoded SHA-256 digest of the contents of the file to be uploaded.
    /// This member is required.
    public var fileContentsSha256: Swift.String?
    /// The name of the file to be uploaded.
    /// This member is required.
    public var fileName: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Whether the file is associated with a Q App definition or a specific Q App session.
    /// This member is required.
    public var scope: QAppsClientTypes.DocumentScope?
    /// The unique identifier of the Q App session the file is associated with, if applicable.
    public var sessionId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        cardId: Swift.String? = nil,
        fileContentsSha256: Swift.String? = nil,
        fileName: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        scope: QAppsClientTypes.DocumentScope? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.appId = appId
        self.cardId = cardId
        self.fileContentsSha256 = fileContentsSha256
        self.fileName = fileName
        self.instanceId = instanceId
        self.scope = scope
        self.sessionId = sessionId
    }
}

public struct CreatePresignedUrlOutput: Swift.Sendable {
    /// The unique identifier assigned to the file to be uploaded.
    /// This member is required.
    public var fileId: Swift.String?
    /// The URL for a presigned S3 POST operation used to upload a file.
    /// This member is required.
    public var presignedUrl: Swift.String?
    /// The date and time that the presigned URL will expire in ISO 8601 format.
    /// This member is required.
    public var presignedUrlExpiration: Foundation.Date?
    /// The form fields to include in the presigned S3 POST operation used to upload a file.
    /// This member is required.
    public var presignedUrlFields: [Swift.String: Swift.String]?

    public init(
        fileId: Swift.String? = nil,
        presignedUrl: Swift.String? = nil,
        presignedUrlExpiration: Foundation.Date? = nil,
        presignedUrlFields: [Swift.String: Swift.String]? = nil
    ) {
        self.fileId = fileId
        self.presignedUrl = presignedUrl
        self.presignedUrlExpiration = presignedUrlExpiration
        self.presignedUrlFields = presignedUrlFields
    }
}

public struct CreateQAppOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the new Q App.
    /// This member is required.
    public var appArn: Swift.String?
    /// The unique identifier of the new Q App.
    /// This member is required.
    public var appId: Swift.String?
    /// The version of the new Q App.
    /// This member is required.
    public var appVersion: Swift.Int?
    /// The date and time the Q App was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user who created the Q App.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the new Q App.
    public var description: Swift.String?
    /// The initial prompt displayed when the Q App is started.
    public var initialPrompt: Swift.String?
    /// The capabilities required to run the Q App, such as file upload or third-party integrations.
    public var requiredCapabilities: [QAppsClientTypes.AppRequiredCapability]?
    /// The status of the new Q App, such as "Created".
    /// This member is required.
    public var status: QAppsClientTypes.AppStatus?
    /// The title of the new Q App.
    /// This member is required.
    public var title: Swift.String?
    /// The date and time the Q App was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The user who last updated the Q App.
    /// This member is required.
    public var updatedBy: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        initialPrompt: Swift.String? = nil,
        requiredCapabilities: [QAppsClientTypes.AppRequiredCapability]? = nil,
        status: QAppsClientTypes.AppStatus? = nil,
        title: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    ) {
        self.appArn = appArn
        self.appId = appId
        self.appVersion = appVersion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.initialPrompt = initialPrompt
        self.requiredCapabilities = requiredCapabilities
        self.status = status
        self.title = title
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

public struct DeleteLibraryItemInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the library item to delete.
    /// This member is required.
    public var libraryItemId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        libraryItemId: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.libraryItemId = libraryItemId
    }
}

public struct DeleteQAppInput: Swift.Sendable {
    /// The unique identifier of the Q App to delete.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    ) {
        self.appId = appId
        self.instanceId = instanceId
    }
}

public struct DescribeQAppPermissionsInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q App for which to retrieve permissions.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    ) {
        self.appId = appId
        self.instanceId = instanceId
    }
}

extension QAppsClientTypes {

    public enum UserType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case owner
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .owner,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .owner: return "owner"
            case .user: return "user"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QAppsClientTypes {

    /// The principal for which the permission applies.
    public struct PrincipalOutput: Swift.Sendable {
        /// The email address associated with the user.
        public var email: Swift.String?
        /// The unique identifier of the user.
        public var userId: Swift.String?
        /// The type of the user.
        public var userType: QAppsClientTypes.UserType?

        public init(
            email: Swift.String? = nil,
            userId: Swift.String? = nil,
            userType: QAppsClientTypes.UserType? = nil
        ) {
            self.email = email
            self.userId = userId
            self.userType = userType
        }
    }
}

extension QAppsClientTypes {

    /// The permission granted to the Amazon Q App.
    public struct PermissionOutput: Swift.Sendable {
        /// The action associated with the permission.
        /// This member is required.
        public var action: QAppsClientTypes.Action?
        /// The principal user to which the permission applies.
        /// This member is required.
        public var principal: QAppsClientTypes.PrincipalOutput?

        public init(
            action: QAppsClientTypes.Action? = nil,
            principal: QAppsClientTypes.PrincipalOutput? = nil
        ) {
            self.action = action
            self.principal = principal
        }
    }
}

public struct DescribeQAppPermissionsOutput: Swift.Sendable {
    /// The unique identifier of the Amazon Q App for which permissions are returned.
    public var appId: Swift.String?
    /// The list of permissions granted for the Amazon Q App.
    public var permissions: [QAppsClientTypes.PermissionOutput]?
    /// The Amazon Resource Name (ARN) of the Amazon Q App for which permissions are returned.
    public var resourceArn: Swift.String?

    public init(
        appId: Swift.String? = nil,
        permissions: [QAppsClientTypes.PermissionOutput]? = nil,
        resourceArn: Swift.String? = nil
    ) {
        self.appId = appId
        self.permissions = permissions
        self.resourceArn = resourceArn
    }
}

public struct DisassociateLibraryItemReviewInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the library item to remove the review from.
    /// This member is required.
    public var libraryItemId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        libraryItemId: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.libraryItemId = libraryItemId
    }
}

public struct DisassociateQAppFromUserInput: Swift.Sendable {
    /// The unique identifier of the Q App to disassociate from the user.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    ) {
        self.appId = appId
        self.instanceId = instanceId
    }
}

public struct ExportQAppSessionDataInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the Q App data collection session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.sessionId = sessionId
    }
}

public struct ExportQAppSessionDataOutput: Swift.Sendable {
    /// The link where the exported Q App session data can be downloaded from.
    /// This member is required.
    public var csvFileLink: Swift.String?
    /// The date and time when the link for the exported Q App session data expires.
    /// This member is required.
    public var expiresAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the Q App data collection session.
    /// This member is required.
    public var sessionArn: Swift.String?

    public init(
        csvFileLink: Swift.String? = nil,
        expiresAt: Foundation.Date? = nil,
        sessionArn: Swift.String? = nil
    ) {
        self.csvFileLink = csvFileLink
        self.expiresAt = expiresAt
        self.sessionArn = sessionArn
    }
}

public struct GetLibraryItemInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q App associated with the library item.
    public var appId: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the library item to retrieve.
    /// This member is required.
    public var libraryItemId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        libraryItemId: Swift.String? = nil
    ) {
        self.appId = appId
        self.instanceId = instanceId
        self.libraryItemId = libraryItemId
    }
}

public struct GetLibraryItemOutput: Swift.Sendable {
    /// The unique identifier of the Q App associated with the library item.
    /// This member is required.
    public var appId: Swift.String?
    /// The version of the Q App associated with the library item.
    /// This member is required.
    public var appVersion: Swift.Int?
    /// The categories associated with the library item for discovery.
    /// This member is required.
    public var categories: [QAppsClientTypes.Category]?
    /// The date and time the library item was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user who created the library item.
    /// This member is required.
    public var createdBy: Swift.String?
    /// Whether the current user has rated the library item.
    public var isRatedByUser: Swift.Bool?
    /// Indicates whether the library item has been verified.
    public var isVerified: Swift.Bool?
    /// The unique identifier of the library item.
    /// This member is required.
    public var libraryItemId: Swift.String?
    /// The number of ratings the library item has received from users.
    /// This member is required.
    public var ratingCount: Swift.Int?
    /// The status of the library item, such as "Published".
    /// This member is required.
    public var status: Swift.String?
    /// The date and time the library item was last updated.
    public var updatedAt: Foundation.Date?
    /// The user who last updated the library item.
    public var updatedBy: Swift.String?
    /// The number of users who have associated the Q App with their account.
    public var userCount: Swift.Int?

    public init(
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        categories: [QAppsClientTypes.Category]? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        isRatedByUser: Swift.Bool? = nil,
        isVerified: Swift.Bool? = nil,
        libraryItemId: Swift.String? = nil,
        ratingCount: Swift.Int? = nil,
        status: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil,
        userCount: Swift.Int? = nil
    ) {
        self.appId = appId
        self.appVersion = appVersion
        self.categories = categories
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.isRatedByUser = isRatedByUser
        self.isVerified = isVerified
        self.libraryItemId = libraryItemId
        self.ratingCount = ratingCount
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.userCount = userCount
    }
}

public struct GetQAppInput: Swift.Sendable {
    /// The unique identifier of the Q App to retrieve.
    /// This member is required.
    public var appId: Swift.String?
    /// The version of the Q App.
    public var appVersion: Swift.Int?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        instanceId: Swift.String? = nil
    ) {
        self.appId = appId
        self.appVersion = appVersion
        self.instanceId = instanceId
    }
}

public struct GetQAppSessionInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the Q App session to retrieve.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.sessionId = sessionId
    }
}

public struct GetQAppSessionOutput: Swift.Sendable {
    /// The version of the Q App used for the session.
    public var appVersion: Swift.Int?
    /// The current status for each card in the Q App session.
    /// This member is required.
    public var cardStatus: [Swift.String: QAppsClientTypes.CardStatus]?
    /// The latest published version of the Q App used for the session.
    public var latestPublishedAppVersion: Swift.Int?
    /// The Amazon Resource Name (ARN) of the Q App session.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// The unique identifier of the Q App session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The name of the Q App session.
    public var sessionName: Swift.String?
    /// The current status of the Q App session.
    /// This member is required.
    public var status: QAppsClientTypes.ExecutionStatus?
    /// Indicates whether the current user is the owner of the Q App data collection session.
    public var userIsHost: Swift.Bool?

    public init(
        appVersion: Swift.Int? = nil,
        cardStatus: [Swift.String: QAppsClientTypes.CardStatus]? = nil,
        latestPublishedAppVersion: Swift.Int? = nil,
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionName: Swift.String? = nil,
        status: QAppsClientTypes.ExecutionStatus? = nil,
        userIsHost: Swift.Bool? = nil
    ) {
        self.appVersion = appVersion
        self.cardStatus = cardStatus
        self.latestPublishedAppVersion = latestPublishedAppVersion
        self.sessionArn = sessionArn
        self.sessionId = sessionId
        self.sessionName = sessionName
        self.status = status
        self.userIsHost = userIsHost
    }
}

public struct GetQAppSessionMetadataInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the Q App session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.sessionId = sessionId
    }
}

extension QAppsClientTypes {

    /// The sharing configuration of an Amazon Q App data collection session.
    public struct SessionSharingConfiguration: Swift.Sendable {
        /// Indicates whether an Q App session can accept responses from users.
        public var acceptResponses: Swift.Bool?
        /// Indicates whether an Q App session is shareable with other users.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Indicates whether collected responses for an Q App session are revealed for all users.
        public var revealCards: Swift.Bool?

        public init(
            acceptResponses: Swift.Bool? = nil,
            enabled: Swift.Bool? = nil,
            revealCards: Swift.Bool? = nil
        ) {
            self.acceptResponses = acceptResponses
            self.enabled = enabled
            self.revealCards = revealCards
        }
    }
}

public struct GetQAppSessionMetadataOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Q App session.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// The unique identifier of the Q App session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The name of the Q App session.
    public var sessionName: Swift.String?
    /// Indicates whether the current user is the owner of the Q App session.
    public var sessionOwner: Swift.Bool?
    /// The sharing configuration of the Q App data collection session.
    /// This member is required.
    public var sharingConfiguration: QAppsClientTypes.SessionSharingConfiguration?

    public init(
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionName: Swift.String? = nil,
        sessionOwner: Swift.Bool? = nil,
        sharingConfiguration: QAppsClientTypes.SessionSharingConfiguration? = nil
    ) {
        self.sessionArn = sessionArn
        self.sessionId = sessionId
        self.sessionName = sessionName
        self.sessionOwner = sessionOwner
        self.sharingConfiguration = sharingConfiguration
    }
}

public struct ImportDocumentInput: Swift.Sendable {
    /// The unique identifier of the Q App the file is associated with.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique identifier of the card the file is associated with.
    /// This member is required.
    public var cardId: Swift.String?
    /// The base64-encoded contents of the file to upload.
    /// This member is required.
    public var fileContentsBase64: Swift.String?
    /// The name of the file being uploaded.
    /// This member is required.
    public var fileName: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Whether the file is associated with a Q App definition or a specific Q App session.
    /// This member is required.
    public var scope: QAppsClientTypes.DocumentScope?
    /// The unique identifier of the Q App session the file is associated with, if applicable.
    public var sessionId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        cardId: Swift.String? = nil,
        fileContentsBase64: Swift.String? = nil,
        fileName: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        scope: QAppsClientTypes.DocumentScope? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.appId = appId
        self.cardId = cardId
        self.fileContentsBase64 = fileContentsBase64
        self.fileName = fileName
        self.instanceId = instanceId
        self.scope = scope
        self.sessionId = sessionId
    }
}

public struct ImportDocumentOutput: Swift.Sendable {
    /// The unique identifier assigned to the uploaded file.
    public var fileId: Swift.String?

    public init(
        fileId: Swift.String? = nil
    ) {
        self.fileId = fileId
    }
}

extension QAppsClientTypes {

    /// A library item is a snapshot of an Amazon Q App that can be published so the users in their Amazon Q Apps library can discover it, clone it, and run it.
    public struct LibraryItemMember: Swift.Sendable {
        /// The unique identifier of the Q App associated with the library item.
        /// This member is required.
        public var appId: Swift.String?
        /// The version of the Q App associated with the library item.
        /// This member is required.
        public var appVersion: Swift.Int?
        /// The categories associated with the library item.
        /// This member is required.
        public var categories: [QAppsClientTypes.Category]?
        /// The date and time the library item was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The user who created the library item.
        /// This member is required.
        public var createdBy: Swift.String?
        /// Whether the current user has rated the library item.
        public var isRatedByUser: Swift.Bool?
        /// Indicates whether the library item has been verified.
        public var isVerified: Swift.Bool?
        /// The unique identifier of the library item.
        /// This member is required.
        public var libraryItemId: Swift.String?
        /// The number of ratings the library item has received.
        /// This member is required.
        public var ratingCount: Swift.Int?
        /// The status of the library item.
        /// This member is required.
        public var status: Swift.String?
        /// The date and time the library item was last updated.
        public var updatedAt: Foundation.Date?
        /// The user who last updated the library item.
        public var updatedBy: Swift.String?
        /// The number of users who have the associated Q App.
        public var userCount: Swift.Int?

        public init(
            appId: Swift.String? = nil,
            appVersion: Swift.Int? = nil,
            categories: [QAppsClientTypes.Category]? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            isRatedByUser: Swift.Bool? = nil,
            isVerified: Swift.Bool? = nil,
            libraryItemId: Swift.String? = nil,
            ratingCount: Swift.Int? = nil,
            status: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil,
            userCount: Swift.Int? = nil
        ) {
            self.appId = appId
            self.appVersion = appVersion
            self.categories = categories
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.isRatedByUser = isRatedByUser
            self.isVerified = isVerified
            self.libraryItemId = libraryItemId
            self.ratingCount = ratingCount
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.userCount = userCount
        }
    }
}

extension QAppsClientTypes {

    public enum LibraryItemStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [LibraryItemStatus] {
            return [
                .disabled,
                .published
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListCategoriesInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    ) {
        self.instanceId = instanceId
    }
}

public struct ListCategoriesOutput: Swift.Sendable {
    /// The categories of a Amazon Q Business application environment instance.
    public var categories: [QAppsClientTypes.Category]?

    public init(
        categories: [QAppsClientTypes.Category]? = nil
    ) {
        self.categories = categories
    }
}

public struct ListLibraryItemsInput: Swift.Sendable {
    /// Optional category to filter the library items by.
    public var categoryId: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of library items to return in the response.
    public var limit: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        categoryId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.categoryId = categoryId
        self.instanceId = instanceId
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct ListLibraryItemsOutput: Swift.Sendable {
    /// The list of library items meeting the request criteria.
    public var libraryItems: [QAppsClientTypes.LibraryItemMember]?
    /// The token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        libraryItems: [QAppsClientTypes.LibraryItemMember]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.libraryItems = libraryItems
        self.nextToken = nextToken
    }
}

public struct ListQAppsInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of Q Apps to return in the response.
    public var limit: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.limit = limit
        self.nextToken = nextToken
    }
}

extension QAppsClientTypes {

    /// An Amazon Q App associated with a user, either owned by the user or favorited.
    public struct UserAppItem: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Q App.
        /// This member is required.
        public var appArn: Swift.String?
        /// The unique identifier of the Q App.
        /// This member is required.
        public var appId: Swift.String?
        /// A flag indicating whether the user can edit the Q App.
        public var canEdit: Swift.Bool?
        /// The date and time the user's association with the Q App was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the Q App.
        public var description: Swift.String?
        /// Indicates whether the Q App has been verified.
        public var isVerified: Swift.Bool
        /// The status of the user's association with the Q App.
        public var status: Swift.String?
        /// The title of the Q App.
        /// This member is required.
        public var title: Swift.String?

        public init(
            appArn: Swift.String? = nil,
            appId: Swift.String? = nil,
            canEdit: Swift.Bool? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            isVerified: Swift.Bool = false,
            status: Swift.String? = nil,
            title: Swift.String? = nil
        ) {
            self.appArn = appArn
            self.appId = appId
            self.canEdit = canEdit
            self.createdAt = createdAt
            self.description = description
            self.isVerified = isVerified
            self.status = status
            self.title = title
        }
    }
}

public struct ListQAppsOutput: Swift.Sendable {
    /// The list of Amazon Q Apps meeting the request criteria.
    /// This member is required.
    public var apps: [QAppsClientTypes.UserAppItem]?
    /// The token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        apps: [QAppsClientTypes.UserAppItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.apps = apps
        self.nextToken = nextToken
    }
}

public struct ListQAppSessionDataInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the Q App data collection session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.sessionId = sessionId
    }
}

extension QAppsClientTypes {

    /// A user of an Amazon Q App.
    public struct User: Swift.Sendable {
        /// The unique identifier of a user.
        public var userId: Swift.String?

        public init(
            userId: Swift.String? = nil
        ) {
            self.userId = userId
        }
    }
}

extension QAppsClientTypes {

    /// The response collected for a Amazon Q App session. This container represents a single response to a Q App session.
    public struct QAppSessionData: Swift.Sendable {
        /// The card Id associated with the response submitted for a Q App session.
        /// This member is required.
        public var cardId: Swift.String?
        /// The unique identifier of the submission.
        public var submissionId: Swift.String?
        /// The date and time when the session data is submitted.
        public var timestamp: Foundation.Date?
        /// The user who submitted the response for a Q App session.
        /// This member is required.
        public var user: QAppsClientTypes.User?
        /// The response submitted for a Q App session.
        public var value: Smithy.Document?

        public init(
            cardId: Swift.String? = nil,
            submissionId: Swift.String? = nil,
            timestamp: Foundation.Date? = nil,
            user: QAppsClientTypes.User? = nil,
            value: Smithy.Document? = nil
        ) {
            self.cardId = cardId
            self.submissionId = submissionId
            self.timestamp = timestamp
            self.user = user
            self.value = value
        }
    }
}

public struct ListQAppSessionDataOutput: Swift.Sendable {
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Q App data collection session.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// The collected responses of a Q App session.
    public var sessionData: [QAppsClientTypes.QAppSessionData]?
    /// The unique identifier of the Q App data collection session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        sessionArn: Swift.String? = nil,
        sessionData: [QAppsClientTypes.QAppSessionData]? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.nextToken = nextToken
        self.sessionArn = sessionArn
        self.sessionData = sessionData
        self.sessionId = sessionId
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource whose tags should be listed.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    ) {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of tags that are assigned to the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

extension QAppsClientTypes {

    /// The permission to grant or revoke for a Amazon Q App.
    public struct PermissionInput: Swift.Sendable {
        /// The action associated with the permission.
        /// This member is required.
        public var action: QAppsClientTypes.Action?
        /// The principal user to which the permission applies.
        /// This member is required.
        public var principal: Swift.String?

        public init(
            action: QAppsClientTypes.Action? = nil,
            principal: Swift.String? = nil
        ) {
            self.action = action
            self.principal = principal
        }
    }
}

extension QAppsClientTypes {

    /// The input options for generating an Q App definition.
    public enum PredictQAppInputOptions: Swift.Sendable {
        /// A conversation to use as input for generating the Q App definition.
        case conversation([QAppsClientTypes.ConversationMessage])
        /// A problem statement to use as input for generating the Q App definition.
        case problemstatement(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

public struct PredictQAppInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The input to generate the Q App definition from, either a conversation or problem statement.
    public var options: QAppsClientTypes.PredictQAppInputOptions?

    public init(
        instanceId: Swift.String? = nil,
        options: QAppsClientTypes.PredictQAppInputOptions? = nil
    ) {
        self.instanceId = instanceId
        self.options = options
    }
}

public struct StartQAppSessionInput: Swift.Sendable {
    /// The unique identifier of the Q App to start a session for.
    /// This member is required.
    public var appId: Swift.String?
    /// The version of the Q App to use for the session.
    /// This member is required.
    public var appVersion: Swift.Int?
    /// Optional initial input values to provide for the Q App session.
    public var initialValues: [QAppsClientTypes.CardValue]?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the a Q App session.
    public var sessionId: Swift.String?
    /// Optional tags to associate with the new Q App session.
    public var tags: [Swift.String: Swift.String]?

    public init(
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        initialValues: [QAppsClientTypes.CardValue]? = nil,
        instanceId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.appId = appId
        self.appVersion = appVersion
        self.initialValues = initialValues
        self.instanceId = instanceId
        self.sessionId = sessionId
        self.tags = tags
    }
}

public struct StartQAppSessionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the new Q App session.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// The unique identifier of the new or retrieved Q App session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.sessionArn = sessionArn
        self.sessionId = sessionId
    }
}

public struct StopQAppSessionInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the Q App session to stop.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.sessionId = sessionId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags to associate with the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to disassociate the tag from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys of the tags to disassociate from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateLibraryItemInput: Swift.Sendable {
    /// The new categories to associate with the library item.
    public var categories: [Swift.String]?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the library item to update.
    /// This member is required.
    public var libraryItemId: Swift.String?
    /// The new status to set for the library item, such as "Published" or "Hidden".
    public var status: QAppsClientTypes.LibraryItemStatus?

    public init(
        categories: [Swift.String]? = nil,
        instanceId: Swift.String? = nil,
        libraryItemId: Swift.String? = nil,
        status: QAppsClientTypes.LibraryItemStatus? = nil
    ) {
        self.categories = categories
        self.instanceId = instanceId
        self.libraryItemId = libraryItemId
        self.status = status
    }
}

public struct UpdateLibraryItemOutput: Swift.Sendable {
    /// The unique identifier of the Q App associated with the library item.
    /// This member is required.
    public var appId: Swift.String?
    /// The version of the Q App associated with the library item.
    /// This member is required.
    public var appVersion: Swift.Int?
    /// The categories associated with the updated library item.
    /// This member is required.
    public var categories: [QAppsClientTypes.Category]?
    /// The date and time the library item was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user who originally created the library item.
    /// This member is required.
    public var createdBy: Swift.String?
    /// Whether the current user has rated the library item.
    public var isRatedByUser: Swift.Bool?
    /// Indicates whether the library item has been verified.
    public var isVerified: Swift.Bool?
    /// The unique identifier of the updated library item.
    /// This member is required.
    public var libraryItemId: Swift.String?
    /// The number of ratings the library item has received.
    /// This member is required.
    public var ratingCount: Swift.Int?
    /// The new status of the updated library item.
    /// This member is required.
    public var status: Swift.String?
    /// The date and time the library item was last updated.
    public var updatedAt: Foundation.Date?
    /// The user who last updated the library item.
    public var updatedBy: Swift.String?
    /// The number of users who have the associated Q App.
    public var userCount: Swift.Int?

    public init(
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        categories: [QAppsClientTypes.Category]? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        isRatedByUser: Swift.Bool? = nil,
        isVerified: Swift.Bool? = nil,
        libraryItemId: Swift.String? = nil,
        ratingCount: Swift.Int? = nil,
        status: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil,
        userCount: Swift.Int? = nil
    ) {
        self.appId = appId
        self.appVersion = appVersion
        self.categories = categories
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.isRatedByUser = isRatedByUser
        self.isVerified = isVerified
        self.libraryItemId = libraryItemId
        self.ratingCount = ratingCount
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.userCount = userCount
    }
}

public struct UpdateLibraryItemMetadataInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The verification status of the library item
    public var isVerified: Swift.Bool?
    /// The unique identifier of the updated library item.
    /// This member is required.
    public var libraryItemId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        isVerified: Swift.Bool? = nil,
        libraryItemId: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.isVerified = isVerified
        self.libraryItemId = libraryItemId
    }
}

public struct UpdateQAppOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated Q App.
    /// This member is required.
    public var appArn: Swift.String?
    /// The unique identifier of the updated Q App.
    /// This member is required.
    public var appId: Swift.String?
    /// The new version of the updated Q App.
    /// This member is required.
    public var appVersion: Swift.Int?
    /// The date and time the Q App was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user who originally created the Q App.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The new description of the updated Q App.
    public var description: Swift.String?
    /// The initial prompt for the updated Q App.
    public var initialPrompt: Swift.String?
    /// The capabilities required for the updated Q App.
    public var requiredCapabilities: [QAppsClientTypes.AppRequiredCapability]?
    /// The status of the updated Q App.
    /// This member is required.
    public var status: QAppsClientTypes.AppStatus?
    /// The new title of the updated Q App.
    /// This member is required.
    public var title: Swift.String?
    /// The date and time the Q App was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The user who last updated the Q App.
    /// This member is required.
    public var updatedBy: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        initialPrompt: Swift.String? = nil,
        requiredCapabilities: [QAppsClientTypes.AppRequiredCapability]? = nil,
        status: QAppsClientTypes.AppStatus? = nil,
        title: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    ) {
        self.appArn = appArn
        self.appId = appId
        self.appVersion = appVersion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.initialPrompt = initialPrompt
        self.requiredCapabilities = requiredCapabilities
        self.status = status
        self.title = title
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

public struct UpdateQAppPermissionsInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q App for which permissions are being updated.
    /// This member is required.
    public var appId: Swift.String?
    /// The list of permissions to grant for the Amazon Q App.
    public var grantPermissions: [QAppsClientTypes.PermissionInput]?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The list of permissions to revoke for the Amazon Q App.
    public var revokePermissions: [QAppsClientTypes.PermissionInput]?

    public init(
        appId: Swift.String? = nil,
        grantPermissions: [QAppsClientTypes.PermissionInput]? = nil,
        instanceId: Swift.String? = nil,
        revokePermissions: [QAppsClientTypes.PermissionInput]? = nil
    ) {
        self.appId = appId
        self.grantPermissions = grantPermissions
        self.instanceId = instanceId
        self.revokePermissions = revokePermissions
    }
}

public struct UpdateQAppPermissionsOutput: Swift.Sendable {
    /// The unique identifier of the Amazon Q App for which permissions were updated.
    public var appId: Swift.String?
    /// The updated list of permissions for the Amazon Q App.
    public var permissions: [QAppsClientTypes.PermissionOutput]?
    /// The Amazon Resource Name (ARN) of the Amazon Q App for which permissions were updated.
    public var resourceArn: Swift.String?

    public init(
        appId: Swift.String? = nil,
        permissions: [QAppsClientTypes.PermissionOutput]? = nil,
        resourceArn: Swift.String? = nil
    ) {
        self.appId = appId
        self.permissions = permissions
        self.resourceArn = resourceArn
    }
}

public struct UpdateQAppSessionInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the Q App session to provide input for.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The input values to provide for the current state of the Q App session.
    public var values: [QAppsClientTypes.CardValue]?

    public init(
        instanceId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        values: [QAppsClientTypes.CardValue]? = nil
    ) {
        self.instanceId = instanceId
        self.sessionId = sessionId
        self.values = values
    }
}

public struct UpdateQAppSessionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated Q App session.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// The unique identifier of the updated Q App session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.sessionArn = sessionArn
        self.sessionId = sessionId
    }
}

public struct UpdateQAppSessionMetadataInput: Swift.Sendable {
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The unique identifier of the Q App session to update configuration for.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The new name for the Q App session.
    public var sessionName: Swift.String?
    /// The new sharing configuration for the Q App data collection session.
    /// This member is required.
    public var sharingConfiguration: QAppsClientTypes.SessionSharingConfiguration?

    public init(
        instanceId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionName: Swift.String? = nil,
        sharingConfiguration: QAppsClientTypes.SessionSharingConfiguration? = nil
    ) {
        self.instanceId = instanceId
        self.sessionId = sessionId
        self.sessionName = sessionName
        self.sharingConfiguration = sharingConfiguration
    }
}

public struct UpdateQAppSessionMetadataOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated Q App session.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// The unique identifier of the updated Q App session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The new name of the updated Q App session.
    public var sessionName: Swift.String?
    /// The new sharing configuration of the updated Q App data collection session.
    /// This member is required.
    public var sharingConfiguration: QAppsClientTypes.SessionSharingConfiguration?

    public init(
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionName: Swift.String? = nil,
        sharingConfiguration: QAppsClientTypes.SessionSharingConfiguration? = nil
    ) {
        self.sessionArn = sessionArn
        self.sessionId = sessionId
        self.sessionName = sessionName
        self.sharingConfiguration = sharingConfiguration
    }
}

extension QAppsClientTypes {

    /// The filter criteria used on responses based on document attributes or metadata fields.
    public struct AttributeFilter: Swift.Sendable {
        /// Performs a logical AND operation on all supplied filters.
        public var andAllFilters: [QAppsClientTypes.AttributeFilter]?
        /// Returns true when a document contains all the specified document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): stringListValue.
        public var containsAll: QAppsClientTypes.DocumentAttribute?
        /// Returns true when a document contains any of the specified document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): stringListValue.
        public var containsAny: QAppsClientTypes.DocumentAttribute?
        /// Performs an equals operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue, longValue, stringListValue and stringValue.
        public var equalsTo: QAppsClientTypes.DocumentAttribute?
        /// Performs a greater than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue and longValue.
        public var greaterThan: QAppsClientTypes.DocumentAttribute?
        /// Performs a greater than or equals operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue and longValue.
        public var greaterThanOrEquals: QAppsClientTypes.DocumentAttribute?
        /// Performs a less than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue and longValue.
        public var lessThan: QAppsClientTypes.DocumentAttribute?
        /// Performs a less than or equals operation on two document attributes or metadata fields.Supported for the following [document attribute value type](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue and longValue.
        public var lessThanOrEquals: QAppsClientTypes.DocumentAttribute?
        /// Performs a logical NOT operation on all supplied filters.
        @Indirect public var notFilter: QAppsClientTypes.AttributeFilter?
        /// Performs a logical OR operation on all supplied filters.
        public var orAllFilters: [QAppsClientTypes.AttributeFilter]?

        public init(
            andAllFilters: [QAppsClientTypes.AttributeFilter]? = nil,
            containsAll: QAppsClientTypes.DocumentAttribute? = nil,
            containsAny: QAppsClientTypes.DocumentAttribute? = nil,
            equalsTo: QAppsClientTypes.DocumentAttribute? = nil,
            greaterThan: QAppsClientTypes.DocumentAttribute? = nil,
            greaterThanOrEquals: QAppsClientTypes.DocumentAttribute? = nil,
            lessThan: QAppsClientTypes.DocumentAttribute? = nil,
            lessThanOrEquals: QAppsClientTypes.DocumentAttribute? = nil,
            notFilter: QAppsClientTypes.AttributeFilter? = nil,
            orAllFilters: [QAppsClientTypes.AttributeFilter]? = nil
        ) {
            self.andAllFilters = andAllFilters
            self.containsAll = containsAll
            self.containsAny = containsAny
            self.equalsTo = equalsTo
            self.greaterThan = greaterThan
            self.greaterThanOrEquals = greaterThanOrEquals
            self.lessThan = lessThan
            self.lessThanOrEquals = lessThanOrEquals
            self.notFilter = notFilter
            self.orAllFilters = orAllFilters
        }
    }
}

extension QAppsClientTypes {

    /// A card in a Amazon Q App that generates a response based on the Amazon Q Business service.
    public struct QQueryCard: Swift.Sendable {
        /// The Amazon Q Business filters applied in this query card when resolving data sources
        public var attributeFilter: QAppsClientTypes.AttributeFilter?
        /// Any dependencies or requirements for the query card.
        /// This member is required.
        public var dependencies: [Swift.String]?
        /// The unique identifier of the query card.
        /// This member is required.
        public var id: Swift.String?
        /// Any dependencies for the query card, where the dependencies are references to the collected responses.
        public var memoryReferences: [Swift.String]?
        /// The source or type of output generated by the query card.
        /// This member is required.
        public var outputSource: QAppsClientTypes.CardOutputSource?
        /// The prompt or instructions displayed for the query card.
        /// This member is required.
        public var prompt: Swift.String?
        /// The title or label of the query card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            attributeFilter: QAppsClientTypes.AttributeFilter? = nil,
            dependencies: [Swift.String]? = nil,
            id: Swift.String? = nil,
            memoryReferences: [Swift.String]? = nil,
            outputSource: QAppsClientTypes.CardOutputSource? = nil,
            prompt: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = nil
        ) {
            self.attributeFilter = attributeFilter
            self.dependencies = dependencies
            self.id = id
            self.memoryReferences = memoryReferences
            self.outputSource = outputSource
            self.prompt = prompt
            self.title = title
            self.type = type
        }
    }
}

extension QAppsClientTypes {

    /// The input shape for defining a query card in an Amazon Q App.
    public struct QQueryCardInput: Swift.Sendable {
        /// Turns on filtering of responses based on document attributes or metadata fields.
        public var attributeFilter: QAppsClientTypes.AttributeFilter?
        /// The unique identifier of the query card.
        /// This member is required.
        public var id: Swift.String?
        /// The source or type of output to generate for the query card.
        public var outputSource: QAppsClientTypes.CardOutputSource?
        /// The prompt or instructions displayed for the query card.
        /// This member is required.
        public var prompt: Swift.String?
        /// The title or label of the query card.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the card.
        /// This member is required.
        public var type: QAppsClientTypes.CardType?

        public init(
            attributeFilter: QAppsClientTypes.AttributeFilter? = nil,
            id: Swift.String? = nil,
            outputSource: QAppsClientTypes.CardOutputSource? = .approvedSources,
            prompt: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QAppsClientTypes.CardType? = .qQuery
        ) {
            self.attributeFilter = attributeFilter
            self.id = id
            self.outputSource = outputSource
            self.prompt = prompt
            self.title = title
            self.type = type
        }
    }
}

extension QAppsClientTypes {

    /// A card representing a component or step in an Amazon Q App's flow.
    public indirect enum Card: Swift.Sendable {
        /// A container for the properties of the text input card.
        case textinput(QAppsClientTypes.TextInputCard)
        /// A container for the properties of the query card.
        case qquery(QAppsClientTypes.QQueryCard)
        /// A container for the properties of the plugin card.
        case qplugin(QAppsClientTypes.QPluginCard)
        /// A container for the properties of the file upload card.
        case fileupload(QAppsClientTypes.FileUploadCard)
        /// A container for the properties of the form input card.
        case forminput(QAppsClientTypes.FormInputCard)
        case sdkUnknown(Swift.String)
    }
}

extension QAppsClientTypes {

    /// The properties defining an input card in an Amazon Q App.
    public indirect enum CardInput: Swift.Sendable {
        /// A container for the properties of the text input card.
        case textinput(QAppsClientTypes.TextInputCardInput)
        /// A container for the properties of the query input card.
        case qquery(QAppsClientTypes.QQueryCardInput)
        /// A container for the properties of the plugin input card.
        case qplugin(QAppsClientTypes.QPluginCardInput)
        /// A container for the properties of the file upload input card.
        case fileupload(QAppsClientTypes.FileUploadCardInput)
        /// A container for the properties of the form input card.
        case forminput(QAppsClientTypes.FormInputCardInput)
        case sdkUnknown(Swift.String)
    }
}

extension QAppsClientTypes {

    /// The definition of the Q App, specifying the cards and flow.
    public struct AppDefinition: Swift.Sendable {
        /// The version of the app definition schema or specification.
        /// This member is required.
        public var appDefinitionVersion: Swift.String?
        /// A flag indicating whether the Q App's definition can be edited by the user.
        public var canEdit: Swift.Bool?
        /// The cards that make up the Q App, such as text input, file upload, or query cards.
        /// This member is required.
        public var cards: [QAppsClientTypes.Card]?

        public init(
            appDefinitionVersion: Swift.String? = nil,
            canEdit: Swift.Bool? = nil,
            cards: [QAppsClientTypes.Card]? = nil
        ) {
            self.appDefinitionVersion = appDefinitionVersion
            self.canEdit = canEdit
            self.cards = cards
        }
    }
}

extension QAppsClientTypes {

    /// The input for defining an Q App.
    public struct AppDefinitionInput: Swift.Sendable {
        /// The cards that make up the Q App definition.
        /// This member is required.
        public var cards: [QAppsClientTypes.CardInput]?
        /// The initial prompt displayed when the Q App is started.
        public var initialPrompt: Swift.String?

        public init(
            cards: [QAppsClientTypes.CardInput]? = nil,
            initialPrompt: Swift.String? = nil
        ) {
            self.cards = cards
            self.initialPrompt = initialPrompt
        }
    }
}

extension QAppsClientTypes {

    /// The definition of an Amazon Q App generated based on input such as a conversation or problem statement.
    public struct PredictAppDefinition: Swift.Sendable {
        /// The definition specifying the cards and flow of the generated Q App.
        /// This member is required.
        public var appDefinition: QAppsClientTypes.AppDefinitionInput?
        /// The description of the generated Q App definition.
        public var description: Swift.String?
        /// The title of the generated Q App definition.
        /// This member is required.
        public var title: Swift.String?

        public init(
            appDefinition: QAppsClientTypes.AppDefinitionInput? = nil,
            description: Swift.String? = nil,
            title: Swift.String? = nil
        ) {
            self.appDefinition = appDefinition
            self.description = description
            self.title = title
        }
    }
}

public struct CreateQAppInput: Swift.Sendable {
    /// The definition of the new Q App, specifying the cards and flow.
    /// This member is required.
    public var appDefinition: QAppsClientTypes.AppDefinitionInput?
    /// The description of the new Q App.
    public var description: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Optional tags to associate with the new Q App.
    public var tags: [Swift.String: Swift.String]?
    /// The title of the new Q App.
    /// This member is required.
    public var title: Swift.String?

    public init(
        appDefinition: QAppsClientTypes.AppDefinitionInput? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        title: Swift.String? = nil
    ) {
        self.appDefinition = appDefinition
        self.description = description
        self.instanceId = instanceId
        self.tags = tags
        self.title = title
    }
}

public struct GetQAppOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Q App.
    /// This member is required.
    public var appArn: Swift.String?
    /// The full definition of the Q App, specifying the cards and flow.
    /// This member is required.
    public var appDefinition: QAppsClientTypes.AppDefinition?
    /// The unique identifier of the Q App.
    /// This member is required.
    public var appId: Swift.String?
    /// The version of the Q App.
    /// This member is required.
    public var appVersion: Swift.Int?
    /// The date and time the Q App was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user who created the Q App.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the Q App.
    public var description: Swift.String?
    /// The initial prompt displayed when the Q App is started.
    public var initialPrompt: Swift.String?
    /// The capabilities required to run the Q App, such as file upload or third-party integrations.
    public var requiredCapabilities: [QAppsClientTypes.AppRequiredCapability]?
    /// The status of the Q App.
    /// This member is required.
    public var status: QAppsClientTypes.AppStatus?
    /// The title of the Q App.
    /// This member is required.
    public var title: Swift.String?
    /// The date and time the Q App was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The user who last updated the Q App.
    /// This member is required.
    public var updatedBy: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appDefinition: QAppsClientTypes.AppDefinition? = nil,
        appId: Swift.String? = nil,
        appVersion: Swift.Int? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        initialPrompt: Swift.String? = nil,
        requiredCapabilities: [QAppsClientTypes.AppRequiredCapability]? = nil,
        status: QAppsClientTypes.AppStatus? = nil,
        title: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    ) {
        self.appArn = appArn
        self.appDefinition = appDefinition
        self.appId = appId
        self.appVersion = appVersion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.initialPrompt = initialPrompt
        self.requiredCapabilities = requiredCapabilities
        self.status = status
        self.title = title
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

public struct UpdateQAppInput: Swift.Sendable {
    /// The new definition specifying the cards and flow for the Q App.
    public var appDefinition: QAppsClientTypes.AppDefinitionInput?
    /// The unique identifier of the Q App to update.
    /// This member is required.
    public var appId: Swift.String?
    /// The new description for the Q App.
    public var description: Swift.String?
    /// The unique identifier of the Amazon Q Business application environment instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The new title for the Q App.
    public var title: Swift.String?

    public init(
        appDefinition: QAppsClientTypes.AppDefinitionInput? = nil,
        appId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        title: Swift.String? = nil
    ) {
        self.appDefinition = appDefinition
        self.appId = appId
        self.description = description
        self.instanceId = instanceId
        self.title = title
    }
}

public struct PredictQAppOutput: Swift.Sendable {
    /// The generated Q App definition.
    /// This member is required.
    public var app: QAppsClientTypes.PredictAppDefinition?
    /// The problem statement extracted from the input conversation, if provided.
    /// This member is required.
    public var problemStatement: Swift.String?

    public init(
        app: QAppsClientTypes.PredictAppDefinition? = nil,
        problemStatement: Swift.String? = nil
    ) {
        self.app = app
        self.problemStatement = problemStatement
    }
}

extension AssociateLibraryItemReviewInput {

    static func urlPathProvider(_ value: AssociateLibraryItemReviewInput) -> Swift.String? {
        return "/catalog.associateItemRating"
    }
}

extension AssociateLibraryItemReviewInput {

    static func headerProvider(_ value: AssociateLibraryItemReviewInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension AssociateQAppWithUserInput {

    static func urlPathProvider(_ value: AssociateQAppWithUserInput) -> Swift.String? {
        return "/apps.install"
    }
}

extension AssociateQAppWithUserInput {

    static func headerProvider(_ value: AssociateQAppWithUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension BatchCreateCategoryInput {

    static func urlPathProvider(_ value: BatchCreateCategoryInput) -> Swift.String? {
        return "/catalog.createCategories"
    }
}

extension BatchCreateCategoryInput {

    static func headerProvider(_ value: BatchCreateCategoryInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension BatchDeleteCategoryInput {

    static func urlPathProvider(_ value: BatchDeleteCategoryInput) -> Swift.String? {
        return "/catalog.deleteCategories"
    }
}

extension BatchDeleteCategoryInput {

    static func headerProvider(_ value: BatchDeleteCategoryInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension BatchUpdateCategoryInput {

    static func urlPathProvider(_ value: BatchUpdateCategoryInput) -> Swift.String? {
        return "/catalog.updateCategories"
    }
}

extension BatchUpdateCategoryInput {

    static func headerProvider(_ value: BatchUpdateCategoryInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension CreateLibraryItemInput {

    static func urlPathProvider(_ value: CreateLibraryItemInput) -> Swift.String? {
        return "/catalog.createItem"
    }
}

extension CreateLibraryItemInput {

    static func headerProvider(_ value: CreateLibraryItemInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension CreatePresignedUrlInput {

    static func urlPathProvider(_ value: CreatePresignedUrlInput) -> Swift.String? {
        return "/apps.createPresignedUrl"
    }
}

extension CreatePresignedUrlInput {

    static func headerProvider(_ value: CreatePresignedUrlInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension CreateQAppInput {

    static func urlPathProvider(_ value: CreateQAppInput) -> Swift.String? {
        return "/apps.create"
    }
}

extension CreateQAppInput {

    static func headerProvider(_ value: CreateQAppInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension DeleteLibraryItemInput {

    static func urlPathProvider(_ value: DeleteLibraryItemInput) -> Swift.String? {
        return "/catalog.deleteItem"
    }
}

extension DeleteLibraryItemInput {

    static func headerProvider(_ value: DeleteLibraryItemInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension DeleteQAppInput {

    static func urlPathProvider(_ value: DeleteQAppInput) -> Swift.String? {
        return "/apps.delete"
    }
}

extension DeleteQAppInput {

    static func headerProvider(_ value: DeleteQAppInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension DescribeQAppPermissionsInput {

    static func urlPathProvider(_ value: DescribeQAppPermissionsInput) -> Swift.String? {
        return "/apps.describeQAppPermissions"
    }
}

extension DescribeQAppPermissionsInput {

    static func headerProvider(_ value: DescribeQAppPermissionsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension DescribeQAppPermissionsInput {

    static func queryItemProvider(_ value: DescribeQAppPermissionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let appId = value.appId else {
            let message = "Creating a URL Query Item failed. appId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let appIdQueryItem = Smithy.URIQueryItem(name: "appId".urlPercentEncoding(), value: Swift.String(appId).urlPercentEncoding())
        items.append(appIdQueryItem)
        return items
    }
}

extension DisassociateLibraryItemReviewInput {

    static func urlPathProvider(_ value: DisassociateLibraryItemReviewInput) -> Swift.String? {
        return "/catalog.disassociateItemRating"
    }
}

extension DisassociateLibraryItemReviewInput {

    static func headerProvider(_ value: DisassociateLibraryItemReviewInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension DisassociateQAppFromUserInput {

    static func urlPathProvider(_ value: DisassociateQAppFromUserInput) -> Swift.String? {
        return "/apps.uninstall"
    }
}

extension DisassociateQAppFromUserInput {

    static func headerProvider(_ value: DisassociateQAppFromUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension ExportQAppSessionDataInput {

    static func urlPathProvider(_ value: ExportQAppSessionDataInput) -> Swift.String? {
        return "/runtime.exportQAppSessionData"
    }
}

extension ExportQAppSessionDataInput {

    static func headerProvider(_ value: ExportQAppSessionDataInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension GetLibraryItemInput {

    static func urlPathProvider(_ value: GetLibraryItemInput) -> Swift.String? {
        return "/catalog.getItem"
    }
}

extension GetLibraryItemInput {

    static func headerProvider(_ value: GetLibraryItemInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension GetLibraryItemInput {

    static func queryItemProvider(_ value: GetLibraryItemInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let libraryItemId = value.libraryItemId else {
            let message = "Creating a URL Query Item failed. libraryItemId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let libraryItemIdQueryItem = Smithy.URIQueryItem(name: "libraryItemId".urlPercentEncoding(), value: Swift.String(libraryItemId).urlPercentEncoding())
        items.append(libraryItemIdQueryItem)
        if let appId = value.appId {
            let appIdQueryItem = Smithy.URIQueryItem(name: "appId".urlPercentEncoding(), value: Swift.String(appId).urlPercentEncoding())
            items.append(appIdQueryItem)
        }
        return items
    }
}

extension GetQAppInput {

    static func urlPathProvider(_ value: GetQAppInput) -> Swift.String? {
        return "/apps.get"
    }
}

extension GetQAppInput {

    static func headerProvider(_ value: GetQAppInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension GetQAppInput {

    static func queryItemProvider(_ value: GetQAppInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let appVersion = value.appVersion {
            let appVersionQueryItem = Smithy.URIQueryItem(name: "appVersion".urlPercentEncoding(), value: Swift.String(appVersion).urlPercentEncoding())
            items.append(appVersionQueryItem)
        }
        guard let appId = value.appId else {
            let message = "Creating a URL Query Item failed. appId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let appIdQueryItem = Smithy.URIQueryItem(name: "appId".urlPercentEncoding(), value: Swift.String(appId).urlPercentEncoding())
        items.append(appIdQueryItem)
        return items
    }
}

extension GetQAppSessionInput {

    static func urlPathProvider(_ value: GetQAppSessionInput) -> Swift.String? {
        return "/runtime.getQAppSession"
    }
}

extension GetQAppSessionInput {

    static func headerProvider(_ value: GetQAppSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension GetQAppSessionInput {

    static func queryItemProvider(_ value: GetQAppSessionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let sessionId = value.sessionId else {
            let message = "Creating a URL Query Item failed. sessionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
        items.append(sessionIdQueryItem)
        return items
    }
}

extension GetQAppSessionMetadataInput {

    static func urlPathProvider(_ value: GetQAppSessionMetadataInput) -> Swift.String? {
        return "/runtime.getQAppSessionMetadata"
    }
}

extension GetQAppSessionMetadataInput {

    static func headerProvider(_ value: GetQAppSessionMetadataInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension GetQAppSessionMetadataInput {

    static func queryItemProvider(_ value: GetQAppSessionMetadataInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let sessionId = value.sessionId else {
            let message = "Creating a URL Query Item failed. sessionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
        items.append(sessionIdQueryItem)
        return items
    }
}

extension ImportDocumentInput {

    static func urlPathProvider(_ value: ImportDocumentInput) -> Swift.String? {
        return "/apps.importDocument"
    }
}

extension ImportDocumentInput {

    static func headerProvider(_ value: ImportDocumentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension ListCategoriesInput {

    static func urlPathProvider(_ value: ListCategoriesInput) -> Swift.String? {
        return "/catalog.listCategories"
    }
}

extension ListCategoriesInput {

    static func headerProvider(_ value: ListCategoriesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension ListLibraryItemsInput {

    static func urlPathProvider(_ value: ListLibraryItemsInput) -> Swift.String? {
        return "/catalog.list"
    }
}

extension ListLibraryItemsInput {

    static func headerProvider(_ value: ListLibraryItemsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension ListLibraryItemsInput {

    static func queryItemProvider(_ value: ListLibraryItemsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let categoryId = value.categoryId {
            let categoryIdQueryItem = Smithy.URIQueryItem(name: "categoryId".urlPercentEncoding(), value: Swift.String(categoryId).urlPercentEncoding())
            items.append(categoryIdQueryItem)
        }
        return items
    }
}

extension ListQAppsInput {

    static func urlPathProvider(_ value: ListQAppsInput) -> Swift.String? {
        return "/apps.list"
    }
}

extension ListQAppsInput {

    static func headerProvider(_ value: ListQAppsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension ListQAppsInput {

    static func queryItemProvider(_ value: ListQAppsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension ListQAppSessionDataInput {

    static func urlPathProvider(_ value: ListQAppSessionDataInput) -> Swift.String? {
        return "/runtime.listQAppSessionData"
    }
}

extension ListQAppSessionDataInput {

    static func headerProvider(_ value: ListQAppSessionDataInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension ListQAppSessionDataInput {

    static func queryItemProvider(_ value: ListQAppSessionDataInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let sessionId = value.sessionId else {
            let message = "Creating a URL Query Item failed. sessionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
        items.append(sessionIdQueryItem)
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceARN = value.resourceARN else {
            return nil
        }
        return "/tags/\(resourceARN.urlPercentEncoding())"
    }
}

extension PredictQAppInput {

    static func urlPathProvider(_ value: PredictQAppInput) -> Swift.String? {
        return "/apps.predictQApp"
    }
}

extension PredictQAppInput {

    static func headerProvider(_ value: PredictQAppInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension StartQAppSessionInput {

    static func urlPathProvider(_ value: StartQAppSessionInput) -> Swift.String? {
        return "/runtime.startQAppSession"
    }
}

extension StartQAppSessionInput {

    static func headerProvider(_ value: StartQAppSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension StopQAppSessionInput {

    static func urlPathProvider(_ value: StopQAppSessionInput) -> Swift.String? {
        return "/runtime.deleteMiniAppRun"
    }
}

extension StopQAppSessionInput {

    static func headerProvider(_ value: StopQAppSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceARN = value.resourceARN else {
            return nil
        }
        return "/tags/\(resourceARN.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceARN = value.resourceARN else {
            return nil
        }
        return "/tags/\(resourceARN.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateLibraryItemInput {

    static func urlPathProvider(_ value: UpdateLibraryItemInput) -> Swift.String? {
        return "/catalog.updateItem"
    }
}

extension UpdateLibraryItemInput {

    static func headerProvider(_ value: UpdateLibraryItemInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension UpdateLibraryItemMetadataInput {

    static func urlPathProvider(_ value: UpdateLibraryItemMetadataInput) -> Swift.String? {
        return "/catalog.updateItemMetadata"
    }
}

extension UpdateLibraryItemMetadataInput {

    static func headerProvider(_ value: UpdateLibraryItemMetadataInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension UpdateQAppInput {

    static func urlPathProvider(_ value: UpdateQAppInput) -> Swift.String? {
        return "/apps.update"
    }
}

extension UpdateQAppInput {

    static func headerProvider(_ value: UpdateQAppInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension UpdateQAppPermissionsInput {

    static func urlPathProvider(_ value: UpdateQAppPermissionsInput) -> Swift.String? {
        return "/apps.updateQAppPermissions"
    }
}

extension UpdateQAppPermissionsInput {

    static func headerProvider(_ value: UpdateQAppPermissionsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension UpdateQAppSessionInput {

    static func urlPathProvider(_ value: UpdateQAppSessionInput) -> Swift.String? {
        return "/runtime.updateQAppSession"
    }
}

extension UpdateQAppSessionInput {

    static func headerProvider(_ value: UpdateQAppSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension UpdateQAppSessionMetadataInput {

    static func urlPathProvider(_ value: UpdateQAppSessionMetadataInput) -> Swift.String? {
        return "/runtime.updateQAppSessionMetadata"
    }
}

extension UpdateQAppSessionMetadataInput {

    static func headerProvider(_ value: UpdateQAppSessionMetadataInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let instanceId = value.instanceId {
            items.add(SmithyHTTPAPI.Header(name: "instance-id", value: Swift.String(instanceId)))
        }
        return items
    }
}

extension AssociateLibraryItemReviewInput {

    static func write(value: AssociateLibraryItemReviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["libraryItemId"].write(value.libraryItemId)
    }
}

extension AssociateQAppWithUserInput {

    static func write(value: AssociateQAppWithUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension BatchCreateCategoryInput {

    static func write(value: BatchCreateCategoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["categories"].writeList(value.categories, memberWritingClosure: QAppsClientTypes.BatchCreateCategoryInputCategory.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDeleteCategoryInput {

    static func write(value: BatchDeleteCategoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["categories"].writeList(value.categories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdateCategoryInput {

    static func write(value: BatchUpdateCategoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["categories"].writeList(value.categories, memberWritingClosure: QAppsClientTypes.CategoryInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateLibraryItemInput {

    static func write(value: CreateLibraryItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["appVersion"].write(value.appVersion)
        try writer["categories"].writeList(value.categories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreatePresignedUrlInput {

    static func write(value: CreatePresignedUrlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["cardId"].write(value.cardId)
        try writer["fileContentsSha256"].write(value.fileContentsSha256)
        try writer["fileName"].write(value.fileName)
        try writer["scope"].write(value.scope)
        try writer["sessionId"].write(value.sessionId)
    }
}

extension CreateQAppInput {

    static func write(value: CreateQAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appDefinition"].write(value.appDefinition, with: QAppsClientTypes.AppDefinitionInput.write(value:to:))
        try writer["description"].write(value.description)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["title"].write(value.title)
    }
}

extension DeleteLibraryItemInput {

    static func write(value: DeleteLibraryItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["libraryItemId"].write(value.libraryItemId)
    }
}

extension DeleteQAppInput {

    static func write(value: DeleteQAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension DisassociateLibraryItemReviewInput {

    static func write(value: DisassociateLibraryItemReviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["libraryItemId"].write(value.libraryItemId)
    }
}

extension DisassociateQAppFromUserInput {

    static func write(value: DisassociateQAppFromUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension ExportQAppSessionDataInput {

    static func write(value: ExportQAppSessionDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sessionId"].write(value.sessionId)
    }
}

extension ImportDocumentInput {

    static func write(value: ImportDocumentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["cardId"].write(value.cardId)
        try writer["fileContentsBase64"].write(value.fileContentsBase64)
        try writer["fileName"].write(value.fileName)
        try writer["scope"].write(value.scope)
        try writer["sessionId"].write(value.sessionId)
    }
}

extension PredictQAppInput {

    static func write(value: PredictQAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["options"].write(value.options, with: QAppsClientTypes.PredictQAppInputOptions.write(value:to:))
    }
}

extension StartQAppSessionInput {

    static func write(value: StartQAppSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["appVersion"].write(value.appVersion)
        try writer["initialValues"].writeList(value.initialValues, memberWritingClosure: QAppsClientTypes.CardValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sessionId"].write(value.sessionId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StopQAppSessionInput {

    static func write(value: StopQAppSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sessionId"].write(value.sessionId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateLibraryItemInput {

    static func write(value: UpdateLibraryItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["categories"].writeList(value.categories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["libraryItemId"].write(value.libraryItemId)
        try writer["status"].write(value.status)
    }
}

extension UpdateLibraryItemMetadataInput {

    static func write(value: UpdateLibraryItemMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["isVerified"].write(value.isVerified)
        try writer["libraryItemId"].write(value.libraryItemId)
    }
}

extension UpdateQAppInput {

    static func write(value: UpdateQAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appDefinition"].write(value.appDefinition, with: QAppsClientTypes.AppDefinitionInput.write(value:to:))
        try writer["appId"].write(value.appId)
        try writer["description"].write(value.description)
        try writer["title"].write(value.title)
    }
}

extension UpdateQAppPermissionsInput {

    static func write(value: UpdateQAppPermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["grantPermissions"].writeList(value.grantPermissions, memberWritingClosure: QAppsClientTypes.PermissionInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["revokePermissions"].writeList(value.revokePermissions, memberWritingClosure: QAppsClientTypes.PermissionInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateQAppSessionInput {

    static func write(value: UpdateQAppSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sessionId"].write(value.sessionId)
        try writer["values"].writeList(value.values, memberWritingClosure: QAppsClientTypes.CardValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateQAppSessionMetadataInput {

    static func write(value: UpdateQAppSessionMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sessionId"].write(value.sessionId)
        try writer["sessionName"].write(value.sessionName)
        try writer["sharingConfiguration"].write(value.sharingConfiguration, with: QAppsClientTypes.SessionSharingConfiguration.write(value:to:))
    }
}

extension AssociateLibraryItemReviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateLibraryItemReviewOutput {
        return AssociateLibraryItemReviewOutput()
    }
}

extension AssociateQAppWithUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateQAppWithUserOutput {
        return AssociateQAppWithUserOutput()
    }
}

extension BatchCreateCategoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateCategoryOutput {
        return BatchCreateCategoryOutput()
    }
}

extension BatchDeleteCategoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteCategoryOutput {
        return BatchDeleteCategoryOutput()
    }
}

extension BatchUpdateCategoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateCategoryOutput {
        return BatchUpdateCategoryOutput()
    }
}

extension CreateLibraryItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLibraryItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLibraryItemOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.isVerified = try reader["isVerified"].readIfPresent()
        value.libraryItemId = try reader["libraryItemId"].readIfPresent() ?? ""
        value.ratingCount = try reader["ratingCount"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension CreatePresignedUrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePresignedUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePresignedUrlOutput()
        value.fileId = try reader["fileId"].readIfPresent() ?? ""
        value.presignedUrl = try reader["presignedUrl"].readIfPresent() ?? ""
        value.presignedUrlExpiration = try reader["presignedUrlExpiration"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.presignedUrlFields = try reader["presignedUrlFields"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension CreateQAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateQAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateQAppOutput()
        value.appArn = try reader["appArn"].readIfPresent() ?? ""
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appVersion = try reader["appVersion"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.initialPrompt = try reader["initialPrompt"].readIfPresent()
        value.requiredCapabilities = try reader["requiredCapabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QAppsClientTypes.AppRequiredCapability>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["title"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteLibraryItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLibraryItemOutput {
        return DeleteLibraryItemOutput()
    }
}

extension DeleteQAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteQAppOutput {
        return DeleteQAppOutput()
    }
}

extension DescribeQAppPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeQAppPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeQAppPermissionsOutput()
        value.appId = try reader["appId"].readIfPresent()
        value.permissions = try reader["permissions"].readListIfPresent(memberReadingClosure: QAppsClientTypes.PermissionOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        return value
    }
}

extension DisassociateLibraryItemReviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateLibraryItemReviewOutput {
        return DisassociateLibraryItemReviewOutput()
    }
}

extension DisassociateQAppFromUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateQAppFromUserOutput {
        return DisassociateQAppFromUserOutput()
    }
}

extension ExportQAppSessionDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExportQAppSessionDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExportQAppSessionDataOutput()
        value.csvFileLink = try reader["csvFileLink"].readIfPresent() ?? ""
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        return value
    }
}

extension GetLibraryItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLibraryItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLibraryItemOutput()
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appVersion = try reader["appVersion"].readIfPresent() ?? 0
        value.categories = try reader["categories"].readListIfPresent(memberReadingClosure: QAppsClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.isRatedByUser = try reader["isRatedByUser"].readIfPresent()
        value.isVerified = try reader["isVerified"].readIfPresent()
        value.libraryItemId = try reader["libraryItemId"].readIfPresent() ?? ""
        value.ratingCount = try reader["ratingCount"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.userCount = try reader["userCount"].readIfPresent()
        return value
    }
}

extension GetQAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQAppOutput()
        value.appArn = try reader["appArn"].readIfPresent() ?? ""
        value.appDefinition = try reader["appDefinition"].readIfPresent(with: QAppsClientTypes.AppDefinition.read(from:))
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appVersion = try reader["appVersion"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.initialPrompt = try reader["initialPrompt"].readIfPresent()
        value.requiredCapabilities = try reader["requiredCapabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QAppsClientTypes.AppRequiredCapability>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["title"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent() ?? ""
        return value
    }
}

extension GetQAppSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQAppSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQAppSessionOutput()
        value.appVersion = try reader["appVersion"].readIfPresent()
        value.cardStatus = try reader["cardStatus"].readMapIfPresent(valueReadingClosure: QAppsClientTypes.CardStatus.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.latestPublishedAppVersion = try reader["latestPublishedAppVersion"].readIfPresent()
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.sessionName = try reader["sessionName"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.userIsHost = try reader["userIsHost"].readIfPresent()
        return value
    }
}

extension GetQAppSessionMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQAppSessionMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQAppSessionMetadataOutput()
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.sessionName = try reader["sessionName"].readIfPresent()
        value.sessionOwner = try reader["sessionOwner"].readIfPresent()
        value.sharingConfiguration = try reader["sharingConfiguration"].readIfPresent(with: QAppsClientTypes.SessionSharingConfiguration.read(from:))
        return value
    }
}

extension ImportDocumentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportDocumentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportDocumentOutput()
        value.fileId = try reader["fileId"].readIfPresent()
        return value
    }
}

extension ListCategoriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCategoriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCategoriesOutput()
        value.categories = try reader["categories"].readListIfPresent(memberReadingClosure: QAppsClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListLibraryItemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLibraryItemsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLibraryItemsOutput()
        value.libraryItems = try reader["libraryItems"].readListIfPresent(memberReadingClosure: QAppsClientTypes.LibraryItemMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListQAppsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQAppsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQAppsOutput()
        value.apps = try reader["apps"].readListIfPresent(memberReadingClosure: QAppsClientTypes.UserAppItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListQAppSessionDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQAppSessionDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQAppSessionDataOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionData = try reader["sessionData"].readListIfPresent(memberReadingClosure: QAppsClientTypes.QAppSessionData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PredictQAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PredictQAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PredictQAppOutput()
        value.app = try reader["app"].readIfPresent(with: QAppsClientTypes.PredictAppDefinition.read(from:))
        value.problemStatement = try reader["problemStatement"].readIfPresent() ?? ""
        return value
    }
}

extension StartQAppSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartQAppSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartQAppSessionOutput()
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension StopQAppSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopQAppSessionOutput {
        return StopQAppSessionOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateLibraryItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLibraryItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLibraryItemOutput()
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appVersion = try reader["appVersion"].readIfPresent() ?? 0
        value.categories = try reader["categories"].readListIfPresent(memberReadingClosure: QAppsClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.isRatedByUser = try reader["isRatedByUser"].readIfPresent()
        value.isVerified = try reader["isVerified"].readIfPresent()
        value.libraryItemId = try reader["libraryItemId"].readIfPresent() ?? ""
        value.ratingCount = try reader["ratingCount"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.userCount = try reader["userCount"].readIfPresent()
        return value
    }
}

extension UpdateLibraryItemMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLibraryItemMetadataOutput {
        return UpdateLibraryItemMetadataOutput()
    }
}

extension UpdateQAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateQAppOutput()
        value.appArn = try reader["appArn"].readIfPresent() ?? ""
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appVersion = try reader["appVersion"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.initialPrompt = try reader["initialPrompt"].readIfPresent()
        value.requiredCapabilities = try reader["requiredCapabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QAppsClientTypes.AppRequiredCapability>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["title"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateQAppPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQAppPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateQAppPermissionsOutput()
        value.appId = try reader["appId"].readIfPresent()
        value.permissions = try reader["permissions"].readListIfPresent(memberReadingClosure: QAppsClientTypes.PermissionOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        return value
    }
}

extension UpdateQAppSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQAppSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateQAppSessionOutput()
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateQAppSessionMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQAppSessionMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateQAppSessionMetadataOutput()
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.sessionName = try reader["sessionName"].readIfPresent()
        value.sharingConfiguration = try reader["sharingConfiguration"].readIfPresent(with: QAppsClientTypes.SessionSharingConfiguration.read(from:))
        return value
    }
}

enum AssociateLibraryItemReviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateQAppWithUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchCreateCategoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteCategoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateCategoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLibraryItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePresignedUrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateQAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ContentTooLargeException": return try ContentTooLargeException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLibraryItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteQAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeQAppPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateLibraryItemReviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateQAppFromUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExportQAppSessionDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLibraryItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQAppSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQAppSessionMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportDocumentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ContentTooLargeException": return try ContentTooLargeException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCategoriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLibraryItemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQAppsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQAppSessionDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PredictQAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartQAppSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopQAppSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLibraryItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLibraryItemMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ContentTooLargeException": return try ContentTooLargeException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQAppPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQAppSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQAppSessionMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ContentTooLargeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ContentTooLargeException {
        let reader = baseError.errorBodyReader
        var value = ContentTooLargeException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QAppsClientTypes.PermissionOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.PermissionOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.PermissionOutput()
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.principal = try reader["principal"].readIfPresent(with: QAppsClientTypes.PrincipalOutput.read(from:))
        return value
    }
}

extension QAppsClientTypes.PrincipalOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.PrincipalOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.PrincipalOutput()
        value.userId = try reader["userId"].readIfPresent()
        value.userType = try reader["userType"].readIfPresent()
        value.email = try reader["email"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.Category {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.Category {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.Category()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.color = try reader["color"].readIfPresent()
        value.appCount = try reader["appCount"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.AppDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.AppDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.AppDefinition()
        value.appDefinitionVersion = try reader["appDefinitionVersion"].readIfPresent() ?? ""
        value.cards = try reader["cards"].readListIfPresent(memberReadingClosure: QAppsClientTypes.Card.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.canEdit = try reader["canEdit"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.Card {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.Card {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "textInput":
                return .textinput(try reader["textInput"].read(with: QAppsClientTypes.TextInputCard.read(from:)))
            case "qQuery":
                return .qquery(try reader["qQuery"].read(with: QAppsClientTypes.QQueryCard.read(from:)))
            case "qPlugin":
                return .qplugin(try reader["qPlugin"].read(with: QAppsClientTypes.QPluginCard.read(from:)))
            case "fileUpload":
                return .fileupload(try reader["fileUpload"].read(with: QAppsClientTypes.FileUploadCard.read(from:)))
            case "formInput":
                return .forminput(try reader["formInput"].read(with: QAppsClientTypes.FormInputCard.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QAppsClientTypes.FormInputCard {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.FormInputCard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.FormInputCard()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.dependencies = try reader["dependencies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.metadata = try reader["metadata"].readIfPresent(with: QAppsClientTypes.FormInputCardMetadata.read(from:))
        value.computeMode = try reader["computeMode"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.FormInputCardMetadata {

    static func write(value: QAppsClientTypes.FormInputCardMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["schema"].write(value.schema)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.FormInputCardMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.FormInputCardMetadata()
        value.schema = try reader["schema"].readIfPresent() ?? [:]
        return value
    }
}

extension QAppsClientTypes.FileUploadCard {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.FileUploadCard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.FileUploadCard()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.dependencies = try reader["dependencies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.filename = try reader["filename"].readIfPresent()
        value.fileId = try reader["fileId"].readIfPresent()
        value.allowOverride = try reader["allowOverride"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.QPluginCard {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.QPluginCard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.QPluginCard()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.dependencies = try reader["dependencies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.prompt = try reader["prompt"].readIfPresent() ?? ""
        value.pluginType = try reader["pluginType"].readIfPresent() ?? .sdkUnknown("")
        value.pluginId = try reader["pluginId"].readIfPresent() ?? ""
        value.actionIdentifier = try reader["actionIdentifier"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.QQueryCard {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.QQueryCard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.QQueryCard()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.dependencies = try reader["dependencies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.prompt = try reader["prompt"].readIfPresent() ?? ""
        value.outputSource = try reader["outputSource"].readIfPresent() ?? .sdkUnknown("")
        value.attributeFilter = try reader["attributeFilter"].readIfPresent(with: QAppsClientTypes.AttributeFilter.read(from:))
        value.memoryReferences = try reader["memoryReferences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QAppsClientTypes.AttributeFilter {

    static func write(value: QAppsClientTypes.AttributeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["andAllFilters"].writeList(value.andAllFilters, memberWritingClosure: QAppsClientTypes.AttributeFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["containsAll"].write(value.containsAll, with: QAppsClientTypes.DocumentAttribute.write(value:to:))
        try writer["containsAny"].write(value.containsAny, with: QAppsClientTypes.DocumentAttribute.write(value:to:))
        try writer["equalsTo"].write(value.equalsTo, with: QAppsClientTypes.DocumentAttribute.write(value:to:))
        try writer["greaterThan"].write(value.greaterThan, with: QAppsClientTypes.DocumentAttribute.write(value:to:))
        try writer["greaterThanOrEquals"].write(value.greaterThanOrEquals, with: QAppsClientTypes.DocumentAttribute.write(value:to:))
        try writer["lessThan"].write(value.lessThan, with: QAppsClientTypes.DocumentAttribute.write(value:to:))
        try writer["lessThanOrEquals"].write(value.lessThanOrEquals, with: QAppsClientTypes.DocumentAttribute.write(value:to:))
        try writer["notFilter"].write(value.notFilter, with: QAppsClientTypes.AttributeFilter.write(value:to:))
        try writer["orAllFilters"].writeList(value.orAllFilters, memberWritingClosure: QAppsClientTypes.AttributeFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.AttributeFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.AttributeFilter()
        value.andAllFilters = try reader["andAllFilters"].readListIfPresent(memberReadingClosure: QAppsClientTypes.AttributeFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.orAllFilters = try reader["orAllFilters"].readListIfPresent(memberReadingClosure: QAppsClientTypes.AttributeFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.notFilter = try reader["notFilter"].readIfPresent(with: QAppsClientTypes.AttributeFilter.read(from:))
        value.equalsTo = try reader["equalsTo"].readIfPresent(with: QAppsClientTypes.DocumentAttribute.read(from:))
        value.containsAll = try reader["containsAll"].readIfPresent(with: QAppsClientTypes.DocumentAttribute.read(from:))
        value.containsAny = try reader["containsAny"].readIfPresent(with: QAppsClientTypes.DocumentAttribute.read(from:))
        value.greaterThan = try reader["greaterThan"].readIfPresent(with: QAppsClientTypes.DocumentAttribute.read(from:))
        value.greaterThanOrEquals = try reader["greaterThanOrEquals"].readIfPresent(with: QAppsClientTypes.DocumentAttribute.read(from:))
        value.lessThan = try reader["lessThan"].readIfPresent(with: QAppsClientTypes.DocumentAttribute.read(from:))
        value.lessThanOrEquals = try reader["lessThanOrEquals"].readIfPresent(with: QAppsClientTypes.DocumentAttribute.read(from:))
        return value
    }
}

extension QAppsClientTypes.DocumentAttribute {

    static func write(value: QAppsClientTypes.DocumentAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value, with: QAppsClientTypes.DocumentAttributeValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.DocumentAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.DocumentAttribute()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent(with: QAppsClientTypes.DocumentAttributeValue.read(from:))
        return value
    }
}

extension QAppsClientTypes.DocumentAttributeValue {

    static func write(value: QAppsClientTypes.DocumentAttributeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .datevalue(datevalue):
                try writer["dateValue"].writeTimestamp(datevalue, format: SmithyTimestamps.TimestampFormat.epochSeconds)
            case let .longvalue(longvalue):
                try writer["longValue"].write(longvalue)
            case let .stringlistvalue(stringlistvalue):
                try writer["stringListValue"].writeList(stringlistvalue, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .stringvalue(stringvalue):
                try writer["stringValue"].write(stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.DocumentAttributeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "stringValue":
                return .stringvalue(try reader["stringValue"].read())
            case "stringListValue":
                return .stringlistvalue(try reader["stringListValue"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false))
            case "longValue":
                return .longvalue(try reader["longValue"].read())
            case "dateValue":
                return .datevalue(try reader["dateValue"].readTimestamp(format: SmithyTimestamps.TimestampFormat.epochSeconds))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QAppsClientTypes.TextInputCard {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.TextInputCard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.TextInputCard()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.dependencies = try reader["dependencies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.placeholder = try reader["placeholder"].readIfPresent()
        value.defaultValue = try reader["defaultValue"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.CardStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.CardStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.CardStatus()
        value.currentState = try reader["currentState"].readIfPresent() ?? .sdkUnknown("")
        value.currentValue = try reader["currentValue"].readIfPresent() ?? ""
        value.submissions = try reader["submissions"].readListIfPresent(memberReadingClosure: QAppsClientTypes.Submission.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QAppsClientTypes.Submission {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.Submission {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.Submission()
        value.value = try reader["value"].readIfPresent()
        value.submissionId = try reader["submissionId"].readIfPresent()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension QAppsClientTypes.SessionSharingConfiguration {

    static func write(value: QAppsClientTypes.SessionSharingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["acceptResponses"].write(value.acceptResponses)
        try writer["enabled"].write(value.enabled)
        try writer["revealCards"].write(value.revealCards)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.SessionSharingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.SessionSharingConfiguration()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        value.acceptResponses = try reader["acceptResponses"].readIfPresent()
        value.revealCards = try reader["revealCards"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.LibraryItemMember {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.LibraryItemMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.LibraryItemMember()
        value.libraryItemId = try reader["libraryItemId"].readIfPresent() ?? ""
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appVersion = try reader["appVersion"].readIfPresent() ?? 0
        value.categories = try reader["categories"].readListIfPresent(memberReadingClosure: QAppsClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.ratingCount = try reader["ratingCount"].readIfPresent() ?? 0
        value.isRatedByUser = try reader["isRatedByUser"].readIfPresent()
        value.userCount = try reader["userCount"].readIfPresent()
        value.isVerified = try reader["isVerified"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.UserAppItem {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.UserAppItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.UserAppItem()
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appArn = try reader["appArn"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.canEdit = try reader["canEdit"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.isVerified = try reader["isVerified"].readIfPresent() ?? false
        return value
    }
}

extension QAppsClientTypes.QAppSessionData {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.QAppSessionData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.QAppSessionData()
        value.cardId = try reader["cardId"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent()
        value.user = try reader["user"].readIfPresent(with: QAppsClientTypes.User.read(from:))
        value.submissionId = try reader["submissionId"].readIfPresent()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension QAppsClientTypes.User {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.User {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.User()
        value.userId = try reader["userId"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.PredictAppDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.PredictAppDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.PredictAppDefinition()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.appDefinition = try reader["appDefinition"].readIfPresent(with: QAppsClientTypes.AppDefinitionInput.read(from:))
        return value
    }
}

extension QAppsClientTypes.AppDefinitionInput {

    static func write(value: QAppsClientTypes.AppDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cards"].writeList(value.cards, memberWritingClosure: QAppsClientTypes.CardInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["initialPrompt"].write(value.initialPrompt)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.AppDefinitionInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.AppDefinitionInput()
        value.cards = try reader["cards"].readListIfPresent(memberReadingClosure: QAppsClientTypes.CardInput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.initialPrompt = try reader["initialPrompt"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.CardInput {

    static func write(value: QAppsClientTypes.CardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .fileupload(fileupload):
                try writer["fileUpload"].write(fileupload, with: QAppsClientTypes.FileUploadCardInput.write(value:to:))
            case let .forminput(forminput):
                try writer["formInput"].write(forminput, with: QAppsClientTypes.FormInputCardInput.write(value:to:))
            case let .qplugin(qplugin):
                try writer["qPlugin"].write(qplugin, with: QAppsClientTypes.QPluginCardInput.write(value:to:))
            case let .qquery(qquery):
                try writer["qQuery"].write(qquery, with: QAppsClientTypes.QQueryCardInput.write(value:to:))
            case let .textinput(textinput):
                try writer["textInput"].write(textinput, with: QAppsClientTypes.TextInputCardInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.CardInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "textInput":
                return .textinput(try reader["textInput"].read(with: QAppsClientTypes.TextInputCardInput.read(from:)))
            case "qQuery":
                return .qquery(try reader["qQuery"].read(with: QAppsClientTypes.QQueryCardInput.read(from:)))
            case "qPlugin":
                return .qplugin(try reader["qPlugin"].read(with: QAppsClientTypes.QPluginCardInput.read(from:)))
            case "fileUpload":
                return .fileupload(try reader["fileUpload"].read(with: QAppsClientTypes.FileUploadCardInput.read(from:)))
            case "formInput":
                return .forminput(try reader["formInput"].read(with: QAppsClientTypes.FormInputCardInput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QAppsClientTypes.FormInputCardInput {

    static func write(value: QAppsClientTypes.FormInputCardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["computeMode"].write(value.computeMode)
        try writer["id"].write(value.id)
        try writer["metadata"].write(value.metadata, with: QAppsClientTypes.FormInputCardMetadata.write(value:to:))
        try writer["title"].write(value.title)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.FormInputCardInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.FormInputCardInput()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .formInput
        value.metadata = try reader["metadata"].readIfPresent(with: QAppsClientTypes.FormInputCardMetadata.read(from:))
        value.computeMode = try reader["computeMode"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.FileUploadCardInput {

    static func write(value: QAppsClientTypes.FileUploadCardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowOverride"].write(value.allowOverride)
        try writer["fileId"].write(value.fileId)
        try writer["filename"].write(value.filename)
        try writer["id"].write(value.id)
        try writer["title"].write(value.title)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.FileUploadCardInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.FileUploadCardInput()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .fileUpload
        value.filename = try reader["filename"].readIfPresent()
        value.fileId = try reader["fileId"].readIfPresent()
        value.allowOverride = try reader["allowOverride"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.QPluginCardInput {

    static func write(value: QAppsClientTypes.QPluginCardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionIdentifier"].write(value.actionIdentifier)
        try writer["id"].write(value.id)
        try writer["pluginId"].write(value.pluginId)
        try writer["prompt"].write(value.prompt)
        try writer["title"].write(value.title)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.QPluginCardInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.QPluginCardInput()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .qPlugin
        value.prompt = try reader["prompt"].readIfPresent() ?? ""
        value.pluginId = try reader["pluginId"].readIfPresent() ?? ""
        value.actionIdentifier = try reader["actionIdentifier"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.QQueryCardInput {

    static func write(value: QAppsClientTypes.QQueryCardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributeFilter"].write(value.attributeFilter, with: QAppsClientTypes.AttributeFilter.write(value:to:))
        try writer["id"].write(value.id)
        try writer["outputSource"].write(value.outputSource)
        try writer["prompt"].write(value.prompt)
        try writer["title"].write(value.title)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.QQueryCardInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.QQueryCardInput()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .qQuery
        value.prompt = try reader["prompt"].readIfPresent() ?? ""
        value.outputSource = try reader["outputSource"].readIfPresent() ?? .approvedSources
        value.attributeFilter = try reader["attributeFilter"].readIfPresent(with: QAppsClientTypes.AttributeFilter.read(from:))
        return value
    }
}

extension QAppsClientTypes.TextInputCardInput {

    static func write(value: QAppsClientTypes.TextInputCardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultValue"].write(value.defaultValue)
        try writer["id"].write(value.id)
        try writer["placeholder"].write(value.placeholder)
        try writer["title"].write(value.title)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QAppsClientTypes.TextInputCardInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QAppsClientTypes.TextInputCardInput()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .textInput
        value.placeholder = try reader["placeholder"].readIfPresent()
        value.defaultValue = try reader["defaultValue"].readIfPresent()
        return value
    }
}

extension QAppsClientTypes.BatchCreateCategoryInputCategory {

    static func write(value: QAppsClientTypes.BatchCreateCategoryInputCategory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["color"].write(value.color)
        try writer["id"].write(value.id)
        try writer["title"].write(value.title)
    }
}

extension QAppsClientTypes.CategoryInput {

    static func write(value: QAppsClientTypes.CategoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["color"].write(value.color)
        try writer["id"].write(value.id)
        try writer["title"].write(value.title)
    }
}

extension QAppsClientTypes.PredictQAppInputOptions {

    static func write(value: QAppsClientTypes.PredictQAppInputOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .conversation(conversation):
                try writer["conversation"].writeList(conversation, memberWritingClosure: QAppsClientTypes.ConversationMessage.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .problemstatement(problemstatement):
                try writer["problemStatement"].write(problemstatement)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension QAppsClientTypes.ConversationMessage {

    static func write(value: QAppsClientTypes.ConversationMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
        try writer["type"].write(value.type)
    }
}

extension QAppsClientTypes.CardValue {

    static func write(value: QAppsClientTypes.CardValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cardId"].write(value.cardId)
        try writer["submissionMutation"].write(value.submissionMutation, with: QAppsClientTypes.SubmissionMutation.write(value:to:))
        try writer["value"].write(value.value)
    }
}

extension QAppsClientTypes.SubmissionMutation {

    static func write(value: QAppsClientTypes.SubmissionMutation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mutationType"].write(value.mutationType)
        try writer["submissionId"].write(value.submissionId)
    }
}

extension QAppsClientTypes.PermissionInput {

    static func write(value: QAppsClientTypes.PermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["principal"].write(value.principal)
    }
}

public enum QAppsClientTypes {}
