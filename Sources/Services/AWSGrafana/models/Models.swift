// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GrafanaClientTypes {
    public enum AccountAccessType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates that the customer is using Grafana to monitor resources in their current account.
        case currentAccount
        /// Indicates that the customer is using Grafana to monitor resources in organizational units.
        case organization
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountAccessType] {
            return [
                .currentAccount,
                .organization,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .currentAccount: return "CURRENT_ACCOUNT"
            case .organization: return "ORGANIZATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountAccessType(rawValue: rawValue) ?? AccountAccessType.sdkUnknown(rawValue)
        }
    }
}

extension GrafanaClientTypes.AssertionAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email
        case groups
        case login
        case name
        case org
        case role
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let groups = self.groups {
            try encodeContainer.encode(groups, forKey: .groups)
        }
        if let login = self.login {
            try encodeContainer.encode(login, forKey: .login)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let org = self.org {
            try encodeContainer.encode(org, forKey: .org)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let loginDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .login)
        login = loginDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let groupsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groups)
        groups = groupsDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let orgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .org)
        org = orgDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure that defines which attributes in the IdP assertion are to be used to define information about the users authenticated by the IdP to use the workspace.
    public struct AssertionAttributes: Swift.Equatable {
        /// The name of the attribute within the SAML assertion to use as the email names for SAML users.
        public var email: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the user full "friendly" names for user groups.
        public var groups: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the login names for SAML users.
        public var login: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the user full "friendly" names for SAML users.
        public var name: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the user full "friendly" names for the users' organizations.
        public var org: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the user roles.
        public var role: Swift.String?

        public init(
            email: Swift.String? = nil,
            groups: Swift.String? = nil,
            login: Swift.String? = nil,
            name: Swift.String? = nil,
            org: Swift.String? = nil,
            role: Swift.String? = nil
        )
        {
            self.email = email
            self.groups = groups
            self.login = login
            self.name = name
            self.org = org
            self.role = role
        }
    }

}

extension AssociateLicenseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let licenseType = licenseType else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/licenses/\(licenseType.rawValue.urlPercentEncoding())"
    }
}

public struct AssociateLicenseInput: Swift.Equatable {
    /// The type of license to associate with the workspace.
    /// This member is required.
    public var licenseType: GrafanaClientTypes.LicenseType?
    /// The ID of the workspace to associate the license with.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        licenseType: GrafanaClientTypes.LicenseType? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.licenseType = licenseType
        self.workspaceId = workspaceId
    }
}

struct AssociateLicenseInputBody: Swift.Equatable {
}

extension AssociateLicenseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssociateLicenseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateLicenseOutputBody = try responseDecoder.decode(responseBody: data)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

public struct AssociateLicenseOutput: Swift.Equatable {
    /// A structure containing data about the workspace.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init(
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct AssociateLicenseOutputBody: Swift.Equatable {
    let workspace: GrafanaClientTypes.WorkspaceDescription?
}

extension AssociateLicenseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

enum AssociateLicenseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GrafanaClientTypes.AuthenticationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsSso
        case providers
        case saml
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsSso = self.awsSso {
            try encodeContainer.encode(awsSso, forKey: .awsSso)
        }
        if let providers = providers {
            var providersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .providers)
            for authenticationprovidertypes0 in providers {
                try providersContainer.encode(authenticationprovidertypes0.rawValue)
            }
        }
        if let saml = self.saml {
            try encodeContainer.encode(saml, forKey: .saml)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providersContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.AuthenticationProviderTypes?].self, forKey: .providers)
        var providersDecoded0:[GrafanaClientTypes.AuthenticationProviderTypes]? = nil
        if let providersContainer = providersContainer {
            providersDecoded0 = [GrafanaClientTypes.AuthenticationProviderTypes]()
            for string0 in providersContainer {
                if let string0 = string0 {
                    providersDecoded0?.append(string0)
                }
            }
        }
        providers = providersDecoded0
        let samlDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.SamlAuthentication.self, forKey: .saml)
        saml = samlDecoded
        let awsSsoDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AwsSsoAuthentication.self, forKey: .awsSso)
        awsSso = awsSsoDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure containing information about the user authentication methods used by the workspace.
    public struct AuthenticationDescription: Swift.Equatable {
        /// A structure containing information about how this workspace works with IAM Identity Center.
        public var awsSso: GrafanaClientTypes.AwsSsoAuthentication?
        /// Specifies whether this workspace uses IAM Identity Center, SAML, or both methods to authenticate users to use the Grafana console in the Amazon Managed Grafana workspace.
        /// This member is required.
        public var providers: [GrafanaClientTypes.AuthenticationProviderTypes]?
        /// A structure containing information about how this workspace works with SAML, including what attributes within the assertion are to be mapped to user information in the workspace.
        public var saml: GrafanaClientTypes.SamlAuthentication?

        public init(
            awsSso: GrafanaClientTypes.AwsSsoAuthentication? = nil,
            providers: [GrafanaClientTypes.AuthenticationProviderTypes]? = nil,
            saml: GrafanaClientTypes.SamlAuthentication? = nil
        )
        {
            self.awsSso = awsSso
            self.providers = providers
            self.saml = saml
        }
    }

}

extension GrafanaClientTypes {
    public enum AuthenticationProviderTypes: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates that AMG workspace has AWS SSO enabled as its authentication provider.
        case awsSso
        /// Indicates that the AMG workspace has SAML enabled as its authentication provider.
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationProviderTypes] {
            return [
                .awsSso,
                .saml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsSso: return "AWS_SSO"
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationProviderTypes(rawValue: rawValue) ?? AuthenticationProviderTypes.sdkUnknown(rawValue)
        }
    }
}

extension GrafanaClientTypes.AuthenticationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case providers
        case samlConfigurationStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let providers = providers {
            var providersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .providers)
            for authenticationprovidertypes0 in providers {
                try providersContainer.encode(authenticationprovidertypes0.rawValue)
            }
        }
        if let samlConfigurationStatus = self.samlConfigurationStatus {
            try encodeContainer.encode(samlConfigurationStatus.rawValue, forKey: .samlConfigurationStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providersContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.AuthenticationProviderTypes?].self, forKey: .providers)
        var providersDecoded0:[GrafanaClientTypes.AuthenticationProviderTypes]? = nil
        if let providersContainer = providersContainer {
            providersDecoded0 = [GrafanaClientTypes.AuthenticationProviderTypes]()
            for string0 in providersContainer {
                if let string0 = string0 {
                    providersDecoded0?.append(string0)
                }
            }
        }
        providers = providersDecoded0
        let samlConfigurationStatusDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.SamlConfigurationStatus.self, forKey: .samlConfigurationStatus)
        samlConfigurationStatus = samlConfigurationStatusDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure that describes whether the workspace uses SAML, IAM Identity Center, or both methods for user authentication, and whether that authentication is fully configured.
    public struct AuthenticationSummary: Swift.Equatable {
        /// Specifies whether the workspace uses SAML, IAM Identity Center, or both methods for user authentication.
        /// This member is required.
        public var providers: [GrafanaClientTypes.AuthenticationProviderTypes]?
        /// Specifies whether the workplace's user authentication method is fully configured.
        public var samlConfigurationStatus: GrafanaClientTypes.SamlConfigurationStatus?

        public init(
            providers: [GrafanaClientTypes.AuthenticationProviderTypes]? = nil,
            samlConfigurationStatus: GrafanaClientTypes.SamlConfigurationStatus? = nil
        )
        {
            self.providers = providers
            self.samlConfigurationStatus = samlConfigurationStatus
        }
    }

}

extension GrafanaClientTypes.AwsSsoAuthentication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ssoClientId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ssoClientId = self.ssoClientId {
            try encodeContainer.encode(ssoClientId, forKey: .ssoClientId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ssoClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssoClientId)
        ssoClientId = ssoClientIdDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure containing information about how this workspace works with IAM Identity Center.
    public struct AwsSsoAuthentication: Swift.Equatable {
        /// The ID of the IAM Identity Center-managed application that is created by Amazon Managed Grafana.
        public var ssoClientId: Swift.String?

        public init(
            ssoClientId: Swift.String? = nil
        )
        {
            self.ssoClientId = ssoClientId
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource was in an inconsistent state during an update or a deletion.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateWorkspaceApiKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyName
        case keyRole
        case secondsToLive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyName = self.keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let keyRole = self.keyRole {
            try encodeContainer.encode(keyRole, forKey: .keyRole)
        }
        if let secondsToLive = self.secondsToLive {
            try encodeContainer.encode(secondsToLive, forKey: .secondsToLive)
        }
    }
}

extension CreateWorkspaceApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/apikeys"
    }
}

public struct CreateWorkspaceApiKeyInput: Swift.Equatable {
    /// Specifies the name of the key. Keynames must be unique to the workspace.
    /// This member is required.
    public var keyName: Swift.String?
    /// Specifies the permission level of the key. Valid values: VIEWER|EDITOR|ADMIN
    /// This member is required.
    public var keyRole: Swift.String?
    /// Specifies the time in seconds until the key expires. Keys can be valid for up to 30 days.
    /// This member is required.
    public var secondsToLive: Swift.Int?
    /// The ID of the workspace to create an API key.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        keyName: Swift.String? = nil,
        keyRole: Swift.String? = nil,
        secondsToLive: Swift.Int? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.keyName = keyName
        self.keyRole = keyRole
        self.secondsToLive = secondsToLive
        self.workspaceId = workspaceId
    }
}

struct CreateWorkspaceApiKeyInputBody: Swift.Equatable {
    let keyName: Swift.String?
    let keyRole: Swift.String?
    let secondsToLive: Swift.Int?
}

extension CreateWorkspaceApiKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyName
        case keyRole
        case secondsToLive
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let keyRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyRole)
        keyRole = keyRoleDecoded
        let secondsToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondsToLive)
        secondsToLive = secondsToLiveDecoded
    }
}

extension CreateWorkspaceApiKeyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkspaceApiKeyOutput(keyName: \(Swift.String(describing: keyName)), workspaceId: \(Swift.String(describing: workspaceId)), key: \"CONTENT_REDACTED\")"}
}

extension CreateWorkspaceApiKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkspaceApiKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.key = output.key
            self.keyName = output.keyName
            self.workspaceId = output.workspaceId
        } else {
            self.key = nil
            self.keyName = nil
            self.workspaceId = nil
        }
    }
}

public struct CreateWorkspaceApiKeyOutput: Swift.Equatable {
    /// The key token. Use this value as a bearer token to authenticate HTTP requests to the workspace.
    /// This member is required.
    public var key: Swift.String?
    /// The name of the key that was created.
    /// This member is required.
    public var keyName: Swift.String?
    /// The ID of the workspace that the key is valid for.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        key: Swift.String? = nil,
        keyName: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.key = key
        self.keyName = keyName
        self.workspaceId = workspaceId
    }
}

struct CreateWorkspaceApiKeyOutputBody: Swift.Equatable {
    let keyName: Swift.String?
    let key: Swift.String?
    let workspaceId: Swift.String?
}

extension CreateWorkspaceApiKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case keyName
        case workspaceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

enum CreateWorkspaceApiKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkspaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkspaceInput(accountAccessType: \(Swift.String(describing: accountAccessType)), authenticationProviders: \(Swift.String(describing: authenticationProviders)), clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), grafanaVersion: \(Swift.String(describing: grafanaVersion)), networkAccessControl: \(Swift.String(describing: networkAccessControl)), permissionType: \(Swift.String(describing: permissionType)), stackSetName: \(Swift.String(describing: stackSetName)), tags: \(Swift.String(describing: tags)), vpcConfiguration: \(Swift.String(describing: vpcConfiguration)), workspaceDataSources: \(Swift.String(describing: workspaceDataSources)), workspaceNotificationDestinations: \(Swift.String(describing: workspaceNotificationDestinations)), organizationRoleName: \"CONTENT_REDACTED\", workspaceDescription: \"CONTENT_REDACTED\", workspaceName: \"CONTENT_REDACTED\", workspaceOrganizationalUnits: \"CONTENT_REDACTED\", workspaceRoleArn: \"CONTENT_REDACTED\")"}
}

extension CreateWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAccessType
        case authenticationProviders
        case clientToken
        case configuration
        case grafanaVersion
        case networkAccessControl
        case organizationRoleName
        case permissionType
        case stackSetName
        case tags
        case vpcConfiguration
        case workspaceDataSources
        case workspaceDescription
        case workspaceName
        case workspaceNotificationDestinations
        case workspaceOrganizationalUnits
        case workspaceRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAccessType = self.accountAccessType {
            try encodeContainer.encode(accountAccessType.rawValue, forKey: .accountAccessType)
        }
        if let authenticationProviders = authenticationProviders {
            var authenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authenticationProviders)
            for authenticationprovidertypes0 in authenticationProviders {
                try authenticationProvidersContainer.encode(authenticationprovidertypes0.rawValue)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let grafanaVersion = self.grafanaVersion {
            try encodeContainer.encode(grafanaVersion, forKey: .grafanaVersion)
        }
        if let networkAccessControl = self.networkAccessControl {
            try encodeContainer.encode(networkAccessControl, forKey: .networkAccessControl)
        }
        if let organizationRoleName = self.organizationRoleName {
            try encodeContainer.encode(organizationRoleName, forKey: .organizationRoleName)
        }
        if let permissionType = self.permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let stackSetName = self.stackSetName {
            try encodeContainer.encode(stackSetName, forKey: .stackSetName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfiguration = self.vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
        if let workspaceDataSources = workspaceDataSources {
            var workspaceDataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceDataSources)
            for datasourcetype0 in workspaceDataSources {
                try workspaceDataSourcesContainer.encode(datasourcetype0.rawValue)
            }
        }
        if let workspaceDescription = self.workspaceDescription {
            try encodeContainer.encode(workspaceDescription, forKey: .workspaceDescription)
        }
        if let workspaceName = self.workspaceName {
            try encodeContainer.encode(workspaceName, forKey: .workspaceName)
        }
        if let workspaceNotificationDestinations = workspaceNotificationDestinations {
            var workspaceNotificationDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceNotificationDestinations)
            for notificationdestinationtype0 in workspaceNotificationDestinations {
                try workspaceNotificationDestinationsContainer.encode(notificationdestinationtype0.rawValue)
            }
        }
        if let workspaceOrganizationalUnits = workspaceOrganizationalUnits {
            var workspaceOrganizationalUnitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceOrganizationalUnits)
            for organizationalunit0 in workspaceOrganizationalUnits {
                try workspaceOrganizationalUnitsContainer.encode(organizationalunit0)
            }
        }
        if let workspaceRoleArn = self.workspaceRoleArn {
            try encodeContainer.encode(workspaceRoleArn, forKey: .workspaceRoleArn)
        }
    }
}

extension CreateWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workspaces"
    }
}

public struct CreateWorkspaceInput: Swift.Equatable {
    /// Specifies whether the workspace can access Amazon Web Services resources in this Amazon Web Services account only, or whether it can also access Amazon Web Services resources in other accounts in the same organization. If you specify ORGANIZATION, you must specify which organizational units the workspace can access in the workspaceOrganizationalUnits parameter.
    /// This member is required.
    public var accountAccessType: GrafanaClientTypes.AccountAccessType?
    /// Specifies whether this workspace uses SAML 2.0, IAM Identity Center (successor to Single Sign-On), or both to authenticate users for using the Grafana console within a workspace. For more information, see [User authentication in Amazon Managed Grafana](https://docs.aws.amazon.com/grafana/latest/userguide/authentication-in-AMG.html).
    /// This member is required.
    public var authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]?
    /// A unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The configuration string for the workspace that you create. For more information about the format and configuration options available, see [Working in your Grafana workspace](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-configure-workspace.html).
    public var configuration: Swift.String?
    /// Specifies the version of Grafana to support in the new workspace. To get a list of supported version, use the ListVersions operation.
    public var grafanaVersion: Swift.String?
    /// Configuration for network access to your workspace. When this is configured, only listed IP addresses and VPC endpoints will be able to access your workspace. Standard Grafana authentication and authorization will still be required. If this is not configured, or is removed, then all IP addresses and VPC endpoints will be allowed. Standard Grafana authentication and authorization will still be required.
    public var networkAccessControl: GrafanaClientTypes.NetworkAccessConfiguration?
    /// The name of an IAM role that already exists to use with Organizations to access Amazon Web Services data sources and notification channels in other accounts in an organization.
    public var organizationRoleName: Swift.String?
    /// When creating a workspace through the Amazon Web Services API, CLI or Amazon Web Services CloudFormation, you must manage IAM roles and provision the permissions that the workspace needs to use Amazon Web Services data sources and notification channels. You must also specify a workspaceRoleArn for a role that you will manage for the workspace to use when accessing those datasources and notification channels. The ability for Amazon Managed Grafana to create and update IAM roles on behalf of the user is supported only in the Amazon Managed Grafana console, where this value may be set to SERVICE_MANAGED. Use only the CUSTOMER_MANAGED permission type when creating a workspace with the API, CLI or Amazon Web Services CloudFormation. For more information, see [Amazon Managed Grafana permissions and policies for Amazon Web Services data sources and notification channels](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-manage-permissions.html).
    /// This member is required.
    public var permissionType: GrafanaClientTypes.PermissionType?
    /// The name of the CloudFormation stack set to use to generate IAM roles to be used for this workspace.
    public var stackSetName: Swift.String?
    /// The list of tags associated with the workspace.
    public var tags: [Swift.String:Swift.String]?
    /// The configuration settings for an Amazon VPC that contains data sources for your Grafana workspace to connect to. Connecting to a private VPC is not yet available in the Asia Pacific (Seoul) Region (ap-northeast-2).
    public var vpcConfiguration: GrafanaClientTypes.VpcConfiguration?
    /// This parameter is for internal use only, and should not be used.
    public var workspaceDataSources: [GrafanaClientTypes.DataSourceType]?
    /// A description for the workspace. This is used only to help you identify this workspace. Pattern: ^[\\p{L}\\p{Z}\\p{N}\\p{P}]{0,2048}$
    public var workspaceDescription: Swift.String?
    /// The name for the workspace. It does not have to be unique.
    public var workspaceName: Swift.String?
    /// Specify the Amazon Web Services notification channels that you plan to use in this workspace. Specifying these data sources here enables Amazon Managed Grafana to create IAM roles and permissions that allow Amazon Managed Grafana to use these channels.
    public var workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
    /// Specifies the organizational units that this workspace is allowed to use data sources from, if this workspace is in an account that is part of an organization.
    public var workspaceOrganizationalUnits: [Swift.String]?
    /// Specified the IAM role that grants permissions to the Amazon Web Services resources that the workspace will view data from, including both data sources and notification channels. You are responsible for managing the permissions for this role as new data sources or notification channels are added.
    public var workspaceRoleArn: Swift.String?

    public init(
        accountAccessType: GrafanaClientTypes.AccountAccessType? = nil,
        authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]? = nil,
        clientToken: Swift.String? = nil,
        configuration: Swift.String? = nil,
        grafanaVersion: Swift.String? = nil,
        networkAccessControl: GrafanaClientTypes.NetworkAccessConfiguration? = nil,
        organizationRoleName: Swift.String? = nil,
        permissionType: GrafanaClientTypes.PermissionType? = nil,
        stackSetName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfiguration: GrafanaClientTypes.VpcConfiguration? = nil,
        workspaceDataSources: [GrafanaClientTypes.DataSourceType]? = nil,
        workspaceDescription: Swift.String? = nil,
        workspaceName: Swift.String? = nil,
        workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]? = nil,
        workspaceOrganizationalUnits: [Swift.String]? = nil,
        workspaceRoleArn: Swift.String? = nil
    )
    {
        self.accountAccessType = accountAccessType
        self.authenticationProviders = authenticationProviders
        self.clientToken = clientToken
        self.configuration = configuration
        self.grafanaVersion = grafanaVersion
        self.networkAccessControl = networkAccessControl
        self.organizationRoleName = organizationRoleName
        self.permissionType = permissionType
        self.stackSetName = stackSetName
        self.tags = tags
        self.vpcConfiguration = vpcConfiguration
        self.workspaceDataSources = workspaceDataSources
        self.workspaceDescription = workspaceDescription
        self.workspaceName = workspaceName
        self.workspaceNotificationDestinations = workspaceNotificationDestinations
        self.workspaceOrganizationalUnits = workspaceOrganizationalUnits
        self.workspaceRoleArn = workspaceRoleArn
    }
}

struct CreateWorkspaceInputBody: Swift.Equatable {
    let accountAccessType: GrafanaClientTypes.AccountAccessType?
    let clientToken: Swift.String?
    let organizationRoleName: Swift.String?
    let permissionType: GrafanaClientTypes.PermissionType?
    let stackSetName: Swift.String?
    let workspaceDataSources: [GrafanaClientTypes.DataSourceType]?
    let workspaceDescription: Swift.String?
    let workspaceName: Swift.String?
    let workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
    let workspaceOrganizationalUnits: [Swift.String]?
    let workspaceRoleArn: Swift.String?
    let authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]?
    let tags: [Swift.String:Swift.String]?
    let vpcConfiguration: GrafanaClientTypes.VpcConfiguration?
    let configuration: Swift.String?
    let networkAccessControl: GrafanaClientTypes.NetworkAccessConfiguration?
    let grafanaVersion: Swift.String?
}

extension CreateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAccessType
        case authenticationProviders
        case clientToken
        case configuration
        case grafanaVersion
        case networkAccessControl
        case organizationRoleName
        case permissionType
        case stackSetName
        case tags
        case vpcConfiguration
        case workspaceDataSources
        case workspaceDescription
        case workspaceName
        case workspaceNotificationDestinations
        case workspaceOrganizationalUnits
        case workspaceRoleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAccessTypeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AccountAccessType.self, forKey: .accountAccessType)
        accountAccessType = accountAccessTypeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationRoleName)
        organizationRoleName = organizationRoleNameDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let stackSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackSetName)
        stackSetName = stackSetNameDecoded
        let workspaceDataSourcesContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.DataSourceType?].self, forKey: .workspaceDataSources)
        var workspaceDataSourcesDecoded0:[GrafanaClientTypes.DataSourceType]? = nil
        if let workspaceDataSourcesContainer = workspaceDataSourcesContainer {
            workspaceDataSourcesDecoded0 = [GrafanaClientTypes.DataSourceType]()
            for string0 in workspaceDataSourcesContainer {
                if let string0 = string0 {
                    workspaceDataSourcesDecoded0?.append(string0)
                }
            }
        }
        workspaceDataSources = workspaceDataSourcesDecoded0
        let workspaceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceDescription)
        workspaceDescription = workspaceDescriptionDecoded
        let workspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceName)
        workspaceName = workspaceNameDecoded
        let workspaceNotificationDestinationsContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.NotificationDestinationType?].self, forKey: .workspaceNotificationDestinations)
        var workspaceNotificationDestinationsDecoded0:[GrafanaClientTypes.NotificationDestinationType]? = nil
        if let workspaceNotificationDestinationsContainer = workspaceNotificationDestinationsContainer {
            workspaceNotificationDestinationsDecoded0 = [GrafanaClientTypes.NotificationDestinationType]()
            for string0 in workspaceNotificationDestinationsContainer {
                if let string0 = string0 {
                    workspaceNotificationDestinationsDecoded0?.append(string0)
                }
            }
        }
        workspaceNotificationDestinations = workspaceNotificationDestinationsDecoded0
        let workspaceOrganizationalUnitsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .workspaceOrganizationalUnits)
        var workspaceOrganizationalUnitsDecoded0:[Swift.String]? = nil
        if let workspaceOrganizationalUnitsContainer = workspaceOrganizationalUnitsContainer {
            workspaceOrganizationalUnitsDecoded0 = [Swift.String]()
            for string0 in workspaceOrganizationalUnitsContainer {
                if let string0 = string0 {
                    workspaceOrganizationalUnitsDecoded0?.append(string0)
                }
            }
        }
        workspaceOrganizationalUnits = workspaceOrganizationalUnitsDecoded0
        let workspaceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceRoleArn)
        workspaceRoleArn = workspaceRoleArnDecoded
        let authenticationProvidersContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.AuthenticationProviderTypes?].self, forKey: .authenticationProviders)
        var authenticationProvidersDecoded0:[GrafanaClientTypes.AuthenticationProviderTypes]? = nil
        if let authenticationProvidersContainer = authenticationProvidersContainer {
            authenticationProvidersDecoded0 = [GrafanaClientTypes.AuthenticationProviderTypes]()
            for string0 in authenticationProvidersContainer {
                if let string0 = string0 {
                    authenticationProvidersDecoded0?.append(string0)
                }
            }
        }
        authenticationProviders = authenticationProvidersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuration)
        configuration = configurationDecoded
        let networkAccessControlDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.NetworkAccessConfiguration.self, forKey: .networkAccessControl)
        networkAccessControl = networkAccessControlDecoded
        let grafanaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grafanaVersion)
        grafanaVersion = grafanaVersionDecoded
    }
}

extension CreateWorkspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkspaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

public struct CreateWorkspaceOutput: Swift.Equatable {
    /// A structure containing data about the workspace that was created.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init(
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct CreateWorkspaceOutputBody: Swift.Equatable {
    let workspace: GrafanaClientTypes.WorkspaceDescription?
}

extension CreateWorkspaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

enum CreateWorkspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GrafanaClientTypes {
    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Amazon OpenSearch Service
        case amazonOpensearchService
        /// Amazon Athena
        case athena
        /// CloudWatch Logs
        case cloudwatch
        /// Managed Prometheus
        case prometheus
        /// Redshift
        case redshift
        /// IoT SiteWise
        case sitewise
        /// Timestream
        case timestream
        /// IoT TwinMaker
        case twinmaker
        /// X-Ray
        case xray
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .amazonOpensearchService,
                .athena,
                .cloudwatch,
                .prometheus,
                .redshift,
                .sitewise,
                .timestream,
                .twinmaker,
                .xray,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonOpensearchService: return "AMAZON_OPENSEARCH_SERVICE"
            case .athena: return "ATHENA"
            case .cloudwatch: return "CLOUDWATCH"
            case .prometheus: return "PROMETHEUS"
            case .redshift: return "REDSHIFT"
            case .sitewise: return "SITEWISE"
            case .timestream: return "TIMESTREAM"
            case .twinmaker: return "TWINMAKER"
            case .xray: return "XRAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteWorkspaceApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let keyName = keyName else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/apikeys/\(keyName.urlPercentEncoding())"
    }
}

public struct DeleteWorkspaceApiKeyInput: Swift.Equatable {
    /// The name of the API key to delete.
    /// This member is required.
    public var keyName: Swift.String?
    /// The ID of the workspace to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        keyName: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.keyName = keyName
        self.workspaceId = workspaceId
    }
}

struct DeleteWorkspaceApiKeyInputBody: Swift.Equatable {
}

extension DeleteWorkspaceApiKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkspaceApiKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteWorkspaceApiKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyName = output.keyName
            self.workspaceId = output.workspaceId
        } else {
            self.keyName = nil
            self.workspaceId = nil
        }
    }
}

public struct DeleteWorkspaceApiKeyOutput: Swift.Equatable {
    /// The name of the key that was deleted.
    /// This member is required.
    public var keyName: Swift.String?
    /// The ID of the workspace where the key was deleted.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        keyName: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.keyName = keyName
        self.workspaceId = workspaceId
    }
}

struct DeleteWorkspaceApiKeyOutputBody: Swift.Equatable {
    let keyName: Swift.String?
    let workspaceId: Swift.String?
}

extension DeleteWorkspaceApiKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyName
        case workspaceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

enum DeleteWorkspaceApiKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct DeleteWorkspaceInput: Swift.Equatable {
    /// The ID of the workspace to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DeleteWorkspaceInputBody: Swift.Equatable {
}

extension DeleteWorkspaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteWorkspaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

public struct DeleteWorkspaceOutput: Swift.Equatable {
    /// A structure containing information about the workspace that was deleted.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init(
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct DeleteWorkspaceOutputBody: Swift.Equatable {
    let workspace: GrafanaClientTypes.WorkspaceDescription?
}

extension DeleteWorkspaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

enum DeleteWorkspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorkspaceAuthenticationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/authentication"
    }
}

public struct DescribeWorkspaceAuthenticationInput: Swift.Equatable {
    /// The ID of the workspace to return authentication information about.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeWorkspaceAuthenticationInputBody: Swift.Equatable {
}

extension DescribeWorkspaceAuthenticationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeWorkspaceAuthenticationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorkspaceAuthenticationOutputBody = try responseDecoder.decode(responseBody: data)
            self.authentication = output.authentication
        } else {
            self.authentication = nil
        }
    }
}

public struct DescribeWorkspaceAuthenticationOutput: Swift.Equatable {
    /// A structure containing information about the authentication methods used in the workspace.
    /// This member is required.
    public var authentication: GrafanaClientTypes.AuthenticationDescription?

    public init(
        authentication: GrafanaClientTypes.AuthenticationDescription? = nil
    )
    {
        self.authentication = authentication
    }
}

struct DescribeWorkspaceAuthenticationOutputBody: Swift.Equatable {
    let authentication: GrafanaClientTypes.AuthenticationDescription?
}

extension DescribeWorkspaceAuthenticationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authentication
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AuthenticationDescription.self, forKey: .authentication)
        authentication = authenticationDecoded
    }
}

enum DescribeWorkspaceAuthenticationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorkspaceConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/configuration"
    }
}

public struct DescribeWorkspaceConfigurationInput: Swift.Equatable {
    /// The ID of the workspace to get configuration information for.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeWorkspaceConfigurationInputBody: Swift.Equatable {
}

extension DescribeWorkspaceConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeWorkspaceConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorkspaceConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
            self.grafanaVersion = output.grafanaVersion
        } else {
            self.configuration = nil
            self.grafanaVersion = nil
        }
    }
}

public struct DescribeWorkspaceConfigurationOutput: Swift.Equatable {
    /// The configuration string for the workspace that you requested. For more information about the format and configuration options available, see [Working in your Grafana workspace](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-configure-workspace.html).
    /// This member is required.
    public var configuration: Swift.String?
    /// The supported Grafana version for the workspace.
    public var grafanaVersion: Swift.String?

    public init(
        configuration: Swift.String? = nil,
        grafanaVersion: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.grafanaVersion = grafanaVersion
    }
}

struct DescribeWorkspaceConfigurationOutputBody: Swift.Equatable {
    let configuration: Swift.String?
    let grafanaVersion: Swift.String?
}

extension DescribeWorkspaceConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case grafanaVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuration)
        configuration = configurationDecoded
        let grafanaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grafanaVersion)
        grafanaVersion = grafanaVersionDecoded
    }
}

enum DescribeWorkspaceConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct DescribeWorkspaceInput: Swift.Equatable {
    /// The ID of the workspace to display information about.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeWorkspaceInputBody: Swift.Equatable {
}

extension DescribeWorkspaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeWorkspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorkspaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

public struct DescribeWorkspaceOutput: Swift.Equatable {
    /// A structure containing information about the workspace.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init(
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct DescribeWorkspaceOutputBody: Swift.Equatable {
    let workspace: GrafanaClientTypes.WorkspaceDescription?
}

extension DescribeWorkspaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

enum DescribeWorkspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateLicenseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let licenseType = licenseType else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/licenses/\(licenseType.rawValue.urlPercentEncoding())"
    }
}

public struct DisassociateLicenseInput: Swift.Equatable {
    /// The type of license to remove from the workspace.
    /// This member is required.
    public var licenseType: GrafanaClientTypes.LicenseType?
    /// The ID of the workspace to remove the Grafana Enterprise license from.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        licenseType: GrafanaClientTypes.LicenseType? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.licenseType = licenseType
        self.workspaceId = workspaceId
    }
}

struct DisassociateLicenseInputBody: Swift.Equatable {
}

extension DisassociateLicenseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateLicenseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateLicenseOutputBody = try responseDecoder.decode(responseBody: data)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

public struct DisassociateLicenseOutput: Swift.Equatable {
    /// A structure containing information about the workspace.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init(
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct DisassociateLicenseOutputBody: Swift.Equatable {
    let workspace: GrafanaClientTypes.WorkspaceDescription?
}

extension DisassociateLicenseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

enum DisassociateLicenseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GrafanaClientTypes.IdpMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case url
        case xml
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .url(url):
                try container.encode(url, forKey: .url)
            case let .xml(xml):
                try container.encode(xml, forKey: .xml)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .url)
        if let url = urlDecoded {
            self = .url(url)
            return
        }
        let xmlDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .xml)
        if let xml = xmlDecoded {
            self = .xml(xml)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GrafanaClientTypes {
    /// A structure containing the identity provider (IdP) metadata used to integrate the identity provider with this workspace. You can specify the metadata either by providing a URL to its location in the url parameter, or by specifying the full metadata in XML format in the xml parameter. Specifying both will cause an error.
    public enum IdpMetadata: Swift.Equatable {
        /// The URL of the location containing the IdP metadata.
        case url(Swift.String)
        /// The full IdP metadata, in XML format.
        case xml(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Unexpected error while processing the request. Retry the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// How long to wait before you retry this operation.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GrafanaClientTypes {
    public enum LicenseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Grafana Enterprise License.
        case enterprise
        /// Grafana Enterprise Free Trial License.
        case enterpriseFreeTrial
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseType] {
            return [
                .enterprise,
                .enterpriseFreeTrial,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enterprise: return "ENTERPRISE"
            case .enterpriseFreeTrial: return "ENTERPRISE_FREE_TRIAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LicenseType(rawValue: rawValue) ?? LicenseType.sdkUnknown(rawValue)
        }
    }
}

extension ListPermissionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let groupId = groupId {
                let groupIdQueryItem = ClientRuntime.URLQueryItem(name: "groupId".urlPercentEncoding(), value: Swift.String(groupId).urlPercentEncoding())
                items.append(groupIdQueryItem)
            }
            if let userType = userType {
                let userTypeQueryItem = ClientRuntime.URLQueryItem(name: "userType".urlPercentEncoding(), value: Swift.String(userType.rawValue).urlPercentEncoding())
                items.append(userTypeQueryItem)
            }
            if let userId = userId {
                let userIdQueryItem = ClientRuntime.URLQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
                items.append(userIdQueryItem)
            }
            return items
        }
    }
}

extension ListPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/permissions"
    }
}

public struct ListPermissionsInput: Swift.Equatable {
    /// (Optional) Limits the results to only the group that matches this ID.
    public var groupId: Swift.String?
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListPermissions operation.
    public var nextToken: Swift.String?
    /// (Optional) Limits the results to only the user that matches this ID.
    public var userId: Swift.String?
    /// (Optional) If you specify SSO_USER, then only the permissions of IAM Identity Center users are returned. If you specify SSO_GROUP, only the permissions of IAM Identity Center groups are returned.
    public var userType: GrafanaClientTypes.UserType?
    /// The ID of the workspace to list permissions for. This parameter is required.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userId: Swift.String? = nil,
        userType: GrafanaClientTypes.UserType? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userId = userId
        self.userType = userType
        self.workspaceId = workspaceId
    }
}

struct ListPermissionsInputBody: Swift.Equatable {
}

extension ListPermissionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListPermissionsOutput: Swift.Equatable {
    /// The token to use in a subsequent ListPermissions operation to return the next set of results.
    public var nextToken: Swift.String?
    /// The permissions returned by the operation.
    /// This member is required.
    public var permissions: [GrafanaClientTypes.PermissionEntry]?

    public init(
        nextToken: Swift.String? = nil,
        permissions: [GrafanaClientTypes.PermissionEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListPermissionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let permissions: [GrafanaClientTypes.PermissionEntry]?
}

extension ListPermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.PermissionEntry?].self, forKey: .permissions)
        var permissionsDecoded0:[GrafanaClientTypes.PermissionEntry]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [GrafanaClientTypes.PermissionEntry]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

enum ListPermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource the list of tags are associated with.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The list of tags that are associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let workspaceId = workspaceId {
                let workspaceIdQueryItem = ClientRuntime.URLQueryItem(name: "workspace-id".urlPercentEncoding(), value: Swift.String(workspaceId).urlPercentEncoding())
                items.append(workspaceIdQueryItem)
            }
            return items
        }
    }
}

extension ListVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/versions"
    }
}

public struct ListVersionsInput: Swift.Equatable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You receive this token from a previous ListVersions operation.
    public var nextToken: Swift.String?
    /// The ID of the workspace to list the available upgrade versions. If not included, lists all versions of Grafana that are supported for CreateWorkspace.
    public var workspaceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListVersionsInputBody: Swift.Equatable {
}

extension ListVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.grafanaVersions = output.grafanaVersions
            self.nextToken = output.nextToken
        } else {
            self.grafanaVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListVersionsOutput: Swift.Equatable {
    /// The Grafana versions available to create. If a workspace ID is included in the request, the Grafana versions to which this workspace can be upgraded.
    public var grafanaVersions: [Swift.String]?
    /// The token to use in a subsequent ListVersions operation to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        grafanaVersions: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.grafanaVersions = grafanaVersions
        self.nextToken = nextToken
    }
}

struct ListVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let grafanaVersions: [Swift.String]?
}

extension ListVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grafanaVersions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let grafanaVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .grafanaVersions)
        var grafanaVersionsDecoded0:[Swift.String]? = nil
        if let grafanaVersionsContainer = grafanaVersionsContainer {
            grafanaVersionsDecoded0 = [Swift.String]()
            for string0 in grafanaVersionsContainer {
                if let string0 = string0 {
                    grafanaVersionsDecoded0?.append(string0)
                }
            }
        }
        grafanaVersions = grafanaVersionsDecoded0
    }
}

enum ListVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkspacesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workspaces"
    }
}

public struct ListWorkspacesInput: Swift.Equatable {
    /// The maximum number of workspaces to include in the results.
    public var maxResults: Swift.Int?
    /// The token for the next set of workspaces to return. (You receive this token from a previous ListWorkspaces operation.)
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkspacesInputBody: Swift.Equatable {
}

extension ListWorkspacesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkspacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkspacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workspaces = output.workspaces
        } else {
            self.nextToken = nil
            self.workspaces = nil
        }
    }
}

public struct ListWorkspacesOutput: Swift.Equatable {
    /// The token to use when requesting the next set of workspaces.
    public var nextToken: Swift.String?
    /// An array of structures that contain some information about the workspaces in the account.
    /// This member is required.
    public var workspaces: [GrafanaClientTypes.WorkspaceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workspaces: [GrafanaClientTypes.WorkspaceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaces = workspaces
    }
}

struct ListWorkspacesOutputBody: Swift.Equatable {
    let workspaces: [GrafanaClientTypes.WorkspaceSummary]?
    let nextToken: Swift.String?
}

extension ListWorkspacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workspaces
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.WorkspaceSummary?].self, forKey: .workspaces)
        var workspacesDecoded0:[GrafanaClientTypes.WorkspaceSummary]? = nil
        if let workspacesContainer = workspacesContainer {
            workspacesDecoded0 = [GrafanaClientTypes.WorkspaceSummary]()
            for structure0 in workspacesContainer {
                if let structure0 = structure0 {
                    workspacesDecoded0?.append(structure0)
                }
            }
        }
        workspaces = workspacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorkspacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GrafanaClientTypes.NetworkAccessConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case prefixListIds
        case vpceIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let prefixListIds = prefixListIds {
            var prefixListIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .prefixListIds)
            for prefixlistid0 in prefixListIds {
                try prefixListIdsContainer.encode(prefixlistid0)
            }
        }
        if let vpceIds = vpceIds {
            var vpceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpceIds)
            for vpceid0 in vpceIds {
                try vpceIdsContainer.encode(vpceid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixListIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .prefixListIds)
        var prefixListIdsDecoded0:[Swift.String]? = nil
        if let prefixListIdsContainer = prefixListIdsContainer {
            prefixListIdsDecoded0 = [Swift.String]()
            for string0 in prefixListIdsContainer {
                if let string0 = string0 {
                    prefixListIdsDecoded0?.append(string0)
                }
            }
        }
        prefixListIds = prefixListIdsDecoded0
        let vpceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpceIds)
        var vpceIdsDecoded0:[Swift.String]? = nil
        if let vpceIdsContainer = vpceIdsContainer {
            vpceIdsDecoded0 = [Swift.String]()
            for string0 in vpceIdsContainer {
                if let string0 = string0 {
                    vpceIdsDecoded0?.append(string0)
                }
            }
        }
        vpceIds = vpceIdsDecoded0
    }
}

extension GrafanaClientTypes {
    /// The configuration settings for in-bound network access to your workspace. When this is configured, only listed IP addresses and VPC endpoints will be able to access your workspace. Standard Grafana authentication and authorization are still required. Access is granted to a caller that is in either the IP address list or the VPC endpoint list - they do not need to be in both. If this is not configured, or is removed, then all IP addresses and VPC endpoints are allowed. Standard Grafana authentication and authorization are still required. While both prefixListIds and vpceIds are required, you can pass in an empty array of strings for either parameter if you do not want to allow any of that type. If both are passed as empty arrays, no traffic is allowed to the workspace, because only explicitly allowed connections are accepted.
    public struct NetworkAccessConfiguration: Swift.Equatable {
        /// An array of prefix list IDs. A prefix list is a list of CIDR ranges of IP addresses. The IP addresses specified are allowed to access your workspace. If the list is not included in the configuration (passed an empty array) then no IP addresses are allowed to access the workspace. You create a prefix list using the Amazon VPC console. Prefix list IDs have the format pl-1a2b3c4d . For more information about prefix lists, see [Group CIDR blocks using managed prefix lists](https://docs.aws.amazon.com/vpc/latest/userguide/managed-prefix-lists.html)in the Amazon Virtual Private Cloud User Guide.
        /// This member is required.
        public var prefixListIds: [Swift.String]?
        /// An array of Amazon VPC endpoint IDs for the workspace. You can create VPC endpoints to your Amazon Managed Grafana workspace for access from within a VPC. If a NetworkAccessConfiguration is specified then only VPC endpoints specified here are allowed to access the workspace. If you pass in an empty array of strings, then no VPCs are allowed to access the workspace. VPC endpoint IDs have the format vpce-1a2b3c4d . For more information about creating an interface VPC endpoint, see [Interface VPC endpoints](https://docs.aws.amazon.com/grafana/latest/userguide/VPC-endpoints) in the Amazon Managed Grafana User Guide. The only VPC endpoints that can be specified here are interface VPC endpoints for Grafana workspaces (using the com.amazonaws.[region].grafana-workspace service endpoint). Other VPC endpoints are ignored.
        /// This member is required.
        public var vpceIds: [Swift.String]?

        public init(
            prefixListIds: [Swift.String]? = nil,
            vpceIds: [Swift.String]? = nil
        )
        {
            self.prefixListIds = prefixListIds
            self.vpceIds = vpceIds
        }
    }

}

extension GrafanaClientTypes {
    public enum NotificationDestinationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// AWS Simple Notification Service
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationDestinationType] {
            return [
                .sns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationDestinationType(rawValue: rawValue) ?? NotificationDestinationType.sdkUnknown(rawValue)
        }
    }
}

extension GrafanaClientTypes.PermissionEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role
        case user
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let user = self.user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.User.self, forKey: .user)
        user = userDecoded
        let roleDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.Role.self, forKey: .role)
        role = roleDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure containing the identity of one user or group and the Admin, Editor, or Viewer role that they have.
    public struct PermissionEntry: Swift.Equatable {
        /// Specifies whether the user or group has the Admin, Editor, or Viewer role.
        /// This member is required.
        public var role: GrafanaClientTypes.Role?
        /// A structure with the ID of the user or group with this role.
        /// This member is required.
        public var user: GrafanaClientTypes.User?

        public init(
            role: GrafanaClientTypes.Role? = nil,
            user: GrafanaClientTypes.User? = nil
        )
        {
            self.role = role
            self.user = user
        }
    }

}

extension GrafanaClientTypes {
    public enum PermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Customer Managed
        case customerManaged
        /// Service Managed
        case serviceManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .customerManaged,
                .serviceManaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customerManaged: return "CUSTOMER_MANAGED"
            case .serviceManaged: return "SERVICE_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionType(rawValue: rawValue) ?? PermissionType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The value of a parameter in the request caused an error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension GrafanaClientTypes {
    public enum Role: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Role Admin.
        case admin
        /// Role Editor.
        case editor
        /// Role Viewer.
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [Role] {
            return [
                .admin,
                .editor,
                .viewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .admin: return "ADMIN"
            case .editor: return "EDITOR"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Role(rawValue: rawValue) ?? Role.sdkUnknown(rawValue)
        }
    }
}

extension GrafanaClientTypes.RoleValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case admin
        case editor
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let admin = admin {
            var adminContainer = encodeContainer.nestedUnkeyedContainer(forKey: .admin)
            for rolevalue0 in admin {
                try adminContainer.encode(rolevalue0)
            }
        }
        if let editor = editor {
            var editorContainer = encodeContainer.nestedUnkeyedContainer(forKey: .editor)
            for rolevalue0 in editor {
                try editorContainer.encode(rolevalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let editorContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .editor)
        var editorDecoded0:[Swift.String]? = nil
        if let editorContainer = editorContainer {
            editorDecoded0 = [Swift.String]()
            for string0 in editorContainer {
                if let string0 = string0 {
                    editorDecoded0?.append(string0)
                }
            }
        }
        editor = editorDecoded0
        let adminContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .admin)
        var adminDecoded0:[Swift.String]? = nil
        if let adminContainer = adminContainer {
            adminDecoded0 = [Swift.String]()
            for string0 in adminContainer {
                if let string0 = string0 {
                    adminDecoded0?.append(string0)
                }
            }
        }
        admin = adminDecoded0
    }
}

extension GrafanaClientTypes.RoleValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoleValues(admin: \"CONTENT_REDACTED\", editor: \"CONTENT_REDACTED\")"}
}

extension GrafanaClientTypes {
    /// This structure defines which groups defined in the SAML assertion attribute are to be mapped to the Grafana Admin and Editor roles in the workspace. SAML authenticated users not part of Admin or Editor role groups have Viewer permission over the workspace.
    public struct RoleValues: Swift.Equatable {
        /// A list of groups from the SAML assertion attribute to grant the Grafana Admin role to.
        public var admin: [Swift.String]?
        /// A list of groups from the SAML assertion attribute to grant the Grafana Editor role to.
        public var editor: [Swift.String]?

        public init(
            admin: [Swift.String]? = nil,
            editor: [Swift.String]? = nil
        )
        {
            self.admin = admin
            self.editor = editor
        }
    }

}

extension GrafanaClientTypes.SamlAuthentication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.SamlConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.SamlConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure containing information about how this workspace works with SAML.
    public struct SamlAuthentication: Swift.Equatable {
        /// A structure containing details about how this workspace works with SAML.
        public var configuration: GrafanaClientTypes.SamlConfiguration?
        /// Specifies whether the workspace's SAML configuration is complete.
        /// This member is required.
        public var status: GrafanaClientTypes.SamlConfigurationStatus?

        public init(
            configuration: GrafanaClientTypes.SamlConfiguration? = nil,
            status: GrafanaClientTypes.SamlConfigurationStatus? = nil
        )
        {
            self.configuration = configuration
            self.status = status
        }
    }

}

extension GrafanaClientTypes.SamlConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedOrganizations
        case assertionAttributes
        case idpMetadata
        case loginValidityDuration
        case roleValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedOrganizations = allowedOrganizations {
            var allowedOrganizationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOrganizations)
            for allowedorganization0 in allowedOrganizations {
                try allowedOrganizationsContainer.encode(allowedorganization0)
            }
        }
        if let assertionAttributes = self.assertionAttributes {
            try encodeContainer.encode(assertionAttributes, forKey: .assertionAttributes)
        }
        if let idpMetadata = self.idpMetadata {
            try encodeContainer.encode(idpMetadata, forKey: .idpMetadata)
        }
        if loginValidityDuration != 0 {
            try encodeContainer.encode(loginValidityDuration, forKey: .loginValidityDuration)
        }
        if let roleValues = self.roleValues {
            try encodeContainer.encode(roleValues, forKey: .roleValues)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idpMetadataDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.IdpMetadata.self, forKey: .idpMetadata)
        idpMetadata = idpMetadataDecoded
        let assertionAttributesDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AssertionAttributes.self, forKey: .assertionAttributes)
        assertionAttributes = assertionAttributesDecoded
        let roleValuesDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.RoleValues.self, forKey: .roleValues)
        roleValues = roleValuesDecoded
        let allowedOrganizationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedOrganizations)
        var allowedOrganizationsDecoded0:[Swift.String]? = nil
        if let allowedOrganizationsContainer = allowedOrganizationsContainer {
            allowedOrganizationsDecoded0 = [Swift.String]()
            for string0 in allowedOrganizationsContainer {
                if let string0 = string0 {
                    allowedOrganizationsDecoded0?.append(string0)
                }
            }
        }
        allowedOrganizations = allowedOrganizationsDecoded0
        let loginValidityDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .loginValidityDuration) ?? 0
        loginValidityDuration = loginValidityDurationDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure containing information about how this workspace works with SAML.
    public struct SamlConfiguration: Swift.Equatable {
        /// Lists which organizations defined in the SAML assertion are allowed to use the Amazon Managed Grafana workspace. If this is empty, all organizations in the assertion attribute have access.
        public var allowedOrganizations: [Swift.String]?
        /// A structure that defines which attributes in the SAML assertion are to be used to define information about the users authenticated by that IdP to use the workspace.
        public var assertionAttributes: GrafanaClientTypes.AssertionAttributes?
        /// A structure containing the identity provider (IdP) metadata used to integrate the identity provider with this workspace.
        /// This member is required.
        public var idpMetadata: GrafanaClientTypes.IdpMetadata?
        /// How long a sign-on session by a SAML user is valid, before the user has to sign on again.
        public var loginValidityDuration: Swift.Int
        /// A structure containing arrays that map group names in the SAML assertion to the Grafana Admin and Editor roles in the workspace.
        public var roleValues: GrafanaClientTypes.RoleValues?

        public init(
            allowedOrganizations: [Swift.String]? = nil,
            assertionAttributes: GrafanaClientTypes.AssertionAttributes? = nil,
            idpMetadata: GrafanaClientTypes.IdpMetadata? = nil,
            loginValidityDuration: Swift.Int = 0,
            roleValues: GrafanaClientTypes.RoleValues? = nil
        )
        {
            self.allowedOrganizations = allowedOrganizations
            self.assertionAttributes = assertionAttributes
            self.idpMetadata = idpMetadata
            self.loginValidityDuration = loginValidityDuration
            self.roleValues = roleValues
        }
    }

}

extension GrafanaClientTypes {
    public enum SamlConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates that SAML on an AMG workspace is enabled and has been configured.
        case configured
        /// Indicates that SAML on an AMG workspace is enabled but has not been configured.
        case notConfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [SamlConfigurationStatus] {
            return [
                .configured,
                .notConfigured,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configured: return "CONFIGURED"
            case .notConfigured: return "NOT_CONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SamlConfigurationStatus(rawValue: rawValue) ?? SamlConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The value of a parameter in the request caused an error.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource the tag is associated with.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys and values to associate with the resource. You can associate tag keys only, tags (key and values) only or a combination of tag keys and tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because of request throttling. Retry the request.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The value of a parameter in the request caused an error.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The ID of the service that is associated with the error.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource the tag association is removed from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key values of the tag to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GrafanaClientTypes {
    public enum UpdateAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Add permissions.
        case add
        /// Revoke permissions.
        case revoke
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateAction] {
            return [
                .add,
                .revoke,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .revoke: return "REVOKE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateAction(rawValue: rawValue) ?? UpdateAction.sdkUnknown(rawValue)
        }
    }
}

extension GrafanaClientTypes.UpdateError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case causedBy
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let causedBy = self.causedBy {
            try encodeContainer.encode(causedBy, forKey: .causedBy)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let causedByDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.UpdateInstruction.self, forKey: .causedBy)
        causedBy = causedByDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure containing information about one error encountered while performing an [UpdatePermissions](https://docs.aws.amazon.com/grafana/latest/APIReference/API_UpdatePermissions.html) operation.
    public struct UpdateError: Swift.Equatable {
        /// Specifies which permission update caused the error.
        /// This member is required.
        public var causedBy: GrafanaClientTypes.UpdateInstruction?
        /// The error code.
        /// This member is required.
        public var code: Swift.Int?
        /// The message for this error.
        /// This member is required.
        public var message: Swift.String?

        public init(
            causedBy: GrafanaClientTypes.UpdateInstruction? = nil,
            code: Swift.Int? = nil,
            message: Swift.String? = nil
        )
        {
            self.causedBy = causedBy
            self.code = code
            self.message = message
        }
    }

}

extension GrafanaClientTypes.UpdateInstruction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case role
        case users
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for user0 in users {
                try usersContainer.encode(user0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.UpdateAction.self, forKey: .action)
        action = actionDecoded
        let roleDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.Role.self, forKey: .role)
        role = roleDecoded
        let usersContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[GrafanaClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [GrafanaClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension GrafanaClientTypes {
    /// Contains the instructions for one Grafana role permission update in a [UpdatePermissions](https://docs.aws.amazon.com/grafana/latest/APIReference/API_UpdatePermissions.html) operation.
    public struct UpdateInstruction: Swift.Equatable {
        /// Specifies whether this update is to add or revoke role permissions.
        /// This member is required.
        public var action: GrafanaClientTypes.UpdateAction?
        /// The role to add or revoke for the user or the group specified in users.
        /// This member is required.
        public var role: GrafanaClientTypes.Role?
        /// A structure that specifies the user or group to add or revoke the role for.
        /// This member is required.
        public var users: [GrafanaClientTypes.User]?

        public init(
            action: GrafanaClientTypes.UpdateAction? = nil,
            role: GrafanaClientTypes.Role? = nil,
            users: [GrafanaClientTypes.User]? = nil
        )
        {
            self.action = action
            self.role = role
            self.users = users
        }
    }

}

extension UpdatePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateInstructionBatch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updateInstructionBatch = updateInstructionBatch {
            var updateInstructionBatchContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updateInstructionBatch)
            for updateinstruction0 in updateInstructionBatch {
                try updateInstructionBatchContainer.encode(updateinstruction0)
            }
        }
    }
}

extension UpdatePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/permissions"
    }
}

public struct UpdatePermissionsInput: Swift.Equatable {
    /// An array of structures that contain the permission updates to make.
    /// This member is required.
    public var updateInstructionBatch: [GrafanaClientTypes.UpdateInstruction]?
    /// The ID of the workspace to update.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        updateInstructionBatch: [GrafanaClientTypes.UpdateInstruction]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.updateInstructionBatch = updateInstructionBatch
        self.workspaceId = workspaceId
    }
}

struct UpdatePermissionsInputBody: Swift.Equatable {
    let updateInstructionBatch: [GrafanaClientTypes.UpdateInstruction]?
}

extension UpdatePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateInstructionBatch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateInstructionBatchContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.UpdateInstruction?].self, forKey: .updateInstructionBatch)
        var updateInstructionBatchDecoded0:[GrafanaClientTypes.UpdateInstruction]? = nil
        if let updateInstructionBatchContainer = updateInstructionBatchContainer {
            updateInstructionBatchDecoded0 = [GrafanaClientTypes.UpdateInstruction]()
            for structure0 in updateInstructionBatchContainer {
                if let structure0 = structure0 {
                    updateInstructionBatchDecoded0?.append(structure0)
                }
            }
        }
        updateInstructionBatch = updateInstructionBatchDecoded0
    }
}

extension UpdatePermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct UpdatePermissionsOutput: Swift.Equatable {
    /// An array of structures that contain the errors from the operation, if any.
    /// This member is required.
    public var errors: [GrafanaClientTypes.UpdateError]?

    public init(
        errors: [GrafanaClientTypes.UpdateError]? = nil
    )
    {
        self.errors = errors
    }
}

struct UpdatePermissionsOutputBody: Swift.Equatable {
    let errors: [GrafanaClientTypes.UpdateError]?
}

extension UpdatePermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.UpdateError?].self, forKey: .errors)
        var errorsDecoded0:[GrafanaClientTypes.UpdateError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [GrafanaClientTypes.UpdateError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum UpdatePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkspaceAuthenticationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationProviders
        case samlConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationProviders = authenticationProviders {
            var authenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authenticationProviders)
            for authenticationprovidertypes0 in authenticationProviders {
                try authenticationProvidersContainer.encode(authenticationprovidertypes0.rawValue)
            }
        }
        if let samlConfiguration = self.samlConfiguration {
            try encodeContainer.encode(samlConfiguration, forKey: .samlConfiguration)
        }
    }
}

extension UpdateWorkspaceAuthenticationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/authentication"
    }
}

public struct UpdateWorkspaceAuthenticationInput: Swift.Equatable {
    /// Specifies whether this workspace uses SAML 2.0, IAM Identity Center (successor to Single Sign-On), or both to authenticate users for using the Grafana console within a workspace. For more information, see [User authentication in Amazon Managed Grafana](https://docs.aws.amazon.com/grafana/latest/userguide/authentication-in-AMG.html).
    /// This member is required.
    public var authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]?
    /// If the workspace uses SAML, use this structure to map SAML assertion attributes to workspace user information and define which groups in the assertion attribute are to have the Admin and Editor roles in the workspace.
    public var samlConfiguration: GrafanaClientTypes.SamlConfiguration?
    /// The ID of the workspace to update the authentication for.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]? = nil,
        samlConfiguration: GrafanaClientTypes.SamlConfiguration? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.authenticationProviders = authenticationProviders
        self.samlConfiguration = samlConfiguration
        self.workspaceId = workspaceId
    }
}

struct UpdateWorkspaceAuthenticationInputBody: Swift.Equatable {
    let authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]?
    let samlConfiguration: GrafanaClientTypes.SamlConfiguration?
}

extension UpdateWorkspaceAuthenticationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationProviders
        case samlConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationProvidersContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.AuthenticationProviderTypes?].self, forKey: .authenticationProviders)
        var authenticationProvidersDecoded0:[GrafanaClientTypes.AuthenticationProviderTypes]? = nil
        if let authenticationProvidersContainer = authenticationProvidersContainer {
            authenticationProvidersDecoded0 = [GrafanaClientTypes.AuthenticationProviderTypes]()
            for string0 in authenticationProvidersContainer {
                if let string0 = string0 {
                    authenticationProvidersDecoded0?.append(string0)
                }
            }
        }
        authenticationProviders = authenticationProvidersDecoded0
        let samlConfigurationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.SamlConfiguration.self, forKey: .samlConfiguration)
        samlConfiguration = samlConfigurationDecoded
    }
}

extension UpdateWorkspaceAuthenticationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkspaceAuthenticationOutputBody = try responseDecoder.decode(responseBody: data)
            self.authentication = output.authentication
        } else {
            self.authentication = nil
        }
    }
}

public struct UpdateWorkspaceAuthenticationOutput: Swift.Equatable {
    /// A structure that describes the user authentication for this workspace after the update is made.
    /// This member is required.
    public var authentication: GrafanaClientTypes.AuthenticationDescription?

    public init(
        authentication: GrafanaClientTypes.AuthenticationDescription? = nil
    )
    {
        self.authentication = authentication
    }
}

struct UpdateWorkspaceAuthenticationOutputBody: Swift.Equatable {
    let authentication: GrafanaClientTypes.AuthenticationDescription?
}

extension UpdateWorkspaceAuthenticationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authentication
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AuthenticationDescription.self, forKey: .authentication)
        authentication = authenticationDecoded
    }
}

enum UpdateWorkspaceAuthenticationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkspaceConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case grafanaVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let grafanaVersion = self.grafanaVersion {
            try encodeContainer.encode(grafanaVersion, forKey: .grafanaVersion)
        }
    }
}

extension UpdateWorkspaceConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/configuration"
    }
}

public struct UpdateWorkspaceConfigurationInput: Swift.Equatable {
    /// The new configuration string for the workspace. For more information about the format and configuration options available, see [Working in your Grafana workspace](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-configure-workspace.html).
    /// This member is required.
    public var configuration: Swift.String?
    /// Specifies the version of Grafana to support in the new workspace. Can only be used to upgrade (for example, from 8.4 to 9.4), not downgrade (for example, from 9.4 to 8.4). To know what versions are available to upgrade to for a specific workspace, see the ListVersions operation.
    public var grafanaVersion: Swift.String?
    /// The ID of the workspace to update.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        configuration: Swift.String? = nil,
        grafanaVersion: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.grafanaVersion = grafanaVersion
        self.workspaceId = workspaceId
    }
}

struct UpdateWorkspaceConfigurationInputBody: Swift.Equatable {
    let configuration: Swift.String?
    let grafanaVersion: Swift.String?
}

extension UpdateWorkspaceConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case grafanaVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuration)
        configuration = configurationDecoded
        let grafanaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grafanaVersion)
        grafanaVersion = grafanaVersionDecoded
    }
}

extension UpdateWorkspaceConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateWorkspaceConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateWorkspaceConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkspaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWorkspaceInput(accountAccessType: \(Swift.String(describing: accountAccessType)), networkAccessControl: \(Swift.String(describing: networkAccessControl)), permissionType: \(Swift.String(describing: permissionType)), removeNetworkAccessConfiguration: \(Swift.String(describing: removeNetworkAccessConfiguration)), removeVpcConfiguration: \(Swift.String(describing: removeVpcConfiguration)), stackSetName: \(Swift.String(describing: stackSetName)), vpcConfiguration: \(Swift.String(describing: vpcConfiguration)), workspaceDataSources: \(Swift.String(describing: workspaceDataSources)), workspaceId: \(Swift.String(describing: workspaceId)), workspaceNotificationDestinations: \(Swift.String(describing: workspaceNotificationDestinations)), organizationRoleName: \"CONTENT_REDACTED\", workspaceDescription: \"CONTENT_REDACTED\", workspaceName: \"CONTENT_REDACTED\", workspaceOrganizationalUnits: \"CONTENT_REDACTED\", workspaceRoleArn: \"CONTENT_REDACTED\")"}
}

extension UpdateWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAccessType
        case networkAccessControl
        case organizationRoleName
        case permissionType
        case removeNetworkAccessConfiguration
        case removeVpcConfiguration
        case stackSetName
        case vpcConfiguration
        case workspaceDataSources
        case workspaceDescription
        case workspaceName
        case workspaceNotificationDestinations
        case workspaceOrganizationalUnits
        case workspaceRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAccessType = self.accountAccessType {
            try encodeContainer.encode(accountAccessType.rawValue, forKey: .accountAccessType)
        }
        if let networkAccessControl = self.networkAccessControl {
            try encodeContainer.encode(networkAccessControl, forKey: .networkAccessControl)
        }
        if let organizationRoleName = self.organizationRoleName {
            try encodeContainer.encode(organizationRoleName, forKey: .organizationRoleName)
        }
        if let permissionType = self.permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let removeNetworkAccessConfiguration = self.removeNetworkAccessConfiguration {
            try encodeContainer.encode(removeNetworkAccessConfiguration, forKey: .removeNetworkAccessConfiguration)
        }
        if let removeVpcConfiguration = self.removeVpcConfiguration {
            try encodeContainer.encode(removeVpcConfiguration, forKey: .removeVpcConfiguration)
        }
        if let stackSetName = self.stackSetName {
            try encodeContainer.encode(stackSetName, forKey: .stackSetName)
        }
        if let vpcConfiguration = self.vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
        if let workspaceDataSources = workspaceDataSources {
            var workspaceDataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceDataSources)
            for datasourcetype0 in workspaceDataSources {
                try workspaceDataSourcesContainer.encode(datasourcetype0.rawValue)
            }
        }
        if let workspaceDescription = self.workspaceDescription {
            try encodeContainer.encode(workspaceDescription, forKey: .workspaceDescription)
        }
        if let workspaceName = self.workspaceName {
            try encodeContainer.encode(workspaceName, forKey: .workspaceName)
        }
        if let workspaceNotificationDestinations = workspaceNotificationDestinations {
            var workspaceNotificationDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceNotificationDestinations)
            for notificationdestinationtype0 in workspaceNotificationDestinations {
                try workspaceNotificationDestinationsContainer.encode(notificationdestinationtype0.rawValue)
            }
        }
        if let workspaceOrganizationalUnits = workspaceOrganizationalUnits {
            var workspaceOrganizationalUnitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceOrganizationalUnits)
            for organizationalunit0 in workspaceOrganizationalUnits {
                try workspaceOrganizationalUnitsContainer.encode(organizationalunit0)
            }
        }
        if let workspaceRoleArn = self.workspaceRoleArn {
            try encodeContainer.encode(workspaceRoleArn, forKey: .workspaceRoleArn)
        }
    }
}

extension UpdateWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct UpdateWorkspaceInput: Swift.Equatable {
    /// Specifies whether the workspace can access Amazon Web Services resources in this Amazon Web Services account only, or whether it can also access Amazon Web Services resources in other accounts in the same organization. If you specify ORGANIZATION, you must specify which organizational units the workspace can access in the workspaceOrganizationalUnits parameter.
    public var accountAccessType: GrafanaClientTypes.AccountAccessType?
    /// The configuration settings for network access to your workspace. When this is configured, only listed IP addresses and VPC endpoints will be able to access your workspace. Standard Grafana authentication and authorization will still be required. If this is not configured, or is removed, then all IP addresses and VPC endpoints will be allowed. Standard Grafana authentication and authorization will still be required.
    public var networkAccessControl: GrafanaClientTypes.NetworkAccessConfiguration?
    /// The name of an IAM role that already exists to use to access resources through Organizations. This can only be used with a workspace that has the permissionType set to CUSTOMER_MANAGED.
    public var organizationRoleName: Swift.String?
    /// Use this parameter if you want to change a workspace from SERVICE_MANAGED to CUSTOMER_MANAGED. This allows you to manage the permissions that the workspace uses to access datasources and notification channels. If the workspace is in a member Amazon Web Services account of an organization, and that account is not a delegated administrator account, and you want the workspace to access data sources in other Amazon Web Services accounts in the organization, you must choose CUSTOMER_MANAGED. If you specify this as CUSTOMER_MANAGED, you must also specify a workspaceRoleArn that the workspace will use for accessing Amazon Web Services resources. For more information on the role and permissions needed, see [Amazon Managed Grafana permissions and policies for Amazon Web Services data sources and notification channels](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-manage-permissions.html) Do not use this to convert a CUSTOMER_MANAGED workspace to SERVICE_MANAGED. Do not include this parameter if you want to leave the workspace as SERVICE_MANAGED. You can convert a CUSTOMER_MANAGED workspace to SERVICE_MANAGED using the Amazon Managed Grafana console. For more information, see [Managing permissions for data sources and notification channels](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-datasource-and-notification.html).
    public var permissionType: GrafanaClientTypes.PermissionType?
    /// Whether to remove the network access configuration from the workspace. Setting this to true and providing a networkAccessControl to set will return an error. If you remove this configuration by setting this to true, then all IP addresses and VPC endpoints will be allowed. Standard Grafana authentication and authorization will still be required.
    public var removeNetworkAccessConfiguration: Swift.Bool?
    /// Whether to remove the VPC configuration from the workspace. Setting this to true and providing a vpcConfiguration to set will return an error.
    public var removeVpcConfiguration: Swift.Bool?
    /// The name of the CloudFormation stack set to use to generate IAM roles to be used for this workspace.
    public var stackSetName: Swift.String?
    /// The configuration settings for an Amazon VPC that contains data sources for your Grafana workspace to connect to.
    public var vpcConfiguration: GrafanaClientTypes.VpcConfiguration?
    /// This parameter is for internal use only, and should not be used.
    public var workspaceDataSources: [GrafanaClientTypes.DataSourceType]?
    /// A description for the workspace. This is used only to help you identify this workspace.
    public var workspaceDescription: Swift.String?
    /// The ID of the workspace to update.
    /// This member is required.
    public var workspaceId: Swift.String?
    /// A new name for the workspace to update.
    public var workspaceName: Swift.String?
    /// Specify the Amazon Web Services notification channels that you plan to use in this workspace. Specifying these data sources here enables Amazon Managed Grafana to create IAM roles and permissions that allow Amazon Managed Grafana to use these channels.
    public var workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
    /// Specifies the organizational units that this workspace is allowed to use data sources from, if this workspace is in an account that is part of an organization.
    public var workspaceOrganizationalUnits: [Swift.String]?
    /// Specifies an IAM role that grants permissions to Amazon Web Services resources that the workspace accesses, such as data sources and notification channels. If this workspace has permissionTypeCUSTOMER_MANAGED, then this role is required.
    public var workspaceRoleArn: Swift.String?

    public init(
        accountAccessType: GrafanaClientTypes.AccountAccessType? = nil,
        networkAccessControl: GrafanaClientTypes.NetworkAccessConfiguration? = nil,
        organizationRoleName: Swift.String? = nil,
        permissionType: GrafanaClientTypes.PermissionType? = nil,
        removeNetworkAccessConfiguration: Swift.Bool? = nil,
        removeVpcConfiguration: Swift.Bool? = nil,
        stackSetName: Swift.String? = nil,
        vpcConfiguration: GrafanaClientTypes.VpcConfiguration? = nil,
        workspaceDataSources: [GrafanaClientTypes.DataSourceType]? = nil,
        workspaceDescription: Swift.String? = nil,
        workspaceId: Swift.String? = nil,
        workspaceName: Swift.String? = nil,
        workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]? = nil,
        workspaceOrganizationalUnits: [Swift.String]? = nil,
        workspaceRoleArn: Swift.String? = nil
    )
    {
        self.accountAccessType = accountAccessType
        self.networkAccessControl = networkAccessControl
        self.organizationRoleName = organizationRoleName
        self.permissionType = permissionType
        self.removeNetworkAccessConfiguration = removeNetworkAccessConfiguration
        self.removeVpcConfiguration = removeVpcConfiguration
        self.stackSetName = stackSetName
        self.vpcConfiguration = vpcConfiguration
        self.workspaceDataSources = workspaceDataSources
        self.workspaceDescription = workspaceDescription
        self.workspaceId = workspaceId
        self.workspaceName = workspaceName
        self.workspaceNotificationDestinations = workspaceNotificationDestinations
        self.workspaceOrganizationalUnits = workspaceOrganizationalUnits
        self.workspaceRoleArn = workspaceRoleArn
    }
}

struct UpdateWorkspaceInputBody: Swift.Equatable {
    let accountAccessType: GrafanaClientTypes.AccountAccessType?
    let organizationRoleName: Swift.String?
    let permissionType: GrafanaClientTypes.PermissionType?
    let stackSetName: Swift.String?
    let workspaceDataSources: [GrafanaClientTypes.DataSourceType]?
    let workspaceDescription: Swift.String?
    let workspaceName: Swift.String?
    let workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
    let workspaceOrganizationalUnits: [Swift.String]?
    let workspaceRoleArn: Swift.String?
    let vpcConfiguration: GrafanaClientTypes.VpcConfiguration?
    let removeVpcConfiguration: Swift.Bool?
    let networkAccessControl: GrafanaClientTypes.NetworkAccessConfiguration?
    let removeNetworkAccessConfiguration: Swift.Bool?
}

extension UpdateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAccessType
        case networkAccessControl
        case organizationRoleName
        case permissionType
        case removeNetworkAccessConfiguration
        case removeVpcConfiguration
        case stackSetName
        case vpcConfiguration
        case workspaceDataSources
        case workspaceDescription
        case workspaceName
        case workspaceNotificationDestinations
        case workspaceOrganizationalUnits
        case workspaceRoleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAccessTypeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AccountAccessType.self, forKey: .accountAccessType)
        accountAccessType = accountAccessTypeDecoded
        let organizationRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationRoleName)
        organizationRoleName = organizationRoleNameDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let stackSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackSetName)
        stackSetName = stackSetNameDecoded
        let workspaceDataSourcesContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.DataSourceType?].self, forKey: .workspaceDataSources)
        var workspaceDataSourcesDecoded0:[GrafanaClientTypes.DataSourceType]? = nil
        if let workspaceDataSourcesContainer = workspaceDataSourcesContainer {
            workspaceDataSourcesDecoded0 = [GrafanaClientTypes.DataSourceType]()
            for string0 in workspaceDataSourcesContainer {
                if let string0 = string0 {
                    workspaceDataSourcesDecoded0?.append(string0)
                }
            }
        }
        workspaceDataSources = workspaceDataSourcesDecoded0
        let workspaceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceDescription)
        workspaceDescription = workspaceDescriptionDecoded
        let workspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceName)
        workspaceName = workspaceNameDecoded
        let workspaceNotificationDestinationsContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.NotificationDestinationType?].self, forKey: .workspaceNotificationDestinations)
        var workspaceNotificationDestinationsDecoded0:[GrafanaClientTypes.NotificationDestinationType]? = nil
        if let workspaceNotificationDestinationsContainer = workspaceNotificationDestinationsContainer {
            workspaceNotificationDestinationsDecoded0 = [GrafanaClientTypes.NotificationDestinationType]()
            for string0 in workspaceNotificationDestinationsContainer {
                if let string0 = string0 {
                    workspaceNotificationDestinationsDecoded0?.append(string0)
                }
            }
        }
        workspaceNotificationDestinations = workspaceNotificationDestinationsDecoded0
        let workspaceOrganizationalUnitsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .workspaceOrganizationalUnits)
        var workspaceOrganizationalUnitsDecoded0:[Swift.String]? = nil
        if let workspaceOrganizationalUnitsContainer = workspaceOrganizationalUnitsContainer {
            workspaceOrganizationalUnitsDecoded0 = [Swift.String]()
            for string0 in workspaceOrganizationalUnitsContainer {
                if let string0 = string0 {
                    workspaceOrganizationalUnitsDecoded0?.append(string0)
                }
            }
        }
        workspaceOrganizationalUnits = workspaceOrganizationalUnitsDecoded0
        let workspaceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceRoleArn)
        workspaceRoleArn = workspaceRoleArnDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let removeVpcConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeVpcConfiguration)
        removeVpcConfiguration = removeVpcConfigurationDecoded
        let networkAccessControlDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.NetworkAccessConfiguration.self, forKey: .networkAccessControl)
        networkAccessControl = networkAccessControlDecoded
        let removeNetworkAccessConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeNetworkAccessConfiguration)
        removeNetworkAccessConfiguration = removeNetworkAccessConfigurationDecoded
    }
}

extension UpdateWorkspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkspaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

public struct UpdateWorkspaceOutput: Swift.Equatable {
    /// A structure containing data about the workspace that was created.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init(
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct UpdateWorkspaceOutputBody: Swift.Equatable {
    let workspace: GrafanaClientTypes.WorkspaceDescription?
}

extension UpdateWorkspaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

enum UpdateWorkspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GrafanaClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure that specifies one user or group in the workspace.
    public struct User: Swift.Equatable {
        /// The ID of the user or group. Pattern: ^([0-9a-fA-F]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$
        /// This member is required.
        public var id: Swift.String?
        /// Specifies whether this is a single user or a group.
        /// This member is required.
        public var type: GrafanaClientTypes.UserType?

        public init(
            id: Swift.String? = nil,
            type: GrafanaClientTypes.UserType? = nil
        )
        {
            self.id = id
            self.type = type
        }
    }

}

extension GrafanaClientTypes {
    public enum UserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// SSO group.
        case ssoGroup
        /// SSO user.
        case ssoUser
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .ssoGroup,
                .ssoUser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssoGroup: return "SSO_GROUP"
            case .ssoUser: return "SSO_USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserType(rawValue: rawValue) ?? UserType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The value of a parameter in the request caused an error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A list of fields that might be associated with the error.
        public internal(set) var fieldList: [GrafanaClientTypes.ValidationExceptionField]? = nil
        /// A description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason that the operation failed.
        /// This member is required.
        public internal(set) var reason: GrafanaClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [GrafanaClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: GrafanaClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: GrafanaClientTypes.ValidationExceptionReason?
    let fieldList: [GrafanaClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[GrafanaClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [GrafanaClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension GrafanaClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GrafanaClientTypes {
    /// A structure that contains information about a request parameter that caused an error.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message describing why this field couldn't be validated.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that caused the validation error.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension GrafanaClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension GrafanaClientTypes.VpcConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
        case subnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension GrafanaClientTypes {
    /// The configuration settings for an Amazon VPC that contains data sources for your Grafana workspace to connect to. Provided securityGroupIds and subnetIds must be part of the same VPC. Connecting to a private VPC is not yet available in the Asia Pacific (Seoul) Region (ap-northeast-2).
    public struct VpcConfiguration: Swift.Equatable {
        /// The list of Amazon EC2 security group IDs attached to the Amazon VPC for your Grafana workspace to connect. Duplicates not allowed.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// The list of Amazon EC2 subnet IDs created in the Amazon VPC for your Grafana workspace to connect. Duplicates not allowed.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension GrafanaClientTypes.WorkspaceDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAccessType
        case authentication
        case created
        case dataSources
        case description
        case endpoint
        case freeTrialConsumed
        case freeTrialExpiration
        case grafanaVersion
        case id
        case licenseExpiration
        case licenseType
        case modified
        case name
        case networkAccessControl
        case notificationDestinations
        case organizationRoleName
        case organizationalUnits
        case permissionType
        case stackSetName
        case status
        case tags
        case vpcConfiguration
        case workspaceRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAccessType = self.accountAccessType {
            try encodeContainer.encode(accountAccessType.rawValue, forKey: .accountAccessType)
        }
        if let authentication = self.authentication {
            try encodeContainer.encode(authentication, forKey: .authentication)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasourcetype0 in dataSources {
                try dataSourcesContainer.encode(datasourcetype0.rawValue)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let freeTrialConsumed = self.freeTrialConsumed {
            try encodeContainer.encode(freeTrialConsumed, forKey: .freeTrialConsumed)
        }
        if let freeTrialExpiration = self.freeTrialExpiration {
            try encodeContainer.encodeTimestamp(freeTrialExpiration, format: .epochSeconds, forKey: .freeTrialExpiration)
        }
        if let grafanaVersion = self.grafanaVersion {
            try encodeContainer.encode(grafanaVersion, forKey: .grafanaVersion)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let licenseExpiration = self.licenseExpiration {
            try encodeContainer.encodeTimestamp(licenseExpiration, format: .epochSeconds, forKey: .licenseExpiration)
        }
        if let licenseType = self.licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let modified = self.modified {
            try encodeContainer.encodeTimestamp(modified, format: .epochSeconds, forKey: .modified)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkAccessControl = self.networkAccessControl {
            try encodeContainer.encode(networkAccessControl, forKey: .networkAccessControl)
        }
        if let notificationDestinations = notificationDestinations {
            var notificationDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationDestinations)
            for notificationdestinationtype0 in notificationDestinations {
                try notificationDestinationsContainer.encode(notificationdestinationtype0.rawValue)
            }
        }
        if let organizationRoleName = self.organizationRoleName {
            try encodeContainer.encode(organizationRoleName, forKey: .organizationRoleName)
        }
        if let organizationalUnits = organizationalUnits {
            var organizationalUnitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnits)
            for organizationalunit0 in organizationalUnits {
                try organizationalUnitsContainer.encode(organizationalunit0)
            }
        }
        if let permissionType = self.permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let stackSetName = self.stackSetName {
            try encodeContainer.encode(stackSetName, forKey: .stackSetName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfiguration = self.vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
        if let workspaceRoleArn = self.workspaceRoleArn {
            try encodeContainer.encode(workspaceRoleArn, forKey: .workspaceRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAccessTypeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AccountAccessType.self, forKey: .accountAccessType)
        accountAccessType = accountAccessTypeDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let dataSourcesContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.DataSourceType?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[GrafanaClientTypes.DataSourceType]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [GrafanaClientTypes.DataSourceType]()
            for string0 in dataSourcesContainer {
                if let string0 = string0 {
                    dataSourcesDecoded0?.append(string0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let grafanaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grafanaVersion)
        grafanaVersion = grafanaVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let modifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modified)
        modified = modifiedDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let organizationRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationRoleName)
        organizationRoleName = organizationRoleNameDecoded
        let notificationDestinationsContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.NotificationDestinationType?].self, forKey: .notificationDestinations)
        var notificationDestinationsDecoded0:[GrafanaClientTypes.NotificationDestinationType]? = nil
        if let notificationDestinationsContainer = notificationDestinationsContainer {
            notificationDestinationsDecoded0 = [GrafanaClientTypes.NotificationDestinationType]()
            for string0 in notificationDestinationsContainer {
                if let string0 = string0 {
                    notificationDestinationsDecoded0?.append(string0)
                }
            }
        }
        notificationDestinations = notificationDestinationsDecoded0
        let organizationalUnitsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnits)
        var organizationalUnitsDecoded0:[Swift.String]? = nil
        if let organizationalUnitsContainer = organizationalUnitsContainer {
            organizationalUnitsDecoded0 = [Swift.String]()
            for string0 in organizationalUnitsContainer {
                if let string0 = string0 {
                    organizationalUnitsDecoded0?.append(string0)
                }
            }
        }
        organizationalUnits = organizationalUnitsDecoded0
        let permissionTypeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let stackSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackSetName)
        stackSetName = stackSetNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceStatus.self, forKey: .status)
        status = statusDecoded
        let workspaceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceRoleArn)
        workspaceRoleArn = workspaceRoleArnDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.LicenseType.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let freeTrialConsumedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .freeTrialConsumed)
        freeTrialConsumed = freeTrialConsumedDecoded
        let licenseExpirationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .licenseExpiration)
        licenseExpiration = licenseExpirationDecoded
        let freeTrialExpirationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .freeTrialExpiration)
        freeTrialExpiration = freeTrialExpirationDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AuthenticationSummary.self, forKey: .authentication)
        authentication = authenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let networkAccessControlDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.NetworkAccessConfiguration.self, forKey: .networkAccessControl)
        networkAccessControl = networkAccessControlDecoded
    }
}

extension GrafanaClientTypes.WorkspaceDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorkspaceDescription(accountAccessType: \(Swift.String(describing: accountAccessType)), authentication: \(Swift.String(describing: authentication)), created: \(Swift.String(describing: created)), dataSources: \(Swift.String(describing: dataSources)), endpoint: \(Swift.String(describing: endpoint)), freeTrialConsumed: \(Swift.String(describing: freeTrialConsumed)), freeTrialExpiration: \(Swift.String(describing: freeTrialExpiration)), grafanaVersion: \(Swift.String(describing: grafanaVersion)), id: \(Swift.String(describing: id)), licenseExpiration: \(Swift.String(describing: licenseExpiration)), licenseType: \(Swift.String(describing: licenseType)), modified: \(Swift.String(describing: modified)), networkAccessControl: \(Swift.String(describing: networkAccessControl)), notificationDestinations: \(Swift.String(describing: notificationDestinations)), permissionType: \(Swift.String(describing: permissionType)), stackSetName: \(Swift.String(describing: stackSetName)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), vpcConfiguration: \(Swift.String(describing: vpcConfiguration)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", organizationRoleName: \"CONTENT_REDACTED\", organizationalUnits: \"CONTENT_REDACTED\", workspaceRoleArn: \"CONTENT_REDACTED\")"}
}

extension GrafanaClientTypes {
    /// A structure containing information about an Amazon Managed Grafana workspace in your account.
    public struct WorkspaceDescription: Swift.Equatable {
        /// Specifies whether the workspace can access Amazon Web Services resources in this Amazon Web Services account only, or whether it can also access Amazon Web Services resources in other accounts in the same organization. If this is ORGANIZATION, the workspaceOrganizationalUnits parameter specifies which organizational units the workspace can access.
        public var accountAccessType: GrafanaClientTypes.AccountAccessType?
        /// A structure that describes whether the workspace uses SAML, IAM Identity Center, or both methods for user authentication.
        /// This member is required.
        public var authentication: GrafanaClientTypes.AuthenticationSummary?
        /// The date that the workspace was created.
        /// This member is required.
        public var created: ClientRuntime.Date?
        /// Specifies the Amazon Web Services data sources that have been configured to have IAM roles and permissions created to allow Amazon Managed Grafana to read data from these sources. This list is only used when the workspace was created through the Amazon Web Services console, and the permissionType is SERVICE_MANAGED.
        /// This member is required.
        public var dataSources: [GrafanaClientTypes.DataSourceType]?
        /// The user-defined description of the workspace.
        public var description: Swift.String?
        /// The URL that users can use to access the Grafana console in the workspace.
        /// This member is required.
        public var endpoint: Swift.String?
        /// Specifies whether this workspace has already fully used its free trial for Grafana Enterprise.
        public var freeTrialConsumed: Swift.Bool?
        /// If this workspace is currently in the free trial period for Grafana Enterprise, this value specifies when that free trial ends.
        public var freeTrialExpiration: ClientRuntime.Date?
        /// The version of Grafana supported in this workspace.
        /// This member is required.
        public var grafanaVersion: Swift.String?
        /// The unique ID of this workspace.
        /// This member is required.
        public var id: Swift.String?
        /// If this workspace has a full Grafana Enterprise license, this specifies when the license ends and will need to be renewed.
        public var licenseExpiration: ClientRuntime.Date?
        /// Specifies whether this workspace has a full Grafana Enterprise license or a free trial license.
        public var licenseType: GrafanaClientTypes.LicenseType?
        /// The most recent date that the workspace was modified.
        /// This member is required.
        public var modified: ClientRuntime.Date?
        /// The name of the workspace.
        public var name: Swift.String?
        /// The configuration settings for network access to your workspace.
        public var networkAccessControl: GrafanaClientTypes.NetworkAccessConfiguration?
        /// The Amazon Web Services notification channels that Amazon Managed Grafana can automatically create IAM roles and permissions for, to allow Amazon Managed Grafana to use these channels.
        public var notificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
        /// The name of the IAM role that is used to access resources through Organizations.
        public var organizationRoleName: Swift.String?
        /// Specifies the organizational units that this workspace is allowed to use data sources from, if this workspace is in an account that is part of an organization.
        public var organizationalUnits: [Swift.String]?
        /// If this is SERVICE_MANAGED, and the workplace was created through the Amazon Managed Grafana console, then Amazon Managed Grafana automatically creates the IAM roles and provisions the permissions that the workspace needs to use Amazon Web Services data sources and notification channels. If this is CUSTOMER_MANAGED, you must manage those roles and permissions yourself. If you are working with a workspace in a member account of an organization and that account is not a delegated administrator account, and you want the workspace to access data sources in other Amazon Web Services accounts in the organization, this parameter must be set to CUSTOMER_MANAGED. For more information about converting between customer and service managed, see [Managing permissions for data sources and notification channels](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-datasource-and-notification.html). For more information about the roles and permissions that must be managed for customer managed workspaces, see [Amazon Managed Grafana permissions and policies for Amazon Web Services data sources and notification channels](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-manage-permissions.html)
        public var permissionType: GrafanaClientTypes.PermissionType?
        /// The name of the CloudFormation stack set that is used to generate IAM roles to be used for this workspace.
        public var stackSetName: Swift.String?
        /// The current status of the workspace.
        /// This member is required.
        public var status: GrafanaClientTypes.WorkspaceStatus?
        /// The list of tags associated with the workspace.
        public var tags: [Swift.String:Swift.String]?
        /// The configuration for connecting to data sources in a private VPC (Amazon Virtual Private Cloud).
        public var vpcConfiguration: GrafanaClientTypes.VpcConfiguration?
        /// The IAM role that grants permissions to the Amazon Web Services resources that the workspace will view data from. This role must already exist.
        public var workspaceRoleArn: Swift.String?

        public init(
            accountAccessType: GrafanaClientTypes.AccountAccessType? = nil,
            authentication: GrafanaClientTypes.AuthenticationSummary? = nil,
            created: ClientRuntime.Date? = nil,
            dataSources: [GrafanaClientTypes.DataSourceType]? = nil,
            description: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            freeTrialConsumed: Swift.Bool? = nil,
            freeTrialExpiration: ClientRuntime.Date? = nil,
            grafanaVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            licenseExpiration: ClientRuntime.Date? = nil,
            licenseType: GrafanaClientTypes.LicenseType? = nil,
            modified: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            networkAccessControl: GrafanaClientTypes.NetworkAccessConfiguration? = nil,
            notificationDestinations: [GrafanaClientTypes.NotificationDestinationType]? = nil,
            organizationRoleName: Swift.String? = nil,
            organizationalUnits: [Swift.String]? = nil,
            permissionType: GrafanaClientTypes.PermissionType? = nil,
            stackSetName: Swift.String? = nil,
            status: GrafanaClientTypes.WorkspaceStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vpcConfiguration: GrafanaClientTypes.VpcConfiguration? = nil,
            workspaceRoleArn: Swift.String? = nil
        )
        {
            self.accountAccessType = accountAccessType
            self.authentication = authentication
            self.created = created
            self.dataSources = dataSources
            self.description = description
            self.endpoint = endpoint
            self.freeTrialConsumed = freeTrialConsumed
            self.freeTrialExpiration = freeTrialExpiration
            self.grafanaVersion = grafanaVersion
            self.id = id
            self.licenseExpiration = licenseExpiration
            self.licenseType = licenseType
            self.modified = modified
            self.name = name
            self.networkAccessControl = networkAccessControl
            self.notificationDestinations = notificationDestinations
            self.organizationRoleName = organizationRoleName
            self.organizationalUnits = organizationalUnits
            self.permissionType = permissionType
            self.stackSetName = stackSetName
            self.status = status
            self.tags = tags
            self.vpcConfiguration = vpcConfiguration
            self.workspaceRoleArn = workspaceRoleArn
        }
    }

}

extension GrafanaClientTypes {
    public enum WorkspaceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Workspace is active.
        case active
        /// Workspace is being created.
        case creating
        /// Workspace creation failed.
        case creationFailed
        /// Workspace is being deleted.
        case deleting
        /// Workspace deletion failed.
        case deletionFailed
        /// Workspace is in an invalid state, it can only and should be deleted.
        case failed
        /// Failed to remove enterprise license from workspace.
        case licenseRemovalFailed
        /// Workspace update failed.
        case updateFailed
        /// Workspace is being updated.
        case updating
        /// Workspace upgrade failed.
        case upgradeFailed
        /// Workspace is being upgraded to enterprise.
        case upgrading
        /// Workspace version update failed.
        case versionUpdateFailed
        /// Workspace version is being updated.
        case versionUpdating
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceStatus] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .deletionFailed,
                .failed,
                .licenseRemovalFailed,
                .updateFailed,
                .updating,
                .upgradeFailed,
                .upgrading,
                .versionUpdateFailed,
                .versionUpdating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .deletionFailed: return "DELETION_FAILED"
            case .failed: return "FAILED"
            case .licenseRemovalFailed: return "LICENSE_REMOVAL_FAILED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case .upgradeFailed: return "UPGRADE_FAILED"
            case .upgrading: return "UPGRADING"
            case .versionUpdateFailed: return "VERSION_UPDATE_FAILED"
            case .versionUpdating: return "VERSION_UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceStatus(rawValue: rawValue) ?? WorkspaceStatus.sdkUnknown(rawValue)
        }
    }
}

extension GrafanaClientTypes.WorkspaceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authentication
        case created
        case description
        case endpoint
        case grafanaVersion
        case id
        case modified
        case name
        case notificationDestinations
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authentication = self.authentication {
            try encodeContainer.encode(authentication, forKey: .authentication)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let grafanaVersion = self.grafanaVersion {
            try encodeContainer.encode(grafanaVersion, forKey: .grafanaVersion)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modified = self.modified {
            try encodeContainer.encodeTimestamp(modified, format: .epochSeconds, forKey: .modified)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notificationDestinations = notificationDestinations {
            var notificationDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationDestinations)
            for notificationdestinationtype0 in notificationDestinations {
                try notificationDestinationsContainer.encode(notificationdestinationtype0.rawValue)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let grafanaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grafanaVersion)
        grafanaVersion = grafanaVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let modifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modified)
        modified = modifiedDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let notificationDestinationsContainer = try containerValues.decodeIfPresent([GrafanaClientTypes.NotificationDestinationType?].self, forKey: .notificationDestinations)
        var notificationDestinationsDecoded0:[GrafanaClientTypes.NotificationDestinationType]? = nil
        if let notificationDestinationsContainer = notificationDestinationsContainer {
            notificationDestinationsDecoded0 = [GrafanaClientTypes.NotificationDestinationType]()
            for string0 in notificationDestinationsContainer {
                if let string0 = string0 {
                    notificationDestinationsDecoded0?.append(string0)
                }
            }
        }
        notificationDestinations = notificationDestinationsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.WorkspaceStatus.self, forKey: .status)
        status = statusDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(GrafanaClientTypes.AuthenticationSummary.self, forKey: .authentication)
        authentication = authenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GrafanaClientTypes.WorkspaceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorkspaceSummary(authentication: \(Swift.String(describing: authentication)), created: \(Swift.String(describing: created)), endpoint: \(Swift.String(describing: endpoint)), grafanaVersion: \(Swift.String(describing: grafanaVersion)), id: \(Swift.String(describing: id)), modified: \(Swift.String(describing: modified)), notificationDestinations: \(Swift.String(describing: notificationDestinations)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GrafanaClientTypes {
    /// A structure that contains some information about one workspace in the account.
    public struct WorkspaceSummary: Swift.Equatable {
        /// A structure containing information about the authentication methods used in the workspace.
        /// This member is required.
        public var authentication: GrafanaClientTypes.AuthenticationSummary?
        /// The date that the workspace was created.
        /// This member is required.
        public var created: ClientRuntime.Date?
        /// The customer-entered description of the workspace.
        public var description: Swift.String?
        /// The URL endpoint to use to access the Grafana console in the workspace.
        /// This member is required.
        public var endpoint: Swift.String?
        /// The Grafana version that the workspace is running.
        /// This member is required.
        public var grafanaVersion: Swift.String?
        /// The unique ID of the workspace.
        /// This member is required.
        public var id: Swift.String?
        /// The most recent date that the workspace was modified.
        /// This member is required.
        public var modified: ClientRuntime.Date?
        /// The name of the workspace.
        public var name: Swift.String?
        /// The Amazon Web Services notification channels that Amazon Managed Grafana can automatically create IAM roles and permissions for, which allows Amazon Managed Grafana to use these channels.
        public var notificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
        /// The current status of the workspace.
        /// This member is required.
        public var status: GrafanaClientTypes.WorkspaceStatus?
        /// The list of tags associated with the workspace.
        public var tags: [Swift.String:Swift.String]?

        public init(
            authentication: GrafanaClientTypes.AuthenticationSummary? = nil,
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            grafanaVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            modified: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            notificationDestinations: [GrafanaClientTypes.NotificationDestinationType]? = nil,
            status: GrafanaClientTypes.WorkspaceStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.authentication = authentication
            self.created = created
            self.description = description
            self.endpoint = endpoint
            self.grafanaVersion = grafanaVersion
            self.id = id
            self.modified = modified
            self.name = name
            self.notificationDestinations = notificationDestinations
            self.status = status
            self.tags = tags
        }
    }

}
