//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GrafanaClientTypes {

    public enum AccountAccessType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates that the customer is using Grafana to monitor resources in their current account.
        case currentAccount
        /// Indicates that the customer is using Grafana to monitor resources in organizational units.
        case organization
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountAccessType] {
            return [
                .currentAccount,
                .organization
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .currentAccount: return "CURRENT_ACCOUNT"
            case .organization: return "ORGANIZATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// A resource was in an inconsistent state during an update or a deletion.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Unexpected error while processing the request. Retry the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// How long to wait before you retry this operation.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The value of a parameter in the request caused an error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The value of a parameter in the request caused an error.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The request was denied because of request throttling. Retry the request.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The value of a parameter in the request caused an error.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The ID of the service that is associated with the error.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension GrafanaClientTypes {

    /// A structure that contains information about a request parameter that caused an error.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message describing why this field couldn't be validated.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that caused the validation error.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension GrafanaClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The value of a parameter in the request caused an error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A list of fields that might be associated with the error.
        public internal(set) var fieldList: [GrafanaClientTypes.ValidationExceptionField]? = nil
        /// A description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason that the operation failed.
        /// This member is required.
        public internal(set) var reason: GrafanaClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [GrafanaClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: GrafanaClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct CreateWorkspaceApiKeyInput: Swift.Sendable {
    /// Specifies the name of the key. Keynames must be unique to the workspace.
    /// This member is required.
    public var keyName: Swift.String?
    /// Specifies the permission level of the key. Valid values: ADMIN|EDITOR|VIEWER
    /// This member is required.
    public var keyRole: Swift.String?
    /// Specifies the time in seconds until the key expires. Keys can be valid for up to 30 days.
    /// This member is required.
    public var secondsToLive: Swift.Int?
    /// The ID of the workspace to create an API key.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        keyName: Swift.String? = nil,
        keyRole: Swift.String? = nil,
        secondsToLive: Swift.Int? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.keyName = keyName
        self.keyRole = keyRole
        self.secondsToLive = secondsToLive
        self.workspaceId = workspaceId
    }
}

public struct CreateWorkspaceApiKeyOutput: Swift.Sendable {
    /// The key token. Use this value as a bearer token to authenticate HTTP requests to the workspace.
    /// This member is required.
    public var key: Swift.String?
    /// The name of the key that was created.
    /// This member is required.
    public var keyName: Swift.String?
    /// The ID of the workspace that the key is valid for.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        key: Swift.String? = nil,
        keyName: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.key = key
        self.keyName = keyName
        self.workspaceId = workspaceId
    }
}

extension CreateWorkspaceApiKeyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkspaceApiKeyOutput(keyName: \(Swift.String(describing: keyName)), workspaceId: \(Swift.String(describing: workspaceId)), key: \"CONTENT_REDACTED\")"}
}

public struct DeleteWorkspaceApiKeyInput: Swift.Sendable {
    /// The name of the API key to delete.
    /// This member is required.
    public var keyName: Swift.String?
    /// The ID of the workspace to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        keyName: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.keyName = keyName
        self.workspaceId = workspaceId
    }
}

public struct DeleteWorkspaceApiKeyOutput: Swift.Sendable {
    /// The name of the key that was deleted.
    /// This member is required.
    public var keyName: Swift.String?
    /// The ID of the workspace where the key was deleted.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        keyName: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.keyName = keyName
        self.workspaceId = workspaceId
    }
}

extension GrafanaClientTypes {

    /// A structure that defines which attributes in the IdP assertion are to be used to define information about the users authenticated by the IdP to use the workspace.
    public struct AssertionAttributes: Swift.Sendable {
        /// The name of the attribute within the SAML assertion to use as the email names for SAML users.
        public var email: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the user full "friendly" names for user groups.
        public var groups: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the login names for SAML users.
        public var login: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the user full "friendly" names for SAML users.
        public var name: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the user full "friendly" names for the users' organizations.
        public var org: Swift.String?
        /// The name of the attribute within the SAML assertion to use as the user roles.
        public var role: Swift.String?

        public init(
            email: Swift.String? = nil,
            groups: Swift.String? = nil,
            login: Swift.String? = nil,
            name: Swift.String? = nil,
            org: Swift.String? = nil,
            role: Swift.String? = nil
        )
        {
            self.email = email
            self.groups = groups
            self.login = login
            self.name = name
            self.org = org
            self.role = role
        }
    }
}

extension GrafanaClientTypes {

    public enum LicenseType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Grafana Enterprise License.
        case enterprise
        /// Grafana Enterprise Free Trial License.
        case enterpriseFreeTrial
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseType] {
            return [
                .enterprise,
                .enterpriseFreeTrial
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enterprise: return "ENTERPRISE"
            case .enterpriseFreeTrial: return "ENTERPRISE_FREE_TRIAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AssociateLicenseInput: Swift.Sendable {
    /// A token from Grafana Labs that ties your Amazon Web Services account with a Grafana Labs account. For more information, see [Link your account with Grafana Labs](https://docs.aws.amazon.com/grafana/latest/userguide/upgrade-to-Grafana-Enterprise.html#AMG-workspace-register-enterprise).
    public var grafanaToken: Swift.String?
    /// The type of license to associate with the workspace. Amazon Managed Grafana workspaces no longer support Grafana Enterprise free trials.
    /// This member is required.
    public var licenseType: GrafanaClientTypes.LicenseType?
    /// The ID of the workspace to associate the license with.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        grafanaToken: Swift.String? = nil,
        licenseType: GrafanaClientTypes.LicenseType? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.grafanaToken = grafanaToken
        self.licenseType = licenseType
        self.workspaceId = workspaceId
    }
}

extension GrafanaClientTypes {

    public enum AuthenticationProviderTypes: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates that AMG workspace has AWS SSO enabled as its authentication provider.
        case awsSso
        /// Indicates that the AMG workspace has SAML enabled as its authentication provider.
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationProviderTypes] {
            return [
                .awsSso,
                .saml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsSso: return "AWS_SSO"
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GrafanaClientTypes {

    public enum SamlConfigurationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates that SAML on an AMG workspace is enabled and has been configured.
        case configured
        /// Indicates that SAML on an AMG workspace is enabled but has not been configured.
        case notConfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [SamlConfigurationStatus] {
            return [
                .configured,
                .notConfigured
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configured: return "CONFIGURED"
            case .notConfigured: return "NOT_CONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GrafanaClientTypes {

    /// A structure that describes whether the workspace uses SAML, IAM Identity Center, or both methods for user authentication, and whether that authentication is fully configured.
    public struct AuthenticationSummary: Swift.Sendable {
        /// Specifies whether the workspace uses SAML, IAM Identity Center, or both methods for user authentication.
        /// This member is required.
        public var providers: [GrafanaClientTypes.AuthenticationProviderTypes]?
        /// Specifies whether the workplace's user authentication method is fully configured.
        public var samlConfigurationStatus: GrafanaClientTypes.SamlConfigurationStatus?

        public init(
            providers: [GrafanaClientTypes.AuthenticationProviderTypes]? = nil,
            samlConfigurationStatus: GrafanaClientTypes.SamlConfigurationStatus? = nil
        )
        {
            self.providers = providers
            self.samlConfigurationStatus = samlConfigurationStatus
        }
    }
}

extension GrafanaClientTypes {

    public enum DataSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Amazon OpenSearch Service
        case amazonOpensearchService
        /// Amazon Athena
        case athena
        /// CloudWatch Logs
        case cloudwatch
        /// Managed Prometheus
        case prometheus
        /// Redshift
        case redshift
        /// IoT SiteWise
        case sitewise
        /// Timestream
        case timestream
        /// IoT TwinMaker
        case twinmaker
        /// X-Ray
        case xray
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .amazonOpensearchService,
                .athena,
                .cloudwatch,
                .prometheus,
                .redshift,
                .sitewise,
                .timestream,
                .twinmaker,
                .xray
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonOpensearchService: return "AMAZON_OPENSEARCH_SERVICE"
            case .athena: return "ATHENA"
            case .cloudwatch: return "CLOUDWATCH"
            case .prometheus: return "PROMETHEUS"
            case .redshift: return "REDSHIFT"
            case .sitewise: return "SITEWISE"
            case .timestream: return "TIMESTREAM"
            case .twinmaker: return "TWINMAKER"
            case .xray: return "XRAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GrafanaClientTypes {

    /// The configuration settings for in-bound network access to your workspace. When this is configured, only listed IP addresses and VPC endpoints will be able to access your workspace. Standard Grafana authentication and authorization are still required. Access is granted to a caller that is in either the IP address list or the VPC endpoint list - they do not need to be in both. If this is not configured, or is removed, then all IP addresses and VPC endpoints are allowed. Standard Grafana authentication and authorization are still required. While both prefixListIds and vpceIds are required, you can pass in an empty array of strings for either parameter if you do not want to allow any of that type. If both are passed as empty arrays, no traffic is allowed to the workspace, because only explicitly allowed connections are accepted.
    public struct NetworkAccessConfiguration: Swift.Sendable {
        /// An array of prefix list IDs. A prefix list is a list of CIDR ranges of IP addresses. The IP addresses specified are allowed to access your workspace. If the list is not included in the configuration (passed an empty array) then no IP addresses are allowed to access the workspace. You create a prefix list using the Amazon VPC console. Prefix list IDs have the format pl-1a2b3c4d . For more information about prefix lists, see [Group CIDR blocks using managed prefix lists](https://docs.aws.amazon.com/vpc/latest/userguide/managed-prefix-lists.html)in the Amazon Virtual Private Cloud User Guide.
        /// This member is required.
        public var prefixListIds: [Swift.String]?
        /// An array of Amazon VPC endpoint IDs for the workspace. You can create VPC endpoints to your Amazon Managed Grafana workspace for access from within a VPC. If a NetworkAccessConfiguration is specified then only VPC endpoints specified here are allowed to access the workspace. If you pass in an empty array of strings, then no VPCs are allowed to access the workspace. VPC endpoint IDs have the format vpce-1a2b3c4d . For more information about creating an interface VPC endpoint, see [Interface VPC endpoints](https://docs.aws.amazon.com/grafana/latest/userguide/VPC-endpoints) in the Amazon Managed Grafana User Guide. The only VPC endpoints that can be specified here are interface VPC endpoints for Grafana workspaces (using the com.amazonaws.[region].grafana-workspace service endpoint). Other VPC endpoints are ignored.
        /// This member is required.
        public var vpceIds: [Swift.String]?

        public init(
            prefixListIds: [Swift.String]? = nil,
            vpceIds: [Swift.String]? = nil
        )
        {
            self.prefixListIds = prefixListIds
            self.vpceIds = vpceIds
        }
    }
}

extension GrafanaClientTypes {

    public enum NotificationDestinationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// AWS Simple Notification Service
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationDestinationType] {
            return [
                .sns
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GrafanaClientTypes {

    public enum PermissionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Customer Managed
        case customerManaged
        /// Service Managed
        case serviceManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .customerManaged,
                .serviceManaged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customerManaged: return "CUSTOMER_MANAGED"
            case .serviceManaged: return "SERVICE_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GrafanaClientTypes {

    public enum WorkspaceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Workspace is active.
        case active
        /// Workspace is being created.
        case creating
        /// Workspace creation failed.
        case creationFailed
        /// Workspace is being deleted.
        case deleting
        /// Workspace deletion failed.
        case deletionFailed
        /// Workspace is in an invalid state, it can only and should be deleted.
        case failed
        /// Failed to remove enterprise license from workspace.
        case licenseRemovalFailed
        /// Workspace update failed.
        case updateFailed
        /// Workspace is being updated.
        case updating
        /// Workspace upgrade failed.
        case upgradeFailed
        /// Workspace is being upgraded to enterprise.
        case upgrading
        /// Workspace version update failed.
        case versionUpdateFailed
        /// Workspace version is being updated.
        case versionUpdating
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceStatus] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .deletionFailed,
                .failed,
                .licenseRemovalFailed,
                .updateFailed,
                .updating,
                .upgradeFailed,
                .upgrading,
                .versionUpdateFailed,
                .versionUpdating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .deletionFailed: return "DELETION_FAILED"
            case .failed: return "FAILED"
            case .licenseRemovalFailed: return "LICENSE_REMOVAL_FAILED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case .upgradeFailed: return "UPGRADE_FAILED"
            case .upgrading: return "UPGRADING"
            case .versionUpdateFailed: return "VERSION_UPDATE_FAILED"
            case .versionUpdating: return "VERSION_UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GrafanaClientTypes {

    /// The configuration settings for an Amazon VPC that contains data sources for your Grafana workspace to connect to. Provided securityGroupIds and subnetIds must be part of the same VPC. Connecting to a private VPC is not yet available in the Asia Pacific (Seoul) Region (ap-northeast-2).
    public struct VpcConfiguration: Swift.Sendable {
        /// The list of Amazon EC2 security group IDs attached to the Amazon VPC for your Grafana workspace to connect. Duplicates not allowed.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// The list of Amazon EC2 subnet IDs created in the Amazon VPC for your Grafana workspace to connect. Duplicates not allowed.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }
}

extension GrafanaClientTypes {

    /// A structure containing information about an Amazon Managed Grafana workspace in your account.
    public struct WorkspaceDescription: Swift.Sendable {
        /// Specifies whether the workspace can access Amazon Web Services resources in this Amazon Web Services account only, or whether it can also access Amazon Web Services resources in other accounts in the same organization. If this is ORGANIZATION, the workspaceOrganizationalUnits parameter specifies which organizational units the workspace can access.
        public var accountAccessType: GrafanaClientTypes.AccountAccessType?
        /// A structure that describes whether the workspace uses SAML, IAM Identity Center, or both methods for user authentication.
        /// This member is required.
        public var authentication: GrafanaClientTypes.AuthenticationSummary?
        /// The date that the workspace was created.
        /// This member is required.
        public var created: Foundation.Date?
        /// Specifies the Amazon Web Services data sources that have been configured to have IAM roles and permissions created to allow Amazon Managed Grafana to read data from these sources. This list is only used when the workspace was created through the Amazon Web Services console, and the permissionType is SERVICE_MANAGED.
        /// This member is required.
        public var dataSources: [GrafanaClientTypes.DataSourceType]?
        /// The user-defined description of the workspace.
        public var description: Swift.String?
        /// The URL that users can use to access the Grafana console in the workspace.
        /// This member is required.
        public var endpoint: Swift.String?
        /// Specifies whether this workspace has already fully used its free trial for Grafana Enterprise. Amazon Managed Grafana workspaces no longer support Grafana Enterprise free trials.
        public var freeTrialConsumed: Swift.Bool?
        /// If this workspace is currently in the free trial period for Grafana Enterprise, this value specifies when that free trial ends. Amazon Managed Grafana workspaces no longer support Grafana Enterprise free trials.
        public var freeTrialExpiration: Foundation.Date?
        /// The token that ties this workspace to a Grafana Labs account. For more information, see [Link your account with Grafana Labs](https://docs.aws.amazon.com/grafana/latest/userguide/upgrade-to-Grafana-Enterprise.html#AMG-workspace-register-enterprise).
        public var grafanaToken: Swift.String?
        /// The version of Grafana supported in this workspace.
        /// This member is required.
        public var grafanaVersion: Swift.String?
        /// The unique ID of this workspace.
        /// This member is required.
        public var id: Swift.String?
        /// If this workspace has a full Grafana Enterprise license purchased through Amazon Web Services Marketplace, this specifies when the license ends and will need to be renewed. Purchasing the Enterprise plugins option through Amazon Managed Grafana does not have an expiration. It is valid until the license is removed.
        public var licenseExpiration: Foundation.Date?
        /// Specifies whether this workspace has a full Grafana Enterprise license. Amazon Managed Grafana workspaces no longer support Grafana Enterprise free trials.
        public var licenseType: GrafanaClientTypes.LicenseType?
        /// The most recent date that the workspace was modified.
        /// This member is required.
        public var modified: Foundation.Date?
        /// The name of the workspace.
        public var name: Swift.String?
        /// The configuration settings for network access to your workspace.
        public var networkAccessControl: GrafanaClientTypes.NetworkAccessConfiguration?
        /// The Amazon Web Services notification channels that Amazon Managed Grafana can automatically create IAM roles and permissions for, to allow Amazon Managed Grafana to use these channels.
        public var notificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
        /// The name of the IAM role that is used to access resources through Organizations.
        public var organizationRoleName: Swift.String?
        /// Specifies the organizational units that this workspace is allowed to use data sources from, if this workspace is in an account that is part of an organization.
        public var organizationalUnits: [Swift.String]?
        /// If this is SERVICE_MANAGED, and the workplace was created through the Amazon Managed Grafana console, then Amazon Managed Grafana automatically creates the IAM roles and provisions the permissions that the workspace needs to use Amazon Web Services data sources and notification channels. If this is CUSTOMER_MANAGED, you must manage those roles and permissions yourself. If you are working with a workspace in a member account of an organization and that account is not a delegated administrator account, and you want the workspace to access data sources in other Amazon Web Services accounts in the organization, this parameter must be set to CUSTOMER_MANAGED. For more information about converting between customer and service managed, see [Managing permissions for data sources and notification channels](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-datasource-and-notification.html). For more information about the roles and permissions that must be managed for customer managed workspaces, see [Amazon Managed Grafana permissions and policies for Amazon Web Services data sources and notification channels](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-manage-permissions.html)
        public var permissionType: GrafanaClientTypes.PermissionType?
        /// The name of the CloudFormation stack set that is used to generate IAM roles to be used for this workspace.
        public var stackSetName: Swift.String?
        /// The current status of the workspace.
        /// This member is required.
        public var status: GrafanaClientTypes.WorkspaceStatus?
        /// The list of tags associated with the workspace.
        public var tags: [Swift.String: Swift.String]?
        /// The configuration for connecting to data sources in a private VPC (Amazon Virtual Private Cloud).
        public var vpcConfiguration: GrafanaClientTypes.VpcConfiguration?
        /// The IAM role that grants permissions to the Amazon Web Services resources that the workspace will view data from. This role must already exist.
        public var workspaceRoleArn: Swift.String?

        public init(
            accountAccessType: GrafanaClientTypes.AccountAccessType? = nil,
            authentication: GrafanaClientTypes.AuthenticationSummary? = nil,
            created: Foundation.Date? = nil,
            dataSources: [GrafanaClientTypes.DataSourceType]? = nil,
            description: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            freeTrialConsumed: Swift.Bool? = nil,
            freeTrialExpiration: Foundation.Date? = nil,
            grafanaToken: Swift.String? = nil,
            grafanaVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            licenseExpiration: Foundation.Date? = nil,
            licenseType: GrafanaClientTypes.LicenseType? = nil,
            modified: Foundation.Date? = nil,
            name: Swift.String? = nil,
            networkAccessControl: GrafanaClientTypes.NetworkAccessConfiguration? = nil,
            notificationDestinations: [GrafanaClientTypes.NotificationDestinationType]? = nil,
            organizationRoleName: Swift.String? = nil,
            organizationalUnits: [Swift.String]? = nil,
            permissionType: GrafanaClientTypes.PermissionType? = nil,
            stackSetName: Swift.String? = nil,
            status: GrafanaClientTypes.WorkspaceStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            vpcConfiguration: GrafanaClientTypes.VpcConfiguration? = nil,
            workspaceRoleArn: Swift.String? = nil
        )
        {
            self.accountAccessType = accountAccessType
            self.authentication = authentication
            self.created = created
            self.dataSources = dataSources
            self.description = description
            self.endpoint = endpoint
            self.freeTrialConsumed = freeTrialConsumed
            self.freeTrialExpiration = freeTrialExpiration
            self.grafanaToken = grafanaToken
            self.grafanaVersion = grafanaVersion
            self.id = id
            self.licenseExpiration = licenseExpiration
            self.licenseType = licenseType
            self.modified = modified
            self.name = name
            self.networkAccessControl = networkAccessControl
            self.notificationDestinations = notificationDestinations
            self.organizationRoleName = organizationRoleName
            self.organizationalUnits = organizationalUnits
            self.permissionType = permissionType
            self.stackSetName = stackSetName
            self.status = status
            self.tags = tags
            self.vpcConfiguration = vpcConfiguration
            self.workspaceRoleArn = workspaceRoleArn
        }
    }
}

extension GrafanaClientTypes.WorkspaceDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorkspaceDescription(accountAccessType: \(Swift.String(describing: accountAccessType)), authentication: \(Swift.String(describing: authentication)), created: \(Swift.String(describing: created)), dataSources: \(Swift.String(describing: dataSources)), endpoint: \(Swift.String(describing: endpoint)), freeTrialConsumed: \(Swift.String(describing: freeTrialConsumed)), freeTrialExpiration: \(Swift.String(describing: freeTrialExpiration)), grafanaToken: \(Swift.String(describing: grafanaToken)), grafanaVersion: \(Swift.String(describing: grafanaVersion)), id: \(Swift.String(describing: id)), licenseExpiration: \(Swift.String(describing: licenseExpiration)), licenseType: \(Swift.String(describing: licenseType)), modified: \(Swift.String(describing: modified)), networkAccessControl: \(Swift.String(describing: networkAccessControl)), notificationDestinations: \(Swift.String(describing: notificationDestinations)), permissionType: \(Swift.String(describing: permissionType)), stackSetName: \(Swift.String(describing: stackSetName)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), vpcConfiguration: \(Swift.String(describing: vpcConfiguration)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", organizationRoleName: \"CONTENT_REDACTED\", organizationalUnits: \"CONTENT_REDACTED\", workspaceRoleArn: \"CONTENT_REDACTED\")"}
}

public struct AssociateLicenseOutput: Swift.Sendable {
    /// A structure containing data about the workspace.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init(
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

public struct DescribeWorkspaceAuthenticationInput: Swift.Sendable {
    /// The ID of the workspace to return authentication information about.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

extension GrafanaClientTypes {

    /// A structure containing information about how this workspace works with IAM Identity Center.
    public struct AwsSsoAuthentication: Swift.Sendable {
        /// The ID of the IAM Identity Center-managed application that is created by Amazon Managed Grafana.
        public var ssoClientId: Swift.String?

        public init(
            ssoClientId: Swift.String? = nil
        )
        {
            self.ssoClientId = ssoClientId
        }
    }
}

extension GrafanaClientTypes {

    /// A structure containing the identity provider (IdP) metadata used to integrate the identity provider with this workspace. You can specify the metadata either by providing a URL to its location in the url parameter, or by specifying the full metadata in XML format in the xml parameter. Specifying both will cause an error.
    public enum IdpMetadata: Swift.Sendable {
        /// The URL of the location containing the IdP metadata.
        case url(Swift.String)
        /// The full IdP metadata, in XML format.
        case xml(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension GrafanaClientTypes {

    /// This structure defines which groups defined in the SAML assertion attribute are to be mapped to the Grafana Admin and Editor roles in the workspace. SAML authenticated users not part of Admin or Editor role groups have Viewer permission over the workspace.
    public struct RoleValues: Swift.Sendable {
        /// A list of groups from the SAML assertion attribute to grant the Grafana Admin role to.
        public var admin: [Swift.String]?
        /// A list of groups from the SAML assertion attribute to grant the Grafana Editor role to.
        public var editor: [Swift.String]?

        public init(
            admin: [Swift.String]? = nil,
            editor: [Swift.String]? = nil
        )
        {
            self.admin = admin
            self.editor = editor
        }
    }
}

extension GrafanaClientTypes.RoleValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoleValues(admin: \"CONTENT_REDACTED\", editor: \"CONTENT_REDACTED\")"}
}

extension GrafanaClientTypes {

    /// A structure containing information about how this workspace works with SAML.
    public struct SamlConfiguration: Swift.Sendable {
        /// Lists which organizations defined in the SAML assertion are allowed to use the Amazon Managed Grafana workspace. If this is empty, all organizations in the assertion attribute have access.
        public var allowedOrganizations: [Swift.String]?
        /// A structure that defines which attributes in the SAML assertion are to be used to define information about the users authenticated by that IdP to use the workspace.
        public var assertionAttributes: GrafanaClientTypes.AssertionAttributes?
        /// A structure containing the identity provider (IdP) metadata used to integrate the identity provider with this workspace.
        /// This member is required.
        public var idpMetadata: GrafanaClientTypes.IdpMetadata?
        /// How long a sign-on session by a SAML user is valid, before the user has to sign on again.
        public var loginValidityDuration: Swift.Int
        /// A structure containing arrays that map group names in the SAML assertion to the Grafana Admin and Editor roles in the workspace.
        public var roleValues: GrafanaClientTypes.RoleValues?

        public init(
            allowedOrganizations: [Swift.String]? = nil,
            assertionAttributes: GrafanaClientTypes.AssertionAttributes? = nil,
            idpMetadata: GrafanaClientTypes.IdpMetadata? = nil,
            loginValidityDuration: Swift.Int = 0,
            roleValues: GrafanaClientTypes.RoleValues? = nil
        )
        {
            self.allowedOrganizations = allowedOrganizations
            self.assertionAttributes = assertionAttributes
            self.idpMetadata = idpMetadata
            self.loginValidityDuration = loginValidityDuration
            self.roleValues = roleValues
        }
    }
}

extension GrafanaClientTypes {

    /// A structure containing information about how this workspace works with SAML.
    public struct SamlAuthentication: Swift.Sendable {
        /// A structure containing details about how this workspace works with SAML.
        public var configuration: GrafanaClientTypes.SamlConfiguration?
        /// Specifies whether the workspace's SAML configuration is complete.
        /// This member is required.
        public var status: GrafanaClientTypes.SamlConfigurationStatus?

        public init(
            configuration: GrafanaClientTypes.SamlConfiguration? = nil,
            status: GrafanaClientTypes.SamlConfigurationStatus? = nil
        )
        {
            self.configuration = configuration
            self.status = status
        }
    }
}

extension GrafanaClientTypes {

    /// A structure containing information about the user authentication methods used by the workspace.
    public struct AuthenticationDescription: Swift.Sendable {
        /// A structure containing information about how this workspace works with IAM Identity Center.
        public var awsSso: GrafanaClientTypes.AwsSsoAuthentication?
        /// Specifies whether this workspace uses IAM Identity Center, SAML, or both methods to authenticate users to use the Grafana console in the Amazon Managed Grafana workspace.
        /// This member is required.
        public var providers: [GrafanaClientTypes.AuthenticationProviderTypes]?
        /// A structure containing information about how this workspace works with SAML, including what attributes within the assertion are to be mapped to user information in the workspace.
        public var saml: GrafanaClientTypes.SamlAuthentication?

        public init(
            awsSso: GrafanaClientTypes.AwsSsoAuthentication? = nil,
            providers: [GrafanaClientTypes.AuthenticationProviderTypes]? = nil,
            saml: GrafanaClientTypes.SamlAuthentication? = nil
        )
        {
            self.awsSso = awsSso
            self.providers = providers
            self.saml = saml
        }
    }
}

public struct DescribeWorkspaceAuthenticationOutput: Swift.Sendable {
    /// A structure containing information about the authentication methods used in the workspace.
    /// This member is required.
    public var authentication: GrafanaClientTypes.AuthenticationDescription?

    public init(
        authentication: GrafanaClientTypes.AuthenticationDescription? = nil
    )
    {
        self.authentication = authentication
    }
}

public struct UpdateWorkspaceAuthenticationInput: Swift.Sendable {
    /// Specifies whether this workspace uses SAML 2.0, IAM Identity Center, or both to authenticate users for using the Grafana console within a workspace. For more information, see [User authentication in Amazon Managed Grafana](https://docs.aws.amazon.com/grafana/latest/userguide/authentication-in-AMG.html).
    /// This member is required.
    public var authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]?
    /// If the workspace uses SAML, use this structure to map SAML assertion attributes to workspace user information and define which groups in the assertion attribute are to have the Admin and Editor roles in the workspace.
    public var samlConfiguration: GrafanaClientTypes.SamlConfiguration?
    /// The ID of the workspace to update the authentication for.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]? = nil,
        samlConfiguration: GrafanaClientTypes.SamlConfiguration? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.authenticationProviders = authenticationProviders
        self.samlConfiguration = samlConfiguration
        self.workspaceId = workspaceId
    }
}

public struct UpdateWorkspaceAuthenticationOutput: Swift.Sendable {
    /// A structure that describes the user authentication for this workspace after the update is made.
    /// This member is required.
    public var authentication: GrafanaClientTypes.AuthenticationDescription?

    public init(
        authentication: GrafanaClientTypes.AuthenticationDescription? = nil
    )
    {
        self.authentication = authentication
    }
}

public struct DescribeWorkspaceConfigurationInput: Swift.Sendable {
    /// The ID of the workspace to get configuration information for.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

public struct DescribeWorkspaceConfigurationOutput: Swift.Sendable {
    /// The configuration string for the workspace that you requested. For more information about the format and configuration options available, see [Working in your Grafana workspace](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-configure-workspace.html).
    /// This member is required.
    public var configuration: Swift.String?
    /// The supported Grafana version for the workspace.
    public var grafanaVersion: Swift.String?

    public init(
        configuration: Swift.String? = nil,
        grafanaVersion: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.grafanaVersion = grafanaVersion
    }
}

public struct UpdateWorkspaceConfigurationInput: Swift.Sendable {
    /// The new configuration string for the workspace. For more information about the format and configuration options available, see [Working in your Grafana workspace](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-configure-workspace.html).
    /// This member is required.
    public var configuration: Swift.String?
    /// Specifies the version of Grafana to support in the workspace. If not specified, keeps the current version of the workspace. Can only be used to upgrade (for example, from 8.4 to 9.4), not downgrade (for example, from 9.4 to 8.4). To know what versions are available to upgrade to for a specific workspace, see the [ListVersions](https://docs.aws.amazon.com/grafana/latest/APIReference/API_ListVersions.html) operation.
    public var grafanaVersion: Swift.String?
    /// The ID of the workspace to update.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        configuration: Swift.String? = nil,
        grafanaVersion: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.grafanaVersion = grafanaVersion
        self.workspaceId = workspaceId
    }
}

public struct UpdateWorkspaceConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateLicenseInput: Swift.Sendable {
    /// The type of license to remove from the workspace.
    /// This member is required.
    public var licenseType: GrafanaClientTypes.LicenseType?
    /// The ID of the workspace to remove the Grafana Enterprise license from.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        licenseType: GrafanaClientTypes.LicenseType? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.licenseType = licenseType
        self.workspaceId = workspaceId
    }
}

public struct DisassociateLicenseOutput: Swift.Sendable {
    /// A structure containing information about the workspace.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init(
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource the list of tags are associated with.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of tags that are associated with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListVersionsInput: Swift.Sendable {
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You receive this token from a previous ListVersions operation.
    public var nextToken: Swift.String?
    /// The ID of the workspace to list the available upgrade versions. If not included, lists all versions of Grafana that are supported for CreateWorkspace.
    public var workspaceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

public struct ListVersionsOutput: Swift.Sendable {
    /// The Grafana versions available to create. If a workspace ID is included in the request, the Grafana versions to which this workspace can be upgraded.
    public var grafanaVersions: [Swift.String]?
    /// The token to use in a subsequent ListVersions operation to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        grafanaVersions: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.grafanaVersions = grafanaVersions
        self.nextToken = nextToken
    }
}

extension GrafanaClientTypes {

    public enum UserType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// SSO group.
        case ssoGroup
        /// SSO user.
        case ssoUser
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .ssoGroup,
                .ssoUser
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ssoGroup: return "SSO_GROUP"
            case .ssoUser: return "SSO_USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListPermissionsInput: Swift.Sendable {
    /// (Optional) Limits the results to only the group that matches this ID.
    public var groupId: Swift.String?
    /// The maximum number of results to include in the response.
    public var maxResults: Swift.Int?
    /// The token to use when requesting the next set of results. You received this token from a previous ListPermissions operation.
    public var nextToken: Swift.String?
    /// (Optional) Limits the results to only the user that matches this ID.
    public var userId: Swift.String?
    /// (Optional) If you specify SSO_USER, then only the permissions of IAM Identity Center users are returned. If you specify SSO_GROUP, only the permissions of IAM Identity Center groups are returned.
    public var userType: GrafanaClientTypes.UserType?
    /// The ID of the workspace to list permissions for. This parameter is required.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userId: Swift.String? = nil,
        userType: GrafanaClientTypes.UserType? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userId = userId
        self.userType = userType
        self.workspaceId = workspaceId
    }
}

extension GrafanaClientTypes {

    public enum Role: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Role Admin.
        case admin
        /// Role Editor.
        case editor
        /// Role Viewer.
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [Role] {
            return [
                .admin,
                .editor,
                .viewer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .admin: return "ADMIN"
            case .editor: return "EDITOR"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GrafanaClientTypes {

    /// A structure that specifies one user or group in the workspace.
    public struct User: Swift.Sendable {
        /// The ID of the user or group. Pattern: ^([0-9a-fA-F]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$
        /// This member is required.
        public var id: Swift.String?
        /// Specifies whether this is a single user or a group.
        /// This member is required.
        public var type: GrafanaClientTypes.UserType?

        public init(
            id: Swift.String? = nil,
            type: GrafanaClientTypes.UserType? = nil
        )
        {
            self.id = id
            self.type = type
        }
    }
}

extension GrafanaClientTypes {

    /// A structure containing the identity of one user or group and the Admin, Editor, or Viewer role that they have.
    public struct PermissionEntry: Swift.Sendable {
        /// Specifies whether the user or group has the Admin, Editor, or Viewer role.
        /// This member is required.
        public var role: GrafanaClientTypes.Role?
        /// A structure with the ID of the user or group with this role.
        /// This member is required.
        public var user: GrafanaClientTypes.User?

        public init(
            role: GrafanaClientTypes.Role? = nil,
            user: GrafanaClientTypes.User? = nil
        )
        {
            self.role = role
            self.user = user
        }
    }
}

public struct ListPermissionsOutput: Swift.Sendable {
    /// The token to use in a subsequent ListPermissions operation to return the next set of results.
    public var nextToken: Swift.String?
    /// The permissions returned by the operation.
    /// This member is required.
    public var permissions: [GrafanaClientTypes.PermissionEntry]?

    public init(
        nextToken: Swift.String? = nil,
        permissions: [GrafanaClientTypes.PermissionEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

extension GrafanaClientTypes {

    public enum UpdateAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Add permissions.
        case add
        /// Revoke permissions.
        case revoke
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateAction] {
            return [
                .add,
                .revoke
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .revoke: return "REVOKE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GrafanaClientTypes {

    /// Contains the instructions for one Grafana role permission update in a [UpdatePermissions](https://docs.aws.amazon.com/grafana/latest/APIReference/API_UpdatePermissions.html) operation.
    public struct UpdateInstruction: Swift.Sendable {
        /// Specifies whether this update is to add or revoke role permissions.
        /// This member is required.
        public var action: GrafanaClientTypes.UpdateAction?
        /// The role to add or revoke for the user or the group specified in users.
        /// This member is required.
        public var role: GrafanaClientTypes.Role?
        /// A structure that specifies the user or group to add or revoke the role for.
        /// This member is required.
        public var users: [GrafanaClientTypes.User]?

        public init(
            action: GrafanaClientTypes.UpdateAction? = nil,
            role: GrafanaClientTypes.Role? = nil,
            users: [GrafanaClientTypes.User]? = nil
        )
        {
            self.action = action
            self.role = role
            self.users = users
        }
    }
}

public struct UpdatePermissionsInput: Swift.Sendable {
    /// An array of structures that contain the permission updates to make.
    /// This member is required.
    public var updateInstructionBatch: [GrafanaClientTypes.UpdateInstruction]?
    /// The ID of the workspace to update.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        updateInstructionBatch: [GrafanaClientTypes.UpdateInstruction]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.updateInstructionBatch = updateInstructionBatch
        self.workspaceId = workspaceId
    }
}

extension GrafanaClientTypes {

    /// A structure containing information about one error encountered while performing an [UpdatePermissions](https://docs.aws.amazon.com/grafana/latest/APIReference/API_UpdatePermissions.html) operation.
    public struct UpdateError: Swift.Sendable {
        /// Specifies which permission update caused the error.
        /// This member is required.
        public var causedBy: GrafanaClientTypes.UpdateInstruction?
        /// The error code.
        /// This member is required.
        public var code: Swift.Int?
        /// The message for this error.
        /// This member is required.
        public var message: Swift.String?

        public init(
            causedBy: GrafanaClientTypes.UpdateInstruction? = nil,
            code: Swift.Int? = nil,
            message: Swift.String? = nil
        )
        {
            self.causedBy = causedBy
            self.code = code
            self.message = message
        }
    }
}

public struct UpdatePermissionsOutput: Swift.Sendable {
    /// An array of structures that contain the errors from the operation, if any.
    /// This member is required.
    public var errors: [GrafanaClientTypes.UpdateError]?

    public init(
        errors: [GrafanaClientTypes.UpdateError]? = nil
    )
    {
        self.errors = errors
    }
}

public struct CreateWorkspaceServiceAccountInput: Swift.Sendable {
    /// The permission level to use for this service account. For more information about the roles and the permissions each has, see [User roles](https://docs.aws.amazon.com/grafana/latest/userguide/Grafana-user-roles.html) in the Amazon Managed Grafana User Guide.
    /// This member is required.
    public var grafanaRole: GrafanaClientTypes.Role?
    /// A name for the service account. The name must be unique within the workspace, as it determines the ID associated with the service account.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the workspace within which to create the service account.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        grafanaRole: GrafanaClientTypes.Role? = nil,
        name: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.grafanaRole = grafanaRole
        self.name = name
        self.workspaceId = workspaceId
    }
}

public struct CreateWorkspaceServiceAccountOutput: Swift.Sendable {
    /// The permission level given to the service account.
    /// This member is required.
    public var grafanaRole: GrafanaClientTypes.Role?
    /// The ID of the service account.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the service account.
    /// This member is required.
    public var name: Swift.String?
    /// The workspace with which the service account is associated.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        grafanaRole: GrafanaClientTypes.Role? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.grafanaRole = grafanaRole
        self.id = id
        self.name = name
        self.workspaceId = workspaceId
    }
}

public struct DeleteWorkspaceServiceAccountInput: Swift.Sendable {
    /// The ID of the service account to delete.
    /// This member is required.
    public var serviceAccountId: Swift.String?
    /// The ID of the workspace where the service account resides.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        serviceAccountId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.serviceAccountId = serviceAccountId
        self.workspaceId = workspaceId
    }
}

public struct DeleteWorkspaceServiceAccountOutput: Swift.Sendable {
    /// The ID of the service account deleted.
    /// This member is required.
    public var serviceAccountId: Swift.String?
    /// The ID of the workspace where the service account was deleted.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        serviceAccountId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.serviceAccountId = serviceAccountId
        self.workspaceId = workspaceId
    }
}

public struct ListWorkspaceServiceAccountsInput: Swift.Sendable {
    /// The maximum number of service accounts to include in the results.
    public var maxResults: Swift.Int?
    /// The token for the next set of service accounts to return. (You receive this token from a previous ListWorkspaceServiceAccounts operation.)
    public var nextToken: Swift.String?
    /// The workspace for which to list service accounts.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

extension GrafanaClientTypes {

    /// A structure that contains the information about one service account.
    public struct ServiceAccountSummary: Swift.Sendable {
        /// The role of the service account, which sets the permission level used when calling Grafana APIs.
        /// This member is required.
        public var grafanaRole: GrafanaClientTypes.Role?
        /// The unique ID of the service account.
        /// This member is required.
        public var id: Swift.String?
        /// Returns true if the service account is disabled. Service accounts can be disabled and enabled in the Amazon Managed Grafana console.
        /// This member is required.
        public var isDisabled: Swift.String?
        /// The name of the service account.
        /// This member is required.
        public var name: Swift.String?

        public init(
            grafanaRole: GrafanaClientTypes.Role? = nil,
            id: Swift.String? = nil,
            isDisabled: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.grafanaRole = grafanaRole
            self.id = id
            self.isDisabled = isDisabled
            self.name = name
        }
    }
}

public struct ListWorkspaceServiceAccountsOutput: Swift.Sendable {
    /// The token to use when requesting the next set of service accounts.
    public var nextToken: Swift.String?
    /// An array of structures containing information about the service accounts.
    /// This member is required.
    public var serviceAccounts: [GrafanaClientTypes.ServiceAccountSummary]?
    /// The workspace to which the service accounts are associated.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        serviceAccounts: [GrafanaClientTypes.ServiceAccountSummary]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceAccounts = serviceAccounts
        self.workspaceId = workspaceId
    }
}

public struct CreateWorkspaceServiceAccountTokenInput: Swift.Sendable {
    /// A name for the token to create.
    /// This member is required.
    public var name: Swift.String?
    /// Sets how long the token will be valid, in seconds. You can set the time up to 30 days in the future.
    /// This member is required.
    public var secondsToLive: Swift.Int?
    /// The ID of the service account for which to create a token.
    /// This member is required.
    public var serviceAccountId: Swift.String?
    /// The ID of the workspace the service account resides within.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        name: Swift.String? = nil,
        secondsToLive: Swift.Int? = nil,
        serviceAccountId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.name = name
        self.secondsToLive = secondsToLive
        self.serviceAccountId = serviceAccountId
        self.workspaceId = workspaceId
    }
}

extension GrafanaClientTypes {

    /// A structure that contains the information about a service account token. This structure is returned when creating the token. It is important to store the key that is returned, as it is not retrievable at a later time. If you lose the key, you can delete and recreate the token, which will create a new key.
    public struct ServiceAccountTokenSummaryWithKey: Swift.Sendable {
        /// The unique ID of the service account token.
        /// This member is required.
        public var id: Swift.String?
        /// The key for the service account token. Used when making calls to the Grafana HTTP APIs to authenticate and authorize the requests.
        /// This member is required.
        public var key: Swift.String?
        /// The name of the service account token.
        /// This member is required.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            key: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.key = key
            self.name = name
        }
    }
}

extension GrafanaClientTypes.ServiceAccountTokenSummaryWithKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceAccountTokenSummaryWithKey(id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), key: \"CONTENT_REDACTED\")"}
}

public struct CreateWorkspaceServiceAccountTokenOutput: Swift.Sendable {
    /// The ID of the service account where the token was created.
    /// This member is required.
    public var serviceAccountId: Swift.String?
    /// Information about the created token, including the key. Be sure to store the key securely.
    /// This member is required.
    public var serviceAccountToken: GrafanaClientTypes.ServiceAccountTokenSummaryWithKey?
    /// The ID of the workspace where the token was created.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        serviceAccountId: Swift.String? = nil,
        serviceAccountToken: GrafanaClientTypes.ServiceAccountTokenSummaryWithKey? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.serviceAccountId = serviceAccountId
        self.serviceAccountToken = serviceAccountToken
        self.workspaceId = workspaceId
    }
}

public struct DeleteWorkspaceServiceAccountTokenInput: Swift.Sendable {
    /// The ID of the service account from which to delete the token.
    /// This member is required.
    public var serviceAccountId: Swift.String?
    /// The ID of the token to delete.
    /// This member is required.
    public var tokenId: Swift.String?
    /// The ID of the workspace from which to delete the token.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        serviceAccountId: Swift.String? = nil,
        tokenId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.serviceAccountId = serviceAccountId
        self.tokenId = tokenId
        self.workspaceId = workspaceId
    }
}

public struct DeleteWorkspaceServiceAccountTokenOutput: Swift.Sendable {
    /// The ID of the service account where the token was deleted.
    /// This member is required.
    public var serviceAccountId: Swift.String?
    /// The ID of the token that was deleted.
    /// This member is required.
    public var tokenId: Swift.String?
    /// The ID of the workspace where the token was deleted.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        serviceAccountId: Swift.String? = nil,
        tokenId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.serviceAccountId = serviceAccountId
        self.tokenId = tokenId
        self.workspaceId = workspaceId
    }
}

public struct ListWorkspaceServiceAccountTokensInput: Swift.Sendable {
    /// The maximum number of tokens to include in the results.
    public var maxResults: Swift.Int?
    /// The token for the next set of service accounts to return. (You receive this token from a previous ListWorkspaceServiceAccountTokens operation.)
    public var nextToken: Swift.String?
    /// The ID of the service account for which to return tokens.
    /// This member is required.
    public var serviceAccountId: Swift.String?
    /// The ID of the workspace for which to return tokens.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceAccountId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceAccountId = serviceAccountId
        self.workspaceId = workspaceId
    }
}

extension GrafanaClientTypes {

    /// A structure that contains the information about a service account token.
    public struct ServiceAccountTokenSummary: Swift.Sendable {
        /// When the service account token was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// When the service account token will expire.
        /// This member is required.
        public var expiresAt: Foundation.Date?
        /// The unique ID of the service account token.
        /// This member is required.
        public var id: Swift.String?
        /// The last time the token was used to authorize a Grafana HTTP API.
        public var lastUsedAt: Foundation.Date?
        /// The name of the service account token.
        /// This member is required.
        public var name: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            expiresAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            lastUsedAt: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.id = id
            self.lastUsedAt = lastUsedAt
            self.name = name
        }
    }
}

public struct ListWorkspaceServiceAccountTokensOutput: Swift.Sendable {
    /// The token to use when requesting the next set of service accounts.
    public var nextToken: Swift.String?
    /// The ID of the service account where the tokens reside.
    /// This member is required.
    public var serviceAccountId: Swift.String?
    /// An array of structures containing information about the tokens.
    /// This member is required.
    public var serviceAccountTokens: [GrafanaClientTypes.ServiceAccountTokenSummary]?
    /// The ID of the workspace where the tokens reside.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        serviceAccountId: Swift.String? = nil,
        serviceAccountTokens: [GrafanaClientTypes.ServiceAccountTokenSummary]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceAccountId = serviceAccountId
        self.serviceAccountTokens = serviceAccountTokens
        self.workspaceId = workspaceId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource the tag is associated with.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys and values to associate with the resource. You can associate tag keys only, tags (key and values) only or a combination of tag keys and tags.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource the tag association is removed from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key values of the tag to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct CreateWorkspaceInput: Swift.Sendable {
    /// Specifies whether the workspace can access Amazon Web Services resources in this Amazon Web Services account only, or whether it can also access Amazon Web Services resources in other accounts in the same organization. If you specify ORGANIZATION, you must specify which organizational units the workspace can access in the workspaceOrganizationalUnits parameter.
    /// This member is required.
    public var accountAccessType: GrafanaClientTypes.AccountAccessType?
    /// Specifies whether this workspace uses SAML 2.0, IAM Identity Center, or both to authenticate users for using the Grafana console within a workspace. For more information, see [User authentication in Amazon Managed Grafana](https://docs.aws.amazon.com/grafana/latest/userguide/authentication-in-AMG.html).
    /// This member is required.
    public var authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]?
    /// A unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The configuration string for the workspace that you create. For more information about the format and configuration options available, see [Working in your Grafana workspace](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-configure-workspace.html).
    public var configuration: Swift.String?
    /// Specifies the version of Grafana to support in the new workspace. If not specified, defaults to the latest version (for example, 10.4). To get a list of supported versions, use the ListVersions operation.
    public var grafanaVersion: Swift.String?
    /// Configuration for network access to your workspace. When this is configured, only listed IP addresses and VPC endpoints will be able to access your workspace. Standard Grafana authentication and authorization will still be required. If this is not configured, or is removed, then all IP addresses and VPC endpoints will be allowed. Standard Grafana authentication and authorization will still be required.
    public var networkAccessControl: GrafanaClientTypes.NetworkAccessConfiguration?
    /// The name of an IAM role that already exists to use with Organizations to access Amazon Web Services data sources and notification channels in other accounts in an organization.
    public var organizationRoleName: Swift.String?
    /// When creating a workspace through the Amazon Web Services API, CLI or Amazon Web Services CloudFormation, you must manage IAM roles and provision the permissions that the workspace needs to use Amazon Web Services data sources and notification channels. You must also specify a workspaceRoleArn for a role that you will manage for the workspace to use when accessing those datasources and notification channels. The ability for Amazon Managed Grafana to create and update IAM roles on behalf of the user is supported only in the Amazon Managed Grafana console, where this value may be set to SERVICE_MANAGED. Use only the CUSTOMER_MANAGED permission type when creating a workspace with the API, CLI or Amazon Web Services CloudFormation. For more information, see [Amazon Managed Grafana permissions and policies for Amazon Web Services data sources and notification channels](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-manage-permissions.html).
    /// This member is required.
    public var permissionType: GrafanaClientTypes.PermissionType?
    /// The name of the CloudFormation stack set to use to generate IAM roles to be used for this workspace.
    public var stackSetName: Swift.String?
    /// The list of tags associated with the workspace.
    public var tags: [Swift.String: Swift.String]?
    /// The configuration settings for an Amazon VPC that contains data sources for your Grafana workspace to connect to. Connecting to a private VPC is not yet available in the Asia Pacific (Seoul) Region (ap-northeast-2).
    public var vpcConfiguration: GrafanaClientTypes.VpcConfiguration?
    /// This parameter is for internal use only, and should not be used.
    public var workspaceDataSources: [GrafanaClientTypes.DataSourceType]?
    /// A description for the workspace. This is used only to help you identify this workspace. Pattern: ^[\\p{L}\\p{Z}\\p{N}\\p{P}]{0,2048}$
    public var workspaceDescription: Swift.String?
    /// The name for the workspace. It does not have to be unique.
    public var workspaceName: Swift.String?
    /// Specify the Amazon Web Services notification channels that you plan to use in this workspace. Specifying these data sources here enables Amazon Managed Grafana to create IAM roles and permissions that allow Amazon Managed Grafana to use these channels.
    public var workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
    /// Specifies the organizational units that this workspace is allowed to use data sources from, if this workspace is in an account that is part of an organization.
    public var workspaceOrganizationalUnits: [Swift.String]?
    /// Specified the IAM role that grants permissions to the Amazon Web Services resources that the workspace will view data from, including both data sources and notification channels. You are responsible for managing the permissions for this role as new data sources or notification channels are added.
    public var workspaceRoleArn: Swift.String?

    public init(
        accountAccessType: GrafanaClientTypes.AccountAccessType? = nil,
        authenticationProviders: [GrafanaClientTypes.AuthenticationProviderTypes]? = nil,
        clientToken: Swift.String? = nil,
        configuration: Swift.String? = nil,
        grafanaVersion: Swift.String? = nil,
        networkAccessControl: GrafanaClientTypes.NetworkAccessConfiguration? = nil,
        organizationRoleName: Swift.String? = nil,
        permissionType: GrafanaClientTypes.PermissionType? = nil,
        stackSetName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcConfiguration: GrafanaClientTypes.VpcConfiguration? = nil,
        workspaceDataSources: [GrafanaClientTypes.DataSourceType]? = nil,
        workspaceDescription: Swift.String? = nil,
        workspaceName: Swift.String? = nil,
        workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]? = nil,
        workspaceOrganizationalUnits: [Swift.String]? = nil,
        workspaceRoleArn: Swift.String? = nil
    )
    {
        self.accountAccessType = accountAccessType
        self.authenticationProviders = authenticationProviders
        self.clientToken = clientToken
        self.configuration = configuration
        self.grafanaVersion = grafanaVersion
        self.networkAccessControl = networkAccessControl
        self.organizationRoleName = organizationRoleName
        self.permissionType = permissionType
        self.stackSetName = stackSetName
        self.tags = tags
        self.vpcConfiguration = vpcConfiguration
        self.workspaceDataSources = workspaceDataSources
        self.workspaceDescription = workspaceDescription
        self.workspaceName = workspaceName
        self.workspaceNotificationDestinations = workspaceNotificationDestinations
        self.workspaceOrganizationalUnits = workspaceOrganizationalUnits
        self.workspaceRoleArn = workspaceRoleArn
    }
}

extension CreateWorkspaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkspaceInput(accountAccessType: \(Swift.String(describing: accountAccessType)), authenticationProviders: \(Swift.String(describing: authenticationProviders)), clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), grafanaVersion: \(Swift.String(describing: grafanaVersion)), networkAccessControl: \(Swift.String(describing: networkAccessControl)), permissionType: \(Swift.String(describing: permissionType)), stackSetName: \(Swift.String(describing: stackSetName)), tags: \(Swift.String(describing: tags)), vpcConfiguration: \(Swift.String(describing: vpcConfiguration)), workspaceDataSources: \(Swift.String(describing: workspaceDataSources)), workspaceNotificationDestinations: \(Swift.String(describing: workspaceNotificationDestinations)), organizationRoleName: \"CONTENT_REDACTED\", workspaceDescription: \"CONTENT_REDACTED\", workspaceName: \"CONTENT_REDACTED\", workspaceOrganizationalUnits: \"CONTENT_REDACTED\", workspaceRoleArn: \"CONTENT_REDACTED\")"}
}

public struct CreateWorkspaceOutput: Swift.Sendable {
    /// A structure containing data about the workspace that was created.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init(
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

public struct DeleteWorkspaceInput: Swift.Sendable {
    /// The ID of the workspace to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

public struct DeleteWorkspaceOutput: Swift.Sendable {
    /// A structure containing information about the workspace that was deleted.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init(
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

public struct DescribeWorkspaceInput: Swift.Sendable {
    /// The ID of the workspace to display information about.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

public struct DescribeWorkspaceOutput: Swift.Sendable {
    /// A structure containing information about the workspace.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init(
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

public struct ListWorkspacesInput: Swift.Sendable {
    /// The maximum number of workspaces to include in the results.
    public var maxResults: Swift.Int?
    /// The token for the next set of workspaces to return. (You receive this token from a previous ListWorkspaces operation.)
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GrafanaClientTypes {

    /// A structure that contains some information about one workspace in the account.
    public struct WorkspaceSummary: Swift.Sendable {
        /// A structure containing information about the authentication methods used in the workspace.
        /// This member is required.
        public var authentication: GrafanaClientTypes.AuthenticationSummary?
        /// The date that the workspace was created.
        /// This member is required.
        public var created: Foundation.Date?
        /// The customer-entered description of the workspace.
        public var description: Swift.String?
        /// The URL endpoint to use to access the Grafana console in the workspace.
        /// This member is required.
        public var endpoint: Swift.String?
        /// The token that ties this workspace to a Grafana Labs account. For more information, see [Link your account with Grafana Labs](https://docs.aws.amazon.com/grafana/latest/userguide/upgrade-to-Grafana-Enterprise.html#AMG-workspace-register-enterprise).
        public var grafanaToken: Swift.String?
        /// The Grafana version that the workspace is running.
        /// This member is required.
        public var grafanaVersion: Swift.String?
        /// The unique ID of the workspace.
        /// This member is required.
        public var id: Swift.String?
        /// Specifies whether this workspace has a full Grafana Enterprise license. Amazon Managed Grafana workspaces no longer support Grafana Enterprise free trials.
        public var licenseType: GrafanaClientTypes.LicenseType?
        /// The most recent date that the workspace was modified.
        /// This member is required.
        public var modified: Foundation.Date?
        /// The name of the workspace.
        public var name: Swift.String?
        /// The Amazon Web Services notification channels that Amazon Managed Grafana can automatically create IAM roles and permissions for, which allows Amazon Managed Grafana to use these channels.
        public var notificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
        /// The current status of the workspace.
        /// This member is required.
        public var status: GrafanaClientTypes.WorkspaceStatus?
        /// The list of tags associated with the workspace.
        public var tags: [Swift.String: Swift.String]?

        public init(
            authentication: GrafanaClientTypes.AuthenticationSummary? = nil,
            created: Foundation.Date? = nil,
            description: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            grafanaToken: Swift.String? = nil,
            grafanaVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            licenseType: GrafanaClientTypes.LicenseType? = nil,
            modified: Foundation.Date? = nil,
            name: Swift.String? = nil,
            notificationDestinations: [GrafanaClientTypes.NotificationDestinationType]? = nil,
            status: GrafanaClientTypes.WorkspaceStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.authentication = authentication
            self.created = created
            self.description = description
            self.endpoint = endpoint
            self.grafanaToken = grafanaToken
            self.grafanaVersion = grafanaVersion
            self.id = id
            self.licenseType = licenseType
            self.modified = modified
            self.name = name
            self.notificationDestinations = notificationDestinations
            self.status = status
            self.tags = tags
        }
    }
}

extension GrafanaClientTypes.WorkspaceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorkspaceSummary(authentication: \(Swift.String(describing: authentication)), created: \(Swift.String(describing: created)), endpoint: \(Swift.String(describing: endpoint)), grafanaToken: \(Swift.String(describing: grafanaToken)), grafanaVersion: \(Swift.String(describing: grafanaVersion)), id: \(Swift.String(describing: id)), licenseType: \(Swift.String(describing: licenseType)), modified: \(Swift.String(describing: modified)), notificationDestinations: \(Swift.String(describing: notificationDestinations)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListWorkspacesOutput: Swift.Sendable {
    /// The token to use when requesting the next set of workspaces.
    public var nextToken: Swift.String?
    /// An array of structures that contain some information about the workspaces in the account.
    /// This member is required.
    public var workspaces: [GrafanaClientTypes.WorkspaceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workspaces: [GrafanaClientTypes.WorkspaceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaces = workspaces
    }
}

public struct UpdateWorkspaceInput: Swift.Sendable {
    /// Specifies whether the workspace can access Amazon Web Services resources in this Amazon Web Services account only, or whether it can also access Amazon Web Services resources in other accounts in the same organization. If you specify ORGANIZATION, you must specify which organizational units the workspace can access in the workspaceOrganizationalUnits parameter.
    public var accountAccessType: GrafanaClientTypes.AccountAccessType?
    /// The configuration settings for network access to your workspace. When this is configured, only listed IP addresses and VPC endpoints will be able to access your workspace. Standard Grafana authentication and authorization will still be required. If this is not configured, or is removed, then all IP addresses and VPC endpoints will be allowed. Standard Grafana authentication and authorization will still be required.
    public var networkAccessControl: GrafanaClientTypes.NetworkAccessConfiguration?
    /// The name of an IAM role that already exists to use to access resources through Organizations. This can only be used with a workspace that has the permissionType set to CUSTOMER_MANAGED.
    public var organizationRoleName: Swift.String?
    /// Use this parameter if you want to change a workspace from SERVICE_MANAGED to CUSTOMER_MANAGED. This allows you to manage the permissions that the workspace uses to access datasources and notification channels. If the workspace is in a member Amazon Web Services account of an organization, and that account is not a delegated administrator account, and you want the workspace to access data sources in other Amazon Web Services accounts in the organization, you must choose CUSTOMER_MANAGED. If you specify this as CUSTOMER_MANAGED, you must also specify a workspaceRoleArn that the workspace will use for accessing Amazon Web Services resources. For more information on the role and permissions needed, see [Amazon Managed Grafana permissions and policies for Amazon Web Services data sources and notification channels](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-manage-permissions.html) Do not use this to convert a CUSTOMER_MANAGED workspace to SERVICE_MANAGED. Do not include this parameter if you want to leave the workspace as SERVICE_MANAGED. You can convert a CUSTOMER_MANAGED workspace to SERVICE_MANAGED using the Amazon Managed Grafana console. For more information, see [Managing permissions for data sources and notification channels](https://docs.aws.amazon.com/grafana/latest/userguide/AMG-datasource-and-notification.html).
    public var permissionType: GrafanaClientTypes.PermissionType?
    /// Whether to remove the network access configuration from the workspace. Setting this to true and providing a networkAccessControl to set will return an error. If you remove this configuration by setting this to true, then all IP addresses and VPC endpoints will be allowed. Standard Grafana authentication and authorization will still be required.
    public var removeNetworkAccessConfiguration: Swift.Bool?
    /// Whether to remove the VPC configuration from the workspace. Setting this to true and providing a vpcConfiguration to set will return an error.
    public var removeVpcConfiguration: Swift.Bool?
    /// The name of the CloudFormation stack set to use to generate IAM roles to be used for this workspace.
    public var stackSetName: Swift.String?
    /// The configuration settings for an Amazon VPC that contains data sources for your Grafana workspace to connect to.
    public var vpcConfiguration: GrafanaClientTypes.VpcConfiguration?
    /// This parameter is for internal use only, and should not be used.
    public var workspaceDataSources: [GrafanaClientTypes.DataSourceType]?
    /// A description for the workspace. This is used only to help you identify this workspace.
    public var workspaceDescription: Swift.String?
    /// The ID of the workspace to update.
    /// This member is required.
    public var workspaceId: Swift.String?
    /// A new name for the workspace to update.
    public var workspaceName: Swift.String?
    /// Specify the Amazon Web Services notification channels that you plan to use in this workspace. Specifying these data sources here enables Amazon Managed Grafana to create IAM roles and permissions that allow Amazon Managed Grafana to use these channels.
    public var workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]?
    /// Specifies the organizational units that this workspace is allowed to use data sources from, if this workspace is in an account that is part of an organization.
    public var workspaceOrganizationalUnits: [Swift.String]?
    /// Specifies an IAM role that grants permissions to Amazon Web Services resources that the workspace accesses, such as data sources and notification channels. If this workspace has permissionTypeCUSTOMER_MANAGED, then this role is required.
    public var workspaceRoleArn: Swift.String?

    public init(
        accountAccessType: GrafanaClientTypes.AccountAccessType? = nil,
        networkAccessControl: GrafanaClientTypes.NetworkAccessConfiguration? = nil,
        organizationRoleName: Swift.String? = nil,
        permissionType: GrafanaClientTypes.PermissionType? = nil,
        removeNetworkAccessConfiguration: Swift.Bool? = nil,
        removeVpcConfiguration: Swift.Bool? = nil,
        stackSetName: Swift.String? = nil,
        vpcConfiguration: GrafanaClientTypes.VpcConfiguration? = nil,
        workspaceDataSources: [GrafanaClientTypes.DataSourceType]? = nil,
        workspaceDescription: Swift.String? = nil,
        workspaceId: Swift.String? = nil,
        workspaceName: Swift.String? = nil,
        workspaceNotificationDestinations: [GrafanaClientTypes.NotificationDestinationType]? = nil,
        workspaceOrganizationalUnits: [Swift.String]? = nil,
        workspaceRoleArn: Swift.String? = nil
    )
    {
        self.accountAccessType = accountAccessType
        self.networkAccessControl = networkAccessControl
        self.organizationRoleName = organizationRoleName
        self.permissionType = permissionType
        self.removeNetworkAccessConfiguration = removeNetworkAccessConfiguration
        self.removeVpcConfiguration = removeVpcConfiguration
        self.stackSetName = stackSetName
        self.vpcConfiguration = vpcConfiguration
        self.workspaceDataSources = workspaceDataSources
        self.workspaceDescription = workspaceDescription
        self.workspaceId = workspaceId
        self.workspaceName = workspaceName
        self.workspaceNotificationDestinations = workspaceNotificationDestinations
        self.workspaceOrganizationalUnits = workspaceOrganizationalUnits
        self.workspaceRoleArn = workspaceRoleArn
    }
}

extension UpdateWorkspaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWorkspaceInput(accountAccessType: \(Swift.String(describing: accountAccessType)), networkAccessControl: \(Swift.String(describing: networkAccessControl)), permissionType: \(Swift.String(describing: permissionType)), removeNetworkAccessConfiguration: \(Swift.String(describing: removeNetworkAccessConfiguration)), removeVpcConfiguration: \(Swift.String(describing: removeVpcConfiguration)), stackSetName: \(Swift.String(describing: stackSetName)), vpcConfiguration: \(Swift.String(describing: vpcConfiguration)), workspaceDataSources: \(Swift.String(describing: workspaceDataSources)), workspaceId: \(Swift.String(describing: workspaceId)), workspaceNotificationDestinations: \(Swift.String(describing: workspaceNotificationDestinations)), organizationRoleName: \"CONTENT_REDACTED\", workspaceDescription: \"CONTENT_REDACTED\", workspaceName: \"CONTENT_REDACTED\", workspaceOrganizationalUnits: \"CONTENT_REDACTED\", workspaceRoleArn: \"CONTENT_REDACTED\")"}
}

public struct UpdateWorkspaceOutput: Swift.Sendable {
    /// A structure containing data about the workspace that was created.
    /// This member is required.
    public var workspace: GrafanaClientTypes.WorkspaceDescription?

    public init(
        workspace: GrafanaClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

extension AssociateLicenseInput {

    static func urlPathProvider(_ value: AssociateLicenseInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let licenseType = value.licenseType else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/licenses/\(licenseType.rawValue.urlPercentEncoding())"
    }
}

extension AssociateLicenseInput {

    static func headerProvider(_ value: AssociateLicenseInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let grafanaToken = value.grafanaToken {
            items.add(SmithyHTTPAPI.Header(name: "Grafana-Token", value: Swift.String(grafanaToken)))
        }
        return items
    }
}

extension CreateWorkspaceInput {

    static func urlPathProvider(_ value: CreateWorkspaceInput) -> Swift.String? {
        return "/workspaces"
    }
}

extension CreateWorkspaceApiKeyInput {

    static func urlPathProvider(_ value: CreateWorkspaceApiKeyInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/apikeys"
    }
}

extension CreateWorkspaceServiceAccountInput {

    static func urlPathProvider(_ value: CreateWorkspaceServiceAccountInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/serviceaccounts"
    }
}

extension CreateWorkspaceServiceAccountTokenInput {

    static func urlPathProvider(_ value: CreateWorkspaceServiceAccountTokenInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let serviceAccountId = value.serviceAccountId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/serviceaccounts/\(serviceAccountId.urlPercentEncoding())/tokens"
    }
}

extension DeleteWorkspaceInput {

    static func urlPathProvider(_ value: DeleteWorkspaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

extension DeleteWorkspaceApiKeyInput {

    static func urlPathProvider(_ value: DeleteWorkspaceApiKeyInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let keyName = value.keyName else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/apikeys/\(keyName.urlPercentEncoding())"
    }
}

extension DeleteWorkspaceServiceAccountInput {

    static func urlPathProvider(_ value: DeleteWorkspaceServiceAccountInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let serviceAccountId = value.serviceAccountId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/serviceaccounts/\(serviceAccountId.urlPercentEncoding())"
    }
}

extension DeleteWorkspaceServiceAccountTokenInput {

    static func urlPathProvider(_ value: DeleteWorkspaceServiceAccountTokenInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let serviceAccountId = value.serviceAccountId else {
            return nil
        }
        guard let tokenId = value.tokenId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/serviceaccounts/\(serviceAccountId.urlPercentEncoding())/tokens/\(tokenId.urlPercentEncoding())"
    }
}

extension DescribeWorkspaceInput {

    static func urlPathProvider(_ value: DescribeWorkspaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

extension DescribeWorkspaceAuthenticationInput {

    static func urlPathProvider(_ value: DescribeWorkspaceAuthenticationInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/authentication"
    }
}

extension DescribeWorkspaceConfigurationInput {

    static func urlPathProvider(_ value: DescribeWorkspaceConfigurationInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/configuration"
    }
}

extension DisassociateLicenseInput {

    static func urlPathProvider(_ value: DisassociateLicenseInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let licenseType = value.licenseType else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/licenses/\(licenseType.rawValue.urlPercentEncoding())"
    }
}

extension ListPermissionsInput {

    static func urlPathProvider(_ value: ListPermissionsInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/permissions"
    }
}

extension ListPermissionsInput {

    static func queryItemProvider(_ value: ListPermissionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let groupId = value.groupId {
            let groupIdQueryItem = Smithy.URIQueryItem(name: "groupId".urlPercentEncoding(), value: Swift.String(groupId).urlPercentEncoding())
            items.append(groupIdQueryItem)
        }
        if let userType = value.userType {
            let userTypeQueryItem = Smithy.URIQueryItem(name: "userType".urlPercentEncoding(), value: Swift.String(userType.rawValue).urlPercentEncoding())
            items.append(userTypeQueryItem)
        }
        if let userId = value.userId {
            let userIdQueryItem = Smithy.URIQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListVersionsInput {

    static func urlPathProvider(_ value: ListVersionsInput) -> Swift.String? {
        return "/versions"
    }
}

extension ListVersionsInput {

    static func queryItemProvider(_ value: ListVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let workspaceId = value.workspaceId {
            let workspaceIdQueryItem = Smithy.URIQueryItem(name: "workspace-id".urlPercentEncoding(), value: Swift.String(workspaceId).urlPercentEncoding())
            items.append(workspaceIdQueryItem)
        }
        return items
    }
}

extension ListWorkspacesInput {

    static func urlPathProvider(_ value: ListWorkspacesInput) -> Swift.String? {
        return "/workspaces"
    }
}

extension ListWorkspacesInput {

    static func queryItemProvider(_ value: ListWorkspacesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListWorkspaceServiceAccountsInput {

    static func urlPathProvider(_ value: ListWorkspaceServiceAccountsInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/serviceaccounts"
    }
}

extension ListWorkspaceServiceAccountsInput {

    static func queryItemProvider(_ value: ListWorkspaceServiceAccountsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListWorkspaceServiceAccountTokensInput {

    static func urlPathProvider(_ value: ListWorkspaceServiceAccountTokensInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let serviceAccountId = value.serviceAccountId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/serviceaccounts/\(serviceAccountId.urlPercentEncoding())/tokens"
    }
}

extension ListWorkspaceServiceAccountTokensInput {

    static func queryItemProvider(_ value: ListWorkspaceServiceAccountTokensInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdatePermissionsInput {

    static func urlPathProvider(_ value: UpdatePermissionsInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/permissions"
    }
}

extension UpdateWorkspaceInput {

    static func urlPathProvider(_ value: UpdateWorkspaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

extension UpdateWorkspaceAuthenticationInput {

    static func urlPathProvider(_ value: UpdateWorkspaceAuthenticationInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/authentication"
    }
}

extension UpdateWorkspaceConfigurationInput {

    static func urlPathProvider(_ value: UpdateWorkspaceConfigurationInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/configuration"
    }
}

extension CreateWorkspaceInput {

    static func write(value: CreateWorkspaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountAccessType"].write(value.accountAccessType)
        try writer["authenticationProviders"].writeList(value.authenticationProviders, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GrafanaClientTypes.AuthenticationProviderTypes>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration)
        try writer["grafanaVersion"].write(value.grafanaVersion)
        try writer["networkAccessControl"].write(value.networkAccessControl, with: GrafanaClientTypes.NetworkAccessConfiguration.write(value:to:))
        try writer["organizationRoleName"].write(value.organizationRoleName)
        try writer["permissionType"].write(value.permissionType)
        try writer["stackSetName"].write(value.stackSetName)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["vpcConfiguration"].write(value.vpcConfiguration, with: GrafanaClientTypes.VpcConfiguration.write(value:to:))
        try writer["workspaceDataSources"].writeList(value.workspaceDataSources, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GrafanaClientTypes.DataSourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workspaceDescription"].write(value.workspaceDescription)
        try writer["workspaceName"].write(value.workspaceName)
        try writer["workspaceNotificationDestinations"].writeList(value.workspaceNotificationDestinations, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GrafanaClientTypes.NotificationDestinationType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workspaceOrganizationalUnits"].writeList(value.workspaceOrganizationalUnits, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workspaceRoleArn"].write(value.workspaceRoleArn)
    }
}

extension CreateWorkspaceApiKeyInput {

    static func write(value: CreateWorkspaceApiKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keyName"].write(value.keyName)
        try writer["keyRole"].write(value.keyRole)
        try writer["secondsToLive"].write(value.secondsToLive)
    }
}

extension CreateWorkspaceServiceAccountInput {

    static func write(value: CreateWorkspaceServiceAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["grafanaRole"].write(value.grafanaRole)
        try writer["name"].write(value.name)
    }
}

extension CreateWorkspaceServiceAccountTokenInput {

    static func write(value: CreateWorkspaceServiceAccountTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["secondsToLive"].write(value.secondsToLive)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdatePermissionsInput {

    static func write(value: UpdatePermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["updateInstructionBatch"].writeList(value.updateInstructionBatch, memberWritingClosure: GrafanaClientTypes.UpdateInstruction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateWorkspaceInput {

    static func write(value: UpdateWorkspaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountAccessType"].write(value.accountAccessType)
        try writer["networkAccessControl"].write(value.networkAccessControl, with: GrafanaClientTypes.NetworkAccessConfiguration.write(value:to:))
        try writer["organizationRoleName"].write(value.organizationRoleName)
        try writer["permissionType"].write(value.permissionType)
        try writer["removeNetworkAccessConfiguration"].write(value.removeNetworkAccessConfiguration)
        try writer["removeVpcConfiguration"].write(value.removeVpcConfiguration)
        try writer["stackSetName"].write(value.stackSetName)
        try writer["vpcConfiguration"].write(value.vpcConfiguration, with: GrafanaClientTypes.VpcConfiguration.write(value:to:))
        try writer["workspaceDataSources"].writeList(value.workspaceDataSources, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GrafanaClientTypes.DataSourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workspaceDescription"].write(value.workspaceDescription)
        try writer["workspaceName"].write(value.workspaceName)
        try writer["workspaceNotificationDestinations"].writeList(value.workspaceNotificationDestinations, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GrafanaClientTypes.NotificationDestinationType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workspaceOrganizationalUnits"].writeList(value.workspaceOrganizationalUnits, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workspaceRoleArn"].write(value.workspaceRoleArn)
    }
}

extension UpdateWorkspaceAuthenticationInput {

    static func write(value: UpdateWorkspaceAuthenticationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authenticationProviders"].writeList(value.authenticationProviders, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GrafanaClientTypes.AuthenticationProviderTypes>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["samlConfiguration"].write(value.samlConfiguration, with: GrafanaClientTypes.SamlConfiguration.write(value:to:))
    }
}

extension UpdateWorkspaceConfigurationInput {

    static func write(value: UpdateWorkspaceConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration)
        try writer["grafanaVersion"].write(value.grafanaVersion)
    }
}

extension AssociateLicenseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateLicenseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateLicenseOutput()
        value.workspace = try reader["workspace"].readIfPresent(with: GrafanaClientTypes.WorkspaceDescription.read(from:))
        return value
    }
}

extension CreateWorkspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkspaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkspaceOutput()
        value.workspace = try reader["workspace"].readIfPresent(with: GrafanaClientTypes.WorkspaceDescription.read(from:))
        return value
    }
}

extension CreateWorkspaceApiKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkspaceApiKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkspaceApiKeyOutput()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.keyName = try reader["keyName"].readIfPresent() ?? ""
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateWorkspaceServiceAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkspaceServiceAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkspaceServiceAccountOutput()
        value.grafanaRole = try reader["grafanaRole"].readIfPresent() ?? .sdkUnknown("")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateWorkspaceServiceAccountTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkspaceServiceAccountTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkspaceServiceAccountTokenOutput()
        value.serviceAccountId = try reader["serviceAccountId"].readIfPresent() ?? ""
        value.serviceAccountToken = try reader["serviceAccountToken"].readIfPresent(with: GrafanaClientTypes.ServiceAccountTokenSummaryWithKey.read(from:))
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteWorkspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkspaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteWorkspaceOutput()
        value.workspace = try reader["workspace"].readIfPresent(with: GrafanaClientTypes.WorkspaceDescription.read(from:))
        return value
    }
}

extension DeleteWorkspaceApiKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkspaceApiKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteWorkspaceApiKeyOutput()
        value.keyName = try reader["keyName"].readIfPresent() ?? ""
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteWorkspaceServiceAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkspaceServiceAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteWorkspaceServiceAccountOutput()
        value.serviceAccountId = try reader["serviceAccountId"].readIfPresent() ?? ""
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteWorkspaceServiceAccountTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkspaceServiceAccountTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteWorkspaceServiceAccountTokenOutput()
        value.serviceAccountId = try reader["serviceAccountId"].readIfPresent() ?? ""
        value.tokenId = try reader["tokenId"].readIfPresent() ?? ""
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension DescribeWorkspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkspaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkspaceOutput()
        value.workspace = try reader["workspace"].readIfPresent(with: GrafanaClientTypes.WorkspaceDescription.read(from:))
        return value
    }
}

extension DescribeWorkspaceAuthenticationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkspaceAuthenticationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkspaceAuthenticationOutput()
        value.authentication = try reader["authentication"].readIfPresent(with: GrafanaClientTypes.AuthenticationDescription.read(from:))
        return value
    }
}

extension DescribeWorkspaceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkspaceConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkspaceConfigurationOutput()
        value.configuration = try reader["configuration"].readIfPresent() ?? ""
        value.grafanaVersion = try reader["grafanaVersion"].readIfPresent()
        return value
    }
}

extension DisassociateLicenseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateLicenseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateLicenseOutput()
        value.workspace = try reader["workspace"].readIfPresent(with: GrafanaClientTypes.WorkspaceDescription.read(from:))
        return value
    }
}

extension ListPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPermissionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.permissions = try reader["permissions"].readListIfPresent(memberReadingClosure: GrafanaClientTypes.PermissionEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVersionsOutput()
        value.grafanaVersions = try reader["grafanaVersions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListWorkspacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkspacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkspacesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workspaces = try reader["workspaces"].readListIfPresent(memberReadingClosure: GrafanaClientTypes.WorkspaceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListWorkspaceServiceAccountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkspaceServiceAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkspaceServiceAccountsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.serviceAccounts = try reader["serviceAccounts"].readListIfPresent(memberReadingClosure: GrafanaClientTypes.ServiceAccountSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension ListWorkspaceServiceAccountTokensOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkspaceServiceAccountTokensOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkspaceServiceAccountTokensOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.serviceAccountId = try reader["serviceAccountId"].readIfPresent() ?? ""
        value.serviceAccountTokens = try reader["serviceAccountTokens"].readListIfPresent(memberReadingClosure: GrafanaClientTypes.ServiceAccountTokenSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdatePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePermissionsOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: GrafanaClientTypes.UpdateError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension UpdateWorkspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkspaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorkspaceOutput()
        value.workspace = try reader["workspace"].readIfPresent(with: GrafanaClientTypes.WorkspaceDescription.read(from:))
        return value
    }
}

extension UpdateWorkspaceAuthenticationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkspaceAuthenticationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorkspaceAuthenticationOutput()
        value.authentication = try reader["authentication"].readIfPresent(with: GrafanaClientTypes.AuthenticationDescription.read(from:))
        return value
    }
}

extension UpdateWorkspaceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkspaceConfigurationOutput {
        return UpdateWorkspaceConfigurationOutput()
    }
}

enum AssociateLicenseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkspaceApiKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkspaceServiceAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkspaceServiceAccountTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkspaceApiKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkspaceServiceAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkspaceServiceAccountTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkspaceAuthenticationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkspaceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateLicenseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkspacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkspaceServiceAccountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkspaceServiceAccountTokensOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkspaceAuthenticationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkspaceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: GrafanaClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GrafanaClientTypes.WorkspaceDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.WorkspaceDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.WorkspaceDescription()
        value.accountAccessType = try reader["accountAccessType"].readIfPresent()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.dataSources = try reader["dataSources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GrafanaClientTypes.DataSourceType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.description = try reader["description"].readIfPresent()
        value.endpoint = try reader["endpoint"].readIfPresent() ?? ""
        value.grafanaVersion = try reader["grafanaVersion"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.modified = try reader["modified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent()
        value.organizationRoleName = try reader["organizationRoleName"].readIfPresent()
        value.notificationDestinations = try reader["notificationDestinations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GrafanaClientTypes.NotificationDestinationType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.organizationalUnits = try reader["organizationalUnits"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.permissionType = try reader["permissionType"].readIfPresent()
        value.stackSetName = try reader["stackSetName"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.workspaceRoleArn = try reader["workspaceRoleArn"].readIfPresent()
        value.licenseType = try reader["licenseType"].readIfPresent()
        value.freeTrialConsumed = try reader["freeTrialConsumed"].readIfPresent()
        value.licenseExpiration = try reader["licenseExpiration"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.freeTrialExpiration = try reader["freeTrialExpiration"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.authentication = try reader["authentication"].readIfPresent(with: GrafanaClientTypes.AuthenticationSummary.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcConfiguration = try reader["vpcConfiguration"].readIfPresent(with: GrafanaClientTypes.VpcConfiguration.read(from:))
        value.networkAccessControl = try reader["networkAccessControl"].readIfPresent(with: GrafanaClientTypes.NetworkAccessConfiguration.read(from:))
        value.grafanaToken = try reader["grafanaToken"].readIfPresent()
        return value
    }
}

extension GrafanaClientTypes.NetworkAccessConfiguration {

    static func write(value: GrafanaClientTypes.NetworkAccessConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["prefixListIds"].writeList(value.prefixListIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vpceIds"].writeList(value.vpceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.NetworkAccessConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.NetworkAccessConfiguration()
        value.prefixListIds = try reader["prefixListIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.vpceIds = try reader["vpceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GrafanaClientTypes.VpcConfiguration {

    static func write(value: GrafanaClientTypes.VpcConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.VpcConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.VpcConfiguration()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GrafanaClientTypes.AuthenticationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.AuthenticationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.AuthenticationSummary()
        value.providers = try reader["providers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GrafanaClientTypes.AuthenticationProviderTypes>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.samlConfigurationStatus = try reader["samlConfigurationStatus"].readIfPresent()
        return value
    }
}

extension GrafanaClientTypes.ServiceAccountTokenSummaryWithKey {

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.ServiceAccountTokenSummaryWithKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.ServiceAccountTokenSummaryWithKey()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.key = try reader["key"].readIfPresent() ?? ""
        return value
    }
}

extension GrafanaClientTypes.AuthenticationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.AuthenticationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.AuthenticationDescription()
        value.providers = try reader["providers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GrafanaClientTypes.AuthenticationProviderTypes>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.saml = try reader["saml"].readIfPresent(with: GrafanaClientTypes.SamlAuthentication.read(from:))
        value.awsSso = try reader["awsSso"].readIfPresent(with: GrafanaClientTypes.AwsSsoAuthentication.read(from:))
        return value
    }
}

extension GrafanaClientTypes.AwsSsoAuthentication {

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.AwsSsoAuthentication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.AwsSsoAuthentication()
        value.ssoClientId = try reader["ssoClientId"].readIfPresent()
        return value
    }
}

extension GrafanaClientTypes.SamlAuthentication {

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.SamlAuthentication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.SamlAuthentication()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.configuration = try reader["configuration"].readIfPresent(with: GrafanaClientTypes.SamlConfiguration.read(from:))
        return value
    }
}

extension GrafanaClientTypes.SamlConfiguration {

    static func write(value: GrafanaClientTypes.SamlConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedOrganizations"].writeList(value.allowedOrganizations, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["assertionAttributes"].write(value.assertionAttributes, with: GrafanaClientTypes.AssertionAttributes.write(value:to:))
        try writer["idpMetadata"].write(value.idpMetadata, with: GrafanaClientTypes.IdpMetadata.write(value:to:))
        try writer["loginValidityDuration"].write(value.loginValidityDuration)
        try writer["roleValues"].write(value.roleValues, with: GrafanaClientTypes.RoleValues.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.SamlConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.SamlConfiguration()
        value.idpMetadata = try reader["idpMetadata"].readIfPresent(with: GrafanaClientTypes.IdpMetadata.read(from:))
        value.assertionAttributes = try reader["assertionAttributes"].readIfPresent(with: GrafanaClientTypes.AssertionAttributes.read(from:))
        value.roleValues = try reader["roleValues"].readIfPresent(with: GrafanaClientTypes.RoleValues.read(from:))
        value.allowedOrganizations = try reader["allowedOrganizations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.loginValidityDuration = try reader["loginValidityDuration"].readIfPresent() ?? 0
        return value
    }
}

extension GrafanaClientTypes.RoleValues {

    static func write(value: GrafanaClientTypes.RoleValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["admin"].writeList(value.admin, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["editor"].writeList(value.editor, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.RoleValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.RoleValues()
        value.editor = try reader["editor"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.admin = try reader["admin"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GrafanaClientTypes.AssertionAttributes {

    static func write(value: GrafanaClientTypes.AssertionAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["email"].write(value.email)
        try writer["groups"].write(value.groups)
        try writer["login"].write(value.login)
        try writer["name"].write(value.name)
        try writer["org"].write(value.org)
        try writer["role"].write(value.role)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.AssertionAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.AssertionAttributes()
        value.name = try reader["name"].readIfPresent()
        value.login = try reader["login"].readIfPresent()
        value.email = try reader["email"].readIfPresent()
        value.groups = try reader["groups"].readIfPresent()
        value.role = try reader["role"].readIfPresent()
        value.org = try reader["org"].readIfPresent()
        return value
    }
}

extension GrafanaClientTypes.IdpMetadata {

    static func write(value: GrafanaClientTypes.IdpMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .url(url):
                try writer["url"].write(url)
            case let .xml(xml):
                try writer["xml"].write(xml)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.IdpMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "url":
                return .url(try reader["url"].read())
            case "xml":
                return .xml(try reader["xml"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension GrafanaClientTypes.PermissionEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.PermissionEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.PermissionEntry()
        value.user = try reader["user"].readIfPresent(with: GrafanaClientTypes.User.read(from:))
        value.role = try reader["role"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GrafanaClientTypes.User {

    static func write(value: GrafanaClientTypes.User?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.User {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.User()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GrafanaClientTypes.WorkspaceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.WorkspaceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.WorkspaceSummary()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.endpoint = try reader["endpoint"].readIfPresent() ?? ""
        value.grafanaVersion = try reader["grafanaVersion"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.modified = try reader["modified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent()
        value.notificationDestinations = try reader["notificationDestinations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GrafanaClientTypes.NotificationDestinationType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.authentication = try reader["authentication"].readIfPresent(with: GrafanaClientTypes.AuthenticationSummary.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.licenseType = try reader["licenseType"].readIfPresent()
        value.grafanaToken = try reader["grafanaToken"].readIfPresent()
        return value
    }
}

extension GrafanaClientTypes.ServiceAccountSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.ServiceAccountSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.ServiceAccountSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.isDisabled = try reader["isDisabled"].readIfPresent() ?? ""
        value.grafanaRole = try reader["grafanaRole"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GrafanaClientTypes.ServiceAccountTokenSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.ServiceAccountTokenSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.ServiceAccountTokenSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUsedAt = try reader["lastUsedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GrafanaClientTypes.UpdateError {

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.UpdateError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.UpdateError()
        value.code = try reader["code"].readIfPresent() ?? 0
        value.message = try reader["message"].readIfPresent() ?? ""
        value.causedBy = try reader["causedBy"].readIfPresent(with: GrafanaClientTypes.UpdateInstruction.read(from:))
        return value
    }
}

extension GrafanaClientTypes.UpdateInstruction {

    static func write(value: GrafanaClientTypes.UpdateInstruction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["role"].write(value.role)
        try writer["users"].writeList(value.users, memberWritingClosure: GrafanaClientTypes.User.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.UpdateInstruction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.UpdateInstruction()
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.role = try reader["role"].readIfPresent() ?? .sdkUnknown("")
        value.users = try reader["users"].readListIfPresent(memberReadingClosure: GrafanaClientTypes.User.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GrafanaClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> GrafanaClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GrafanaClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

public enum GrafanaClientTypes {}
