//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There is an error in the call or in a SQL statement. (This error only appears in calls from Aurora Serverless v1 databases.)
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by this BadRequestException error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There was an error in processing the SQL statement.
public struct DatabaseErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DatabaseErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The DB cluster doesn't have a DB instance.
public struct DatabaseNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DatabaseNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The writer instance in the DB cluster isn't available.
public struct DatabaseUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "DatabaseUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// There are insufficient privileges to make the call.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by this ForbiddenException error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The HTTP endpoint for using RDS Data API isn't enabled for the DB cluster.
public struct HttpEndpointNotEnabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "HttpEndpointNotEnabledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An internal error occurred.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// The Secrets Manager secret used with the request isn't valid.
public struct InvalidSecretException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSecretException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There was a problem with the Secrets Manager secret used with the request, caused by one of the following conditions:
///
/// * RDS Data API timed out retrieving the secret.
///
/// * The secret provided wasn't found.
///
/// * The secret couldn't be decrypted.
public struct SecretsErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SecretsErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service specified by the resourceArn parameter isn't available.
public struct ServiceUnavailableError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "ServiceUnavailableError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// The execution of the SQL statement timed out.
public struct StatementTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The database connection ID that executed the SQL statement.
        public internal(set) var dbConnectionId: Swift.Int = 0
        /// The error message returned by this StatementTimeoutException error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StatementTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        dbConnectionId: Swift.Int = 0,
        message: Swift.String? = nil
    )
    {
        self.properties.dbConnectionId = dbConnectionId
        self.properties.message = message
    }
}

/// The transaction ID wasn't found.
public struct TransactionNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TransactionNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RDSDataClientTypes {

    public enum TypeHint: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case date
        case decimal
        case json
        case time
        case timestamp
        case uuid
        case sdkUnknown(Swift.String)

        public static var allCases: [TypeHint] {
            return [
                .date,
                .decimal,
                .json,
                .time,
                .timestamp,
                .uuid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .date: return "DATE"
            case .decimal: return "DECIMAL"
            case .json: return "JSON"
            case .time: return "TIME"
            case .timestamp: return "TIMESTAMP"
            case .uuid: return "UUID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request parameters represent the input of a request to start a SQL transaction.
public struct BeginTransactionInput: Swift.Sendable {
    /// The name of the database.
    public var database: Swift.String?
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name of the database schema.
    public var schema: Swift.String?
    /// The name or ARN of the secret that enables access to the DB cluster.
    /// This member is required.
    public var secretArn: Swift.String?

    public init(
        database: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        schema: Swift.String? = nil,
        secretArn: Swift.String? = nil
    )
    {
        self.database = database
        self.resourceArn = resourceArn
        self.schema = schema
        self.secretArn = secretArn
    }
}

/// The response elements represent the output of a request to start a SQL transaction.
public struct BeginTransactionOutput: Swift.Sendable {
    /// The transaction ID of the transaction started by the call.
    public var transactionId: Swift.String?

    public init(
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

extension RDSDataClientTypes {

    /// Contains the metadata for a column.
    public struct ColumnMetadata: Swift.Sendable {
        /// The type of the column.
        public var arrayBaseColumnType: Swift.Int
        /// A value that indicates whether the column increments automatically.
        public var isAutoIncrement: Swift.Bool
        /// A value that indicates whether the column is case-sensitive.
        public var isCaseSensitive: Swift.Bool
        /// A value that indicates whether the column contains currency values.
        public var isCurrency: Swift.Bool
        /// A value that indicates whether an integer column is signed.
        public var isSigned: Swift.Bool
        /// The label for the column.
        public var label: Swift.String?
        /// The name of the column.
        public var name: Swift.String?
        /// A value that indicates whether the column is nullable.
        public var nullable: Swift.Int
        /// The precision value of a decimal number column.
        public var precision: Swift.Int
        /// The scale value of a decimal number column.
        public var scale: Swift.Int
        /// The name of the schema that owns the table that includes the column.
        public var schemaName: Swift.String?
        /// The name of the table that includes the column.
        public var tableName: Swift.String?
        /// The type of the column.
        public var type: Swift.Int
        /// The database-specific data type of the column.
        public var typeName: Swift.String?

        public init(
            arrayBaseColumnType: Swift.Int = 0,
            isAutoIncrement: Swift.Bool = false,
            isCaseSensitive: Swift.Bool = false,
            isCurrency: Swift.Bool = false,
            isSigned: Swift.Bool = false,
            label: Swift.String? = nil,
            name: Swift.String? = nil,
            nullable: Swift.Int = 0,
            precision: Swift.Int = 0,
            scale: Swift.Int = 0,
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            type: Swift.Int = 0,
            typeName: Swift.String? = nil
        )
        {
            self.arrayBaseColumnType = arrayBaseColumnType
            self.isAutoIncrement = isAutoIncrement
            self.isCaseSensitive = isCaseSensitive
            self.isCurrency = isCurrency
            self.isSigned = isSigned
            self.label = label
            self.name = name
            self.nullable = nullable
            self.precision = precision
            self.scale = scale
            self.schemaName = schemaName
            self.tableName = tableName
            self.type = type
            self.typeName = typeName
        }
    }
}

/// The resourceArn, secretArn, or transactionId value can't be found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by this NotFoundException error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request parameters represent the input of a commit transaction request.
public struct CommitTransactionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name or ARN of the secret that enables access to the DB cluster.
    /// This member is required.
    public var secretArn: Swift.String?
    /// The identifier of the transaction to end and commit.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.secretArn = secretArn
        self.transactionId = transactionId
    }
}

/// The response elements represent the output of a commit transaction request.
public struct CommitTransactionOutput: Swift.Sendable {
    /// The status of the commit operation.
    public var transactionStatus: Swift.String?

    public init(
        transactionStatus: Swift.String? = nil
    )
    {
        self.transactionStatus = transactionStatus
    }
}

extension RDSDataClientTypes {

    public enum DecimalReturnType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case doubleOrLong
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [DecimalReturnType] {
            return [
                .doubleOrLong,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .doubleOrLong: return "DOUBLE_OR_LONG"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// There was a problem with the result because of one of the following conditions:
///
/// * It contained an unsupported data type.
///
/// * It contained a multidimensional array.
///
/// * The size was too large.
public struct UnsupportedResultException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedResultException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RDSDataClientTypes {

    public enum RecordsFormatType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordsFormatType] {
            return [
                .json,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RDSDataClientTypes {

    public enum LongReturnType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case long
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [LongReturnType] {
            return [
                .long,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .long: return "LONG"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RDSDataClientTypes {

    /// Options that control how the result set is returned.
    public struct ResultSetOptions: Swift.Sendable {
        /// A value that indicates how a field of DECIMAL type is represented in the response. The value of STRING, the default, specifies that it is converted to a String value. The value of DOUBLE_OR_LONG specifies that it is converted to a Long value if its scale is 0, or to a Double value otherwise. Conversion to Double or Long can result in roundoff errors due to precision loss. We recommend converting to String, especially when working with currency values.
        public var decimalReturnType: RDSDataClientTypes.DecimalReturnType?
        /// A value that indicates how a field of LONG type is represented. Allowed values are LONG and STRING. The default is LONG. Specify STRING if the length or precision of numeric values might cause truncation or rounding errors.
        public var longReturnType: RDSDataClientTypes.LongReturnType?

        public init(
            decimalReturnType: RDSDataClientTypes.DecimalReturnType? = nil,
            longReturnType: RDSDataClientTypes.LongReturnType? = nil
        )
        {
            self.decimalReturnType = decimalReturnType
            self.longReturnType = longReturnType
        }
    }
}

/// The request parameters represent the input of a request to perform a rollback of a transaction.
public struct RollbackTransactionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name or ARN of the secret that enables access to the DB cluster.
    /// This member is required.
    public var secretArn: Swift.String?
    /// The identifier of the transaction to roll back.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.secretArn = secretArn
        self.transactionId = transactionId
    }
}

/// The response elements represent the output of a request to perform a rollback of a transaction.
public struct RollbackTransactionOutput: Swift.Sendable {
    /// The status of the rollback operation.
    public var transactionStatus: Swift.String?

    public init(
        transactionStatus: Swift.String? = nil
    )
    {
        self.transactionStatus = transactionStatus
    }
}

extension RDSDataClientTypes {

    /// Contains an array.
    public indirect enum ArrayValue: Swift.Sendable {
        /// An array of Boolean values.
        case booleanvalues([Swift.Bool])
        /// An array of integers.
        case longvalues([Swift.Int])
        /// An array of floating-point numbers.
        case doublevalues([Swift.Double])
        /// An array of strings.
        case stringvalues([Swift.String])
        /// An array of arrays.
        case arrayvalues([RDSDataClientTypes.ArrayValue])
        case sdkUnknown(Swift.String)
    }
}

extension RDSDataClientTypes {

    /// Contains a value.
    public indirect enum Field: Swift.Sendable {
        /// A NULL value.
        case isnull(Swift.Bool)
        /// A value of Boolean data type.
        case booleanvalue(Swift.Bool)
        /// A value of long data type.
        case longvalue(Swift.Int)
        /// A value of double data type.
        case doublevalue(Swift.Double)
        /// A value of string data type.
        case stringvalue(Swift.String)
        /// A value of BLOB data type.
        case blobvalue(Foundation.Data)
        /// An array of values.
        case arrayvalue(RDSDataClientTypes.ArrayValue)
        case sdkUnknown(Swift.String)
    }
}

extension RDSDataClientTypes {

    /// A parameter used in a SQL statement.
    public struct SqlParameter: Swift.Sendable {
        /// The name of the parameter.
        public var name: Swift.String?
        /// A hint that specifies the correct object type for data type mapping. Possible values are as follows:
        ///
        /// * DATE - The corresponding String parameter value is sent as an object of DATE type to the database. The accepted format is YYYY-MM-DD.
        ///
        /// * DECIMAL - The corresponding String parameter value is sent as an object of DECIMAL type to the database.
        ///
        /// * JSON - The corresponding String parameter value is sent as an object of JSON type to the database.
        ///
        /// * TIME - The corresponding String parameter value is sent as an object of TIME type to the database. The accepted format is HH:MM:SS[.FFF].
        ///
        /// * TIMESTAMP - The corresponding String parameter value is sent as an object of TIMESTAMP type to the database. The accepted format is YYYY-MM-DD HH:MM:SS[.FFF].
        ///
        /// * UUID - The corresponding String parameter value is sent as an object of UUID type to the database.
        public var typeHint: RDSDataClientTypes.TypeHint?
        /// The value of the parameter.
        public var value: RDSDataClientTypes.Field?

        public init(
            name: Swift.String? = nil,
            typeHint: RDSDataClientTypes.TypeHint? = nil,
            value: RDSDataClientTypes.Field? = nil
        )
        {
            self.name = name
            self.typeHint = typeHint
            self.value = value
        }
    }
}

extension RDSDataClientTypes {

    /// The response elements represent the results of an update.
    public struct UpdateResult: Swift.Sendable {
        /// Values for fields generated during the request.
        public var generatedFields: [RDSDataClientTypes.Field]?

        public init(
            generatedFields: [RDSDataClientTypes.Field]? = nil
        )
        {
            self.generatedFields = generatedFields
        }
    }
}

/// The request parameters represent the input of a request to run a SQL statement against a database.
public struct ExecuteStatementInput: Swift.Sendable {
    /// A value that indicates whether to continue running the statement after the call times out. By default, the statement stops running when the call times out. For DDL statements, we recommend continuing to run the statement after the call times out. When a DDL statement terminates before it is finished running, it can result in errors and possibly corrupted data structures.
    public var continueAfterTimeout: Swift.Bool
    /// The name of the database.
    public var database: Swift.String?
    /// A value that indicates whether to format the result set as a single JSON string. This parameter only applies to SELECT statements and is ignored for other types of statements. Allowed values are NONE and JSON. The default value is NONE. The result is returned in the formattedRecords field. For usage information about the JSON format for result sets, see [Using the Data API](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html) in the Amazon Aurora User Guide.
    public var formatRecordsAs: RDSDataClientTypes.RecordsFormatType?
    /// A value that indicates whether to include metadata in the results.
    public var includeResultMetadata: Swift.Bool
    /// The parameters for the SQL statement. Array parameters are not supported.
    public var parameters: [RDSDataClientTypes.SqlParameter]?
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Options that control how the result set is returned.
    public var resultSetOptions: RDSDataClientTypes.ResultSetOptions?
    /// The name of the database schema. Currently, the schema parameter isn't supported.
    public var schema: Swift.String?
    /// The ARN of the secret that enables access to the DB cluster. Enter the database user name and password for the credentials in the secret. For information about creating the secret, see [Create a database secret](https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_database_secret.html).
    /// This member is required.
    public var secretArn: Swift.String?
    /// The SQL statement to run.
    /// This member is required.
    public var sql: Swift.String?
    /// The identifier of a transaction that was started by using the BeginTransaction operation. Specify the transaction ID of the transaction that you want to include the SQL statement in. If the SQL statement is not part of a transaction, don't set this parameter.
    public var transactionId: Swift.String?

    public init(
        continueAfterTimeout: Swift.Bool = false,
        database: Swift.String? = nil,
        formatRecordsAs: RDSDataClientTypes.RecordsFormatType? = nil,
        includeResultMetadata: Swift.Bool = false,
        parameters: [RDSDataClientTypes.SqlParameter]? = nil,
        resourceArn: Swift.String? = nil,
        resultSetOptions: RDSDataClientTypes.ResultSetOptions? = nil,
        schema: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        sql: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.continueAfterTimeout = continueAfterTimeout
        self.database = database
        self.formatRecordsAs = formatRecordsAs
        self.includeResultMetadata = includeResultMetadata
        self.parameters = parameters
        self.resourceArn = resourceArn
        self.resultSetOptions = resultSetOptions
        self.schema = schema
        self.secretArn = secretArn
        self.sql = sql
        self.transactionId = transactionId
    }
}

/// The request parameters represent the input of a SQL statement over an array of data.
public struct BatchExecuteStatementInput: Swift.Sendable {
    /// The name of the database.
    public var database: Swift.String?
    /// The parameter set for the batch operation. The SQL statement is executed as many times as the number of parameter sets provided. To execute a SQL statement with no parameters, use one of the following options:
    ///
    /// * Specify one or more empty parameter sets.
    ///
    /// * Use the ExecuteStatement operation instead of the BatchExecuteStatement operation.
    ///
    ///
    /// Array parameters are not supported.
    public var parameterSets: [[RDSDataClientTypes.SqlParameter]]?
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name of the database schema. Currently, the schema parameter isn't supported.
    public var schema: Swift.String?
    /// The ARN of the secret that enables access to the DB cluster. Enter the database user name and password for the credentials in the secret. For information about creating the secret, see [Create a database secret](https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_database_secret.html).
    /// This member is required.
    public var secretArn: Swift.String?
    /// The SQL statement to run. Don't include a semicolon (;) at the end of the SQL statement.
    /// This member is required.
    public var sql: Swift.String?
    /// The identifier of a transaction that was started by using the BeginTransaction operation. Specify the transaction ID of the transaction that you want to include the SQL statement in. If the SQL statement is not part of a transaction, don't set this parameter.
    public var transactionId: Swift.String?

    public init(
        database: Swift.String? = nil,
        parameterSets: [[RDSDataClientTypes.SqlParameter]]? = nil,
        resourceArn: Swift.String? = nil,
        schema: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        sql: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.database = database
        self.parameterSets = parameterSets
        self.resourceArn = resourceArn
        self.schema = schema
        self.secretArn = secretArn
        self.sql = sql
        self.transactionId = transactionId
    }
}

/// The response elements represent the output of a SQL statement over an array of data.
public struct BatchExecuteStatementOutput: Swift.Sendable {
    /// The execution results of each batch entry.
    public var updateResults: [RDSDataClientTypes.UpdateResult]?

    public init(
        updateResults: [RDSDataClientTypes.UpdateResult]? = nil
    )
    {
        self.updateResults = updateResults
    }
}

/// The response elements represent the output of a request to run a SQL statement against a database.
public struct ExecuteStatementOutput: Swift.Sendable {
    /// Metadata for the columns included in the results. This field is blank if the formatRecordsAs parameter is set to JSON.
    public var columnMetadata: [RDSDataClientTypes.ColumnMetadata]?
    /// A string value that represents the result set of a SELECT statement in JSON format. This value is only present when the formatRecordsAs parameter is set to JSON. The size limit for this field is currently 10 MB. If the JSON-formatted string representing the result set requires more than 10 MB, the call returns an error.
    public var formattedRecords: Swift.String?
    /// Values for fields generated during a DML request. The generatedFields data isn't supported by Aurora PostgreSQL. To get the values of generated fields, use the RETURNING clause. For more information, see [Returning Data From Modified Rows](https://www.postgresql.org/docs/10/dml-returning.html) in the PostgreSQL documentation.
    public var generatedFields: [RDSDataClientTypes.Field]?
    /// The number of records updated by the request.
    public var numberOfRecordsUpdated: Swift.Int
    /// The records returned by the SQL statement. This field is blank if the formatRecordsAs parameter is set to JSON.
    public var records: [[RDSDataClientTypes.Field]]?

    public init(
        columnMetadata: [RDSDataClientTypes.ColumnMetadata]? = nil,
        formattedRecords: Swift.String? = nil,
        generatedFields: [RDSDataClientTypes.Field]? = nil,
        numberOfRecordsUpdated: Swift.Int = 0,
        records: [[RDSDataClientTypes.Field]]? = nil
    )
    {
        self.columnMetadata = columnMetadata
        self.formattedRecords = formattedRecords
        self.generatedFields = generatedFields
        self.numberOfRecordsUpdated = numberOfRecordsUpdated
        self.records = records
    }
}

extension BatchExecuteStatementInput {

    static func urlPathProvider(_ value: BatchExecuteStatementInput) -> Swift.String? {
        return "/BatchExecute"
    }
}

extension BeginTransactionInput {

    static func urlPathProvider(_ value: BeginTransactionInput) -> Swift.String? {
        return "/BeginTransaction"
    }
}

extension CommitTransactionInput {

    static func urlPathProvider(_ value: CommitTransactionInput) -> Swift.String? {
        return "/CommitTransaction"
    }
}

extension ExecuteStatementInput {

    static func urlPathProvider(_ value: ExecuteStatementInput) -> Swift.String? {
        return "/Execute"
    }
}

extension RollbackTransactionInput {

    static func urlPathProvider(_ value: RollbackTransactionInput) -> Swift.String? {
        return "/RollbackTransaction"
    }
}

extension BatchExecuteStatementInput {

    static func write(value: BatchExecuteStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["database"].write(value.database)
        try writer["parameterSets"].writeList(value.parameterSets, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: RDSDataClientTypes.SqlParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceArn"].write(value.resourceArn)
        try writer["schema"].write(value.schema)
        try writer["secretArn"].write(value.secretArn)
        try writer["sql"].write(value.sql)
        try writer["transactionId"].write(value.transactionId)
    }
}

extension BeginTransactionInput {

    static func write(value: BeginTransactionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["database"].write(value.database)
        try writer["resourceArn"].write(value.resourceArn)
        try writer["schema"].write(value.schema)
        try writer["secretArn"].write(value.secretArn)
    }
}

extension CommitTransactionInput {

    static func write(value: CommitTransactionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["secretArn"].write(value.secretArn)
        try writer["transactionId"].write(value.transactionId)
    }
}

extension ExecuteStatementInput {

    static func write(value: ExecuteStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["continueAfterTimeout"].write(value.continueAfterTimeout)
        try writer["database"].write(value.database)
        try writer["formatRecordsAs"].write(value.formatRecordsAs)
        try writer["includeResultMetadata"].write(value.includeResultMetadata)
        try writer["parameters"].writeList(value.parameters, memberWritingClosure: RDSDataClientTypes.SqlParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceArn"].write(value.resourceArn)
        try writer["resultSetOptions"].write(value.resultSetOptions, with: RDSDataClientTypes.ResultSetOptions.write(value:to:))
        try writer["schema"].write(value.schema)
        try writer["secretArn"].write(value.secretArn)
        try writer["sql"].write(value.sql)
        try writer["transactionId"].write(value.transactionId)
    }
}

extension RollbackTransactionInput {

    static func write(value: RollbackTransactionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["secretArn"].write(value.secretArn)
        try writer["transactionId"].write(value.transactionId)
    }
}

extension BatchExecuteStatementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchExecuteStatementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchExecuteStatementOutput()
        value.updateResults = try reader["updateResults"].readListIfPresent(memberReadingClosure: RDSDataClientTypes.UpdateResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BeginTransactionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BeginTransactionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BeginTransactionOutput()
        value.transactionId = try reader["transactionId"].readIfPresent()
        return value
    }
}

extension CommitTransactionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CommitTransactionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CommitTransactionOutput()
        value.transactionStatus = try reader["transactionStatus"].readIfPresent()
        return value
    }
}

extension ExecuteStatementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteStatementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExecuteStatementOutput()
        value.columnMetadata = try reader["columnMetadata"].readListIfPresent(memberReadingClosure: RDSDataClientTypes.ColumnMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.formattedRecords = try reader["formattedRecords"].readIfPresent()
        value.generatedFields = try reader["generatedFields"].readListIfPresent(memberReadingClosure: RDSDataClientTypes.Field.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.numberOfRecordsUpdated = try reader["numberOfRecordsUpdated"].readIfPresent() ?? 0
        value.records = try reader["records"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: RDSDataClientTypes.Field.read(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RollbackTransactionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RollbackTransactionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RollbackTransactionOutput()
        value.transactionStatus = try reader["transactionStatus"].readIfPresent()
        return value
    }
}

enum BatchExecuteStatementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DatabaseErrorException": return try DatabaseErrorException.makeError(baseError: baseError)
            case "DatabaseNotFoundException": return try DatabaseNotFoundException.makeError(baseError: baseError)
            case "DatabaseUnavailableException": return try DatabaseUnavailableException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "HttpEndpointNotEnabledException": return try HttpEndpointNotEnabledException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidSecretException": return try InvalidSecretException.makeError(baseError: baseError)
            case "SecretsErrorException": return try SecretsErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableError": return try ServiceUnavailableError.makeError(baseError: baseError)
            case "StatementTimeoutException": return try StatementTimeoutException.makeError(baseError: baseError)
            case "TransactionNotFoundException": return try TransactionNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BeginTransactionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DatabaseErrorException": return try DatabaseErrorException.makeError(baseError: baseError)
            case "DatabaseNotFoundException": return try DatabaseNotFoundException.makeError(baseError: baseError)
            case "DatabaseUnavailableException": return try DatabaseUnavailableException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "HttpEndpointNotEnabledException": return try HttpEndpointNotEnabledException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidSecretException": return try InvalidSecretException.makeError(baseError: baseError)
            case "SecretsErrorException": return try SecretsErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableError": return try ServiceUnavailableError.makeError(baseError: baseError)
            case "StatementTimeoutException": return try StatementTimeoutException.makeError(baseError: baseError)
            case "TransactionNotFoundException": return try TransactionNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CommitTransactionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DatabaseErrorException": return try DatabaseErrorException.makeError(baseError: baseError)
            case "DatabaseNotFoundException": return try DatabaseNotFoundException.makeError(baseError: baseError)
            case "DatabaseUnavailableException": return try DatabaseUnavailableException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "HttpEndpointNotEnabledException": return try HttpEndpointNotEnabledException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidSecretException": return try InvalidSecretException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "SecretsErrorException": return try SecretsErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableError": return try ServiceUnavailableError.makeError(baseError: baseError)
            case "StatementTimeoutException": return try StatementTimeoutException.makeError(baseError: baseError)
            case "TransactionNotFoundException": return try TransactionNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteStatementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DatabaseErrorException": return try DatabaseErrorException.makeError(baseError: baseError)
            case "DatabaseNotFoundException": return try DatabaseNotFoundException.makeError(baseError: baseError)
            case "DatabaseUnavailableException": return try DatabaseUnavailableException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "HttpEndpointNotEnabledException": return try HttpEndpointNotEnabledException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidSecretException": return try InvalidSecretException.makeError(baseError: baseError)
            case "SecretsErrorException": return try SecretsErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableError": return try ServiceUnavailableError.makeError(baseError: baseError)
            case "StatementTimeoutException": return try StatementTimeoutException.makeError(baseError: baseError)
            case "TransactionNotFoundException": return try TransactionNotFoundException.makeError(baseError: baseError)
            case "UnsupportedResultException": return try UnsupportedResultException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RollbackTransactionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DatabaseErrorException": return try DatabaseErrorException.makeError(baseError: baseError)
            case "DatabaseNotFoundException": return try DatabaseNotFoundException.makeError(baseError: baseError)
            case "DatabaseUnavailableException": return try DatabaseUnavailableException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "HttpEndpointNotEnabledException": return try HttpEndpointNotEnabledException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidSecretException": return try InvalidSecretException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "SecretsErrorException": return try SecretsErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableError": return try ServiceUnavailableError.makeError(baseError: baseError)
            case "StatementTimeoutException": return try StatementTimeoutException.makeError(baseError: baseError)
            case "TransactionNotFoundException": return try TransactionNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DatabaseNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DatabaseNotFoundException {
        let reader = baseError.errorBodyReader
        var value = DatabaseNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DatabaseUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DatabaseUnavailableException {
        var value = DatabaseUnavailableException()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TransactionNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TransactionNotFoundException {
        let reader = baseError.errorBodyReader
        var value = TransactionNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DatabaseErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DatabaseErrorException {
        let reader = baseError.errorBodyReader
        var value = DatabaseErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension HttpEndpointNotEnabledException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> HttpEndpointNotEnabledException {
        let reader = baseError.errorBodyReader
        var value = HttpEndpointNotEnabledException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        var value = InternalServerErrorException()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StatementTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> StatementTimeoutException {
        let reader = baseError.errorBodyReader
        var value = StatementTimeoutException()
        value.properties.dbConnectionId = try reader["dbConnectionId"].readIfPresent() ?? 0
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableError {
        var value = ServiceUnavailableError()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSecretException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidSecretException {
        let reader = baseError.errorBodyReader
        var value = InvalidSecretException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SecretsErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SecretsErrorException {
        let reader = baseError.errorBodyReader
        var value = SecretsErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedResultException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedResultException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedResultException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RDSDataClientTypes.UpdateResult {

    static func read(from reader: SmithyJSON.Reader) throws -> RDSDataClientTypes.UpdateResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RDSDataClientTypes.UpdateResult()
        value.generatedFields = try reader["generatedFields"].readListIfPresent(memberReadingClosure: RDSDataClientTypes.Field.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RDSDataClientTypes.Field {

    static func write(value: RDSDataClientTypes.Field?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .arrayvalue(arrayvalue):
                try writer["arrayValue"].write(arrayvalue, with: RDSDataClientTypes.ArrayValue.write(value:to:))
            case let .blobvalue(blobvalue):
                try writer["blobValue"].write(blobvalue)
            case let .booleanvalue(booleanvalue):
                try writer["booleanValue"].write(booleanvalue)
            case let .doublevalue(doublevalue):
                try writer["doubleValue"].write(doublevalue)
            case let .isnull(isnull):
                try writer["isNull"].write(isnull)
            case let .longvalue(longvalue):
                try writer["longValue"].write(longvalue)
            case let .stringvalue(stringvalue):
                try writer["stringValue"].write(stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RDSDataClientTypes.Field {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "isNull":
                return .isnull(try reader["isNull"].read())
            case "booleanValue":
                return .booleanvalue(try reader["booleanValue"].read())
            case "longValue":
                return .longvalue(try reader["longValue"].read())
            case "doubleValue":
                return .doublevalue(try reader["doubleValue"].read())
            case "stringValue":
                return .stringvalue(try reader["stringValue"].read())
            case "blobValue":
                return .blobvalue(try reader["blobValue"].read())
            case "arrayValue":
                return .arrayvalue(try reader["arrayValue"].read(with: RDSDataClientTypes.ArrayValue.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension RDSDataClientTypes.ArrayValue {

    static func write(value: RDSDataClientTypes.ArrayValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .arrayvalues(arrayvalues):
                try writer["arrayValues"].writeList(arrayvalues, memberWritingClosure: RDSDataClientTypes.ArrayValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .booleanvalues(booleanvalues):
                try writer["booleanValues"].writeList(booleanvalues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeBool(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .doublevalues(doublevalues):
                try writer["doubleValues"].writeList(doublevalues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .longvalues(longvalues):
                try writer["longValues"].writeList(longvalues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .stringvalues(stringvalues):
                try writer["stringValues"].writeList(stringvalues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RDSDataClientTypes.ArrayValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "booleanValues":
                return .booleanvalues(try reader["booleanValues"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readBool(from:), memberNodeInfo: "member", isFlattened: false))
            case "longValues":
                return .longvalues(try reader["longValues"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false))
            case "doubleValues":
                return .doublevalues(try reader["doubleValues"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false))
            case "stringValues":
                return .stringvalues(try reader["stringValues"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false))
            case "arrayValues":
                return .arrayvalues(try reader["arrayValues"].readList(memberReadingClosure: RDSDataClientTypes.ArrayValue.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension RDSDataClientTypes.ColumnMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> RDSDataClientTypes.ColumnMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RDSDataClientTypes.ColumnMetadata()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent() ?? 0
        value.typeName = try reader["typeName"].readIfPresent()
        value.label = try reader["label"].readIfPresent()
        value.schemaName = try reader["schemaName"].readIfPresent()
        value.tableName = try reader["tableName"].readIfPresent()
        value.isAutoIncrement = try reader["isAutoIncrement"].readIfPresent() ?? false
        value.isSigned = try reader["isSigned"].readIfPresent() ?? false
        value.isCurrency = try reader["isCurrency"].readIfPresent() ?? false
        value.isCaseSensitive = try reader["isCaseSensitive"].readIfPresent() ?? false
        value.nullable = try reader["nullable"].readIfPresent() ?? 0
        value.precision = try reader["precision"].readIfPresent() ?? 0
        value.scale = try reader["scale"].readIfPresent() ?? 0
        value.arrayBaseColumnType = try reader["arrayBaseColumnType"].readIfPresent() ?? 0
        return value
    }
}

extension RDSDataClientTypes.SqlParameter {

    static func write(value: RDSDataClientTypes.SqlParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["typeHint"].write(value.typeHint)
        try writer["value"].write(value.value, with: RDSDataClientTypes.Field.write(value:to:))
    }
}

extension RDSDataClientTypes.ResultSetOptions {

    static func write(value: RDSDataClientTypes.ResultSetOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["decimalReturnType"].write(value.decimalReturnType)
        try writer["longReturnType"].write(value.longReturnType)
    }
}

public enum RDSDataClientTypes {}
