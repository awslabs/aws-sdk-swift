// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RDSDataClientTypes.ArrayValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayvalues = "arrayValues"
        case booleanvalues = "booleanValues"
        case doublevalues = "doubleValues"
        case longvalues = "longValues"
        case sdkUnknown
        case stringvalues = "stringValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arrayvalues(arrayvalues):
                var arrayvaluesContainer = container.nestedUnkeyedContainer(forKey: .arrayvalues)
                for arrayvalue0 in arrayvalues {
                    try arrayvaluesContainer.encode(arrayvalue0)
                }
            case let .booleanvalues(booleanvalues):
                var booleanvaluesContainer = container.nestedUnkeyedContainer(forKey: .booleanvalues)
                for boxedboolean0 in booleanvalues {
                    try booleanvaluesContainer.encode(boxedboolean0)
                }
            case let .doublevalues(doublevalues):
                var doublevaluesContainer = container.nestedUnkeyedContainer(forKey: .doublevalues)
                for boxeddouble0 in doublevalues {
                    try doublevaluesContainer.encode(boxeddouble0)
                }
            case let .longvalues(longvalues):
                var longvaluesContainer = container.nestedUnkeyedContainer(forKey: .longvalues)
                for boxedlong0 in longvalues {
                    try longvaluesContainer.encode(boxedlong0)
                }
            case let .stringvalues(stringvalues):
                var stringvaluesContainer = container.nestedUnkeyedContainer(forKey: .stringvalues)
                for string0 in stringvalues {
                    try stringvaluesContainer.encode(string0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let booleanvaluesContainer = try values.decodeIfPresent([Swift.Bool?].self, forKey: .booleanvalues)
        var booleanvaluesDecoded0:[Swift.Bool]? = nil
        if let booleanvaluesContainer = booleanvaluesContainer {
            booleanvaluesDecoded0 = [Swift.Bool]()
            for boolean0 in booleanvaluesContainer {
                if let boolean0 = boolean0 {
                    booleanvaluesDecoded0?.append(boolean0)
                }
            }
        }
        if let booleanvalues = booleanvaluesDecoded0 {
            self = .booleanvalues(booleanvalues)
            return
        }
        let longvaluesContainer = try values.decodeIfPresent([Swift.Int?].self, forKey: .longvalues)
        var longvaluesDecoded0:[Swift.Int]? = nil
        if let longvaluesContainer = longvaluesContainer {
            longvaluesDecoded0 = [Swift.Int]()
            for long0 in longvaluesContainer {
                if let long0 = long0 {
                    longvaluesDecoded0?.append(long0)
                }
            }
        }
        if let longvalues = longvaluesDecoded0 {
            self = .longvalues(longvalues)
            return
        }
        let doublevaluesContainer = try values.decodeIfPresent([Swift.Double?].self, forKey: .doublevalues)
        var doublevaluesDecoded0:[Swift.Double]? = nil
        if let doublevaluesContainer = doublevaluesContainer {
            doublevaluesDecoded0 = [Swift.Double]()
            for double0 in doublevaluesContainer {
                if let double0 = double0 {
                    doublevaluesDecoded0?.append(double0)
                }
            }
        }
        if let doublevalues = doublevaluesDecoded0 {
            self = .doublevalues(doublevalues)
            return
        }
        let stringvaluesContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .stringvalues)
        var stringvaluesDecoded0:[Swift.String]? = nil
        if let stringvaluesContainer = stringvaluesContainer {
            stringvaluesDecoded0 = [Swift.String]()
            for string0 in stringvaluesContainer {
                if let string0 = string0 {
                    stringvaluesDecoded0?.append(string0)
                }
            }
        }
        if let stringvalues = stringvaluesDecoded0 {
            self = .stringvalues(stringvalues)
            return
        }
        let arrayvaluesContainer = try values.decodeIfPresent([RDSDataClientTypes.ArrayValue?].self, forKey: .arrayvalues)
        var arrayvaluesDecoded0:[RDSDataClientTypes.ArrayValue]? = nil
        if let arrayvaluesContainer = arrayvaluesContainer {
            arrayvaluesDecoded0 = [RDSDataClientTypes.ArrayValue]()
            for union0 in arrayvaluesContainer {
                if let union0 = union0 {
                    arrayvaluesDecoded0?.append(union0)
                }
            }
        }
        if let arrayvalues = arrayvaluesDecoded0 {
            self = .arrayvalues(arrayvalues)
            return
        }
        self = .sdkUnknown("")
    }
}

extension RDSDataClientTypes {
    /// Contains an array.
    public enum ArrayValue: Swift.Equatable {
        /// An array of Boolean values.
        case booleanvalues([Swift.Bool])
        /// An array of integers.
        case longvalues([Swift.Int])
        /// An array of floating-point numbers.
        case doublevalues([Swift.Double])
        /// An array of strings.
        case stringvalues([Swift.String])
        /// An array of arrays.
        case arrayvalues([RDSDataClientTypes.ArrayValue])
        case sdkUnknown(Swift.String)
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is an error in the call or in a SQL statement.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by this BadRequestException error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchExecuteStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database
        case parameterSets
        case resourceArn
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let parameterSets = parameterSets {
            var parameterSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterSets)
            for sqlparameterslist0 in parameterSets {
                var sqlparameterslist0Container = parameterSetsContainer.nestedUnkeyedContainer()
                for sqlparameter1 in sqlparameterslist0 {
                    try sqlparameterslist0Container.encode(sqlparameter1)
                }
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let sql = self.sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension BatchExecuteStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BatchExecute"
    }
}

/// The request parameters represent the input of a SQL statement over an array of data.
public struct BatchExecuteStatementInput: Swift.Equatable {
    /// The name of the database.
    public var database: Swift.String?
    /// The parameter set for the batch operation. The SQL statement is executed as many times as the number of parameter sets provided. To execute a SQL statement with no parameters, use one of the following options:
    ///
    /// * Specify one or more empty parameter sets.
    ///
    /// * Use the ExecuteStatement operation instead of the BatchExecuteStatement operation.
    ///
    ///
    /// Array parameters are not supported.
    public var parameterSets: [[RDSDataClientTypes.SqlParameter]]?
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name of the database schema. Currently, the schema parameter isn't supported.
    public var schema: Swift.String?
    /// The ARN of the secret that enables access to the DB cluster. Enter the database user name and password for the credentials in the secret. For information about creating the secret, see [Create a database secret](https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_database_secret.html).
    /// This member is required.
    public var secretArn: Swift.String?
    /// The SQL statement to run. Don't include a semicolon (;) at the end of the SQL statement.
    /// This member is required.
    public var sql: Swift.String?
    /// The identifier of a transaction that was started by using the BeginTransaction operation. Specify the transaction ID of the transaction that you want to include the SQL statement in. If the SQL statement is not part of a transaction, don't set this parameter.
    public var transactionId: Swift.String?

    public init(
        database: Swift.String? = nil,
        parameterSets: [[RDSDataClientTypes.SqlParameter]]? = nil,
        resourceArn: Swift.String? = nil,
        schema: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        sql: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.database = database
        self.parameterSets = parameterSets
        self.resourceArn = resourceArn
        self.schema = schema
        self.secretArn = secretArn
        self.sql = sql
        self.transactionId = transactionId
    }
}

struct BatchExecuteStatementInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let secretArn: Swift.String?
    let sql: Swift.String?
    let database: Swift.String?
    let schema: Swift.String?
    let parameterSets: [[RDSDataClientTypes.SqlParameter]]?
    let transactionId: Swift.String?
}

extension BatchExecuteStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database
        case parameterSets
        case resourceArn
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let sqlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sql)
        sql = sqlDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let parameterSetsContainer = try containerValues.decodeIfPresent([[RDSDataClientTypes.SqlParameter?]?].self, forKey: .parameterSets)
        var parameterSetsDecoded0:[[RDSDataClientTypes.SqlParameter]]? = nil
        if let parameterSetsContainer = parameterSetsContainer {
            parameterSetsDecoded0 = [[RDSDataClientTypes.SqlParameter]]()
            for list0 in parameterSetsContainer {
                var list0Decoded0: [RDSDataClientTypes.SqlParameter]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [RDSDataClientTypes.SqlParameter]()
                    for structure1 in list0 {
                        if let structure1 = structure1 {
                            list0Decoded0?.append(structure1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    parameterSetsDecoded0?.append(list0Decoded0)
                }
            }
        }
        parameterSets = parameterSetsDecoded0
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension BatchExecuteStatementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchExecuteStatementOutputBody = try responseDecoder.decode(responseBody: data)
            self.updateResults = output.updateResults
        } else {
            self.updateResults = nil
        }
    }
}

/// The response elements represent the output of a SQL statement over an array of data.
public struct BatchExecuteStatementOutput: Swift.Equatable {
    /// The execution results of each batch entry.
    public var updateResults: [RDSDataClientTypes.UpdateResult]?

    public init(
        updateResults: [RDSDataClientTypes.UpdateResult]? = nil
    )
    {
        self.updateResults = updateResults
    }
}

struct BatchExecuteStatementOutputBody: Swift.Equatable {
    let updateResults: [RDSDataClientTypes.UpdateResult]?
}

extension BatchExecuteStatementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateResults
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateResultsContainer = try containerValues.decodeIfPresent([RDSDataClientTypes.UpdateResult?].self, forKey: .updateResults)
        var updateResultsDecoded0:[RDSDataClientTypes.UpdateResult]? = nil
        if let updateResultsContainer = updateResultsContainer {
            updateResultsDecoded0 = [RDSDataClientTypes.UpdateResult]()
            for structure0 in updateResultsContainer {
                if let structure0 = structure0 {
                    updateResultsDecoded0?.append(structure0)
                }
            }
        }
        updateResults = updateResultsDecoded0
    }
}

enum BatchExecuteStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableError": return try await ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StatementTimeoutException": return try await StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BeginTransactionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database
        case resourceArn
        case schema
        case secretArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
    }
}

extension BeginTransactionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BeginTransaction"
    }
}

/// The request parameters represent the input of a request to start a SQL transaction.
public struct BeginTransactionInput: Swift.Equatable {
    /// The name of the database.
    public var database: Swift.String?
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name of the database schema.
    public var schema: Swift.String?
    /// The name or ARN of the secret that enables access to the DB cluster.
    /// This member is required.
    public var secretArn: Swift.String?

    public init(
        database: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        schema: Swift.String? = nil,
        secretArn: Swift.String? = nil
    )
    {
        self.database = database
        self.resourceArn = resourceArn
        self.schema = schema
        self.secretArn = secretArn
    }
}

struct BeginTransactionInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let secretArn: Swift.String?
    let database: Swift.String?
    let schema: Swift.String?
}

extension BeginTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database
        case resourceArn
        case schema
        case secretArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension BeginTransactionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BeginTransactionOutputBody = try responseDecoder.decode(responseBody: data)
            self.transactionId = output.transactionId
        } else {
            self.transactionId = nil
        }
    }
}

/// The response elements represent the output of a request to start a SQL transaction.
public struct BeginTransactionOutput: Swift.Equatable {
    /// The transaction ID of the transaction started by the call.
    public var transactionId: Swift.String?

    public init(
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

struct BeginTransactionOutputBody: Swift.Equatable {
    let transactionId: Swift.String?
}

extension BeginTransactionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

enum BeginTransactionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableError": return try await ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StatementTimeoutException": return try await StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RDSDataClientTypes.ColumnMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayBaseColumnType
        case isAutoIncrement
        case isCaseSensitive
        case isCurrency
        case isSigned
        case label
        case name
        case nullable
        case precision
        case scale
        case schemaName
        case tableName
        case type
        case typeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if arrayBaseColumnType != 0 {
            try encodeContainer.encode(arrayBaseColumnType, forKey: .arrayBaseColumnType)
        }
        if isAutoIncrement != false {
            try encodeContainer.encode(isAutoIncrement, forKey: .isAutoIncrement)
        }
        if isCaseSensitive != false {
            try encodeContainer.encode(isCaseSensitive, forKey: .isCaseSensitive)
        }
        if isCurrency != false {
            try encodeContainer.encode(isCurrency, forKey: .isCurrency)
        }
        if isSigned != false {
            try encodeContainer.encode(isSigned, forKey: .isSigned)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if nullable != 0 {
            try encodeContainer.encode(nullable, forKey: .nullable)
        }
        if precision != 0 {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if scale != 0 {
            try encodeContainer.encode(scale, forKey: .scale)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if type != 0 {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let typeName = self.typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .type) ?? 0
        type = typeDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let isAutoIncrementDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAutoIncrement) ?? false
        isAutoIncrement = isAutoIncrementDecoded
        let isSignedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSigned) ?? false
        isSigned = isSignedDecoded
        let isCurrencyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isCurrency) ?? false
        isCurrency = isCurrencyDecoded
        let isCaseSensitiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isCaseSensitive) ?? false
        isCaseSensitive = isCaseSensitiveDecoded
        let nullableDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nullable) ?? 0
        nullable = nullableDecoded
        let precisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .precision) ?? 0
        precision = precisionDecoded
        let scaleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .scale) ?? 0
        scale = scaleDecoded
        let arrayBaseColumnTypeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .arrayBaseColumnType) ?? 0
        arrayBaseColumnType = arrayBaseColumnTypeDecoded
    }
}

extension RDSDataClientTypes {
    /// Contains the metadata for a column.
    public struct ColumnMetadata: Swift.Equatable {
        /// The type of the column.
        public var arrayBaseColumnType: Swift.Int
        /// A value that indicates whether the column increments automatically.
        public var isAutoIncrement: Swift.Bool
        /// A value that indicates whether the column is case-sensitive.
        public var isCaseSensitive: Swift.Bool
        /// A value that indicates whether the column contains currency values.
        public var isCurrency: Swift.Bool
        /// A value that indicates whether an integer column is signed.
        public var isSigned: Swift.Bool
        /// The label for the column.
        public var label: Swift.String?
        /// The name of the column.
        public var name: Swift.String?
        /// A value that indicates whether the column is nullable.
        public var nullable: Swift.Int
        /// The precision value of a decimal number column.
        public var precision: Swift.Int
        /// The scale value of a decimal number column.
        public var scale: Swift.Int
        /// The name of the schema that owns the table that includes the column.
        public var schemaName: Swift.String?
        /// The name of the table that includes the column.
        public var tableName: Swift.String?
        /// The type of the column.
        public var type: Swift.Int
        /// The database-specific data type of the column.
        public var typeName: Swift.String?

        public init(
            arrayBaseColumnType: Swift.Int = 0,
            isAutoIncrement: Swift.Bool = false,
            isCaseSensitive: Swift.Bool = false,
            isCurrency: Swift.Bool = false,
            isSigned: Swift.Bool = false,
            label: Swift.String? = nil,
            name: Swift.String? = nil,
            nullable: Swift.Int = 0,
            precision: Swift.Int = 0,
            scale: Swift.Int = 0,
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            type: Swift.Int = 0,
            typeName: Swift.String? = nil
        )
        {
            self.arrayBaseColumnType = arrayBaseColumnType
            self.isAutoIncrement = isAutoIncrement
            self.isCaseSensitive = isCaseSensitive
            self.isCurrency = isCurrency
            self.isSigned = isSigned
            self.label = label
            self.name = name
            self.nullable = nullable
            self.precision = precision
            self.scale = scale
            self.schemaName = schemaName
            self.tableName = tableName
            self.type = type
            self.typeName = typeName
        }
    }

}

extension CommitTransactionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension CommitTransactionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CommitTransaction"
    }
}

/// The request parameters represent the input of a commit transaction request.
public struct CommitTransactionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name or ARN of the secret that enables access to the DB cluster.
    /// This member is required.
    public var secretArn: Swift.String?
    /// The identifier of the transaction to end and commit.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.secretArn = secretArn
        self.transactionId = transactionId
    }
}

struct CommitTransactionInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let secretArn: Swift.String?
    let transactionId: Swift.String?
}

extension CommitTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension CommitTransactionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommitTransactionOutputBody = try responseDecoder.decode(responseBody: data)
            self.transactionStatus = output.transactionStatus
        } else {
            self.transactionStatus = nil
        }
    }
}

/// The response elements represent the output of a commit transaction request.
public struct CommitTransactionOutput: Swift.Equatable {
    /// The status of the commit operation.
    public var transactionStatus: Swift.String?

    public init(
        transactionStatus: Swift.String? = nil
    )
    {
        self.transactionStatus = transactionStatus
    }
}

struct CommitTransactionOutputBody: Swift.Equatable {
    let transactionStatus: Swift.String?
}

extension CommitTransactionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionStatus)
        transactionStatus = transactionStatusDecoded
    }
}

enum CommitTransactionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableError": return try await ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StatementTimeoutException": return try await StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RDSDataClientTypes {
    public enum DecimalReturnType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case doubleOrLong
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [DecimalReturnType] {
            return [
                .doubleOrLong,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .doubleOrLong: return "DOUBLE_OR_LONG"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DecimalReturnType(rawValue: rawValue) ?? DecimalReturnType.sdkUnknown(rawValue)
        }
    }
}

extension ExecuteSqlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsSecretStoreArn
        case database
        case dbClusterOrInstanceArn
        case schema
        case sqlStatements
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsSecretStoreArn = self.awsSecretStoreArn {
            try encodeContainer.encode(awsSecretStoreArn, forKey: .awsSecretStoreArn)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbClusterOrInstanceArn = self.dbClusterOrInstanceArn {
            try encodeContainer.encode(dbClusterOrInstanceArn, forKey: .dbClusterOrInstanceArn)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let sqlStatements = self.sqlStatements {
            try encodeContainer.encode(sqlStatements, forKey: .sqlStatements)
        }
    }
}

extension ExecuteSqlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ExecuteSql"
    }
}

/// The request parameters represent the input of a request to run one or more SQL statements.
public struct ExecuteSqlInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the secret that enables access to the DB cluster. Enter the database user name and password for the credentials in the secret. For information about creating the secret, see [Create a database secret](https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_database_secret.html).
    /// This member is required.
    public var awsSecretStoreArn: Swift.String?
    /// The name of the database.
    public var database: Swift.String?
    /// The ARN of the Aurora Serverless DB cluster.
    /// This member is required.
    public var dbClusterOrInstanceArn: Swift.String?
    /// The name of the database schema.
    public var schema: Swift.String?
    /// One or more SQL statements to run on the DB cluster. You can separate SQL statements from each other with a semicolon (;). Any valid SQL statement is permitted, including data definition, data manipulation, and commit statements.
    /// This member is required.
    public var sqlStatements: Swift.String?

    public init(
        awsSecretStoreArn: Swift.String? = nil,
        database: Swift.String? = nil,
        dbClusterOrInstanceArn: Swift.String? = nil,
        schema: Swift.String? = nil,
        sqlStatements: Swift.String? = nil
    )
    {
        self.awsSecretStoreArn = awsSecretStoreArn
        self.database = database
        self.dbClusterOrInstanceArn = dbClusterOrInstanceArn
        self.schema = schema
        self.sqlStatements = sqlStatements
    }
}

struct ExecuteSqlInputBody: Swift.Equatable {
    let dbClusterOrInstanceArn: Swift.String?
    let awsSecretStoreArn: Swift.String?
    let sqlStatements: Swift.String?
    let database: Swift.String?
    let schema: Swift.String?
}

extension ExecuteSqlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsSecretStoreArn
        case database
        case dbClusterOrInstanceArn
        case schema
        case sqlStatements
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbClusterOrInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterOrInstanceArn)
        dbClusterOrInstanceArn = dbClusterOrInstanceArnDecoded
        let awsSecretStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsSecretStoreArn)
        awsSecretStoreArn = awsSecretStoreArnDecoded
        let sqlStatementsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqlStatements)
        sqlStatements = sqlStatementsDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension ExecuteSqlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExecuteSqlOutputBody = try responseDecoder.decode(responseBody: data)
            self.sqlStatementResults = output.sqlStatementResults
        } else {
            self.sqlStatementResults = nil
        }
    }
}

/// The response elements represent the output of a request to run one or more SQL statements.
public struct ExecuteSqlOutput: Swift.Equatable {
    /// The results of the SQL statement or statements.
    public var sqlStatementResults: [RDSDataClientTypes.SqlStatementResult]?

    public init(
        sqlStatementResults: [RDSDataClientTypes.SqlStatementResult]? = nil
    )
    {
        self.sqlStatementResults = sqlStatementResults
    }
}

struct ExecuteSqlOutputBody: Swift.Equatable {
    let sqlStatementResults: [RDSDataClientTypes.SqlStatementResult]?
}

extension ExecuteSqlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sqlStatementResults
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlStatementResultsContainer = try containerValues.decodeIfPresent([RDSDataClientTypes.SqlStatementResult?].self, forKey: .sqlStatementResults)
        var sqlStatementResultsDecoded0:[RDSDataClientTypes.SqlStatementResult]? = nil
        if let sqlStatementResultsContainer = sqlStatementResultsContainer {
            sqlStatementResultsDecoded0 = [RDSDataClientTypes.SqlStatementResult]()
            for structure0 in sqlStatementResultsContainer {
                if let structure0 = structure0 {
                    sqlStatementResultsDecoded0?.append(structure0)
                }
            }
        }
        sqlStatementResults = sqlStatementResultsDecoded0
    }
}

enum ExecuteSqlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableError": return try await ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExecuteStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continueAfterTimeout
        case database
        case formatRecordsAs
        case includeResultMetadata
        case parameters
        case resourceArn
        case resultSetOptions
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if continueAfterTimeout != false {
            try encodeContainer.encode(continueAfterTimeout, forKey: .continueAfterTimeout)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let formatRecordsAs = self.formatRecordsAs {
            try encodeContainer.encode(formatRecordsAs.rawValue, forKey: .formatRecordsAs)
        }
        if includeResultMetadata != false {
            try encodeContainer.encode(includeResultMetadata, forKey: .includeResultMetadata)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for sqlparameter0 in parameters {
                try parametersContainer.encode(sqlparameter0)
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resultSetOptions = self.resultSetOptions {
            try encodeContainer.encode(resultSetOptions, forKey: .resultSetOptions)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let sql = self.sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension ExecuteStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/Execute"
    }
}

/// The request parameters represent the input of a request to run a SQL statement against a database.
public struct ExecuteStatementInput: Swift.Equatable {
    /// A value that indicates whether to continue running the statement after the call times out. By default, the statement stops running when the call times out. For DDL statements, we recommend continuing to run the statement after the call times out. When a DDL statement terminates before it is finished running, it can result in errors and possibly corrupted data structures.
    public var continueAfterTimeout: Swift.Bool
    /// The name of the database.
    public var database: Swift.String?
    /// A value that indicates whether to format the result set as a single JSON string. This parameter only applies to SELECT statements and is ignored for other types of statements. Allowed values are NONE and JSON. The default value is NONE. The result is returned in the formattedRecords field. For usage information about the JSON format for result sets, see [Using the Data API](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html) in the Amazon Aurora User Guide.
    public var formatRecordsAs: RDSDataClientTypes.RecordsFormatType?
    /// A value that indicates whether to include metadata in the results.
    public var includeResultMetadata: Swift.Bool
    /// The parameters for the SQL statement. Array parameters are not supported.
    public var parameters: [RDSDataClientTypes.SqlParameter]?
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Options that control how the result set is returned.
    public var resultSetOptions: RDSDataClientTypes.ResultSetOptions?
    /// The name of the database schema. Currently, the schema parameter isn't supported.
    public var schema: Swift.String?
    /// The ARN of the secret that enables access to the DB cluster. Enter the database user name and password for the credentials in the secret. For information about creating the secret, see [Create a database secret](https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_database_secret.html).
    /// This member is required.
    public var secretArn: Swift.String?
    /// The SQL statement to run.
    /// This member is required.
    public var sql: Swift.String?
    /// The identifier of a transaction that was started by using the BeginTransaction operation. Specify the transaction ID of the transaction that you want to include the SQL statement in. If the SQL statement is not part of a transaction, don't set this parameter.
    public var transactionId: Swift.String?

    public init(
        continueAfterTimeout: Swift.Bool = false,
        database: Swift.String? = nil,
        formatRecordsAs: RDSDataClientTypes.RecordsFormatType? = nil,
        includeResultMetadata: Swift.Bool = false,
        parameters: [RDSDataClientTypes.SqlParameter]? = nil,
        resourceArn: Swift.String? = nil,
        resultSetOptions: RDSDataClientTypes.ResultSetOptions? = nil,
        schema: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        sql: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.continueAfterTimeout = continueAfterTimeout
        self.database = database
        self.formatRecordsAs = formatRecordsAs
        self.includeResultMetadata = includeResultMetadata
        self.parameters = parameters
        self.resourceArn = resourceArn
        self.resultSetOptions = resultSetOptions
        self.schema = schema
        self.secretArn = secretArn
        self.sql = sql
        self.transactionId = transactionId
    }
}

struct ExecuteStatementInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let secretArn: Swift.String?
    let sql: Swift.String?
    let database: Swift.String?
    let schema: Swift.String?
    let parameters: [RDSDataClientTypes.SqlParameter]?
    let transactionId: Swift.String?
    let includeResultMetadata: Swift.Bool
    let continueAfterTimeout: Swift.Bool
    let resultSetOptions: RDSDataClientTypes.ResultSetOptions?
    let formatRecordsAs: RDSDataClientTypes.RecordsFormatType?
}

extension ExecuteStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continueAfterTimeout
        case database
        case formatRecordsAs
        case includeResultMetadata
        case parameters
        case resourceArn
        case resultSetOptions
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let sqlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sql)
        sql = sqlDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let parametersContainer = try containerValues.decodeIfPresent([RDSDataClientTypes.SqlParameter?].self, forKey: .parameters)
        var parametersDecoded0:[RDSDataClientTypes.SqlParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [RDSDataClientTypes.SqlParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let includeResultMetadataDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeResultMetadata) ?? false
        includeResultMetadata = includeResultMetadataDecoded
        let continueAfterTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .continueAfterTimeout) ?? false
        continueAfterTimeout = continueAfterTimeoutDecoded
        let resultSetOptionsDecoded = try containerValues.decodeIfPresent(RDSDataClientTypes.ResultSetOptions.self, forKey: .resultSetOptions)
        resultSetOptions = resultSetOptionsDecoded
        let formatRecordsAsDecoded = try containerValues.decodeIfPresent(RDSDataClientTypes.RecordsFormatType.self, forKey: .formatRecordsAs)
        formatRecordsAs = formatRecordsAsDecoded
    }
}

extension ExecuteStatementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExecuteStatementOutputBody = try responseDecoder.decode(responseBody: data)
            self.columnMetadata = output.columnMetadata
            self.formattedRecords = output.formattedRecords
            self.generatedFields = output.generatedFields
            self.numberOfRecordsUpdated = output.numberOfRecordsUpdated
            self.records = output.records
        } else {
            self.columnMetadata = nil
            self.formattedRecords = nil
            self.generatedFields = nil
            self.numberOfRecordsUpdated = 0
            self.records = nil
        }
    }
}

/// The response elements represent the output of a request to run a SQL statement against a database.
public struct ExecuteStatementOutput: Swift.Equatable {
    /// Metadata for the columns included in the results. This field is blank if the formatRecordsAs parameter is set to JSON.
    public var columnMetadata: [RDSDataClientTypes.ColumnMetadata]?
    /// A string value that represents the result set of a SELECT statement in JSON format. This value is only present when the formatRecordsAs parameter is set to JSON. The size limit for this field is currently 10 MB. If the JSON-formatted string representing the result set requires more than 10 MB, the call returns an error.
    public var formattedRecords: Swift.String?
    /// Values for fields generated during a DML request. The generatedFields data isn't supported by Aurora PostgreSQL. To get the values of generated fields, use the RETURNING clause. For more information, see [Returning Data From Modified Rows](https://www.postgresql.org/docs/10/dml-returning.html) in the PostgreSQL documentation.
    public var generatedFields: [RDSDataClientTypes.Field]?
    /// The number of records updated by the request.
    public var numberOfRecordsUpdated: Swift.Int
    /// The records returned by the SQL statement. This field is blank if the formatRecordsAs parameter is set to JSON.
    public var records: [[RDSDataClientTypes.Field]]?

    public init(
        columnMetadata: [RDSDataClientTypes.ColumnMetadata]? = nil,
        formattedRecords: Swift.String? = nil,
        generatedFields: [RDSDataClientTypes.Field]? = nil,
        numberOfRecordsUpdated: Swift.Int = 0,
        records: [[RDSDataClientTypes.Field]]? = nil
    )
    {
        self.columnMetadata = columnMetadata
        self.formattedRecords = formattedRecords
        self.generatedFields = generatedFields
        self.numberOfRecordsUpdated = numberOfRecordsUpdated
        self.records = records
    }
}

struct ExecuteStatementOutputBody: Swift.Equatable {
    let records: [[RDSDataClientTypes.Field]]?
    let columnMetadata: [RDSDataClientTypes.ColumnMetadata]?
    let numberOfRecordsUpdated: Swift.Int
    let generatedFields: [RDSDataClientTypes.Field]?
    let formattedRecords: Swift.String?
}

extension ExecuteStatementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnMetadata
        case formattedRecords
        case generatedFields
        case numberOfRecordsUpdated
        case records
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([[RDSDataClientTypes.Field?]?].self, forKey: .records)
        var recordsDecoded0:[[RDSDataClientTypes.Field]]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [[RDSDataClientTypes.Field]]()
            for list0 in recordsContainer {
                var list0Decoded0: [RDSDataClientTypes.Field]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [RDSDataClientTypes.Field]()
                    for union1 in list0 {
                        if let union1 = union1 {
                            list0Decoded0?.append(union1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    recordsDecoded0?.append(list0Decoded0)
                }
            }
        }
        records = recordsDecoded0
        let columnMetadataContainer = try containerValues.decodeIfPresent([RDSDataClientTypes.ColumnMetadata?].self, forKey: .columnMetadata)
        var columnMetadataDecoded0:[RDSDataClientTypes.ColumnMetadata]? = nil
        if let columnMetadataContainer = columnMetadataContainer {
            columnMetadataDecoded0 = [RDSDataClientTypes.ColumnMetadata]()
            for structure0 in columnMetadataContainer {
                if let structure0 = structure0 {
                    columnMetadataDecoded0?.append(structure0)
                }
            }
        }
        columnMetadata = columnMetadataDecoded0
        let numberOfRecordsUpdatedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecordsUpdated) ?? 0
        numberOfRecordsUpdated = numberOfRecordsUpdatedDecoded
        let generatedFieldsContainer = try containerValues.decodeIfPresent([RDSDataClientTypes.Field?].self, forKey: .generatedFields)
        var generatedFieldsDecoded0:[RDSDataClientTypes.Field]? = nil
        if let generatedFieldsContainer = generatedFieldsContainer {
            generatedFieldsDecoded0 = [RDSDataClientTypes.Field]()
            for union0 in generatedFieldsContainer {
                if let union0 = union0 {
                    generatedFieldsDecoded0?.append(union0)
                }
            }
        }
        generatedFields = generatedFieldsDecoded0
        let formattedRecordsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formattedRecords)
        formattedRecords = formattedRecordsDecoded
    }
}

enum ExecuteStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableError": return try await ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StatementTimeoutException": return try await StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RDSDataClientTypes.Field: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayvalue = "arrayValue"
        case blobvalue = "blobValue"
        case booleanvalue = "booleanValue"
        case doublevalue = "doubleValue"
        case isnull = "isNull"
        case longvalue = "longValue"
        case sdkUnknown
        case stringvalue = "stringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arrayvalue(arrayvalue):
                try container.encode(arrayvalue, forKey: .arrayvalue)
            case let .blobvalue(blobvalue):
                try container.encode(blobvalue.base64EncodedString(), forKey: .blobvalue)
            case let .booleanvalue(booleanvalue):
                try container.encode(booleanvalue, forKey: .booleanvalue)
            case let .doublevalue(doublevalue):
                try container.encode(doublevalue, forKey: .doublevalue)
            case let .isnull(isnull):
                try container.encode(isnull, forKey: .isnull)
            case let .longvalue(longvalue):
                try container.encode(longvalue, forKey: .longvalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let isnullDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .isnull)
        if let isnull = isnullDecoded {
            self = .isnull(isnull)
            return
        }
        let booleanvalueDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .booleanvalue)
        if let booleanvalue = booleanvalueDecoded {
            self = .booleanvalue(booleanvalue)
            return
        }
        let longvalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .longvalue)
        if let longvalue = longvalueDecoded {
            self = .longvalue(longvalue)
            return
        }
        let doublevalueDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .doublevalue)
        if let doublevalue = doublevalueDecoded {
            self = .doublevalue(doublevalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let blobvalueDecoded = try values.decodeIfPresent(ClientRuntime.Data.self, forKey: .blobvalue)
        if let blobvalue = blobvalueDecoded {
            self = .blobvalue(blobvalue)
            return
        }
        let arrayvalueDecoded = try values.decodeIfPresent(RDSDataClientTypes.ArrayValue.self, forKey: .arrayvalue)
        if let arrayvalue = arrayvalueDecoded {
            self = .arrayvalue(arrayvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension RDSDataClientTypes {
    /// Contains a value.
    public enum Field: Swift.Equatable {
        /// A NULL value.
        case isnull(Swift.Bool)
        /// A value of Boolean data type.
        case booleanvalue(Swift.Bool)
        /// A value of long data type.
        case longvalue(Swift.Int)
        /// A value of double data type.
        case doublevalue(Swift.Double)
        /// A value of string data type.
        case stringvalue(Swift.String)
        /// A value of BLOB data type.
        case blobvalue(ClientRuntime.Data)
        /// An array of values.
        case arrayvalue(RDSDataClientTypes.ArrayValue)
        case sdkUnknown(Swift.String)
    }

}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There are insufficient privileges to make the call.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by this ForbiddenException error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal error occurred.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension RDSDataClientTypes {
    public enum LongReturnType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case long
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [LongReturnType] {
            return [
                .long,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .long: return "LONG"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LongReturnType(rawValue: rawValue) ?? LongReturnType.sdkUnknown(rawValue)
        }
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resourceArn, secretArn, or transactionId value can't be found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by this NotFoundException error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RDSDataClientTypes.Record: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for value0 in values {
                try valuesContainer.encode(value0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([RDSDataClientTypes.Value?].self, forKey: .values)
        var valuesDecoded0:[RDSDataClientTypes.Value]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [RDSDataClientTypes.Value]()
            for union0 in valuesContainer {
                if let union0 = union0 {
                    valuesDecoded0?.append(union0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension RDSDataClientTypes {
    /// A record returned by a call. This data structure is only used with the deprecated ExecuteSql operation. Use the BatchExecuteStatement or ExecuteStatement operation instead.
    public struct Record: Swift.Equatable {
        /// The values returned in the record.
        public var values: [RDSDataClientTypes.Value]?

        public init(
            values: [RDSDataClientTypes.Value]? = nil
        )
        {
            self.values = values
        }
    }

}

extension RDSDataClientTypes {
    public enum RecordsFormatType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordsFormatType] {
            return [
                .json,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordsFormatType(rawValue: rawValue) ?? RecordsFormatType.sdkUnknown(rawValue)
        }
    }
}

extension RDSDataClientTypes.ResultFrame: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case records
        case resultSetMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for record0 in records {
                try recordsContainer.encode(record0)
            }
        }
        if let resultSetMetadata = self.resultSetMetadata {
            try encodeContainer.encode(resultSetMetadata, forKey: .resultSetMetadata)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultSetMetadataDecoded = try containerValues.decodeIfPresent(RDSDataClientTypes.ResultSetMetadata.self, forKey: .resultSetMetadata)
        resultSetMetadata = resultSetMetadataDecoded
        let recordsContainer = try containerValues.decodeIfPresent([RDSDataClientTypes.Record?].self, forKey: .records)
        var recordsDecoded0:[RDSDataClientTypes.Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [RDSDataClientTypes.Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
    }
}

extension RDSDataClientTypes {
    /// The result set returned by a SQL statement. This data structure is only used with the deprecated ExecuteSql operation. Use the BatchExecuteStatement or ExecuteStatement operation instead.
    public struct ResultFrame: Swift.Equatable {
        /// The records in the result set.
        public var records: [RDSDataClientTypes.Record]?
        /// The result-set metadata in the result set.
        public var resultSetMetadata: RDSDataClientTypes.ResultSetMetadata?

        public init(
            records: [RDSDataClientTypes.Record]? = nil,
            resultSetMetadata: RDSDataClientTypes.ResultSetMetadata? = nil
        )
        {
            self.records = records
            self.resultSetMetadata = resultSetMetadata
        }
    }

}

extension RDSDataClientTypes.ResultSetMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnCount
        case columnMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if columnCount != 0 {
            try encodeContainer.encode(columnCount, forKey: .columnCount)
        }
        if let columnMetadata = columnMetadata {
            var columnMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnMetadata)
            for columnmetadata0 in columnMetadata {
                try columnMetadataContainer.encode(columnmetadata0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .columnCount) ?? 0
        columnCount = columnCountDecoded
        let columnMetadataContainer = try containerValues.decodeIfPresent([RDSDataClientTypes.ColumnMetadata?].self, forKey: .columnMetadata)
        var columnMetadataDecoded0:[RDSDataClientTypes.ColumnMetadata]? = nil
        if let columnMetadataContainer = columnMetadataContainer {
            columnMetadataDecoded0 = [RDSDataClientTypes.ColumnMetadata]()
            for structure0 in columnMetadataContainer {
                if let structure0 = structure0 {
                    columnMetadataDecoded0?.append(structure0)
                }
            }
        }
        columnMetadata = columnMetadataDecoded0
    }
}

extension RDSDataClientTypes {
    /// The metadata of the result set returned by a SQL statement.
    public struct ResultSetMetadata: Swift.Equatable {
        /// The number of columns in the result set.
        public var columnCount: Swift.Int
        /// The metadata of the columns in the result set.
        public var columnMetadata: [RDSDataClientTypes.ColumnMetadata]?

        public init(
            columnCount: Swift.Int = 0,
            columnMetadata: [RDSDataClientTypes.ColumnMetadata]? = nil
        )
        {
            self.columnCount = columnCount
            self.columnMetadata = columnMetadata
        }
    }

}

extension RDSDataClientTypes.ResultSetOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decimalReturnType
        case longReturnType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decimalReturnType = self.decimalReturnType {
            try encodeContainer.encode(decimalReturnType.rawValue, forKey: .decimalReturnType)
        }
        if let longReturnType = self.longReturnType {
            try encodeContainer.encode(longReturnType.rawValue, forKey: .longReturnType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decimalReturnTypeDecoded = try containerValues.decodeIfPresent(RDSDataClientTypes.DecimalReturnType.self, forKey: .decimalReturnType)
        decimalReturnType = decimalReturnTypeDecoded
        let longReturnTypeDecoded = try containerValues.decodeIfPresent(RDSDataClientTypes.LongReturnType.self, forKey: .longReturnType)
        longReturnType = longReturnTypeDecoded
    }
}

extension RDSDataClientTypes {
    /// Options that control how the result set is returned.
    public struct ResultSetOptions: Swift.Equatable {
        /// A value that indicates how a field of DECIMAL type is represented in the response. The value of STRING, the default, specifies that it is converted to a String value. The value of DOUBLE_OR_LONG specifies that it is converted to a Long value if its scale is 0, or to a Double value otherwise. Conversion to Double or Long can result in roundoff errors due to precision loss. We recommend converting to String, especially when working with currency values.
        public var decimalReturnType: RDSDataClientTypes.DecimalReturnType?
        /// A value that indicates how a field of LONG type is represented. Allowed values are LONG and STRING. The default is LONG. Specify STRING if the length or precision of numeric values might cause truncation or rounding errors.
        public var longReturnType: RDSDataClientTypes.LongReturnType?

        public init(
            decimalReturnType: RDSDataClientTypes.DecimalReturnType? = nil,
            longReturnType: RDSDataClientTypes.LongReturnType? = nil
        )
        {
            self.decimalReturnType = decimalReturnType
            self.longReturnType = longReturnType
        }
    }

}

extension RollbackTransactionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension RollbackTransactionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/RollbackTransaction"
    }
}

/// The request parameters represent the input of a request to perform a rollback of a transaction.
public struct RollbackTransactionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name or ARN of the secret that enables access to the DB cluster.
    /// This member is required.
    public var secretArn: Swift.String?
    /// The identifier of the transaction to roll back.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.secretArn = secretArn
        self.transactionId = transactionId
    }
}

struct RollbackTransactionInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let secretArn: Swift.String?
    let transactionId: Swift.String?
}

extension RollbackTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension RollbackTransactionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RollbackTransactionOutputBody = try responseDecoder.decode(responseBody: data)
            self.transactionStatus = output.transactionStatus
        } else {
            self.transactionStatus = nil
        }
    }
}

/// The response elements represent the output of a request to perform a rollback of a transaction.
public struct RollbackTransactionOutput: Swift.Equatable {
    /// The status of the rollback operation.
    public var transactionStatus: Swift.String?

    public init(
        transactionStatus: Swift.String? = nil
    )
    {
        self.transactionStatus = transactionStatus
    }
}

struct RollbackTransactionOutputBody: Swift.Equatable {
    let transactionStatus: Swift.String?
}

extension RollbackTransactionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionStatus)
        transactionStatus = transactionStatusDecoded
    }
}

enum RollbackTransactionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableError": return try await ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StatementTimeoutException": return try await StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceUnavailableError {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service specified by the resourceArn parameter is not available.
public struct ServiceUnavailableError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "ServiceUnavailableError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension RDSDataClientTypes.SqlParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case typeHint
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let typeHint = self.typeHint {
            try encodeContainer.encode(typeHint.rawValue, forKey: .typeHint)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(RDSDataClientTypes.Field.self, forKey: .value)
        value = valueDecoded
        let typeHintDecoded = try containerValues.decodeIfPresent(RDSDataClientTypes.TypeHint.self, forKey: .typeHint)
        typeHint = typeHintDecoded
    }
}

extension RDSDataClientTypes {
    /// A parameter used in a SQL statement.
    public struct SqlParameter: Swift.Equatable {
        /// The name of the parameter.
        public var name: Swift.String?
        /// A hint that specifies the correct object type for data type mapping. Possible values are as follows:
        ///
        /// * DATE - The corresponding String parameter value is sent as an object of DATE type to the database. The accepted format is YYYY-MM-DD.
        ///
        /// * DECIMAL - The corresponding String parameter value is sent as an object of DECIMAL type to the database.
        ///
        /// * JSON - The corresponding String parameter value is sent as an object of JSON type to the database.
        ///
        /// * TIME - The corresponding String parameter value is sent as an object of TIME type to the database. The accepted format is HH:MM:SS[.FFF].
        ///
        /// * TIMESTAMP - The corresponding String parameter value is sent as an object of TIMESTAMP type to the database. The accepted format is YYYY-MM-DD HH:MM:SS[.FFF].
        ///
        /// * UUID - The corresponding String parameter value is sent as an object of UUID type to the database.
        public var typeHint: RDSDataClientTypes.TypeHint?
        /// The value of the parameter.
        public var value: RDSDataClientTypes.Field?

        public init(
            name: Swift.String? = nil,
            typeHint: RDSDataClientTypes.TypeHint? = nil,
            value: RDSDataClientTypes.Field? = nil
        )
        {
            self.name = name
            self.typeHint = typeHint
            self.value = value
        }
    }

}

extension RDSDataClientTypes.SqlStatementResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfRecordsUpdated
        case resultFrame
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if numberOfRecordsUpdated != 0 {
            try encodeContainer.encode(numberOfRecordsUpdated, forKey: .numberOfRecordsUpdated)
        }
        if let resultFrame = self.resultFrame {
            try encodeContainer.encode(resultFrame, forKey: .resultFrame)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultFrameDecoded = try containerValues.decodeIfPresent(RDSDataClientTypes.ResultFrame.self, forKey: .resultFrame)
        resultFrame = resultFrameDecoded
        let numberOfRecordsUpdatedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecordsUpdated) ?? 0
        numberOfRecordsUpdated = numberOfRecordsUpdatedDecoded
    }
}

extension RDSDataClientTypes {
    /// The result of a SQL statement. This data structure is only used with the deprecated ExecuteSql operation. Use the BatchExecuteStatement or ExecuteStatement operation instead.
    public struct SqlStatementResult: Swift.Equatable {
        /// The number of records updated by a SQL statement.
        public var numberOfRecordsUpdated: Swift.Int
        /// The result set of the SQL statement.
        public var resultFrame: RDSDataClientTypes.ResultFrame?

        public init(
            numberOfRecordsUpdated: Swift.Int = 0,
            resultFrame: RDSDataClientTypes.ResultFrame? = nil
        )
        {
            self.numberOfRecordsUpdated = numberOfRecordsUpdated
            self.resultFrame = resultFrame
        }
    }

}

extension StatementTimeoutException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StatementTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.dbConnectionId = output.dbConnectionId
            self.properties.message = output.message
        } else {
            self.properties.dbConnectionId = 0
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The execution of the SQL statement timed out.
public struct StatementTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The database connection ID that executed the SQL statement.
        public internal(set) var dbConnectionId: Swift.Int = 0
        /// The error message returned by this StatementTimeoutException error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StatementTimeoutException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        dbConnectionId: Swift.Int = 0,
        message: Swift.String? = nil
    )
    {
        self.properties.dbConnectionId = dbConnectionId
        self.properties.message = message
    }
}

struct StatementTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let dbConnectionId: Swift.Int
}

extension StatementTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbConnectionId
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let dbConnectionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dbConnectionId) ?? 0
        dbConnectionId = dbConnectionIdDecoded
    }
}

extension RDSDataClientTypes.StructValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for value0 in attributes {
                try attributesContainer.encode(value0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([RDSDataClientTypes.Value?].self, forKey: .attributes)
        var attributesDecoded0:[RDSDataClientTypes.Value]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [RDSDataClientTypes.Value]()
            for union0 in attributesContainer {
                if let union0 = union0 {
                    attributesDecoded0?.append(union0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension RDSDataClientTypes {
    /// A structure value returned by a call. This data structure is only used with the deprecated ExecuteSql operation. Use the BatchExecuteStatement or ExecuteStatement operation instead.
    public struct StructValue: Swift.Equatable {
        /// The attributes returned in the record.
        public var attributes: [RDSDataClientTypes.Value]?

        public init(
            attributes: [RDSDataClientTypes.Value]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

extension RDSDataClientTypes {
    public enum TypeHint: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case date
        case decimal
        case json
        case time
        case timestamp
        case uuid
        case sdkUnknown(Swift.String)

        public static var allCases: [TypeHint] {
            return [
                .date,
                .decimal,
                .json,
                .time,
                .timestamp,
                .uuid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .date: return "DATE"
            case .decimal: return "DECIMAL"
            case .json: return "JSON"
            case .time: return "TIME"
            case .timestamp: return "TIMESTAMP"
            case .uuid: return "UUID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TypeHint(rawValue: rawValue) ?? TypeHint.sdkUnknown(rawValue)
        }
    }
}

extension RDSDataClientTypes.UpdateResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedFields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedFields = generatedFields {
            var generatedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .generatedFields)
            for field0 in generatedFields {
                try generatedFieldsContainer.encode(field0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatedFieldsContainer = try containerValues.decodeIfPresent([RDSDataClientTypes.Field?].self, forKey: .generatedFields)
        var generatedFieldsDecoded0:[RDSDataClientTypes.Field]? = nil
        if let generatedFieldsContainer = generatedFieldsContainer {
            generatedFieldsDecoded0 = [RDSDataClientTypes.Field]()
            for union0 in generatedFieldsContainer {
                if let union0 = union0 {
                    generatedFieldsDecoded0?.append(union0)
                }
            }
        }
        generatedFields = generatedFieldsDecoded0
    }
}

extension RDSDataClientTypes {
    /// The response elements represent the results of an update.
    public struct UpdateResult: Swift.Equatable {
        /// Values for fields generated during the request.
        public var generatedFields: [RDSDataClientTypes.Field]?

        public init(
            generatedFields: [RDSDataClientTypes.Field]? = nil
        )
        {
            self.generatedFields = generatedFields
        }
    }

}

extension RDSDataClientTypes.Value: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayvalues = "arrayValues"
        case bigintvalue = "bigIntValue"
        case bitvalue = "bitValue"
        case blobvalue = "blobValue"
        case doublevalue = "doubleValue"
        case intvalue = "intValue"
        case isnull = "isNull"
        case realvalue = "realValue"
        case sdkUnknown
        case stringvalue = "stringValue"
        case structvalue = "structValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arrayvalues(arrayvalues):
                var arrayvaluesContainer = container.nestedUnkeyedContainer(forKey: .arrayvalues)
                for value0 in arrayvalues {
                    try arrayvaluesContainer.encode(value0)
                }
            case let .bigintvalue(bigintvalue):
                try container.encode(bigintvalue, forKey: .bigintvalue)
            case let .bitvalue(bitvalue):
                try container.encode(bitvalue, forKey: .bitvalue)
            case let .blobvalue(blobvalue):
                try container.encode(blobvalue.base64EncodedString(), forKey: .blobvalue)
            case let .doublevalue(doublevalue):
                try container.encode(doublevalue, forKey: .doublevalue)
            case let .intvalue(intvalue):
                try container.encode(intvalue, forKey: .intvalue)
            case let .isnull(isnull):
                try container.encode(isnull, forKey: .isnull)
            case let .realvalue(realvalue):
                try container.encode(realvalue, forKey: .realvalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .structvalue(structvalue):
                try container.encode(structvalue, forKey: .structvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let isnullDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .isnull)
        if let isnull = isnullDecoded {
            self = .isnull(isnull)
            return
        }
        let bitvalueDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .bitvalue)
        if let bitvalue = bitvalueDecoded {
            self = .bitvalue(bitvalue)
            return
        }
        let bigintvalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .bigintvalue)
        if let bigintvalue = bigintvalueDecoded {
            self = .bigintvalue(bigintvalue)
            return
        }
        let intvalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .intvalue)
        if let intvalue = intvalueDecoded {
            self = .intvalue(intvalue)
            return
        }
        let doublevalueDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .doublevalue)
        if let doublevalue = doublevalueDecoded {
            self = .doublevalue(doublevalue)
            return
        }
        let realvalueDecoded = try values.decodeIfPresent(Swift.Float.self, forKey: .realvalue)
        if let realvalue = realvalueDecoded {
            self = .realvalue(realvalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let blobvalueDecoded = try values.decodeIfPresent(ClientRuntime.Data.self, forKey: .blobvalue)
        if let blobvalue = blobvalueDecoded {
            self = .blobvalue(blobvalue)
            return
        }
        let arrayvaluesContainer = try values.decodeIfPresent([RDSDataClientTypes.Value?].self, forKey: .arrayvalues)
        var arrayvaluesDecoded0:[RDSDataClientTypes.Value]? = nil
        if let arrayvaluesContainer = arrayvaluesContainer {
            arrayvaluesDecoded0 = [RDSDataClientTypes.Value]()
            for union0 in arrayvaluesContainer {
                if let union0 = union0 {
                    arrayvaluesDecoded0?.append(union0)
                }
            }
        }
        if let arrayvalues = arrayvaluesDecoded0 {
            self = .arrayvalues(arrayvalues)
            return
        }
        let structvalueDecoded = try values.decodeIfPresent(RDSDataClientTypes.StructValue.self, forKey: .structvalue)
        if let structvalue = structvalueDecoded {
            self = .structvalue(structvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension RDSDataClientTypes {
    /// Contains the value of a column. This data structure is only used with the deprecated ExecuteSql operation. Use the BatchExecuteStatement or ExecuteStatement operation instead.
    public enum Value: Swift.Equatable {
        /// A NULL value.
        case isnull(Swift.Bool)
        /// A value for a column of BIT data type.
        case bitvalue(Swift.Bool)
        /// A value for a column of big integer data type.
        case bigintvalue(Swift.Int)
        /// A value for a column of integer data type.
        case intvalue(Swift.Int)
        /// A value for a column of double data type.
        case doublevalue(Swift.Double)
        /// A value for a column of real data type.
        case realvalue(Swift.Float)
        /// A value for a column of string data type.
        case stringvalue(Swift.String)
        /// A value for a column of BLOB data type.
        case blobvalue(ClientRuntime.Data)
        /// An array of column values.
        case arrayvalues([RDSDataClientTypes.Value])
        /// A value for a column of STRUCT data type.
        case structvalue(RDSDataClientTypes.StructValue)
        case sdkUnknown(Swift.String)
    }

}
