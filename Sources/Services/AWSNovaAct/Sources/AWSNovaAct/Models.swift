//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import SmithyJSON
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You don't have sufficient permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// You don't have sufficient permissions to perform this action. Verify your IAM permissions and try again.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension NovaActClientTypes {

    /// Error information when an act fails to execute successfully.
    public struct ActError: Swift.Sendable {
        /// A human-readable description of the error that occurred.
        /// This member is required.
        public var message: Swift.String?
        /// The type or category of error that occurred.
        public var type: Swift.String?

        public init(
            message: Swift.String? = nil,
            type: Swift.String? = nil
        ) {
            self.message = message
            self.type = type
        }
    }
}

extension NovaActClientTypes.ActError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActError(type: \(Swift.String(describing: type)), message: \"CONTENT_REDACTED\")"}
}

/// The request could not be completed due to a conflict with the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The requested operation conflicts with the current state of the resource.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that caused the conflict.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that caused the conflict.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension NovaActClientTypes {

    public enum InternalServerExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case invalidModelGeneration
        case tokenLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [InternalServerExceptionReason] {
            return [
                .invalidModelGeneration,
                .tokenLimitExceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .invalidModelGeneration: return "InvalidModelGeneration"
            case .tokenLimitExceeded: return "RequestTokenLimitExceeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// An internal server error occurred. Please try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The service encountered an internal error. Try again later.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the internal server error.
        public internal(set) var reason: NovaActClientTypes.InternalServerExceptionReason? = nil
        /// The number of seconds to wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: NovaActClientTypes.InternalServerExceptionReason? = nil,
        retryAfterSeconds: Swift.Int? = nil
    ) {
        self.properties.message = message
        self.properties.reason = reason
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The requested resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The specified resource was not found.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that wasn't found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that wasn't found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request would exceed a service quota limit.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The request would exceed one or more service quotas for your account.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code for the specific quota that was exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The identifier of the resource that exceeded the quota.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that exceeded the quota.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code for the quota that was exceeded.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The request was throttled due to too many requests. Please try again later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The request was denied due to request throttling.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code related to the throttling.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying the throttled request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The service code where throttling occurred.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension NovaActClientTypes {

    /// Information about a field that failed validation.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A description of the validation error for this field.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

extension NovaActClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fieldValidationFailed
        case guardrailIntervened
        case invalidStatus
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .fieldValidationFailed,
                .guardrailIntervened,
                .invalidStatus
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fieldValidationFailed: return "FieldValidationFailed"
            case .guardrailIntervened: return "GuardrailIntervened"
            case .invalidStatus: return "InvalidStatus"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input parameters for the request are invalid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The list of fields that failed validation.
        public internal(set) var fieldList: [NovaActClientTypes.ValidationExceptionField]? = nil
        /// The input fails to satisfy the constraints specified by the service.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation failure.
        /// This member is required.
        public internal(set) var reason: NovaActClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [NovaActClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: NovaActClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension NovaActClientTypes {

    /// The schema definition for tool input parameters.
    public enum ToolInputSchema: Swift.Sendable {
        /// The JSON schema that defines the expected input format for the tool.
        case json(Smithy.Document)
        case sdkUnknown(Swift.String)
    }
}

extension NovaActClientTypes {

    /// Specification for a tool that acts can invoke, including its name, description, and input schema.
    public struct ToolSpec: Swift.Sendable {
        /// A description of what the tool does and how it should be used.
        /// This member is required.
        public var description: Swift.String?
        /// The JSON schema that defines the expected input format for the tool.
        /// This member is required.
        public var inputSchema: NovaActClientTypes.ToolInputSchema?
        /// The unique name of the tool that acts will use to invoke it.
        /// This member is required.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            inputSchema: NovaActClientTypes.ToolInputSchema? = nil,
            name: Swift.String? = nil
        ) {
            self.description = description
            self.inputSchema = inputSchema
            self.name = name
        }
    }
}

extension NovaActClientTypes.ToolSpec: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ToolSpec(name: \(Swift.String(describing: name)), description: \"CONTENT_REDACTED\", inputSchema: \"CONTENT_REDACTED\")"}
}

public struct CreateActInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the session to create the act in.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The task description that defines what the act should accomplish.
    /// This member is required.
    public var task: Swift.String?
    /// A list of tool specifications that the act can invoke to complete its task.
    public var toolSpecs: [NovaActClientTypes.ToolSpec]?
    /// The name of the workflow definition containing the session.
    /// This member is required.
    public var workflowDefinitionName: Swift.String?
    /// The unique identifier of the workflow run containing the session.
    /// This member is required.
    public var workflowRunId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        task: Swift.String? = nil,
        toolSpecs: [NovaActClientTypes.ToolSpec]? = nil,
        workflowDefinitionName: Swift.String? = nil,
        workflowRunId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.task = task
        self.toolSpecs = toolSpecs
        self.workflowDefinitionName = workflowDefinitionName
        self.workflowRunId = workflowRunId
    }
}

extension CreateActInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateActInput(clientToken: \(Swift.String(describing: clientToken)), sessionId: \(Swift.String(describing: sessionId)), toolSpecs: \(Swift.String(describing: toolSpecs)), workflowDefinitionName: \(Swift.String(describing: workflowDefinitionName)), workflowRunId: \(Swift.String(describing: workflowRunId)), task: \"CONTENT_REDACTED\")"}
}

extension NovaActClientTypes {

    public enum ActStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pendingClientAction
        case pendingHumanAction
        case running
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ActStatus] {
            return [
                .failed,
                .pendingClientAction,
                .pendingHumanAction,
                .running,
                .succeeded,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pendingClientAction: return "PENDING_CLIENT_ACTION"
            case .pendingHumanAction: return "PENDING_HUMAN_ACTION"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateActOutput: Swift.Sendable {
    /// The unique identifier for the created act.
    /// This member is required.
    public var actId: Swift.String?
    /// The initial status of the act after creation.
    /// This member is required.
    public var status: NovaActClientTypes.ActStatus?

    public init(
        actId: Swift.String? = nil,
        status: NovaActClientTypes.ActStatus? = nil
    ) {
        self.actId = actId
        self.status = status
    }
}

extension NovaActClientTypes {

    /// Content returned from a tool call execution.
    public enum CallResultContent: Swift.Sendable {
        /// Text content returned from the tool execution.
        case text(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension NovaActClientTypes {

    /// The result returned from executing a tool call.
    public struct CallResult: Swift.Sendable {
        /// The identifier of the tool call that this result corresponds to.
        public var callId: Swift.String?
        /// The content returned by the tool execution, which can include text or other media types.
        /// This member is required.
        public var content: [NovaActClientTypes.CallResultContent]?

        public init(
            callId: Swift.String? = nil,
            content: [NovaActClientTypes.CallResultContent]? = nil
        ) {
            self.callId = callId
            self.content = content
        }
    }
}

extension NovaActClientTypes.CallResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CallResult(callId: \(Swift.String(describing: callId)), content: \"CONTENT_REDACTED\")"}
}

public struct InvokeActStepInput: Swift.Sendable {
    /// The unique identifier of the act to invoke the next step for.
    /// This member is required.
    public var actId: Swift.String?
    /// The results from previous tool calls that the act requested.
    /// This member is required.
    public var callResults: [NovaActClientTypes.CallResult]?
    /// The identifier of the previous step, used for tracking execution flow.
    public var previousStepId: Swift.String?
    /// The unique identifier of the session containing the act.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The name of the workflow definition containing the act.
    /// This member is required.
    public var workflowDefinitionName: Swift.String?
    /// The unique identifier of the workflow run containing the act.
    /// This member is required.
    public var workflowRunId: Swift.String?

    public init(
        actId: Swift.String? = nil,
        callResults: [NovaActClientTypes.CallResult]? = nil,
        previousStepId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        workflowDefinitionName: Swift.String? = nil,
        workflowRunId: Swift.String? = nil
    ) {
        self.actId = actId
        self.callResults = callResults
        self.previousStepId = previousStepId
        self.sessionId = sessionId
        self.workflowDefinitionName = workflowDefinitionName
        self.workflowRunId = workflowRunId
    }
}

extension NovaActClientTypes {

    /// A request for the client to execute a specific tool with given parameters.
    public struct Call: Swift.Sendable {
        /// A unique identifier for this tool call, used to match results back to requests.
        /// This member is required.
        public var callId: Swift.String?
        /// The input parameters for the tool call, formatted according to the tool's schema.
        /// This member is required.
        public var input: Smithy.Document?
        /// The name of the tool to invoke, following the pattern 'tool.{toolName}' or 'browser.{browserAction}'.
        /// This member is required.
        public var name: Swift.String?

        public init(
            callId: Swift.String? = nil,
            input: Smithy.Document? = nil,
            name: Swift.String? = nil
        ) {
            self.callId = callId
            self.input = input
            self.name = name
        }
    }
}

extension NovaActClientTypes.Call: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Call(callId: \(Swift.String(describing: callId)), name: \(Swift.String(describing: name)), input: \"CONTENT_REDACTED\")"}
}

public struct InvokeActStepOutput: Swift.Sendable {
    /// A list of tool calls that the act wants to execute in this step.
    /// This member is required.
    public var calls: [NovaActClientTypes.Call]?
    /// The unique identifier for this execution step.
    /// This member is required.
    public var stepId: Swift.String?

    public init(
        calls: [NovaActClientTypes.Call]? = nil,
        stepId: Swift.String? = nil
    ) {
        self.calls = calls
        self.stepId = stepId
    }
}

extension NovaActClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "Ascending"
            case .desc: return "Descending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListActsInput: Swift.Sendable {
    /// The maximum number of acts to return in a single response.
    public var maxResults: Swift.Int?
    /// The token for retrieving the next page of results.
    public var nextToken: Swift.String?
    /// The unique identifier of the session to list acts for.
    public var sessionId: Swift.String?
    /// The sort order for the returned acts (ascending or descending).
    public var sortOrder: NovaActClientTypes.SortOrder?
    /// The name of the workflow definition containing the session.
    /// This member is required.
    public var workflowDefinitionName: Swift.String?
    /// The unique identifier of the workflow run containing the session.
    public var workflowRunId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sortOrder: NovaActClientTypes.SortOrder? = nil,
        workflowDefinitionName: Swift.String? = nil,
        workflowRunId: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sessionId = sessionId
        self.sortOrder = sortOrder
        self.workflowDefinitionName = workflowDefinitionName
        self.workflowRunId = workflowRunId
    }
}

extension NovaActClientTypes {

    public enum TraceLocationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [TraceLocationType] {
            return [
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NovaActClientTypes {

    /// Information about where trace data is stored for debugging and monitoring.
    public struct TraceLocation: Swift.Sendable {
        /// The specific location where the trace data is stored.
        /// This member is required.
        public var location: Swift.String?
        /// The type of storage location for the trace data.
        /// This member is required.
        public var locationType: NovaActClientTypes.TraceLocationType?

        public init(
            location: Swift.String? = nil,
            locationType: NovaActClientTypes.TraceLocationType? = nil
        ) {
            self.location = location
            self.locationType = locationType
        }
    }
}

extension NovaActClientTypes {

    /// Summary information about an act, including its status and execution timing.
    public struct ActSummary: Swift.Sendable {
        /// The unique identifier of the act.
        /// This member is required.
        public var actId: Swift.String?
        /// The timestamp when the act completed execution, if applicable.
        public var endedAt: Foundation.Date?
        /// The unique identifier of the session containing this act.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The timestamp when the act started execution.
        /// This member is required.
        public var startedAt: Foundation.Date?
        /// The current execution status of the act.
        /// This member is required.
        public var status: NovaActClientTypes.ActStatus?
        /// The location where trace information for this act is stored.
        public var traceLocation: NovaActClientTypes.TraceLocation?
        /// The unique identifier of the workflow run containing this act.
        /// This member is required.
        public var workflowRunId: Swift.String?

        public init(
            actId: Swift.String? = nil,
            endedAt: Foundation.Date? = nil,
            sessionId: Swift.String? = nil,
            startedAt: Foundation.Date? = nil,
            status: NovaActClientTypes.ActStatus? = nil,
            traceLocation: NovaActClientTypes.TraceLocation? = nil,
            workflowRunId: Swift.String? = nil
        ) {
            self.actId = actId
            self.endedAt = endedAt
            self.sessionId = sessionId
            self.startedAt = startedAt
            self.status = status
            self.traceLocation = traceLocation
            self.workflowRunId = workflowRunId
        }
    }
}

public struct ListActsOutput: Swift.Sendable {
    /// A list of summary information for acts in the session.
    /// This member is required.
    public var actSummaries: [NovaActClientTypes.ActSummary]?
    /// The token for retrieving the next page of results, if available.
    public var nextToken: Swift.String?

    public init(
        actSummaries: [NovaActClientTypes.ActSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.actSummaries = actSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateActInput: Swift.Sendable {
    /// The unique identifier of the act to update.
    /// This member is required.
    public var actId: Swift.String?
    /// Error information to associate with the act, if applicable.
    public var error: NovaActClientTypes.ActError?
    /// The unique identifier of the session containing the act.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The new status to set for the act.
    /// This member is required.
    public var status: NovaActClientTypes.ActStatus?
    /// The name of the workflow definition containing the act.
    /// This member is required.
    public var workflowDefinitionName: Swift.String?
    /// The unique identifier of the workflow run containing the act.
    /// This member is required.
    public var workflowRunId: Swift.String?

    public init(
        actId: Swift.String? = nil,
        error: NovaActClientTypes.ActError? = nil,
        sessionId: Swift.String? = nil,
        status: NovaActClientTypes.ActStatus? = nil,
        workflowDefinitionName: Swift.String? = nil,
        workflowRunId: Swift.String? = nil
    ) {
        self.actId = actId
        self.error = error
        self.sessionId = sessionId
        self.status = status
        self.workflowDefinitionName = workflowDefinitionName
        self.workflowRunId = workflowRunId
    }
}

public struct UpdateActOutput: Swift.Sendable {

    public init() { }
}

public struct ListModelsInput: Swift.Sendable {
    /// The client compatibility version to filter models by compatibility.
    /// This member is required.
    public var clientCompatibilityVersion: Swift.Int?

    public init(
        clientCompatibilityVersion: Swift.Int? = nil
    ) {
        self.clientCompatibilityVersion = clientCompatibilityVersion
    }
}

extension NovaActClientTypes {

    /// Information about client compatibility and supported model versions.
    public struct CompatibilityInformation: Swift.Sendable {
        /// The client compatibility version that was requested.
        /// This member is required.
        public var clientCompatibilityVersion: Swift.Int?
        /// Additional information about compatibility requirements or recommendations.
        public var message: Swift.String?
        /// A list of model IDs that are supported for the client compatibility version.
        /// This member is required.
        public var supportedModelIds: [Swift.String]?

        public init(
            clientCompatibilityVersion: Swift.Int? = nil,
            message: Swift.String? = nil,
            supportedModelIds: [Swift.String]? = nil
        ) {
            self.clientCompatibilityVersion = clientCompatibilityVersion
            self.message = message
            self.supportedModelIds = supportedModelIds
        }
    }
}

extension NovaActClientTypes {

    /// An alias that provides a stable reference to a model version.
    public struct ModelAlias: Swift.Sendable {
        /// The name of the model alias.
        /// This member is required.
        public var aliasName: Swift.String?
        /// The model ID that this alias currently points to.
        /// This member is required.
        public var latestModelId: Swift.String?
        /// The resolved model ID after alias resolution.
        public var resolvedModelId: Swift.String?

        public init(
            aliasName: Swift.String? = nil,
            latestModelId: Swift.String? = nil,
            resolvedModelId: Swift.String? = nil
        ) {
            self.aliasName = aliasName
            self.latestModelId = latestModelId
            self.resolvedModelId = resolvedModelId
        }
    }
}

extension NovaActClientTypes {

    public enum ModelStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deprecated
        case legacy
        case preview
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelStatus] {
            return [
                .active,
                .deprecated,
                .legacy,
                .preview
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deprecated: return "DEPRECATED"
            case .legacy: return "LEGACY"
            case .preview: return "PREVIEW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NovaActClientTypes {

    /// Lifecycle information for an AI model.
    public struct ModelLifecycle: Swift.Sendable {
        /// The current lifecycle status of the model.
        /// This member is required.
        public var status: NovaActClientTypes.ModelStatus?

        public init(
            status: NovaActClientTypes.ModelStatus? = nil
        ) {
            self.status = status
        }
    }
}

extension NovaActClientTypes {

    /// Summary information about an available AI model.
    public struct ModelSummary: Swift.Sendable {
        /// The minimum client compatibility version required to use this model.
        /// This member is required.
        public var minimumCompatibilityVersion: Swift.Int?
        /// The unique identifier of the model.
        /// This member is required.
        public var modelId: Swift.String?
        /// The lifecycle information for the model.
        /// This member is required.
        public var modelLifecycle: NovaActClientTypes.ModelLifecycle?

        public init(
            minimumCompatibilityVersion: Swift.Int? = nil,
            modelId: Swift.String? = nil,
            modelLifecycle: NovaActClientTypes.ModelLifecycle? = nil
        ) {
            self.minimumCompatibilityVersion = minimumCompatibilityVersion
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
        }
    }
}

public struct ListModelsOutput: Swift.Sendable {
    /// Information about client compatibility and supported models.
    /// This member is required.
    public var compatibilityInformation: NovaActClientTypes.CompatibilityInformation?
    /// A list of model aliases that provide stable references to model versions.
    /// This member is required.
    public var modelAliases: [NovaActClientTypes.ModelAlias]?
    /// A list of available AI models with their status and compatibility information.
    /// This member is required.
    public var modelSummaries: [NovaActClientTypes.ModelSummary]?

    public init(
        compatibilityInformation: NovaActClientTypes.CompatibilityInformation? = nil,
        modelAliases: [NovaActClientTypes.ModelAlias]? = nil,
        modelSummaries: [NovaActClientTypes.ModelSummary]? = nil
    ) {
        self.compatibilityInformation = compatibilityInformation
        self.modelAliases = modelAliases
        self.modelSummaries = modelSummaries
    }
}

public struct CreateSessionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the workflow definition containing the workflow run.
    /// This member is required.
    public var workflowDefinitionName: Swift.String?
    /// The unique identifier of the workflow run to create the session in.
    /// This member is required.
    public var workflowRunId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        workflowDefinitionName: Swift.String? = nil,
        workflowRunId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.workflowDefinitionName = workflowDefinitionName
        self.workflowRunId = workflowRunId
    }
}

public struct CreateSessionOutput: Swift.Sendable {
    /// The unique identifier for the created session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    ) {
        self.sessionId = sessionId
    }
}

public struct ListSessionsInput: Swift.Sendable {
    /// The maximum number of sessions to return in a single response.
    public var maxResults: Swift.Int?
    /// The token for retrieving the next page of results.
    public var nextToken: Swift.String?
    /// The sort order for the returned sessions (ascending or descending).
    public var sortOrder: NovaActClientTypes.SortOrder?
    /// The name of the workflow definition containing the workflow run.
    /// This member is required.
    public var workflowDefinitionName: Swift.String?
    /// The unique identifier of the workflow run to list sessions for.
    /// This member is required.
    public var workflowRunId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortOrder: NovaActClientTypes.SortOrder? = nil,
        workflowDefinitionName: Swift.String? = nil,
        workflowRunId: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
        self.workflowDefinitionName = workflowDefinitionName
        self.workflowRunId = workflowRunId
    }
}

extension NovaActClientTypes {

    /// Summary information about a session within a workflow run.
    public struct SessionSummary: Swift.Sendable {
        /// The unique identifier of the session.
        /// This member is required.
        public var sessionId: Swift.String?

        public init(
            sessionId: Swift.String? = nil
        ) {
            self.sessionId = sessionId
        }
    }
}

public struct ListSessionsOutput: Swift.Sendable {
    /// The token for retrieving the next page of results, if available.
    public var nextToken: Swift.String?
    /// A list of summary information for sessions in the workflow run.
    /// This member is required.
    public var sessionSummaries: [NovaActClientTypes.SessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessionSummaries: [NovaActClientTypes.SessionSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.sessionSummaries = sessionSummaries
    }
}

extension NovaActClientTypes {

    /// Configuration settings for exporting workflow execution data and logs to Amazon Simple Storage Service (Amazon S3).
    public struct WorkflowExportConfig: Swift.Sendable {
        /// The name of your Amazon S3 bucket, that Nova Act uses to export your workflow data. Note that the IAM role used to access Nova Act must also have write permissions to this bucket.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// An optional prefix for Amazon S3 object keys to organize exported data.
        public var s3KeyPrefix: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil
        ) {
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }
    }
}

public struct CreateWorkflowDefinitionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// An optional description of the workflow definition's purpose and functionality.
    public var description: Swift.String?
    /// Configuration for exporting workflow execution data to Amazon Simple Storage Service.
    public var exportConfig: NovaActClientTypes.WorkflowExportConfig?
    /// The name of the workflow definition. Must be unique within your account and region.
    /// This member is required.
    public var name: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        exportConfig: NovaActClientTypes.WorkflowExportConfig? = nil,
        name: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.exportConfig = exportConfig
        self.name = name
    }
}

extension CreateWorkflowDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkflowDefinitionInput(clientToken: \(Swift.String(describing: clientToken)), exportConfig: \(Swift.String(describing: exportConfig)), name: \(Swift.String(describing: name)), description: \"CONTENT_REDACTED\")"}
}

extension NovaActClientTypes {

    public enum WorkflowDefinitionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowDefinitionStatus] {
            return [
                .active,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateWorkflowDefinitionOutput: Swift.Sendable {
    /// The current status of the workflow definition after creation.
    /// This member is required.
    public var status: NovaActClientTypes.WorkflowDefinitionStatus?

    public init(
        status: NovaActClientTypes.WorkflowDefinitionStatus? = nil
    ) {
        self.status = status
    }
}

public struct DeleteWorkflowDefinitionInput: Swift.Sendable {
    /// The name of the workflow definition to delete.
    /// This member is required.
    public var workflowDefinitionName: Swift.String?

    public init(
        workflowDefinitionName: Swift.String? = nil
    ) {
        self.workflowDefinitionName = workflowDefinitionName
    }
}

public struct DeleteWorkflowDefinitionOutput: Swift.Sendable {
    /// The status of the workflow definition after deletion request.
    /// This member is required.
    public var status: NovaActClientTypes.WorkflowDefinitionStatus?

    public init(
        status: NovaActClientTypes.WorkflowDefinitionStatus? = nil
    ) {
        self.status = status
    }
}

public struct GetWorkflowDefinitionInput: Swift.Sendable {
    /// The name of the workflow definition to retrieve.
    /// This member is required.
    public var workflowDefinitionName: Swift.String?

    public init(
        workflowDefinitionName: Swift.String? = nil
    ) {
        self.workflowDefinitionName = workflowDefinitionName
    }
}

public struct GetWorkflowDefinitionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the workflow definition.
    /// This member is required.
    public var arn: Swift.String?
    /// The timestamp when the workflow definition was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the workflow definition.
    public var description: Swift.String?
    /// The export configuration for the workflow definition.
    public var exportConfig: NovaActClientTypes.WorkflowExportConfig?
    /// The name of the workflow definition.
    /// This member is required.
    public var name: Swift.String?
    /// The current status of the workflow definition.
    /// This member is required.
    public var status: NovaActClientTypes.WorkflowDefinitionStatus?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        exportConfig: NovaActClientTypes.WorkflowExportConfig? = nil,
        name: Swift.String? = nil,
        status: NovaActClientTypes.WorkflowDefinitionStatus? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.exportConfig = exportConfig
        self.name = name
        self.status = status
    }
}

extension GetWorkflowDefinitionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkflowDefinitionOutput(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), exportConfig: \(Swift.String(describing: exportConfig)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\")"}
}

public struct ListWorkflowDefinitionsInput: Swift.Sendable {
    /// The maximum number of workflow definitions to return in a single response.
    public var maxResults: Swift.Int?
    /// The token for retrieving the next page of results.
    public var nextToken: Swift.String?
    /// The sort order for the returned workflow definitions (ascending or descending).
    public var sortOrder: NovaActClientTypes.SortOrder?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortOrder: NovaActClientTypes.SortOrder? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

extension NovaActClientTypes {

    /// Summary information about a workflow definition, used in list operations.
    public struct WorkflowDefinitionSummary: Swift.Sendable {
        /// The timestamp when the workflow definition was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The current status of the workflow definition.
        /// This member is required.
        public var status: NovaActClientTypes.WorkflowDefinitionStatus?
        /// The Amazon Resource Name (ARN) of the workflow definition.
        /// This member is required.
        public var workflowDefinitionArn: Swift.String?
        /// The name of the workflow definition.
        /// This member is required.
        public var workflowDefinitionName: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            status: NovaActClientTypes.WorkflowDefinitionStatus? = nil,
            workflowDefinitionArn: Swift.String? = nil,
            workflowDefinitionName: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.status = status
            self.workflowDefinitionArn = workflowDefinitionArn
            self.workflowDefinitionName = workflowDefinitionName
        }
    }
}

public struct ListWorkflowDefinitionsOutput: Swift.Sendable {
    /// The token for retrieving the next page of results, if available.
    public var nextToken: Swift.String?
    /// A list of summary information for workflow definitions.
    /// This member is required.
    public var workflowDefinitionSummaries: [NovaActClientTypes.WorkflowDefinitionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflowDefinitionSummaries: [NovaActClientTypes.WorkflowDefinitionSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.workflowDefinitionSummaries = workflowDefinitionSummaries
    }
}

extension NovaActClientTypes {

    /// Information about the client making API requests, used for compatibility checking.
    public struct ClientInfo: Swift.Sendable {
        /// The compatibility version of the client, used to ensure API compatibility.
        /// This member is required.
        public var compatibilityVersion: Swift.Int?
        /// The version of the SDK being used by the client.
        public var sdkVersion: Swift.String?

        public init(
            compatibilityVersion: Swift.Int? = nil,
            sdkVersion: Swift.String? = nil
        ) {
            self.compatibilityVersion = compatibilityVersion
            self.sdkVersion = sdkVersion
        }
    }
}

public struct CreateWorkflowRunInput: Swift.Sendable {
    /// Information about the client making the request, including compatibility version and SDK version.
    /// This member is required.
    public var clientInfo: NovaActClientTypes.ClientInfo?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The CloudWatch log group name for storing workflow execution logs.
    public var logGroupName: Swift.String?
    /// The ID of the AI model to use for workflow execution.
    /// This member is required.
    public var modelId: Swift.String?
    /// The name of the workflow definition to execute.
    /// This member is required.
    public var workflowDefinitionName: Swift.String?

    public init(
        clientInfo: NovaActClientTypes.ClientInfo? = nil,
        clientToken: Swift.String? = nil,
        logGroupName: Swift.String? = nil,
        modelId: Swift.String? = nil,
        workflowDefinitionName: Swift.String? = nil
    ) {
        self.clientInfo = clientInfo
        self.clientToken = clientToken
        self.logGroupName = logGroupName
        self.modelId = modelId
        self.workflowDefinitionName = workflowDefinitionName
    }
}

extension NovaActClientTypes {

    public enum WorkflowRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleting
        case failed
        case running
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowRunStatus] {
            return [
                .deleting,
                .failed,
                .running,
                .succeeded,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateWorkflowRunOutput: Swift.Sendable {
    /// The initial status of the workflow run after creation.
    /// This member is required.
    public var status: NovaActClientTypes.WorkflowRunStatus?
    /// The unique identifier for the created workflow run.
    /// This member is required.
    public var workflowRunId: Swift.String?

    public init(
        status: NovaActClientTypes.WorkflowRunStatus? = nil,
        workflowRunId: Swift.String? = nil
    ) {
        self.status = status
        self.workflowRunId = workflowRunId
    }
}

public struct DeleteWorkflowRunInput: Swift.Sendable {
    /// The name of the workflow definition containing the workflow run.
    /// This member is required.
    public var workflowDefinitionName: Swift.String?
    /// The unique identifier of the workflow run to delete.
    /// This member is required.
    public var workflowRunId: Swift.String?

    public init(
        workflowDefinitionName: Swift.String? = nil,
        workflowRunId: Swift.String? = nil
    ) {
        self.workflowDefinitionName = workflowDefinitionName
        self.workflowRunId = workflowRunId
    }
}

public struct DeleteWorkflowRunOutput: Swift.Sendable {
    /// The status of the workflow run after deletion request.
    /// This member is required.
    public var status: NovaActClientTypes.WorkflowRunStatus?

    public init(
        status: NovaActClientTypes.WorkflowRunStatus? = nil
    ) {
        self.status = status
    }
}

public struct GetWorkflowRunInput: Swift.Sendable {
    /// The name of the workflow definition containing the workflow run.
    /// This member is required.
    public var workflowDefinitionName: Swift.String?
    /// The unique identifier of the workflow run to retrieve.
    /// This member is required.
    public var workflowRunId: Swift.String?

    public init(
        workflowDefinitionName: Swift.String? = nil,
        workflowRunId: Swift.String? = nil
    ) {
        self.workflowDefinitionName = workflowDefinitionName
        self.workflowRunId = workflowRunId
    }
}

public struct GetWorkflowRunOutput: Swift.Sendable {
    /// The timestamp when the workflow run completed execution, if applicable.
    public var endedAt: Foundation.Date?
    /// The CloudWatch log group name for this workflow run's logs.
    public var logGroupName: Swift.String?
    /// The ID of the AI model being used for this workflow run.
    /// This member is required.
    public var modelId: Swift.String?
    /// The timestamp when the workflow run started execution.
    /// This member is required.
    public var startedAt: Foundation.Date?
    /// The current execution status of the workflow run.
    /// This member is required.
    public var status: NovaActClientTypes.WorkflowRunStatus?
    /// The Amazon Resource Name (ARN) of the workflow run.
    /// This member is required.
    public var workflowRunArn: Swift.String?
    /// The unique identifier of the workflow run.
    /// This member is required.
    public var workflowRunId: Swift.String?

    public init(
        endedAt: Foundation.Date? = nil,
        logGroupName: Swift.String? = nil,
        modelId: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        status: NovaActClientTypes.WorkflowRunStatus? = nil,
        workflowRunArn: Swift.String? = nil,
        workflowRunId: Swift.String? = nil
    ) {
        self.endedAt = endedAt
        self.logGroupName = logGroupName
        self.modelId = modelId
        self.startedAt = startedAt
        self.status = status
        self.workflowRunArn = workflowRunArn
        self.workflowRunId = workflowRunId
    }
}

public struct ListWorkflowRunsInput: Swift.Sendable {
    /// The maximum number of workflow runs to return in a single response.
    public var maxResults: Swift.Int?
    /// The token for retrieving the next page of results.
    public var nextToken: Swift.String?
    /// The sort order for the returned workflow runs (ascending or descending).
    public var sortOrder: NovaActClientTypes.SortOrder?
    /// The name of the workflow definition to list workflow runs for.
    /// This member is required.
    public var workflowDefinitionName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortOrder: NovaActClientTypes.SortOrder? = nil,
        workflowDefinitionName: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
        self.workflowDefinitionName = workflowDefinitionName
    }
}

extension NovaActClientTypes {

    /// Summary information about a workflow run, including execution status and timing.
    public struct WorkflowRunSummary: Swift.Sendable {
        /// The timestamp when the workflow run completed execution, if applicable.
        public var endedAt: Foundation.Date?
        /// The timestamp when the workflow run started execution.
        /// This member is required.
        public var startedAt: Foundation.Date?
        /// The current execution status of the workflow run.
        /// This member is required.
        public var status: NovaActClientTypes.WorkflowRunStatus?
        /// The location where trace information for this workflow run is stored.
        public var traceLocation: NovaActClientTypes.TraceLocation?
        /// The Amazon Resource Name (ARN) of the workflow run.
        /// This member is required.
        public var workflowRunArn: Swift.String?
        /// The unique identifier of the workflow run.
        /// This member is required.
        public var workflowRunId: Swift.String?

        public init(
            endedAt: Foundation.Date? = nil,
            startedAt: Foundation.Date? = nil,
            status: NovaActClientTypes.WorkflowRunStatus? = nil,
            traceLocation: NovaActClientTypes.TraceLocation? = nil,
            workflowRunArn: Swift.String? = nil,
            workflowRunId: Swift.String? = nil
        ) {
            self.endedAt = endedAt
            self.startedAt = startedAt
            self.status = status
            self.traceLocation = traceLocation
            self.workflowRunArn = workflowRunArn
            self.workflowRunId = workflowRunId
        }
    }
}

public struct ListWorkflowRunsOutput: Swift.Sendable {
    /// The token for retrieving the next page of results, if available.
    public var nextToken: Swift.String?
    /// A list of summary information for workflow runs.
    /// This member is required.
    public var workflowRunSummaries: [NovaActClientTypes.WorkflowRunSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflowRunSummaries: [NovaActClientTypes.WorkflowRunSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.workflowRunSummaries = workflowRunSummaries
    }
}

public struct UpdateWorkflowRunInput: Swift.Sendable {
    /// The new status to set for the workflow run.
    /// This member is required.
    public var status: NovaActClientTypes.WorkflowRunStatus?
    /// The name of the workflow definition containing the workflow run.
    /// This member is required.
    public var workflowDefinitionName: Swift.String?
    /// The unique identifier of the workflow run to update.
    /// This member is required.
    public var workflowRunId: Swift.String?

    public init(
        status: NovaActClientTypes.WorkflowRunStatus? = nil,
        workflowDefinitionName: Swift.String? = nil,
        workflowRunId: Swift.String? = nil
    ) {
        self.status = status
        self.workflowDefinitionName = workflowDefinitionName
        self.workflowRunId = workflowRunId
    }
}

public struct UpdateWorkflowRunOutput: Swift.Sendable {

    public init() { }
}

extension CreateActInput {

    static func urlPathProvider(_ value: CreateActInput) -> Swift.String? {
        guard let workflowDefinitionName = value.workflowDefinitionName else {
            return nil
        }
        guard let workflowRunId = value.workflowRunId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/workflow-definitions/\(workflowDefinitionName.urlPercentEncoding())/workflow-runs/\(workflowRunId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/acts"
    }
}

extension CreateSessionInput {

    static func urlPathProvider(_ value: CreateSessionInput) -> Swift.String? {
        guard let workflowDefinitionName = value.workflowDefinitionName else {
            return nil
        }
        guard let workflowRunId = value.workflowRunId else {
            return nil
        }
        return "/workflow-definitions/\(workflowDefinitionName.urlPercentEncoding())/workflow-runs/\(workflowRunId.urlPercentEncoding())/sessions"
    }
}

extension CreateWorkflowDefinitionInput {

    static func urlPathProvider(_ value: CreateWorkflowDefinitionInput) -> Swift.String? {
        return "/workflow-definitions"
    }
}

extension CreateWorkflowRunInput {

    static func urlPathProvider(_ value: CreateWorkflowRunInput) -> Swift.String? {
        guard let workflowDefinitionName = value.workflowDefinitionName else {
            return nil
        }
        return "/workflow-definitions/\(workflowDefinitionName.urlPercentEncoding())/workflow-runs"
    }
}

extension DeleteWorkflowDefinitionInput {

    static func urlPathProvider(_ value: DeleteWorkflowDefinitionInput) -> Swift.String? {
        guard let workflowDefinitionName = value.workflowDefinitionName else {
            return nil
        }
        return "/workflow-definitions/\(workflowDefinitionName.urlPercentEncoding())"
    }
}

extension DeleteWorkflowRunInput {

    static func urlPathProvider(_ value: DeleteWorkflowRunInput) -> Swift.String? {
        guard let workflowDefinitionName = value.workflowDefinitionName else {
            return nil
        }
        guard let workflowRunId = value.workflowRunId else {
            return nil
        }
        return "/workflow-definitions/\(workflowDefinitionName.urlPercentEncoding())/workflow-runs/\(workflowRunId.urlPercentEncoding())"
    }
}

extension GetWorkflowDefinitionInput {

    static func urlPathProvider(_ value: GetWorkflowDefinitionInput) -> Swift.String? {
        guard let workflowDefinitionName = value.workflowDefinitionName else {
            return nil
        }
        return "/workflow-definitions/\(workflowDefinitionName.urlPercentEncoding())"
    }
}

extension GetWorkflowRunInput {

    static func urlPathProvider(_ value: GetWorkflowRunInput) -> Swift.String? {
        guard let workflowDefinitionName = value.workflowDefinitionName else {
            return nil
        }
        guard let workflowRunId = value.workflowRunId else {
            return nil
        }
        return "/workflow-definitions/\(workflowDefinitionName.urlPercentEncoding())/workflow-runs/\(workflowRunId.urlPercentEncoding())"
    }
}

extension InvokeActStepInput {

    static func urlPathProvider(_ value: InvokeActStepInput) -> Swift.String? {
        guard let workflowDefinitionName = value.workflowDefinitionName else {
            return nil
        }
        guard let workflowRunId = value.workflowRunId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        guard let actId = value.actId else {
            return nil
        }
        return "/workflow-definitions/\(workflowDefinitionName.urlPercentEncoding())/workflow-runs/\(workflowRunId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/acts/\(actId.urlPercentEncoding())/invoke-step"
    }
}

extension ListActsInput {

    static func urlPathProvider(_ value: ListActsInput) -> Swift.String? {
        guard let workflowDefinitionName = value.workflowDefinitionName else {
            return nil
        }
        return "/workflow-definitions/\(workflowDefinitionName.urlPercentEncoding())/acts"
    }
}

extension ListActsInput {

    static func queryItemProvider(_ value: ListActsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sessionId = value.sessionId {
            let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
            items.append(sessionIdQueryItem)
        }
        if let workflowRunId = value.workflowRunId {
            let workflowRunIdQueryItem = Smithy.URIQueryItem(name: "workflowRunId".urlPercentEncoding(), value: Swift.String(workflowRunId).urlPercentEncoding())
            items.append(workflowRunIdQueryItem)
        }
        return items
    }
}

extension ListModelsInput {

    static func urlPathProvider(_ value: ListModelsInput) -> Swift.String? {
        return "/models"
    }
}

extension ListModelsInput {

    static func queryItemProvider(_ value: ListModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let clientCompatibilityVersion = value.clientCompatibilityVersion else {
            let message = "Creating a URL Query Item failed. clientCompatibilityVersion is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let clientCompatibilityVersionQueryItem = Smithy.URIQueryItem(name: "clientCompatibilityVersion".urlPercentEncoding(), value: Swift.String(clientCompatibilityVersion).urlPercentEncoding())
        items.append(clientCompatibilityVersionQueryItem)
        return items
    }
}

extension ListSessionsInput {

    static func urlPathProvider(_ value: ListSessionsInput) -> Swift.String? {
        guard let workflowDefinitionName = value.workflowDefinitionName else {
            return nil
        }
        guard let workflowRunId = value.workflowRunId else {
            return nil
        }
        return "/workflow-definitions/\(workflowDefinitionName.urlPercentEncoding())/workflow-runs/\(workflowRunId.urlPercentEncoding())"
    }
}

extension ListSessionsInput {

    static func queryItemProvider(_ value: ListSessionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListWorkflowDefinitionsInput {

    static func urlPathProvider(_ value: ListWorkflowDefinitionsInput) -> Swift.String? {
        return "/workflow-definitions"
    }
}

extension ListWorkflowDefinitionsInput {

    static func queryItemProvider(_ value: ListWorkflowDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListWorkflowRunsInput {

    static func urlPathProvider(_ value: ListWorkflowRunsInput) -> Swift.String? {
        guard let workflowDefinitionName = value.workflowDefinitionName else {
            return nil
        }
        return "/workflow-definitions/\(workflowDefinitionName.urlPercentEncoding())/workflow-runs"
    }
}

extension ListWorkflowRunsInput {

    static func queryItemProvider(_ value: ListWorkflowRunsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension UpdateActInput {

    static func urlPathProvider(_ value: UpdateActInput) -> Swift.String? {
        guard let workflowDefinitionName = value.workflowDefinitionName else {
            return nil
        }
        guard let workflowRunId = value.workflowRunId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        guard let actId = value.actId else {
            return nil
        }
        return "/workflow-definitions/\(workflowDefinitionName.urlPercentEncoding())/workflow-runs/\(workflowRunId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/acts/\(actId.urlPercentEncoding())"
    }
}

extension UpdateWorkflowRunInput {

    static func urlPathProvider(_ value: UpdateWorkflowRunInput) -> Swift.String? {
        guard let workflowDefinitionName = value.workflowDefinitionName else {
            return nil
        }
        guard let workflowRunId = value.workflowRunId else {
            return nil
        }
        return "/workflow-definitions/\(workflowDefinitionName.urlPercentEncoding())/workflow-runs/\(workflowRunId.urlPercentEncoding())"
    }
}

extension CreateActInput {

    static func write(value: CreateActInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["task"].write(value.task)
        try writer["toolSpecs"].writeList(value.toolSpecs, memberWritingClosure: NovaActClientTypes.ToolSpec.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSessionInput {

    static func write(value: CreateSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension CreateWorkflowDefinitionInput {

    static func write(value: CreateWorkflowDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["exportConfig"].write(value.exportConfig, with: NovaActClientTypes.WorkflowExportConfig.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension CreateWorkflowRunInput {

    static func write(value: CreateWorkflowRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientInfo"].write(value.clientInfo, with: NovaActClientTypes.ClientInfo.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["logGroupName"].write(value.logGroupName)
        try writer["modelId"].write(value.modelId)
    }
}

extension InvokeActStepInput {

    static func write(value: InvokeActStepInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["callResults"].writeList(value.callResults, memberWritingClosure: NovaActClientTypes.CallResult.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["previousStepId"].write(value.previousStepId)
    }
}

extension ListActsInput {

    static func write(value: ListActsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension ListSessionsInput {

    static func write(value: ListSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension ListWorkflowDefinitionsInput {

    static func write(value: ListWorkflowDefinitionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension ListWorkflowRunsInput {

    static func write(value: ListWorkflowRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension UpdateActInput {

    static func write(value: UpdateActInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["error"].write(value.error, with: NovaActClientTypes.ActError.write(value:to:))
        try writer["status"].write(value.status)
    }
}

extension UpdateWorkflowRunInput {

    static func write(value: UpdateWorkflowRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }
}

extension CreateActOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateActOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateActOutput()
        value.actId = try reader["actId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSessionOutput()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateWorkflowDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkflowDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkflowDefinitionOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateWorkflowRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkflowRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkflowRunOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.workflowRunId = try reader["workflowRunId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteWorkflowDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkflowDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteWorkflowDefinitionOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteWorkflowRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkflowRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteWorkflowRunOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetWorkflowDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowDefinitionOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.exportConfig = try reader["exportConfig"].readIfPresent(with: NovaActClientTypes.WorkflowExportConfig.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetWorkflowRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowRunOutput()
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.logGroupName = try reader["logGroupName"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.workflowRunArn = try reader["workflowRunArn"].readIfPresent() ?? ""
        value.workflowRunId = try reader["workflowRunId"].readIfPresent() ?? ""
        return value
    }
}

extension InvokeActStepOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeActStepOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = InvokeActStepOutput()
        value.calls = try reader["calls"].readListIfPresent(memberReadingClosure: NovaActClientTypes.Call.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.stepId = try reader["stepId"].readIfPresent() ?? ""
        return value
    }
}

extension ListActsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListActsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListActsOutput()
        value.actSummaries = try reader["actSummaries"].readListIfPresent(memberReadingClosure: NovaActClientTypes.ActSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelsOutput()
        value.compatibilityInformation = try reader["compatibilityInformation"].readIfPresent(with: NovaActClientTypes.CompatibilityInformation.read(from:))
        value.modelAliases = try reader["modelAliases"].readListIfPresent(memberReadingClosure: NovaActClientTypes.ModelAlias.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.modelSummaries = try reader["modelSummaries"].readListIfPresent(memberReadingClosure: NovaActClientTypes.ModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSessionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sessionSummaries = try reader["sessionSummaries"].readListIfPresent(memberReadingClosure: NovaActClientTypes.SessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListWorkflowDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkflowDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkflowDefinitionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workflowDefinitionSummaries = try reader["workflowDefinitionSummaries"].readListIfPresent(memberReadingClosure: NovaActClientTypes.WorkflowDefinitionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListWorkflowRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkflowRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkflowRunsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workflowRunSummaries = try reader["workflowRunSummaries"].readListIfPresent(memberReadingClosure: NovaActClientTypes.WorkflowRunSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension UpdateActOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateActOutput {
        return UpdateActOutput()
    }
}

extension UpdateWorkflowRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkflowRunOutput {
        return UpdateWorkflowRunOutput()
    }
}

enum CreateActOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkflowDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkflowRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkflowDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkflowRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeActStepOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListActsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkflowDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkflowRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateActOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkflowRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: NovaActClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NovaActClientTypes.WorkflowExportConfig {

    static func write(value: NovaActClientTypes.WorkflowExportConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3BucketName"].write(value.s3BucketName)
        try writer["s3KeyPrefix"].write(value.s3KeyPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NovaActClientTypes.WorkflowExportConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NovaActClientTypes.WorkflowExportConfig()
        value.s3BucketName = try reader["s3BucketName"].readIfPresent() ?? ""
        value.s3KeyPrefix = try reader["s3KeyPrefix"].readIfPresent()
        return value
    }
}

extension NovaActClientTypes.Call {

    static func read(from reader: SmithyJSON.Reader) throws -> NovaActClientTypes.Call {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NovaActClientTypes.Call()
        value.callId = try reader["callId"].readIfPresent() ?? ""
        value.input = try reader["input"].readIfPresent() ?? [:]
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension NovaActClientTypes.ActSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NovaActClientTypes.ActSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NovaActClientTypes.ActSummary()
        value.workflowRunId = try reader["workflowRunId"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.actId = try reader["actId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.traceLocation = try reader["traceLocation"].readIfPresent(with: NovaActClientTypes.TraceLocation.read(from:))
        return value
    }
}

extension NovaActClientTypes.TraceLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> NovaActClientTypes.TraceLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NovaActClientTypes.TraceLocation()
        value.locationType = try reader["locationType"].readIfPresent() ?? .sdkUnknown("")
        value.location = try reader["location"].readIfPresent() ?? ""
        return value
    }
}

extension NovaActClientTypes.ModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NovaActClientTypes.ModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NovaActClientTypes.ModelSummary()
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.modelLifecycle = try reader["modelLifecycle"].readIfPresent(with: NovaActClientTypes.ModelLifecycle.read(from:))
        value.minimumCompatibilityVersion = try reader["minimumCompatibilityVersion"].readIfPresent() ?? 0
        return value
    }
}

extension NovaActClientTypes.ModelLifecycle {

    static func read(from reader: SmithyJSON.Reader) throws -> NovaActClientTypes.ModelLifecycle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NovaActClientTypes.ModelLifecycle()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension NovaActClientTypes.ModelAlias {

    static func read(from reader: SmithyJSON.Reader) throws -> NovaActClientTypes.ModelAlias {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NovaActClientTypes.ModelAlias()
        value.aliasName = try reader["aliasName"].readIfPresent() ?? ""
        value.latestModelId = try reader["latestModelId"].readIfPresent() ?? ""
        value.resolvedModelId = try reader["resolvedModelId"].readIfPresent()
        return value
    }
}

extension NovaActClientTypes.CompatibilityInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> NovaActClientTypes.CompatibilityInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NovaActClientTypes.CompatibilityInformation()
        value.clientCompatibilityVersion = try reader["clientCompatibilityVersion"].readIfPresent() ?? 0
        value.supportedModelIds = try reader["supportedModelIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension NovaActClientTypes.SessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NovaActClientTypes.SessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NovaActClientTypes.SessionSummary()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension NovaActClientTypes.WorkflowDefinitionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NovaActClientTypes.WorkflowDefinitionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NovaActClientTypes.WorkflowDefinitionSummary()
        value.workflowDefinitionArn = try reader["workflowDefinitionArn"].readIfPresent() ?? ""
        value.workflowDefinitionName = try reader["workflowDefinitionName"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension NovaActClientTypes.WorkflowRunSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NovaActClientTypes.WorkflowRunSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NovaActClientTypes.WorkflowRunSummary()
        value.workflowRunArn = try reader["workflowRunArn"].readIfPresent() ?? ""
        value.workflowRunId = try reader["workflowRunId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.traceLocation = try reader["traceLocation"].readIfPresent(with: NovaActClientTypes.TraceLocation.read(from:))
        return value
    }
}

extension NovaActClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> NovaActClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NovaActClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension NovaActClientTypes.ToolSpec {

    static func write(value: NovaActClientTypes.ToolSpec?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["inputSchema"].write(value.inputSchema, with: NovaActClientTypes.ToolInputSchema.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension NovaActClientTypes.ToolInputSchema {

    static func write(value: NovaActClientTypes.ToolInputSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .json(json):
                try writer["json"].write(json)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension NovaActClientTypes.ClientInfo {

    static func write(value: NovaActClientTypes.ClientInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["compatibilityVersion"].write(value.compatibilityVersion)
        try writer["sdkVersion"].write(value.sdkVersion)
    }
}

extension NovaActClientTypes.CallResult {

    static func write(value: NovaActClientTypes.CallResult?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["callId"].write(value.callId)
        try writer["content"].writeList(value.content, memberWritingClosure: NovaActClientTypes.CallResultContent.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension NovaActClientTypes.CallResultContent {

    static func write(value: NovaActClientTypes.CallResultContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension NovaActClientTypes.ActError {

    static func write(value: NovaActClientTypes.ActError?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["message"].write(value.message)
        try writer["type"].write(value.type)
    }
}

public enum NovaActClientTypes {}
