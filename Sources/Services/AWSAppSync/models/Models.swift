// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have access to perform this operation on this resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.AdditionalAuthenticationProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType
        case lambdaAuthorizerConfig
        case openIDConnectConfig
        case userPoolConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let lambdaAuthorizerConfig = self.lambdaAuthorizerConfig {
            try encodeContainer.encode(lambdaAuthorizerConfig, forKey: .lambdaAuthorizerConfig)
        }
        if let openIDConnectConfig = self.openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let userPoolConfig = self.userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.CognitoUserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let lambdaAuthorizerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaAuthorizerConfig.self, forKey: .lambdaAuthorizerConfig)
        lambdaAuthorizerConfig = lambdaAuthorizerConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an additional authentication provider.
    public struct AdditionalAuthenticationProvider: Swift.Equatable {
        /// The authentication type: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
        public var authenticationType: AppSyncClientTypes.AuthenticationType?
        /// Configuration for Lambda function authorization.
        public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
        /// The OIDC configuration.
        public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
        /// The Amazon Cognito user pool configuration.
        public var userPoolConfig: AppSyncClientTypes.CognitoUserPoolConfig?

        public init(
            authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
            lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
            openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
            userPoolConfig: AppSyncClientTypes.CognitoUserPoolConfig? = nil
        )
        {
            self.authenticationType = authenticationType
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.openIDConnectConfig = openIDConnectConfig
            self.userPoolConfig = userPoolConfig
        }
    }

}

extension AppSyncClientTypes.ApiAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId
        case associationStatus
        case deploymentDetail
        case domainName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = self.apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let associationStatus = self.associationStatus {
            try encodeContainer.encode(associationStatus.rawValue, forKey: .associationStatus)
        }
        if let deploymentDetail = self.deploymentDetail {
            try encodeContainer.encode(deploymentDetail, forKey: .deploymentDetail)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let associationStatusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let deploymentDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentDetail)
        deploymentDetail = deploymentDetailDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an ApiAssociation object.
    public struct ApiAssociation: Swift.Equatable {
        /// The API ID.
        public var apiId: Swift.String?
        /// Identifies the status of an association.
        ///
        /// * PROCESSING: The API association is being created. You cannot modify association requests during processing.
        ///
        /// * SUCCESS: The API association was successful. You can modify associations after success.
        ///
        /// * FAILED: The API association has failed. You can modify associations after failure.
        public var associationStatus: AppSyncClientTypes.AssociationStatus?
        /// Details about the last deployment status.
        public var deploymentDetail: Swift.String?
        /// The domain name.
        public var domainName: Swift.String?

        public init(
            apiId: Swift.String? = nil,
            associationStatus: AppSyncClientTypes.AssociationStatus? = nil,
            deploymentDetail: Swift.String? = nil,
            domainName: Swift.String? = nil
        )
        {
            self.apiId = apiId
            self.associationStatus = associationStatus
            self.deploymentDetail = deploymentDetail
            self.domainName = domainName
        }
    }

}

extension AppSyncClientTypes.ApiCache: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case atRestEncryptionEnabled
        case status
        case transitEncryptionEnabled
        case ttl
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCachingBehavior = self.apiCachingBehavior {
            try encodeContainer.encode(apiCachingBehavior.rawValue, forKey: .apiCachingBehavior)
        }
        if atRestEncryptionEnabled != false {
            try encodeContainer.encode(atRestEncryptionEnabled, forKey: .atRestEncryptionEnabled)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if transitEncryptionEnabled != false {
            try encodeContainer.encode(transitEncryptionEnabled, forKey: .transitEncryptionEnabled)
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ttl) ?? 0
        ttl = ttlDecoded
        let apiCachingBehaviorDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCachingBehavior.self, forKey: .apiCachingBehavior)
        apiCachingBehavior = apiCachingBehaviorDecoded
        let transitEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .transitEncryptionEnabled) ?? false
        transitEncryptionEnabled = transitEncryptionEnabledDecoded
        let atRestEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .atRestEncryptionEnabled) ?? false
        atRestEncryptionEnabled = atRestEncryptionEnabledDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCacheType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCacheStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppSyncClientTypes {
    /// The ApiCache object.
    public struct ApiCache: Swift.Equatable {
        /// Caching behavior.
        ///
        /// * FULL_REQUEST_CACHING: All requests are fully cached.
        ///
        /// * PER_RESOLVER_CACHING: Individual resolvers that you specify are cached.
        public var apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
        /// At-rest encryption flag for cache. You cannot update this setting after creation.
        public var atRestEncryptionEnabled: Swift.Bool
        /// The cache instance status.
        ///
        /// * AVAILABLE: The instance is available for use.
        ///
        /// * CREATING: The instance is currently creating.
        ///
        /// * DELETING: The instance is currently deleting.
        ///
        /// * MODIFYING: The instance is currently modifying.
        ///
        /// * FAILED: The instance has failed creation.
        public var status: AppSyncClientTypes.ApiCacheStatus?
        /// Transit encryption flag when connecting to cache. You cannot update this setting after creation.
        public var transitEncryptionEnabled: Swift.Bool
        /// TTL in seconds for cache entries. Valid values are 1â€“3,600 seconds.
        public var ttl: Swift.Int
        /// The cache instance type. Valid values are
        ///
        /// * SMALL
        ///
        /// * MEDIUM
        ///
        /// * LARGE
        ///
        /// * XLARGE
        ///
        /// * LARGE_2X
        ///
        /// * LARGE_4X
        ///
        /// * LARGE_8X (not available in all regions)
        ///
        /// * LARGE_12X
        ///
        ///
        /// Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used. The following legacy instance types are available, but their use is discouraged:
        ///
        /// * T2_SMALL: A t2.small instance type.
        ///
        /// * T2_MEDIUM: A t2.medium instance type.
        ///
        /// * R4_LARGE: A r4.large instance type.
        ///
        /// * R4_XLARGE: A r4.xlarge instance type.
        ///
        /// * R4_2XLARGE: A r4.2xlarge instance type.
        ///
        /// * R4_4XLARGE: A r4.4xlarge instance type.
        ///
        /// * R4_8XLARGE: A r4.8xlarge instance type.
        public var type: AppSyncClientTypes.ApiCacheType?

        public init(
            apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior? = nil,
            atRestEncryptionEnabled: Swift.Bool = false,
            status: AppSyncClientTypes.ApiCacheStatus? = nil,
            transitEncryptionEnabled: Swift.Bool = false,
            ttl: Swift.Int = 0,
            type: AppSyncClientTypes.ApiCacheType? = nil
        )
        {
            self.apiCachingBehavior = apiCachingBehavior
            self.atRestEncryptionEnabled = atRestEncryptionEnabled
            self.status = status
            self.transitEncryptionEnabled = transitEncryptionEnabled
            self.ttl = ttl
            self.type = type
        }
    }

}

extension AppSyncClientTypes {
    public enum ApiCacheStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case modifying
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiCacheStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .modifying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .modifying: return "MODIFYING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiCacheStatus(rawValue: rawValue) ?? ApiCacheStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum ApiCacheType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case large
        case large12x
        case large2x
        case large4x
        case large8x
        case medium
        case r42xlarge
        case r44xlarge
        case r48xlarge
        case r4Large
        case r4Xlarge
        case small
        case t2Medium
        case t2Small
        case xlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiCacheType] {
            return [
                .large,
                .large12x,
                .large2x,
                .large4x,
                .large8x,
                .medium,
                .r42xlarge,
                .r44xlarge,
                .r48xlarge,
                .r4Large,
                .r4Xlarge,
                .small,
                .t2Medium,
                .t2Small,
                .xlarge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .large: return "LARGE"
            case .large12x: return "LARGE_12X"
            case .large2x: return "LARGE_2X"
            case .large4x: return "LARGE_4X"
            case .large8x: return "LARGE_8X"
            case .medium: return "MEDIUM"
            case .r42xlarge: return "R4_2XLARGE"
            case .r44xlarge: return "R4_4XLARGE"
            case .r48xlarge: return "R4_8XLARGE"
            case .r4Large: return "R4_LARGE"
            case .r4Xlarge: return "R4_XLARGE"
            case .small: return "SMALL"
            case .t2Medium: return "T2_MEDIUM"
            case .t2Small: return "T2_SMALL"
            case .xlarge: return "XLARGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiCacheType(rawValue: rawValue) ?? ApiCacheType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum ApiCachingBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullRequestCaching
        case perResolverCaching
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiCachingBehavior] {
            return [
                .fullRequestCaching,
                .perResolverCaching,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullRequestCaching: return "FULL_REQUEST_CACHING"
            case .perResolverCaching: return "PER_RESOLVER_CACHING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiCachingBehavior(rawValue: rawValue) ?? ApiCachingBehavior.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.ApiKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletes
        case description
        case expires
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deletes != 0 {
            try encodeContainer.encode(deletes, forKey: .deletes)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if expires != 0 {
            try encodeContainer.encode(expires, forKey: .expires)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expiresDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expires) ?? 0
        expires = expiresDecoded
        let deletesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deletes) ?? 0
        deletes = deletesDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an API key. Customers invoke AppSync GraphQL API operations with API keys as an identity mechanism. There are two key versions: da1: We introduced this version at launch in November 2017. These keys always expire after 7 days. Amazon DynamoDB TTL manages key expiration. These keys ceased to be valid after February 21, 2018, and they should no longer be used.
    ///
    /// * ListApiKeys returns the expiration time in milliseconds.
    ///
    /// * CreateApiKey returns the expiration time in milliseconds.
    ///
    /// * UpdateApiKey is not available for this key version.
    ///
    /// * DeleteApiKey deletes the item from the table.
    ///
    /// * Expiration is stored in DynamoDB as milliseconds. This results in a bug where keys are not automatically deleted because DynamoDB expects the TTL to be stored in seconds. As a one-time action, we deleted these keys from the table on February 21, 2018.
    ///
    ///
    /// da2: We introduced this version in February 2018 when AppSync added support to extend key expiration.
    ///
    /// * ListApiKeys returns the expiration time and deletion time in seconds.
    ///
    /// * CreateApiKey returns the expiration time and deletion time in seconds and accepts a user-provided expiration time in seconds.
    ///
    /// * UpdateApiKey returns the expiration time and and deletion time in seconds and accepts a user-provided expiration time in seconds. Expired API keys are kept for 60 days after the expiration time. You can update the key expiration time as long as the key isn't deleted.
    ///
    /// * DeleteApiKey deletes the item from the table.
    ///
    /// * Expiration is stored in DynamoDB as seconds. After the expiration time, using the key to authenticate will fail. However, you can reinstate the key before deletion.
    ///
    /// * Deletion is stored in DynamoDB as seconds. The key is deleted after deletion time.
    public struct ApiKey: Swift.Equatable {
        /// The time after which the API key is deleted. The date is represented as seconds since the epoch, rounded down to the nearest hour.
        public var deletes: Swift.Int
        /// A description of the purpose of the API key.
        public var description: Swift.String?
        /// The time after which the API key expires. The date is represented as seconds since the epoch, rounded down to the nearest hour.
        public var expires: Swift.Int
        /// The API key ID.
        public var id: Swift.String?

        public init(
            deletes: Swift.Int = 0,
            description: Swift.String? = nil,
            expires: Swift.Int = 0,
            id: Swift.String? = nil
        )
        {
            self.deletes = deletes
            self.description = description
            self.expires = expires
            self.id = id
        }
    }

}

extension ApiKeyLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApiKeyLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The API key exceeded a limit. Try your request again.
public struct ApiKeyLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApiKeyLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ApiKeyLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApiKeyLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiKeyValidityOutOfBoundsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApiKeyValidityOutOfBoundsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The API key expiration must be set to a value between 1 and 365 days from creation (for CreateApiKey) or from update (for UpdateApiKey).
public struct ApiKeyValidityOutOfBoundsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApiKeyValidityOutOfBoundsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ApiKeyValidityOutOfBoundsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApiKeyValidityOutOfBoundsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApiLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The GraphQL API exceeded a limit. Try your request again.
public struct ApiLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApiLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ApiLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ApiLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.AppSyncRuntime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case runtimeVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let runtimeVersion = self.runtimeVersion {
            try encodeContainer.encode(runtimeVersion, forKey: .runtimeVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RuntimeName.self, forKey: .name)
        name = nameDecoded
        let runtimeVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeVersion)
        runtimeVersion = runtimeVersionDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
    public struct AppSyncRuntime: Swift.Equatable {
        /// The name of the runtime to use. Currently, the only allowed value is APPSYNC_JS.
        /// This member is required.
        public var name: AppSyncClientTypes.RuntimeName?
        /// The version of the runtime to use. Currently, the only allowed version is 1.0.0.
        /// This member is required.
        public var runtimeVersion: Swift.String?

        public init(
            name: AppSyncClientTypes.RuntimeName? = nil,
            runtimeVersion: Swift.String? = nil
        )
        {
            self.name = name
            self.runtimeVersion = runtimeVersion
        }
    }

}

extension AssociateApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = self.apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
    }
}

extension AssociateApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v1/domainnames/\(domainName.urlPercentEncoding())/apiassociation"
    }
}

public struct AssociateApiInput: Swift.Equatable {
    /// The API ID. Private APIs can not be associated with custom domains.
    /// This member is required.
    public var apiId: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.domainName = domainName
    }
}

struct AssociateApiInputBody: Swift.Equatable {
    let apiId: Swift.String?
}

extension AssociateApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
    }
}

extension AssociateApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiAssociation = output.apiAssociation
        } else {
            self.apiAssociation = nil
        }
    }
}

public struct AssociateApiOutput: Swift.Equatable {
    /// The ApiAssociation object.
    public var apiAssociation: AppSyncClientTypes.ApiAssociation?

    public init(
        apiAssociation: AppSyncClientTypes.ApiAssociation? = nil
    )
    {
        self.apiAssociation = apiAssociation
    }
}

struct AssociateApiOutputBody: Swift.Equatable {
    let apiAssociation: AppSyncClientTypes.ApiAssociation?
}

extension AssociateApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiAssociationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiAssociation.self, forKey: .apiAssociation)
        apiAssociation = apiAssociationDecoded
    }
}

enum AssociateApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateMergedGraphqlApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mergedApiIdentifier
        case sourceApiAssociationConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mergedApiIdentifier = self.mergedApiIdentifier {
            try encodeContainer.encode(mergedApiIdentifier, forKey: .mergedApiIdentifier)
        }
        if let sourceApiAssociationConfig = self.sourceApiAssociationConfig {
            try encodeContainer.encode(sourceApiAssociationConfig, forKey: .sourceApiAssociationConfig)
        }
    }
}

extension AssociateMergedGraphqlApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceApiIdentifier = sourceApiIdentifier else {
            return nil
        }
        return "/v1/sourceApis/\(sourceApiIdentifier.urlPercentEncoding())/mergedApiAssociations"
    }
}

public struct AssociateMergedGraphqlApiInput: Swift.Equatable {
    /// The description field.
    public var description: Swift.String?
    /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
    /// This member is required.
    public var mergedApiIdentifier: Swift.String?
    /// The SourceApiAssociationConfig object data.
    public var sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig?
    /// The identifier of the AppSync Source API. This is generated by the AppSync service. In most cases, source APIs (especially in your account) only require the API ID value or ARN of the source API. However, source APIs from other accounts (cross-account use cases) strictly require the full resource ARN of the source API.
    /// This member is required.
    public var sourceApiIdentifier: Swift.String?

    public init(
        description: Swift.String? = nil,
        mergedApiIdentifier: Swift.String? = nil,
        sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig? = nil,
        sourceApiIdentifier: Swift.String? = nil
    )
    {
        self.description = description
        self.mergedApiIdentifier = mergedApiIdentifier
        self.sourceApiAssociationConfig = sourceApiAssociationConfig
        self.sourceApiIdentifier = sourceApiIdentifier
    }
}

struct AssociateMergedGraphqlApiInputBody: Swift.Equatable {
    let mergedApiIdentifier: Swift.String?
    let description: Swift.String?
    let sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig?
}

extension AssociateMergedGraphqlApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mergedApiIdentifier
        case sourceApiAssociationConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergedApiIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergedApiIdentifier)
        mergedApiIdentifier = mergedApiIdentifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceApiAssociationConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SourceApiAssociationConfig.self, forKey: .sourceApiAssociationConfig)
        sourceApiAssociationConfig = sourceApiAssociationConfigDecoded
    }
}

extension AssociateMergedGraphqlApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateMergedGraphqlApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.sourceApiAssociation = output.sourceApiAssociation
        } else {
            self.sourceApiAssociation = nil
        }
    }
}

public struct AssociateMergedGraphqlApiOutput: Swift.Equatable {
    /// The SourceApiAssociation object data.
    public var sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation?

    public init(
        sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation? = nil
    )
    {
        self.sourceApiAssociation = sourceApiAssociation
    }
}

struct AssociateMergedGraphqlApiOutputBody: Swift.Equatable {
    let sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation?
}

extension AssociateMergedGraphqlApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceApiAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceApiAssociationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SourceApiAssociation.self, forKey: .sourceApiAssociation)
        sourceApiAssociation = sourceApiAssociationDecoded
    }
}

enum AssociateMergedGraphqlApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateSourceGraphqlApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case sourceApiAssociationConfig
        case sourceApiIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sourceApiAssociationConfig = self.sourceApiAssociationConfig {
            try encodeContainer.encode(sourceApiAssociationConfig, forKey: .sourceApiAssociationConfig)
        }
        if let sourceApiIdentifier = self.sourceApiIdentifier {
            try encodeContainer.encode(sourceApiIdentifier, forKey: .sourceApiIdentifier)
        }
    }
}

extension AssociateSourceGraphqlApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mergedApiIdentifier = mergedApiIdentifier else {
            return nil
        }
        return "/v1/mergedApis/\(mergedApiIdentifier.urlPercentEncoding())/sourceApiAssociations"
    }
}

public struct AssociateSourceGraphqlApiInput: Swift.Equatable {
    /// The description field.
    public var description: Swift.String?
    /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
    /// This member is required.
    public var mergedApiIdentifier: Swift.String?
    /// The SourceApiAssociationConfig object data.
    public var sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig?
    /// The identifier of the AppSync Source API. This is generated by the AppSync service. In most cases, source APIs (especially in your account) only require the API ID value or ARN of the source API. However, source APIs from other accounts (cross-account use cases) strictly require the full resource ARN of the source API.
    /// This member is required.
    public var sourceApiIdentifier: Swift.String?

    public init(
        description: Swift.String? = nil,
        mergedApiIdentifier: Swift.String? = nil,
        sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig? = nil,
        sourceApiIdentifier: Swift.String? = nil
    )
    {
        self.description = description
        self.mergedApiIdentifier = mergedApiIdentifier
        self.sourceApiAssociationConfig = sourceApiAssociationConfig
        self.sourceApiIdentifier = sourceApiIdentifier
    }
}

struct AssociateSourceGraphqlApiInputBody: Swift.Equatable {
    let sourceApiIdentifier: Swift.String?
    let description: Swift.String?
    let sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig?
}

extension AssociateSourceGraphqlApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case sourceApiAssociationConfig
        case sourceApiIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceApiIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceApiIdentifier)
        sourceApiIdentifier = sourceApiIdentifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceApiAssociationConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SourceApiAssociationConfig.self, forKey: .sourceApiAssociationConfig)
        sourceApiAssociationConfig = sourceApiAssociationConfigDecoded
    }
}

extension AssociateSourceGraphqlApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateSourceGraphqlApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.sourceApiAssociation = output.sourceApiAssociation
        } else {
            self.sourceApiAssociation = nil
        }
    }
}

public struct AssociateSourceGraphqlApiOutput: Swift.Equatable {
    /// The SourceApiAssociation object data.
    public var sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation?

    public init(
        sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation? = nil
    )
    {
        self.sourceApiAssociation = sourceApiAssociation
    }
}

struct AssociateSourceGraphqlApiOutputBody: Swift.Equatable {
    let sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation?
}

extension AssociateSourceGraphqlApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceApiAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceApiAssociationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SourceApiAssociation.self, forKey: .sourceApiAssociation)
        sourceApiAssociation = sourceApiAssociationDecoded
    }
}

enum AssociateSourceGraphqlApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppSyncClientTypes {
    public enum AssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case processing
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationStatus] {
            return [
                .failed,
                .processing,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .processing: return "PROCESSING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationStatus(rawValue: rawValue) ?? AssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum AuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonCognitoUserPools
        case apiKey
        case awsIam
        case awsLambda
        case openidConnect
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .amazonCognitoUserPools,
                .apiKey,
                .awsIam,
                .awsLambda,
                .openidConnect,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonCognitoUserPools: return "AMAZON_COGNITO_USER_POOLS"
            case .apiKey: return "API_KEY"
            case .awsIam: return "AWS_IAM"
            case .awsLambda: return "AWS_LAMBDA"
            case .openidConnect: return "OPENID_CONNECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationType(rawValue: rawValue) ?? AuthenticationType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.AuthorizationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationType
        case awsIamConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationType = self.authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let awsIamConfig = self.awsIamConfig {
            try encodeContainer.encode(awsIamConfig, forKey: .awsIamConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let awsIamConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AwsIamConfig.self, forKey: .awsIamConfig)
        awsIamConfig = awsIamConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// The authorization configuration in case the HTTP endpoint requires authorization.
    public struct AuthorizationConfig: Swift.Equatable {
        /// The authorization type that the HTTP endpoint requires.
        ///
        /// * AWS_IAM: The authorization type is Signature Version 4 (SigV4).
        /// This member is required.
        public var authorizationType: AppSyncClientTypes.AuthorizationType?
        /// The Identity and Access Management (IAM) settings.
        public var awsIamConfig: AppSyncClientTypes.AwsIamConfig?

        public init(
            authorizationType: AppSyncClientTypes.AuthorizationType? = nil,
            awsIamConfig: AppSyncClientTypes.AwsIamConfig? = nil
        )
        {
            self.authorizationType = authorizationType
            self.awsIamConfig = awsIamConfig
        }
    }

}

extension AppSyncClientTypes {
    public enum AuthorizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsIam
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationType] {
            return [
                .awsIam,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizationType(rawValue: rawValue) ?? AuthorizationType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.AwsIamConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingRegion
        case signingServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingRegion = self.signingRegion {
            try encodeContainer.encode(signingRegion, forKey: .signingRegion)
        }
        if let signingServiceName = self.signingServiceName {
            try encodeContainer.encode(signingServiceName, forKey: .signingServiceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingRegion)
        signingRegion = signingRegionDecoded
        let signingServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingServiceName)
        signingServiceName = signingServiceNameDecoded
    }
}

extension AppSyncClientTypes {
    /// The Identity and Access Management (IAM) configuration.
    public struct AwsIamConfig: Swift.Equatable {
        /// The signing Amazon Web Services Region for IAM authorization.
        public var signingRegion: Swift.String?
        /// The signing service name for IAM authorization.
        public var signingServiceName: Swift.String?

        public init(
            signingRegion: Swift.String? = nil,
            signingServiceName: Swift.String? = nil
        )
        {
            self.signingRegion = signingRegion
            self.signingServiceName = signingServiceName
        }
    }

}

extension AppSyncClientTypes.BadRequestDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeErrors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeErrors = codeErrors {
            var codeErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .codeErrors)
            for codeerror0 in codeErrors {
                try codeErrorsContainer.encode(codeerror0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeErrorsContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.CodeError?].self, forKey: .codeErrors)
        var codeErrorsDecoded0:[AppSyncClientTypes.CodeError]? = nil
        if let codeErrorsContainer = codeErrorsContainer {
            codeErrorsDecoded0 = [AppSyncClientTypes.CodeError]()
            for structure0 in codeErrorsContainer {
                if let structure0 = structure0 {
                    codeErrorsDecoded0?.append(structure0)
                }
            }
        }
        codeErrors = codeErrorsDecoded0
    }
}

extension AppSyncClientTypes {
    /// Provides further details for the reason behind the bad request. For reason type CODE_ERROR, the detail will contain a list of code errors.
    public struct BadRequestDetail: Swift.Equatable {
        /// Contains the list of errors in the request.
        public var codeErrors: [AppSyncClientTypes.CodeError]?

        public init(
            codeErrors: [AppSyncClientTypes.CodeError]? = nil
        )
        {
            self.codeErrors = codeErrors
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.detail = output.detail
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.detail = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is not well formed. For example, a value is invalid or a required field is missing. Check the field values, and then try again.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Provides further details for the reason behind the bad request. For reason type CODE_ERROR, the detail will contain a list of code errors.
        public internal(set) var detail: AppSyncClientTypes.BadRequestDetail? = nil
        public internal(set) var message: Swift.String? = nil
        /// Provides context for the cause of the bad request. The only supported value is CODE_ERROR.
        public internal(set) var reason: AppSyncClientTypes.BadRequestReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        detail: AppSyncClientTypes.BadRequestDetail? = nil,
        message: Swift.String? = nil,
        reason: AppSyncClientTypes.BadRequestReason? = nil
    )
    {
        self.properties.detail = detail
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: AppSyncClientTypes.BadRequestReason?
    let detail: AppSyncClientTypes.BadRequestDetail?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detail
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.BadRequestReason.self, forKey: .reason)
        reason = reasonDecoded
        let detailDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.BadRequestDetail.self, forKey: .detail)
        detail = detailDecoded
    }
}

extension AppSyncClientTypes {
    /// Provides context for the cause of the bad request. The only supported value is CODE_ERROR.
    public enum BadRequestReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case codeError
        case sdkUnknown(Swift.String)

        public static var allCases: [BadRequestReason] {
            return [
                .codeError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .codeError: return "CODE_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BadRequestReason(rawValue: rawValue) ?? BadRequestReason.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.CachingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingKeys
        case ttl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingKeys = cachingKeys {
            var cachingKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cachingKeys)
            for string0 in cachingKeys {
                try cachingKeysContainer.encode(string0)
            }
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ttl) ?? 0
        ttl = ttlDecoded
        let cachingKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cachingKeys)
        var cachingKeysDecoded0:[Swift.String]? = nil
        if let cachingKeysContainer = cachingKeysContainer {
            cachingKeysDecoded0 = [Swift.String]()
            for string0 in cachingKeysContainer {
                if let string0 = string0 {
                    cachingKeysDecoded0?.append(string0)
                }
            }
        }
        cachingKeys = cachingKeysDecoded0
    }
}

extension AppSyncClientTypes {
    /// The caching configuration for a resolver that has caching activated.
    public struct CachingConfig: Swift.Equatable {
        /// The caching keys for a resolver that has caching activated. Valid values are entries from the $context.arguments, $context.source, and $context.identity maps.
        public var cachingKeys: [Swift.String]?
        /// The TTL in seconds for a resolver that has caching activated. Valid values are 1â€“3,600 seconds.
        /// This member is required.
        public var ttl: Swift.Int

        public init(
            cachingKeys: [Swift.String]? = nil,
            ttl: Swift.Int = 0
        )
        {
            self.cachingKeys = cachingKeys
            self.ttl = ttl
        }
    }

}

extension AppSyncClientTypes.CodeError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorType
        case location
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorType = self.errorType {
            try encodeContainer.encode(errorType, forKey: .errorType)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorType)
        errorType = errorTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let locationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.CodeErrorLocation.self, forKey: .location)
        location = locationDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an AppSync error.
    public struct CodeError: Swift.Equatable {
        /// The type of code error. Examples include, but aren't limited to: LINT_ERROR, PARSER_ERROR.
        public var errorType: Swift.String?
        /// The line, column, and span location of the error in the code.
        public var location: AppSyncClientTypes.CodeErrorLocation?
        /// A user presentable error. Examples include, but aren't limited to: Parsing error: Unterminated string literal.
        public var value: Swift.String?

        public init(
            errorType: Swift.String? = nil,
            location: AppSyncClientTypes.CodeErrorLocation? = nil,
            value: Swift.String? = nil
        )
        {
            self.errorType = errorType
            self.location = location
            self.value = value
        }
    }

}

extension AppSyncClientTypes.CodeErrorLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column
        case line
        case span
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if column != 0 {
            try encodeContainer.encode(column, forKey: .column)
        }
        if line != 0 {
            try encodeContainer.encode(line, forKey: .line)
        }
        if span != 0 {
            try encodeContainer.encode(span, forKey: .span)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .line) ?? 0
        line = lineDecoded
        let columnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .column) ?? 0
        column = columnDecoded
        let spanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .span) ?? 0
        span = spanDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes the location of the error in a code sample.
    public struct CodeErrorLocation: Swift.Equatable {
        /// The column number in the code. Defaults to 0 if unknown.
        public var column: Swift.Int
        /// The line number in the code. Defaults to 0 if unknown.
        public var line: Swift.Int
        /// The span/length of the error. Defaults to -1 if unknown.
        public var span: Swift.Int

        public init(
            column: Swift.Int = 0,
            line: Swift.Int = 0,
            span: Swift.Int = 0
        )
        {
            self.column = column
            self.line = line
            self.span = span
        }
    }

}

extension AppSyncClientTypes.CognitoUserPoolConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIdClientRegex
        case awsRegion
        case userPoolId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIdClientRegex = self.appIdClientRegex {
            try encodeContainer.encode(appIdClientRegex, forKey: .appIdClientRegex)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let userPoolId = self.userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let appIdClientRegexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appIdClientRegex)
        appIdClientRegex = appIdClientRegexDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an Amazon Cognito user pool configuration.
    public struct CognitoUserPoolConfig: Swift.Equatable {
        /// A regular expression for validating the incoming Amazon Cognito user pool app client ID. If this value isn't set, no filtering is applied.
        public var appIdClientRegex: Swift.String?
        /// The Amazon Web Services Region in which the user pool was created.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The user pool ID.
        /// This member is required.
        public var userPoolId: Swift.String?

        public init(
            appIdClientRegex: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            userPoolId: Swift.String? = nil
        )
        {
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.userPoolId = userPoolId
        }
    }

}

extension ConcurrentModificationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Another modification is in progress at this time and it must complete before you can make your change.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes {
    public enum ConflictDetectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case version
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictDetectionType] {
            return [
                .none,
                .version,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .version: return "VERSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictDetectionType(rawValue: rawValue) ?? ConflictDetectionType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum ConflictHandlerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automerge
        case lambda
        case `none`
        case optimisticConcurrency
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictHandlerType] {
            return [
                .automerge,
                .lambda,
                .none,
                .optimisticConcurrency,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automerge: return "AUTOMERGE"
            case .lambda: return "LAMBDA"
            case .none: return "NONE"
            case .optimisticConcurrency: return "OPTIMISTIC_CONCURRENCY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictHandlerType(rawValue: rawValue) ?? ConflictHandlerType.sdkUnknown(rawValue)
        }
    }
}

extension CreateApiCacheInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case atRestEncryptionEnabled
        case transitEncryptionEnabled
        case ttl
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCachingBehavior = self.apiCachingBehavior {
            try encodeContainer.encode(apiCachingBehavior.rawValue, forKey: .apiCachingBehavior)
        }
        if let atRestEncryptionEnabled = self.atRestEncryptionEnabled {
            try encodeContainer.encode(atRestEncryptionEnabled, forKey: .atRestEncryptionEnabled)
        }
        if let transitEncryptionEnabled = self.transitEncryptionEnabled {
            try encodeContainer.encode(transitEncryptionEnabled, forKey: .transitEncryptionEnabled)
        }
        if let ttl = self.ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateApiCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches"
    }
}

/// Represents the input of a CreateApiCache operation.
public struct CreateApiCacheInput: Swift.Equatable {
    /// Caching behavior.
    ///
    /// * FULL_REQUEST_CACHING: All requests are fully cached.
    ///
    /// * PER_RESOLVER_CACHING: Individual resolvers that you specify are cached.
    /// This member is required.
    public var apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// At-rest encryption flag for cache. You cannot update this setting after creation.
    public var atRestEncryptionEnabled: Swift.Bool?
    /// Transit encryption flag when connecting to cache. You cannot update this setting after creation.
    public var transitEncryptionEnabled: Swift.Bool?
    /// TTL in seconds for cache entries. Valid values are 1â€“3,600 seconds.
    /// This member is required.
    public var ttl: Swift.Int?
    /// The cache instance type. Valid values are
    ///
    /// * SMALL
    ///
    /// * MEDIUM
    ///
    /// * LARGE
    ///
    /// * XLARGE
    ///
    /// * LARGE_2X
    ///
    /// * LARGE_4X
    ///
    /// * LARGE_8X (not available in all regions)
    ///
    /// * LARGE_12X
    ///
    ///
    /// Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used. The following legacy instance types are available, but their use is discouraged:
    ///
    /// * T2_SMALL: A t2.small instance type.
    ///
    /// * T2_MEDIUM: A t2.medium instance type.
    ///
    /// * R4_LARGE: A r4.large instance type.
    ///
    /// * R4_XLARGE: A r4.xlarge instance type.
    ///
    /// * R4_2XLARGE: A r4.2xlarge instance type.
    ///
    /// * R4_4XLARGE: A r4.4xlarge instance type.
    ///
    /// * R4_8XLARGE: A r4.8xlarge instance type.
    /// This member is required.
    public var type: AppSyncClientTypes.ApiCacheType?

    public init(
        apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior? = nil,
        apiId: Swift.String? = nil,
        atRestEncryptionEnabled: Swift.Bool? = nil,
        transitEncryptionEnabled: Swift.Bool? = nil,
        ttl: Swift.Int? = nil,
        type: AppSyncClientTypes.ApiCacheType? = nil
    )
    {
        self.apiCachingBehavior = apiCachingBehavior
        self.apiId = apiId
        self.atRestEncryptionEnabled = atRestEncryptionEnabled
        self.transitEncryptionEnabled = transitEncryptionEnabled
        self.ttl = ttl
        self.type = type
    }
}

struct CreateApiCacheInputBody: Swift.Equatable {
    let ttl: Swift.Int?
    let transitEncryptionEnabled: Swift.Bool?
    let atRestEncryptionEnabled: Swift.Bool?
    let apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
    let type: AppSyncClientTypes.ApiCacheType?
}

extension CreateApiCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case atRestEncryptionEnabled
        case transitEncryptionEnabled
        case ttl
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ttl)
        ttl = ttlDecoded
        let transitEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .transitEncryptionEnabled)
        transitEncryptionEnabled = transitEncryptionEnabledDecoded
        let atRestEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .atRestEncryptionEnabled)
        atRestEncryptionEnabled = atRestEncryptionEnabledDecoded
        let apiCachingBehaviorDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCachingBehavior.self, forKey: .apiCachingBehavior)
        apiCachingBehavior = apiCachingBehaviorDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCacheType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateApiCacheOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApiCacheOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiCache = output.apiCache
        } else {
            self.apiCache = nil
        }
    }
}

/// Represents the output of a CreateApiCache operation.
public struct CreateApiCacheOutput: Swift.Equatable {
    /// The ApiCache object.
    public var apiCache: AppSyncClientTypes.ApiCache?

    public init(
        apiCache: AppSyncClientTypes.ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

struct CreateApiCacheOutputBody: Swift.Equatable {
    let apiCache: AppSyncClientTypes.ApiCache?
}

extension CreateApiCacheOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCache
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCacheDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCache.self, forKey: .apiCache)
        apiCache = apiCacheDecoded
    }
}

enum CreateApiCacheOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateApiKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expires
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expires = self.expires {
            try encodeContainer.encode(expires, forKey: .expires)
        }
    }
}

extension CreateApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/apikeys"
    }
}

public struct CreateApiKeyInput: Swift.Equatable {
    /// The ID for your GraphQL API.
    /// This member is required.
    public var apiId: Swift.String?
    /// A description of the purpose of the API key.
    public var description: Swift.String?
    /// From the creation time, the time after which the API key expires. The date is represented as seconds since the epoch, rounded down to the nearest hour. The default value for this parameter is 7 days from creation time. For more information, see .
    public var expires: Swift.Int?

    public init(
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        expires: Swift.Int? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.expires = expires
    }
}

struct CreateApiKeyInputBody: Swift.Equatable {
    let description: Swift.String?
    let expires: Swift.Int?
}

extension CreateApiKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expires
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expiresDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expires)
        expires = expiresDecoded
    }
}

extension CreateApiKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApiKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiKey = output.apiKey
        } else {
            self.apiKey = nil
        }
    }
}

public struct CreateApiKeyOutput: Swift.Equatable {
    /// The API key.
    public var apiKey: AppSyncClientTypes.ApiKey?

    public init(
        apiKey: AppSyncClientTypes.ApiKey? = nil
    )
    {
        self.apiKey = apiKey
    }
}

struct CreateApiKeyOutputBody: Swift.Equatable {
    let apiKey: AppSyncClientTypes.ApiKey?
}

extension CreateApiKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiKey.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
    }
}

enum CreateApiKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApiKeyLimitExceededException": return try await ApiKeyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApiKeyValidityOutOfBoundsException": return try await ApiKeyValidityOutOfBoundsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case eventBridgeConfig
        case httpConfig
        case lambdaConfig
        case name
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dynamodbConfig = self.dynamodbConfig {
            try encodeContainer.encode(dynamodbConfig, forKey: .dynamodbConfig)
        }
        if let elasticsearchConfig = self.elasticsearchConfig {
            try encodeContainer.encode(elasticsearchConfig, forKey: .elasticsearchConfig)
        }
        if let eventBridgeConfig = self.eventBridgeConfig {
            try encodeContainer.encode(eventBridgeConfig, forKey: .eventBridgeConfig)
        }
        if let httpConfig = self.httpConfig {
            try encodeContainer.encode(httpConfig, forKey: .httpConfig)
        }
        if let lambdaConfig = self.lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openSearchServiceConfig = self.openSearchServiceConfig {
            try encodeContainer.encode(openSearchServiceConfig, forKey: .openSearchServiceConfig)
        }
        if let relationalDatabaseConfig = self.relationalDatabaseConfig {
            try encodeContainer.encode(relationalDatabaseConfig, forKey: .relationalDatabaseConfig)
        }
        if let serviceRoleArn = self.serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources"
    }
}

public struct CreateDataSourceInput: Swift.Equatable {
    /// The API ID for the GraphQL API for the DataSource.
    /// This member is required.
    public var apiId: Swift.String?
    /// A description of the DataSource.
    public var description: Swift.String?
    /// Amazon DynamoDB settings.
    public var dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
    /// Amazon OpenSearch Service settings. As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. For new data sources, use [CreateDataSourceRequest$openSearchServiceConfig] to create an OpenSearch data source.
    public var elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
    /// Amazon EventBridge settings.
    public var eventBridgeConfig: AppSyncClientTypes.EventBridgeDataSourceConfig?
    /// HTTP endpoint settings.
    public var httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
    /// Lambda settings.
    public var lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
    /// A user-supplied name for the DataSource.
    /// This member is required.
    public var name: Swift.String?
    /// Amazon OpenSearch Service settings.
    public var openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
    /// Relational database settings.
    public var relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
    /// The Identity and Access Management (IAM) service role Amazon Resource Name (ARN) for the data source. The system assumes this role when accessing the data source.
    public var serviceRoleArn: Swift.String?
    /// The type of the DataSource.
    /// This member is required.
    public var type: AppSyncClientTypes.DataSourceType?

    public init(
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig? = nil,
        elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig? = nil,
        eventBridgeConfig: AppSyncClientTypes.EventBridgeDataSourceConfig? = nil,
        httpConfig: AppSyncClientTypes.HttpDataSourceConfig? = nil,
        lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig? = nil,
        name: Swift.String? = nil,
        openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig? = nil,
        relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig? = nil,
        serviceRoleArn: Swift.String? = nil,
        type: AppSyncClientTypes.DataSourceType? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.dynamodbConfig = dynamodbConfig
        self.elasticsearchConfig = elasticsearchConfig
        self.eventBridgeConfig = eventBridgeConfig
        self.httpConfig = httpConfig
        self.lambdaConfig = lambdaConfig
        self.name = name
        self.openSearchServiceConfig = openSearchServiceConfig
        self.relationalDatabaseConfig = relationalDatabaseConfig
        self.serviceRoleArn = serviceRoleArn
        self.type = type
    }
}

struct CreateDataSourceInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let type: AppSyncClientTypes.DataSourceType?
    let serviceRoleArn: Swift.String?
    let dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
    let lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
    let elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
    let openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
    let httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
    let relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
    let eventBridgeConfig: AppSyncClientTypes.EventBridgeDataSourceConfig?
}

extension CreateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case eventBridgeConfig
        case httpConfig
        case lambdaConfig
        case name
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let dynamodbConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DynamodbDataSourceConfig.self, forKey: .dynamodbConfig)
        dynamodbConfig = dynamodbConfigDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaDataSourceConfig.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let elasticsearchConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ElasticsearchDataSourceConfig.self, forKey: .elasticsearchConfig)
        elasticsearchConfig = elasticsearchConfigDecoded
        let openSearchServiceConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenSearchServiceDataSourceConfig.self, forKey: .openSearchServiceConfig)
        openSearchServiceConfig = openSearchServiceConfigDecoded
        let httpConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.HttpDataSourceConfig.self, forKey: .httpConfig)
        httpConfig = httpConfigDecoded
        let relationalDatabaseConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RelationalDatabaseDataSourceConfig.self, forKey: .relationalDatabaseConfig)
        relationalDatabaseConfig = relationalDatabaseConfigDecoded
        let eventBridgeConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.EventBridgeDataSourceConfig.self, forKey: .eventBridgeConfig)
        eventBridgeConfig = eventBridgeConfigDecoded
    }
}

extension CreateDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct CreateDataSourceOutput: Swift.Equatable {
    /// The DataSource object.
    public var dataSource: AppSyncClientTypes.DataSource?

    public init(
        dataSource: AppSyncClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct CreateDataSourceOutputBody: Swift.Equatable {
    let dataSource: AppSyncClientTypes.DataSource?
}

extension CreateDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

enum CreateDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDomainNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case description
        case domainName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension CreateDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domainnames"
    }
}

public struct CreateDomainNameInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the certificate. This can be an Certificate Manager (ACM) certificate or an Identity and Access Management (IAM) server certificate.
    /// This member is required.
    public var certificateArn: Swift.String?
    /// A description of the DomainName.
    public var description: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        description: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.description = description
        self.domainName = domainName
    }
}

struct CreateDomainNameInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let certificateArn: Swift.String?
    let description: Swift.String?
}

extension CreateDomainNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case description
        case domainName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateDomainNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDomainNameOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainNameConfig = output.domainNameConfig
        } else {
            self.domainNameConfig = nil
        }
    }
}

public struct CreateDomainNameOutput: Swift.Equatable {
    /// The configuration for the DomainName.
    public var domainNameConfig: AppSyncClientTypes.DomainNameConfig?

    public init(
        domainNameConfig: AppSyncClientTypes.DomainNameConfig? = nil
    )
    {
        self.domainNameConfig = domainNameConfig
    }
}

struct CreateDomainNameOutputBody: Swift.Equatable {
    let domainNameConfig: AppSyncClientTypes.DomainNameConfig?
}

extension CreateDomainNameOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNameConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DomainNameConfig.self, forKey: .domainNameConfig)
        domainNameConfig = domainNameConfigDecoded
    }
}

enum CreateDomainNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFunctionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case dataSourceName
        case description
        case functionVersion
        case maxBatchSize
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case runtime
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let dataSourceName = self.dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = self.functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let maxBatchSize = self.maxBatchSize {
            try encodeContainer.encode(maxBatchSize, forKey: .maxBatchSize)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestMappingTemplate = self.requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = self.responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime, forKey: .runtime)
        }
        if let syncConfig = self.syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

extension CreateFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions"
    }
}

public struct CreateFunctionInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
    public var code: Swift.String?
    /// The FunctionDataSource name.
    /// This member is required.
    public var dataSourceName: Swift.String?
    /// The Function description.
    public var description: Swift.String?
    /// The version of the request mapping template. Currently, the supported value is 2018-05-29. Note that when using VTL and mapping templates, the functionVersion is required.
    public var functionVersion: Swift.String?
    /// The maximum batching size for a resolver.
    public var maxBatchSize: Swift.Int?
    /// The Function name. The function name does not have to be unique.
    /// This member is required.
    public var name: Swift.String?
    /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
    public var requestMappingTemplate: Swift.String?
    /// The Function response mapping template.
    public var responseMappingTemplate: Swift.String?
    /// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
    public var runtime: AppSyncClientTypes.AppSyncRuntime?
    /// Describes a Sync configuration for a resolver. Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.
    public var syncConfig: AppSyncClientTypes.SyncConfig?

    public init(
        apiId: Swift.String? = nil,
        code: Swift.String? = nil,
        dataSourceName: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        maxBatchSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        runtime: AppSyncClientTypes.AppSyncRuntime? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil
    )
    {
        self.apiId = apiId
        self.code = code
        self.dataSourceName = dataSourceName
        self.description = description
        self.functionVersion = functionVersion
        self.maxBatchSize = maxBatchSize
        self.name = name
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.runtime = runtime
        self.syncConfig = syncConfig
    }
}

struct CreateFunctionInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let dataSourceName: Swift.String?
    let requestMappingTemplate: Swift.String?
    let responseMappingTemplate: Swift.String?
    let functionVersion: Swift.String?
    let syncConfig: AppSyncClientTypes.SyncConfig?
    let maxBatchSize: Swift.Int?
    let runtime: AppSyncClientTypes.AppSyncRuntime?
    let code: Swift.String?
}

extension CreateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case dataSourceName
        case description
        case functionVersion
        case maxBatchSize
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case runtime
        case syncConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let maxBatchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBatchSize)
        maxBatchSize = maxBatchSizeDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AppSyncRuntime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension CreateFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFunctionOutputBody = try responseDecoder.decode(responseBody: data)
            self.functionConfiguration = output.functionConfiguration
        } else {
            self.functionConfiguration = nil
        }
    }
}

public struct CreateFunctionOutput: Swift.Equatable {
    /// The Function object.
    public var functionConfiguration: AppSyncClientTypes.FunctionConfiguration?

    public init(
        functionConfiguration: AppSyncClientTypes.FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

struct CreateFunctionOutputBody: Swift.Equatable {
    let functionConfiguration: AppSyncClientTypes.FunctionConfiguration?
}

extension CreateFunctionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
    }
}

enum CreateFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGraphqlApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case apiType
        case authenticationType
        case lambdaAuthorizerConfig
        case logConfig
        case mergedApiExecutionRoleArn
        case name
        case openIDConnectConfig
        case ownerContact
        case tags
        case userPoolConfig
        case visibility
        case xrayEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthenticationProviders = additionalAuthenticationProviders {
            var additionalAuthenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthenticationProviders)
            for additionalauthenticationprovider0 in additionalAuthenticationProviders {
                try additionalAuthenticationProvidersContainer.encode(additionalauthenticationprovider0)
            }
        }
        if let apiType = self.apiType {
            try encodeContainer.encode(apiType.rawValue, forKey: .apiType)
        }
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let lambdaAuthorizerConfig = self.lambdaAuthorizerConfig {
            try encodeContainer.encode(lambdaAuthorizerConfig, forKey: .lambdaAuthorizerConfig)
        }
        if let logConfig = self.logConfig {
            try encodeContainer.encode(logConfig, forKey: .logConfig)
        }
        if let mergedApiExecutionRoleArn = self.mergedApiExecutionRoleArn {
            try encodeContainer.encode(mergedApiExecutionRoleArn, forKey: .mergedApiExecutionRoleArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openIDConnectConfig = self.openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let ownerContact = self.ownerContact {
            try encodeContainer.encode(ownerContact, forKey: .ownerContact)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userPoolConfig = self.userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
        if let xrayEnabled = self.xrayEnabled {
            try encodeContainer.encode(xrayEnabled, forKey: .xrayEnabled)
        }
    }
}

extension CreateGraphqlApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/apis"
    }
}

public struct CreateGraphqlApiInput: Swift.Equatable {
    /// A list of additional authentication providers for the GraphqlApi API.
    public var additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
    /// The value that indicates whether the GraphQL API is a standard API (GRAPHQL) or merged API (MERGED).
    public var apiType: AppSyncClientTypes.GraphQLApiType?
    /// The authentication type: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
    /// This member is required.
    public var authenticationType: AppSyncClientTypes.AuthenticationType?
    /// Configuration for Lambda function authorization.
    public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
    /// The Amazon CloudWatch Logs configuration.
    public var logConfig: AppSyncClientTypes.LogConfig?
    /// The Identity and Access Management service role ARN for a merged API. The AppSync service assumes this role on behalf of the Merged API to validate access to source APIs at runtime and to prompt the AUTO_MERGE to update the merged API endpoint with the source API changes automatically.
    public var mergedApiExecutionRoleArn: Swift.String?
    /// A user-supplied name for the GraphqlApi.
    /// This member is required.
    public var name: Swift.String?
    /// The OIDC configuration.
    public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
    /// The owner contact information for an API resource. This field accepts any string input with a length of 0 - 256 characters.
    public var ownerContact: Swift.String?
    /// A TagMap object.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Cognito user pool configuration.
    public var userPoolConfig: AppSyncClientTypes.UserPoolConfig?
    /// Sets the value of the GraphQL API to public (GLOBAL) or private (PRIVATE). If no value is provided, the visibility will be set to GLOBAL by default. This value cannot be changed once the API has been created.
    public var visibility: AppSyncClientTypes.GraphQLApiVisibility?
    /// A flag indicating whether to use X-Ray tracing for the GraphqlApi.
    public var xrayEnabled: Swift.Bool?

    public init(
        additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil,
        apiType: AppSyncClientTypes.GraphQLApiType? = nil,
        authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
        lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
        logConfig: AppSyncClientTypes.LogConfig? = nil,
        mergedApiExecutionRoleArn: Swift.String? = nil,
        name: Swift.String? = nil,
        openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
        ownerContact: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userPoolConfig: AppSyncClientTypes.UserPoolConfig? = nil,
        visibility: AppSyncClientTypes.GraphQLApiVisibility? = nil,
        xrayEnabled: Swift.Bool? = nil
    )
    {
        self.additionalAuthenticationProviders = additionalAuthenticationProviders
        self.apiType = apiType
        self.authenticationType = authenticationType
        self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
        self.logConfig = logConfig
        self.mergedApiExecutionRoleArn = mergedApiExecutionRoleArn
        self.name = name
        self.openIDConnectConfig = openIDConnectConfig
        self.ownerContact = ownerContact
        self.tags = tags
        self.userPoolConfig = userPoolConfig
        self.visibility = visibility
        self.xrayEnabled = xrayEnabled
    }
}

struct CreateGraphqlApiInputBody: Swift.Equatable {
    let name: Swift.String?
    let logConfig: AppSyncClientTypes.LogConfig?
    let authenticationType: AppSyncClientTypes.AuthenticationType?
    let userPoolConfig: AppSyncClientTypes.UserPoolConfig?
    let openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
    let tags: [Swift.String:Swift.String]?
    let additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
    let xrayEnabled: Swift.Bool?
    let lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
    let visibility: AppSyncClientTypes.GraphQLApiVisibility?
    let apiType: AppSyncClientTypes.GraphQLApiType?
    let mergedApiExecutionRoleArn: Swift.String?
    let ownerContact: Swift.String?
}

extension CreateGraphqlApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case apiType
        case authenticationType
        case lambdaAuthorizerConfig
        case logConfig
        case mergedApiExecutionRoleArn
        case name
        case openIDConnectConfig
        case ownerContact
        case tags
        case userPoolConfig
        case visibility
        case xrayEnabled
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let logConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LogConfig.self, forKey: .logConfig)
        logConfig = logConfigDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.UserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let additionalAuthenticationProvidersContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.AdditionalAuthenticationProvider?].self, forKey: .additionalAuthenticationProviders)
        var additionalAuthenticationProvidersDecoded0:[AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil
        if let additionalAuthenticationProvidersContainer = additionalAuthenticationProvidersContainer {
            additionalAuthenticationProvidersDecoded0 = [AppSyncClientTypes.AdditionalAuthenticationProvider]()
            for structure0 in additionalAuthenticationProvidersContainer {
                if let structure0 = structure0 {
                    additionalAuthenticationProvidersDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthenticationProviders = additionalAuthenticationProvidersDecoded0
        let xrayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .xrayEnabled)
        xrayEnabled = xrayEnabledDecoded
        let lambdaAuthorizerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaAuthorizerConfig.self, forKey: .lambdaAuthorizerConfig)
        lambdaAuthorizerConfig = lambdaAuthorizerConfigDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.GraphQLApiVisibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let apiTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.GraphQLApiType.self, forKey: .apiType)
        apiType = apiTypeDecoded
        let mergedApiExecutionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergedApiExecutionRoleArn)
        mergedApiExecutionRoleArn = mergedApiExecutionRoleArnDecoded
        let ownerContactDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerContact)
        ownerContact = ownerContactDecoded
    }
}

extension CreateGraphqlApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGraphqlApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.graphqlApi = output.graphqlApi
        } else {
            self.graphqlApi = nil
        }
    }
}

public struct CreateGraphqlApiOutput: Swift.Equatable {
    /// The GraphqlApi.
    public var graphqlApi: AppSyncClientTypes.GraphqlApi?

    public init(
        graphqlApi: AppSyncClientTypes.GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

struct CreateGraphqlApiOutputBody: Swift.Equatable {
    let graphqlApi: AppSyncClientTypes.GraphqlApi?
}

extension CreateGraphqlApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphqlApi
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApiDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.GraphqlApi.self, forKey: .graphqlApi)
        graphqlApi = graphqlApiDecoded
    }
}

enum CreateGraphqlApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApiLimitExceededException": return try await ApiLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateResolverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case code
        case dataSourceName
        case fieldName
        case kind
        case maxBatchSize
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case runtime
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingConfig = self.cachingConfig {
            try encodeContainer.encode(cachingConfig, forKey: .cachingConfig)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let dataSourceName = self.dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let fieldName = self.fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let kind = self.kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let maxBatchSize = self.maxBatchSize {
            try encodeContainer.encode(maxBatchSize, forKey: .maxBatchSize)
        }
        if let pipelineConfig = self.pipelineConfig {
            try encodeContainer.encode(pipelineConfig, forKey: .pipelineConfig)
        }
        if let requestMappingTemplate = self.requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = self.responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime, forKey: .runtime)
        }
        if let syncConfig = self.syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

extension CreateResolverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers"
    }
}

public struct CreateResolverInput: Swift.Equatable {
    /// The ID for the GraphQL API for which the resolver is being created.
    /// This member is required.
    public var apiId: Swift.String?
    /// The caching configuration for the resolver.
    public var cachingConfig: AppSyncClientTypes.CachingConfig?
    /// The resolver code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
    public var code: Swift.String?
    /// The name of the data source for which the resolver is being created.
    public var dataSourceName: Swift.String?
    /// The name of the field to attach the resolver to.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The resolver type.
    ///
    /// * UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.
    ///
    /// * PIPELINE: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of Function objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.
    public var kind: AppSyncClientTypes.ResolverKind?
    /// The maximum batching size for a resolver.
    public var maxBatchSize: Swift.Int?
    /// The PipelineConfig.
    public var pipelineConfig: AppSyncClientTypes.PipelineConfig?
    /// The mapping template to use for requests. A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL). VTL request mapping templates are optional when using an Lambda data source. For all other data sources, VTL request and response mapping templates are required.
    public var requestMappingTemplate: Swift.String?
    /// The mapping template to use for responses from the data source.
    public var responseMappingTemplate: Swift.String?
    /// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
    public var runtime: AppSyncClientTypes.AppSyncRuntime?
    /// The SyncConfig for a resolver attached to a versioned data source.
    public var syncConfig: AppSyncClientTypes.SyncConfig?
    /// The name of the Type.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        cachingConfig: AppSyncClientTypes.CachingConfig? = nil,
        code: Swift.String? = nil,
        dataSourceName: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        kind: AppSyncClientTypes.ResolverKind? = nil,
        maxBatchSize: Swift.Int? = nil,
        pipelineConfig: AppSyncClientTypes.PipelineConfig? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        runtime: AppSyncClientTypes.AppSyncRuntime? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.cachingConfig = cachingConfig
        self.code = code
        self.dataSourceName = dataSourceName
        self.fieldName = fieldName
        self.kind = kind
        self.maxBatchSize = maxBatchSize
        self.pipelineConfig = pipelineConfig
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.runtime = runtime
        self.syncConfig = syncConfig
        self.typeName = typeName
    }
}

struct CreateResolverInputBody: Swift.Equatable {
    let fieldName: Swift.String?
    let dataSourceName: Swift.String?
    let requestMappingTemplate: Swift.String?
    let responseMappingTemplate: Swift.String?
    let kind: AppSyncClientTypes.ResolverKind?
    let pipelineConfig: AppSyncClientTypes.PipelineConfig?
    let syncConfig: AppSyncClientTypes.SyncConfig?
    let cachingConfig: AppSyncClientTypes.CachingConfig?
    let maxBatchSize: Swift.Int?
    let runtime: AppSyncClientTypes.AppSyncRuntime?
    let code: Swift.String?
}

extension CreateResolverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case code
        case dataSourceName
        case fieldName
        case kind
        case maxBatchSize
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case runtime
        case syncConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let kindDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ResolverKind.self, forKey: .kind)
        kind = kindDecoded
        let pipelineConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.PipelineConfig.self, forKey: .pipelineConfig)
        pipelineConfig = pipelineConfigDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let cachingConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.CachingConfig.self, forKey: .cachingConfig)
        cachingConfig = cachingConfigDecoded
        let maxBatchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBatchSize)
        maxBatchSize = maxBatchSizeDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AppSyncRuntime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension CreateResolverOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateResolverOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolver = output.resolver
        } else {
            self.resolver = nil
        }
    }
}

public struct CreateResolverOutput: Swift.Equatable {
    /// The Resolver object.
    public var resolver: AppSyncClientTypes.Resolver?

    public init(
        resolver: AppSyncClientTypes.Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

struct CreateResolverOutputBody: Swift.Equatable {
    let resolver: AppSyncClientTypes.Resolver?
}

extension CreateResolverOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolver
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.Resolver.self, forKey: .resolver)
        resolver = resolverDecoded
    }
}

enum CreateResolverOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case format
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
    }
}

extension CreateTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types"
    }
}

public struct CreateTypeInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type definition, in GraphQL Schema Definition Language (SDL) format. For more information, see the [GraphQL SDL documentation](http://graphql.org/learn/schema/).
    /// This member is required.
    public var definition: Swift.String?
    /// The type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?

    public init(
        apiId: Swift.String? = nil,
        definition: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
        self.format = format
    }
}

struct CreateTypeInputBody: Swift.Equatable {
    let definition: Swift.String?
    let format: AppSyncClientTypes.TypeDefinitionFormat?
}

extension CreateTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case format
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.TypeDefinitionFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension CreateTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.type = output.type
        } else {
            self.type = nil
        }
    }
}

public struct CreateTypeOutput: Swift.Equatable {
    /// The Type object.
    public var type: AppSyncClientTypes.ModelType?

    public init(
        type: AppSyncClientTypes.ModelType? = nil
    )
    {
        self.type = type
    }
}

struct CreateTypeOutputBody: Swift.Equatable {
    let type: AppSyncClientTypes.ModelType?
}

extension CreateTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

enum CreateTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppSyncClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceArn
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case eventBridgeConfig
        case httpConfig
        case lambdaConfig
        case name
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceArn = self.dataSourceArn {
            try encodeContainer.encode(dataSourceArn, forKey: .dataSourceArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dynamodbConfig = self.dynamodbConfig {
            try encodeContainer.encode(dynamodbConfig, forKey: .dynamodbConfig)
        }
        if let elasticsearchConfig = self.elasticsearchConfig {
            try encodeContainer.encode(elasticsearchConfig, forKey: .elasticsearchConfig)
        }
        if let eventBridgeConfig = self.eventBridgeConfig {
            try encodeContainer.encode(eventBridgeConfig, forKey: .eventBridgeConfig)
        }
        if let httpConfig = self.httpConfig {
            try encodeContainer.encode(httpConfig, forKey: .httpConfig)
        }
        if let lambdaConfig = self.lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openSearchServiceConfig = self.openSearchServiceConfig {
            try encodeContainer.encode(openSearchServiceConfig, forKey: .openSearchServiceConfig)
        }
        if let relationalDatabaseConfig = self.relationalDatabaseConfig {
            try encodeContainer.encode(relationalDatabaseConfig, forKey: .relationalDatabaseConfig)
        }
        if let serviceRoleArn = self.serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let dynamodbConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DynamodbDataSourceConfig.self, forKey: .dynamodbConfig)
        dynamodbConfig = dynamodbConfigDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaDataSourceConfig.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let elasticsearchConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ElasticsearchDataSourceConfig.self, forKey: .elasticsearchConfig)
        elasticsearchConfig = elasticsearchConfigDecoded
        let openSearchServiceConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenSearchServiceDataSourceConfig.self, forKey: .openSearchServiceConfig)
        openSearchServiceConfig = openSearchServiceConfigDecoded
        let httpConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.HttpDataSourceConfig.self, forKey: .httpConfig)
        httpConfig = httpConfigDecoded
        let relationalDatabaseConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RelationalDatabaseDataSourceConfig.self, forKey: .relationalDatabaseConfig)
        relationalDatabaseConfig = relationalDatabaseConfigDecoded
        let eventBridgeConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.EventBridgeDataSourceConfig.self, forKey: .eventBridgeConfig)
        eventBridgeConfig = eventBridgeConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a data source.
    public struct DataSource: Swift.Equatable {
        /// The data source Amazon Resource Name (ARN).
        public var dataSourceArn: Swift.String?
        /// The description of the data source.
        public var description: Swift.String?
        /// DynamoDB settings.
        public var dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
        /// Amazon OpenSearch Service settings.
        public var elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
        /// Amazon EventBridge settings.
        public var eventBridgeConfig: AppSyncClientTypes.EventBridgeDataSourceConfig?
        /// HTTP endpoint settings.
        public var httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
        /// Lambda settings.
        public var lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
        /// The name of the data source.
        public var name: Swift.String?
        /// Amazon OpenSearch Service settings.
        public var openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
        /// Relational database settings.
        public var relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
        /// The Identity and Access Management (IAM) service role Amazon Resource Name (ARN) for the data source. The system assumes this role when accessing the data source.
        public var serviceRoleArn: Swift.String?
        /// The type of the data source.
        ///
        /// * AWS_LAMBDA: The data source is an Lambda function.
        ///
        /// * AMAZON_DYNAMODB: The data source is an Amazon DynamoDB table.
        ///
        /// * AMAZON_ELASTICSEARCH: The data source is an Amazon OpenSearch Service domain.
        ///
        /// * AMAZON_OPENSEARCH_SERVICE: The data source is an Amazon OpenSearch Service domain.
        ///
        /// * AMAZON_EVENTBRIDGE: The data source is an Amazon EventBridge configuration.
        ///
        /// * NONE: There is no data source. Use this type when you want to invoke a GraphQL operation without connecting to a data source, such as when you're performing data transformation with resolvers or invoking a subscription from a mutation.
        ///
        /// * HTTP: The data source is an HTTP endpoint.
        ///
        /// * RELATIONAL_DATABASE: The data source is a relational database.
        public var type: AppSyncClientTypes.DataSourceType?

        public init(
            dataSourceArn: Swift.String? = nil,
            description: Swift.String? = nil,
            dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig? = nil,
            elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig? = nil,
            eventBridgeConfig: AppSyncClientTypes.EventBridgeDataSourceConfig? = nil,
            httpConfig: AppSyncClientTypes.HttpDataSourceConfig? = nil,
            lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig? = nil,
            name: Swift.String? = nil,
            openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig? = nil,
            relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig? = nil,
            serviceRoleArn: Swift.String? = nil,
            type: AppSyncClientTypes.DataSourceType? = nil
        )
        {
            self.dataSourceArn = dataSourceArn
            self.description = description
            self.dynamodbConfig = dynamodbConfig
            self.elasticsearchConfig = elasticsearchConfig
            self.eventBridgeConfig = eventBridgeConfig
            self.httpConfig = httpConfig
            self.lambdaConfig = lambdaConfig
            self.name = name
            self.openSearchServiceConfig = openSearchServiceConfig
            self.relationalDatabaseConfig = relationalDatabaseConfig
            self.serviceRoleArn = serviceRoleArn
            self.type = type
        }
    }

}

extension AppSyncClientTypes {
    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonDynamodb
        case amazonElasticsearch
        case amazonEventbridge
        case amazonOpensearchService
        case awsLambda
        case http
        case `none`
        case relationalDatabase
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .amazonDynamodb,
                .amazonElasticsearch,
                .amazonEventbridge,
                .amazonOpensearchService,
                .awsLambda,
                .http,
                .none,
                .relationalDatabase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonDynamodb: return "AMAZON_DYNAMODB"
            case .amazonElasticsearch: return "AMAZON_ELASTICSEARCH"
            case .amazonEventbridge: return "AMAZON_EVENTBRIDGE"
            case .amazonOpensearchService: return "AMAZON_OPENSEARCH_SERVICE"
            case .awsLambda: return "AWS_LAMBDA"
            case .http: return "HTTP"
            case .none: return "NONE"
            case .relationalDatabase: return "RELATIONAL_DATABASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum DefaultAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [DefaultAction] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DefaultAction(rawValue: rawValue) ?? DefaultAction.sdkUnknown(rawValue)
        }
    }
}

extension DeleteApiCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches"
    }
}

/// Represents the input of a DeleteApiCache operation.
public struct DeleteApiCacheInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct DeleteApiCacheInputBody: Swift.Equatable {
}

extension DeleteApiCacheInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApiCacheOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Represents the output of a DeleteApiCache operation.
public struct DeleteApiCacheOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApiCacheOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/apikeys/\(id.urlPercentEncoding())"
    }
}

public struct DeleteApiKeyInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The ID for the API key.
    /// This member is required.
    public var id: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.id = id
    }
}

struct DeleteApiKeyInputBody: Swift.Equatable {
}

extension DeleteApiKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApiKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApiKeyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApiKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources/\(name.urlPercentEncoding())"
    }
}

public struct DeleteDataSourceInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.name = name
    }
}

struct DeleteDataSourceInputBody: Swift.Equatable {
}

extension DeleteDataSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDataSourceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v1/domainnames/\(domainName.urlPercentEncoding())"
    }
}

public struct DeleteDomainNameInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DeleteDomainNameInputBody: Swift.Equatable {
}

extension DeleteDomainNameInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDomainNameOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDomainNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let functionId = functionId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())"
    }
}

public struct DeleteFunctionInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The Function ID.
    /// This member is required.
    public var functionId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        functionId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
    }
}

struct DeleteFunctionInputBody: Swift.Equatable {
}

extension DeleteFunctionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFunctionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGraphqlApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())"
    }
}

public struct DeleteGraphqlApiInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct DeleteGraphqlApiInputBody: Swift.Equatable {
}

extension DeleteGraphqlApiInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGraphqlApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGraphqlApiOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGraphqlApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResolverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        guard let fieldName = fieldName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers/\(fieldName.urlPercentEncoding())"
    }
}

public struct DeleteResolverInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The resolver field name.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The name of the resolver type.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.fieldName = fieldName
        self.typeName = typeName
    }
}

struct DeleteResolverInputBody: Swift.Equatable {
}

extension DeleteResolverInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResolverOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResolverOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResolverOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())"
    }
}

public struct DeleteTypeInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.typeName = typeName
    }
}

struct DeleteTypeInputBody: Swift.Equatable {
}

extension DeleteTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTypeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppSyncClientTypes.DeltaSyncConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseTableTTL
        case deltaSyncTableName
        case deltaSyncTableTTL
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if baseTableTTL != 0 {
            try encodeContainer.encode(baseTableTTL, forKey: .baseTableTTL)
        }
        if let deltaSyncTableName = self.deltaSyncTableName {
            try encodeContainer.encode(deltaSyncTableName, forKey: .deltaSyncTableName)
        }
        if deltaSyncTableTTL != 0 {
            try encodeContainer.encode(deltaSyncTableTTL, forKey: .deltaSyncTableTTL)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseTableTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseTableTTL) ?? 0
        baseTableTTL = baseTableTTLDecoded
        let deltaSyncTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deltaSyncTableName)
        deltaSyncTableName = deltaSyncTableNameDecoded
        let deltaSyncTableTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deltaSyncTableTTL) ?? 0
        deltaSyncTableTTL = deltaSyncTableTTLDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a Delta Sync configuration.
    public struct DeltaSyncConfig: Swift.Equatable {
        /// The number of minutes that an Item is stored in the data source.
        public var baseTableTTL: Swift.Int
        /// The Delta Sync table name.
        public var deltaSyncTableName: Swift.String?
        /// The number of minutes that a Delta Sync log entry is stored in the Delta Sync table.
        public var deltaSyncTableTTL: Swift.Int

        public init(
            baseTableTTL: Swift.Int = 0,
            deltaSyncTableName: Swift.String? = nil,
            deltaSyncTableTTL: Swift.Int = 0
        )
        {
            self.baseTableTTL = baseTableTTL
            self.deltaSyncTableName = deltaSyncTableName
            self.deltaSyncTableTTL = deltaSyncTableTTL
        }
    }

}

extension DisassociateApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v1/domainnames/\(domainName.urlPercentEncoding())/apiassociation"
    }
}

public struct DisassociateApiInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DisassociateApiInputBody: Swift.Equatable {
}

extension DisassociateApiInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateApiOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateMergedGraphqlApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceApiIdentifier = sourceApiIdentifier else {
            return nil
        }
        guard let associationId = associationId else {
            return nil
        }
        return "/v1/sourceApis/\(sourceApiIdentifier.urlPercentEncoding())/mergedApiAssociations/\(associationId.urlPercentEncoding())"
    }
}

public struct DisassociateMergedGraphqlApiInput: Swift.Equatable {
    /// The ID generated by the AppSync service for the source API association.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the AppSync Source API. This is generated by the AppSync service. In most cases, source APIs (especially in your account) only require the API ID value or ARN of the source API. However, source APIs from other accounts (cross-account use cases) strictly require the full resource ARN of the source API.
    /// This member is required.
    public var sourceApiIdentifier: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        sourceApiIdentifier: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.sourceApiIdentifier = sourceApiIdentifier
    }
}

struct DisassociateMergedGraphqlApiInputBody: Swift.Equatable {
}

extension DisassociateMergedGraphqlApiInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateMergedGraphqlApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateMergedGraphqlApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.sourceApiAssociationStatus = output.sourceApiAssociationStatus
        } else {
            self.sourceApiAssociationStatus = nil
        }
    }
}

public struct DisassociateMergedGraphqlApiOutput: Swift.Equatable {
    /// The state of the source API association.
    public var sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus?

    public init(
        sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus? = nil
    )
    {
        self.sourceApiAssociationStatus = sourceApiAssociationStatus
    }
}

struct DisassociateMergedGraphqlApiOutputBody: Swift.Equatable {
    let sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus?
}

extension DisassociateMergedGraphqlApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceApiAssociationStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceApiAssociationStatusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SourceApiAssociationStatus.self, forKey: .sourceApiAssociationStatus)
        sourceApiAssociationStatus = sourceApiAssociationStatusDecoded
    }
}

enum DisassociateMergedGraphqlApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateSourceGraphqlApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mergedApiIdentifier = mergedApiIdentifier else {
            return nil
        }
        guard let associationId = associationId else {
            return nil
        }
        return "/v1/mergedApis/\(mergedApiIdentifier.urlPercentEncoding())/sourceApiAssociations/\(associationId.urlPercentEncoding())"
    }
}

public struct DisassociateSourceGraphqlApiInput: Swift.Equatable {
    /// The ID generated by the AppSync service for the source API association.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
    /// This member is required.
    public var mergedApiIdentifier: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        mergedApiIdentifier: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.mergedApiIdentifier = mergedApiIdentifier
    }
}

struct DisassociateSourceGraphqlApiInputBody: Swift.Equatable {
}

extension DisassociateSourceGraphqlApiInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateSourceGraphqlApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateSourceGraphqlApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.sourceApiAssociationStatus = output.sourceApiAssociationStatus
        } else {
            self.sourceApiAssociationStatus = nil
        }
    }
}

public struct DisassociateSourceGraphqlApiOutput: Swift.Equatable {
    /// The state of the source API association.
    public var sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus?

    public init(
        sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus? = nil
    )
    {
        self.sourceApiAssociationStatus = sourceApiAssociationStatus
    }
}

struct DisassociateSourceGraphqlApiOutputBody: Swift.Equatable {
    let sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus?
}

extension DisassociateSourceGraphqlApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceApiAssociationStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceApiAssociationStatusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SourceApiAssociationStatus.self, forKey: .sourceApiAssociationStatus)
        sourceApiAssociationStatus = sourceApiAssociationStatusDecoded
    }
}

enum DisassociateSourceGraphqlApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppSyncClientTypes.DomainNameConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsyncDomainName
        case certificateArn
        case description
        case domainName
        case hostedZoneId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appsyncDomainName = self.appsyncDomainName {
            try encodeContainer.encode(appsyncDomainName, forKey: .appsyncDomainName)
        }
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let hostedZoneId = self.hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let appsyncDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appsyncDomainName)
        appsyncDomainName = appsyncDomainNameDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a configuration for a custom domain.
    public struct DomainNameConfig: Swift.Equatable {
        /// The domain name that AppSync provides.
        public var appsyncDomainName: Swift.String?
        /// The Amazon Resource Name (ARN) of the certificate. This can be an Certificate Manager (ACM) certificate or an Identity and Access Management (IAM) server certificate.
        public var certificateArn: Swift.String?
        /// A description of the DomainName configuration.
        public var description: Swift.String?
        /// The domain name.
        public var domainName: Swift.String?
        /// The ID of your Amazon Route 53 hosted zone.
        public var hostedZoneId: Swift.String?

        public init(
            appsyncDomainName: Swift.String? = nil,
            certificateArn: Swift.String? = nil,
            description: Swift.String? = nil,
            domainName: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil
        )
        {
            self.appsyncDomainName = appsyncDomainName
            self.certificateArn = certificateArn
            self.description = description
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }
    }

}

extension AppSyncClientTypes.DynamodbDataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion
        case deltaSyncConfig
        case tableName
        case useCallerCredentials
        case versioned
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let deltaSyncConfig = self.deltaSyncConfig {
            try encodeContainer.encode(deltaSyncConfig, forKey: .deltaSyncConfig)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if useCallerCredentials != false {
            try encodeContainer.encode(useCallerCredentials, forKey: .useCallerCredentials)
        }
        if versioned != false {
            try encodeContainer.encode(versioned, forKey: .versioned)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let useCallerCredentialsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useCallerCredentials) ?? false
        useCallerCredentials = useCallerCredentialsDecoded
        let deltaSyncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DeltaSyncConfig.self, forKey: .deltaSyncConfig)
        deltaSyncConfig = deltaSyncConfigDecoded
        let versionedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .versioned) ?? false
        versioned = versionedDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an Amazon DynamoDB data source configuration.
    public struct DynamodbDataSourceConfig: Swift.Equatable {
        /// The Amazon Web Services Region.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The DeltaSyncConfig for a versioned data source.
        public var deltaSyncConfig: AppSyncClientTypes.DeltaSyncConfig?
        /// The table name.
        /// This member is required.
        public var tableName: Swift.String?
        /// Set to TRUE to use Amazon Cognito credentials with this data source.
        public var useCallerCredentials: Swift.Bool
        /// Set to TRUE to use Conflict Detection and Resolution with this data source.
        public var versioned: Swift.Bool

        public init(
            awsRegion: Swift.String? = nil,
            deltaSyncConfig: AppSyncClientTypes.DeltaSyncConfig? = nil,
            tableName: Swift.String? = nil,
            useCallerCredentials: Swift.Bool = false,
            versioned: Swift.Bool = false
        )
        {
            self.awsRegion = awsRegion
            self.deltaSyncConfig = deltaSyncConfig
            self.tableName = tableName
            self.useCallerCredentials = useCallerCredentials
            self.versioned = versioned
        }
    }

}

extension AppSyncClientTypes.ElasticsearchDataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion
        case endpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an OpenSearch data source configuration. As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. For new data sources, use [OpenSearchServiceDataSourceConfig] to specify an OpenSearch data source.
    public struct ElasticsearchDataSourceConfig: Swift.Equatable {
        /// The Amazon Web Services Region.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The endpoint.
        /// This member is required.
        public var endpoint: Swift.String?

        public init(
            awsRegion: Swift.String? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.endpoint = endpoint
        }
    }

}

extension AppSyncClientTypes.ErrorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes {
    /// Contains the list of errors generated. When using JavaScript, this will apply to the request or response function evaluation.
    public struct ErrorDetail: Swift.Equatable {
        /// The error payload.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension AppSyncClientTypes.EvaluateCodeErrorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeErrors
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeErrors = codeErrors {
            var codeErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .codeErrors)
            for codeerror0 in codeErrors {
                try codeErrorsContainer.encode(codeerror0)
            }
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeErrorsContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.CodeError?].self, forKey: .codeErrors)
        var codeErrorsDecoded0:[AppSyncClientTypes.CodeError]? = nil
        if let codeErrorsContainer = codeErrorsContainer {
            codeErrorsDecoded0 = [AppSyncClientTypes.CodeError]()
            for structure0 in codeErrorsContainer {
                if let structure0 = structure0 {
                    codeErrorsDecoded0?.append(structure0)
                }
            }
        }
        codeErrors = codeErrorsDecoded0
    }
}

extension AppSyncClientTypes {
    /// Contains the list of errors from a code evaluation response.
    public struct EvaluateCodeErrorDetail: Swift.Equatable {
        /// Contains the list of CodeError objects.
        public var codeErrors: [AppSyncClientTypes.CodeError]?
        /// The error payload.
        public var message: Swift.String?

        public init(
            codeErrors: [AppSyncClientTypes.CodeError]? = nil,
            message: Swift.String? = nil
        )
        {
            self.codeErrors = codeErrors
            self.message = message
        }
    }

}

extension EvaluateCodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case function
        case runtime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let context = self.context {
            try encodeContainer.encode(context, forKey: .context)
        }
        if let function = self.function {
            try encodeContainer.encode(function, forKey: .function)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime, forKey: .runtime)
        }
    }
}

extension EvaluateCodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/dataplane-evaluatecode"
    }
}

public struct EvaluateCodeInput: Swift.Equatable {
    /// The code definition to be evaluated. Note that code and runtime are both required for this action. The runtime value must be APPSYNC_JS.
    /// This member is required.
    public var code: Swift.String?
    /// The map that holds all of the contextual information for your resolver invocation. A context is required for this action.
    /// This member is required.
    public var context: Swift.String?
    /// The function within the code to be evaluated. If provided, the valid values are request and response.
    public var function: Swift.String?
    /// The runtime to be used when evaluating the code. Currently, only the APPSYNC_JS runtime is supported.
    /// This member is required.
    public var runtime: AppSyncClientTypes.AppSyncRuntime?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        function: Swift.String? = nil,
        runtime: AppSyncClientTypes.AppSyncRuntime? = nil
    )
    {
        self.code = code
        self.context = context
        self.function = function
        self.runtime = runtime
    }
}

struct EvaluateCodeInputBody: Swift.Equatable {
    let runtime: AppSyncClientTypes.AppSyncRuntime?
    let code: Swift.String?
    let context: Swift.String?
    let function: Swift.String?
}

extension EvaluateCodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case function
        case runtime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AppSyncRuntime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
        let functionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .function)
        function = functionDecoded
    }
}

extension EvaluateCodeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EvaluateCodeOutputBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.evaluationResult = output.evaluationResult
            self.logs = output.logs
        } else {
            self.error = nil
            self.evaluationResult = nil
            self.logs = nil
        }
    }
}

public struct EvaluateCodeOutput: Swift.Equatable {
    /// Contains the payload of the response error.
    public var error: AppSyncClientTypes.EvaluateCodeErrorDetail?
    /// The result of the evaluation operation.
    public var evaluationResult: Swift.String?
    /// A list of logs that were generated by calls to util.log.info and util.log.error in the evaluated code.
    public var logs: [Swift.String]?

    public init(
        error: AppSyncClientTypes.EvaluateCodeErrorDetail? = nil,
        evaluationResult: Swift.String? = nil,
        logs: [Swift.String]? = nil
    )
    {
        self.error = error
        self.evaluationResult = evaluationResult
        self.logs = logs
    }
}

struct EvaluateCodeOutputBody: Swift.Equatable {
    let evaluationResult: Swift.String?
    let error: AppSyncClientTypes.EvaluateCodeErrorDetail?
    let logs: [Swift.String]?
}

extension EvaluateCodeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case evaluationResult
        case logs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationResult)
        evaluationResult = evaluationResultDecoded
        let errorDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.EvaluateCodeErrorDetail.self, forKey: .error)
        error = errorDecoded
        let logsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logs)
        var logsDecoded0:[Swift.String]? = nil
        if let logsContainer = logsContainer {
            logsDecoded0 = [Swift.String]()
            for string0 in logsContainer {
                if let string0 = string0 {
                    logsDecoded0?.append(string0)
                }
            }
        }
        logs = logsDecoded0
    }
}

enum EvaluateCodeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EvaluateMappingTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let context = self.context {
            try encodeContainer.encode(context, forKey: .context)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }
}

extension EvaluateMappingTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/dataplane-evaluatetemplate"
    }
}

public struct EvaluateMappingTemplateInput: Swift.Equatable {
    /// The map that holds all of the contextual information for your resolver invocation. A context is required for this action.
    /// This member is required.
    public var context: Swift.String?
    /// The mapping template; this can be a request or response template. A template is required for this action.
    /// This member is required.
    public var template: Swift.String?

    public init(
        context: Swift.String? = nil,
        template: Swift.String? = nil
    )
    {
        self.context = context
        self.template = template
    }
}

struct EvaluateMappingTemplateInputBody: Swift.Equatable {
    let template: Swift.String?
    let context: Swift.String?
}

extension EvaluateMappingTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context
        case template
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension EvaluateMappingTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EvaluateMappingTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.evaluationResult = output.evaluationResult
            self.logs = output.logs
        } else {
            self.error = nil
            self.evaluationResult = nil
            self.logs = nil
        }
    }
}

public struct EvaluateMappingTemplateOutput: Swift.Equatable {
    /// The ErrorDetail object.
    public var error: AppSyncClientTypes.ErrorDetail?
    /// The mapping template; this can be a request or response template.
    public var evaluationResult: Swift.String?
    /// A list of logs that were generated by calls to util.log.info and util.log.error in the evaluated code.
    public var logs: [Swift.String]?

    public init(
        error: AppSyncClientTypes.ErrorDetail? = nil,
        evaluationResult: Swift.String? = nil,
        logs: [Swift.String]? = nil
    )
    {
        self.error = error
        self.evaluationResult = evaluationResult
        self.logs = logs
    }
}

struct EvaluateMappingTemplateOutputBody: Swift.Equatable {
    let evaluationResult: Swift.String?
    let error: AppSyncClientTypes.ErrorDetail?
    let logs: [Swift.String]?
}

extension EvaluateMappingTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case evaluationResult
        case logs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationResult)
        evaluationResult = evaluationResultDecoded
        let errorDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ErrorDetail.self, forKey: .error)
        error = errorDecoded
        let logsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logs)
        var logsDecoded0:[Swift.String]? = nil
        if let logsContainer = logsContainer {
            logsDecoded0 = [Swift.String]()
            for string0 in logsContainer {
                if let string0 = string0 {
                    logsDecoded0?.append(string0)
                }
            }
        }
        logs = logsDecoded0
    }
}

enum EvaluateMappingTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppSyncClientTypes.EventBridgeDataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBusArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusArn = self.eventBusArn {
            try encodeContainer.encode(eventBusArn, forKey: .eventBusArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBusArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventBusArn)
        eventBusArn = eventBusArnDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an Amazon EventBridge bus data source configuration.
    public struct EventBridgeDataSourceConfig: Swift.Equatable {
        /// The ARN of the event bus. For more information about event buses, see [Amazon EventBridge event buses](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-bus.html).
        /// This member is required.
        public var eventBusArn: Swift.String?

        public init(
            eventBusArn: Swift.String? = nil
        )
        {
            self.eventBusArn = eventBusArn
        }
    }

}

extension AppSyncClientTypes {
    public enum FieldLogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case error
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldLogLevel] {
            return [
                .all,
                .error,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .error: return "ERROR"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FieldLogLevel(rawValue: rawValue) ?? FieldLogLevel.sdkUnknown(rawValue)
        }
    }
}

extension FlushApiCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/FlushCache"
    }
}

/// Represents the input of a FlushApiCache operation.
public struct FlushApiCacheInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct FlushApiCacheInputBody: Swift.Equatable {
}

extension FlushApiCacheInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension FlushApiCacheOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Represents the output of a FlushApiCache operation.
public struct FlushApiCacheOutput: Swift.Equatable {

    public init() { }
}

enum FlushApiCacheOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppSyncClientTypes.FunctionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case dataSourceName
        case description
        case functionArn
        case functionId
        case functionVersion
        case maxBatchSize
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case runtime
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let dataSourceName = self.dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionArn = self.functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionId = self.functionId {
            try encodeContainer.encode(functionId, forKey: .functionId)
        }
        if let functionVersion = self.functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if maxBatchSize != 0 {
            try encodeContainer.encode(maxBatchSize, forKey: .maxBatchSize)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestMappingTemplate = self.requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = self.responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime, forKey: .runtime)
        }
        if let syncConfig = self.syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionId)
        functionId = functionIdDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let maxBatchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBatchSize) ?? 0
        maxBatchSize = maxBatchSizeDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AppSyncRuntime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension AppSyncClientTypes {
    /// A function is a reusable entity. You can use multiple functions to compose the resolver logic.
    public struct FunctionConfiguration: Swift.Equatable {
        /// The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
        public var code: Swift.String?
        /// The name of the DataSource.
        public var dataSourceName: Swift.String?
        /// The Function description.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the Function object.
        public var functionArn: Swift.String?
        /// A unique ID representing the Function object.
        public var functionId: Swift.String?
        /// The version of the request mapping template. Currently, only the 2018-05-29 version of the template is supported.
        public var functionVersion: Swift.String?
        /// The maximum batching size for a resolver.
        public var maxBatchSize: Swift.Int
        /// The name of the Function object.
        public var name: Swift.String?
        /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
        public var requestMappingTemplate: Swift.String?
        /// The Function response mapping template.
        public var responseMappingTemplate: Swift.String?
        /// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
        public var runtime: AppSyncClientTypes.AppSyncRuntime?
        /// Describes a Sync configuration for a resolver. Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.
        public var syncConfig: AppSyncClientTypes.SyncConfig?

        public init(
            code: Swift.String? = nil,
            dataSourceName: Swift.String? = nil,
            description: Swift.String? = nil,
            functionArn: Swift.String? = nil,
            functionId: Swift.String? = nil,
            functionVersion: Swift.String? = nil,
            maxBatchSize: Swift.Int = 0,
            name: Swift.String? = nil,
            requestMappingTemplate: Swift.String? = nil,
            responseMappingTemplate: Swift.String? = nil,
            runtime: AppSyncClientTypes.AppSyncRuntime? = nil,
            syncConfig: AppSyncClientTypes.SyncConfig? = nil
        )
        {
            self.code = code
            self.dataSourceName = dataSourceName
            self.description = description
            self.functionArn = functionArn
            self.functionId = functionId
            self.functionVersion = functionVersion
            self.maxBatchSize = maxBatchSize
            self.name = name
            self.requestMappingTemplate = requestMappingTemplate
            self.responseMappingTemplate = responseMappingTemplate
            self.runtime = runtime
            self.syncConfig = syncConfig
        }
    }

}

extension GetApiAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v1/domainnames/\(domainName.urlPercentEncoding())/apiassociation"
    }
}

public struct GetApiAssociationInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetApiAssociationInputBody: Swift.Equatable {
}

extension GetApiAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApiAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApiAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiAssociation = output.apiAssociation
        } else {
            self.apiAssociation = nil
        }
    }
}

public struct GetApiAssociationOutput: Swift.Equatable {
    /// The ApiAssociation object.
    public var apiAssociation: AppSyncClientTypes.ApiAssociation?

    public init(
        apiAssociation: AppSyncClientTypes.ApiAssociation? = nil
    )
    {
        self.apiAssociation = apiAssociation
    }
}

struct GetApiAssociationOutputBody: Swift.Equatable {
    let apiAssociation: AppSyncClientTypes.ApiAssociation?
}

extension GetApiAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiAssociationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiAssociation.self, forKey: .apiAssociation)
        apiAssociation = apiAssociationDecoded
    }
}

enum GetApiAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApiCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches"
    }
}

/// Represents the input of a GetApiCache operation.
public struct GetApiCacheInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetApiCacheInputBody: Swift.Equatable {
}

extension GetApiCacheInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApiCacheOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApiCacheOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiCache = output.apiCache
        } else {
            self.apiCache = nil
        }
    }
}

/// Represents the output of a GetApiCache operation.
public struct GetApiCacheOutput: Swift.Equatable {
    /// The ApiCache object.
    public var apiCache: AppSyncClientTypes.ApiCache?

    public init(
        apiCache: AppSyncClientTypes.ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

struct GetApiCacheOutputBody: Swift.Equatable {
    let apiCache: AppSyncClientTypes.ApiCache?
}

extension GetApiCacheOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCache
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCacheDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCache.self, forKey: .apiCache)
        apiCache = apiCacheDecoded
    }
}

enum GetApiCacheOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources/\(name.urlPercentEncoding())"
    }
}

public struct GetDataSourceInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.name = name
    }
}

struct GetDataSourceInputBody: Swift.Equatable {
}

extension GetDataSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct GetDataSourceOutput: Swift.Equatable {
    /// The DataSource object.
    public var dataSource: AppSyncClientTypes.DataSource?

    public init(
        dataSource: AppSyncClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct GetDataSourceOutputBody: Swift.Equatable {
    let dataSource: AppSyncClientTypes.DataSource?
}

extension GetDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

enum GetDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v1/domainnames/\(domainName.urlPercentEncoding())"
    }
}

public struct GetDomainNameInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetDomainNameInputBody: Swift.Equatable {
}

extension GetDomainNameInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDomainNameOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainNameConfig = output.domainNameConfig
        } else {
            self.domainNameConfig = nil
        }
    }
}

public struct GetDomainNameOutput: Swift.Equatable {
    /// The configuration for the DomainName.
    public var domainNameConfig: AppSyncClientTypes.DomainNameConfig?

    public init(
        domainNameConfig: AppSyncClientTypes.DomainNameConfig? = nil
    )
    {
        self.domainNameConfig = domainNameConfig
    }
}

struct GetDomainNameOutputBody: Swift.Equatable {
    let domainNameConfig: AppSyncClientTypes.DomainNameConfig?
}

extension GetDomainNameOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNameConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DomainNameConfig.self, forKey: .domainNameConfig)
        domainNameConfig = domainNameConfigDecoded
    }
}

enum GetDomainNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let functionId = functionId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())"
    }
}

public struct GetFunctionInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The Function ID.
    /// This member is required.
    public var functionId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        functionId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
    }
}

struct GetFunctionInputBody: Swift.Equatable {
}

extension GetFunctionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFunctionOutputBody = try responseDecoder.decode(responseBody: data)
            self.functionConfiguration = output.functionConfiguration
        } else {
            self.functionConfiguration = nil
        }
    }
}

public struct GetFunctionOutput: Swift.Equatable {
    /// The Function object.
    public var functionConfiguration: AppSyncClientTypes.FunctionConfiguration?

    public init(
        functionConfiguration: AppSyncClientTypes.FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

struct GetFunctionOutputBody: Swift.Equatable {
    let functionConfiguration: AppSyncClientTypes.FunctionConfiguration?
}

extension GetFunctionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
    }
}

enum GetFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGraphqlApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())"
    }
}

public struct GetGraphqlApiInput: Swift.Equatable {
    /// The API ID for the GraphQL API.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetGraphqlApiInputBody: Swift.Equatable {
}

extension GetGraphqlApiInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGraphqlApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGraphqlApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.graphqlApi = output.graphqlApi
        } else {
            self.graphqlApi = nil
        }
    }
}

public struct GetGraphqlApiOutput: Swift.Equatable {
    /// The GraphqlApi object.
    public var graphqlApi: AppSyncClientTypes.GraphqlApi?

    public init(
        graphqlApi: AppSyncClientTypes.GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

struct GetGraphqlApiOutputBody: Swift.Equatable {
    let graphqlApi: AppSyncClientTypes.GraphqlApi?
}

extension GetGraphqlApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphqlApi
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApiDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.GraphqlApi.self, forKey: .graphqlApi)
        graphqlApi = graphqlApiDecoded
    }
}

enum GetGraphqlApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIntrospectionSchemaInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let includeDirectives = includeDirectives {
                let includeDirectivesQueryItem = ClientRuntime.URLQueryItem(name: "includeDirectives".urlPercentEncoding(), value: Swift.String(includeDirectives).urlPercentEncoding())
                items.append(includeDirectivesQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            return items
        }
    }
}

extension GetIntrospectionSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/schema"
    }
}

public struct GetIntrospectionSchemaInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The schema format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.OutputType?
    /// A flag that specifies whether the schema introspection should contain directives.
    public var includeDirectives: Swift.Bool?

    public init(
        apiId: Swift.String? = nil,
        format: AppSyncClientTypes.OutputType? = nil,
        includeDirectives: Swift.Bool? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.includeDirectives = includeDirectives
    }
}

struct GetIntrospectionSchemaInputBody: Swift.Equatable {
}

extension GetIntrospectionSchemaInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIntrospectionSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        switch httpResponse.body {
        case .data(let data):
            self.schema = data
        case .stream(let stream):
            self.schema = try stream.readToEnd()
        case .none:
            self.schema = nil
        }
    }
}

public struct GetIntrospectionSchemaOutput: Swift.Equatable {
    /// The schema, in GraphQL Schema Definition Language (SDL) format. For more information, see the [GraphQL SDL documentation](http://graphql.org/learn/schema/).
    public var schema: ClientRuntime.Data?

    public init(
        schema: ClientRuntime.Data? = nil
    )
    {
        self.schema = schema
    }
}

struct GetIntrospectionSchemaOutputBody: Swift.Equatable {
    let schema: ClientRuntime.Data?
}

extension GetIntrospectionSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schema
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .schema)
        schema = schemaDecoded
    }
}

enum GetIntrospectionSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "GraphQLSchemaException": return try await GraphQLSchemaException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResolverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        guard let fieldName = fieldName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers/\(fieldName.urlPercentEncoding())"
    }
}

public struct GetResolverInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The resolver field name.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The resolver type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.fieldName = fieldName
        self.typeName = typeName
    }
}

struct GetResolverInputBody: Swift.Equatable {
}

extension GetResolverInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResolverOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResolverOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolver = output.resolver
        } else {
            self.resolver = nil
        }
    }
}

public struct GetResolverOutput: Swift.Equatable {
    /// The Resolver object.
    public var resolver: AppSyncClientTypes.Resolver?

    public init(
        resolver: AppSyncClientTypes.Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

struct GetResolverOutputBody: Swift.Equatable {
    let resolver: AppSyncClientTypes.Resolver?
}

extension GetResolverOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolver
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.Resolver.self, forKey: .resolver)
        resolver = resolverDecoded
    }
}

enum GetResolverOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSchemaCreationStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/schemacreation"
    }
}

public struct GetSchemaCreationStatusInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetSchemaCreationStatusInputBody: Swift.Equatable {
}

extension GetSchemaCreationStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSchemaCreationStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSchemaCreationStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
            self.status = output.status
        } else {
            self.details = nil
            self.status = nil
        }
    }
}

public struct GetSchemaCreationStatusOutput: Swift.Equatable {
    /// Detailed information about the status of the schema creation operation.
    public var details: Swift.String?
    /// The current state of the schema (PROCESSING, FAILED, SUCCESS, or NOT_APPLICABLE). When the schema is in the ACTIVE state, you can add data.
    public var status: AppSyncClientTypes.SchemaStatus?

    public init(
        details: Swift.String? = nil,
        status: AppSyncClientTypes.SchemaStatus? = nil
    )
    {
        self.details = details
        self.status = status
    }
}

struct GetSchemaCreationStatusOutputBody: Swift.Equatable {
    let status: AppSyncClientTypes.SchemaStatus?
    let details: Swift.String?
}

extension GetSchemaCreationStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SchemaStatus.self, forKey: .status)
        status = statusDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
    }
}

enum GetSchemaCreationStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSourceApiAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mergedApiIdentifier = mergedApiIdentifier else {
            return nil
        }
        guard let associationId = associationId else {
            return nil
        }
        return "/v1/mergedApis/\(mergedApiIdentifier.urlPercentEncoding())/sourceApiAssociations/\(associationId.urlPercentEncoding())"
    }
}

public struct GetSourceApiAssociationInput: Swift.Equatable {
    /// The ID generated by the AppSync service for the source API association.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
    /// This member is required.
    public var mergedApiIdentifier: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        mergedApiIdentifier: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.mergedApiIdentifier = mergedApiIdentifier
    }
}

struct GetSourceApiAssociationInputBody: Swift.Equatable {
}

extension GetSourceApiAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSourceApiAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSourceApiAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sourceApiAssociation = output.sourceApiAssociation
        } else {
            self.sourceApiAssociation = nil
        }
    }
}

public struct GetSourceApiAssociationOutput: Swift.Equatable {
    /// The SourceApiAssociation object data.
    public var sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation?

    public init(
        sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation? = nil
    )
    {
        self.sourceApiAssociation = sourceApiAssociation
    }
}

struct GetSourceApiAssociationOutputBody: Swift.Equatable {
    let sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation?
}

extension GetSourceApiAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceApiAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceApiAssociationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SourceApiAssociation.self, forKey: .sourceApiAssociation)
        sourceApiAssociation = sourceApiAssociationDecoded
    }
}

enum GetSourceApiAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTypeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            return items
        }
    }
}

extension GetTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())"
    }
}

public struct GetTypeInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?
    /// The type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.typeName = typeName
    }
}

struct GetTypeInputBody: Swift.Equatable {
}

extension GetTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.type = output.type
        } else {
            self.type = nil
        }
    }
}

public struct GetTypeOutput: Swift.Equatable {
    /// The Type object.
    public var type: AppSyncClientTypes.ModelType?

    public init(
        type: AppSyncClientTypes.ModelType? = nil
    )
    {
        self.type = type
    }
}

struct GetTypeOutputBody: Swift.Equatable {
    let type: AppSyncClientTypes.ModelType?
}

extension GetTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

enum GetTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppSyncClientTypes {
    public enum GraphQLApiType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case graphql
        case merged
        case sdkUnknown(Swift.String)

        public static var allCases: [GraphQLApiType] {
            return [
                .graphql,
                .merged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .graphql: return "GRAPHQL"
            case .merged: return "MERGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GraphQLApiType(rawValue: rawValue) ?? GraphQLApiType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum GraphQLApiVisibility: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case global
        case `private`
        case sdkUnknown(Swift.String)

        public static var allCases: [GraphQLApiVisibility] {
            return [
                .global,
                .private,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .global: return "GLOBAL"
            case .private: return "PRIVATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GraphQLApiVisibility(rawValue: rawValue) ?? GraphQLApiVisibility.sdkUnknown(rawValue)
        }
    }
}

extension GraphQLSchemaException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GraphQLSchemaExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The GraphQL schema is not valid.
public struct GraphQLSchemaException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GraphQLSchemaException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct GraphQLSchemaExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension GraphQLSchemaExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.GraphqlApi: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case apiId
        case apiType
        case arn
        case authenticationType
        case dns
        case lambdaAuthorizerConfig
        case logConfig
        case mergedApiExecutionRoleArn
        case name
        case openIDConnectConfig
        case owner
        case ownerContact
        case tags
        case uris
        case userPoolConfig
        case visibility
        case wafWebAclArn
        case xrayEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthenticationProviders = additionalAuthenticationProviders {
            var additionalAuthenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthenticationProviders)
            for additionalauthenticationprovider0 in additionalAuthenticationProviders {
                try additionalAuthenticationProvidersContainer.encode(additionalauthenticationprovider0)
            }
        }
        if let apiId = self.apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiType = self.apiType {
            try encodeContainer.encode(apiType.rawValue, forKey: .apiType)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let dns = dns {
            var dnsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dns)
            for (dictKey0, mapOfStringToString0) in dns {
                try dnsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let lambdaAuthorizerConfig = self.lambdaAuthorizerConfig {
            try encodeContainer.encode(lambdaAuthorizerConfig, forKey: .lambdaAuthorizerConfig)
        }
        if let logConfig = self.logConfig {
            try encodeContainer.encode(logConfig, forKey: .logConfig)
        }
        if let mergedApiExecutionRoleArn = self.mergedApiExecutionRoleArn {
            try encodeContainer.encode(mergedApiExecutionRoleArn, forKey: .mergedApiExecutionRoleArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openIDConnectConfig = self.openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let ownerContact = self.ownerContact {
            try encodeContainer.encode(ownerContact, forKey: .ownerContact)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uris = uris {
            var urisContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .uris)
            for (dictKey0, mapOfStringToString0) in uris {
                try urisContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userPoolConfig = self.userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
        if let wafWebAclArn = self.wafWebAclArn {
            try encodeContainer.encode(wafWebAclArn, forKey: .wafWebAclArn)
        }
        if xrayEnabled != false {
            try encodeContainer.encode(xrayEnabled, forKey: .xrayEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let logConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LogConfig.self, forKey: .logConfig)
        logConfig = logConfigDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.UserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let urisContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .uris)
        var urisDecoded0: [Swift.String:Swift.String]? = nil
        if let urisContainer = urisContainer {
            urisDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in urisContainer {
                if let string0 = string0 {
                    urisDecoded0?[key0] = string0
                }
            }
        }
        uris = urisDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let additionalAuthenticationProvidersContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.AdditionalAuthenticationProvider?].self, forKey: .additionalAuthenticationProviders)
        var additionalAuthenticationProvidersDecoded0:[AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil
        if let additionalAuthenticationProvidersContainer = additionalAuthenticationProvidersContainer {
            additionalAuthenticationProvidersDecoded0 = [AppSyncClientTypes.AdditionalAuthenticationProvider]()
            for structure0 in additionalAuthenticationProvidersContainer {
                if let structure0 = structure0 {
                    additionalAuthenticationProvidersDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthenticationProviders = additionalAuthenticationProvidersDecoded0
        let xrayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .xrayEnabled) ?? false
        xrayEnabled = xrayEnabledDecoded
        let wafWebAclArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wafWebAclArn)
        wafWebAclArn = wafWebAclArnDecoded
        let lambdaAuthorizerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaAuthorizerConfig.self, forKey: .lambdaAuthorizerConfig)
        lambdaAuthorizerConfig = lambdaAuthorizerConfigDecoded
        let dnsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dns)
        var dnsDecoded0: [Swift.String:Swift.String]? = nil
        if let dnsContainer = dnsContainer {
            dnsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in dnsContainer {
                if let string0 = string0 {
                    dnsDecoded0?[key0] = string0
                }
            }
        }
        dns = dnsDecoded0
        let visibilityDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.GraphQLApiVisibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let apiTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.GraphQLApiType.self, forKey: .apiType)
        apiType = apiTypeDecoded
        let mergedApiExecutionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergedApiExecutionRoleArn)
        mergedApiExecutionRoleArn = mergedApiExecutionRoleArnDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let ownerContactDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerContact)
        ownerContact = ownerContactDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a GraphQL API.
    public struct GraphqlApi: Swift.Equatable {
        /// A list of additional authentication providers for the GraphqlApi API.
        public var additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
        /// The API ID.
        public var apiId: Swift.String?
        /// The value that indicates whether the GraphQL API is a standard API (GRAPHQL) or merged API (MERGED).
        public var apiType: AppSyncClientTypes.GraphQLApiType?
        /// The Amazon Resource Name (ARN).
        public var arn: Swift.String?
        /// The authentication type.
        public var authenticationType: AppSyncClientTypes.AuthenticationType?
        /// The DNS records for the API.
        public var dns: [Swift.String:Swift.String]?
        /// Configuration for Lambda function authorization.
        public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
        /// The Amazon CloudWatch Logs configuration.
        public var logConfig: AppSyncClientTypes.LogConfig?
        /// The Identity and Access Management service role ARN for a merged API. The AppSync service assumes this role on behalf of the Merged API to validate access to source APIs at runtime and to prompt the AUTO_MERGE to update the merged API endpoint with the source API changes automatically.
        public var mergedApiExecutionRoleArn: Swift.String?
        /// The API name.
        public var name: Swift.String?
        /// The OpenID Connect configuration.
        public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
        /// The account owner of the GraphQL API.
        public var owner: Swift.String?
        /// The owner contact information for an API resource. This field accepts any string input with a length of 0 - 256 characters.
        public var ownerContact: Swift.String?
        /// The tags.
        public var tags: [Swift.String:Swift.String]?
        /// The URIs.
        public var uris: [Swift.String:Swift.String]?
        /// The Amazon Cognito user pool configuration.
        public var userPoolConfig: AppSyncClientTypes.UserPoolConfig?
        /// Sets the value of the GraphQL API to public (GLOBAL) or private (PRIVATE). If no value is provided, the visibility will be set to GLOBAL by default. This value cannot be changed once the API has been created.
        public var visibility: AppSyncClientTypes.GraphQLApiVisibility?
        /// The ARN of the WAF access control list (ACL) associated with this GraphqlApi, if one exists.
        public var wafWebAclArn: Swift.String?
        /// A flag indicating whether to use X-Ray tracing for this GraphqlApi.
        public var xrayEnabled: Swift.Bool

        public init(
            additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil,
            apiId: Swift.String? = nil,
            apiType: AppSyncClientTypes.GraphQLApiType? = nil,
            arn: Swift.String? = nil,
            authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
            dns: [Swift.String:Swift.String]? = nil,
            lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
            logConfig: AppSyncClientTypes.LogConfig? = nil,
            mergedApiExecutionRoleArn: Swift.String? = nil,
            name: Swift.String? = nil,
            openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
            owner: Swift.String? = nil,
            ownerContact: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            uris: [Swift.String:Swift.String]? = nil,
            userPoolConfig: AppSyncClientTypes.UserPoolConfig? = nil,
            visibility: AppSyncClientTypes.GraphQLApiVisibility? = nil,
            wafWebAclArn: Swift.String? = nil,
            xrayEnabled: Swift.Bool = false
        )
        {
            self.additionalAuthenticationProviders = additionalAuthenticationProviders
            self.apiId = apiId
            self.apiType = apiType
            self.arn = arn
            self.authenticationType = authenticationType
            self.dns = dns
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.logConfig = logConfig
            self.mergedApiExecutionRoleArn = mergedApiExecutionRoleArn
            self.name = name
            self.openIDConnectConfig = openIDConnectConfig
            self.owner = owner
            self.ownerContact = ownerContact
            self.tags = tags
            self.uris = uris
            self.userPoolConfig = userPoolConfig
            self.visibility = visibility
            self.wafWebAclArn = wafWebAclArn
            self.xrayEnabled = xrayEnabled
        }
    }

}

extension AppSyncClientTypes.HttpDataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationConfig
        case endpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationConfig = self.authorizationConfig {
            try encodeContainer.encode(authorizationConfig, forKey: .authorizationConfig)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let authorizationConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthorizationConfig.self, forKey: .authorizationConfig)
        authorizationConfig = authorizationConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an HTTP data source configuration.
    public struct HttpDataSourceConfig: Swift.Equatable {
        /// The authorization configuration in case the HTTP endpoint requires authorization.
        public var authorizationConfig: AppSyncClientTypes.AuthorizationConfig?
        /// The HTTP URL endpoint. You can specify either the domain name or IP, and port combination, and the URL scheme must be HTTP or HTTPS. If you don't specify the port, AppSync uses the default port 80 for the HTTP endpoint and port 443 for HTTPS endpoints.
        public var endpoint: Swift.String?

        public init(
            authorizationConfig: AppSyncClientTypes.AuthorizationConfig? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.authorizationConfig = authorizationConfig
            self.endpoint = endpoint
        }
    }

}

extension InternalFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal AppSync error occurred. Try your request again.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.LambdaAuthorizerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerResultTtlInSeconds
        case authorizerUri
        case identityValidationExpression
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if authorizerResultTtlInSeconds != 0 {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerUri = self.authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let identityValidationExpression = self.identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds) ?? 0
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
    }
}

extension AppSyncClientTypes {
    /// A LambdaAuthorizerConfig specifies how to authorize AppSync API access when using the AWS_LAMBDA authorizer mode. Be aware that an AppSync API can have only one Lambda authorizer configured at a time.
    public struct LambdaAuthorizerConfig: Swift.Equatable {
        /// The number of seconds a response should be cached for. The default is 0 seconds, which disables caching. If you don't specify a value for authorizerResultTtlInSeconds, the default value is used. The maximum value is one hour (3600 seconds). The Lambda function can override this by returning a ttlOverride key in its response.
        public var authorizerResultTtlInSeconds: Swift.Int
        /// The Amazon Resource Name (ARN) of the Lambda function to be called for authorization. This can be a standard Lambda ARN, a version ARN (.../v3), or an alias ARN. Note: This Lambda function must have the following resource-based policy assigned to it. When configuring Lambda authorizers in the console, this is done for you. To use the Command Line Interface (CLI), run the following: aws lambda add-permission --function-name "arn:aws:lambda:us-east-2:111122223333:function:my-function" --statement-id "appsync" --principal appsync.amazonaws.com --action lambda:InvokeFunction
        /// This member is required.
        public var authorizerUri: Swift.String?
        /// A regular expression for validation of tokens before the Lambda function is called.
        public var identityValidationExpression: Swift.String?

        public init(
            authorizerResultTtlInSeconds: Swift.Int = 0,
            authorizerUri: Swift.String? = nil,
            identityValidationExpression: Swift.String? = nil
        )
        {
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerUri = authorizerUri
            self.identityValidationExpression = identityValidationExpression
        }
    }

}

extension AppSyncClientTypes.LambdaConflictHandlerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaConflictHandlerArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaConflictHandlerArn = self.lambdaConflictHandlerArn {
            try encodeContainer.encode(lambdaConflictHandlerArn, forKey: .lambdaConflictHandlerArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaConflictHandlerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaConflictHandlerArn)
        lambdaConflictHandlerArn = lambdaConflictHandlerArnDecoded
    }
}

extension AppSyncClientTypes {
    /// The LambdaConflictHandlerConfig object when configuring LAMBDA as the Conflict Handler.
    public struct LambdaConflictHandlerConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the Lambda function to use as the Conflict Handler.
        public var lambdaConflictHandlerArn: Swift.String?

        public init(
            lambdaConflictHandlerArn: Swift.String? = nil
        )
        {
            self.lambdaConflictHandlerArn = lambdaConflictHandlerArn
        }
    }

}

extension AppSyncClientTypes.LambdaDataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaFunctionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaFunctionArn = self.lambdaFunctionArn {
            try encodeContainer.encode(lambdaFunctionArn, forKey: .lambdaFunctionArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an Lambda data source configuration.
    public struct LambdaDataSourceConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the Lambda function.
        /// This member is required.
        public var lambdaFunctionArn: Swift.String?

        public init(
            lambdaFunctionArn: Swift.String? = nil
        )
        {
            self.lambdaFunctionArn = lambdaFunctionArn
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeded a limit. Try your request again.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApiKeysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListApiKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/apikeys"
    }
}

public struct ListApiKeysInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApiKeysInputBody: Swift.Equatable {
}

extension ListApiKeysInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApiKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApiKeysOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiKeys = output.apiKeys
            self.nextToken = output.nextToken
        } else {
            self.apiKeys = nil
            self.nextToken = nil
        }
    }
}

public struct ListApiKeysOutput: Swift.Equatable {
    /// The ApiKey objects.
    public var apiKeys: [AppSyncClientTypes.ApiKey]?
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        apiKeys: [AppSyncClientTypes.ApiKey]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiKeys = apiKeys
        self.nextToken = nextToken
    }
}

struct ListApiKeysOutputBody: Swift.Equatable {
    let apiKeys: [AppSyncClientTypes.ApiKey]?
    let nextToken: Swift.String?
}

extension ListApiKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeys
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeysContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.ApiKey?].self, forKey: .apiKeys)
        var apiKeysDecoded0:[AppSyncClientTypes.ApiKey]? = nil
        if let apiKeysContainer = apiKeysContainer {
            apiKeysDecoded0 = [AppSyncClientTypes.ApiKey]()
            for structure0 in apiKeysContainer {
                if let structure0 = structure0 {
                    apiKeysDecoded0?.append(structure0)
                }
            }
        }
        apiKeys = apiKeysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApiKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataSourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDataSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources"
    }
}

public struct ListDataSourcesInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSourcesInputBody: Swift.Equatable {
}

extension ListDataSourcesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataSourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSources = output.dataSources
            self.nextToken = output.nextToken
        } else {
            self.dataSources = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSourcesOutput: Swift.Equatable {
    /// The DataSource objects.
    public var dataSources: [AppSyncClientTypes.DataSource]?
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        dataSources: [AppSyncClientTypes.DataSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSources = dataSources
        self.nextToken = nextToken
    }
}

struct ListDataSourcesOutputBody: Swift.Equatable {
    let dataSources: [AppSyncClientTypes.DataSource]?
    let nextToken: Swift.String?
}

extension ListDataSourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSources
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourcesContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[AppSyncClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [AppSyncClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataSourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDomainNamesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDomainNamesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domainnames"
    }
}

public struct ListDomainNamesInput: Swift.Equatable {
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainNamesInputBody: Swift.Equatable {
}

extension ListDomainNamesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDomainNamesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDomainNamesOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainNameConfigs = output.domainNameConfigs
            self.nextToken = output.nextToken
        } else {
            self.domainNameConfigs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainNamesOutput: Swift.Equatable {
    /// Lists configurations for multiple domain names.
    public var domainNameConfigs: [AppSyncClientTypes.DomainNameConfig]?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        domainNameConfigs: [AppSyncClientTypes.DomainNameConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainNameConfigs = domainNameConfigs
        self.nextToken = nextToken
    }
}

struct ListDomainNamesOutputBody: Swift.Equatable {
    let domainNameConfigs: [AppSyncClientTypes.DomainNameConfig]?
    let nextToken: Swift.String?
}

extension ListDomainNamesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNameConfigs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameConfigsContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.DomainNameConfig?].self, forKey: .domainNameConfigs)
        var domainNameConfigsDecoded0:[AppSyncClientTypes.DomainNameConfig]? = nil
        if let domainNameConfigsContainer = domainNameConfigsContainer {
            domainNameConfigsDecoded0 = [AppSyncClientTypes.DomainNameConfig]()
            for structure0 in domainNameConfigsContainer {
                if let structure0 = structure0 {
                    domainNameConfigsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigs = domainNameConfigsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDomainNamesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFunctionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFunctionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions"
    }
}

public struct ListFunctionsInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFunctionsInputBody: Swift.Equatable {
}

extension ListFunctionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFunctionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.functions = output.functions
            self.nextToken = output.nextToken
        } else {
            self.functions = nil
            self.nextToken = nil
        }
    }
}

public struct ListFunctionsOutput: Swift.Equatable {
    /// A list of Function objects.
    public var functions: [AppSyncClientTypes.FunctionConfiguration]?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        functions: [AppSyncClientTypes.FunctionConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functions = functions
        self.nextToken = nextToken
    }
}

struct ListFunctionsOutputBody: Swift.Equatable {
    let functions: [AppSyncClientTypes.FunctionConfiguration]?
    let nextToken: Swift.String?
}

extension ListFunctionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionsContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.FunctionConfiguration?].self, forKey: .functions)
        var functionsDecoded0:[AppSyncClientTypes.FunctionConfiguration]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [AppSyncClientTypes.FunctionConfiguration]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        functions = functionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFunctionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGraphqlApisInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let owner = owner {
                let ownerQueryItem = ClientRuntime.URLQueryItem(name: "owner".urlPercentEncoding(), value: Swift.String(owner.rawValue).urlPercentEncoding())
                items.append(ownerQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let apiType = apiType {
                let apiTypeQueryItem = ClientRuntime.URLQueryItem(name: "apiType".urlPercentEncoding(), value: Swift.String(apiType.rawValue).urlPercentEncoding())
                items.append(apiTypeQueryItem)
            }
            return items
        }
    }
}

extension ListGraphqlApisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/apis"
    }
}

public struct ListGraphqlApisInput: Swift.Equatable {
    /// The value that indicates whether the GraphQL API is a standard API (GRAPHQL) or merged API (MERGED).
    public var apiType: AppSyncClientTypes.GraphQLApiType?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The account owner of the GraphQL API.
    public var owner: AppSyncClientTypes.Ownership?

    public init(
        apiType: AppSyncClientTypes.GraphQLApiType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: AppSyncClientTypes.Ownership? = nil
    )
    {
        self.apiType = apiType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListGraphqlApisInputBody: Swift.Equatable {
}

extension ListGraphqlApisInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGraphqlApisOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGraphqlApisOutputBody = try responseDecoder.decode(responseBody: data)
            self.graphqlApis = output.graphqlApis
            self.nextToken = output.nextToken
        } else {
            self.graphqlApis = nil
            self.nextToken = nil
        }
    }
}

public struct ListGraphqlApisOutput: Swift.Equatable {
    /// The GraphqlApi objects.
    public var graphqlApis: [AppSyncClientTypes.GraphqlApi]?
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        graphqlApis: [AppSyncClientTypes.GraphqlApi]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphqlApis = graphqlApis
        self.nextToken = nextToken
    }
}

struct ListGraphqlApisOutputBody: Swift.Equatable {
    let graphqlApis: [AppSyncClientTypes.GraphqlApi]?
    let nextToken: Swift.String?
}

extension ListGraphqlApisOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphqlApis
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApisContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.GraphqlApi?].self, forKey: .graphqlApis)
        var graphqlApisDecoded0:[AppSyncClientTypes.GraphqlApi]? = nil
        if let graphqlApisContainer = graphqlApisContainer {
            graphqlApisDecoded0 = [AppSyncClientTypes.GraphqlApi]()
            for structure0 in graphqlApisContainer {
                if let structure0 = structure0 {
                    graphqlApisDecoded0?.append(structure0)
                }
            }
        }
        graphqlApis = graphqlApisDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGraphqlApisOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResolversByFunctionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListResolversByFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let functionId = functionId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())/resolvers"
    }
}

public struct ListResolversByFunctionInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The function ID.
    /// This member is required.
    public var functionId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        functionId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolversByFunctionInputBody: Swift.Equatable {
}

extension ListResolversByFunctionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListResolversByFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResolversByFunctionOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolvers = output.resolvers
        } else {
            self.nextToken = nil
            self.resolvers = nil
        }
    }
}

public struct ListResolversByFunctionOutput: Swift.Equatable {
    /// An identifier that you can use to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The list of resolvers.
    public var resolvers: [AppSyncClientTypes.Resolver]?

    public init(
        nextToken: Swift.String? = nil,
        resolvers: [AppSyncClientTypes.Resolver]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolvers = resolvers
    }
}

struct ListResolversByFunctionOutputBody: Swift.Equatable {
    let resolvers: [AppSyncClientTypes.Resolver]?
    let nextToken: Swift.String?
}

extension ListResolversByFunctionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resolvers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolversContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.Resolver?].self, forKey: .resolvers)
        var resolversDecoded0:[AppSyncClientTypes.Resolver]? = nil
        if let resolversContainer = resolversContainer {
            resolversDecoded0 = [AppSyncClientTypes.Resolver]()
            for structure0 in resolversContainer {
                if let structure0 = structure0 {
                    resolversDecoded0?.append(structure0)
                }
            }
        }
        resolvers = resolversDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListResolversByFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResolversInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListResolversInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers"
    }
}

public struct ListResolversInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.typeName = typeName
    }
}

struct ListResolversInputBody: Swift.Equatable {
}

extension ListResolversInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListResolversOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResolversOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolvers = output.resolvers
        } else {
            self.nextToken = nil
            self.resolvers = nil
        }
    }
}

public struct ListResolversOutput: Swift.Equatable {
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The Resolver objects.
    public var resolvers: [AppSyncClientTypes.Resolver]?

    public init(
        nextToken: Swift.String? = nil,
        resolvers: [AppSyncClientTypes.Resolver]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolvers = resolvers
    }
}

struct ListResolversOutputBody: Swift.Equatable {
    let resolvers: [AppSyncClientTypes.Resolver]?
    let nextToken: Swift.String?
}

extension ListResolversOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resolvers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolversContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.Resolver?].self, forKey: .resolvers)
        var resolversDecoded0:[AppSyncClientTypes.Resolver]? = nil
        if let resolversContainer = resolversContainer {
            resolversDecoded0 = [AppSyncClientTypes.Resolver]()
            for structure0 in resolversContainer {
                if let structure0 = structure0 {
                    resolversDecoded0?.append(structure0)
                }
            }
        }
        resolvers = resolversDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListResolversOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSourceApiAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSourceApiAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/sourceApiAssociations"
    }
}

public struct ListSourceApiAssociationsInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSourceApiAssociationsInputBody: Swift.Equatable {
}

extension ListSourceApiAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSourceApiAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSourceApiAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sourceApiAssociationSummaries = output.sourceApiAssociationSummaries
        } else {
            self.nextToken = nil
            self.sourceApiAssociationSummaries = nil
        }
    }
}

public struct ListSourceApiAssociationsOutput: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The SourceApiAssociationSummary object data.
    public var sourceApiAssociationSummaries: [AppSyncClientTypes.SourceApiAssociationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sourceApiAssociationSummaries: [AppSyncClientTypes.SourceApiAssociationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sourceApiAssociationSummaries = sourceApiAssociationSummaries
    }
}

struct ListSourceApiAssociationsOutputBody: Swift.Equatable {
    let sourceApiAssociationSummaries: [AppSyncClientTypes.SourceApiAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListSourceApiAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sourceApiAssociationSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceApiAssociationSummariesContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.SourceApiAssociationSummary?].self, forKey: .sourceApiAssociationSummaries)
        var sourceApiAssociationSummariesDecoded0:[AppSyncClientTypes.SourceApiAssociationSummary]? = nil
        if let sourceApiAssociationSummariesContainer = sourceApiAssociationSummariesContainer {
            sourceApiAssociationSummariesDecoded0 = [AppSyncClientTypes.SourceApiAssociationSummary]()
            for structure0 in sourceApiAssociationSummariesContainer {
                if let structure0 = structure0 {
                    sourceApiAssociationSummariesDecoded0?.append(structure0)
                }
            }
        }
        sourceApiAssociationSummaries = sourceApiAssociationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSourceApiAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The GraphqlApi Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A TagMap object.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTypesByAssociationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            return items
        }
    }
}

extension ListTypesByAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mergedApiIdentifier = mergedApiIdentifier else {
            return nil
        }
        guard let associationId = associationId else {
            return nil
        }
        return "/v1/mergedApis/\(mergedApiIdentifier.urlPercentEncoding())/sourceApiAssociations/\(associationId.urlPercentEncoding())/types"
    }
}

public struct ListTypesByAssociationInput: Swift.Equatable {
    /// The ID generated by the AppSync service for the source API association.
    /// This member is required.
    public var associationId: Swift.String?
    /// The format type.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
    /// This member is required.
    public var mergedApiIdentifier: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
        maxResults: Swift.Int? = nil,
        mergedApiIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.format = format
        self.maxResults = maxResults
        self.mergedApiIdentifier = mergedApiIdentifier
        self.nextToken = nextToken
    }
}

struct ListTypesByAssociationInputBody: Swift.Equatable {
}

extension ListTypesByAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTypesByAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTypesByAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.types = output.types
        } else {
            self.nextToken = nil
            self.types = nil
        }
    }
}

public struct ListTypesByAssociationOutput: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The Type objects.
    public var types: [AppSyncClientTypes.ModelType]?

    public init(
        nextToken: Swift.String? = nil,
        types: [AppSyncClientTypes.ModelType]? = nil
    )
    {
        self.nextToken = nextToken
        self.types = types
    }
}

struct ListTypesByAssociationOutputBody: Swift.Equatable {
    let types: [AppSyncClientTypes.ModelType]?
    let nextToken: Swift.String?
}

extension ListTypesByAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case types
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typesContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.ModelType?].self, forKey: .types)
        var typesDecoded0:[AppSyncClientTypes.ModelType]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [AppSyncClientTypes.ModelType]()
            for structure0 in typesContainer {
                if let structure0 = structure0 {
                    typesDecoded0?.append(structure0)
                }
            }
        }
        types = typesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTypesByAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTypesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            return items
        }
    }
}

extension ListTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types"
    }
}

public struct ListTypesInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTypesInputBody: Swift.Equatable {
}

extension ListTypesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.types = output.types
        } else {
            self.nextToken = nil
            self.types = nil
        }
    }
}

public struct ListTypesOutput: Swift.Equatable {
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The Type objects.
    public var types: [AppSyncClientTypes.ModelType]?

    public init(
        nextToken: Swift.String? = nil,
        types: [AppSyncClientTypes.ModelType]? = nil
    )
    {
        self.nextToken = nextToken
        self.types = types
    }
}

struct ListTypesOutputBody: Swift.Equatable {
    let types: [AppSyncClientTypes.ModelType]?
    let nextToken: Swift.String?
}

extension ListTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case types
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typesContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.ModelType?].self, forKey: .types)
        var typesDecoded0:[AppSyncClientTypes.ModelType]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [AppSyncClientTypes.ModelType]()
            for structure0 in typesContainer {
                if let structure0 = structure0 {
                    typesDecoded0?.append(structure0)
                }
            }
        }
        types = typesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppSyncClientTypes.LogConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsRoleArn
        case excludeVerboseContent
        case fieldLogLevel
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsRoleArn = self.cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if excludeVerboseContent != false {
            try encodeContainer.encode(excludeVerboseContent, forKey: .excludeVerboseContent)
        }
        if let fieldLogLevel = self.fieldLogLevel {
            try encodeContainer.encode(fieldLogLevel.rawValue, forKey: .fieldLogLevel)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLogLevelDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.FieldLogLevel.self, forKey: .fieldLogLevel)
        fieldLogLevel = fieldLogLevelDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let excludeVerboseContentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excludeVerboseContent) ?? false
        excludeVerboseContent = excludeVerboseContentDecoded
    }
}

extension AppSyncClientTypes {
    /// The Amazon CloudWatch Logs configuration.
    public struct LogConfig: Swift.Equatable {
        /// The service role that AppSync assumes to publish to CloudWatch logs in your account.
        /// This member is required.
        public var cloudWatchLogsRoleArn: Swift.String?
        /// Set to TRUE to exclude sections that contain information such as headers, context, and evaluated mapping templates, regardless of logging level.
        public var excludeVerboseContent: Swift.Bool
        /// The field logging level. Values can be NONE, ERROR, or ALL.
        ///
        /// * NONE: No field-level logs are captured.
        ///
        /// * ERROR: Logs the following information only for the fields that are in error:
        ///
        /// * The error section in the server response.
        ///
        /// * Field-level errors.
        ///
        /// * The generated request/response functions that got resolved for error fields.
        ///
        ///
        ///
        ///
        /// * ALL: The following information is logged for all fields in the query:
        ///
        /// * Field-level tracing information.
        ///
        /// * The generated request/response functions that got resolved for each field.
        /// This member is required.
        public var fieldLogLevel: AppSyncClientTypes.FieldLogLevel?

        public init(
            cloudWatchLogsRoleArn: Swift.String? = nil,
            excludeVerboseContent: Swift.Bool = false,
            fieldLogLevel: AppSyncClientTypes.FieldLogLevel? = nil
        )
        {
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.excludeVerboseContent = excludeVerboseContent
            self.fieldLogLevel = fieldLogLevel
        }
    }

}

extension AppSyncClientTypes {
    public enum MergeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case autoMerge
        case manualMerge
        case sdkUnknown(Swift.String)

        public static var allCases: [MergeType] {
            return [
                .autoMerge,
                .manualMerge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .autoMerge: return "AUTO_MERGE"
            case .manualMerge: return "MANUAL_MERGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MergeType(rawValue: rawValue) ?? MergeType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.ModelType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case definition
        case description
        case format
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.TypeDefinitionFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource specified in the request was not found. Check the resource, and then try again.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppSyncClientTypes.OpenIDConnectConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authTTL
        case clientId
        case iatTTL
        case issuer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if authTTL != 0 {
            try encodeContainer.encode(authTTL, forKey: .authTTL)
        }
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if iatTTL != 0 {
            try encodeContainer.encode(iatTTL, forKey: .iatTTL)
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let iatTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iatTTL) ?? 0
        iatTTL = iatTTLDecoded
        let authTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authTTL) ?? 0
        authTTL = authTTLDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an OpenID Connect (OIDC) configuration.
    public struct OpenIDConnectConfig: Swift.Equatable {
        /// The number of milliseconds that a token is valid after being authenticated.
        public var authTTL: Swift.Int
        /// The client identifier of the relying party at the OpenID identity provider. This identifier is typically obtained when the relying party is registered with the OpenID identity provider. You can specify a regular expression so that AppSync can validate against multiple client identifiers at a time.
        public var clientId: Swift.String?
        /// The number of milliseconds that a token is valid after it's issued to a user.
        public var iatTTL: Swift.Int
        /// The issuer for the OIDC configuration. The issuer returned by discovery must exactly match the value of iss in the ID token.
        /// This member is required.
        public var issuer: Swift.String?

        public init(
            authTTL: Swift.Int = 0,
            clientId: Swift.String? = nil,
            iatTTL: Swift.Int = 0,
            issuer: Swift.String? = nil
        )
        {
            self.authTTL = authTTL
            self.clientId = clientId
            self.iatTTL = iatTTL
            self.issuer = issuer
        }
    }

}

extension AppSyncClientTypes.OpenSearchServiceDataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion
        case endpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an OpenSearch data source configuration.
    public struct OpenSearchServiceDataSourceConfig: Swift.Equatable {
        /// The Amazon Web Services Region.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The endpoint.
        /// This member is required.
        public var endpoint: Swift.String?

        public init(
            awsRegion: Swift.String? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.endpoint = endpoint
        }
    }

}

extension AppSyncClientTypes {
    public enum OutputType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case sdl
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputType] {
            return [
                .json,
                .sdl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .sdl: return "SDL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputType(rawValue: rawValue) ?? OutputType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum Ownership: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case currentAccount
        case otherAccounts
        case sdkUnknown(Swift.String)

        public static var allCases: [Ownership] {
            return [
                .currentAccount,
                .otherAccounts,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .currentAccount: return "CURRENT_ACCOUNT"
            case .otherAccounts: return "OTHER_ACCOUNTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Ownership(rawValue: rawValue) ?? Ownership.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.PipelineConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functions)
            for string0 in functions {
                try functionsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .functions)
        var functionsDecoded0:[Swift.String]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [Swift.String]()
            for string0 in functionsContainer {
                if let string0 = string0 {
                    functionsDecoded0?.append(string0)
                }
            }
        }
        functions = functionsDecoded0
    }
}

extension AppSyncClientTypes {
    /// The pipeline configuration for a resolver of kind PIPELINE.
    public struct PipelineConfig: Swift.Equatable {
        /// A list of Function objects.
        public var functions: [Swift.String]?

        public init(
            functions: [Swift.String]? = nil
        )
        {
            self.functions = functions
        }
    }

}

extension AppSyncClientTypes.RdsHttpEndpointConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion
        case awsSecretStoreArn
        case databaseName
        case dbClusterIdentifier
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let awsSecretStoreArn = self.awsSecretStoreArn {
            try encodeContainer.encode(awsSecretStoreArn, forKey: .awsSecretStoreArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dbClusterIdentifier = self.dbClusterIdentifier {
            try encodeContainer.encode(dbClusterIdentifier, forKey: .dbClusterIdentifier)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let dbClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterIdentifier)
        dbClusterIdentifier = dbClusterIdentifierDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let awsSecretStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsSecretStoreArn)
        awsSecretStoreArn = awsSecretStoreArnDecoded
    }
}

extension AppSyncClientTypes {
    /// The Amazon Relational Database Service (Amazon RDS) HTTP endpoint configuration.
    public struct RdsHttpEndpointConfig: Swift.Equatable {
        /// Amazon Web Services Region for Amazon RDS HTTP endpoint.
        public var awsRegion: Swift.String?
        /// Amazon Web Services secret store Amazon Resource Name (ARN) for database credentials.
        public var awsSecretStoreArn: Swift.String?
        /// Logical database name.
        public var databaseName: Swift.String?
        /// Amazon RDS cluster Amazon Resource Name (ARN).
        public var dbClusterIdentifier: Swift.String?
        /// Logical schema name.
        public var schema: Swift.String?

        public init(
            awsRegion: Swift.String? = nil,
            awsSecretStoreArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dbClusterIdentifier: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.awsSecretStoreArn = awsSecretStoreArn
            self.databaseName = databaseName
            self.dbClusterIdentifier = dbClusterIdentifier
            self.schema = schema
        }
    }

}

extension AppSyncClientTypes.RelationalDatabaseDataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rdsHttpEndpointConfig
        case relationalDatabaseSourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rdsHttpEndpointConfig = self.rdsHttpEndpointConfig {
            try encodeContainer.encode(rdsHttpEndpointConfig, forKey: .rdsHttpEndpointConfig)
        }
        if let relationalDatabaseSourceType = self.relationalDatabaseSourceType {
            try encodeContainer.encode(relationalDatabaseSourceType.rawValue, forKey: .relationalDatabaseSourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relationalDatabaseSourceTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RelationalDatabaseSourceType.self, forKey: .relationalDatabaseSourceType)
        relationalDatabaseSourceType = relationalDatabaseSourceTypeDecoded
        let rdsHttpEndpointConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RdsHttpEndpointConfig.self, forKey: .rdsHttpEndpointConfig)
        rdsHttpEndpointConfig = rdsHttpEndpointConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a relational database data source configuration.
    public struct RelationalDatabaseDataSourceConfig: Swift.Equatable {
        /// Amazon RDS HTTP endpoint settings.
        public var rdsHttpEndpointConfig: AppSyncClientTypes.RdsHttpEndpointConfig?
        /// Source type for the relational database.
        ///
        /// * RDS_HTTP_ENDPOINT: The relational database source type is an Amazon Relational Database Service (Amazon RDS) HTTP endpoint.
        public var relationalDatabaseSourceType: AppSyncClientTypes.RelationalDatabaseSourceType?

        public init(
            rdsHttpEndpointConfig: AppSyncClientTypes.RdsHttpEndpointConfig? = nil,
            relationalDatabaseSourceType: AppSyncClientTypes.RelationalDatabaseSourceType? = nil
        )
        {
            self.rdsHttpEndpointConfig = rdsHttpEndpointConfig
            self.relationalDatabaseSourceType = relationalDatabaseSourceType
        }
    }

}

extension AppSyncClientTypes {
    public enum RelationalDatabaseSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rdsHttpEndpoint
        case sdkUnknown(Swift.String)

        public static var allCases: [RelationalDatabaseSourceType] {
            return [
                .rdsHttpEndpoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rdsHttpEndpoint: return "RDS_HTTP_ENDPOINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelationalDatabaseSourceType(rawValue: rawValue) ?? RelationalDatabaseSourceType.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.Resolver: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case code
        case dataSourceName
        case fieldName
        case kind
        case maxBatchSize
        case pipelineConfig
        case requestMappingTemplate
        case resolverArn
        case responseMappingTemplate
        case runtime
        case syncConfig
        case typeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingConfig = self.cachingConfig {
            try encodeContainer.encode(cachingConfig, forKey: .cachingConfig)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let dataSourceName = self.dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let fieldName = self.fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let kind = self.kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if maxBatchSize != 0 {
            try encodeContainer.encode(maxBatchSize, forKey: .maxBatchSize)
        }
        if let pipelineConfig = self.pipelineConfig {
            try encodeContainer.encode(pipelineConfig, forKey: .pipelineConfig)
        }
        if let requestMappingTemplate = self.requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let resolverArn = self.resolverArn {
            try encodeContainer.encode(resolverArn, forKey: .resolverArn)
        }
        if let responseMappingTemplate = self.responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime, forKey: .runtime)
        }
        if let syncConfig = self.syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
        if let typeName = self.typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let resolverArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverArn)
        resolverArn = resolverArnDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let kindDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ResolverKind.self, forKey: .kind)
        kind = kindDecoded
        let pipelineConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.PipelineConfig.self, forKey: .pipelineConfig)
        pipelineConfig = pipelineConfigDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let cachingConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.CachingConfig.self, forKey: .cachingConfig)
        cachingConfig = cachingConfigDecoded
        let maxBatchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBatchSize) ?? 0
        maxBatchSize = maxBatchSizeDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AppSyncRuntime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a resolver.
    public struct Resolver: Swift.Equatable {
        /// The caching configuration for the resolver.
        public var cachingConfig: AppSyncClientTypes.CachingConfig?
        /// The resolver code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
        public var code: Swift.String?
        /// The resolver data source name.
        public var dataSourceName: Swift.String?
        /// The resolver field name.
        public var fieldName: Swift.String?
        /// The resolver type.
        ///
        /// * UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.
        ///
        /// * PIPELINE: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of Function objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.
        public var kind: AppSyncClientTypes.ResolverKind?
        /// The maximum batching size for a resolver.
        public var maxBatchSize: Swift.Int
        /// The PipelineConfig.
        public var pipelineConfig: AppSyncClientTypes.PipelineConfig?
        /// The request mapping template.
        public var requestMappingTemplate: Swift.String?
        /// The resolver Amazon Resource Name (ARN).
        public var resolverArn: Swift.String?
        /// The response mapping template.
        public var responseMappingTemplate: Swift.String?
        /// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
        public var runtime: AppSyncClientTypes.AppSyncRuntime?
        /// The SyncConfig for a resolver attached to a versioned data source.
        public var syncConfig: AppSyncClientTypes.SyncConfig?
        /// The resolver type name.
        public var typeName: Swift.String?

        public init(
            cachingConfig: AppSyncClientTypes.CachingConfig? = nil,
            code: Swift.String? = nil,
            dataSourceName: Swift.String? = nil,
            fieldName: Swift.String? = nil,
            kind: AppSyncClientTypes.ResolverKind? = nil,
            maxBatchSize: Swift.Int = 0,
            pipelineConfig: AppSyncClientTypes.PipelineConfig? = nil,
            requestMappingTemplate: Swift.String? = nil,
            resolverArn: Swift.String? = nil,
            responseMappingTemplate: Swift.String? = nil,
            runtime: AppSyncClientTypes.AppSyncRuntime? = nil,
            syncConfig: AppSyncClientTypes.SyncConfig? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.cachingConfig = cachingConfig
            self.code = code
            self.dataSourceName = dataSourceName
            self.fieldName = fieldName
            self.kind = kind
            self.maxBatchSize = maxBatchSize
            self.pipelineConfig = pipelineConfig
            self.requestMappingTemplate = requestMappingTemplate
            self.resolverArn = resolverArn
            self.responseMappingTemplate = responseMappingTemplate
            self.runtime = runtime
            self.syncConfig = syncConfig
            self.typeName = typeName
        }
    }

}

extension AppSyncClientTypes {
    public enum ResolverKind: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pipeline
        case unit
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverKind] {
            return [
                .pipeline,
                .unit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pipeline: return "PIPELINE"
            case .unit: return "UNIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverKind(rawValue: rawValue) ?? ResolverKind.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum RuntimeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appsyncJs
        case sdkUnknown(Swift.String)

        public static var allCases: [RuntimeName] {
            return [
                .appsyncJs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appsyncJs: return "APPSYNC_JS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuntimeName(rawValue: rawValue) ?? RuntimeName.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes {
    public enum SchemaStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case failed
        case notapplicable
        case processing
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaStatus] {
            return [
                .active,
                .deleting,
                .failed,
                .notapplicable,
                .processing,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .notapplicable: return "NOT_APPLICABLE"
            case .processing: return "PROCESSING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SchemaStatus(rawValue: rawValue) ?? SchemaStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.SourceApiAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationArn
        case associationId
        case description
        case lastSuccessfulMergeDate
        case mergedApiArn
        case mergedApiId
        case sourceApiArn
        case sourceApiAssociationConfig
        case sourceApiAssociationStatus
        case sourceApiAssociationStatusDetail
        case sourceApiId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationArn = self.associationArn {
            try encodeContainer.encode(associationArn, forKey: .associationArn)
        }
        if let associationId = self.associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastSuccessfulMergeDate = self.lastSuccessfulMergeDate {
            try encodeContainer.encodeTimestamp(lastSuccessfulMergeDate, format: .epochSeconds, forKey: .lastSuccessfulMergeDate)
        }
        if let mergedApiArn = self.mergedApiArn {
            try encodeContainer.encode(mergedApiArn, forKey: .mergedApiArn)
        }
        if let mergedApiId = self.mergedApiId {
            try encodeContainer.encode(mergedApiId, forKey: .mergedApiId)
        }
        if let sourceApiArn = self.sourceApiArn {
            try encodeContainer.encode(sourceApiArn, forKey: .sourceApiArn)
        }
        if let sourceApiAssociationConfig = self.sourceApiAssociationConfig {
            try encodeContainer.encode(sourceApiAssociationConfig, forKey: .sourceApiAssociationConfig)
        }
        if let sourceApiAssociationStatus = self.sourceApiAssociationStatus {
            try encodeContainer.encode(sourceApiAssociationStatus.rawValue, forKey: .sourceApiAssociationStatus)
        }
        if let sourceApiAssociationStatusDetail = self.sourceApiAssociationStatusDetail {
            try encodeContainer.encode(sourceApiAssociationStatusDetail, forKey: .sourceApiAssociationStatusDetail)
        }
        if let sourceApiId = self.sourceApiId {
            try encodeContainer.encode(sourceApiId, forKey: .sourceApiId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationArn)
        associationArn = associationArnDecoded
        let sourceApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceApiId)
        sourceApiId = sourceApiIdDecoded
        let sourceApiArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceApiArn)
        sourceApiArn = sourceApiArnDecoded
        let mergedApiArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergedApiArn)
        mergedApiArn = mergedApiArnDecoded
        let mergedApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergedApiId)
        mergedApiId = mergedApiIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceApiAssociationConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SourceApiAssociationConfig.self, forKey: .sourceApiAssociationConfig)
        sourceApiAssociationConfig = sourceApiAssociationConfigDecoded
        let sourceApiAssociationStatusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SourceApiAssociationStatus.self, forKey: .sourceApiAssociationStatus)
        sourceApiAssociationStatus = sourceApiAssociationStatusDecoded
        let sourceApiAssociationStatusDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceApiAssociationStatusDetail)
        sourceApiAssociationStatusDetail = sourceApiAssociationStatusDetailDecoded
        let lastSuccessfulMergeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSuccessfulMergeDate)
        lastSuccessfulMergeDate = lastSuccessfulMergeDateDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes the configuration of a source API. A source API is a GraphQL API that is linked to a merged API. There can be multiple source APIs attached to each merged API. When linked to a merged API, the source API's schema, data sources, and resolvers will be combined with other linked source API data to form a new, singular API. Source APIs can originate from your account or from other accounts via Amazon Web Services Resource Access Manager. For more information about sharing resources from other accounts, see [What is Amazon Web Services Resource Access Manager?](https://docs.aws.amazon.com/ram/latest/userguide/what-is.html) in the Amazon Web Services Resource Access Manager guide.
    public struct SourceApiAssociation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the source API association.
        public var associationArn: Swift.String?
        /// The ID generated by the AppSync service for the source API association.
        public var associationId: Swift.String?
        /// The description field.
        public var description: Swift.String?
        /// The datetime value of the last successful merge of the source API association. The result will be in UTC format and your local time zone.
        public var lastSuccessfulMergeDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the AppSync Merged API.
        public var mergedApiArn: Swift.String?
        /// The ID of the AppSync Merged API.
        public var mergedApiId: Swift.String?
        /// The Amazon Resource Name (ARN) of the AppSync source API.
        public var sourceApiArn: Swift.String?
        /// The SourceApiAssociationConfig object data.
        public var sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig?
        /// The state of the source API association.
        public var sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus?
        /// The detailed message related to the current state of the source API association.
        public var sourceApiAssociationStatusDetail: Swift.String?
        /// The ID of the AppSync source API.
        public var sourceApiId: Swift.String?

        public init(
            associationArn: Swift.String? = nil,
            associationId: Swift.String? = nil,
            description: Swift.String? = nil,
            lastSuccessfulMergeDate: ClientRuntime.Date? = nil,
            mergedApiArn: Swift.String? = nil,
            mergedApiId: Swift.String? = nil,
            sourceApiArn: Swift.String? = nil,
            sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig? = nil,
            sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus? = nil,
            sourceApiAssociationStatusDetail: Swift.String? = nil,
            sourceApiId: Swift.String? = nil
        )
        {
            self.associationArn = associationArn
            self.associationId = associationId
            self.description = description
            self.lastSuccessfulMergeDate = lastSuccessfulMergeDate
            self.mergedApiArn = mergedApiArn
            self.mergedApiId = mergedApiId
            self.sourceApiArn = sourceApiArn
            self.sourceApiAssociationConfig = sourceApiAssociationConfig
            self.sourceApiAssociationStatus = sourceApiAssociationStatus
            self.sourceApiAssociationStatusDetail = sourceApiAssociationStatusDetail
            self.sourceApiId = sourceApiId
        }
    }

}

extension AppSyncClientTypes.SourceApiAssociationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mergeType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mergeType = self.mergeType {
            try encodeContainer.encode(mergeType.rawValue, forKey: .mergeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergeTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.MergeType.self, forKey: .mergeType)
        mergeType = mergeTypeDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes properties used to specify configurations related to a source API.
    public struct SourceApiAssociationConfig: Swift.Equatable {
        /// The property that indicates which merging option is enabled in the source API association. Valid merge types are MANUAL_MERGE (default) and AUTO_MERGE. Manual merges are the default behavior and require the user to trigger any changes from the source APIs to the merged API manually. Auto merges subscribe the merged API to the changes performed on the source APIs so that any change in the source APIs are also made to the merged API. Auto merges use MergedApiExecutionRoleArn to perform merge operations.
        public var mergeType: AppSyncClientTypes.MergeType?

        public init(
            mergeType: AppSyncClientTypes.MergeType? = nil
        )
        {
            self.mergeType = mergeType
        }
    }

}

extension AppSyncClientTypes {
    public enum SourceApiAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case autoMergeScheduleFailed
        case deletionFailed
        case deletionInProgress
        case deletionScheduled
        case mergeFailed
        case mergeInProgress
        case mergeScheduled
        case mergeSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceApiAssociationStatus] {
            return [
                .autoMergeScheduleFailed,
                .deletionFailed,
                .deletionInProgress,
                .deletionScheduled,
                .mergeFailed,
                .mergeInProgress,
                .mergeScheduled,
                .mergeSuccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .autoMergeScheduleFailed: return "AUTO_MERGE_SCHEDULE_FAILED"
            case .deletionFailed: return "DELETION_FAILED"
            case .deletionInProgress: return "DELETION_IN_PROGRESS"
            case .deletionScheduled: return "DELETION_SCHEDULED"
            case .mergeFailed: return "MERGE_FAILED"
            case .mergeInProgress: return "MERGE_IN_PROGRESS"
            case .mergeScheduled: return "MERGE_SCHEDULED"
            case .mergeSuccess: return "MERGE_SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceApiAssociationStatus(rawValue: rawValue) ?? SourceApiAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppSyncClientTypes.SourceApiAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationArn
        case associationId
        case description
        case mergedApiArn
        case mergedApiId
        case sourceApiArn
        case sourceApiId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationArn = self.associationArn {
            try encodeContainer.encode(associationArn, forKey: .associationArn)
        }
        if let associationId = self.associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mergedApiArn = self.mergedApiArn {
            try encodeContainer.encode(mergedApiArn, forKey: .mergedApiArn)
        }
        if let mergedApiId = self.mergedApiId {
            try encodeContainer.encode(mergedApiId, forKey: .mergedApiId)
        }
        if let sourceApiArn = self.sourceApiArn {
            try encodeContainer.encode(sourceApiArn, forKey: .sourceApiArn)
        }
        if let sourceApiId = self.sourceApiId {
            try encodeContainer.encode(sourceApiId, forKey: .sourceApiId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationArn)
        associationArn = associationArnDecoded
        let sourceApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceApiId)
        sourceApiId = sourceApiIdDecoded
        let sourceApiArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceApiArn)
        sourceApiArn = sourceApiArnDecoded
        let mergedApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergedApiId)
        mergedApiId = mergedApiIdDecoded
        let mergedApiArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergedApiArn)
        mergedApiArn = mergedApiArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes the ARNs and IDs of associations, Merged APIs, and source APIs.
    public struct SourceApiAssociationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the source API association.
        public var associationArn: Swift.String?
        /// The ID generated by the AppSync service for the source API association.
        public var associationId: Swift.String?
        /// The description field.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the AppSync Merged API.
        public var mergedApiArn: Swift.String?
        /// The ID of the AppSync Merged API.
        public var mergedApiId: Swift.String?
        /// The Amazon Resource Name (ARN) of the AppSync Source API.
        public var sourceApiArn: Swift.String?
        /// The ID of the AppSync source API.
        public var sourceApiId: Swift.String?

        public init(
            associationArn: Swift.String? = nil,
            associationId: Swift.String? = nil,
            description: Swift.String? = nil,
            mergedApiArn: Swift.String? = nil,
            mergedApiId: Swift.String? = nil,
            sourceApiArn: Swift.String? = nil,
            sourceApiId: Swift.String? = nil
        )
        {
            self.associationArn = associationArn
            self.associationId = associationId
            self.description = description
            self.mergedApiArn = mergedApiArn
            self.mergedApiId = mergedApiId
            self.sourceApiArn = sourceApiArn
            self.sourceApiId = sourceApiId
        }
    }

}

extension StartSchemaCreationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition.base64EncodedString(), forKey: .definition)
        }
    }
}

extension StartSchemaCreationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/schemacreation"
    }
}

public struct StartSchemaCreationInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The schema definition, in GraphQL schema language format.
    /// This member is required.
    public var definition: ClientRuntime.Data?

    public init(
        apiId: Swift.String? = nil,
        definition: ClientRuntime.Data? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
    }
}

struct StartSchemaCreationInputBody: Swift.Equatable {
    let definition: ClientRuntime.Data?
}

extension StartSchemaCreationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension StartSchemaCreationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSchemaCreationOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct StartSchemaCreationOutput: Swift.Equatable {
    /// The current state of the schema (PROCESSING, FAILED, SUCCESS, or NOT_APPLICABLE). When the schema is in the ACTIVE state, you can add data.
    public var status: AppSyncClientTypes.SchemaStatus?

    public init(
        status: AppSyncClientTypes.SchemaStatus? = nil
    )
    {
        self.status = status
    }
}

struct StartSchemaCreationOutputBody: Swift.Equatable {
    let status: AppSyncClientTypes.SchemaStatus?
}

extension StartSchemaCreationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SchemaStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum StartSchemaCreationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartSchemaMergeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mergedApiIdentifier = mergedApiIdentifier else {
            return nil
        }
        guard let associationId = associationId else {
            return nil
        }
        return "/v1/mergedApis/\(mergedApiIdentifier.urlPercentEncoding())/sourceApiAssociations/\(associationId.urlPercentEncoding())/merge"
    }
}

public struct StartSchemaMergeInput: Swift.Equatable {
    /// The ID generated by the AppSync service for the source API association.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
    /// This member is required.
    public var mergedApiIdentifier: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        mergedApiIdentifier: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.mergedApiIdentifier = mergedApiIdentifier
    }
}

struct StartSchemaMergeInputBody: Swift.Equatable {
}

extension StartSchemaMergeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartSchemaMergeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSchemaMergeOutputBody = try responseDecoder.decode(responseBody: data)
            self.sourceApiAssociationStatus = output.sourceApiAssociationStatus
        } else {
            self.sourceApiAssociationStatus = nil
        }
    }
}

public struct StartSchemaMergeOutput: Swift.Equatable {
    /// The state of the source API association.
    public var sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus?

    public init(
        sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus? = nil
    )
    {
        self.sourceApiAssociationStatus = sourceApiAssociationStatus
    }
}

struct StartSchemaMergeOutputBody: Swift.Equatable {
    let sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus?
}

extension StartSchemaMergeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceApiAssociationStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceApiAssociationStatusDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SourceApiAssociationStatus.self, forKey: .sourceApiAssociationStatus)
        sourceApiAssociationStatus = sourceApiAssociationStatusDecoded
    }
}

enum StartSchemaMergeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppSyncClientTypes.SyncConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictDetection
        case conflictHandler
        case lambdaConflictHandlerConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetection = self.conflictDetection {
            try encodeContainer.encode(conflictDetection.rawValue, forKey: .conflictDetection)
        }
        if let conflictHandler = self.conflictHandler {
            try encodeContainer.encode(conflictHandler.rawValue, forKey: .conflictHandler)
        }
        if let lambdaConflictHandlerConfig = self.lambdaConflictHandlerConfig {
            try encodeContainer.encode(lambdaConflictHandlerConfig, forKey: .lambdaConflictHandlerConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictHandlerDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ConflictHandlerType.self, forKey: .conflictHandler)
        conflictHandler = conflictHandlerDecoded
        let conflictDetectionDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ConflictDetectionType.self, forKey: .conflictDetection)
        conflictDetection = conflictDetectionDecoded
        let lambdaConflictHandlerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaConflictHandlerConfig.self, forKey: .lambdaConflictHandlerConfig)
        lambdaConflictHandlerConfig = lambdaConflictHandlerConfigDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes a Sync configuration for a resolver. Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.
    public struct SyncConfig: Swift.Equatable {
        /// The Conflict Detection strategy to use.
        ///
        /// * VERSION: Detect conflicts based on object versions for this resolver.
        ///
        /// * NONE: Do not detect conflicts when invoking this resolver.
        public var conflictDetection: AppSyncClientTypes.ConflictDetectionType?
        /// The Conflict Resolution strategy to perform in the event of a conflict.
        ///
        /// * OPTIMISTIC_CONCURRENCY: Resolve conflicts by rejecting mutations when versions don't match the latest version at the server.
        ///
        /// * AUTOMERGE: Resolve conflicts with the Automerge conflict resolution strategy.
        ///
        /// * LAMBDA: Resolve conflicts with an Lambda function supplied in the LambdaConflictHandlerConfig.
        public var conflictHandler: AppSyncClientTypes.ConflictHandlerType?
        /// The LambdaConflictHandlerConfig when configuring LAMBDA as the Conflict Handler.
        public var lambdaConflictHandlerConfig: AppSyncClientTypes.LambdaConflictHandlerConfig?

        public init(
            conflictDetection: AppSyncClientTypes.ConflictDetectionType? = nil,
            conflictHandler: AppSyncClientTypes.ConflictHandlerType? = nil,
            lambdaConflictHandlerConfig: AppSyncClientTypes.LambdaConflictHandlerConfig? = nil
        )
        {
            self.conflictDetection = conflictDetection
            self.conflictHandler = conflictHandler
            self.lambdaConflictHandlerConfig = lambdaConflictHandlerConfig
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The GraphqlApi Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A TagMap object.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppSyncClientTypes {
    /// Describes a type.
    public struct ModelType: Swift.Equatable {
        /// The type Amazon Resource Name (ARN).
        public var arn: Swift.String?
        /// The type definition.
        public var definition: Swift.String?
        /// The type description.
        public var description: Swift.String?
        /// The type format: SDL or JSON.
        public var format: AppSyncClientTypes.TypeDefinitionFormat?
        /// The type name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            definition: Swift.String? = nil,
            description: Swift.String? = nil,
            format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.definition = definition
            self.description = description
            self.format = format
            self.name = name
        }
    }

}

extension AppSyncClientTypes {
    public enum TypeDefinitionFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case sdl
        case sdkUnknown(Swift.String)

        public static var allCases: [TypeDefinitionFormat] {
            return [
                .json,
                .sdl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .sdl: return "SDL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TypeDefinitionFormat(rawValue: rawValue) ?? TypeDefinitionFormat.sdkUnknown(rawValue)
        }
    }
}

extension UnauthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You aren't authorized to perform this operation.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The GraphqlApi Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of TagKey objects.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApiCacheInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case ttl
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCachingBehavior = self.apiCachingBehavior {
            try encodeContainer.encode(apiCachingBehavior.rawValue, forKey: .apiCachingBehavior)
        }
        if let ttl = self.ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateApiCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches/update"
    }
}

/// Represents the input of a UpdateApiCache operation.
public struct UpdateApiCacheInput: Swift.Equatable {
    /// Caching behavior.
    ///
    /// * FULL_REQUEST_CACHING: All requests are fully cached.
    ///
    /// * PER_RESOLVER_CACHING: Individual resolvers that you specify are cached.
    /// This member is required.
    public var apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// TTL in seconds for cache entries. Valid values are 1â€“3,600 seconds.
    /// This member is required.
    public var ttl: Swift.Int?
    /// The cache instance type. Valid values are
    ///
    /// * SMALL
    ///
    /// * MEDIUM
    ///
    /// * LARGE
    ///
    /// * XLARGE
    ///
    /// * LARGE_2X
    ///
    /// * LARGE_4X
    ///
    /// * LARGE_8X (not available in all regions)
    ///
    /// * LARGE_12X
    ///
    ///
    /// Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used. The following legacy instance types are available, but their use is discouraged:
    ///
    /// * T2_SMALL: A t2.small instance type.
    ///
    /// * T2_MEDIUM: A t2.medium instance type.
    ///
    /// * R4_LARGE: A r4.large instance type.
    ///
    /// * R4_XLARGE: A r4.xlarge instance type.
    ///
    /// * R4_2XLARGE: A r4.2xlarge instance type.
    ///
    /// * R4_4XLARGE: A r4.4xlarge instance type.
    ///
    /// * R4_8XLARGE: A r4.8xlarge instance type.
    /// This member is required.
    public var type: AppSyncClientTypes.ApiCacheType?

    public init(
        apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior? = nil,
        apiId: Swift.String? = nil,
        ttl: Swift.Int? = nil,
        type: AppSyncClientTypes.ApiCacheType? = nil
    )
    {
        self.apiCachingBehavior = apiCachingBehavior
        self.apiId = apiId
        self.ttl = ttl
        self.type = type
    }
}

struct UpdateApiCacheInputBody: Swift.Equatable {
    let ttl: Swift.Int?
    let apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
    let type: AppSyncClientTypes.ApiCacheType?
}

extension UpdateApiCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCachingBehavior
        case ttl
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ttl)
        ttl = ttlDecoded
        let apiCachingBehaviorDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCachingBehavior.self, forKey: .apiCachingBehavior)
        apiCachingBehavior = apiCachingBehaviorDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCacheType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UpdateApiCacheOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApiCacheOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiCache = output.apiCache
        } else {
            self.apiCache = nil
        }
    }
}

/// Represents the output of a UpdateApiCache operation.
public struct UpdateApiCacheOutput: Swift.Equatable {
    /// The ApiCache object.
    public var apiCache: AppSyncClientTypes.ApiCache?

    public init(
        apiCache: AppSyncClientTypes.ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

struct UpdateApiCacheOutputBody: Swift.Equatable {
    let apiCache: AppSyncClientTypes.ApiCache?
}

extension UpdateApiCacheOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCache
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCacheDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiCache.self, forKey: .apiCache)
        apiCache = apiCacheDecoded
    }
}

enum UpdateApiCacheOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApiKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expires
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expires = self.expires {
            try encodeContainer.encode(expires, forKey: .expires)
        }
    }
}

extension UpdateApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/apikeys/\(id.urlPercentEncoding())"
    }
}

public struct UpdateApiKeyInput: Swift.Equatable {
    /// The ID for the GraphQL API.
    /// This member is required.
    public var apiId: Swift.String?
    /// A description of the purpose of the API key.
    public var description: Swift.String?
    /// From the update time, the time after which the API key expires. The date is represented as seconds since the epoch. For more information, see .
    public var expires: Swift.Int?
    /// The API key ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        expires: Swift.Int? = nil,
        id: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.expires = expires
        self.id = id
    }
}

struct UpdateApiKeyInputBody: Swift.Equatable {
    let description: Swift.String?
    let expires: Swift.Int?
}

extension UpdateApiKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expires
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expiresDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expires)
        expires = expiresDecoded
    }
}

extension UpdateApiKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApiKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiKey = output.apiKey
        } else {
            self.apiKey = nil
        }
    }
}

public struct UpdateApiKeyOutput: Swift.Equatable {
    /// The API key.
    public var apiKey: AppSyncClientTypes.ApiKey?

    public init(
        apiKey: AppSyncClientTypes.ApiKey? = nil
    )
    {
        self.apiKey = apiKey
    }
}

struct UpdateApiKeyOutputBody: Swift.Equatable {
    let apiKey: AppSyncClientTypes.ApiKey?
}

extension UpdateApiKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ApiKey.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
    }
}

enum UpdateApiKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ApiKeyValidityOutOfBoundsException": return try await ApiKeyValidityOutOfBoundsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case eventBridgeConfig
        case httpConfig
        case lambdaConfig
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dynamodbConfig = self.dynamodbConfig {
            try encodeContainer.encode(dynamodbConfig, forKey: .dynamodbConfig)
        }
        if let elasticsearchConfig = self.elasticsearchConfig {
            try encodeContainer.encode(elasticsearchConfig, forKey: .elasticsearchConfig)
        }
        if let eventBridgeConfig = self.eventBridgeConfig {
            try encodeContainer.encode(eventBridgeConfig, forKey: .eventBridgeConfig)
        }
        if let httpConfig = self.httpConfig {
            try encodeContainer.encode(httpConfig, forKey: .httpConfig)
        }
        if let lambdaConfig = self.lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let openSearchServiceConfig = self.openSearchServiceConfig {
            try encodeContainer.encode(openSearchServiceConfig, forKey: .openSearchServiceConfig)
        }
        if let relationalDatabaseConfig = self.relationalDatabaseConfig {
            try encodeContainer.encode(relationalDatabaseConfig, forKey: .relationalDatabaseConfig)
        }
        if let serviceRoleArn = self.serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources/\(name.urlPercentEncoding())"
    }
}

public struct UpdateDataSourceInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The new description for the data source.
    public var description: Swift.String?
    /// The new Amazon DynamoDB configuration.
    public var dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
    /// The new OpenSearch configuration. As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. Instead, use [UpdateDataSourceRequest$openSearchServiceConfig] to update an OpenSearch data source.
    public var elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
    /// The new Amazon EventBridge settings.
    public var eventBridgeConfig: AppSyncClientTypes.EventBridgeDataSourceConfig?
    /// The new HTTP endpoint configuration.
    public var httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
    /// The new Lambda configuration.
    public var lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
    /// The new name for the data source.
    /// This member is required.
    public var name: Swift.String?
    /// The new OpenSearch configuration.
    public var openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
    /// The new relational database configuration.
    public var relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
    /// The new service role Amazon Resource Name (ARN) for the data source.
    public var serviceRoleArn: Swift.String?
    /// The new data source type.
    /// This member is required.
    public var type: AppSyncClientTypes.DataSourceType?

    public init(
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig? = nil,
        elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig? = nil,
        eventBridgeConfig: AppSyncClientTypes.EventBridgeDataSourceConfig? = nil,
        httpConfig: AppSyncClientTypes.HttpDataSourceConfig? = nil,
        lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig? = nil,
        name: Swift.String? = nil,
        openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig? = nil,
        relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig? = nil,
        serviceRoleArn: Swift.String? = nil,
        type: AppSyncClientTypes.DataSourceType? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.dynamodbConfig = dynamodbConfig
        self.elasticsearchConfig = elasticsearchConfig
        self.eventBridgeConfig = eventBridgeConfig
        self.httpConfig = httpConfig
        self.lambdaConfig = lambdaConfig
        self.name = name
        self.openSearchServiceConfig = openSearchServiceConfig
        self.relationalDatabaseConfig = relationalDatabaseConfig
        self.serviceRoleArn = serviceRoleArn
        self.type = type
    }
}

struct UpdateDataSourceInputBody: Swift.Equatable {
    let description: Swift.String?
    let type: AppSyncClientTypes.DataSourceType?
    let serviceRoleArn: Swift.String?
    let dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
    let lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
    let elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
    let openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
    let httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
    let relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
    let eventBridgeConfig: AppSyncClientTypes.EventBridgeDataSourceConfig?
}

extension UpdateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case eventBridgeConfig
        case httpConfig
        case lambdaConfig
        case openSearchServiceConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let dynamodbConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DynamodbDataSourceConfig.self, forKey: .dynamodbConfig)
        dynamodbConfig = dynamodbConfigDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaDataSourceConfig.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let elasticsearchConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ElasticsearchDataSourceConfig.self, forKey: .elasticsearchConfig)
        elasticsearchConfig = elasticsearchConfigDecoded
        let openSearchServiceConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenSearchServiceDataSourceConfig.self, forKey: .openSearchServiceConfig)
        openSearchServiceConfig = openSearchServiceConfigDecoded
        let httpConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.HttpDataSourceConfig.self, forKey: .httpConfig)
        httpConfig = httpConfigDecoded
        let relationalDatabaseConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.RelationalDatabaseDataSourceConfig.self, forKey: .relationalDatabaseConfig)
        relationalDatabaseConfig = relationalDatabaseConfigDecoded
        let eventBridgeConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.EventBridgeDataSourceConfig.self, forKey: .eventBridgeConfig)
        eventBridgeConfig = eventBridgeConfigDecoded
    }
}

extension UpdateDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct UpdateDataSourceOutput: Swift.Equatable {
    /// The updated DataSource object.
    public var dataSource: AppSyncClientTypes.DataSource?

    public init(
        dataSource: AppSyncClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct UpdateDataSourceOutputBody: Swift.Equatable {
    let dataSource: AppSyncClientTypes.DataSource?
}

extension UpdateDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

enum UpdateDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDomainNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v1/domainnames/\(domainName.urlPercentEncoding())"
    }
}

public struct UpdateDomainNameInput: Swift.Equatable {
    /// A description of the DomainName.
    public var description: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.description = description
        self.domainName = domainName
    }
}

struct UpdateDomainNameInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateDomainNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDomainNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDomainNameOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainNameConfig = output.domainNameConfig
        } else {
            self.domainNameConfig = nil
        }
    }
}

public struct UpdateDomainNameOutput: Swift.Equatable {
    /// The configuration for the DomainName.
    public var domainNameConfig: AppSyncClientTypes.DomainNameConfig?

    public init(
        domainNameConfig: AppSyncClientTypes.DomainNameConfig? = nil
    )
    {
        self.domainNameConfig = domainNameConfig
    }
}

struct UpdateDomainNameOutputBody: Swift.Equatable {
    let domainNameConfig: AppSyncClientTypes.DomainNameConfig?
}

extension UpdateDomainNameOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNameConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DomainNameConfig.self, forKey: .domainNameConfig)
        domainNameConfig = domainNameConfigDecoded
    }
}

enum UpdateDomainNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFunctionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case dataSourceName
        case description
        case functionVersion
        case maxBatchSize
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case runtime
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let dataSourceName = self.dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = self.functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let maxBatchSize = self.maxBatchSize {
            try encodeContainer.encode(maxBatchSize, forKey: .maxBatchSize)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestMappingTemplate = self.requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = self.responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime, forKey: .runtime)
        }
        if let syncConfig = self.syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

extension UpdateFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let functionId = functionId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())"
    }
}

public struct UpdateFunctionInput: Swift.Equatable {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
    public var code: Swift.String?
    /// The FunctionDataSource name.
    /// This member is required.
    public var dataSourceName: Swift.String?
    /// The Function description.
    public var description: Swift.String?
    /// The function ID.
    /// This member is required.
    public var functionId: Swift.String?
    /// The version of the request mapping template. Currently, the supported value is 2018-05-29. Note that when using VTL and mapping templates, the functionVersion is required.
    public var functionVersion: Swift.String?
    /// The maximum batching size for a resolver.
    public var maxBatchSize: Swift.Int?
    /// The Function name.
    /// This member is required.
    public var name: Swift.String?
    /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
    public var requestMappingTemplate: Swift.String?
    /// The Function request mapping template.
    public var responseMappingTemplate: Swift.String?
    /// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
    public var runtime: AppSyncClientTypes.AppSyncRuntime?
    /// Describes a Sync configuration for a resolver. Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.
    public var syncConfig: AppSyncClientTypes.SyncConfig?

    public init(
        apiId: Swift.String? = nil,
        code: Swift.String? = nil,
        dataSourceName: Swift.String? = nil,
        description: Swift.String? = nil,
        functionId: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        maxBatchSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        runtime: AppSyncClientTypes.AppSyncRuntime? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil
    )
    {
        self.apiId = apiId
        self.code = code
        self.dataSourceName = dataSourceName
        self.description = description
        self.functionId = functionId
        self.functionVersion = functionVersion
        self.maxBatchSize = maxBatchSize
        self.name = name
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.runtime = runtime
        self.syncConfig = syncConfig
    }
}

struct UpdateFunctionInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let dataSourceName: Swift.String?
    let requestMappingTemplate: Swift.String?
    let responseMappingTemplate: Swift.String?
    let functionVersion: Swift.String?
    let syncConfig: AppSyncClientTypes.SyncConfig?
    let maxBatchSize: Swift.Int?
    let runtime: AppSyncClientTypes.AppSyncRuntime?
    let code: Swift.String?
}

extension UpdateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case dataSourceName
        case description
        case functionVersion
        case maxBatchSize
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case runtime
        case syncConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let maxBatchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBatchSize)
        maxBatchSize = maxBatchSizeDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AppSyncRuntime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UpdateFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFunctionOutputBody = try responseDecoder.decode(responseBody: data)
            self.functionConfiguration = output.functionConfiguration
        } else {
            self.functionConfiguration = nil
        }
    }
}

public struct UpdateFunctionOutput: Swift.Equatable {
    /// The Function object.
    public var functionConfiguration: AppSyncClientTypes.FunctionConfiguration?

    public init(
        functionConfiguration: AppSyncClientTypes.FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

struct UpdateFunctionOutputBody: Swift.Equatable {
    let functionConfiguration: AppSyncClientTypes.FunctionConfiguration?
}

extension UpdateFunctionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
    }
}

enum UpdateFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGraphqlApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case authenticationType
        case lambdaAuthorizerConfig
        case logConfig
        case mergedApiExecutionRoleArn
        case name
        case openIDConnectConfig
        case ownerContact
        case userPoolConfig
        case xrayEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthenticationProviders = additionalAuthenticationProviders {
            var additionalAuthenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthenticationProviders)
            for additionalauthenticationprovider0 in additionalAuthenticationProviders {
                try additionalAuthenticationProvidersContainer.encode(additionalauthenticationprovider0)
            }
        }
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let lambdaAuthorizerConfig = self.lambdaAuthorizerConfig {
            try encodeContainer.encode(lambdaAuthorizerConfig, forKey: .lambdaAuthorizerConfig)
        }
        if let logConfig = self.logConfig {
            try encodeContainer.encode(logConfig, forKey: .logConfig)
        }
        if let mergedApiExecutionRoleArn = self.mergedApiExecutionRoleArn {
            try encodeContainer.encode(mergedApiExecutionRoleArn, forKey: .mergedApiExecutionRoleArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openIDConnectConfig = self.openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let ownerContact = self.ownerContact {
            try encodeContainer.encode(ownerContact, forKey: .ownerContact)
        }
        if let userPoolConfig = self.userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
        if let xrayEnabled = self.xrayEnabled {
            try encodeContainer.encode(xrayEnabled, forKey: .xrayEnabled)
        }
    }
}

extension UpdateGraphqlApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())"
    }
}

public struct UpdateGraphqlApiInput: Swift.Equatable {
    /// A list of additional authentication providers for the GraphqlApi API.
    public var additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The new authentication type for the GraphqlApi object.
    public var authenticationType: AppSyncClientTypes.AuthenticationType?
    /// Configuration for Lambda function authorization.
    public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
    /// The Amazon CloudWatch Logs configuration for the GraphqlApi object.
    public var logConfig: AppSyncClientTypes.LogConfig?
    /// The Identity and Access Management service role ARN for a merged API. The AppSync service assumes this role on behalf of the Merged API to validate access to source APIs at runtime and to prompt the AUTO_MERGE to update the merged API endpoint with the source API changes automatically.
    public var mergedApiExecutionRoleArn: Swift.String?
    /// The new name for the GraphqlApi object.
    /// This member is required.
    public var name: Swift.String?
    /// The OpenID Connect configuration for the GraphqlApi object.
    public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
    /// The owner contact information for an API resource. This field accepts any string input with a length of 0 - 256 characters.
    public var ownerContact: Swift.String?
    /// The new Amazon Cognito user pool configuration for the ~GraphqlApi object.
    public var userPoolConfig: AppSyncClientTypes.UserPoolConfig?
    /// A flag indicating whether to use X-Ray tracing for the GraphqlApi.
    public var xrayEnabled: Swift.Bool?

    public init(
        additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil,
        apiId: Swift.String? = nil,
        authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
        lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
        logConfig: AppSyncClientTypes.LogConfig? = nil,
        mergedApiExecutionRoleArn: Swift.String? = nil,
        name: Swift.String? = nil,
        openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
        ownerContact: Swift.String? = nil,
        userPoolConfig: AppSyncClientTypes.UserPoolConfig? = nil,
        xrayEnabled: Swift.Bool? = nil
    )
    {
        self.additionalAuthenticationProviders = additionalAuthenticationProviders
        self.apiId = apiId
        self.authenticationType = authenticationType
        self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
        self.logConfig = logConfig
        self.mergedApiExecutionRoleArn = mergedApiExecutionRoleArn
        self.name = name
        self.openIDConnectConfig = openIDConnectConfig
        self.ownerContact = ownerContact
        self.userPoolConfig = userPoolConfig
        self.xrayEnabled = xrayEnabled
    }
}

struct UpdateGraphqlApiInputBody: Swift.Equatable {
    let name: Swift.String?
    let logConfig: AppSyncClientTypes.LogConfig?
    let authenticationType: AppSyncClientTypes.AuthenticationType?
    let userPoolConfig: AppSyncClientTypes.UserPoolConfig?
    let openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
    let additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
    let xrayEnabled: Swift.Bool?
    let lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
    let mergedApiExecutionRoleArn: Swift.String?
    let ownerContact: Swift.String?
}

extension UpdateGraphqlApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthenticationProviders
        case authenticationType
        case lambdaAuthorizerConfig
        case logConfig
        case mergedApiExecutionRoleArn
        case name
        case openIDConnectConfig
        case ownerContact
        case userPoolConfig
        case xrayEnabled
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let logConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LogConfig.self, forKey: .logConfig)
        logConfig = logConfigDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.UserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let additionalAuthenticationProvidersContainer = try containerValues.decodeIfPresent([AppSyncClientTypes.AdditionalAuthenticationProvider?].self, forKey: .additionalAuthenticationProviders)
        var additionalAuthenticationProvidersDecoded0:[AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil
        if let additionalAuthenticationProvidersContainer = additionalAuthenticationProvidersContainer {
            additionalAuthenticationProvidersDecoded0 = [AppSyncClientTypes.AdditionalAuthenticationProvider]()
            for structure0 in additionalAuthenticationProvidersContainer {
                if let structure0 = structure0 {
                    additionalAuthenticationProvidersDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthenticationProviders = additionalAuthenticationProvidersDecoded0
        let xrayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .xrayEnabled)
        xrayEnabled = xrayEnabledDecoded
        let lambdaAuthorizerConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.LambdaAuthorizerConfig.self, forKey: .lambdaAuthorizerConfig)
        lambdaAuthorizerConfig = lambdaAuthorizerConfigDecoded
        let mergedApiExecutionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergedApiExecutionRoleArn)
        mergedApiExecutionRoleArn = mergedApiExecutionRoleArnDecoded
        let ownerContactDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerContact)
        ownerContact = ownerContactDecoded
    }
}

extension UpdateGraphqlApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGraphqlApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.graphqlApi = output.graphqlApi
        } else {
            self.graphqlApi = nil
        }
    }
}

public struct UpdateGraphqlApiOutput: Swift.Equatable {
    /// The updated GraphqlApi object.
    public var graphqlApi: AppSyncClientTypes.GraphqlApi?

    public init(
        graphqlApi: AppSyncClientTypes.GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

struct UpdateGraphqlApiOutputBody: Swift.Equatable {
    let graphqlApi: AppSyncClientTypes.GraphqlApi?
}

extension UpdateGraphqlApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphqlApi
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApiDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.GraphqlApi.self, forKey: .graphqlApi)
        graphqlApi = graphqlApiDecoded
    }
}

enum UpdateGraphqlApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResolverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case code
        case dataSourceName
        case kind
        case maxBatchSize
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case runtime
        case syncConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingConfig = self.cachingConfig {
            try encodeContainer.encode(cachingConfig, forKey: .cachingConfig)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let dataSourceName = self.dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let kind = self.kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let maxBatchSize = self.maxBatchSize {
            try encodeContainer.encode(maxBatchSize, forKey: .maxBatchSize)
        }
        if let pipelineConfig = self.pipelineConfig {
            try encodeContainer.encode(pipelineConfig, forKey: .pipelineConfig)
        }
        if let requestMappingTemplate = self.requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = self.responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime, forKey: .runtime)
        }
        if let syncConfig = self.syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

extension UpdateResolverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        guard let fieldName = fieldName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers/\(fieldName.urlPercentEncoding())"
    }
}

public struct UpdateResolverInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The caching configuration for the resolver.
    public var cachingConfig: AppSyncClientTypes.CachingConfig?
    /// The resolver code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
    public var code: Swift.String?
    /// The new data source name.
    public var dataSourceName: Swift.String?
    /// The new field name.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The resolver type.
    ///
    /// * UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.
    ///
    /// * PIPELINE: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of Function objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.
    public var kind: AppSyncClientTypes.ResolverKind?
    /// The maximum batching size for a resolver.
    public var maxBatchSize: Swift.Int?
    /// The PipelineConfig.
    public var pipelineConfig: AppSyncClientTypes.PipelineConfig?
    /// The new request mapping template. A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL). VTL request mapping templates are optional when using an Lambda data source. For all other data sources, VTL request and response mapping templates are required.
    public var requestMappingTemplate: Swift.String?
    /// The new response mapping template.
    public var responseMappingTemplate: Swift.String?
    /// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
    public var runtime: AppSyncClientTypes.AppSyncRuntime?
    /// The SyncConfig for a resolver attached to a versioned data source.
    public var syncConfig: AppSyncClientTypes.SyncConfig?
    /// The new type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        cachingConfig: AppSyncClientTypes.CachingConfig? = nil,
        code: Swift.String? = nil,
        dataSourceName: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        kind: AppSyncClientTypes.ResolverKind? = nil,
        maxBatchSize: Swift.Int? = nil,
        pipelineConfig: AppSyncClientTypes.PipelineConfig? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        runtime: AppSyncClientTypes.AppSyncRuntime? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.cachingConfig = cachingConfig
        self.code = code
        self.dataSourceName = dataSourceName
        self.fieldName = fieldName
        self.kind = kind
        self.maxBatchSize = maxBatchSize
        self.pipelineConfig = pipelineConfig
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.runtime = runtime
        self.syncConfig = syncConfig
        self.typeName = typeName
    }
}

struct UpdateResolverInputBody: Swift.Equatable {
    let dataSourceName: Swift.String?
    let requestMappingTemplate: Swift.String?
    let responseMappingTemplate: Swift.String?
    let kind: AppSyncClientTypes.ResolverKind?
    let pipelineConfig: AppSyncClientTypes.PipelineConfig?
    let syncConfig: AppSyncClientTypes.SyncConfig?
    let cachingConfig: AppSyncClientTypes.CachingConfig?
    let maxBatchSize: Swift.Int?
    let runtime: AppSyncClientTypes.AppSyncRuntime?
    let code: Swift.String?
}

extension UpdateResolverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachingConfig
        case code
        case dataSourceName
        case kind
        case maxBatchSize
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case runtime
        case syncConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let kindDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ResolverKind.self, forKey: .kind)
        kind = kindDecoded
        let pipelineConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.PipelineConfig.self, forKey: .pipelineConfig)
        pipelineConfig = pipelineConfigDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let cachingConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.CachingConfig.self, forKey: .cachingConfig)
        cachingConfig = cachingConfigDecoded
        let maxBatchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBatchSize)
        maxBatchSize = maxBatchSizeDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.AppSyncRuntime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UpdateResolverOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateResolverOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolver = output.resolver
        } else {
            self.resolver = nil
        }
    }
}

public struct UpdateResolverOutput: Swift.Equatable {
    /// The updated Resolver object.
    public var resolver: AppSyncClientTypes.Resolver?

    public init(
        resolver: AppSyncClientTypes.Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

struct UpdateResolverOutputBody: Swift.Equatable {
    let resolver: AppSyncClientTypes.Resolver?
}

extension UpdateResolverOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolver
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.Resolver.self, forKey: .resolver)
        resolver = resolverDecoded
    }
}

enum UpdateResolverOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSourceApiAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case sourceApiAssociationConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sourceApiAssociationConfig = self.sourceApiAssociationConfig {
            try encodeContainer.encode(sourceApiAssociationConfig, forKey: .sourceApiAssociationConfig)
        }
    }
}

extension UpdateSourceApiAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mergedApiIdentifier = mergedApiIdentifier else {
            return nil
        }
        guard let associationId = associationId else {
            return nil
        }
        return "/v1/mergedApis/\(mergedApiIdentifier.urlPercentEncoding())/sourceApiAssociations/\(associationId.urlPercentEncoding())"
    }
}

public struct UpdateSourceApiAssociationInput: Swift.Equatable {
    /// The ID generated by the AppSync service for the source API association.
    /// This member is required.
    public var associationId: Swift.String?
    /// The description field.
    public var description: Swift.String?
    /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
    /// This member is required.
    public var mergedApiIdentifier: Swift.String?
    /// The SourceApiAssociationConfig object data.
    public var sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig?

    public init(
        associationId: Swift.String? = nil,
        description: Swift.String? = nil,
        mergedApiIdentifier: Swift.String? = nil,
        sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig? = nil
    )
    {
        self.associationId = associationId
        self.description = description
        self.mergedApiIdentifier = mergedApiIdentifier
        self.sourceApiAssociationConfig = sourceApiAssociationConfig
    }
}

struct UpdateSourceApiAssociationInputBody: Swift.Equatable {
    let description: Swift.String?
    let sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig?
}

extension UpdateSourceApiAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case sourceApiAssociationConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceApiAssociationConfigDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SourceApiAssociationConfig.self, forKey: .sourceApiAssociationConfig)
        sourceApiAssociationConfig = sourceApiAssociationConfigDecoded
    }
}

extension UpdateSourceApiAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSourceApiAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sourceApiAssociation = output.sourceApiAssociation
        } else {
            self.sourceApiAssociation = nil
        }
    }
}

public struct UpdateSourceApiAssociationOutput: Swift.Equatable {
    /// The SourceApiAssociation object data.
    public var sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation?

    public init(
        sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation? = nil
    )
    {
        self.sourceApiAssociation = sourceApiAssociation
    }
}

struct UpdateSourceApiAssociationOutputBody: Swift.Equatable {
    let sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation?
}

extension UpdateSourceApiAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceApiAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceApiAssociationDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.SourceApiAssociation.self, forKey: .sourceApiAssociation)
        sourceApiAssociation = sourceApiAssociationDecoded
    }
}

enum UpdateSourceApiAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case format
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
    }
}

extension UpdateTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let typeName = typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())"
    }
}

public struct UpdateTypeInput: Swift.Equatable {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The new definition.
    public var definition: Swift.String?
    /// The new type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?
    /// The new type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        definition: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
        self.format = format
        self.typeName = typeName
    }
}

struct UpdateTypeInputBody: Swift.Equatable {
    let definition: Swift.String?
    let format: AppSyncClientTypes.TypeDefinitionFormat?
}

extension UpdateTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case format
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.TypeDefinitionFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension UpdateTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.type = output.type
        } else {
            self.type = nil
        }
    }
}

public struct UpdateTypeOutput: Swift.Equatable {
    /// The updated Type object.
    public var type: AppSyncClientTypes.ModelType?

    public init(
        type: AppSyncClientTypes.ModelType? = nil
    )
    {
        self.type = type
    }
}

struct UpdateTypeOutputBody: Swift.Equatable {
    let type: AppSyncClientTypes.ModelType?
}

extension UpdateTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

enum UpdateTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppSyncClientTypes.UserPoolConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIdClientRegex
        case awsRegion
        case defaultAction
        case userPoolId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIdClientRegex = self.appIdClientRegex {
            try encodeContainer.encode(appIdClientRegex, forKey: .appIdClientRegex)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let defaultAction = self.defaultAction {
            try encodeContainer.encode(defaultAction.rawValue, forKey: .defaultAction)
        }
        if let userPoolId = self.userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(AppSyncClientTypes.DefaultAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let appIdClientRegexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appIdClientRegex)
        appIdClientRegex = appIdClientRegexDecoded
    }
}

extension AppSyncClientTypes {
    /// Describes an Amazon Cognito user pool configuration.
    public struct UserPoolConfig: Swift.Equatable {
        /// A regular expression for validating the incoming Amazon Cognito user pool app client ID. If this value isn't set, no filtering is applied.
        public var appIdClientRegex: Swift.String?
        /// The Amazon Web Services Region in which the user pool was created.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The action that you want your GraphQL API to take when a request that uses Amazon Cognito user pool authentication doesn't match the Amazon Cognito user pool configuration.
        /// This member is required.
        public var defaultAction: AppSyncClientTypes.DefaultAction?
        /// The user pool ID.
        /// This member is required.
        public var userPoolId: Swift.String?

        public init(
            appIdClientRegex: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            defaultAction: AppSyncClientTypes.DefaultAction? = nil,
            userPoolId: Swift.String? = nil
        )
        {
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.defaultAction = defaultAction
            self.userPoolId = userPoolId
        }
    }

}
